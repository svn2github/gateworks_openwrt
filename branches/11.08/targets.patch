Index: trunk/target/linux/ixp4xx/config-2.6.37
===================================================================
--- trunk/target/linux/ixp4xx/config-2.6.37	(revision 27590)
+++ trunk/target/linux/ixp4xx/config-2.6.37	(working copy)
@@ -17,7 +17,6 @@
 CONFIG_ARM_L1_CACHE_SHIFT=5
 # CONFIG_ARM_THUMB is not set
 # CONFIG_ARPD is not set
-CONFIG_BKL=y
 CONFIG_BOUNCE=y
 CONFIG_CMDLINE="root=/dev/mtdblock2 rootfstype=squashfs,jffs2 noinitrd console=ttyS0,115200"
 CONFIG_CPU_32v5=y
@@ -40,8 +39,6 @@
 CONFIG_DMABOUNCE=y
 CONFIG_DNOTIFY=y
 CONFIG_EEPROM_AT24=y
-# CONFIG_FPE_FASTFPE is not set
-# CONFIG_FPE_NWFPE is not set
 CONFIG_FRAME_POINTER=y
 CONFIG_GENERIC_ATOMIC64=y
 CONFIG_GENERIC_CLOCKEVENTS=y
@@ -137,7 +134,7 @@
 CONFIG_NEED_DMA_MAP_STATE=y
 CONFIG_NEED_PER_CPU_KM=y
 CONFIG_PAGEFLAGS_EXTENDED=y
-CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_PAGE_OFFSET=0x80000000
 CONFIG_PCI=y
 CONFIG_PERF_USE_VMALLOC=y
 CONFIG_PHYLIB=y
@@ -150,15 +147,19 @@
 CONFIG_RTC_DRV_X1205=y
 # CONFIG_SCSI_DMA is not set
 CONFIG_SENSORS_AD7418=y
+CONFIG_SENSORS_GSP=y
 CONFIG_SENSORS_MAX6650=y
 CONFIG_SENSORS_W83781D=y
-CONFIG_SERIAL_8250_NR_UARTS=4
-CONFIG_SERIAL_8250_RUNTIME_UARTS=4
+CONFIG_SERIAL_8250_NR_UARTS=20
+CONFIG_SERIAL_8250_PCI=y
+CONFIG_SERIAL_8250_RUNTIME_UARTS=20
 CONFIG_SPLIT_PTLOCK_CPUS=999999
 CONFIG_SYS_SUPPORTS_APM_EMULATION=y
 CONFIG_UID16=y
 CONFIG_USB_SUPPORT=y
 CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_VMSPLIT_2G=y
+# CONFIG_VMSPLIT_3G is not set
 CONFIG_VM_EVENT_COUNTERS=y
 CONFIG_WATCHDOG_NOWAYOUT=y
 CONFIG_XSCALE_PMU=y
Index: trunk/target/linux/ixp4xx/patches-2.6.37/301-avila_led.patch
===================================================================
--- trunk/target/linux/ixp4xx/patches-2.6.37/301-avila_led.patch	(revision 27590)
+++ trunk/target/linux/ixp4xx/patches-2.6.37/301-avila_led.patch	(working copy)
@@ -129,11 +129,12 @@
  }
  
  static void __init avila_gw2355_setup(void)
-@@ -222,11 +301,29 @@ static void __init avila_gw2355_setup(vo
+@@ -222,11 +301,30 @@ static void __init avila_gw2355_setup(vo
  
  	avila_npec_data.phy = 16;
  	platform_device_register(&avila_npec_device);
 +
++	avila_gpio_leds[0].gpio = AVILA_GW23X7_LED_USER_GPIO;
 +	platform_device_register(&avila_gpio_leds_device);
 +
 +	*IXP4XX_EXP_CS4 |= 0xbfff3c03;
Index: trunk/target/linux/ixp4xx/patches-2.6.37/506-gw2370_support.patch
===================================================================
--- trunk/target/linux/ixp4xx/patches-2.6.37/506-gw2370_support.patch	(revision 0)
+++ trunk/target/linux/ixp4xx/patches-2.6.37/506-gw2370_support.patch	(revision 0)
@@ -0,0 +1,89 @@
+--- a/arch/arm/mach-ixp4xx/avila-setup.c
++++ b/arch/arm/mach-ixp4xx/avila-setup.c
+@@ -493,14 +493,14 @@ static void __init avila_gw2365_setup(vo
+ 	avila_npec_data.phy = 2;
+ 	platform_device_register(&avila_npec_device);
+ 
+-	avila_pata_resources[0].start = IXP4XX_EXP_BUS_BASE(1);
+-	avila_pata_resources[0].end = IXP4XX_EXP_BUS_END(1);
++	avila_pata_resources[0].start = IXP4XX_EXP_BUS_BASE(2);
++	avila_pata_resources[0].end = IXP4XX_EXP_BUS_END(2);
+ 
+-	avila_pata_resources[1].start = IXP4XX_EXP_BUS_BASE(2);
+-	avila_pata_resources[1].end = IXP4XX_EXP_BUS_END(2);
++	avila_pata_resources[1].start = IXP4XX_EXP_BUS_BASE(3);
++	avila_pata_resources[1].end = IXP4XX_EXP_BUS_END(3);
+ 
+-	avila_pata_data.cs0_cfg = IXP4XX_EXP_CS1;
+-	avila_pata_data.cs1_cfg = IXP4XX_EXP_CS2;
++	avila_pata_data.cs0_cfg = IXP4XX_EXP_CS2;
++	avila_pata_data.cs1_cfg = IXP4XX_EXP_CS3;
+ 
+ 	platform_device_register(&avila_pata);
+ 
+@@ -518,6 +518,37 @@ static void __init avila_gw2369_setup(vo
+ 	platform_device_register(&avila_npec_device);
+ }
+ 
++static void __init avila_gw2370_setup(void)
++{
++	avila_npeb_data.phy = 5;
++	platform_device_register(&avila_npeb_device);
++
++	avila_npec_data.phy = IXP4XX_ETH_PHY_MAX_ADDR;
++	avila_npec_data.phy_mask = 0x1e; /* ports 1-4 of the KS8995 switch */
++	platform_device_register(&avila_npec_device);
++
++	*IXP4XX_EXP_CS2 = 0xBFFF3C43;
++	set_irq_type(IRQ_IXP4XX_GPIO2, IRQ_TYPE_EDGE_RISING);
++	avila_optional_uart_data[0].mapbase = 0x52000000;
++	avila_optional_uart_data[0].membase = (void __iomem *)ioremap(0x52000000, 0x0fff);
++	avila_optional_uart_data[0].irq   = IRQ_IXP4XX_GPIO2;
++
++	*IXP4XX_EXP_CS3 = 0xBFFF3C43;
++	set_irq_type(IRQ_IXP4XX_GPIO3, IRQ_TYPE_EDGE_RISING);
++	avila_optional_uart_data[1].mapbase = 0x53000000;
++	avila_optional_uart_data[1].membase = (void __iomem *)ioremap(0x53000000, 0x0fff);
++	avila_optional_uart_data[1].irq   = IRQ_IXP4XX_GPIO3;
++
++	avila_optional_uart.num_resources = 2;
++
++	platform_device_register(&avila_optional_uart);
++
++	avila_gpio_leds[0].gpio = 101;
++	platform_device_register(&avila_gpio_leds_device);
++}
++
++
++
+ static struct avila_board_info avila_boards[] __initdata = {
+ 	{
+ 		.model		= "GW2342",
+@@ -546,6 +577,9 @@ static struct avila_board_info avila_boa
+ 	}, {
+ 		.model		= "GW2369",
+ 		.setup		= avila_gw2369_setup,
++	}, {
++		.model		= "GW2370",
++		.setup		= avila_gw2370_setup,
+ 	}
+ };
+ 
+@@ -590,7 +624,7 @@ static void at24_setup(struct memory_acc
+ static struct at24_platform_data avila_eeprom_info = {
+ 	.byte_len	= 1024,
+ 	.page_size	= 16,
+-	.flags		= AT24_FLAG_READONLY,
++	//.flags		= AT24_FLAG_READONLY,
+ 	.setup		= at24_setup,
+ };
+ 
+@@ -628,7 +662,7 @@ static void __init avila_init(void)
+ 	 */
+ 	avila_flash_resource.start = IXP4XX_EXP_BUS_BASE(0);
+ 	avila_flash_resource.end =
+-		IXP4XX_EXP_BUS_BASE(0) + ixp4xx_exp_bus_size - 1;
++		IXP4XX_EXP_BUS_BASE(0) + (2 * ixp4xx_exp_bus_size) - 1;
+ 
+ 	platform_add_devices(avila_devices, ARRAY_SIZE(avila_devices));
+ 
Index: trunk/target/linux/ixp4xx/patches-2.6.37/508-gw2373_support.patch
===================================================================
--- trunk/target/linux/ixp4xx/patches-2.6.37/508-gw2373_support.patch	(revision 0)
+++ trunk/target/linux/ixp4xx/patches-2.6.37/508-gw2373_support.patch	(revision 0)
@@ -0,0 +1,12 @@
+--- a/arch/arm/mach-ixp4xx/avila-setup.c
++++ b/arch/arm/mach-ixp4xx/avila-setup.c
+@@ -580,6 +580,9 @@ static struct avila_board_info avila_boa
+ 	}, {
+ 		.model		= "GW2370",
+ 		.setup		= avila_gw2370_setup,
++	}, {
++		.model		= "GW2373",
++		.setup		= avila_gw2369_setup,
+ 	}
+ };
+ 
Index: trunk/target/linux/ixp4xx/patches-2.6.37/501-cambria-e1000-irq.patch
===================================================================
--- trunk/target/linux/ixp4xx/patches-2.6.37/501-cambria-e1000-irq.patch	(revision 0)
+++ trunk/target/linux/ixp4xx/patches-2.6.37/501-cambria-e1000-irq.patch	(revision 0)
@@ -0,0 +1,14 @@
+--- a/arch/arm/mach-ixp4xx/cambria-pci.c
++++ b/arch/arm/mach-ixp4xx/cambria-pci.c
+@@ -52,6 +52,11 @@ static int __init cambria_map_irq(struct
+ 		return IRQ_IXP4XX_GPIO9;
+ 	else if (slot == 4)
+ 		return IRQ_IXP4XX_GPIO8;
++  else if (slot == 6)
++    return IRQ_IXP4XX_GPIO10;
++  else if (slot == 15)
++    return IRQ_IXP4XX_GPIO8;
++
+ 	else return -1;
+ }
+ 
Index: trunk/target/linux/ixp4xx/patches-2.6.37/505-gateworks_gsp.patch
===================================================================
--- trunk/target/linux/ixp4xx/patches-2.6.37/505-gateworks_gsp.patch	(revision 0)
+++ trunk/target/linux/ixp4xx/patches-2.6.37/505-gateworks_gsp.patch	(revision 0)
@@ -0,0 +1,339 @@
+--- /dev/null
++++ b/drivers/hwmon/gsp.c
+@@ -0,0 +1,308 @@
++/*
++ * A hwmon driver for the Gateworks System Peripheral
++ * Copyright (C) 2009 Gateworks Corporation
++ *
++ * Author: Chris Lang <clang@gateworks.com>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License,
++ * as published by the Free Software Foundation - version 2.
++ */
++
++#include <linux/module.h>
++#include <linux/i2c.h>
++#include <linux/hwmon.h>
++#include <linux/hwmon-sysfs.h>
++#include <linux/err.h>
++#include <linux/slab.h>
++
++#define DRV_VERSION "0.2"
++
++enum chips { gsp };
++
++/* AD7418 registers */
++#define GSP_REG_TEMP_IN		0x00
++#define GSP_REG_VIN		0x02
++#define GSP_REG_3P3		0x05
++#define GSP_REG_BAT		0x08
++#define GSP_REG_5P0		0x0b
++#define GSP_REG_CORE		0x0e
++#define GSP_REG_CPU1		0x11
++#define GSP_REG_CPU2		0x14
++#define GSP_REG_DRAM		0x17
++#define GSP_REG_EXT_BAT		0x1a
++#define GSP_REG_IO1		0x1d
++#define GSP_REG_IO2 		0x20
++#define GSP_REG_PCIE		0x23
++#define GSP_REG_CURRENT		0x26
++#define GSP_FAN_0		0x2C
++#define GSP_FAN_1		0x2E
++#define GSP_FAN_2		0x30
++#define GSP_FAN_3		0x32
++#define GSP_FAN_4		0x34
++#define GSP_FAN_5		0x36
++
++struct gsp_sensor_info {
++	const char* name;
++	int reg;
++};
++
++static const struct gsp_sensor_info gsp_sensors[] = {
++	{"temp", GSP_REG_TEMP_IN},
++	{"vin", GSP_REG_VIN},
++	{"3p3", GSP_REG_3P3},
++	{"bat", GSP_REG_BAT},
++	{"5p0", GSP_REG_5P0},
++	{"core", GSP_REG_CORE},
++	{"cpu1", GSP_REG_CPU1},
++	{"cpu2", GSP_REG_CPU2},
++	{"dram", GSP_REG_DRAM},
++	{"ext_bat", GSP_REG_EXT_BAT},
++	{"io1", GSP_REG_IO1},
++	{"io2", GSP_REG_IO2},
++	{"pci2", GSP_REG_PCIE},
++	{"current", GSP_REG_CURRENT},
++	{"fan_point0", GSP_FAN_0},
++	{"fan_point1", GSP_FAN_1},
++	{"fan_point2", GSP_FAN_2},
++	{"fan_point3", GSP_FAN_3},
++	{"fan_point4", GSP_FAN_4},
++	{"fan_point5", GSP_FAN_5},
++};
++
++struct gsp_data {
++	struct device		*hwmon_dev;
++	struct attribute_group	attrs;
++	enum chips		type;
++};
++
++static int gsp_probe(struct i2c_client *client,
++			const struct i2c_device_id *id);
++static int gsp_remove(struct i2c_client *client);
++
++static const struct i2c_device_id gsp_id[] = {
++	{ "gsp", 0 },
++	{ }
++};
++MODULE_DEVICE_TABLE(i2c, gsp_id);
++
++static struct i2c_driver gsp_driver = {
++	.driver = {
++		.name	= "gsp",
++	},
++	.probe		= gsp_probe,
++	.remove		= gsp_remove,
++	.id_table	= gsp_id,
++};
++
++/* All registers are word-sized, except for the configuration registers.
++ * AD7418 uses a high-byte first convention. Do NOT use those functions to
++ * access the configuration registers CONF and CONF2, as they are byte-sized.
++ */
++static inline int gsp_read(struct i2c_client *client, u8 reg)
++{
++	unsigned int adc = 0;
++	if (reg == GSP_REG_TEMP_IN || reg > GSP_REG_CURRENT)
++	{
++		adc |= i2c_smbus_read_byte_data(client, reg);
++		adc |= i2c_smbus_read_byte_data(client, reg + 1) << 8;
++		return adc;
++	}
++	else
++	{
++		adc |= i2c_smbus_read_byte_data(client, reg);
++		adc |= i2c_smbus_read_byte_data(client, reg + 1) << 8;
++		adc |= i2c_smbus_read_byte_data(client, reg + 2) << 16;
++		return adc;
++	}
++}
++
++static inline int gsp_write(struct i2c_client *client, u8 reg, u16 value)
++{
++	i2c_smbus_write_byte_data(client, reg, value & 0xff);
++	i2c_smbus_write_byte_data(client, reg + 1, ((value >> 8) & 0xff));
++	return 1;
++}
++
++static ssize_t show_adc(struct device *dev, struct device_attribute *devattr,
++			char *buf)
++{
++	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
++	struct i2c_client *client = to_i2c_client(dev);
++	return sprintf(buf, "%d\n", gsp_read(client, gsp_sensors[attr->index].reg));
++}
++
++static ssize_t show_label(struct device *dev,
++			struct device_attribute *devattr, char *buf)
++{
++	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
++
++	return sprintf(buf, "%s\n", gsp_sensors[attr->index].name);
++}
++
++static ssize_t store_fan(struct device *dev,
++			struct device_attribute *devattr, const char *buf, size_t count)
++{
++	u16 val;
++	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
++	struct i2c_client *client = to_i2c_client(dev);
++	val = simple_strtoul(buf, NULL, 10);
++	gsp_write(client, gsp_sensors[attr->index].reg, val);
++	return count;
++}
++
++static SENSOR_DEVICE_ATTR(temp0_input, S_IRUGO, show_adc, NULL, 0);
++static SENSOR_DEVICE_ATTR(temp0_label, S_IRUGO, show_label, NULL, 0);
++
++static SENSOR_DEVICE_ATTR(in0_input, S_IRUGO, show_adc, NULL, 1);
++static SENSOR_DEVICE_ATTR(in0_label, S_IRUGO, show_label, NULL, 1);
++static SENSOR_DEVICE_ATTR(in1_input, S_IRUGO, show_adc, NULL, 2);
++static SENSOR_DEVICE_ATTR(in1_label, S_IRUGO, show_label, NULL, 2);
++static SENSOR_DEVICE_ATTR(in2_input, S_IRUGO, show_adc, NULL, 3);
++static SENSOR_DEVICE_ATTR(in2_label, S_IRUGO, show_label, NULL, 3);
++static SENSOR_DEVICE_ATTR(in3_input, S_IRUGO, show_adc, NULL, 4);
++static SENSOR_DEVICE_ATTR(in3_label, S_IRUGO, show_label, NULL, 4);
++static SENSOR_DEVICE_ATTR(in4_input, S_IRUGO, show_adc, NULL, 5);
++static SENSOR_DEVICE_ATTR(in4_label, S_IRUGO, show_label, NULL, 5);
++static SENSOR_DEVICE_ATTR(in5_input, S_IRUGO, show_adc, NULL, 6);
++static SENSOR_DEVICE_ATTR(in5_label, S_IRUGO, show_label, NULL, 6);
++static SENSOR_DEVICE_ATTR(in6_input, S_IRUGO, show_adc, NULL, 7);
++static SENSOR_DEVICE_ATTR(in6_label, S_IRUGO, show_label, NULL, 7);
++static SENSOR_DEVICE_ATTR(in7_input, S_IRUGO, show_adc, NULL, 8);
++static SENSOR_DEVICE_ATTR(in7_label, S_IRUGO, show_label, NULL, 8);
++static SENSOR_DEVICE_ATTR(in8_input, S_IRUGO, show_adc, NULL, 9);
++static SENSOR_DEVICE_ATTR(in8_label, S_IRUGO, show_label, NULL, 9);
++static SENSOR_DEVICE_ATTR(in9_input, S_IRUGO, show_adc, NULL, 10);
++static SENSOR_DEVICE_ATTR(in9_label, S_IRUGO, show_label, NULL, 10);
++static SENSOR_DEVICE_ATTR(in10_input, S_IRUGO, show_adc, NULL, 11);
++static SENSOR_DEVICE_ATTR(in10_label, S_IRUGO, show_label, NULL, 11);
++static SENSOR_DEVICE_ATTR(in11_input, S_IRUGO, show_adc, NULL, 12);
++static SENSOR_DEVICE_ATTR(in11_label, S_IRUGO, show_label, NULL, 12);
++static SENSOR_DEVICE_ATTR(in12_input, S_IRUGO, show_adc, NULL, 13);
++static SENSOR_DEVICE_ATTR(in12_label, S_IRUGO, show_label, NULL, 13);
++
++static SENSOR_DEVICE_ATTR(fan0_point0, S_IRUGO | S_IWUSR, show_adc, store_fan, 14);
++static SENSOR_DEVICE_ATTR(fan0_point1, S_IRUGO | S_IWUSR, show_adc, store_fan, 15);
++static SENSOR_DEVICE_ATTR(fan0_point2, S_IRUGO | S_IWUSR, show_adc, store_fan, 16);
++static SENSOR_DEVICE_ATTR(fan0_point3, S_IRUGO | S_IWUSR, show_adc, store_fan, 17);
++static SENSOR_DEVICE_ATTR(fan0_point4, S_IRUGO | S_IWUSR, show_adc, store_fan, 18);
++static SENSOR_DEVICE_ATTR(fan0_point5, S_IRUGO | S_IWUSR, show_adc, store_fan, 19);
++
++static struct attribute *gsp_attributes[] = {
++	&sensor_dev_attr_temp0_input.dev_attr.attr,
++	&sensor_dev_attr_in0_input.dev_attr.attr,
++	&sensor_dev_attr_in1_input.dev_attr.attr,
++	&sensor_dev_attr_in2_input.dev_attr.attr,
++	&sensor_dev_attr_in3_input.dev_attr.attr,
++	&sensor_dev_attr_in4_input.dev_attr.attr,
++	&sensor_dev_attr_in5_input.dev_attr.attr,
++	&sensor_dev_attr_in6_input.dev_attr.attr,
++	&sensor_dev_attr_in7_input.dev_attr.attr,
++	&sensor_dev_attr_in8_input.dev_attr.attr,
++	&sensor_dev_attr_in9_input.dev_attr.attr,
++	&sensor_dev_attr_in10_input.dev_attr.attr,
++	&sensor_dev_attr_in11_input.dev_attr.attr,
++	&sensor_dev_attr_in12_input.dev_attr.attr,
++
++	&sensor_dev_attr_temp0_label.dev_attr.attr,
++	&sensor_dev_attr_in0_label.dev_attr.attr,
++	&sensor_dev_attr_in1_label.dev_attr.attr,
++	&sensor_dev_attr_in2_label.dev_attr.attr,
++	&sensor_dev_attr_in3_label.dev_attr.attr,
++	&sensor_dev_attr_in4_label.dev_attr.attr,
++	&sensor_dev_attr_in5_label.dev_attr.attr,
++	&sensor_dev_attr_in6_label.dev_attr.attr,
++	&sensor_dev_attr_in7_label.dev_attr.attr,
++	&sensor_dev_attr_in8_label.dev_attr.attr,
++	&sensor_dev_attr_in9_label.dev_attr.attr,
++	&sensor_dev_attr_in10_label.dev_attr.attr,
++	&sensor_dev_attr_in11_label.dev_attr.attr,
++	&sensor_dev_attr_in12_label.dev_attr.attr,
++
++	&sensor_dev_attr_fan0_point0.dev_attr.attr,
++	&sensor_dev_attr_fan0_point1.dev_attr.attr,
++	&sensor_dev_attr_fan0_point2.dev_attr.attr,
++	&sensor_dev_attr_fan0_point3.dev_attr.attr,
++	&sensor_dev_attr_fan0_point4.dev_attr.attr,
++	&sensor_dev_attr_fan0_point5.dev_attr.attr,
++	NULL
++};
++
++
++static int gsp_probe(struct i2c_client *client,
++			 const struct i2c_device_id *id)
++{
++	struct i2c_adapter *adapter = client->adapter;
++	struct gsp_data *data;
++	int err;
++
++	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA |
++					I2C_FUNC_SMBUS_WORD_DATA)) {
++		err = -EOPNOTSUPP;
++		goto exit;
++	}
++
++	if (!(data = kzalloc(sizeof(struct gsp_data), GFP_KERNEL))) {
++		err = -ENOMEM;
++		goto exit;
++	}
++
++	i2c_set_clientdata(client, data);
++
++	data->type = id->driver_data;
++
++	switch (data->type) {
++	case 0:
++		data->attrs.attrs = gsp_attributes;
++		break;
++	}
++
++	dev_info(&client->dev, "%s chip found\n", client->name);
++
++	/* Register sysfs hooks */
++	if ((err = sysfs_create_group(&client->dev.kobj, &data->attrs)))
++		goto exit_free;
++
++	data->hwmon_dev = hwmon_device_register(&client->dev);
++	if (IS_ERR(data->hwmon_dev)) {
++		err = PTR_ERR(data->hwmon_dev);
++		goto exit_remove;
++	}
++
++	return 0;
++
++exit_remove:
++	sysfs_remove_group(&client->dev.kobj, &data->attrs);
++exit_free:
++	kfree(data);
++exit:
++	return err;
++}
++
++static int gsp_remove(struct i2c_client *client)
++{
++	struct gsp_data *data = i2c_get_clientdata(client);
++	hwmon_device_unregister(data->hwmon_dev);
++	sysfs_remove_group(&client->dev.kobj, &data->attrs);
++	kfree(data);
++	return 0;
++}
++
++static int __init gsp_init(void)
++{
++	return i2c_add_driver(&gsp_driver);
++}
++
++static void __exit gsp_exit(void)
++{
++	i2c_del_driver(&gsp_driver);
++}
++
++module_init(gsp_init);
++module_exit(gsp_exit);
++
++MODULE_AUTHOR("Chris Lang <clang@gateworks.com>");
++MODULE_DESCRIPTION("GSP HWMON driver");
++MODULE_LICENSE("GPL");
++MODULE_VERSION(DRV_VERSION);
++
+--- a/drivers/hwmon/Kconfig
++++ b/drivers/hwmon/Kconfig
+@@ -68,6 +68,15 @@ config SENSORS_ABITUGURU3
+ 	  This driver can also be built as a module.  If so, the module
+ 	  will be called abituguru3.
+ 
++config SENSORS_GSP
++  tristate "Gateworks System Peripheral"
++  depends on I2C && EXPERIMENTAL
++  help
++    If you say yes here you get support for the Gateworks System Peripherals.
++
++    This driver can also be built as a module. If so, the module
++    will be called gsp.
++
+ config SENSORS_AD7414
+ 	tristate "Analog Devices AD7414"
+ 	depends on I2C && EXPERIMENTAL
+--- a/drivers/hwmon/Makefile
++++ b/drivers/hwmon/Makefile
+@@ -20,6 +20,7 @@ obj-$(CONFIG_SENSORS_W83791D)	+= w83791d
+ 
+ obj-$(CONFIG_SENSORS_ABITUGURU)	+= abituguru.o
+ obj-$(CONFIG_SENSORS_ABITUGURU3)+= abituguru3.o
++obj-$(CONFIG_SENSORS_GSP)	+= gsp.o
+ obj-$(CONFIG_SENSORS_AD7414)	+= ad7414.o
+ obj-$(CONFIG_SENSORS_AD7418)	+= ad7418.o
+ obj-$(CONFIG_SENSORS_ADCXX)	+= adcxx.o
Index: trunk/target/linux/ixp4xx/patches-2.6.37/302-avila_gpio_device.patch
===================================================================
--- trunk/target/linux/ixp4xx/patches-2.6.37/302-avila_gpio_device.patch	(revision 27590)
+++ trunk/target/linux/ixp4xx/patches-2.6.37/302-avila_gpio_device.patch	(working copy)
@@ -14,3 +14,28 @@
  struct avila_board_info {
  	unsigned char	*model;
  	void		(*setup)(void);
+@@ -243,6 +250,11 @@ static struct platform_device *avila_dev
+ 	&avila_uart
+ };
+ 
++static struct platform_device avila_gpio_dev = {
++	.name     = "GPIODEV",
++	.id     = -1,
++};
++
+ static void __init avila_gw23xx_setup(void)
+ {
+ 	platform_device_register(&avila_npeb_device);
+@@ -434,8 +446,10 @@ static void __init avila_init(void)
+ 
+ 	platform_device_register(&avila_pata);
+ 
+-		i2c_register_board_info(0, avila_i2c_board_info,
+-				ARRAY_SIZE(avila_i2c_board_info));
++	i2c_register_board_info(0, avila_i2c_board_info,
++			ARRAY_SIZE(avila_i2c_board_info));
++
++	platform_device_register(&avila_gpio_dev);
+ }
+ 
+ static int __init avila_model_setup(void)
Index: trunk/target/linux/ixp4xx/patches-2.6.37/503-gw2365-optional-uart.patch
===================================================================
--- trunk/target/linux/ixp4xx/patches-2.6.37/503-gw2365-optional-uart.patch	(revision 0)
+++ trunk/target/linux/ixp4xx/patches-2.6.37/503-gw2365-optional-uart.patch	(revision 0)
@@ -0,0 +1,105 @@
+--- a/arch/arm/mach-ixp4xx/avila-setup.c
++++ b/arch/arm/mach-ixp4xx/avila-setup.c
+@@ -125,6 +125,69 @@ static struct platform_device avila_uart
+ 	.resource		= avila_uart_resources
+ };
+ 
++static struct resource avila_optional_uart_resources[] = {
++  {
++    .start  = 0x54000000,
++    .end  = 0x54000fff,
++    .flags  = IORESOURCE_MEM
++  },
++  {
++    .start  = 0x55000000,
++    .end  = 0x55000fff,
++    .flags  = IORESOURCE_MEM
++  },
++  {
++    .start  = 0x56000000,
++    .end  = 0x56000fff,
++    .flags  = IORESOURCE_MEM
++  },
++  {
++    .start  = 0x57000000,
++    .end  = 0x57000fff,
++    .flags  = IORESOURCE_MEM
++  }
++};
++
++static struct plat_serial8250_port avila_optional_uart_data[] = {
++  {
++    .flags    = UPF_BOOT_AUTOCONF,
++    .iotype   = UPIO_MEM,
++    .regshift = 0,
++    .uartclk  = 18432000,
++    .rw_delay = 2,
++  },
++  {
++    .flags    = UPF_BOOT_AUTOCONF,
++    .iotype   = UPIO_MEM,
++    .regshift = 0,
++    .uartclk  = 18432000,
++    .rw_delay = 2,
++  },
++  {
++    .flags    = UPF_BOOT_AUTOCONF,
++    .iotype   = UPIO_MEM,
++    .regshift = 0,
++    .uartclk  = 18432000,
++    .rw_delay = 2,
++  },
++  {
++    .flags    = UPF_BOOT_AUTOCONF,
++    .iotype   = UPIO_MEM,
++    .regshift = 0,
++    .uartclk  = 18432000,
++    .rw_delay = 2,
++  },
++  { },
++};
++
++static struct platform_device avila_optional_uart = {
++  .name   = "serial8250",
++  .id   = PLAT8250_DEV_PLATFORM1,
++  .dev.platform_data  = avila_optional_uart_data,
++  .num_resources  = 4,
++  .resource = avila_optional_uart_resources,
++};
++
+ static struct resource avila_pata_resources[] = {
+ 	{
+ 		.flags	= IORESOURCE_MEM
+@@ -340,6 +403,32 @@ static void __init avila_gw2357_setup(vo
+ 
+ static void __init avila_gw2365_setup(void)
+ {
++	*IXP4XX_EXP_CS4 = 0xBFFF3C43;
++  set_irq_type(IRQ_IXP4XX_GPIO0, IRQ_TYPE_EDGE_RISING);
++  avila_optional_uart_data[0].mapbase = 0x54000000;
++  avila_optional_uart_data[0].membase = (void __iomem *)ioremap(0x54000000, 0x0fff);
++  avila_optional_uart_data[0].irq   = IRQ_IXP4XX_GPIO0;
++
++  *IXP4XX_EXP_CS5 = 0xBFFF3C43;
++  set_irq_type(IRQ_IXP4XX_GPIO1, IRQ_TYPE_EDGE_RISING);
++  avila_optional_uart_data[1].mapbase = 0x55000000;
++  avila_optional_uart_data[1].membase = (void __iomem *)ioremap(0x55000000, 0x0fff);
++  avila_optional_uart_data[1].irq   = IRQ_IXP4XX_GPIO1;
++
++  *IXP4XX_EXP_CS6 = 0xBFFF3C43;
++  set_irq_type(IRQ_IXP4XX_GPIO2, IRQ_TYPE_EDGE_RISING);
++  avila_optional_uart_data[2].mapbase = 0x56000000;
++  avila_optional_uart_data[2].membase = (void __iomem *)ioremap(0x56000000, 0x0fff);
++  avila_optional_uart_data[2].irq   = IRQ_IXP4XX_GPIO2;
++
++  *IXP4XX_EXP_CS7 = 0xBFFF3C43;
++  set_irq_type(IRQ_IXP4XX_GPIO3, IRQ_TYPE_EDGE_RISING);
++  avila_optional_uart_data[3].mapbase = 0x57000000;
++  avila_optional_uart_data[3].membase = (void __iomem *)ioremap(0x57000000, 0x0fff);
++  avila_optional_uart_data[3].irq   = IRQ_IXP4XX_GPIO3;
++
++	platform_device_register(&avila_optional_uart);
++	
+ 	avila_npeb_data.phy = 1;
+ 	platform_device_register(&avila_npeb_device);
+ 
Index: trunk/target/linux/ixp4xx/patches-2.6.37/507-gw2371_support.patch
===================================================================
--- trunk/target/linux/ixp4xx/patches-2.6.37/507-gw2371_support.patch	(revision 0)
+++ trunk/target/linux/ixp4xx/patches-2.6.37/507-gw2371_support.patch	(revision 0)
@@ -0,0 +1,12 @@
+--- a/arch/arm/mach-ixp4xx/cambria-setup.c
++++ b/arch/arm/mach-ixp4xx/cambria-setup.c
+@@ -448,6 +448,9 @@ static struct cambria_board_info cambria
+ 	}, {
+ 		.model	= "GW2358",
+ 		.setup	= cambria_gw2358_setup,
++	}, {
++		.model	= "GW2371",
++		.setup	= cambria_gw2358_setup,
+ 	}
+ };
+ 
Index: trunk/target/linux/ixp4xx/patches-2.6.37/509-avila_hss_audio_support.patch
===================================================================
--- trunk/target/linux/ixp4xx/patches-2.6.37/509-avila_hss_audio_support.patch	(revision 0)
+++ trunk/target/linux/ixp4xx/patches-2.6.37/509-avila_hss_audio_support.patch	(revision 0)
@@ -0,0 +1,2215 @@
+--- a/sound/soc/Kconfig
++++ b/sound/soc/Kconfig
+@@ -40,6 +40,7 @@ source "sound/soc/s3c24xx/Kconfig"
+ source "sound/soc/s6000/Kconfig"
+ source "sound/soc/sh/Kconfig"
+ source "sound/soc/txx9/Kconfig"
++source "sound/soc/gw-avila/Kconfig"
+ 
+ # Supported codecs
+ source "sound/soc/codecs/Kconfig"
+--- a/sound/soc/Makefile
++++ b/sound/soc/Makefile
+@@ -18,3 +18,4 @@ obj-$(CONFIG_SND_SOC)	+= s3c24xx/
+ obj-$(CONFIG_SND_SOC)	+= s6000/
+ obj-$(CONFIG_SND_SOC)	+= sh/
+ obj-$(CONFIG_SND_SOC)	+= txx9/
++obj-$(CONFIG_SND_SOC)	+= gw-avila/
+--- /dev/null
++++ b/sound/soc/gw-avila/Kconfig
+@@ -0,0 +1,17 @@
++config SND_GW_AVILA_SOC_PCM
++	tristate
++
++config SND_GW_AVILA_SOC_HSS
++	tristate
++
++config SND_GW_AVILA_SOC
++	tristate "SoC Audio for the Gateworks AVILA Family"
++	depends on ARCH_IXP4XX && SND_SOC
++	select SND_GW_AVILA_SOC_PCM
++	select SND_GW_AVILA_SOC_HSS
++	select SND_SOC_TLV320AIC3X
++	help
++	  Say Y or M if you want to add support for codecs attached to
++	  the Gateworks HSS interface. You will also need
++	  to select the audio interfaces to support below.
++
+--- /dev/null
++++ b/sound/soc/gw-avila/Makefile
+@@ -0,0 +1,8 @@
++# Gateworks Avila HSS Platform Support
++snd-soc-gw-avila-objs := gw-avila.o ixp4xx_hss.o
++snd-soc-gw-avila-pcm-objs := gw-avila-pcm.o
++snd-soc-gw-avila-hss-objs := gw-avila-hss.o
++
++obj-$(CONFIG_SND_GW_AVILA_SOC) += snd-soc-gw-avila.o
++obj-$(CONFIG_SND_GW_AVILA_SOC_PCM) += snd-soc-gw-avila-pcm.o
++obj-$(CONFIG_SND_GW_AVILA_SOC_HSS) += snd-soc-gw-avila-hss.o
+--- /dev/null
++++ b/sound/soc/gw-avila/gw-avila-hss.c
+@@ -0,0 +1,98 @@
++/*
++ * gw-avila-hss.c -- HSS Audio Support for Gateworks Avila
++ *
++ * Author:	Chris Lang	<clang@gateworks.com>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ */
++
++#include <linux/init.h>
++#include <linux/module.h>
++#include <linux/platform_device.h>
++#include <linux/interrupt.h>
++#include <linux/wait.h>
++#include <linux/delay.h>
++
++#include <sound/core.h>
++#include <sound/pcm.h>
++#include <sound/ac97_codec.h>
++#include <sound/initval.h>
++#include <sound/soc.h>
++
++#include <asm/irq.h>
++#include <linux/mutex.h>
++#include <linux/gpio.h>
++
++#include "ixp4xx_hss.h"
++#include "gw-avila-hss.h"
++
++#define gw_avila_hss_suspend	NULL
++#define gw_avila_hss_resume	NULL
++
++struct snd_soc_dai_driver gw_avila_hss_dai = {
++	.playback = {
++		.channels_min = 2,
++		.channels_max = 2,
++		.rates = (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000 |
++			SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_32000 |
++			SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 |
++			SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000 |
++			SNDRV_PCM_RATE_KNOT),
++		.formats = SNDRV_PCM_FMTBIT_S16_LE, },
++	.capture = {
++		.channels_min = 2,
++		.channels_max = 2,
++		.rates = (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000 |
++			SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_32000 |
++			SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 |
++			SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000 |
++			SNDRV_PCM_RATE_KNOT),
++		.formats = SNDRV_PCM_FMTBIT_S16_LE, },
++};
++
++static int gw_avila_hss_probe(struct platform_device *pdev)
++{
++	int port = (pdev->id < 2) ? 0 : 1;
++	int channel = (pdev->id % 2);
++
++	hss_handle[pdev->id] = hss_init(port, channel);
++	if (!hss_handle[pdev->id]) {
++		return -ENODEV;
++	}
++
++	return snd_soc_register_dai(&pdev->dev, &gw_avila_hss_dai);
++}
++
++static int gw_avila_hss_remove(struct platform_device *pdev)
++{
++	snd_soc_unregister_dai(&pdev->dev);
++
++	return 0;
++}
++
++static struct platform_driver gw_avila_hss_driver = {
++	.probe    = gw_avila_hss_probe,
++	.remove   = gw_avila_hss_remove,
++	.driver   = {
++		.name = "gw_avila_hss",
++		.owner  = THIS_MODULE,
++	}
++};
++
++static int __init gw_avila_hss_init(void)
++{
++	return platform_driver_register(&gw_avila_hss_driver);
++}
++module_init(gw_avila_hss_init);
++
++static void __exit gw_avila_hss_exit(void)
++{
++	platform_driver_unregister(&gw_avila_hss_driver);
++}
++module_exit(gw_avila_hss_exit);
++
++MODULE_AUTHOR("Chris Lang");
++MODULE_DESCRIPTION("HSS Audio Driver for Gateworks Avila");
++MODULE_LICENSE("GPL");
+--- /dev/null
++++ b/sound/soc/gw-avila/gw-avila-hss.h
+@@ -0,0 +1,12 @@
++/*
++ * Author: Chris Lang <clang@gateworks.com>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ */
++
++#ifndef _GW_AVILA_HSS_H
++#define _GW_AVILA_HSS_H
++
++#endif
+--- /dev/null
++++ b/sound/soc/gw-avila/gw-avila-pcm.c
+@@ -0,0 +1,325 @@
++/*
++ * ALSA PCM interface for the TI DAVINCI processor
++ *
++ * Author:      Chris Lang, <clang@gateworks.com>
++ * Copyright:   (C) 2009 Gateworks Corporation
++ *
++ * Based On:    davinci-evm.c, Author: Vladimir Barinov, <vbarinov@ru.mvista.com>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ */
++
++#include <linux/module.h>
++#include <linux/init.h>
++#include <linux/platform_device.h>
++#include <linux/slab.h>
++#include <linux/dma-mapping.h>
++
++#include <sound/core.h>
++#include <sound/pcm.h>
++#include <sound/pcm_params.h>
++#include <sound/soc.h>
++
++#include <asm/dma.h>
++
++#include "gw-avila-pcm.h"
++#include "gw-avila-hss.h"
++#include "ixp4xx_hss.h"
++
++#define GW_AVILA_PCM_DEBUG 0
++#if GW_AVILA_PCM_DEBUG
++#define DPRINTK(x...) printk(KERN_DEBUG x)
++#else
++#define DPRINTK(x...)
++#endif
++
++static struct snd_pcm_hardware gw_avila_pcm_hardware = {
++	.info = (SNDRV_PCM_INFO_INTERLEAVED | SNDRV_PCM_INFO_BLOCK_TRANSFER |
++		 SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_MMAP_VALID),
++/*		 SNDRV_PCM_INFO_PAUSE),*/
++	.formats = (SNDRV_PCM_FMTBIT_S16_LE),
++	.rates = (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000 |
++		  SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_32000 |
++		  SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 |
++		  SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000 |
++		  SNDRV_PCM_RATE_KNOT),
++	.rate_min = 8000,
++	.rate_max = 8000,
++	.channels_min = 2,
++	.channels_max = 2,
++	.buffer_bytes_max = 64 * 1024, // All of the lines below may need to be changed
++	.period_bytes_min = 128,
++	.period_bytes_max = 4 * 1024,
++	.periods_min = 16,
++	.periods_max = 32,
++	.fifo_size = 0,
++};
++
++struct gw_avila_runtime_data {
++	spinlock_t lock;
++	int period;		/* current DMA period */
++	int master_lch;		/* Master DMA channel */
++	int slave_lch;		/* Slave DMA channel */
++	struct gw_avila_pcm_dma_params *params;	/* DMA params */
++};
++
++static void gw_avila_dma_irq(void *data)
++{
++	struct snd_pcm_substream *substream = data;
++	snd_pcm_period_elapsed(substream);
++}
++
++static int gw_avila_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
++{
++	struct snd_pcm_runtime *runtime = substream->runtime;
++	struct hss_device *hdev = runtime->private_data;
++	int ret = 0;
++
++	switch (cmd) {
++	case SNDRV_PCM_TRIGGER_START:
++	case SNDRV_PCM_TRIGGER_RESUME:
++	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
++		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
++			hss_tx_start(hdev);
++		else
++			hss_rx_start(hdev);
++		break;
++	case SNDRV_PCM_TRIGGER_STOP:
++	case SNDRV_PCM_TRIGGER_SUSPEND:
++	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
++		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
++			hss_tx_stop(hdev);
++		else
++			hss_rx_stop(hdev);
++		break;
++	default:
++		ret = -EINVAL;
++		break;
++	}
++	return ret;
++}
++
++static int gw_avila_pcm_prepare(struct snd_pcm_substream *substream)
++{
++	struct snd_pcm_runtime *runtime = substream->runtime;
++	struct hss_device *hdev = runtime->private_data;
++
++	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
++		hss_set_tx_callback(hdev, gw_avila_dma_irq, substream);
++		hss_config_tx_dma(hdev, runtime->dma_area, runtime->buffer_size, runtime->period_size);
++	} else {
++		hss_set_rx_callback(hdev, gw_avila_dma_irq, substream);
++		hss_config_rx_dma(hdev, runtime->dma_area, runtime->buffer_size, runtime->period_size);
++	}
++
++	return 0;
++}
++
++static snd_pcm_uframes_t
++gw_avila_pcm_pointer(struct snd_pcm_substream *substream)
++{
++	struct snd_pcm_runtime *runtime = substream->runtime;
++	struct hss_device *hdev = runtime->private_data;
++
++	unsigned int curr = 0;
++	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
++		curr = hss_curr_offset_tx(hdev);
++	else
++		curr = hss_curr_offset_rx(hdev);
++  return curr;
++}
++
++static int gw_avila_pcm_open(struct snd_pcm_substream *substream)
++{
++	struct snd_pcm_runtime *runtime = substream->runtime;
++	struct snd_soc_pcm_runtime *rtd = substream->private_data;
++	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
++
++	snd_soc_set_runtime_hwparams(substream, &gw_avila_pcm_hardware);
++
++	if (hss_handle[cpu_dai->id] != NULL)
++		runtime->private_data = hss_handle[cpu_dai->id];
++	else {
++		pr_err("hss_handle is NULL\n");
++		return -1;
++	}
++
++	hss_chan_open(hss_handle[cpu_dai->id]);
++
++	return 0;
++}
++
++static int gw_avila_pcm_close(struct snd_pcm_substream *substream)
++{
++	struct snd_pcm_runtime *runtime = substream->runtime;
++	struct hss_device *hdev = runtime->private_data;
++
++	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
++		memset(hdev->tx_buf, 0, runtime->buffer_size);
++	} else
++		memset(hdev->rx_buf, 0, runtime->buffer_size);
++
++	hss_chan_close(hdev);
++
++	return 0;
++}
++
++static int gw_avila_pcm_hw_params(struct snd_pcm_substream *substream,
++				 struct snd_pcm_hw_params *hw_params)
++{
++	return snd_pcm_lib_malloc_pages(substream,
++					params_buffer_bytes(hw_params));
++}
++
++static int gw_avila_pcm_hw_free(struct snd_pcm_substream *substream)
++{
++	struct snd_pcm_runtime *runtime = substream->runtime;
++
++	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
++	  memset(runtime->dma_area, 0, runtime->buffer_size);
++
++	return snd_pcm_lib_free_pages(substream);
++}
++
++static int gw_avila_pcm_mmap(struct snd_pcm_substream *substream,
++          struct vm_area_struct *vma)
++{
++	struct snd_pcm_runtime *runtime = substream->runtime;
++
++	return dma_mmap_writecombine(substream->pcm->card->dev, vma,
++						runtime->dma_area,
++						runtime->dma_addr,
++						runtime->dma_bytes);
++}
++
++struct snd_pcm_ops gw_avila_pcm_ops = {
++	.open = 	gw_avila_pcm_open,
++	.close = 	gw_avila_pcm_close,
++	.ioctl = 	snd_pcm_lib_ioctl,
++	.hw_params = 	gw_avila_pcm_hw_params,
++	.hw_free = 	gw_avila_pcm_hw_free,
++	.prepare = 	gw_avila_pcm_prepare,
++	.trigger = 	gw_avila_pcm_trigger,
++	.pointer = 	gw_avila_pcm_pointer,
++	.mmap = gw_avila_pcm_mmap,
++};
++
++static int gw_avila_pcm_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)
++{
++	struct snd_pcm_substream *substream = pcm->streams[stream].substream;
++	struct snd_dma_buffer *buf = &substream->dma_buffer;
++	size_t size = gw_avila_pcm_hardware.buffer_bytes_max;
++
++	buf->dev.type = SNDRV_DMA_TYPE_DEV;
++	buf->dev.dev = pcm->card->dev;
++	buf->private_data = NULL;
++
++	buf->area = dma_alloc_coherent(pcm->card->dev, size,
++					   &buf->addr, GFP_KERNEL);
++
++	if (!buf->area) {
++		return -ENOMEM;
++	}
++
++	memset(buf->area, 0xff, size);
++
++	DPRINTK("preallocate_dma_buffer: area=%p, addr=%p, size=%d\n",
++		(void *) buf->area, (void *) buf->addr, size);
++
++	buf->bytes = size;
++
++	return 0;
++}
++
++static void gw_avila_pcm_free(struct snd_pcm *pcm)
++{
++	struct snd_pcm_substream *substream;
++	struct snd_dma_buffer *buf;
++	int stream;
++
++	for (stream = 0; stream < 2; stream++) {
++		substream = pcm->streams[stream].substream;
++		if (!substream)
++			continue;
++
++		buf = &substream->dma_buffer;
++		if (!buf->area)
++			continue;
++
++		dma_free_coherent(NULL, buf->bytes, buf->area, 0);
++		buf->area = NULL;
++	}
++}
++
++static u64 gw_avila_pcm_dmamask = 0xFFFFFFFF;
++
++static int gw_avila_pcm_new(struct snd_card *card,
++		struct snd_soc_dai *dai, struct snd_pcm *pcm)
++{
++	int ret;
++
++	if (!card->dev->dma_mask)
++		card->dev->dma_mask = &gw_avila_pcm_dmamask;
++	if (!card->dev->coherent_dma_mask)
++		card->dev->coherent_dma_mask = 0xFFFFFFFF;
++
++	if (dai->driver->playback.channels_min) {
++		ret = gw_avila_pcm_preallocate_dma_buffer(pcm,
++			SNDRV_PCM_STREAM_PLAYBACK);
++		if (ret)
++			return ret;
++	}
++
++	if (dai->driver->capture.channels_min) {
++		ret = gw_avila_pcm_preallocate_dma_buffer(pcm,
++			SNDRV_PCM_STREAM_CAPTURE);
++		if (ret)
++			return ret;
++	}
++
++	return 0;
++}
++
++struct snd_soc_platform_driver gw_avila_soc_platform = {
++	.ops = 	&gw_avila_pcm_ops,
++	.pcm_new = 	gw_avila_pcm_new,
++	.pcm_free = 	gw_avila_pcm_free,
++};
++
++static int __devinit gw_avila_pcm_platform_probe(struct platform_device *pdev)
++{
++	return snd_soc_register_platform(&pdev->dev, &gw_avila_soc_platform);
++}
++
++static int __devexit gw_avila_pcm_platform_remove(struct platform_device *pdev)
++{
++	snd_soc_unregister_platform(&pdev->dev);
++	return 0;
++}
++
++static struct platform_driver gw_avila_pcm_driver = {
++	.driver = {
++		.name = "gw_avila-audio",
++		.owner = THIS_MODULE,
++	},
++	.probe = gw_avila_pcm_platform_probe,
++	.remove = __devexit_p(gw_avila_pcm_platform_remove),
++};
++
++static int __init gw_avila_soc_platform_init(void)
++{
++	return platform_driver_register(&gw_avila_pcm_driver);
++}
++module_init(gw_avila_soc_platform_init);
++
++static void __exit gw_avila_soc_platform_exit(void)
++{
++	platform_driver_unregister(&gw_avila_pcm_driver);
++}
++module_exit(gw_avila_soc_platform_exit);
++
++MODULE_AUTHOR("Chris Lang");
++MODULE_DESCRIPTION("Gateworks Avila PCM DMA module");
++MODULE_LICENSE("GPL");
+--- /dev/null
++++ b/sound/soc/gw-avila/gw-avila-pcm.h
+@@ -0,0 +1,32 @@
++/*
++ * ALSA PCM interface for the Gateworks Avila platform
++ *
++ * Author:      Chris Lang, <clang@gateworks.com>
++ * Copyright:   (C) 2009 Gateworks Corporation
++ *
++ * Based On:    davinci-evm.c, Author: Vladimir Barinov, <vbarinov@ru.mvista.com>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ */
++
++#ifndef _GW_AVILA_PCM_H
++#define _GW_AVILA_PCM_H
++
++#if 0
++struct gw_avila_pcm_dma_params {
++	char *name;		/* stream identifier */
++	int channel;		/* sync dma channel ID */
++	dma_addr_t dma_addr;	/* device physical address for DMA */
++	unsigned int data_type;	/* xfer data type */
++};
++
++struct gw_avila_snd_platform_data {
++	int tx_dma_ch; // XXX Do we need this?
++	int rx_dma_ch; // XXX Do we need this
++};
++extern struct snd_soc_platform gw_avila_soc_platform[];
++#endif
++
++#endif
+--- /dev/null
++++ b/sound/soc/gw-avila/gw-avila.c
+@@ -0,0 +1,241 @@
++/*
++ * File:         sound/soc/gw-avila/gw_avila.c
++ * Author:       Chris Lang <clang@gateworks.com>
++ *
++ * Created:      Tue June 06 2008
++ * Description:  Board driver for Gateworks Avila
++ *
++ * Modified:
++ *               Copyright 2009 Gateworks Corporation
++ *
++ * Bugs:         What Bugs?
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, see the file COPYING, or write
++ * to the Free Software Foundation, Inc.,
++ * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
++ */
++
++#include <linux/module.h>
++#include <linux/moduleparam.h>
++#include <linux/device.h>
++#include <asm/dma.h>
++#include <linux/platform_device.h>
++#include <sound/core.h>
++#include <sound/pcm.h>
++#include <sound/soc.h>
++#include <sound/soc-dapm.h>
++#include <linux/slab.h>
++#include <linux/gpio.h>
++
++#include "../codecs/tlv320aic3x.h"
++#include "ixp4xx_hss.h"
++#include "gw-avila-hss.h"
++#include "gw-avila-pcm.h"
++
++#define CODEC_FREQ 33333000
++
++static int gw_avila_board_startup(struct snd_pcm_substream *substream)
++{
++	pr_debug("%s enter\n", __func__);
++	return 0;
++}
++
++static int gw_avila_hw_params(struct snd_pcm_substream *substream,
++		struct snd_pcm_hw_params *params)
++{
++	struct snd_soc_pcm_runtime *rtd = substream->private_data;
++	struct snd_soc_dai *codec_dai = rtd->codec_dai;
++	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
++
++	int ret = 0;
++
++	/* set codec DAI configuration */
++	if (cpu_dai->id % 2) {
++  		ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_DSP_B | SND_SOC_DAIFMT_IB_NF | SND_SOC_DAIFMT_CBS_CFS);
++			snd_soc_dai_set_tdm_slot(codec_dai, 0, 0, 1, 32);
++	} else {
++	  	ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_DSP_B | SND_SOC_DAIFMT_IB_NF | SND_SOC_DAIFMT_CBM_CFM);
++			snd_soc_dai_set_tdm_slot(codec_dai, 0, 0, 0, 32);
++	}
++
++	if (ret < 0)
++	    return ret;
++
++	/* set the codec system clock */
++	ret = snd_soc_dai_set_sysclk(codec_dai, 0, CODEC_FREQ, SND_SOC_CLOCK_OUT);
++	if (ret < 0)
++	    return ret;
++
++	return 0;
++}
++
++static const struct snd_soc_dapm_widget aic3x_dapm_widgets[] = {
++  SND_SOC_DAPM_HP("Headphone Jack", NULL),
++  SND_SOC_DAPM_LINE("Line Out", NULL),
++  SND_SOC_DAPM_LINE("Line In", NULL),
++};
++
++static const struct snd_soc_dapm_route audio_map[] = {
++  {"Headphone Jack", NULL, "HPLOUT"},
++  {"Headphone Jack", NULL, "HPROUT"},
++
++  /* Line Out connected to LLOUT, RLOUT */
++  {"Line Out", NULL, "LLOUT"},
++  {"Line Out", NULL, "RLOUT"},
++
++  /* Line In connected to (LINE1L | LINE2L), (LINE1R | LINE2R) */
++  {"LINE1L", NULL, "Line In"},
++  {"LINE1R", NULL, "Line In"},
++};
++
++/* Logic for a aic3x as connected on a davinci-evm */
++static int aic3x_init(struct snd_soc_pcm_runtime *rtd)
++{
++	struct snd_soc_codec *codec = rtd->codec;
++
++  /* Add davinci-evm specific widgets */
++  snd_soc_dapm_new_controls(codec, aic3x_dapm_widgets,
++          ARRAY_SIZE(aic3x_dapm_widgets));
++
++  /* Set up davinci-evm specific audio path audio_map */
++  snd_soc_dapm_add_routes(codec, audio_map, ARRAY_SIZE(audio_map));
++
++  /* not connected */
++  snd_soc_dapm_disable_pin(codec, "MONO_LOUT");
++  //snd_soc_dapm_disable_pin(codec, "HPLCOM");
++  //snd_soc_dapm_disable_pin(codec, "HPRCOM");
++  snd_soc_dapm_disable_pin(codec, "MIC3L");
++  snd_soc_dapm_disable_pin(codec, "MIC3R");
++  snd_soc_dapm_disable_pin(codec, "LINE2L");
++  snd_soc_dapm_disable_pin(codec, "LINE2R");
++
++  /* always connected */
++	snd_soc_dapm_enable_pin(codec, "Headphone Jack");
++  snd_soc_dapm_enable_pin(codec, "Line Out");
++  snd_soc_dapm_enable_pin(codec, "Line In");
++
++  snd_soc_dapm_sync(codec);
++
++	return 0;
++}
++
++static struct snd_soc_ops gw_avila_board_ops = {
++	.startup = gw_avila_board_startup,
++	.hw_params = gw_avila_hw_params,
++};
++
++static struct snd_soc_dai_link gw_avila_board_dai[] = {
++	{
++		.name = "HSS-0",
++		.stream_name = "HSS-0",
++		.cpu_dai_name = "gw_avila_hss.0",
++		.codec_dai_name = "tlv320aic3x-hifi",
++		.codec_name = "tlv320aic3x-codec.0-001b",
++		.platform_name = "gw_avila-audio.0",
++		.init = aic3x_init,
++		.ops = &gw_avila_board_ops,
++	},{
++		.name = "HSS-1",
++		.stream_name = "HSS-1",
++		.cpu_dai_name = "gw_avila_hss.1",
++		.codec_dai_name = "tlv320aic3x-hifi",
++		.codec_name = "tlv320aic3x-codec.0-001a",
++		.platform_name = "gw_avila-audio.1",
++		.init = aic3x_init,
++		.ops = &gw_avila_board_ops,
++	},{
++		.name = "HSS-2",
++		.stream_name = "HSS-2",
++		.cpu_dai_name = "gw_avila_hss.2",
++		.codec_dai_name = "tlv320aic3x-hifi",
++		.codec_name = "tlv320aic3x-codec.0-0019",
++		.platform_name = "gw_avila-audio.2",
++		.init = aic3x_init,
++		.ops = &gw_avila_board_ops,
++	},{
++		.name = "HSS-3",
++		.stream_name = "HSS-3",
++		.cpu_dai_name = "gw_avila_hss.3",
++		.codec_dai_name = "tlv320aic3x-hifi",
++		.codec_name = "tlv320aic3x-codec.0-0018",
++		.platform_name = "gw_avila-audio.3",
++		.init = aic3x_init,
++		.ops = &gw_avila_board_ops,
++	},
++};
++
++static struct snd_soc_card gw_avila_board[] = {
++	{
++		.name = "gw_avila-board.0",
++		.dai_link = &gw_avila_board_dai[0],
++		.num_links = 1,
++	},{
++		.name = "gw_avila-board.1",
++		.dai_link = &gw_avila_board_dai[1],
++		.num_links = 1,
++	},{
++		.name = "gw_avila-board.2",
++		.dai_link = &gw_avila_board_dai[2],
++		.num_links = 1,
++	},{
++		.name = "gw_avila-board.3",
++		.dai_link = &gw_avila_board_dai[3],
++		.num_links = 1,
++	}
++};
++
++static struct platform_device *gw_avila_board_snd_device[4];
++
++static int __init gw_avila_board_init(void)
++{
++	int ret;
++	struct port *port;
++	int i;
++
++	if ((hss_port[0] = kzalloc(sizeof(*port), GFP_KERNEL)) == NULL)
++		return -ENOMEM;
++
++	if ((hss_port[1] = kzalloc(sizeof(*port), GFP_KERNEL)) == NULL)
++		return -ENOMEM;
++
++	for (i = 0; i < 4; i++) {
++		gw_avila_board_snd_device[i] = platform_device_alloc("soc-audio", i);
++		if (!gw_avila_board_snd_device[i]) {
++			return -ENOMEM;
++		}
++
++		platform_set_drvdata(gw_avila_board_snd_device[i], &gw_avila_board[i]);
++		ret = platform_device_add(gw_avila_board_snd_device[i]);
++
++		if (ret) {
++			platform_device_put(gw_avila_board_snd_device[i]);
++		}
++	}
++	return ret;
++}
++
++static void __exit gw_avila_board_exit(void)
++{
++	int i;
++	for (i = 0; i < 4; i++)
++		platform_device_unregister(gw_avila_board_snd_device[i]);
++}
++
++module_init(gw_avila_board_init);
++module_exit(gw_avila_board_exit);
++
++/* Module information */
++MODULE_AUTHOR("Chris Lang");
++MODULE_DESCRIPTION("ALSA SoC HSS Audio gw_avila board");
++MODULE_LICENSE("GPL");
+--- /dev/null
++++ b/sound/soc/gw-avila/ixp4xx_hss.c
+@@ -0,0 +1,900 @@
++/*
++ * Intel IXP4xx HSS (synchronous serial port) driver for Linux
++ *
++ * Copyright (C) 2009 Chris Lang <clang@gateworks.com>
++ *
++ * This program is free software; you can redistribute it and/or modify it
++ * under the terms of version 2 of the GNU General Public License
++ * as published by the Free Software Foundation.
++ */
++
++#include <linux/bitops.h>
++#include <linux/cdev.h>
++#include <linux/dma-mapping.h>
++#include <linux/dmapool.h>
++#include <linux/fs.h>
++#include <linux/io.h>
++#include <linux/kernel.h>
++#include <linux/platform_device.h>
++#include <linux/poll.h>
++#include <linux/slab.h>
++#include <mach/npe.h>
++#include <mach/qmgr.h>
++#include <linux/delay.h>
++
++#include "ixp4xx_hss.h"
++
++/*****************************************************************************
++ * global variables
++ ****************************************************************************/
++
++void hss_chan_read(unsigned long data);
++static char lock_init = 0;
++static spinlock_t npe_lock;
++static struct npe *npe;
++
++static const struct {
++	int tx, txdone, rx, rxfree, chan;
++}queue_ids[2] = {{HSS0_PKT_TX0_QUEUE, HSS0_PKT_TXDONE_QUEUE, HSS0_PKT_RX_QUEUE,
++		  HSS0_PKT_RXFREE0_QUEUE, HSS0_CHL_RXTRIG_QUEUE},
++		 {HSS1_PKT_TX0_QUEUE, HSS1_PKT_TXDONE_QUEUE, HSS1_PKT_RX_QUEUE,
++		  HSS1_PKT_RXFREE0_QUEUE, HSS1_CHL_RXTRIG_QUEUE},
++};
++
++struct port *hss_port[2];
++struct hss_device *hss_handle[32];
++EXPORT_SYMBOL(hss_handle);
++
++/*****************************************************************************
++ * utility functions
++ ****************************************************************************/
++
++#ifndef __ARMEB__
++static inline void memcpy_swab32(u32 *dest, u32 *src, int cnt)
++{
++	int i;
++	for (i = 0; i < cnt; i++)
++		dest[i] = swab32(src[i]);
++}
++#endif
++
++static inline unsigned int sub_offset(unsigned int a, unsigned int b,
++				      unsigned int modulo)
++{
++	return (modulo /* make sure the result >= 0 */ + a - b) % modulo;
++}
++
++/*****************************************************************************
++ * HSS access
++ ****************************************************************************/
++
++static void hss_config_load(struct port *port)
++{
++	struct msg msg;
++
++	do {
++		memset(&msg, 0, sizeof(msg));
++		msg.cmd = PORT_CONFIG_LOAD;
++		msg.hss_port = port->id;
++		if (npe_send_message(npe, &msg, "HSS_LOAD_CONFIG"))
++			break;
++		if (npe_recv_message(npe, &msg, "HSS_LOAD_CONFIG"))
++			break;
++
++		/* HSS_LOAD_CONFIG for port #1 returns port_id = #4 */
++		if (msg.cmd != PORT_CONFIG_LOAD || msg.data32)
++			break;
++
++		/* HDLC may stop working without this */
++		npe_recv_message(npe, &msg, "FLUSH_IT");
++		return;
++	} while (0);
++
++	printk(KERN_CRIT "HSS-%i: unable to reload HSS configuration\n",
++	       port->id);
++	BUG();
++}
++
++static void hss_config_set_pcr(struct port *port)
++{
++	struct msg msg;
++
++	do {
++		memset(&msg, 0, sizeof(msg));
++		msg.cmd = PORT_CONFIG_WRITE;
++		msg.hss_port = port->id;
++		msg.index = HSS_CONFIG_TX_PCR;
++#if 0
++		msg.data32 = PCR_FRM_SYNC_RISINGEDGE | PCR_MSB_ENDIAN |
++			PCR_TX_DATA_ENABLE | PCR_TX_UNASS_HIGH_IMP | PCR_TX_V56K_HIGH_IMP | PCR_TX_FB_HIGH_IMP;
++#else
++		msg.data32 = PCR_FRM_SYNC_RISINGEDGE | PCR_MSB_ENDIAN |
++			PCR_TX_DATA_ENABLE | PCR_TX_FB_HIGH_IMP | PCR_DCLK_EDGE_RISING;
++#endif
++		if (port->frame_size % 8 == 0)
++			msg.data32 |= PCR_SOF_NO_FBIT;
++
++		if (npe_send_message(npe, &msg, "HSS_SET_TX_PCR"))
++			break;
++
++		msg.index = HSS_CONFIG_RX_PCR;
++		msg.data32 &= ~ (PCR_DCLK_EDGE_RISING | PCR_FCLK_EDGE_RISING | PCR_TX_DATA_ENABLE);
++
++		if (npe_send_message(npe, &msg, "HSS_SET_RX_PCR"))
++			break;
++		return;
++	} while (0);
++
++	printk(KERN_CRIT "HSS-%i: unable to set HSS PCR registers\n", port->id);
++	BUG();
++}
++
++static void hss_config_set_core(struct port *port)
++{
++	struct msg msg;
++
++	memset(&msg, 0, sizeof(msg));
++	msg.cmd = PORT_CONFIG_WRITE;
++	msg.hss_port = port->id;
++	msg.index = HSS_CONFIG_CORE_CR;
++#if 0
++	msg.data32 = 0 | CCR_LOOPBACK |
++		(port->id ? CCR_SECOND_HSS : 0);
++#else
++	msg.data32 = 0 |
++		(port->id ? CCR_SECOND_HSS : 0);
++#endif
++	if (npe_send_message(npe, &msg, "HSS_SET_CORE_CR")) {
++		printk(KERN_CRIT "HSS-%i: unable to set HSS core control"
++		       " register\n", port->id);
++		BUG();
++	}
++}
++
++static void hss_config_set_line(struct port *port)
++{
++	struct msg msg;
++
++	hss_config_set_pcr(port);
++	hss_config_set_core(port);
++
++	memset(&msg, 0, sizeof(msg));
++	msg.cmd = PORT_CONFIG_WRITE;
++	msg.hss_port = port->id;
++	msg.index = HSS_CONFIG_CLOCK_CR;
++	msg.data32 = CLK42X_SPEED_8192KHZ /* FIXME */;
++	if (npe_send_message(npe, &msg, "HSS_SET_CLOCK_CR")) {
++		printk(KERN_CRIT "HSS-%i: unable to set HSS clock control"
++		       " register\n", port->id);
++		BUG();
++	}
++}
++
++static void hss_config_set_rx_frame(struct port *port)
++{
++	struct msg msg;
++
++	memset(&msg, 0, sizeof(msg));
++	msg.cmd = PORT_CONFIG_WRITE;
++	msg.hss_port = port->id;
++	msg.index = HSS_CONFIG_RX_FCR;
++	msg.data16a = port->frame_sync_offset;
++	msg.data16b = port->frame_size - 1;
++	if (npe_send_message(npe, &msg, "HSS_SET_RX_FCR")) {
++		printk(KERN_CRIT "HSS-%i: unable to set HSS RX frame size"
++		       " and offset\n", port->id);
++		BUG();
++	}
++}
++
++static void hss_config_set_frame(struct port *port)
++{
++	struct msg msg;
++
++	memset(&msg, 0, sizeof(msg));
++	msg.cmd = PORT_CONFIG_WRITE;
++	msg.hss_port = port->id;
++	msg.index = HSS_CONFIG_TX_FCR;
++	msg.data16a = TX_FRAME_SYNC_OFFSET;
++	msg.data16b = port->frame_size - 1;
++	if (npe_send_message(npe, &msg, "HSS_SET_TX_FCR")) {
++		printk(KERN_CRIT "HSS-%i: unable to set HSS TX frame size"
++		       " and offset\n", port->id);
++		BUG();
++	}
++	hss_config_set_rx_frame(port);
++}
++
++static void hss_config_set_lut(struct port *port)
++{
++	struct msg msg;
++	int chan_count = 32;
++
++	memset(&msg, 0, sizeof(msg));
++	msg.cmd = PORT_CONFIG_WRITE;
++	msg.hss_port = port->id;
++
++	msg.index = HSS_CONFIG_TX_LUT;
++	msg.data32 = 0xffffffff;
++	npe_send_message(npe, &msg, "HSS_SET_TX_LUT");
++	msg.index += 4;
++	npe_send_message(npe, &msg, "HSS_SET_TX_LUT");
++	msg.data32 = 0x0;
++	msg.index += 4;
++	npe_send_message(npe, &msg, "HSS_SET_TX_LUT");
++	msg.index += 4;
++	npe_send_message(npe, &msg, "HSS_SET_TX_LUT");
++	msg.index += 4;
++	npe_send_message(npe, &msg, "HSS_SET_TX_LUT");
++	msg.index += 4;
++	npe_send_message(npe, &msg, "HSS_SET_TX_LUT");
++	msg.index += 4;
++	npe_send_message(npe, &msg, "HSS_SET_TX_LUT");
++	msg.index += 4;
++	npe_send_message(npe, &msg, "HSS_SET_TX_LUT");
++
++	msg.index = HSS_CONFIG_RX_LUT;
++	msg.data32 = 0xffffffff;
++	npe_send_message(npe, &msg, "HSS_SET_RX_LUT");
++	msg.index += 4;
++	npe_send_message(npe, &msg, "HSS_SET_RX_LUT");
++	msg.data32 = 0x0;
++	msg.index += 4;
++	npe_send_message(npe, &msg, "HSS_SET_RX_LUT");
++	msg.index += 4;
++	npe_send_message(npe, &msg, "HSS_SET_RX_LUT");
++	msg.index += 4;
++	npe_send_message(npe, &msg, "HSS_SET_RX_LUT");
++	msg.index += 4;
++	npe_send_message(npe, &msg, "HSS_SET_RX_LUT");
++	msg.index += 4;
++	npe_send_message(npe, &msg, "HSS_SET_RX_LUT");
++	msg.index += 4;
++	npe_send_message(npe, &msg, "HSS_SET_RX_LUT");
++
++	hss_config_set_frame(port);
++
++	memset(&msg, 0, sizeof(msg));
++	msg.cmd = CHAN_NUM_CHANS_WRITE;
++	msg.hss_port = port->id;
++	msg.data8a = chan_count;
++	if (npe_send_message(npe, &msg, "CHAN_NUM_CHANS_WRITE")) {
++		printk(KERN_CRIT "HSS-%i: unable to set HSS channel count\n",
++		       port->id);
++		BUG();
++	}
++}
++
++static u32 hss_config_get_status(struct port *port)
++{
++	struct msg msg;
++
++	do {
++		memset(&msg, 0, sizeof(msg));
++		msg.cmd = PORT_ERROR_READ;
++		msg.hss_port = port->id;
++		if (npe_send_message(npe, &msg, "PORT_ERROR_READ"))
++			break;
++		if (npe_recv_message(npe, &msg, "PORT_ERROR_READ"))
++			break;
++
++		return msg.data32;
++	} while (0);
++
++	printk(KERN_CRIT "HSS-%i: unable to read HSS status\n", port->id);
++	BUG();
++}
++
++static void hss_config_start_chan(struct port *port)
++{
++	struct msg msg;
++
++	port->chan_last_tx = 0;
++	port->chan_last_rx = 0;
++
++	do {
++		memset(&msg, 0, sizeof(msg));
++		msg.cmd = CHAN_RX_BUF_ADDR_WRITE;
++		msg.hss_port = port->id;
++		msg.data32 = port->chan_rx_buf_phys;
++		if (npe_send_message(npe, &msg, "CHAN_RX_BUF_ADDR_WRITE"))
++			break;
++
++		memset(&msg, 0, sizeof(msg));
++		msg.cmd = CHAN_TX_BUF_ADDR_WRITE;
++		msg.hss_port = port->id;
++		msg.data32 = port->chan_tx_pointers_phys;
++		if (npe_send_message(npe, &msg, "CHAN_TX_BUF_ADDR_WRITE"))
++			break;
++
++		memset(&msg, 0, sizeof(msg));
++		msg.cmd = CHAN_FLOW_ENABLE;
++		msg.hss_port = port->id;
++		if (npe_send_message(npe, &msg, "CHAN_FLOW_ENABLE"))
++			break;
++		port->chan_started = 1;
++		return;
++	} while (0);
++
++	printk(KERN_CRIT "HSS-%i: unable to start channelized flow\n",
++	       port->id);
++	BUG();
++}
++
++static void hss_config_stop_chan(struct port *port)
++{
++	struct msg msg;
++
++	if (!port->chan_started)
++		return;
++
++	memset(&msg, 0, sizeof(msg));
++	msg.cmd = CHAN_FLOW_DISABLE;
++	msg.hss_port = port->id;
++	if (npe_send_message(npe, &msg, "CHAN_FLOW_DISABLE")) {
++		printk(KERN_CRIT "HSS-%i: unable to stop channelized flow\n",
++		       port->id);
++		BUG();
++	}
++	hss_config_get_status(port); /* make sure it's halted */
++	port->chan_started = 0;
++}
++
++static int hss_config_load_firmware(struct port *port)
++{
++	struct msg msg;
++
++	if (port->initialized)
++		return 0;
++
++	if (!npe_running(npe)) {
++		int err;
++		if ((err = npe_load_firmware(npe, "NPE-A-HSS",
++					     port->dev)))
++			return err;
++	}
++
++	do {
++		/* HSS main configuration */
++		hss_config_set_line(port);
++
++		hss_config_set_frame(port);
++
++		/* Channelized operation settings */
++		memset(&msg, 0, sizeof(msg));
++		msg.cmd = CHAN_TX_BLK_CFG_WRITE;
++		msg.hss_port = port->id;
++		msg.data8b = (CHAN_TX_LIST_FRAMES & ~7) / 2;
++		msg.data8a = msg.data8b / 4;
++		msg.data8d = CHAN_TX_LIST_FRAMES - msg.data8b;
++		msg.data8c = msg.data8d / 4;
++		if (npe_send_message(npe, &msg, "CHAN_TX_BLK_CFG_WRITE"))
++			break;
++
++		memset(&msg, 0, sizeof(msg));
++		msg.cmd = CHAN_RX_BUF_CFG_WRITE;
++		msg.hss_port = port->id;
++		msg.data8a = CHAN_RX_TRIGGER / 8;
++		msg.data8b = CHAN_RX_FRAMES;
++		if (npe_send_message(npe, &msg, "CHAN_RX_BUF_CFG_WRITE"))
++			break;
++
++		memset(&msg, 0, sizeof(msg));
++		msg.cmd = CHAN_TX_BUF_SIZE_WRITE;
++		msg.hss_port = port->id;
++		msg.data8a = CHAN_TX_LISTS;
++		if (npe_send_message(npe, &msg, "CHAN_TX_BUF_SIZE_WRITE"))
++			break;
++
++		port->initialized = 1;
++		return 0;
++	} while (0);
++
++	printk(KERN_CRIT "HSS-%i: unable to start HSS operation\n", port->id);
++	BUG();
++}
++
++void hss_chan_irq(void *pdev)
++{
++	struct port *port = pdev;
++
++	qmgr_disable_irq(queue_ids[port->id].chan);
++
++	tasklet_hi_schedule(&port->task);
++}
++
++
++int hss_prepare_chan(struct port *port)
++{
++	int err, i, j;
++	u32 *temp;
++	u32 temp2;
++	u8 *temp3;
++
++	if (port->initialized)
++		return 0;
++
++	if ((err = hss_config_load_firmware(port)))
++		return err;
++
++	if ((err = qmgr_request_queue(queue_ids[port->id].chan,
++				      CHAN_QUEUE_LEN, 0, 0, "%s:hss", "hss")))
++		return err;
++
++	port->chan_tx_buf = dma_alloc_coherent(port->dev, chan_tx_buf_len(port), &port->chan_tx_buf_phys, GFP_DMA);
++	memset(port->chan_tx_buf, 0, chan_tx_buf_len(port));
++
++	port->chan_tx_pointers = dma_alloc_coherent(port->dev, chan_tx_buf_len(port) / CHAN_TX_LIST_FRAMES * 4, &port->chan_tx_pointers_phys, GFP_DMA);
++
++	temp3 = port->chan_tx_buf;
++	for (i = 0; i < CHAN_TX_LISTS; i++) {
++		for (j = 0; j < 8; j++) {
++			port->tx_lists[i][j] = temp3;
++			temp3 += CHAN_TX_LIST_FRAMES * 4;
++		}
++	}
++
++	temp = port->chan_tx_pointers;
++	temp2 = port->chan_tx_buf_phys;
++	for (i = 0; i < CHAN_TX_LISTS; i++)
++	{
++		for (j = 0; j < 32; j++)
++		{
++			*temp = temp2;
++			temp2 += CHAN_TX_LIST_FRAMES;
++			temp++;
++		}
++	}
++
++	port->chan_rx_buf = dma_alloc_coherent(port->dev, chan_rx_buf_len(port), &port->chan_rx_buf_phys, GFP_DMA);
++
++	for (i = 0; i < 8; i++) {
++		temp3 = port->chan_rx_buf + (i * 4 * 128);
++		for (j = 0; j < 8; j++) {
++			port->rx_frames[i][j] = temp3;
++			temp3 += CHAN_RX_TRIGGER;
++		}
++	}
++
++	qmgr_set_irq(queue_ids[port->id].chan, QUEUE_IRQ_SRC_NOT_EMPTY,
++		     hss_chan_irq, port);
++
++	return 0;
++
++}
++
++int hss_tx_start(struct hss_device *hdev)
++{
++	unsigned long flags;
++	struct port *port = hdev->port;
++
++	hdev->tx_loc = 0;
++	hdev->tx_frame = 0;
++
++	set_bit((1 << hdev->id), &port->chan_tx_bitmap);
++
++	if (!port->chan_started)
++	{
++		qmgr_enable_irq(queue_ids[port->id].chan);
++		spin_lock_irqsave(&npe_lock, flags);
++		hss_config_start_chan(port);
++		spin_unlock_irqrestore(&npe_lock, flags);
++		hss_chan_irq(port);
++	}
++
++	return 0;
++}
++EXPORT_SYMBOL(hss_tx_start);
++
++int hss_rx_start(struct hss_device *hdev)
++{
++	unsigned long flags;
++	struct port *port = hdev->port;
++
++	hdev->rx_loc = 0;
++	hdev->rx_frame = 0;
++
++	set_bit((1 << hdev->id), &port->chan_rx_bitmap);
++
++	if (!port->chan_started)
++	{
++		qmgr_enable_irq(queue_ids[port->id].chan);
++		spin_lock_irqsave(&npe_lock, flags);
++		hss_config_start_chan(port);
++		spin_unlock_irqrestore(&npe_lock, flags);
++		hss_chan_irq(port);
++	}
++
++	return 0;
++}
++EXPORT_SYMBOL(hss_rx_start);
++
++int hss_tx_stop(struct hss_device *hdev)
++{
++	struct port *port = hdev->port;
++
++	clear_bit((1 << hdev->id), &port->chan_tx_bitmap);
++
++	return 0;
++}
++EXPORT_SYMBOL(hss_tx_stop);
++
++int hss_rx_stop(struct hss_device *hdev)
++{
++	struct port *port = hdev->port;
++
++	clear_bit((1 << hdev->id), &port->chan_rx_bitmap);
++
++	return 0;
++}
++EXPORT_SYMBOL(hss_rx_stop);
++
++int hss_chan_open(struct hss_device *hdev)
++{
++	struct port *port = hdev->port;
++	int i, err = 0;
++
++	if (port->chan_open)
++		return 0;
++
++	if (port->mode == MODE_HDLC) {
++		err = -ENOSYS;
++		goto out;
++	}
++
++	if (port->mode == MODE_G704 && port->channels[0] == hdev->id) {
++		err = -EBUSY; /* channel #0 is used for G.704 signaling */
++		goto out;
++	}
++
++	for (i = MAX_CHANNELS; i > port->frame_size / 8; i--)
++		if (port->channels[i - 1] == hdev->id) {
++			err = -ECHRNG; /* frame too short */
++			goto out;
++		}
++
++	hdev->rx_loc = hdev->tx_loc = 0;
++	hdev->rx_frame = hdev->tx_frame = 0;
++
++	//clear_bit((1 << hdev->id), &port->chan_rx_bitmap);
++	//clear_bit((1 << hdev->id), &port->chan_tx_bitmap);
++
++	if (!port->initialized) {
++		hss_prepare_chan(port);
++
++		hss_config_stop_chan(port);
++		hdev->open_count++;
++		port->chan_open_count++;
++
++		hss_config_set_lut(port);
++		hss_config_load(port);
++
++	}
++	port->chan_open = 1;
++
++out:
++	return err;
++}
++EXPORT_SYMBOL(hss_chan_open);
++
++int hss_chan_close(struct hss_device *hdev)
++{
++	return 0;
++}
++EXPORT_SYMBOL(hss_chan_close);
++
++void hss_chan_read(unsigned long data)
++{
++	struct port *port = (void *)data;
++	struct hss_device *hdev;
++	u8 *hw_buf, *save_buf;
++	u8 *buf;
++	u32 v;
++  unsigned int tx_list, rx_frame;
++	int i, j, channel;
++	u8 more_work = 0;
++
++/*
++	My Data in the hardware buffer is scattered by channels into 4 trunks
++	as follows for rx
++
++					channel 0					channel 1					channel 2					channel 3
++Trunk 1	=	0			-> 	127			128		->	255			256		->	383			384		->	512
++Trunk 2 =	513		->	639			640		->	768			769		->	895			896		->	1023
++Trunk 3 =	1024	->	1151		1152	->	1207		1208	->	1407		1408	->	1535
++Trunk 4 = 1535	->	1663		1664	->	1791		1792	->	1920		1921	->	2047
++
++	I will get CHAN_RX_TRIGGER worth of bytes out of each channel on each trunk
++	with each IRQ
++
++	For TX Data, it is split into 8 lists with each list containing 16 bytes per
++	channel
++
++Trunk 1 = 0		->	16				17		->	32			33		->	48			49		->	64
++Trunk 2 = 65	->	80				81		->	96			97		->	112			113		->	128
++Trunk	3	=	129	->	144				145		->	160			161		->	176			177		->	192
++Trunk	4	=	193	->	208				209		->	224			225		->	240			241		->	256
++
++*/
++
++
++	while ((v = qmgr_get_entry(queue_ids[port->id].chan)))
++	{
++		tx_list = (v >> 8) & 0xFF;
++		rx_frame = v & 0xFF;
++
++		if (tx_list == 7)
++			tx_list = 0;
++		else
++			tx_list++;
++		for (channel = 0; channel < 8; channel++) {
++
++			hdev = port->chan_devices[channel];
++			if (!hdev)
++				continue;
++
++			if (test_bit(1 << channel, &port->chan_tx_bitmap)) {
++				buf = (u8 *)hdev->tx_buf + hdev->tx_loc;
++#if 0
++				hw_buf = (u8 *)port->chan_tx_buf;
++				hw_buf += (tx_list * CHAN_TX_LIST_FRAMES * 32);
++				hw_buf += (4 * CHAN_TX_LIST_FRAMES * channel);
++				save_buf = hw_buf;
++#else
++				save_buf = port->tx_lists[tx_list][channel];
++#endif
++				for (i = 0; i < CHAN_TX_LIST_FRAMES; i++) {
++					hw_buf = save_buf + i;
++					for (j = 0; j < 4; j++) {
++						*hw_buf = *(buf++);
++						hw_buf += CHAN_TX_LIST_FRAMES;
++					}
++
++					hdev->tx_loc += 4;
++					hdev->tx_frame++;
++					if (hdev->tx_loc >= hdev->tx_buffer_size) {
++						hdev->tx_loc = 0;
++						buf = (u8 *)hdev->tx_buf;
++					}
++				}
++			} else {
++#if 0
++				hw_buf = (u8 *)port->chan_tx_buf;
++				hw_buf += (tx_list * CHAN_TX_LIST_FRAMES * 32);
++				hw_buf += (4 * CHAN_TX_LIST_FRAMES * channel);
++#else
++				hw_buf = port->tx_lists[tx_list][channel];
++#endif
++				memset(hw_buf, 0, 64);
++			}
++
++			if (hdev->tx_frame >= hdev->tx_period_size && test_bit(1 << channel, &port->chan_tx_bitmap))
++			{
++				hdev->tx_frame %= hdev->tx_period_size;
++				if (hdev->tx_callback)
++					hdev->tx_callback(hdev->tx_data);
++				more_work = 1;
++			}
++
++			if (test_bit(1 << channel, &port->chan_rx_bitmap)) {
++				buf = (u8 *)hdev->rx_buf + hdev->rx_loc;
++#if 0
++				hw_buf = (u8 *)port->chan_rx_buf;
++				hw_buf += (4 * CHAN_RX_FRAMES * channel);
++				hw_buf += rx_frame;
++				save_buf = hw_buf;
++#else
++				save_buf = port->rx_frames[channel][rx_frame >> 4];
++#endif
++				for (i = 0; i < CHAN_RX_TRIGGER; i++) {
++					hw_buf = save_buf + i;
++					for (j = 0; j < 4; j++) {
++						*(buf++) = *hw_buf;
++						hw_buf += CHAN_RX_FRAMES;
++					}
++					hdev->rx_loc += 4;
++					hdev->rx_frame++;
++					if (hdev->rx_loc >= hdev->rx_buffer_size) {
++						hdev->rx_loc = 0;
++						buf = (u8 *)hdev->rx_buf;
++					}
++				}
++			}
++
++			if (hdev->rx_frame >= hdev->rx_period_size && test_bit(1 << channel, &port->chan_rx_bitmap))
++			{
++				hdev->rx_frame %= hdev->rx_period_size;
++				if (hdev->rx_callback)
++					hdev->rx_callback(hdev->rx_data);
++				more_work = 1;
++			}
++		}
++#if 0
++		if (more_work)
++		{
++			tasklet_hi_schedule(&port->task);
++			return;
++		}
++#endif
++	}
++
++	qmgr_enable_irq(queue_ids[port->id].chan);
++
++	return;
++
++}
++
++struct hss_device *hss_chan_create(struct port *port, unsigned int channel)
++{
++	struct hss_device *chan_dev;
++	unsigned long flags;
++
++	chan_dev = kzalloc(sizeof(struct hss_device), GFP_KERNEL);
++
++	spin_lock_irqsave(&npe_lock, flags);
++
++	chan_dev->id = channel;
++	chan_dev->port = port;
++
++	port->channels[channel] = channel;
++
++	port->chan_devices[channel] = chan_dev;
++
++	spin_unlock_irqrestore(&npe_lock, flags);
++
++	return chan_dev;
++}
++
++/*****************************************************************************
++ * initialization
++ ****************************************************************************/
++
++static struct platform_device gw_avila_hss_device_0 = {
++  .name     = "ixp4xx_hss",
++  .id       = 0,
++};
++
++static struct platform_device gw_avila_hss_device_1 = {
++  .name     = "ixp4xx_hss",
++  .id       = 1,
++};
++
++static struct platform_device *gw_avila_hss_port_0;
++static struct platform_device *gw_avila_hss_port_1;
++static u64 hss_dmamask = 0xFFFFFFFF;
++
++struct hss_device *hss_init(int id, int channel)
++{
++	struct port *port = hss_port[id];
++	struct hss_device *hdev;
++	int ret;
++
++	if (!lock_init)
++	{
++		spin_lock_init(&npe_lock);
++		lock_init = 1;
++		npe = npe_request(0);
++	}
++
++	if (!port->init) {
++		if (id == 0) {
++			gw_avila_hss_port_0 = platform_device_alloc("hss-port", 0);
++
++			platform_set_drvdata(gw_avila_hss_port_0, &gw_avila_hss_device_0);
++			port->dev = &gw_avila_hss_port_0->dev;
++
++			if (!port->dev->dma_mask)
++		    port->dev->dma_mask = &hss_dmamask;
++		  if (!port->dev->coherent_dma_mask)
++	    	port->dev->coherent_dma_mask = 0xFFFFFFFF;
++
++			ret = platform_device_add(gw_avila_hss_port_0);
++
++		  if (ret)
++	  	  platform_device_put(gw_avila_hss_port_0);
++
++			tasklet_init(&port->task, hss_chan_read, (unsigned long) port);
++		}
++		else
++		{
++			gw_avila_hss_port_1 = platform_device_alloc("hss-port", 1);
++
++			platform_set_drvdata(gw_avila_hss_port_1, &gw_avila_hss_device_1);
++			port->dev = &gw_avila_hss_port_1->dev;
++
++			if (!port->dev->dma_mask)
++		    port->dev->dma_mask = &hss_dmamask;
++		  if (!port->dev->coherent_dma_mask)
++	    	port->dev->coherent_dma_mask = 0xFFFFFFFF;
++
++			ret = platform_device_add(gw_avila_hss_port_1);
++
++		  if (ret)
++	  	  platform_device_put(gw_avila_hss_port_1);
++
++			tasklet_init(&port->task, hss_chan_read, (unsigned long) port);
++		}
++
++		port->init = 1;
++		port->id = id;
++		port->clock_type = CLOCK_EXT;
++		port->clock_rate = 8192000;
++		port->frame_size = 256; /* E1 */
++		port->mode = MODE_RAW;
++		port->next_rx_frame = 0;
++		memset(port->channels, CHANNEL_UNUSED, sizeof(port->channels));
++	}
++
++	hdev = hss_chan_create(port, channel);
++
++	return hdev;
++}
++EXPORT_SYMBOL(hss_init);
++
++int hss_set_tx_callback(struct hss_device *hdev, void (*tx_callback)(void *), void *tx_data)
++{
++  BUG_ON(tx_callback == NULL);
++  hdev->tx_callback = tx_callback;
++  hdev->tx_data = tx_data;
++
++  return 0;
++}
++EXPORT_SYMBOL(hss_set_tx_callback);
++
++int hss_set_rx_callback(struct hss_device *hdev, void (*rx_callback)(void *), void *rx_data)
++{
++  BUG_ON(rx_callback == NULL);
++  hdev->rx_callback = rx_callback;
++  hdev->rx_data = rx_data;
++
++  return 0;
++}
++EXPORT_SYMBOL(hss_set_rx_callback);
++
++int hss_config_rx_dma(struct hss_device *hdev, void *buf, size_t buffer_size, size_t period_size)
++{
++	/*
++	 * Period Size and Buffer Size are in Frames which are u32
++	 * We convert the u32 *buf to u8 in order to make channel reads
++	 * and rx_loc easier
++	 */
++
++	hdev->rx_buf = (u8 *)buf;
++	hdev->rx_buffer_size = buffer_size << 2;
++	hdev->rx_period_size = period_size;
++
++	return 0;
++}
++EXPORT_SYMBOL(hss_config_rx_dma);
++
++int hss_config_tx_dma(struct hss_device *hdev, void *buf, size_t buffer_size, size_t period_size)
++{
++	/*
++	 * Period Size and Buffer Size are in Frames which are u32
++	 * We convert the u32 *buf to u8 in order to make channel reads
++	 * and rx_loc easier
++	 */
++
++	hdev->tx_buf = (u8 *)buf;
++	hdev->tx_buffer_size = buffer_size << 2;
++	hdev->tx_period_size = period_size;
++
++	return 0;
++}
++EXPORT_SYMBOL(hss_config_tx_dma);
++
++unsigned long hss_curr_offset_rx(struct hss_device *hdev)
++{
++	return hdev->rx_loc >> 2;
++}
++EXPORT_SYMBOL(hss_curr_offset_rx);
++
++unsigned long hss_curr_offset_tx(struct hss_device *hdev)
++{
++	return hdev->tx_loc >> 2;
++}
++EXPORT_SYMBOL(hss_curr_offset_tx);
++
++MODULE_AUTHOR("Chris Lang");
++MODULE_DESCRIPTION("Intel IXP4xx HSS Audio driver");
++MODULE_LICENSE("GPL v2");
+--- /dev/null
++++ b/sound/soc/gw-avila/ixp4xx_hss.h
+@@ -0,0 +1,401 @@
++/*
++ *
++ *
++ * Copyright (C) 2009 Gateworks Corporation
++ *
++ * This program is free software; you can redistribute it and/or modify it
++ * under the terms of version 2 of the GNU General Public License
++ * as published by the Free Software Foundation.
++ */
++
++#include <linux/types.h>
++#include <linux/bitops.h>
++#include <linux/dma-mapping.h>
++#include <linux/dmapool.h>
++#include <linux/fs.h>
++#include <linux/io.h>
++#include <linux/kernel.h>
++#include <linux/platform_device.h>
++#include <linux/poll.h>
++#include <mach/npe.h>
++#include <mach/qmgr.h>
++#include <linux/interrupt.h>
++
++//#include <linux/hdlc.h> XXX We aren't HDLC
++
++#define DEBUG_QUEUES		0
++#define DEBUG_DESC		0
++#define DEBUG_RX		0
++#define DEBUG_TX		0
++#define DEBUG_PKT_BYTES		0
++#define DEBUG_CLOSE		0
++#define DEBUG_FRAMER		0
++
++#define DRV_NAME		"ixp4xx_hss"
++
++#define PKT_EXTRA_FLAGS		0 /* orig 1 */
++#define TX_FRAME_SYNC_OFFSET	0 /* channelized */
++#define PKT_NUM_PIPES		1 /* 1, 2 or 4 */
++#define PKT_PIPE_FIFO_SIZEW	4 /* total 4 dwords per HSS */
++
++#define RX_DESCS		512 /* also length of all RX queues */
++#define TX_DESCS		512 /* also length of all TX queues */
++
++//#define POOL_ALLOC_SIZE		(sizeof(struct desc) * (RX_DESCS + TX_DESCS))
++#define RX_SIZE			(HDLC_MAX_MRU + 4) /* NPE needs more space */
++#define MAX_CLOSE_WAIT		1000 /* microseconds */
++#define HSS_COUNT		2
++#define MIN_FRAME_SIZE		16   /* bits */
++#define MAX_FRAME_SIZE		257  /* 256 bits + framing bit */
++#define MAX_CHANNELS		(MAX_FRAME_SIZE / 8)
++#define MAX_CHAN_DEVICES	32
++#define CHANNEL_HDLC		0xFE
++#define CHANNEL_UNUSED		0xFF
++
++#define NAPI_WEIGHT		16
++#define CHAN_RX_TRIGGER		16 /* 8 RX frames = 1 ms @ E1 */
++#define CHAN_RX_FRAMES		128
++#define CHAN_RX_TRUNKS		1
++#define MAX_CHAN_RX_BAD_SYNC	(CHAN_RX_TRIGGER / 2 /* pairs */ - 3)
++
++#define CHAN_TX_LIST_FRAMES	CHAN_RX_TRIGGER /* bytes/channel per list, 16 - 48 */
++#define CHAN_TX_LISTS		8
++#define CHAN_TX_TRUNKS CHAN_RX_TRUNKS
++#define CHAN_TX_FRAMES		(CHAN_TX_LIST_FRAMES * CHAN_TX_LISTS)
++
++#define CHAN_QUEUE_LEN		32 /* minimum possible */
++
++#define chan_rx_buf_len(port)	(port->frame_size / 8 * CHAN_RX_FRAMES * CHAN_RX_TRUNKS)
++#define chan_tx_buf_len(port) (port->frame_size / 8 * CHAN_TX_FRAMES * CHAN_TX_TRUNKS)
++
++/* Queue IDs */
++#define HSS0_CHL_RXTRIG_QUEUE	12	/* orig size = 32 dwords */
++#define HSS0_PKT_RX_QUEUE	13	/* orig size = 32 dwords */
++#define HSS0_PKT_TX0_QUEUE	14	/* orig size = 16 dwords */
++#define HSS0_PKT_TX1_QUEUE	15
++#define HSS0_PKT_TX2_QUEUE	16
++#define HSS0_PKT_TX3_QUEUE	17
++#define HSS0_PKT_RXFREE0_QUEUE	18	/* orig size = 16 dwords */
++#define HSS0_PKT_RXFREE1_QUEUE	19
++#define HSS0_PKT_RXFREE2_QUEUE	20
++#define HSS0_PKT_RXFREE3_QUEUE	21
++#define HSS0_PKT_TXDONE_QUEUE	22	/* orig size = 64 dwords */
++
++#define HSS1_CHL_RXTRIG_QUEUE	10
++#define HSS1_PKT_RX_QUEUE	0
++#define HSS1_PKT_TX0_QUEUE	5
++#define HSS1_PKT_TX1_QUEUE	6
++#define HSS1_PKT_TX2_QUEUE	7
++#define HSS1_PKT_TX3_QUEUE	8
++#define HSS1_PKT_RXFREE0_QUEUE	1
++#define HSS1_PKT_RXFREE1_QUEUE	2
++#define HSS1_PKT_RXFREE2_QUEUE	3
++#define HSS1_PKT_RXFREE3_QUEUE	4
++#define HSS1_PKT_TXDONE_QUEUE	9
++
++#define NPE_PKT_MODE_HDLC		0
++#define NPE_PKT_MODE_RAW		1
++#define NPE_PKT_MODE_56KMODE		2
++#define NPE_PKT_MODE_56KENDIAN_MSB	4
++
++/* PKT_PIPE_HDLC_CFG_WRITE flags */
++#define PKT_HDLC_IDLE_ONES		0x1 /* default = flags */
++#define PKT_HDLC_CRC_32			0x2 /* default = CRC-16 */
++#define PKT_HDLC_MSB_ENDIAN		0x4 /* default = LE */
++
++
++/* hss_config, PCRs */
++/* Frame sync sampling, default = active low */
++#define PCR_FRM_SYNC_ACTIVE_HIGH	0x40000000
++#define PCR_FRM_SYNC_FALLINGEDGE	0x80000000
++#define PCR_FRM_SYNC_RISINGEDGE		0xC0000000
++
++/* Frame sync pin: input (default) or output generated off a given clk edge */
++#define PCR_FRM_SYNC_OUTPUT_FALLING	0x20000000
++#define PCR_FRM_SYNC_OUTPUT_RISING	0x30000000
++
++/* Frame and data clock sampling on edge, default = falling */
++#define PCR_FCLK_EDGE_RISING		0x08000000
++#define PCR_DCLK_EDGE_RISING		0x04000000
++
++/* Clock direction, default = input */
++#define PCR_SYNC_CLK_DIR_OUTPUT		0x02000000
++
++/* Generate/Receive frame pulses, default = enabled */
++#define PCR_FRM_PULSE_DISABLED		0x01000000
++
++ /* Data rate is full (default) or half the configured clk speed */
++#define PCR_HALF_CLK_RATE		0x00200000
++
++/* Invert data between NPE and HSS FIFOs? (default = no) */
++#define PCR_DATA_POLARITY_INVERT	0x00100000
++
++/* TX/RX endianness, default = LSB */
++#define PCR_MSB_ENDIAN			0x00080000
++
++/* Normal (default) / open drain mode (TX only) */
++#define PCR_TX_PINS_OPEN_DRAIN		0x00040000
++
++/* No framing bit transmitted and expected on RX? (default = framing bit) */
++#define PCR_SOF_NO_FBIT			0x00020000
++
++/* Drive data pins? */
++#define PCR_TX_DATA_ENABLE		0x00010000
++
++/* Voice 56k type: drive the data pins low (default), high, high Z */
++#define PCR_TX_V56K_HIGH		0x00002000
++#define PCR_TX_V56K_HIGH_IMP		0x00004000
++
++/* Unassigned type: drive the data pins low (default), high, high Z */
++#define PCR_TX_UNASS_HIGH		0x00000800
++#define PCR_TX_UNASS_HIGH_IMP		0x00001000
++
++/* T1 @ 1.544MHz only: Fbit dictated in FIFO (default) or high Z */
++#define PCR_TX_FB_HIGH_IMP		0x00000400
++
++/* 56k data endiannes - which bit unused: high (default) or low */
++#define PCR_TX_56KE_BIT_0_UNUSED	0x00000200
++
++/* 56k data transmission type: 32/8 bit data (default) or 56K data */
++#define PCR_TX_56KS_56K_DATA		0x00000100
++
++/* hss_config, cCR */
++/* Number of packetized clients, default = 1 */
++#define CCR_NPE_HFIFO_2_HDLC		0x04000000
++#define CCR_NPE_HFIFO_3_OR_4HDLC	0x08000000
++
++/* default = no loopback */
++#define CCR_LOOPBACK			0x02000000
++
++/* HSS number, default = 0 (first) */
++#define CCR_SECOND_HSS			0x01000000
++
++
++/* hss_config, clkCR: main:10, num:10, denom:12 */
++#define CLK42X_SPEED_EXP	((0x3FF << 22) | (  2 << 12) |   15) /*65 KHz*/
++
++#define CLK42X_SPEED_512KHZ	((  130 << 22) | (  2 << 12) |   15)
++#define CLK42X_SPEED_1536KHZ	((   43 << 22) | ( 18 << 12) |   47)
++#define CLK42X_SPEED_1544KHZ	((   43 << 22) | ( 33 << 12) |  192)
++#define CLK42X_SPEED_2048KHZ	((   32 << 22) | ( 34 << 12) |   63)
++#define CLK42X_SPEED_4096KHZ	((   16 << 22) | ( 34 << 12) |  127)
++#define CLK42X_SPEED_8192KHZ	((    8 << 22) | ( 34 << 12) |  255)
++
++#define CLK46X_SPEED_512KHZ	((  130 << 22) | ( 24 << 12) |  127)
++#define CLK46X_SPEED_1536KHZ	((   43 << 22) | (152 << 12) |  383)
++#define CLK46X_SPEED_1544KHZ	((   43 << 22) | ( 66 << 12) |  385)
++#define CLK46X_SPEED_2048KHZ	((   32 << 22) | (280 << 12) |  511)
++#define CLK46X_SPEED_4096KHZ	((   16 << 22) | (280 << 12) | 1023)
++#define CLK46X_SPEED_8192KHZ	((    8 << 22) | (280 << 12) | 2047)
++
++
++/* hss_config, LUT entries */
++#define TDMMAP_UNASSIGNED	0
++#define TDMMAP_HDLC		1	/* HDLC - packetized */
++#define TDMMAP_VOICE56K		2	/* Voice56K - 7-bit channelized */
++#define TDMMAP_VOICE64K		3	/* Voice64K - 8-bit channelized */
++
++/* offsets into HSS config */
++#define HSS_CONFIG_TX_PCR	0x00 /* port configuration registers */
++#define HSS_CONFIG_RX_PCR	0x04
++#define HSS_CONFIG_CORE_CR	0x08 /* loopback control, HSS# */
++#define HSS_CONFIG_CLOCK_CR	0x0C /* clock generator control */
++#define HSS_CONFIG_TX_FCR	0x10 /* frame configuration registers */
++#define HSS_CONFIG_RX_FCR	0x14
++#define HSS_CONFIG_TX_LUT	0x18 /* channel look-up tables */
++#define HSS_CONFIG_RX_LUT	0x38
++
++
++/* NPE command codes */
++/* writes the ConfigWord value to the location specified by offset */
++#define PORT_CONFIG_WRITE		0x40
++
++/* triggers the NPE to load the contents of the configuration table */
++#define PORT_CONFIG_LOAD		0x41
++
++/* triggers the NPE to return an HssErrorReadResponse message */
++#define PORT_ERROR_READ			0x42
++
++/* reset NPE internal status and enable the HssChannelized operation */
++#define CHAN_FLOW_ENABLE		0x43
++#define CHAN_FLOW_DISABLE		0x44
++#define CHAN_IDLE_PATTERN_WRITE		0x45
++#define CHAN_NUM_CHANS_WRITE		0x46
++#define CHAN_RX_BUF_ADDR_WRITE		0x47
++#define CHAN_RX_BUF_CFG_WRITE		0x48
++#define CHAN_TX_BLK_CFG_WRITE		0x49
++#define CHAN_TX_BUF_ADDR_WRITE		0x4A
++#define CHAN_TX_BUF_SIZE_WRITE		0x4B
++#define CHAN_TSLOTSWITCH_ENABLE		0x4C
++#define CHAN_TSLOTSWITCH_DISABLE	0x4D
++
++/* downloads the gainWord value for a timeslot switching channel associated
++   with bypassNum */
++#define CHAN_TSLOTSWITCH_GCT_DOWNLOAD	0x4E
++
++/* triggers the NPE to reset internal status and enable the HssPacketized
++   operation for the flow specified by pPipe */
++#define PKT_PIPE_FLOW_ENABLE		0x50
++#define PKT_PIPE_FLOW_DISABLE		0x51
++#define PKT_NUM_PIPES_WRITE		0x52
++#define PKT_PIPE_FIFO_SIZEW_WRITE	0x53
++#define PKT_PIPE_HDLC_CFG_WRITE		0x54
++#define PKT_PIPE_IDLE_PATTERN_WRITE	0x55
++#define PKT_PIPE_RX_SIZE_WRITE		0x56
++#define PKT_PIPE_MODE_WRITE		0x57
++
++/* HDLC packet status values - desc->status */
++#define ERR_SHUTDOWN		1 /* stop or shutdown occurrance */
++#define ERR_HDLC_ALIGN		2 /* HDLC alignment error */
++#define ERR_HDLC_FCS		3 /* HDLC Frame Check Sum error */
++#define ERR_RXFREE_Q_EMPTY	4 /* RX-free queue became empty while receiving
++				     this packet (if buf_len < pkt_len) */
++#define ERR_HDLC_TOO_LONG	5 /* HDLC frame size too long */
++#define ERR_HDLC_ABORT		6 /* abort sequence received */
++#define ERR_DISCONNECTING	7 /* disconnect is in progress */
++
++#define CLOCK_EXT 0
++#define CLOCK_INT 1
++
++enum mode {MODE_HDLC = 0, MODE_RAW, MODE_G704};
++enum rx_tx_bit {
++	TX_BIT = 0,
++	RX_BIT = 1
++};
++enum chan_bit {
++	CHAN_0 = (1 << 0),
++	CHAN_1 = (1 << 1),
++	CHAN_2 = (1 << 2),
++	CHAN_3 = (1 << 3),
++	CHAN_4 = (1 << 4),
++	CHAN_5 = (1 << 5),
++	CHAN_6 = (1 << 6),
++	CHAN_7 = (1 << 7),
++	CHAN_8 = (1 << 8),
++	CHAN_9 = (1 << 9),
++	CHAN_10 = (1 << 10),
++	CHAN_11 = (1 << 11),
++	CHAN_12 = (1 << 12),
++	CHAN_13 = (1 << 13),
++	CHAN_14 = (1 << 14),
++	CHAN_15 = (1 << 15)
++};
++
++enum alignment { NOT_ALIGNED = 0, EVEN_FIRST, ODD_FIRST };
++
++#ifdef __ARMEB__
++typedef struct sk_buff buffer_t;
++#define free_buffer dev_kfree_skb
++#define free_buffer_irq dev_kfree_skb_irq
++#else
++typedef void buffer_t;
++#define free_buffer kfree
++#define free_buffer_irq kfree
++#endif
++
++struct hss_device {
++	struct port *port;
++	unsigned int open_count, excl_open;
++	unsigned long tx_loc, rx_loc; /* bytes */
++	unsigned long tx_frame, rx_frame; /* Frames */
++	u8 id, chan_count;
++	u8 log_channels[MAX_CHANNELS];
++
++  u8 *rx_buf;
++  u8 *tx_buf;
++
++	size_t rx_buffer_size;
++	size_t rx_period_size;
++	size_t tx_buffer_size;
++	size_t tx_period_size;
++
++  void (*rx_callback)(void *data);
++  void *rx_data;
++  void (*tx_callback)(void *data);
++  void *tx_data;
++  void *private_data;
++};
++
++extern struct hss_device *hss_handle[32];
++extern struct port *hss_port[2];
++
++struct port {
++	unsigned char init;
++
++	struct device *dev;
++
++	struct tasklet_struct task;
++	unsigned int id;
++	unsigned long chan_rx_bitmap;
++	unsigned long chan_tx_bitmap;
++	unsigned char chan_open;
++
++	/* the following fields must be protected by npe_lock */
++	enum mode mode;
++	unsigned int clock_type, clock_rate, loopback;
++	unsigned int frame_size, frame_sync_offset;
++	unsigned int next_rx_frame;
++
++	struct hss_device *chan_devices[MAX_CHAN_DEVICES];
++	u32 chan_tx_buf_phys, chan_rx_buf_phys;
++	u32	chan_tx_pointers_phys;
++	u32 *chan_tx_pointers;
++	u8 *chan_rx_buf;
++	u8 *chan_tx_buf;
++	u8 *tx_lists[CHAN_TX_LISTS][8];
++	u8 *rx_frames[8][CHAN_TX_LISTS];
++	unsigned int chan_open_count, hdlc_open;
++	unsigned int chan_started, initialized, just_set_offset;
++	unsigned int chan_last_rx, chan_last_tx;
++
++	/* assigned channels, may be invalid with given frame length or mode */
++	u8 channels[MAX_CHANNELS];
++	int msg_count;
++};
++
++/* NPE message structure */
++struct msg {
++#ifdef __ARMEB__
++	u8 cmd, unused, hss_port, index;
++	union {
++		struct { u8 data8a, data8b, data8c, data8d; };
++		struct { u16 data16a, data16b; };
++		struct { u32 data32; };
++	};
++#else
++	u8 index, hss_port, unused, cmd;
++	union {
++		struct { u8 data8d, data8c, data8b, data8a; };
++		struct { u16 data16b, data16a; };
++		struct { u32 data32; };
++	};
++#endif
++};
++
++#define rx_desc_phys(port, n)	((port)->desc_tab_phys +		\
++				 (n) * sizeof(struct desc))
++#define rx_desc_ptr(port, n)	(&(port)->desc_tab[n])
++
++#define tx_desc_phys(port, n)	((port)->desc_tab_phys +		\
++				 ((n) + RX_DESCS) * sizeof(struct desc))
++#define tx_desc_ptr(port, n)	(&(port)->desc_tab[(n) + RX_DESCS])
++
++int hss_prepare_chan(struct port *port);
++void hss_chan_stop(struct port *port);
++
++struct hss_device *hss_init(int id, int channel);
++int hss_chan_open(struct hss_device *hdev);
++int hss_chan_close(struct hss_device *hdev);
++
++int hss_set_tx_callback(struct hss_device *hdev, void (*tx_callback)(void *), void *tx_data);
++int hss_set_rx_callback(struct hss_device *hdev, void (*rx_callback)(void *), void *rx_data);
++int hss_tx_start(struct hss_device *hdev);
++int hss_tx_stop(struct hss_device *hdev);
++int hss_rx_start(struct hss_device *hdev);
++int hss_rx_stop(struct hss_device *hdev);
++
++int hss_config_rx_dma(struct hss_device *hdev, void *buf, size_t buffer_size, size_t period_size);
++int hss_config_tx_dma(struct hss_device *hdev, void *buf, size_t buffer_size, size_t period_size);
++unsigned long hss_curr_offset_rx(struct hss_device *hdev);
++unsigned long hss_curr_offset_tx(struct hss_device *hdev);
++
+--- a/arch/arm/mach-ixp4xx/avila-setup.c
++++ b/arch/arm/mach-ixp4xx/avila-setup.c
+@@ -333,6 +333,54 @@ static struct platform_device avila_gpio
+ 	.id     = -1,
+ };
+ 
++/*
++ * Audio Devices
++ */
++
++static struct platform_device avila_hss_device[] = {
++	{
++		.name = "gw_avila_hss",
++		.id = 0,
++	},{
++		.name = "gw_avila_hss",
++		.id = 1,
++	},{
++		.name = "gw_avila_hss",
++		.id = 2,
++	},{
++		.name = "gw_avila_hss",
++		.id = 3,
++	},
++};
++
++static struct platform_device avila_pcm_device[] = {
++	{
++		.name = "gw_avila-audio",
++		.id = 0,
++	},{
++		.name = "gw_avila-audio",
++		.id = 1,
++	},{
++		.name = "gw_avila-audio",
++		.id = 2,
++	},{
++		.name = "gw_avila-audio",
++		.id = 3,
++	}
++};
++
++static void setup_audio_devices(void) {
++	platform_device_register(&avila_hss_device[0]);
++	platform_device_register(&avila_hss_device[1]);
++	platform_device_register(&avila_hss_device[2]);
++	platform_device_register(&avila_hss_device[3]);
++
++	platform_device_register(&avila_pcm_device[0]);
++	platform_device_register(&avila_pcm_device[1]);
++	platform_device_register(&avila_pcm_device[2]);
++	platform_device_register(&avila_pcm_device[3]);
++}
++
+ static void __init avila_gw23xx_setup(void)
+ {
+ 	platform_device_register(&avila_npeb_device);
+@@ -508,6 +556,8 @@ static void __init avila_gw2365_setup(vo
+ 	avila_gpio_leds[0].gpio = 109;
+ 	avila_gpio_leds_data.num_leds = 5;
+ 	platform_device_register(&avila_gpio_leds_device);
++
++	setup_audio_devices();
+ }
+ 
+ static void __init avila_gw2369_setup(void)
+@@ -517,6 +567,8 @@ static void __init avila_gw2369_setup(vo
+ 
+ 	avila_npec_data.phy = 2;
+ 	platform_device_register(&avila_npec_device);
++
++	setup_audio_devices();
+ }
+ 
+ static void __init avila_gw2370_setup(void)
+@@ -654,6 +706,18 @@ static struct i2c_board_info __initdata
+ 		I2C_BOARD_INFO("24c08", 0x51),
+ 		.platform_data	= &avila_eeprom_info
+ 	},
++	{
++		I2C_BOARD_INFO("tlv320aic33", 0x1b),
++	},
++	{
++		I2C_BOARD_INFO("tlv320aic33", 0x1a),
++	},
++	{
++		I2C_BOARD_INFO("tlv320aic33", 0x19),
++	},
++	{
++		I2C_BOARD_INFO("tlv320aic33", 0x18),
++	},
+ };
+ 
+ static void __init avila_init(void)
+--- a/sound/soc/codecs/tlv320aic3x.c
++++ b/sound/soc/codecs/tlv320aic3x.c
+@@ -985,6 +985,22 @@ static int aic3x_set_dai_sysclk(struct s
+ 	return 0;
+ }
+ 
++static int aic3x_set_tdm_slot(struct snd_soc_dai *codec_dai,
++	unsigned int tx_mask, unsigned int rx_mask,
++	int slots, int width)
++{
++	struct snd_soc_codec *codec = codec_dai->codec;
++	u8 iface_creg;
++
++	iface_creg = snd_soc_read(codec, AIC3X_ASD_INTF_CTRLC);
++
++	iface_creg = slots * width;
++
++	snd_soc_write(codec, AIC3X_ASD_INTF_CTRLC, iface_creg);
++
++	return 0;
++}
++
+ static int aic3x_set_dai_fmt(struct snd_soc_dai *codec_dai,
+ 			     unsigned int fmt)
+ {
+@@ -996,6 +1012,9 @@ static int aic3x_set_dai_fmt(struct snd_
+ 	iface_areg = snd_soc_read(codec, AIC3X_ASD_INTF_CTRLA) & 0x3f;
+ 	iface_breg = snd_soc_read(codec, AIC3X_ASD_INTF_CTRLB) & 0x3f;
+ 
++	iface_areg |= 0x30;
++	iface_breg |= 0x8;
++
+ 	/* set master/slave audio interface */
+ 	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+ 	case SND_SOC_DAIFMT_CBM_CFM:
+@@ -1227,6 +1246,7 @@ static struct snd_soc_dai_ops aic3x_dai_
+ 	.digital_mute	= aic3x_mute,
+ 	.set_sysclk	= aic3x_set_dai_sysclk,
+ 	.set_fmt	= aic3x_set_dai_fmt,
++	.set_tdm_slot	= aic3x_set_tdm_slot,
+ };
+ 
+ static struct snd_soc_dai_driver aic3x_dai = {
Index: trunk/target/linux/ixp4xx/patches-2.6.37/504-gw2369_support.patch
===================================================================
--- trunk/target/linux/ixp4xx/patches-2.6.37/504-gw2369_support.patch	(revision 0)
+++ trunk/target/linux/ixp4xx/patches-2.6.37/504-gw2369_support.patch	(revision 0)
@@ -0,0 +1,381 @@
+--- a/arch/arm/mach-ixp4xx/avila-setup.c
++++ b/arch/arm/mach-ixp4xx/avila-setup.c
+@@ -23,6 +23,7 @@
+ #include <linux/i2c.h>
+ #include <linux/i2c/at24.h>
+ #include <linux/leds.h>
++#include <linux/i2c/pca953x.h>
+ #include <linux/i2c-gpio.h>
+ #include <asm/types.h>
+ #include <asm/setup.h>
+@@ -32,6 +33,7 @@
+ #include <asm/irq.h>
+ #include <asm/mach/arch.h>
+ #include <asm/mach/flash.h>
++#include <linux/irq.h>
+ 
+ #define AVILA_SDA_PIN	7
+ #define AVILA_SCL_PIN	6
+@@ -126,58 +128,52 @@ static struct platform_device avila_uart
+ };
+ 
+ static struct resource avila_optional_uart_resources[] = {
+-  {
+-    .start  = 0x54000000,
+-    .end  = 0x54000fff,
+-    .flags  = IORESOURCE_MEM
+-  },
+-  {
+-    .start  = 0x55000000,
+-    .end  = 0x55000fff,
+-    .flags  = IORESOURCE_MEM
+-  },
+-  {
+-    .start  = 0x56000000,
+-    .end  = 0x56000fff,
+-    .flags  = IORESOURCE_MEM
+-  },
+-  {
+-    .start  = 0x57000000,
+-    .end  = 0x57000fff,
+-    .flags  = IORESOURCE_MEM
+-  }
++	{
++		.start  = 0x54000000,
++		.end  = 0x54000fff,
++		.flags  = IORESOURCE_MEM
++	},{
++		.start  = 0x55000000,
++		.end  = 0x55000fff,
++		.flags  = IORESOURCE_MEM
++	},{
++		.start  = 0x56000000,
++		.end  = 0x56000fff,
++		.flags  = IORESOURCE_MEM
++	},{
++		.start  = 0x57000000,
++		.end  = 0x57000fff,
++		.flags  = IORESOURCE_MEM
++	}
+ };
+ 
+ static struct plat_serial8250_port avila_optional_uart_data[] = {
+-  {
+-    .flags    = UPF_BOOT_AUTOCONF,
+-    .iotype   = UPIO_MEM,
+-    .regshift = 0,
+-    .uartclk  = 18432000,
+-    .rw_delay = 2,
+-  },
+-  {
+-    .flags    = UPF_BOOT_AUTOCONF,
+-    .iotype   = UPIO_MEM,
+-    .regshift = 0,
+-    .uartclk  = 18432000,
+-    .rw_delay = 2,
+-  },
+-  {
+-    .flags    = UPF_BOOT_AUTOCONF,
+-    .iotype   = UPIO_MEM,
+-    .regshift = 0,
+-    .uartclk  = 18432000,
+-    .rw_delay = 2,
+-  },
+-  {
+-    .flags    = UPF_BOOT_AUTOCONF,
+-    .iotype   = UPIO_MEM,
+-    .regshift = 0,
+-    .uartclk  = 18432000,
+-    .rw_delay = 2,
+-  },
+-  { },
++	{
++		.flags    = UPF_BOOT_AUTOCONF,
++		.iotype   = UPIO_MEM,
++		.regshift = 0,
++		.uartclk  = 18432000,
++		.rw_delay = 2,
++	},{
++		.flags    = UPF_BOOT_AUTOCONF,
++		.iotype   = UPIO_MEM,
++		.regshift = 0,
++		.uartclk  = 18432000,
++		.rw_delay = 2,
++	},{
++		.flags    = UPF_BOOT_AUTOCONF,
++		.iotype   = UPIO_MEM,
++		.regshift = 0,
++		.uartclk  = 18432000,
++		.rw_delay = 2,
++	},{
++		.flags    = UPF_BOOT_AUTOCONF,
++		.iotype   = UPIO_MEM,
++		.regshift = 0,
++		.uartclk  = 18432000,
++		.rw_delay = 2,
++	},
++	{ }
+ };
+ 
+ static struct platform_device avila_optional_uart = {
+@@ -191,11 +187,9 @@ static struct platform_device avila_opti
+ static struct resource avila_pata_resources[] = {
+ 	{
+ 		.flags	= IORESOURCE_MEM
+-	},
+-	{
++	},{
+ 		.flags	= IORESOURCE_MEM,
+-	},
+-	{
++	},{
+ 		.name	= "intrq",
+ 		.start	= IRQ_IXP4XX_GPIO12,
+ 		.end	= IRQ_IXP4XX_GPIO12,
+@@ -246,7 +240,28 @@ static struct gpio_led avila_gpio_leds[]
+ 		.name		= "user",  /* green led */
+ 		.gpio		= AVILA_GW23XX_LED_USER_GPIO,
+ 		.active_low	= 1,
+-	}
++	},
++	{
++		.name		= "radio1",  /* green led */
++		.gpio		= 104,
++		.active_low	= 1,
++	},
++	{
++		.name		= "radio2",  /* green led */
++		.gpio		= 105,
++		.active_low	= 1,
++	},
++	{
++		.name		= "radio3",  /* green led */
++		.gpio		= 106,
++		.active_low	= 1,
++	},
++	{
++		.name		= "radio4",  /* green led */
++		.gpio		= 107,
++		.active_low	= 1,
++	},
++
+ };
+ 
+ static struct gpio_led_platform_data avila_gpio_leds_data = {
+@@ -332,6 +347,17 @@ static void __init avila_gw2342_setup(vo
+ 	platform_device_register(&avila_npec_device);
+ 
+ 	platform_device_register(&avila_gpio_leds_device);
++
++	avila_pata_resources[0].start = IXP4XX_EXP_BUS_BASE(1);
++	avila_pata_resources[0].end = IXP4XX_EXP_BUS_END(1);
++
++	avila_pata_resources[1].start = IXP4XX_EXP_BUS_BASE(2);
++	avila_pata_resources[1].end = IXP4XX_EXP_BUS_END(2);
++
++	avila_pata_data.cs0_cfg = IXP4XX_EXP_CS1;
++	avila_pata_data.cs1_cfg = IXP4XX_EXP_CS2;
++
++	platform_device_register(&avila_pata);
+ }
+ 
+ static void __init avila_gw2345_setup(void)
+@@ -344,6 +370,17 @@ static void __init avila_gw2345_setup(vo
+ 	platform_device_register(&avila_npec_device);
+ 
+ 	platform_device_register(&avila_gpio_leds_device);
++
++	avila_pata_resources[0].start = IXP4XX_EXP_BUS_BASE(1);
++	avila_pata_resources[0].end = IXP4XX_EXP_BUS_END(1);
++
++	avila_pata_resources[1].start = IXP4XX_EXP_BUS_BASE(2);
++	avila_pata_resources[1].end = IXP4XX_EXP_BUS_END(2);
++
++	avila_pata_data.cs0_cfg = IXP4XX_EXP_CS1;
++	avila_pata_data.cs1_cfg = IXP4XX_EXP_CS2;
++
++	platform_device_register(&avila_pata);
+ }
+ 
+ static void __init avila_gw2347_setup(void)
+@@ -360,6 +397,17 @@ static void __init avila_gw2348_setup(vo
+ 	platform_device_register(&avila_npec_device);
+ 
+ 	platform_device_register(&avila_gpio_leds_device);
++
++	avila_pata_resources[0].start = IXP4XX_EXP_BUS_BASE(1);
++	avila_pata_resources[0].end = IXP4XX_EXP_BUS_END(1);
++
++	avila_pata_resources[1].start = IXP4XX_EXP_BUS_BASE(2);
++	avila_pata_resources[1].end = IXP4XX_EXP_BUS_END(2);
++
++	avila_pata_data.cs0_cfg = IXP4XX_EXP_CS1;
++	avila_pata_data.cs1_cfg = IXP4XX_EXP_CS2;
++
++	platform_device_register(&avila_pata);
+ }
+ 
+ static void __init avila_gw2353_setup(void)
+@@ -388,6 +436,17 @@ static void __init avila_gw2355_setup(vo
+ 	avila_latch_leds_data.num_leds = 5;
+ 	avila_latch_leds_data.mem = 0x54000000;
+ 	platform_device_register(&avila_latch_leds_device);
++
++	avila_pata_resources[0].start = IXP4XX_EXP_BUS_BASE(1);
++	avila_pata_resources[0].end = IXP4XX_EXP_BUS_END(1);
++
++	avila_pata_resources[1].start = IXP4XX_EXP_BUS_BASE(2);
++	avila_pata_resources[1].end = IXP4XX_EXP_BUS_END(2);
++
++	avila_pata_data.cs0_cfg = IXP4XX_EXP_CS1;
++	avila_pata_data.cs1_cfg = IXP4XX_EXP_CS2;
++
++	platform_device_register(&avila_pata);
+ }
+ 
+ static void __init avila_gw2357_setup(void)
+@@ -404,40 +463,62 @@ static void __init avila_gw2357_setup(vo
+ static void __init avila_gw2365_setup(void)
+ {
+ 	*IXP4XX_EXP_CS4 = 0xBFFF3C43;
+-  set_irq_type(IRQ_IXP4XX_GPIO0, IRQ_TYPE_EDGE_RISING);
+-  avila_optional_uart_data[0].mapbase = 0x54000000;
+-  avila_optional_uart_data[0].membase = (void __iomem *)ioremap(0x54000000, 0x0fff);
+-  avila_optional_uart_data[0].irq   = IRQ_IXP4XX_GPIO0;
+-
+-  *IXP4XX_EXP_CS5 = 0xBFFF3C43;
+-  set_irq_type(IRQ_IXP4XX_GPIO1, IRQ_TYPE_EDGE_RISING);
+-  avila_optional_uart_data[1].mapbase = 0x55000000;
+-  avila_optional_uart_data[1].membase = (void __iomem *)ioremap(0x55000000, 0x0fff);
+-  avila_optional_uart_data[1].irq   = IRQ_IXP4XX_GPIO1;
+-
+-  *IXP4XX_EXP_CS6 = 0xBFFF3C43;
+-  set_irq_type(IRQ_IXP4XX_GPIO2, IRQ_TYPE_EDGE_RISING);
+-  avila_optional_uart_data[2].mapbase = 0x56000000;
+-  avila_optional_uart_data[2].membase = (void __iomem *)ioremap(0x56000000, 0x0fff);
+-  avila_optional_uart_data[2].irq   = IRQ_IXP4XX_GPIO2;
+-
+-  *IXP4XX_EXP_CS7 = 0xBFFF3C43;
+-  set_irq_type(IRQ_IXP4XX_GPIO3, IRQ_TYPE_EDGE_RISING);
+-  avila_optional_uart_data[3].mapbase = 0x57000000;
+-  avila_optional_uart_data[3].membase = (void __iomem *)ioremap(0x57000000, 0x0fff);
+-  avila_optional_uart_data[3].irq   = IRQ_IXP4XX_GPIO3;
++	set_irq_type(IRQ_IXP4XX_GPIO0, IRQ_TYPE_EDGE_RISING);
++	avila_optional_uart_data[0].mapbase = 0x54000000;
++	avila_optional_uart_data[0].membase = (void __iomem *)ioremap(0x54000000, 0x0fff);
++	avila_optional_uart_data[0].irq   = IRQ_IXP4XX_GPIO0;
++
++	*IXP4XX_EXP_CS5 = 0xBFFF3C43;
++	set_irq_type(IRQ_IXP4XX_GPIO1, IRQ_TYPE_EDGE_RISING);
++	avila_optional_uart_data[1].mapbase = 0x55000000;
++	avila_optional_uart_data[1].membase = (void __iomem *)ioremap(0x55000000, 0x0fff);
++	avila_optional_uart_data[1].irq   = IRQ_IXP4XX_GPIO1;
++
++	*IXP4XX_EXP_CS6 = 0xBFFF3C43;
++	set_irq_type(IRQ_IXP4XX_GPIO2, IRQ_TYPE_EDGE_RISING);
++	avila_optional_uart_data[2].mapbase = 0x56000000;
++	avila_optional_uart_data[2].membase = (void __iomem *)ioremap(0x56000000, 0x0fff);
++	avila_optional_uart_data[2].irq   = IRQ_IXP4XX_GPIO2;
++
++	*IXP4XX_EXP_CS7 = 0xBFFF3C43;
++	set_irq_type(IRQ_IXP4XX_GPIO3, IRQ_TYPE_EDGE_RISING);
++	avila_optional_uart_data[3].mapbase = 0x57000000;
++	avila_optional_uart_data[3].membase = (void __iomem *)ioremap(0x57000000, 0x0fff);
++	avila_optional_uart_data[3].irq   = IRQ_IXP4XX_GPIO3;
+ 
+ 	platform_device_register(&avila_optional_uart);
+-	
++
+ 	avila_npeb_data.phy = 1;
+ 	platform_device_register(&avila_npeb_device);
+ 
+ 	avila_npec_data.phy = 2;
+ 	platform_device_register(&avila_npec_device);
+ 
++	avila_pata_resources[0].start = IXP4XX_EXP_BUS_BASE(1);
++	avila_pata_resources[0].end = IXP4XX_EXP_BUS_END(1);
++
++	avila_pata_resources[1].start = IXP4XX_EXP_BUS_BASE(2);
++	avila_pata_resources[1].end = IXP4XX_EXP_BUS_END(2);
++
++	avila_pata_data.cs0_cfg = IXP4XX_EXP_CS1;
++	avila_pata_data.cs1_cfg = IXP4XX_EXP_CS2;
++
++	platform_device_register(&avila_pata);
++
++	avila_gpio_leds[0].gpio = 109;
++	avila_gpio_leds_data.num_leds = 5;
+ 	platform_device_register(&avila_gpio_leds_device);
+ }
+ 
++static void __init avila_gw2369_setup(void)
++{
++	avila_npeb_data.phy = 1;
++	platform_device_register(&avila_npeb_device);
++
++	avila_npec_data.phy = 2;
++	platform_device_register(&avila_npec_device);
++}
++
+ static struct avila_board_info avila_boards[] __initdata = {
+ 	{
+ 		.model		= "GW2342",
+@@ -463,6 +544,9 @@ static struct avila_board_info avila_boa
+ 	}, {
+ 		.model		= "GW2365",
+ 		.setup		= avila_gw2365_setup,
++	}, {
++		.model		= "GW2369",
++		.setup		= avila_gw2369_setup,
+ 	}
+ };
+ 
+@@ -511,11 +595,22 @@ static struct at24_platform_data avila_e
+ 	.setup		= at24_setup,
+ };
+ 
++static struct pca953x_platform_data avila_pca_data = {
++	.gpio_base  = 100,
++};
++
+ static struct i2c_board_info __initdata avila_i2c_board_info[] = {
+ 	{
+ 		I2C_BOARD_INFO("ds1672", 0x68),
+ 	},
+ 	{
++		I2C_BOARD_INFO("gsp", 0x29),
++	},
++	{
++		I2C_BOARD_INFO("pca9555", 0x23),
++		.platform_data = &avila_pca_data,
++	},
++	{
+ 		I2C_BOARD_INFO("ad7418", 0x28),
+ 	},
+ 	{
+@@ -538,17 +633,6 @@ static void __init avila_init(void)
+ 
+ 	platform_add_devices(avila_devices, ARRAY_SIZE(avila_devices));
+ 
+-	avila_pata_resources[0].start = IXP4XX_EXP_BUS_BASE(1);
+-	avila_pata_resources[0].end = IXP4XX_EXP_BUS_END(1);
+-
+-	avila_pata_resources[1].start = IXP4XX_EXP_BUS_BASE(2);
+-	avila_pata_resources[1].end = IXP4XX_EXP_BUS_END(2);
+-
+-	avila_pata_data.cs0_cfg = IXP4XX_EXP_CS1;
+-	avila_pata_data.cs1_cfg = IXP4XX_EXP_CS2;
+-
+-	platform_device_register(&avila_pata);
+-
+ 	i2c_register_board_info(0, avila_i2c_board_info,
+ 			ARRAY_SIZE(avila_i2c_board_info));
+ 
+@@ -569,7 +653,6 @@ static int __init avila_model_setup(void
+ 						" -- defaults will be used\n");
+ 		avila_gw23xx_setup();
+ 	}
+-
+ 	return 0;
+ }
+ late_initcall(avila_model_setup);
Index: trunk/target/linux/ixp4xx/patches-2.6.37/502-gw2365-eth.patch
===================================================================
--- trunk/target/linux/ixp4xx/patches-2.6.37/502-gw2365-eth.patch	(revision 0)
+++ trunk/target/linux/ixp4xx/patches-2.6.37/502-gw2365-eth.patch	(revision 0)
@@ -0,0 +1,30 @@
+--- a/arch/arm/mach-ixp4xx/avila-setup.c
++++ b/arch/arm/mach-ixp4xx/avila-setup.c
+@@ -338,6 +338,17 @@ static void __init avila_gw2357_setup(vo
+ 	platform_device_register(&avila_latch_leds_device);
+ }
+ 
++static void __init avila_gw2365_setup(void)
++{
++	avila_npeb_data.phy = 1;
++	platform_device_register(&avila_npeb_device);
++
++	avila_npec_data.phy = 2;
++	platform_device_register(&avila_npec_device);
++
++	platform_device_register(&avila_gpio_leds_device);
++}
++
+ static struct avila_board_info avila_boards[] __initdata = {
+ 	{
+ 		.model		= "GW2342",
+@@ -360,6 +371,9 @@ static struct avila_board_info avila_boa
+ 	}, {
+ 		.model		= "GW2357",
+ 		.setup		= avila_gw2357_setup,
++	}, {
++		.model		= "GW2365",
++		.setup		= avila_gw2365_setup,
+ 	}
+ };
+ 
Index: trunk/target/linux/ixp4xx/patches-2.6.38/301-avila_led.patch
===================================================================
--- trunk/target/linux/ixp4xx/patches-2.6.38/301-avila_led.patch	(revision 27590)
+++ trunk/target/linux/ixp4xx/patches-2.6.38/301-avila_led.patch	(working copy)
@@ -129,11 +129,12 @@
  }
  
  static void __init avila_gw2355_setup(void)
-@@ -222,11 +301,29 @@ static void __init avila_gw2355_setup(vo
+@@ -222,11 +301,30 @@ static void __init avila_gw2355_setup(vo
  
  	avila_npec_data.phy = 16;
  	platform_device_register(&avila_npec_device);
 +
++	avila_gpio_leds[0].gpio = AVILA_GW23X7_LED_USER_GPIO;
 +	platform_device_register(&avila_gpio_leds_device);
 +
 +	*IXP4XX_EXP_CS4 |= 0xbfff3c03;
Index: trunk/target/linux/ixp4xx/patches-2.6.38/506-gw2370_support.patch
===================================================================
--- trunk/target/linux/ixp4xx/patches-2.6.38/506-gw2370_support.patch	(revision 0)
+++ trunk/target/linux/ixp4xx/patches-2.6.38/506-gw2370_support.patch	(revision 0)
@@ -0,0 +1,89 @@
+--- a/arch/arm/mach-ixp4xx/avila-setup.c
++++ b/arch/arm/mach-ixp4xx/avila-setup.c
+@@ -495,14 +495,14 @@ static void __init avila_gw2365_setup(vo
+ 	avila_npec_data.phy = 2;
+ 	platform_device_register(&avila_npec_device);
+ 
+-	avila_pata_resources[0].start = IXP4XX_EXP_BUS_BASE(1);
+-	avila_pata_resources[0].end = IXP4XX_EXP_BUS_END(1);
++	avila_pata_resources[0].start = IXP4XX_EXP_BUS_BASE(2);
++	avila_pata_resources[0].end = IXP4XX_EXP_BUS_END(2);
+ 
+-	avila_pata_resources[1].start = IXP4XX_EXP_BUS_BASE(2);
+-	avila_pata_resources[1].end = IXP4XX_EXP_BUS_END(2);
++	avila_pata_resources[1].start = IXP4XX_EXP_BUS_BASE(3);
++	avila_pata_resources[1].end = IXP4XX_EXP_BUS_END(3);
+ 
+-	avila_pata_data.cs0_cfg = IXP4XX_EXP_CS1;
+-	avila_pata_data.cs1_cfg = IXP4XX_EXP_CS2;
++	avila_pata_data.cs0_cfg = IXP4XX_EXP_CS2;
++	avila_pata_data.cs1_cfg = IXP4XX_EXP_CS3;
+ 
+ 	platform_device_register(&avila_pata);
+ 
+@@ -520,6 +520,37 @@ static void __init avila_gw2369_setup(vo
+ 	platform_device_register(&avila_npec_device);
+ }
+ 
++static void __init avila_gw2370_setup(void)
++{
++	avila_npeb_data.phy = 5;
++	platform_device_register(&avila_npeb_device);
++
++	avila_npec_data.phy = IXP4XX_ETH_PHY_MAX_ADDR;
++	avila_npec_data.phy_mask = 0x1e; /* ports 1-4 of the KS8995 switch */
++	platform_device_register(&avila_npec_device);
++
++	*IXP4XX_EXP_CS2 = 0xBFFF3C43;
++	set_irq_type(IRQ_IXP4XX_GPIO2, IRQ_TYPE_EDGE_RISING);
++	avila_optional_uart_data[0].mapbase = 0x52000000;
++	avila_optional_uart_data[0].membase = (void __iomem *)ioremap(0x52000000, 0x0fff);
++	avila_optional_uart_data[0].irq   = IRQ_IXP4XX_GPIO2;
++
++	*IXP4XX_EXP_CS3 = 0xBFFF3C43;
++	set_irq_type(IRQ_IXP4XX_GPIO3, IRQ_TYPE_EDGE_RISING);
++	avila_optional_uart_data[1].mapbase = 0x53000000;
++	avila_optional_uart_data[1].membase = (void __iomem *)ioremap(0x53000000, 0x0fff);
++	avila_optional_uart_data[1].irq   = IRQ_IXP4XX_GPIO3;
++
++	avila_optional_uart.num_resources = 2;
++
++	platform_device_register(&avila_optional_uart);
++
++	avila_gpio_leds[0].gpio = 101;
++	platform_device_register(&avila_gpio_leds_device);
++}
++
++
++
+ static struct avila_board_info avila_boards[] __initdata = {
+ 	{
+ 		.model		= "GW2342",
+@@ -548,6 +579,9 @@ static struct avila_board_info avila_boa
+ 	}, {
+ 		.model		= "GW2369",
+ 		.setup		= avila_gw2369_setup,
++	}, {
++		.model		= "GW2370",
++		.setup		= avila_gw2370_setup,
+ 	}
+ };
+ 
+@@ -592,7 +626,7 @@ static void at24_setup(struct memory_acc
+ static struct at24_platform_data avila_eeprom_info = {
+ 	.byte_len	= 1024,
+ 	.page_size	= 16,
+-	.flags		= AT24_FLAG_READONLY,
++	//.flags		= AT24_FLAG_READONLY,
+ 	.setup		= at24_setup,
+ };
+ 
+@@ -630,7 +664,7 @@ static void __init avila_init(void)
+ 	 */
+ 	avila_flash_resource.start = IXP4XX_EXP_BUS_BASE(0);
+ 	avila_flash_resource.end =
+-		IXP4XX_EXP_BUS_BASE(0) + ixp4xx_exp_bus_size - 1;
++		IXP4XX_EXP_BUS_BASE(0) + (2 * ixp4xx_exp_bus_size) - 1;
+ 
+ 	platform_add_devices(avila_devices, ARRAY_SIZE(avila_devices));
+ 
Index: trunk/target/linux/ixp4xx/patches-2.6.38/508-gw2373_support.patch
===================================================================
--- trunk/target/linux/ixp4xx/patches-2.6.38/508-gw2373_support.patch	(revision 0)
+++ trunk/target/linux/ixp4xx/patches-2.6.38/508-gw2373_support.patch	(revision 0)
@@ -0,0 +1,12 @@
+--- a/arch/arm/mach-ixp4xx/avila-setup.c
++++ b/arch/arm/mach-ixp4xx/avila-setup.c
+@@ -582,6 +582,9 @@ static struct avila_board_info avila_boa
+ 	}, {
+ 		.model		= "GW2370",
+ 		.setup		= avila_gw2370_setup,
++	}, {
++		.model		= "GW2373",
++		.setup		= avila_gw2369_setup,
+ 	}
+ };
+ 
Index: trunk/target/linux/ixp4xx/patches-2.6.38/501-cambria-e1000-irq.patch
===================================================================
--- trunk/target/linux/ixp4xx/patches-2.6.38/501-cambria-e1000-irq.patch	(revision 0)
+++ trunk/target/linux/ixp4xx/patches-2.6.38/501-cambria-e1000-irq.patch	(revision 0)
@@ -0,0 +1,14 @@
+--- a/arch/arm/mach-ixp4xx/cambria-pci.c
++++ b/arch/arm/mach-ixp4xx/cambria-pci.c
+@@ -52,6 +52,11 @@ static int __init cambria_map_irq(struct
+ 		return IRQ_IXP4XX_GPIO9;
+ 	else if (slot == 4)
+ 		return IRQ_IXP4XX_GPIO8;
++  else if (slot == 6)
++    return IRQ_IXP4XX_GPIO10;
++  else if (slot == 15)
++    return IRQ_IXP4XX_GPIO8;
++
+ 	else return -1;
+ }
+ 
Index: trunk/target/linux/ixp4xx/patches-2.6.38/505-gateworks_gsp.patch
===================================================================
--- trunk/target/linux/ixp4xx/patches-2.6.38/505-gateworks_gsp.patch	(revision 0)
+++ trunk/target/linux/ixp4xx/patches-2.6.38/505-gateworks_gsp.patch	(revision 0)
@@ -0,0 +1,339 @@
+--- /dev/null
++++ b/drivers/hwmon/gsp.c
+@@ -0,0 +1,308 @@
++/*
++ * A hwmon driver for the Gateworks System Peripheral
++ * Copyright (C) 2009 Gateworks Corporation
++ *
++ * Author: Chris Lang <clang@gateworks.com>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License,
++ * as published by the Free Software Foundation - version 2.
++ */
++
++#include <linux/module.h>
++#include <linux/i2c.h>
++#include <linux/hwmon.h>
++#include <linux/hwmon-sysfs.h>
++#include <linux/err.h>
++#include <linux/slab.h>
++
++#define DRV_VERSION "0.2"
++
++enum chips { gsp };
++
++/* AD7418 registers */
++#define GSP_REG_TEMP_IN		0x00
++#define GSP_REG_VIN		0x02
++#define GSP_REG_3P3		0x05
++#define GSP_REG_BAT		0x08
++#define GSP_REG_5P0		0x0b
++#define GSP_REG_CORE		0x0e
++#define GSP_REG_CPU1		0x11
++#define GSP_REG_CPU2		0x14
++#define GSP_REG_DRAM		0x17
++#define GSP_REG_EXT_BAT		0x1a
++#define GSP_REG_IO1		0x1d
++#define GSP_REG_IO2 		0x20
++#define GSP_REG_PCIE		0x23
++#define GSP_REG_CURRENT		0x26
++#define GSP_FAN_0		0x2C
++#define GSP_FAN_1		0x2E
++#define GSP_FAN_2		0x30
++#define GSP_FAN_3		0x32
++#define GSP_FAN_4		0x34
++#define GSP_FAN_5		0x36
++
++struct gsp_sensor_info {
++	const char* name;
++	int reg;
++};
++
++static const struct gsp_sensor_info gsp_sensors[] = {
++	{"temp", GSP_REG_TEMP_IN},
++	{"vin", GSP_REG_VIN},
++	{"3p3", GSP_REG_3P3},
++	{"bat", GSP_REG_BAT},
++	{"5p0", GSP_REG_5P0},
++	{"core", GSP_REG_CORE},
++	{"cpu1", GSP_REG_CPU1},
++	{"cpu2", GSP_REG_CPU2},
++	{"dram", GSP_REG_DRAM},
++	{"ext_bat", GSP_REG_EXT_BAT},
++	{"io1", GSP_REG_IO1},
++	{"io2", GSP_REG_IO2},
++	{"pci2", GSP_REG_PCIE},
++	{"current", GSP_REG_CURRENT},
++	{"fan_point0", GSP_FAN_0},
++	{"fan_point1", GSP_FAN_1},
++	{"fan_point2", GSP_FAN_2},
++	{"fan_point3", GSP_FAN_3},
++	{"fan_point4", GSP_FAN_4},
++	{"fan_point5", GSP_FAN_5},
++};
++
++struct gsp_data {
++	struct device		*hwmon_dev;
++	struct attribute_group	attrs;
++	enum chips		type;
++};
++
++static int gsp_probe(struct i2c_client *client,
++			const struct i2c_device_id *id);
++static int gsp_remove(struct i2c_client *client);
++
++static const struct i2c_device_id gsp_id[] = {
++	{ "gsp", 0 },
++	{ }
++};
++MODULE_DEVICE_TABLE(i2c, gsp_id);
++
++static struct i2c_driver gsp_driver = {
++	.driver = {
++		.name	= "gsp",
++	},
++	.probe		= gsp_probe,
++	.remove		= gsp_remove,
++	.id_table	= gsp_id,
++};
++
++/* All registers are word-sized, except for the configuration registers.
++ * AD7418 uses a high-byte first convention. Do NOT use those functions to
++ * access the configuration registers CONF and CONF2, as they are byte-sized.
++ */
++static inline int gsp_read(struct i2c_client *client, u8 reg)
++{
++	unsigned int adc = 0;
++	if (reg == GSP_REG_TEMP_IN || reg > GSP_REG_CURRENT)
++	{
++		adc |= i2c_smbus_read_byte_data(client, reg);
++		adc |= i2c_smbus_read_byte_data(client, reg + 1) << 8;
++		return adc;
++	}
++	else
++	{
++		adc |= i2c_smbus_read_byte_data(client, reg);
++		adc |= i2c_smbus_read_byte_data(client, reg + 1) << 8;
++		adc |= i2c_smbus_read_byte_data(client, reg + 2) << 16;
++		return adc;
++	}
++}
++
++static inline int gsp_write(struct i2c_client *client, u8 reg, u16 value)
++{
++	i2c_smbus_write_byte_data(client, reg, value & 0xff);
++	i2c_smbus_write_byte_data(client, reg + 1, ((value >> 8) & 0xff));
++	return 1;
++}
++
++static ssize_t show_adc(struct device *dev, struct device_attribute *devattr,
++			char *buf)
++{
++	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
++	struct i2c_client *client = to_i2c_client(dev);
++	return sprintf(buf, "%d\n", gsp_read(client, gsp_sensors[attr->index].reg));
++}
++
++static ssize_t show_label(struct device *dev,
++			struct device_attribute *devattr, char *buf)
++{
++	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
++
++	return sprintf(buf, "%s\n", gsp_sensors[attr->index].name);
++}
++
++static ssize_t store_fan(struct device *dev,
++			struct device_attribute *devattr, const char *buf, size_t count)
++{
++	u16 val;
++	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
++	struct i2c_client *client = to_i2c_client(dev);
++	val = simple_strtoul(buf, NULL, 10);
++	gsp_write(client, gsp_sensors[attr->index].reg, val);
++	return count;
++}
++
++static SENSOR_DEVICE_ATTR(temp0_input, S_IRUGO, show_adc, NULL, 0);
++static SENSOR_DEVICE_ATTR(temp0_label, S_IRUGO, show_label, NULL, 0);
++
++static SENSOR_DEVICE_ATTR(in0_input, S_IRUGO, show_adc, NULL, 1);
++static SENSOR_DEVICE_ATTR(in0_label, S_IRUGO, show_label, NULL, 1);
++static SENSOR_DEVICE_ATTR(in1_input, S_IRUGO, show_adc, NULL, 2);
++static SENSOR_DEVICE_ATTR(in1_label, S_IRUGO, show_label, NULL, 2);
++static SENSOR_DEVICE_ATTR(in2_input, S_IRUGO, show_adc, NULL, 3);
++static SENSOR_DEVICE_ATTR(in2_label, S_IRUGO, show_label, NULL, 3);
++static SENSOR_DEVICE_ATTR(in3_input, S_IRUGO, show_adc, NULL, 4);
++static SENSOR_DEVICE_ATTR(in3_label, S_IRUGO, show_label, NULL, 4);
++static SENSOR_DEVICE_ATTR(in4_input, S_IRUGO, show_adc, NULL, 5);
++static SENSOR_DEVICE_ATTR(in4_label, S_IRUGO, show_label, NULL, 5);
++static SENSOR_DEVICE_ATTR(in5_input, S_IRUGO, show_adc, NULL, 6);
++static SENSOR_DEVICE_ATTR(in5_label, S_IRUGO, show_label, NULL, 6);
++static SENSOR_DEVICE_ATTR(in6_input, S_IRUGO, show_adc, NULL, 7);
++static SENSOR_DEVICE_ATTR(in6_label, S_IRUGO, show_label, NULL, 7);
++static SENSOR_DEVICE_ATTR(in7_input, S_IRUGO, show_adc, NULL, 8);
++static SENSOR_DEVICE_ATTR(in7_label, S_IRUGO, show_label, NULL, 8);
++static SENSOR_DEVICE_ATTR(in8_input, S_IRUGO, show_adc, NULL, 9);
++static SENSOR_DEVICE_ATTR(in8_label, S_IRUGO, show_label, NULL, 9);
++static SENSOR_DEVICE_ATTR(in9_input, S_IRUGO, show_adc, NULL, 10);
++static SENSOR_DEVICE_ATTR(in9_label, S_IRUGO, show_label, NULL, 10);
++static SENSOR_DEVICE_ATTR(in10_input, S_IRUGO, show_adc, NULL, 11);
++static SENSOR_DEVICE_ATTR(in10_label, S_IRUGO, show_label, NULL, 11);
++static SENSOR_DEVICE_ATTR(in11_input, S_IRUGO, show_adc, NULL, 12);
++static SENSOR_DEVICE_ATTR(in11_label, S_IRUGO, show_label, NULL, 12);
++static SENSOR_DEVICE_ATTR(in12_input, S_IRUGO, show_adc, NULL, 13);
++static SENSOR_DEVICE_ATTR(in12_label, S_IRUGO, show_label, NULL, 13);
++
++static SENSOR_DEVICE_ATTR(fan0_point0, S_IRUGO | S_IWUSR, show_adc, store_fan, 14);
++static SENSOR_DEVICE_ATTR(fan0_point1, S_IRUGO | S_IWUSR, show_adc, store_fan, 15);
++static SENSOR_DEVICE_ATTR(fan0_point2, S_IRUGO | S_IWUSR, show_adc, store_fan, 16);
++static SENSOR_DEVICE_ATTR(fan0_point3, S_IRUGO | S_IWUSR, show_adc, store_fan, 17);
++static SENSOR_DEVICE_ATTR(fan0_point4, S_IRUGO | S_IWUSR, show_adc, store_fan, 18);
++static SENSOR_DEVICE_ATTR(fan0_point5, S_IRUGO | S_IWUSR, show_adc, store_fan, 19);
++
++static struct attribute *gsp_attributes[] = {
++	&sensor_dev_attr_temp0_input.dev_attr.attr,
++	&sensor_dev_attr_in0_input.dev_attr.attr,
++	&sensor_dev_attr_in1_input.dev_attr.attr,
++	&sensor_dev_attr_in2_input.dev_attr.attr,
++	&sensor_dev_attr_in3_input.dev_attr.attr,
++	&sensor_dev_attr_in4_input.dev_attr.attr,
++	&sensor_dev_attr_in5_input.dev_attr.attr,
++	&sensor_dev_attr_in6_input.dev_attr.attr,
++	&sensor_dev_attr_in7_input.dev_attr.attr,
++	&sensor_dev_attr_in8_input.dev_attr.attr,
++	&sensor_dev_attr_in9_input.dev_attr.attr,
++	&sensor_dev_attr_in10_input.dev_attr.attr,
++	&sensor_dev_attr_in11_input.dev_attr.attr,
++	&sensor_dev_attr_in12_input.dev_attr.attr,
++
++	&sensor_dev_attr_temp0_label.dev_attr.attr,
++	&sensor_dev_attr_in0_label.dev_attr.attr,
++	&sensor_dev_attr_in1_label.dev_attr.attr,
++	&sensor_dev_attr_in2_label.dev_attr.attr,
++	&sensor_dev_attr_in3_label.dev_attr.attr,
++	&sensor_dev_attr_in4_label.dev_attr.attr,
++	&sensor_dev_attr_in5_label.dev_attr.attr,
++	&sensor_dev_attr_in6_label.dev_attr.attr,
++	&sensor_dev_attr_in7_label.dev_attr.attr,
++	&sensor_dev_attr_in8_label.dev_attr.attr,
++	&sensor_dev_attr_in9_label.dev_attr.attr,
++	&sensor_dev_attr_in10_label.dev_attr.attr,
++	&sensor_dev_attr_in11_label.dev_attr.attr,
++	&sensor_dev_attr_in12_label.dev_attr.attr,
++
++	&sensor_dev_attr_fan0_point0.dev_attr.attr,
++	&sensor_dev_attr_fan0_point1.dev_attr.attr,
++	&sensor_dev_attr_fan0_point2.dev_attr.attr,
++	&sensor_dev_attr_fan0_point3.dev_attr.attr,
++	&sensor_dev_attr_fan0_point4.dev_attr.attr,
++	&sensor_dev_attr_fan0_point5.dev_attr.attr,
++	NULL
++};
++
++
++static int gsp_probe(struct i2c_client *client,
++			 const struct i2c_device_id *id)
++{
++	struct i2c_adapter *adapter = client->adapter;
++	struct gsp_data *data;
++	int err;
++
++	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA |
++					I2C_FUNC_SMBUS_WORD_DATA)) {
++		err = -EOPNOTSUPP;
++		goto exit;
++	}
++
++	if (!(data = kzalloc(sizeof(struct gsp_data), GFP_KERNEL))) {
++		err = -ENOMEM;
++		goto exit;
++	}
++
++	i2c_set_clientdata(client, data);
++
++	data->type = id->driver_data;
++
++	switch (data->type) {
++	case 0:
++		data->attrs.attrs = gsp_attributes;
++		break;
++	}
++
++	dev_info(&client->dev, "%s chip found\n", client->name);
++
++	/* Register sysfs hooks */
++	if ((err = sysfs_create_group(&client->dev.kobj, &data->attrs)))
++		goto exit_free;
++
++	data->hwmon_dev = hwmon_device_register(&client->dev);
++	if (IS_ERR(data->hwmon_dev)) {
++		err = PTR_ERR(data->hwmon_dev);
++		goto exit_remove;
++	}
++
++	return 0;
++
++exit_remove:
++	sysfs_remove_group(&client->dev.kobj, &data->attrs);
++exit_free:
++	kfree(data);
++exit:
++	return err;
++}
++
++static int gsp_remove(struct i2c_client *client)
++{
++	struct gsp_data *data = i2c_get_clientdata(client);
++	hwmon_device_unregister(data->hwmon_dev);
++	sysfs_remove_group(&client->dev.kobj, &data->attrs);
++	kfree(data);
++	return 0;
++}
++
++static int __init gsp_init(void)
++{
++	return i2c_add_driver(&gsp_driver);
++}
++
++static void __exit gsp_exit(void)
++{
++	i2c_del_driver(&gsp_driver);
++}
++
++module_init(gsp_init);
++module_exit(gsp_exit);
++
++MODULE_AUTHOR("Chris Lang <clang@gateworks.com>");
++MODULE_DESCRIPTION("GSP HWMON driver");
++MODULE_LICENSE("GPL");
++MODULE_VERSION(DRV_VERSION);
++
+--- a/drivers/hwmon/Kconfig
++++ b/drivers/hwmon/Kconfig
+@@ -68,6 +68,15 @@ config SENSORS_ABITUGURU3
+ 	  This driver can also be built as a module.  If so, the module
+ 	  will be called abituguru3.
+ 
++config SENSORS_GSP
++  tristate "Gateworks System Peripheral"
++  depends on I2C && EXPERIMENTAL
++  help
++    If you say yes here you get support for the Gateworks System Peripherals.
++
++    This driver can also be built as a module. If so, the module
++    will be called gsp.
++
+ config SENSORS_AD7414
+ 	tristate "Analog Devices AD7414"
+ 	depends on I2C && EXPERIMENTAL
+--- a/drivers/hwmon/Makefile
++++ b/drivers/hwmon/Makefile
+@@ -20,6 +20,7 @@ obj-$(CONFIG_SENSORS_W83791D)	+= w83791d
+ 
+ obj-$(CONFIG_SENSORS_ABITUGURU)	+= abituguru.o
+ obj-$(CONFIG_SENSORS_ABITUGURU3)+= abituguru3.o
++obj-$(CONFIG_SENSORS_GSP)	+= gsp.o
+ obj-$(CONFIG_SENSORS_AD7414)	+= ad7414.o
+ obj-$(CONFIG_SENSORS_AD7418)	+= ad7418.o
+ obj-$(CONFIG_SENSORS_ADCXX)	+= adcxx.o
Index: trunk/target/linux/ixp4xx/patches-2.6.38/302-avila_gpio_device.patch
===================================================================
--- trunk/target/linux/ixp4xx/patches-2.6.38/302-avila_gpio_device.patch	(revision 27590)
+++ trunk/target/linux/ixp4xx/patches-2.6.38/302-avila_gpio_device.patch	(working copy)
@@ -14,3 +14,28 @@
  struct avila_board_info {
  	unsigned char	*model;
  	void		(*setup)(void);
+@@ -243,6 +250,11 @@ static struct platform_device *avila_dev
+ 	&avila_uart
+ };
+ 
++static struct platform_device avila_gpio_dev = {
++	.name     = "GPIODEV",
++	.id     = -1,
++};
++
+ static void __init avila_gw23xx_setup(void)
+ {
+ 	platform_device_register(&avila_npeb_device);
+@@ -435,8 +447,10 @@ static void __init avila_init(void)
+ 
+ 	platform_device_register(&avila_pata);
+ 
+-		i2c_register_board_info(0, avila_i2c_board_info,
+-				ARRAY_SIZE(avila_i2c_board_info));
++	i2c_register_board_info(0, avila_i2c_board_info,
++			ARRAY_SIZE(avila_i2c_board_info));
++
++	platform_device_register(&avila_gpio_dev);
+ }
+ 
+ static int __init avila_model_setup(void)
Index: trunk/target/linux/ixp4xx/patches-2.6.38/503-gw2365-optional-uart.patch
===================================================================
--- trunk/target/linux/ixp4xx/patches-2.6.38/503-gw2365-optional-uart.patch	(revision 0)
+++ trunk/target/linux/ixp4xx/patches-2.6.38/503-gw2365-optional-uart.patch	(revision 0)
@@ -0,0 +1,105 @@
+--- a/arch/arm/mach-ixp4xx/avila-setup.c
++++ b/arch/arm/mach-ixp4xx/avila-setup.c
+@@ -125,6 +125,69 @@ static struct platform_device avila_uart
+ 	.resource		= avila_uart_resources
+ };
+ 
++static struct resource avila_optional_uart_resources[] = {
++  {
++    .start  = 0x54000000,
++    .end  = 0x54000fff,
++    .flags  = IORESOURCE_MEM
++  },
++  {
++    .start  = 0x55000000,
++    .end  = 0x55000fff,
++    .flags  = IORESOURCE_MEM
++  },
++  {
++    .start  = 0x56000000,
++    .end  = 0x56000fff,
++    .flags  = IORESOURCE_MEM
++  },
++  {
++    .start  = 0x57000000,
++    .end  = 0x57000fff,
++    .flags  = IORESOURCE_MEM
++  }
++};
++
++static struct plat_serial8250_port avila_optional_uart_data[] = {
++  {
++    .flags    = UPF_BOOT_AUTOCONF,
++    .iotype   = UPIO_MEM,
++    .regshift = 0,
++    .uartclk  = 18432000,
++    .rw_delay = 2,
++  },
++  {
++    .flags    = UPF_BOOT_AUTOCONF,
++    .iotype   = UPIO_MEM,
++    .regshift = 0,
++    .uartclk  = 18432000,
++    .rw_delay = 2,
++  },
++  {
++    .flags    = UPF_BOOT_AUTOCONF,
++    .iotype   = UPIO_MEM,
++    .regshift = 0,
++    .uartclk  = 18432000,
++    .rw_delay = 2,
++  },
++  {
++    .flags    = UPF_BOOT_AUTOCONF,
++    .iotype   = UPIO_MEM,
++    .regshift = 0,
++    .uartclk  = 18432000,
++    .rw_delay = 2,
++  },
++  { },
++};
++
++static struct platform_device avila_optional_uart = {
++  .name   = "serial8250",
++  .id   = PLAT8250_DEV_PLATFORM1,
++  .dev.platform_data  = avila_optional_uart_data,
++  .num_resources  = 4,
++  .resource = avila_optional_uart_resources,
++};
++
+ static struct resource avila_pata_resources[] = {
+ 	{
+ 		.flags	= IORESOURCE_MEM
+@@ -341,6 +404,32 @@ static void __init avila_gw2357_setup(vo
+ 
+ static void __init avila_gw2365_setup(void)
+ {
++	*IXP4XX_EXP_CS4 = 0xBFFF3C43;
++  set_irq_type(IRQ_IXP4XX_GPIO0, IRQ_TYPE_EDGE_RISING);
++  avila_optional_uart_data[0].mapbase = 0x54000000;
++  avila_optional_uart_data[0].membase = (void __iomem *)ioremap(0x54000000, 0x0fff);
++  avila_optional_uart_data[0].irq   = IRQ_IXP4XX_GPIO0;
++
++  *IXP4XX_EXP_CS5 = 0xBFFF3C43;
++  set_irq_type(IRQ_IXP4XX_GPIO1, IRQ_TYPE_EDGE_RISING);
++  avila_optional_uart_data[1].mapbase = 0x55000000;
++  avila_optional_uart_data[1].membase = (void __iomem *)ioremap(0x55000000, 0x0fff);
++  avila_optional_uart_data[1].irq   = IRQ_IXP4XX_GPIO1;
++
++  *IXP4XX_EXP_CS6 = 0xBFFF3C43;
++  set_irq_type(IRQ_IXP4XX_GPIO2, IRQ_TYPE_EDGE_RISING);
++  avila_optional_uart_data[2].mapbase = 0x56000000;
++  avila_optional_uart_data[2].membase = (void __iomem *)ioremap(0x56000000, 0x0fff);
++  avila_optional_uart_data[2].irq   = IRQ_IXP4XX_GPIO2;
++
++  *IXP4XX_EXP_CS7 = 0xBFFF3C43;
++  set_irq_type(IRQ_IXP4XX_GPIO3, IRQ_TYPE_EDGE_RISING);
++  avila_optional_uart_data[3].mapbase = 0x57000000;
++  avila_optional_uart_data[3].membase = (void __iomem *)ioremap(0x57000000, 0x0fff);
++  avila_optional_uart_data[3].irq   = IRQ_IXP4XX_GPIO3;
++
++	platform_device_register(&avila_optional_uart);
++	
+ 	avila_npeb_data.phy = 1;
+ 	platform_device_register(&avila_npeb_device);
+ 
Index: trunk/target/linux/ixp4xx/patches-2.6.38/507-gw2371_support.patch
===================================================================
--- trunk/target/linux/ixp4xx/patches-2.6.38/507-gw2371_support.patch	(revision 0)
+++ trunk/target/linux/ixp4xx/patches-2.6.38/507-gw2371_support.patch	(revision 0)
@@ -0,0 +1,22 @@
+--- a/arch/arm/mach-ixp4xx/cambria-setup.c
++++ b/arch/arm/mach-ixp4xx/cambria-setup.c
+@@ -448,6 +448,9 @@ static struct cambria_board_info cambria
+ 	}, {
+ 		.model	= "GW2358",
+ 		.setup	= cambria_gw2358_setup,
++	}, {
++		.model	= "GW2371",
++		.setup	= cambria_gw2358_setup,
+ 	}
+ };
+ 
+@@ -501,6 +504,9 @@ static struct i2c_board_info __initdata
+ 		I2C_BOARD_INFO("ds1672", 0x68),
+ 	},
+ 	{
++                I2C_BOARD_INFO("gsp", 0x29),
++        },
++	{
+ 		I2C_BOARD_INFO("ad7418", 0x28),
+ 	},
+ 	{
Index: trunk/target/linux/ixp4xx/patches-2.6.38/509-avila_hss_audio_support.patch
===================================================================
--- trunk/target/linux/ixp4xx/patches-2.6.38/509-avila_hss_audio_support.patch	(revision 0)
+++ trunk/target/linux/ixp4xx/patches-2.6.38/509-avila_hss_audio_support.patch	(revision 0)
@@ -0,0 +1,2214 @@
+--- a/sound/soc/Kconfig
++++ b/sound/soc/Kconfig
+@@ -55,6 +55,7 @@ source "sound/soc/samsung/Kconfig"
+ source "sound/soc/s6000/Kconfig"
+ source "sound/soc/sh/Kconfig"
+ source "sound/soc/txx9/Kconfig"
++source "sound/soc/gw-avila/Kconfig"
+ 
+ # Supported codecs
+ source "sound/soc/codecs/Kconfig"
+--- a/sound/soc/Makefile
++++ b/sound/soc/Makefile
+@@ -18,3 +18,4 @@ obj-$(CONFIG_SND_SOC)	+= samsung/
+ obj-$(CONFIG_SND_SOC)	+= s6000/
+ obj-$(CONFIG_SND_SOC)	+= sh/
+ obj-$(CONFIG_SND_SOC)	+= txx9/
++obj-$(CONFIG_SND_SOC)	+= gw-avila/
+--- /dev/null
++++ b/sound/soc/gw-avila/Kconfig
+@@ -0,0 +1,17 @@
++config SND_GW_AVILA_SOC_PCM
++	tristate
++
++config SND_GW_AVILA_SOC_HSS
++	tristate
++
++config SND_GW_AVILA_SOC
++	tristate "SoC Audio for the Gateworks AVILA Family"
++	depends on ARCH_IXP4XX && SND_SOC
++	select SND_GW_AVILA_SOC_PCM
++	select SND_GW_AVILA_SOC_HSS
++	select SND_SOC_TLV320AIC3X
++	help
++	  Say Y or M if you want to add support for codecs attached to
++	  the Gateworks HSS interface. You will also need
++	  to select the audio interfaces to support below.
++
+--- /dev/null
++++ b/sound/soc/gw-avila/Makefile
+@@ -0,0 +1,8 @@
++# Gateworks Avila HSS Platform Support
++snd-soc-gw-avila-objs := gw-avila.o ixp4xx_hss.o
++snd-soc-gw-avila-pcm-objs := gw-avila-pcm.o
++snd-soc-gw-avila-hss-objs := gw-avila-hss.o
++
++obj-$(CONFIG_SND_GW_AVILA_SOC) += snd-soc-gw-avila.o
++obj-$(CONFIG_SND_GW_AVILA_SOC_PCM) += snd-soc-gw-avila-pcm.o
++obj-$(CONFIG_SND_GW_AVILA_SOC_HSS) += snd-soc-gw-avila-hss.o
+--- /dev/null
++++ b/sound/soc/gw-avila/gw-avila-hss.c
+@@ -0,0 +1,98 @@
++/*
++ * gw-avila-hss.c -- HSS Audio Support for Gateworks Avila
++ *
++ * Author:	Chris Lang	<clang@gateworks.com>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ */
++
++#include <linux/init.h>
++#include <linux/module.h>
++#include <linux/platform_device.h>
++#include <linux/interrupt.h>
++#include <linux/wait.h>
++#include <linux/delay.h>
++
++#include <sound/core.h>
++#include <sound/pcm.h>
++#include <sound/ac97_codec.h>
++#include <sound/initval.h>
++#include <sound/soc.h>
++
++#include <asm/irq.h>
++#include <linux/mutex.h>
++#include <linux/gpio.h>
++
++#include "ixp4xx_hss.h"
++#include "gw-avila-hss.h"
++
++#define gw_avila_hss_suspend	NULL
++#define gw_avila_hss_resume	NULL
++
++struct snd_soc_dai_driver gw_avila_hss_dai = {
++	.playback = {
++		.channels_min = 2,
++		.channels_max = 2,
++		.rates = (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000 |
++			SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_32000 |
++			SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 |
++			SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000 |
++			SNDRV_PCM_RATE_KNOT),
++		.formats = SNDRV_PCM_FMTBIT_S16_LE, },
++	.capture = {
++		.channels_min = 2,
++		.channels_max = 2,
++		.rates = (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000 |
++			SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_32000 |
++			SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 |
++			SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000 |
++			SNDRV_PCM_RATE_KNOT),
++		.formats = SNDRV_PCM_FMTBIT_S16_LE, },
++};
++
++static int gw_avila_hss_probe(struct platform_device *pdev)
++{
++	int port = (pdev->id < 2) ? 0 : 1;
++	int channel = (pdev->id % 2);
++
++	hss_handle[pdev->id] = hss_init(port, channel);
++	if (!hss_handle[pdev->id]) {
++		return -ENODEV;
++	}
++
++	return snd_soc_register_dai(&pdev->dev, &gw_avila_hss_dai);
++}
++
++static int gw_avila_hss_remove(struct platform_device *pdev)
++{
++	snd_soc_unregister_dai(&pdev->dev);
++
++	return 0;
++}
++
++static struct platform_driver gw_avila_hss_driver = {
++	.probe    = gw_avila_hss_probe,
++	.remove   = gw_avila_hss_remove,
++	.driver   = {
++		.name = "gw_avila_hss",
++		.owner  = THIS_MODULE,
++	}
++};
++
++static int __init gw_avila_hss_init(void)
++{
++	return platform_driver_register(&gw_avila_hss_driver);
++}
++module_init(gw_avila_hss_init);
++
++static void __exit gw_avila_hss_exit(void)
++{
++	platform_driver_unregister(&gw_avila_hss_driver);
++}
++module_exit(gw_avila_hss_exit);
++
++MODULE_AUTHOR("Chris Lang");
++MODULE_DESCRIPTION("HSS Audio Driver for Gateworks Avila");
++MODULE_LICENSE("GPL");
+--- /dev/null
++++ b/sound/soc/gw-avila/gw-avila-hss.h
+@@ -0,0 +1,12 @@
++/*
++ * Author: Chris Lang <clang@gateworks.com>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ */
++
++#ifndef _GW_AVILA_HSS_H
++#define _GW_AVILA_HSS_H
++
++#endif
+--- /dev/null
++++ b/sound/soc/gw-avila/gw-avila-pcm.c
+@@ -0,0 +1,325 @@
++/*
++ * ALSA PCM interface for the TI DAVINCI processor
++ *
++ * Author:      Chris Lang, <clang@gateworks.com>
++ * Copyright:   (C) 2009 Gateworks Corporation
++ *
++ * Based On:    davinci-evm.c, Author: Vladimir Barinov, <vbarinov@ru.mvista.com>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ */
++
++#include <linux/module.h>
++#include <linux/init.h>
++#include <linux/platform_device.h>
++#include <linux/slab.h>
++#include <linux/dma-mapping.h>
++
++#include <sound/core.h>
++#include <sound/pcm.h>
++#include <sound/pcm_params.h>
++#include <sound/soc.h>
++
++#include <asm/dma.h>
++
++#include "gw-avila-pcm.h"
++#include "gw-avila-hss.h"
++#include "ixp4xx_hss.h"
++
++#define GW_AVILA_PCM_DEBUG 0
++#if GW_AVILA_PCM_DEBUG
++#define DPRINTK(x...) printk(KERN_DEBUG x)
++#else
++#define DPRINTK(x...)
++#endif
++
++static struct snd_pcm_hardware gw_avila_pcm_hardware = {
++	.info = (SNDRV_PCM_INFO_INTERLEAVED | SNDRV_PCM_INFO_BLOCK_TRANSFER |
++		 SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_MMAP_VALID),
++/*		 SNDRV_PCM_INFO_PAUSE),*/
++	.formats = (SNDRV_PCM_FMTBIT_S16_LE),
++	.rates = (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000 |
++		  SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_32000 |
++		  SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 |
++		  SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000 |
++		  SNDRV_PCM_RATE_KNOT),
++	.rate_min = 8000,
++	.rate_max = 8000,
++	.channels_min = 2,
++	.channels_max = 2,
++	.buffer_bytes_max = 64 * 1024, // All of the lines below may need to be changed
++	.period_bytes_min = 128,
++	.period_bytes_max = 4 * 1024,
++	.periods_min = 16,
++	.periods_max = 32,
++	.fifo_size = 0,
++};
++
++struct gw_avila_runtime_data {
++	spinlock_t lock;
++	int period;		/* current DMA period */
++	int master_lch;		/* Master DMA channel */
++	int slave_lch;		/* Slave DMA channel */
++	struct gw_avila_pcm_dma_params *params;	/* DMA params */
++};
++
++static void gw_avila_dma_irq(void *data)
++{
++	struct snd_pcm_substream *substream = data;
++	snd_pcm_period_elapsed(substream);
++}
++
++static int gw_avila_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
++{
++	struct snd_pcm_runtime *runtime = substream->runtime;
++	struct hss_device *hdev = runtime->private_data;
++	int ret = 0;
++
++	switch (cmd) {
++	case SNDRV_PCM_TRIGGER_START:
++	case SNDRV_PCM_TRIGGER_RESUME:
++	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
++		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
++			hss_tx_start(hdev);
++		else
++			hss_rx_start(hdev);
++		break;
++	case SNDRV_PCM_TRIGGER_STOP:
++	case SNDRV_PCM_TRIGGER_SUSPEND:
++	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
++		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
++			hss_tx_stop(hdev);
++		else
++			hss_rx_stop(hdev);
++		break;
++	default:
++		ret = -EINVAL;
++		break;
++	}
++	return ret;
++}
++
++static int gw_avila_pcm_prepare(struct snd_pcm_substream *substream)
++{
++	struct snd_pcm_runtime *runtime = substream->runtime;
++	struct hss_device *hdev = runtime->private_data;
++
++	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
++		hss_set_tx_callback(hdev, gw_avila_dma_irq, substream);
++		hss_config_tx_dma(hdev, runtime->dma_area, runtime->buffer_size, runtime->period_size);
++	} else {
++		hss_set_rx_callback(hdev, gw_avila_dma_irq, substream);
++		hss_config_rx_dma(hdev, runtime->dma_area, runtime->buffer_size, runtime->period_size);
++	}
++
++	return 0;
++}
++
++static snd_pcm_uframes_t
++gw_avila_pcm_pointer(struct snd_pcm_substream *substream)
++{
++	struct snd_pcm_runtime *runtime = substream->runtime;
++	struct hss_device *hdev = runtime->private_data;
++
++	unsigned int curr = 0;
++	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
++		curr = hss_curr_offset_tx(hdev);
++	else
++		curr = hss_curr_offset_rx(hdev);
++  return curr;
++}
++
++static int gw_avila_pcm_open(struct snd_pcm_substream *substream)
++{
++	struct snd_pcm_runtime *runtime = substream->runtime;
++	struct snd_soc_pcm_runtime *rtd = substream->private_data;
++	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
++
++	snd_soc_set_runtime_hwparams(substream, &gw_avila_pcm_hardware);
++
++	if (hss_handle[cpu_dai->id] != NULL)
++		runtime->private_data = hss_handle[cpu_dai->id];
++	else {
++		pr_err("hss_handle is NULL\n");
++		return -1;
++	}
++
++	hss_chan_open(hss_handle[cpu_dai->id]);
++
++	return 0;
++}
++
++static int gw_avila_pcm_close(struct snd_pcm_substream *substream)
++{
++	struct snd_pcm_runtime *runtime = substream->runtime;
++	struct hss_device *hdev = runtime->private_data;
++
++	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
++		memset(hdev->tx_buf, 0, runtime->buffer_size);
++	} else
++		memset(hdev->rx_buf, 0, runtime->buffer_size);
++
++	hss_chan_close(hdev);
++
++	return 0;
++}
++
++static int gw_avila_pcm_hw_params(struct snd_pcm_substream *substream,
++				 struct snd_pcm_hw_params *hw_params)
++{
++	return snd_pcm_lib_malloc_pages(substream,
++					params_buffer_bytes(hw_params));
++}
++
++static int gw_avila_pcm_hw_free(struct snd_pcm_substream *substream)
++{
++	struct snd_pcm_runtime *runtime = substream->runtime;
++
++	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
++	  memset(runtime->dma_area, 0, runtime->buffer_size);
++
++	return snd_pcm_lib_free_pages(substream);
++}
++
++static int gw_avila_pcm_mmap(struct snd_pcm_substream *substream,
++          struct vm_area_struct *vma)
++{
++	struct snd_pcm_runtime *runtime = substream->runtime;
++
++	return dma_mmap_writecombine(substream->pcm->card->dev, vma,
++						runtime->dma_area,
++						runtime->dma_addr,
++						runtime->dma_bytes);
++}
++
++struct snd_pcm_ops gw_avila_pcm_ops = {
++	.open = 	gw_avila_pcm_open,
++	.close = 	gw_avila_pcm_close,
++	.ioctl = 	snd_pcm_lib_ioctl,
++	.hw_params = 	gw_avila_pcm_hw_params,
++	.hw_free = 	gw_avila_pcm_hw_free,
++	.prepare = 	gw_avila_pcm_prepare,
++	.trigger = 	gw_avila_pcm_trigger,
++	.pointer = 	gw_avila_pcm_pointer,
++	.mmap = gw_avila_pcm_mmap,
++};
++
++static int gw_avila_pcm_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)
++{
++	struct snd_pcm_substream *substream = pcm->streams[stream].substream;
++	struct snd_dma_buffer *buf = &substream->dma_buffer;
++	size_t size = gw_avila_pcm_hardware.buffer_bytes_max;
++
++	buf->dev.type = SNDRV_DMA_TYPE_DEV;
++	buf->dev.dev = pcm->card->dev;
++	buf->private_data = NULL;
++
++	buf->area = dma_alloc_coherent(pcm->card->dev, size,
++					   &buf->addr, GFP_KERNEL);
++
++	if (!buf->area) {
++		return -ENOMEM;
++	}
++
++	memset(buf->area, 0xff, size);
++
++	DPRINTK("preallocate_dma_buffer: area=%p, addr=%p, size=%d\n",
++		(void *) buf->area, (void *) buf->addr, size);
++
++	buf->bytes = size;
++
++	return 0;
++}
++
++static void gw_avila_pcm_free(struct snd_pcm *pcm)
++{
++	struct snd_pcm_substream *substream;
++	struct snd_dma_buffer *buf;
++	int stream;
++
++	for (stream = 0; stream < 2; stream++) {
++		substream = pcm->streams[stream].substream;
++		if (!substream)
++			continue;
++
++		buf = &substream->dma_buffer;
++		if (!buf->area)
++			continue;
++
++		dma_free_coherent(NULL, buf->bytes, buf->area, 0);
++		buf->area = NULL;
++	}
++}
++
++static u64 gw_avila_pcm_dmamask = 0xFFFFFFFF;
++
++static int gw_avila_pcm_new(struct snd_card *card,
++		struct snd_soc_dai *dai, struct snd_pcm *pcm)
++{
++	int ret;
++
++	if (!card->dev->dma_mask)
++		card->dev->dma_mask = &gw_avila_pcm_dmamask;
++	if (!card->dev->coherent_dma_mask)
++		card->dev->coherent_dma_mask = 0xFFFFFFFF;
++
++	if (dai->driver->playback.channels_min) {
++		ret = gw_avila_pcm_preallocate_dma_buffer(pcm,
++			SNDRV_PCM_STREAM_PLAYBACK);
++		if (ret)
++			return ret;
++	}
++
++	if (dai->driver->capture.channels_min) {
++		ret = gw_avila_pcm_preallocate_dma_buffer(pcm,
++			SNDRV_PCM_STREAM_CAPTURE);
++		if (ret)
++			return ret;
++	}
++
++	return 0;
++}
++
++struct snd_soc_platform_driver gw_avila_soc_platform = {
++	.ops = 	&gw_avila_pcm_ops,
++	.pcm_new = 	gw_avila_pcm_new,
++	.pcm_free = 	gw_avila_pcm_free,
++};
++
++static int __devinit gw_avila_pcm_platform_probe(struct platform_device *pdev)
++{
++	return snd_soc_register_platform(&pdev->dev, &gw_avila_soc_platform);
++}
++
++static int __devexit gw_avila_pcm_platform_remove(struct platform_device *pdev)
++{
++	snd_soc_unregister_platform(&pdev->dev);
++	return 0;
++}
++
++static struct platform_driver gw_avila_pcm_driver = {
++	.driver = {
++		.name = "gw_avila-audio",
++		.owner = THIS_MODULE,
++	},
++	.probe = gw_avila_pcm_platform_probe,
++	.remove = __devexit_p(gw_avila_pcm_platform_remove),
++};
++
++static int __init gw_avila_soc_platform_init(void)
++{
++	return platform_driver_register(&gw_avila_pcm_driver);
++}
++module_init(gw_avila_soc_platform_init);
++
++static void __exit gw_avila_soc_platform_exit(void)
++{
++	platform_driver_unregister(&gw_avila_pcm_driver);
++}
++module_exit(gw_avila_soc_platform_exit);
++
++MODULE_AUTHOR("Chris Lang");
++MODULE_DESCRIPTION("Gateworks Avila PCM DMA module");
++MODULE_LICENSE("GPL");
+--- /dev/null
++++ b/sound/soc/gw-avila/gw-avila-pcm.h
+@@ -0,0 +1,32 @@
++/*
++ * ALSA PCM interface for the Gateworks Avila platform
++ *
++ * Author:      Chris Lang, <clang@gateworks.com>
++ * Copyright:   (C) 2009 Gateworks Corporation
++ *
++ * Based On:    davinci-evm.c, Author: Vladimir Barinov, <vbarinov@ru.mvista.com>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ */
++
++#ifndef _GW_AVILA_PCM_H
++#define _GW_AVILA_PCM_H
++
++#if 0
++struct gw_avila_pcm_dma_params {
++	char *name;		/* stream identifier */
++	int channel;		/* sync dma channel ID */
++	dma_addr_t dma_addr;	/* device physical address for DMA */
++	unsigned int data_type;	/* xfer data type */
++};
++
++struct gw_avila_snd_platform_data {
++	int tx_dma_ch; // XXX Do we need this?
++	int rx_dma_ch; // XXX Do we need this
++};
++extern struct snd_soc_platform gw_avila_soc_platform[];
++#endif
++
++#endif
+--- /dev/null
++++ b/sound/soc/gw-avila/gw-avila.c
+@@ -0,0 +1,240 @@
++/*
++ * File:         sound/soc/gw-avila/gw_avila.c
++ * Author:       Chris Lang <clang@gateworks.com>
++ *
++ * Created:      Tue June 06 2008
++ * Description:  Board driver for Gateworks Avila
++ *
++ * Modified:
++ *               Copyright 2009 Gateworks Corporation
++ *
++ * Bugs:         What Bugs?
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, see the file COPYING, or write
++ * to the Free Software Foundation, Inc.,
++ * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
++ */
++
++#include <linux/module.h>
++#include <linux/moduleparam.h>
++#include <linux/device.h>
++#include <asm/dma.h>
++#include <linux/platform_device.h>
++#include <sound/core.h>
++#include <sound/pcm.h>
++#include <sound/soc.h>
++#include <linux/slab.h>
++#include <linux/gpio.h>
++
++#include "ixp4xx_hss.h"
++#include "gw-avila-hss.h"
++#include "gw-avila-pcm.h"
++
++#define CODEC_FREQ 33333000
++
++static int gw_avila_board_startup(struct snd_pcm_substream *substream)
++{
++	pr_debug("%s enter\n", __func__);
++	return 0;
++}
++
++static int gw_avila_hw_params(struct snd_pcm_substream *substream,
++		struct snd_pcm_hw_params *params)
++{
++	struct snd_soc_pcm_runtime *rtd = substream->private_data;
++	struct snd_soc_dai *codec_dai = rtd->codec_dai;
++	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
++
++	int ret = 0;
++
++	/* set codec DAI configuration */
++	if (cpu_dai->id % 2) {
++  		ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_DSP_B | SND_SOC_DAIFMT_IB_NF | SND_SOC_DAIFMT_CBS_CFS);
++			snd_soc_dai_set_tdm_slot(codec_dai, 0, 0, 1, 32);
++	} else {
++	  	ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_DSP_B | SND_SOC_DAIFMT_IB_NF | SND_SOC_DAIFMT_CBM_CFM);
++			snd_soc_dai_set_tdm_slot(codec_dai, 0, 0, 0, 32);
++	}
++
++	if (ret < 0)
++	    return ret;
++
++	/* set the codec system clock */
++	ret = snd_soc_dai_set_sysclk(codec_dai, 0, CODEC_FREQ, SND_SOC_CLOCK_OUT);
++	if (ret < 0)
++	    return ret;
++
++	return 0;
++}
++
++static const struct snd_soc_dapm_widget aic3x_dapm_widgets[] = {
++  SND_SOC_DAPM_HP("Headphone Jack", NULL),
++  SND_SOC_DAPM_LINE("Line Out", NULL),
++  SND_SOC_DAPM_LINE("Line In", NULL),
++};
++
++static const struct snd_soc_dapm_route audio_map[] = {
++  {"Headphone Jack", NULL, "HPLOUT"},
++  {"Headphone Jack", NULL, "HPROUT"},
++
++  /* Line Out connected to LLOUT, RLOUT */
++  {"Line Out", NULL, "LLOUT"},
++  {"Line Out", NULL, "RLOUT"},
++
++  /* Line In connected to (LINE1L | LINE2L), (LINE1R | LINE2R) */
++  {"LINE1L", NULL, "Line In"},
++  {"LINE1R", NULL, "Line In"},
++};
++
++/* Logic for a aic3x as connected on a davinci-evm */
++static int avila_aic3x_init(struct snd_soc_pcm_runtime *rtd)
++{
++	struct snd_soc_codec *codec = rtd->codec;
++	struct snd_soc_dapm_context *dapm = &codec->dapm;
++
++  /* Add davinci-evm specific widgets */
++  snd_soc_dapm_new_controls(dapm, aic3x_dapm_widgets,
++          ARRAY_SIZE(aic3x_dapm_widgets));
++
++  /* Set up davinci-evm specific audio path audio_map */
++  snd_soc_dapm_add_routes(dapm, audio_map, ARRAY_SIZE(audio_map));
++
++  /* not connected */
++  snd_soc_dapm_disable_pin(dapm, "MONO_LOUT");
++  //snd_soc_dapm_disable_pin(dapm, "HPLCOM");
++  //snd_soc_dapm_disable_pin(dapm, "HPRCOM");
++  snd_soc_dapm_disable_pin(dapm, "MIC3L");
++  snd_soc_dapm_disable_pin(dapm, "MIC3R");
++  snd_soc_dapm_disable_pin(dapm, "LINE2L");
++  snd_soc_dapm_disable_pin(dapm, "LINE2R");
++
++  /* always connected */
++	snd_soc_dapm_enable_pin(dapm, "Headphone Jack");
++  snd_soc_dapm_enable_pin(dapm, "Line Out");
++  snd_soc_dapm_enable_pin(dapm, "Line In");
++
++  snd_soc_dapm_sync(dapm);
++
++	return 0;
++}
++
++static struct snd_soc_ops gw_avila_board_ops = {
++	.startup = gw_avila_board_startup,
++	.hw_params = gw_avila_hw_params,
++};
++
++static struct snd_soc_dai_link gw_avila_board_dai[] = {
++	{
++		.name = "HSS-0",
++		.stream_name = "HSS-0",
++		.cpu_dai_name = "gw_avila_hss.0",
++		.codec_dai_name = "tlv320aic3x-hifi",
++		.codec_name = "tlv320aic3x-codec.0-001b",
++		.platform_name = "gw_avila-audio.0",
++		.init = avila_aic3x_init,
++		.ops = &gw_avila_board_ops,
++	},{
++		.name = "HSS-1",
++		.stream_name = "HSS-1",
++		.cpu_dai_name = "gw_avila_hss.1",
++		.codec_dai_name = "tlv320aic3x-hifi",
++		.codec_name = "tlv320aic3x-codec.0-001a",
++		.platform_name = "gw_avila-audio.1",
++		.init = avila_aic3x_init,
++		.ops = &gw_avila_board_ops,
++	},{
++		.name = "HSS-2",
++		.stream_name = "HSS-2",
++		.cpu_dai_name = "gw_avila_hss.2",
++		.codec_dai_name = "tlv320aic3x-hifi",
++		.codec_name = "tlv320aic3x-codec.0-0019",
++		.platform_name = "gw_avila-audio.2",
++		.init = avila_aic3x_init,
++		.ops = &gw_avila_board_ops,
++	},{
++		.name = "HSS-3",
++		.stream_name = "HSS-3",
++		.cpu_dai_name = "gw_avila_hss.3",
++		.codec_dai_name = "tlv320aic3x-hifi",
++		.codec_name = "tlv320aic3x-codec.0-0018",
++		.platform_name = "gw_avila-audio.3",
++		.init = avila_aic3x_init,
++		.ops = &gw_avila_board_ops,
++	},
++};
++
++static struct snd_soc_card gw_avila_board[] = {
++	{
++		.name = "gw_avila-board.0",
++		.dai_link = &gw_avila_board_dai[0],
++		.num_links = 1,
++	},{
++		.name = "gw_avila-board.1",
++		.dai_link = &gw_avila_board_dai[1],
++		.num_links = 1,
++	},{
++		.name = "gw_avila-board.2",
++		.dai_link = &gw_avila_board_dai[2],
++		.num_links = 1,
++	},{
++		.name = "gw_avila-board.3",
++		.dai_link = &gw_avila_board_dai[3],
++		.num_links = 1,
++	}
++};
++
++static struct platform_device *gw_avila_board_snd_device[4];
++
++static int __init gw_avila_board_init(void)
++{
++	int ret;
++	struct port *port;
++	int i;
++
++	if ((hss_port[0] = kzalloc(sizeof(*port), GFP_KERNEL)) == NULL)
++		return -ENOMEM;
++
++	if ((hss_port[1] = kzalloc(sizeof(*port), GFP_KERNEL)) == NULL)
++		return -ENOMEM;
++
++	for (i = 0; i < 4; i++) {
++		gw_avila_board_snd_device[i] = platform_device_alloc("soc-audio", i);
++		if (!gw_avila_board_snd_device[i]) {
++			return -ENOMEM;
++		}
++
++		platform_set_drvdata(gw_avila_board_snd_device[i], &gw_avila_board[i]);
++		ret = platform_device_add(gw_avila_board_snd_device[i]);
++
++		if (ret) {
++			platform_device_put(gw_avila_board_snd_device[i]);
++		}
++	}
++	return ret;
++}
++
++static void __exit gw_avila_board_exit(void)
++{
++	int i;
++	for (i = 0; i < 4; i++)
++		platform_device_unregister(gw_avila_board_snd_device[i]);
++}
++
++module_init(gw_avila_board_init);
++module_exit(gw_avila_board_exit);
++
++/* Module information */
++MODULE_AUTHOR("Chris Lang");
++MODULE_DESCRIPTION("ALSA SoC HSS Audio gw_avila board");
++MODULE_LICENSE("GPL");
+--- /dev/null
++++ b/sound/soc/gw-avila/ixp4xx_hss.c
+@@ -0,0 +1,900 @@
++/*
++ * Intel IXP4xx HSS (synchronous serial port) driver for Linux
++ *
++ * Copyright (C) 2009 Chris Lang <clang@gateworks.com>
++ *
++ * This program is free software; you can redistribute it and/or modify it
++ * under the terms of version 2 of the GNU General Public License
++ * as published by the Free Software Foundation.
++ */
++
++#include <linux/bitops.h>
++#include <linux/cdev.h>
++#include <linux/dma-mapping.h>
++#include <linux/dmapool.h>
++#include <linux/fs.h>
++#include <linux/io.h>
++#include <linux/kernel.h>
++#include <linux/platform_device.h>
++#include <linux/poll.h>
++#include <linux/slab.h>
++#include <mach/npe.h>
++#include <mach/qmgr.h>
++#include <linux/delay.h>
++
++#include "ixp4xx_hss.h"
++
++/*****************************************************************************
++ * global variables
++ ****************************************************************************/
++
++void hss_chan_read(unsigned long data);
++static char lock_init = 0;
++static spinlock_t npe_lock;
++static struct npe *npe;
++
++static const struct {
++	int tx, txdone, rx, rxfree, chan;
++}queue_ids[2] = {{HSS0_PKT_TX0_QUEUE, HSS0_PKT_TXDONE_QUEUE, HSS0_PKT_RX_QUEUE,
++		  HSS0_PKT_RXFREE0_QUEUE, HSS0_CHL_RXTRIG_QUEUE},
++		 {HSS1_PKT_TX0_QUEUE, HSS1_PKT_TXDONE_QUEUE, HSS1_PKT_RX_QUEUE,
++		  HSS1_PKT_RXFREE0_QUEUE, HSS1_CHL_RXTRIG_QUEUE},
++};
++
++struct port *hss_port[2];
++struct hss_device *hss_handle[32];
++EXPORT_SYMBOL(hss_handle);
++
++/*****************************************************************************
++ * utility functions
++ ****************************************************************************/
++
++#ifndef __ARMEB__
++static inline void memcpy_swab32(u32 *dest, u32 *src, int cnt)
++{
++	int i;
++	for (i = 0; i < cnt; i++)
++		dest[i] = swab32(src[i]);
++}
++#endif
++
++static inline unsigned int sub_offset(unsigned int a, unsigned int b,
++				      unsigned int modulo)
++{
++	return (modulo /* make sure the result >= 0 */ + a - b) % modulo;
++}
++
++/*****************************************************************************
++ * HSS access
++ ****************************************************************************/
++
++static void hss_config_load(struct port *port)
++{
++	struct msg msg;
++
++	do {
++		memset(&msg, 0, sizeof(msg));
++		msg.cmd = PORT_CONFIG_LOAD;
++		msg.hss_port = port->id;
++		if (npe_send_message(npe, &msg, "HSS_LOAD_CONFIG"))
++			break;
++		if (npe_recv_message(npe, &msg, "HSS_LOAD_CONFIG"))
++			break;
++
++		/* HSS_LOAD_CONFIG for port #1 returns port_id = #4 */
++		if (msg.cmd != PORT_CONFIG_LOAD || msg.data32)
++			break;
++
++		/* HDLC may stop working without this */
++		npe_recv_message(npe, &msg, "FLUSH_IT");
++		return;
++	} while (0);
++
++	printk(KERN_CRIT "HSS-%i: unable to reload HSS configuration\n",
++	       port->id);
++	BUG();
++}
++
++static void hss_config_set_pcr(struct port *port)
++{
++	struct msg msg;
++
++	do {
++		memset(&msg, 0, sizeof(msg));
++		msg.cmd = PORT_CONFIG_WRITE;
++		msg.hss_port = port->id;
++		msg.index = HSS_CONFIG_TX_PCR;
++#if 0
++		msg.data32 = PCR_FRM_SYNC_RISINGEDGE | PCR_MSB_ENDIAN |
++			PCR_TX_DATA_ENABLE | PCR_TX_UNASS_HIGH_IMP | PCR_TX_V56K_HIGH_IMP | PCR_TX_FB_HIGH_IMP;
++#else
++		msg.data32 = PCR_FRM_SYNC_RISINGEDGE | PCR_MSB_ENDIAN |
++			PCR_TX_DATA_ENABLE | PCR_TX_FB_HIGH_IMP | PCR_DCLK_EDGE_RISING;
++#endif
++		if (port->frame_size % 8 == 0)
++			msg.data32 |= PCR_SOF_NO_FBIT;
++
++		if (npe_send_message(npe, &msg, "HSS_SET_TX_PCR"))
++			break;
++
++		msg.index = HSS_CONFIG_RX_PCR;
++		msg.data32 &= ~ (PCR_DCLK_EDGE_RISING | PCR_FCLK_EDGE_RISING | PCR_TX_DATA_ENABLE);
++
++		if (npe_send_message(npe, &msg, "HSS_SET_RX_PCR"))
++			break;
++		return;
++	} while (0);
++
++	printk(KERN_CRIT "HSS-%i: unable to set HSS PCR registers\n", port->id);
++	BUG();
++}
++
++static void hss_config_set_core(struct port *port)
++{
++	struct msg msg;
++
++	memset(&msg, 0, sizeof(msg));
++	msg.cmd = PORT_CONFIG_WRITE;
++	msg.hss_port = port->id;
++	msg.index = HSS_CONFIG_CORE_CR;
++#if 0
++	msg.data32 = 0 | CCR_LOOPBACK |
++		(port->id ? CCR_SECOND_HSS : 0);
++#else
++	msg.data32 = 0 |
++		(port->id ? CCR_SECOND_HSS : 0);
++#endif
++	if (npe_send_message(npe, &msg, "HSS_SET_CORE_CR")) {
++		printk(KERN_CRIT "HSS-%i: unable to set HSS core control"
++		       " register\n", port->id);
++		BUG();
++	}
++}
++
++static void hss_config_set_line(struct port *port)
++{
++	struct msg msg;
++
++	hss_config_set_pcr(port);
++	hss_config_set_core(port);
++
++	memset(&msg, 0, sizeof(msg));
++	msg.cmd = PORT_CONFIG_WRITE;
++	msg.hss_port = port->id;
++	msg.index = HSS_CONFIG_CLOCK_CR;
++	msg.data32 = CLK42X_SPEED_8192KHZ /* FIXME */;
++	if (npe_send_message(npe, &msg, "HSS_SET_CLOCK_CR")) {
++		printk(KERN_CRIT "HSS-%i: unable to set HSS clock control"
++		       " register\n", port->id);
++		BUG();
++	}
++}
++
++static void hss_config_set_rx_frame(struct port *port)
++{
++	struct msg msg;
++
++	memset(&msg, 0, sizeof(msg));
++	msg.cmd = PORT_CONFIG_WRITE;
++	msg.hss_port = port->id;
++	msg.index = HSS_CONFIG_RX_FCR;
++	msg.data16a = port->frame_sync_offset;
++	msg.data16b = port->frame_size - 1;
++	if (npe_send_message(npe, &msg, "HSS_SET_RX_FCR")) {
++		printk(KERN_CRIT "HSS-%i: unable to set HSS RX frame size"
++		       " and offset\n", port->id);
++		BUG();
++	}
++}
++
++static void hss_config_set_frame(struct port *port)
++{
++	struct msg msg;
++
++	memset(&msg, 0, sizeof(msg));
++	msg.cmd = PORT_CONFIG_WRITE;
++	msg.hss_port = port->id;
++	msg.index = HSS_CONFIG_TX_FCR;
++	msg.data16a = TX_FRAME_SYNC_OFFSET;
++	msg.data16b = port->frame_size - 1;
++	if (npe_send_message(npe, &msg, "HSS_SET_TX_FCR")) {
++		printk(KERN_CRIT "HSS-%i: unable to set HSS TX frame size"
++		       " and offset\n", port->id);
++		BUG();
++	}
++	hss_config_set_rx_frame(port);
++}
++
++static void hss_config_set_lut(struct port *port)
++{
++	struct msg msg;
++	int chan_count = 32;
++
++	memset(&msg, 0, sizeof(msg));
++	msg.cmd = PORT_CONFIG_WRITE;
++	msg.hss_port = port->id;
++
++	msg.index = HSS_CONFIG_TX_LUT;
++	msg.data32 = 0xffffffff;
++	npe_send_message(npe, &msg, "HSS_SET_TX_LUT");
++	msg.index += 4;
++	npe_send_message(npe, &msg, "HSS_SET_TX_LUT");
++	msg.data32 = 0x0;
++	msg.index += 4;
++	npe_send_message(npe, &msg, "HSS_SET_TX_LUT");
++	msg.index += 4;
++	npe_send_message(npe, &msg, "HSS_SET_TX_LUT");
++	msg.index += 4;
++	npe_send_message(npe, &msg, "HSS_SET_TX_LUT");
++	msg.index += 4;
++	npe_send_message(npe, &msg, "HSS_SET_TX_LUT");
++	msg.index += 4;
++	npe_send_message(npe, &msg, "HSS_SET_TX_LUT");
++	msg.index += 4;
++	npe_send_message(npe, &msg, "HSS_SET_TX_LUT");
++
++	msg.index = HSS_CONFIG_RX_LUT;
++	msg.data32 = 0xffffffff;
++	npe_send_message(npe, &msg, "HSS_SET_RX_LUT");
++	msg.index += 4;
++	npe_send_message(npe, &msg, "HSS_SET_RX_LUT");
++	msg.data32 = 0x0;
++	msg.index += 4;
++	npe_send_message(npe, &msg, "HSS_SET_RX_LUT");
++	msg.index += 4;
++	npe_send_message(npe, &msg, "HSS_SET_RX_LUT");
++	msg.index += 4;
++	npe_send_message(npe, &msg, "HSS_SET_RX_LUT");
++	msg.index += 4;
++	npe_send_message(npe, &msg, "HSS_SET_RX_LUT");
++	msg.index += 4;
++	npe_send_message(npe, &msg, "HSS_SET_RX_LUT");
++	msg.index += 4;
++	npe_send_message(npe, &msg, "HSS_SET_RX_LUT");
++
++	hss_config_set_frame(port);
++
++	memset(&msg, 0, sizeof(msg));
++	msg.cmd = CHAN_NUM_CHANS_WRITE;
++	msg.hss_port = port->id;
++	msg.data8a = chan_count;
++	if (npe_send_message(npe, &msg, "CHAN_NUM_CHANS_WRITE")) {
++		printk(KERN_CRIT "HSS-%i: unable to set HSS channel count\n",
++		       port->id);
++		BUG();
++	}
++}
++
++static u32 hss_config_get_status(struct port *port)
++{
++	struct msg msg;
++
++	do {
++		memset(&msg, 0, sizeof(msg));
++		msg.cmd = PORT_ERROR_READ;
++		msg.hss_port = port->id;
++		if (npe_send_message(npe, &msg, "PORT_ERROR_READ"))
++			break;
++		if (npe_recv_message(npe, &msg, "PORT_ERROR_READ"))
++			break;
++
++		return msg.data32;
++	} while (0);
++
++	printk(KERN_CRIT "HSS-%i: unable to read HSS status\n", port->id);
++	BUG();
++}
++
++static void hss_config_start_chan(struct port *port)
++{
++	struct msg msg;
++
++	port->chan_last_tx = 0;
++	port->chan_last_rx = 0;
++
++	do {
++		memset(&msg, 0, sizeof(msg));
++		msg.cmd = CHAN_RX_BUF_ADDR_WRITE;
++		msg.hss_port = port->id;
++		msg.data32 = port->chan_rx_buf_phys;
++		if (npe_send_message(npe, &msg, "CHAN_RX_BUF_ADDR_WRITE"))
++			break;
++
++		memset(&msg, 0, sizeof(msg));
++		msg.cmd = CHAN_TX_BUF_ADDR_WRITE;
++		msg.hss_port = port->id;
++		msg.data32 = port->chan_tx_pointers_phys;
++		if (npe_send_message(npe, &msg, "CHAN_TX_BUF_ADDR_WRITE"))
++			break;
++
++		memset(&msg, 0, sizeof(msg));
++		msg.cmd = CHAN_FLOW_ENABLE;
++		msg.hss_port = port->id;
++		if (npe_send_message(npe, &msg, "CHAN_FLOW_ENABLE"))
++			break;
++		port->chan_started = 1;
++		return;
++	} while (0);
++
++	printk(KERN_CRIT "HSS-%i: unable to start channelized flow\n",
++	       port->id);
++	BUG();
++}
++
++static void hss_config_stop_chan(struct port *port)
++{
++	struct msg msg;
++
++	if (!port->chan_started)
++		return;
++
++	memset(&msg, 0, sizeof(msg));
++	msg.cmd = CHAN_FLOW_DISABLE;
++	msg.hss_port = port->id;
++	if (npe_send_message(npe, &msg, "CHAN_FLOW_DISABLE")) {
++		printk(KERN_CRIT "HSS-%i: unable to stop channelized flow\n",
++		       port->id);
++		BUG();
++	}
++	hss_config_get_status(port); /* make sure it's halted */
++	port->chan_started = 0;
++}
++
++static int hss_config_load_firmware(struct port *port)
++{
++	struct msg msg;
++
++	if (port->initialized)
++		return 0;
++
++	if (!npe_running(npe)) {
++		int err;
++		if ((err = npe_load_firmware(npe, "NPE-A-HSS",
++					     port->dev)))
++			return err;
++	}
++
++	do {
++		/* HSS main configuration */
++		hss_config_set_line(port);
++
++		hss_config_set_frame(port);
++
++		/* Channelized operation settings */
++		memset(&msg, 0, sizeof(msg));
++		msg.cmd = CHAN_TX_BLK_CFG_WRITE;
++		msg.hss_port = port->id;
++		msg.data8b = (CHAN_TX_LIST_FRAMES & ~7) / 2;
++		msg.data8a = msg.data8b / 4;
++		msg.data8d = CHAN_TX_LIST_FRAMES - msg.data8b;
++		msg.data8c = msg.data8d / 4;
++		if (npe_send_message(npe, &msg, "CHAN_TX_BLK_CFG_WRITE"))
++			break;
++
++		memset(&msg, 0, sizeof(msg));
++		msg.cmd = CHAN_RX_BUF_CFG_WRITE;
++		msg.hss_port = port->id;
++		msg.data8a = CHAN_RX_TRIGGER / 8;
++		msg.data8b = CHAN_RX_FRAMES;
++		if (npe_send_message(npe, &msg, "CHAN_RX_BUF_CFG_WRITE"))
++			break;
++
++		memset(&msg, 0, sizeof(msg));
++		msg.cmd = CHAN_TX_BUF_SIZE_WRITE;
++		msg.hss_port = port->id;
++		msg.data8a = CHAN_TX_LISTS;
++		if (npe_send_message(npe, &msg, "CHAN_TX_BUF_SIZE_WRITE"))
++			break;
++
++		port->initialized = 1;
++		return 0;
++	} while (0);
++
++	printk(KERN_CRIT "HSS-%i: unable to start HSS operation\n", port->id);
++	BUG();
++}
++
++void hss_chan_irq(void *pdev)
++{
++	struct port *port = pdev;
++
++	qmgr_disable_irq(queue_ids[port->id].chan);
++
++	tasklet_hi_schedule(&port->task);
++}
++
++
++int hss_prepare_chan(struct port *port)
++{
++	int err, i, j;
++	u32 *temp;
++	u32 temp2;
++	u8 *temp3;
++
++	if (port->initialized)
++		return 0;
++
++	if ((err = hss_config_load_firmware(port)))
++		return err;
++
++	if ((err = qmgr_request_queue(queue_ids[port->id].chan,
++				      CHAN_QUEUE_LEN, 0, 0, "%s:hss", "hss")))
++		return err;
++
++	port->chan_tx_buf = dma_alloc_coherent(port->dev, chan_tx_buf_len(port), &port->chan_tx_buf_phys, GFP_DMA);
++	memset(port->chan_tx_buf, 0, chan_tx_buf_len(port));
++
++	port->chan_tx_pointers = dma_alloc_coherent(port->dev, chan_tx_buf_len(port) / CHAN_TX_LIST_FRAMES * 4, &port->chan_tx_pointers_phys, GFP_DMA);
++
++	temp3 = port->chan_tx_buf;
++	for (i = 0; i < CHAN_TX_LISTS; i++) {
++		for (j = 0; j < 8; j++) {
++			port->tx_lists[i][j] = temp3;
++			temp3 += CHAN_TX_LIST_FRAMES * 4;
++		}
++	}
++
++	temp = port->chan_tx_pointers;
++	temp2 = port->chan_tx_buf_phys;
++	for (i = 0; i < CHAN_TX_LISTS; i++)
++	{
++		for (j = 0; j < 32; j++)
++		{
++			*temp = temp2;
++			temp2 += CHAN_TX_LIST_FRAMES;
++			temp++;
++		}
++	}
++
++	port->chan_rx_buf = dma_alloc_coherent(port->dev, chan_rx_buf_len(port), &port->chan_rx_buf_phys, GFP_DMA);
++
++	for (i = 0; i < 8; i++) {
++		temp3 = port->chan_rx_buf + (i * 4 * 128);
++		for (j = 0; j < 8; j++) {
++			port->rx_frames[i][j] = temp3;
++			temp3 += CHAN_RX_TRIGGER;
++		}
++	}
++
++	qmgr_set_irq(queue_ids[port->id].chan, QUEUE_IRQ_SRC_NOT_EMPTY,
++		     hss_chan_irq, port);
++
++	return 0;
++
++}
++
++int hss_tx_start(struct hss_device *hdev)
++{
++	unsigned long flags;
++	struct port *port = hdev->port;
++
++	hdev->tx_loc = 0;
++	hdev->tx_frame = 0;
++
++	set_bit((1 << hdev->id), &port->chan_tx_bitmap);
++
++	if (!port->chan_started)
++	{
++		qmgr_enable_irq(queue_ids[port->id].chan);
++		spin_lock_irqsave(&npe_lock, flags);
++		hss_config_start_chan(port);
++		spin_unlock_irqrestore(&npe_lock, flags);
++		hss_chan_irq(port);
++	}
++
++	return 0;
++}
++EXPORT_SYMBOL(hss_tx_start);
++
++int hss_rx_start(struct hss_device *hdev)
++{
++	unsigned long flags;
++	struct port *port = hdev->port;
++
++	hdev->rx_loc = 0;
++	hdev->rx_frame = 0;
++
++	set_bit((1 << hdev->id), &port->chan_rx_bitmap);
++
++	if (!port->chan_started)
++	{
++		qmgr_enable_irq(queue_ids[port->id].chan);
++		spin_lock_irqsave(&npe_lock, flags);
++		hss_config_start_chan(port);
++		spin_unlock_irqrestore(&npe_lock, flags);
++		hss_chan_irq(port);
++	}
++
++	return 0;
++}
++EXPORT_SYMBOL(hss_rx_start);
++
++int hss_tx_stop(struct hss_device *hdev)
++{
++	struct port *port = hdev->port;
++
++	clear_bit((1 << hdev->id), &port->chan_tx_bitmap);
++
++	return 0;
++}
++EXPORT_SYMBOL(hss_tx_stop);
++
++int hss_rx_stop(struct hss_device *hdev)
++{
++	struct port *port = hdev->port;
++
++	clear_bit((1 << hdev->id), &port->chan_rx_bitmap);
++
++	return 0;
++}
++EXPORT_SYMBOL(hss_rx_stop);
++
++int hss_chan_open(struct hss_device *hdev)
++{
++	struct port *port = hdev->port;
++	int i, err = 0;
++
++	if (port->chan_open)
++		return 0;
++
++	if (port->mode == MODE_HDLC) {
++		err = -ENOSYS;
++		goto out;
++	}
++
++	if (port->mode == MODE_G704 && port->channels[0] == hdev->id) {
++		err = -EBUSY; /* channel #0 is used for G.704 signaling */
++		goto out;
++	}
++
++	for (i = MAX_CHANNELS; i > port->frame_size / 8; i--)
++		if (port->channels[i - 1] == hdev->id) {
++			err = -ECHRNG; /* frame too short */
++			goto out;
++		}
++
++	hdev->rx_loc = hdev->tx_loc = 0;
++	hdev->rx_frame = hdev->tx_frame = 0;
++
++	//clear_bit((1 << hdev->id), &port->chan_rx_bitmap);
++	//clear_bit((1 << hdev->id), &port->chan_tx_bitmap);
++
++	if (!port->initialized) {
++		hss_prepare_chan(port);
++
++		hss_config_stop_chan(port);
++		hdev->open_count++;
++		port->chan_open_count++;
++
++		hss_config_set_lut(port);
++		hss_config_load(port);
++
++	}
++	port->chan_open = 1;
++
++out:
++	return err;
++}
++EXPORT_SYMBOL(hss_chan_open);
++
++int hss_chan_close(struct hss_device *hdev)
++{
++	return 0;
++}
++EXPORT_SYMBOL(hss_chan_close);
++
++void hss_chan_read(unsigned long data)
++{
++	struct port *port = (void *)data;
++	struct hss_device *hdev;
++	u8 *hw_buf, *save_buf;
++	u8 *buf;
++	u32 v;
++  unsigned int tx_list, rx_frame;
++	int i, j, channel;
++	u8 more_work = 0;
++
++/*
++	My Data in the hardware buffer is scattered by channels into 4 trunks
++	as follows for rx
++
++					channel 0					channel 1					channel 2					channel 3
++Trunk 1	=	0			-> 	127			128		->	255			256		->	383			384		->	512
++Trunk 2 =	513		->	639			640		->	768			769		->	895			896		->	1023
++Trunk 3 =	1024	->	1151		1152	->	1207		1208	->	1407		1408	->	1535
++Trunk 4 = 1535	->	1663		1664	->	1791		1792	->	1920		1921	->	2047
++
++	I will get CHAN_RX_TRIGGER worth of bytes out of each channel on each trunk
++	with each IRQ
++
++	For TX Data, it is split into 8 lists with each list containing 16 bytes per
++	channel
++
++Trunk 1 = 0		->	16				17		->	32			33		->	48			49		->	64
++Trunk 2 = 65	->	80				81		->	96			97		->	112			113		->	128
++Trunk	3	=	129	->	144				145		->	160			161		->	176			177		->	192
++Trunk	4	=	193	->	208				209		->	224			225		->	240			241		->	256
++
++*/
++
++
++	while ((v = qmgr_get_entry(queue_ids[port->id].chan)))
++	{
++		tx_list = (v >> 8) & 0xFF;
++		rx_frame = v & 0xFF;
++
++		if (tx_list == 7)
++			tx_list = 0;
++		else
++			tx_list++;
++		for (channel = 0; channel < 8; channel++) {
++
++			hdev = port->chan_devices[channel];
++			if (!hdev)
++				continue;
++
++			if (test_bit(1 << channel, &port->chan_tx_bitmap)) {
++				buf = (u8 *)hdev->tx_buf + hdev->tx_loc;
++#if 0
++				hw_buf = (u8 *)port->chan_tx_buf;
++				hw_buf += (tx_list * CHAN_TX_LIST_FRAMES * 32);
++				hw_buf += (4 * CHAN_TX_LIST_FRAMES * channel);
++				save_buf = hw_buf;
++#else
++				save_buf = port->tx_lists[tx_list][channel];
++#endif
++				for (i = 0; i < CHAN_TX_LIST_FRAMES; i++) {
++					hw_buf = save_buf + i;
++					for (j = 0; j < 4; j++) {
++						*hw_buf = *(buf++);
++						hw_buf += CHAN_TX_LIST_FRAMES;
++					}
++
++					hdev->tx_loc += 4;
++					hdev->tx_frame++;
++					if (hdev->tx_loc >= hdev->tx_buffer_size) {
++						hdev->tx_loc = 0;
++						buf = (u8 *)hdev->tx_buf;
++					}
++				}
++			} else {
++#if 0
++				hw_buf = (u8 *)port->chan_tx_buf;
++				hw_buf += (tx_list * CHAN_TX_LIST_FRAMES * 32);
++				hw_buf += (4 * CHAN_TX_LIST_FRAMES * channel);
++#else
++				hw_buf = port->tx_lists[tx_list][channel];
++#endif
++				memset(hw_buf, 0, 64);
++			}
++
++			if (hdev->tx_frame >= hdev->tx_period_size && test_bit(1 << channel, &port->chan_tx_bitmap))
++			{
++				hdev->tx_frame %= hdev->tx_period_size;
++				if (hdev->tx_callback)
++					hdev->tx_callback(hdev->tx_data);
++				more_work = 1;
++			}
++
++			if (test_bit(1 << channel, &port->chan_rx_bitmap)) {
++				buf = (u8 *)hdev->rx_buf + hdev->rx_loc;
++#if 0
++				hw_buf = (u8 *)port->chan_rx_buf;
++				hw_buf += (4 * CHAN_RX_FRAMES * channel);
++				hw_buf += rx_frame;
++				save_buf = hw_buf;
++#else
++				save_buf = port->rx_frames[channel][rx_frame >> 4];
++#endif
++				for (i = 0; i < CHAN_RX_TRIGGER; i++) {
++					hw_buf = save_buf + i;
++					for (j = 0; j < 4; j++) {
++						*(buf++) = *hw_buf;
++						hw_buf += CHAN_RX_FRAMES;
++					}
++					hdev->rx_loc += 4;
++					hdev->rx_frame++;
++					if (hdev->rx_loc >= hdev->rx_buffer_size) {
++						hdev->rx_loc = 0;
++						buf = (u8 *)hdev->rx_buf;
++					}
++				}
++			}
++
++			if (hdev->rx_frame >= hdev->rx_period_size && test_bit(1 << channel, &port->chan_rx_bitmap))
++			{
++				hdev->rx_frame %= hdev->rx_period_size;
++				if (hdev->rx_callback)
++					hdev->rx_callback(hdev->rx_data);
++				more_work = 1;
++			}
++		}
++#if 0
++		if (more_work)
++		{
++			tasklet_hi_schedule(&port->task);
++			return;
++		}
++#endif
++	}
++
++	qmgr_enable_irq(queue_ids[port->id].chan);
++
++	return;
++
++}
++
++struct hss_device *hss_chan_create(struct port *port, unsigned int channel)
++{
++	struct hss_device *chan_dev;
++	unsigned long flags;
++
++	chan_dev = kzalloc(sizeof(struct hss_device), GFP_KERNEL);
++
++	spin_lock_irqsave(&npe_lock, flags);
++
++	chan_dev->id = channel;
++	chan_dev->port = port;
++
++	port->channels[channel] = channel;
++
++	port->chan_devices[channel] = chan_dev;
++
++	spin_unlock_irqrestore(&npe_lock, flags);
++
++	return chan_dev;
++}
++
++/*****************************************************************************
++ * initialization
++ ****************************************************************************/
++
++static struct platform_device gw_avila_hss_device_0 = {
++  .name     = "ixp4xx_hss",
++  .id       = 0,
++};
++
++static struct platform_device gw_avila_hss_device_1 = {
++  .name     = "ixp4xx_hss",
++  .id       = 1,
++};
++
++static struct platform_device *gw_avila_hss_port_0;
++static struct platform_device *gw_avila_hss_port_1;
++static u64 hss_dmamask = 0xFFFFFFFF;
++
++struct hss_device *hss_init(int id, int channel)
++{
++	struct port *port = hss_port[id];
++	struct hss_device *hdev;
++	int ret;
++
++	if (!lock_init)
++	{
++		spin_lock_init(&npe_lock);
++		lock_init = 1;
++		npe = npe_request(0);
++	}
++
++	if (!port->init) {
++		if (id == 0) {
++			gw_avila_hss_port_0 = platform_device_alloc("hss-port", 0);
++
++			platform_set_drvdata(gw_avila_hss_port_0, &gw_avila_hss_device_0);
++			port->dev = &gw_avila_hss_port_0->dev;
++
++			if (!port->dev->dma_mask)
++		    port->dev->dma_mask = &hss_dmamask;
++		  if (!port->dev->coherent_dma_mask)
++	    	port->dev->coherent_dma_mask = 0xFFFFFFFF;
++
++			ret = platform_device_add(gw_avila_hss_port_0);
++
++		  if (ret)
++	  	  platform_device_put(gw_avila_hss_port_0);
++
++			tasklet_init(&port->task, hss_chan_read, (unsigned long) port);
++		}
++		else
++		{
++			gw_avila_hss_port_1 = platform_device_alloc("hss-port", 1);
++
++			platform_set_drvdata(gw_avila_hss_port_1, &gw_avila_hss_device_1);
++			port->dev = &gw_avila_hss_port_1->dev;
++
++			if (!port->dev->dma_mask)
++		    port->dev->dma_mask = &hss_dmamask;
++		  if (!port->dev->coherent_dma_mask)
++	    	port->dev->coherent_dma_mask = 0xFFFFFFFF;
++
++			ret = platform_device_add(gw_avila_hss_port_1);
++
++		  if (ret)
++	  	  platform_device_put(gw_avila_hss_port_1);
++
++			tasklet_init(&port->task, hss_chan_read, (unsigned long) port);
++		}
++
++		port->init = 1;
++		port->id = id;
++		port->clock_type = CLOCK_EXT;
++		port->clock_rate = 8192000;
++		port->frame_size = 256; /* E1 */
++		port->mode = MODE_RAW;
++		port->next_rx_frame = 0;
++		memset(port->channels, CHANNEL_UNUSED, sizeof(port->channels));
++	}
++
++	hdev = hss_chan_create(port, channel);
++
++	return hdev;
++}
++EXPORT_SYMBOL(hss_init);
++
++int hss_set_tx_callback(struct hss_device *hdev, void (*tx_callback)(void *), void *tx_data)
++{
++  BUG_ON(tx_callback == NULL);
++  hdev->tx_callback = tx_callback;
++  hdev->tx_data = tx_data;
++
++  return 0;
++}
++EXPORT_SYMBOL(hss_set_tx_callback);
++
++int hss_set_rx_callback(struct hss_device *hdev, void (*rx_callback)(void *), void *rx_data)
++{
++  BUG_ON(rx_callback == NULL);
++  hdev->rx_callback = rx_callback;
++  hdev->rx_data = rx_data;
++
++  return 0;
++}
++EXPORT_SYMBOL(hss_set_rx_callback);
++
++int hss_config_rx_dma(struct hss_device *hdev, void *buf, size_t buffer_size, size_t period_size)
++{
++	/*
++	 * Period Size and Buffer Size are in Frames which are u32
++	 * We convert the u32 *buf to u8 in order to make channel reads
++	 * and rx_loc easier
++	 */
++
++	hdev->rx_buf = (u8 *)buf;
++	hdev->rx_buffer_size = buffer_size << 2;
++	hdev->rx_period_size = period_size;
++
++	return 0;
++}
++EXPORT_SYMBOL(hss_config_rx_dma);
++
++int hss_config_tx_dma(struct hss_device *hdev, void *buf, size_t buffer_size, size_t period_size)
++{
++	/*
++	 * Period Size and Buffer Size are in Frames which are u32
++	 * We convert the u32 *buf to u8 in order to make channel reads
++	 * and rx_loc easier
++	 */
++
++	hdev->tx_buf = (u8 *)buf;
++	hdev->tx_buffer_size = buffer_size << 2;
++	hdev->tx_period_size = period_size;
++
++	return 0;
++}
++EXPORT_SYMBOL(hss_config_tx_dma);
++
++unsigned long hss_curr_offset_rx(struct hss_device *hdev)
++{
++	return hdev->rx_loc >> 2;
++}
++EXPORT_SYMBOL(hss_curr_offset_rx);
++
++unsigned long hss_curr_offset_tx(struct hss_device *hdev)
++{
++	return hdev->tx_loc >> 2;
++}
++EXPORT_SYMBOL(hss_curr_offset_tx);
++
++MODULE_AUTHOR("Chris Lang");
++MODULE_DESCRIPTION("Intel IXP4xx HSS Audio driver");
++MODULE_LICENSE("GPL v2");
+--- /dev/null
++++ b/sound/soc/gw-avila/ixp4xx_hss.h
+@@ -0,0 +1,401 @@
++/*
++ *
++ *
++ * Copyright (C) 2009 Gateworks Corporation
++ *
++ * This program is free software; you can redistribute it and/or modify it
++ * under the terms of version 2 of the GNU General Public License
++ * as published by the Free Software Foundation.
++ */
++
++#include <linux/types.h>
++#include <linux/bitops.h>
++#include <linux/dma-mapping.h>
++#include <linux/dmapool.h>
++#include <linux/fs.h>
++#include <linux/io.h>
++#include <linux/kernel.h>
++#include <linux/platform_device.h>
++#include <linux/poll.h>
++#include <mach/npe.h>
++#include <mach/qmgr.h>
++#include <linux/interrupt.h>
++
++//#include <linux/hdlc.h> XXX We aren't HDLC
++
++#define DEBUG_QUEUES		0
++#define DEBUG_DESC		0
++#define DEBUG_RX		0
++#define DEBUG_TX		0
++#define DEBUG_PKT_BYTES		0
++#define DEBUG_CLOSE		0
++#define DEBUG_FRAMER		0
++
++#define DRV_NAME		"ixp4xx_hss"
++
++#define PKT_EXTRA_FLAGS		0 /* orig 1 */
++#define TX_FRAME_SYNC_OFFSET	0 /* channelized */
++#define PKT_NUM_PIPES		1 /* 1, 2 or 4 */
++#define PKT_PIPE_FIFO_SIZEW	4 /* total 4 dwords per HSS */
++
++#define RX_DESCS		512 /* also length of all RX queues */
++#define TX_DESCS		512 /* also length of all TX queues */
++
++//#define POOL_ALLOC_SIZE		(sizeof(struct desc) * (RX_DESCS + TX_DESCS))
++#define RX_SIZE			(HDLC_MAX_MRU + 4) /* NPE needs more space */
++#define MAX_CLOSE_WAIT		1000 /* microseconds */
++#define HSS_COUNT		2
++#define MIN_FRAME_SIZE		16   /* bits */
++#define MAX_FRAME_SIZE		257  /* 256 bits + framing bit */
++#define MAX_CHANNELS		(MAX_FRAME_SIZE / 8)
++#define MAX_CHAN_DEVICES	32
++#define CHANNEL_HDLC		0xFE
++#define CHANNEL_UNUSED		0xFF
++
++#define NAPI_WEIGHT		16
++#define CHAN_RX_TRIGGER		16 /* 8 RX frames = 1 ms @ E1 */
++#define CHAN_RX_FRAMES		128
++#define CHAN_RX_TRUNKS		1
++#define MAX_CHAN_RX_BAD_SYNC	(CHAN_RX_TRIGGER / 2 /* pairs */ - 3)
++
++#define CHAN_TX_LIST_FRAMES	CHAN_RX_TRIGGER /* bytes/channel per list, 16 - 48 */
++#define CHAN_TX_LISTS		8
++#define CHAN_TX_TRUNKS CHAN_RX_TRUNKS
++#define CHAN_TX_FRAMES		(CHAN_TX_LIST_FRAMES * CHAN_TX_LISTS)
++
++#define CHAN_QUEUE_LEN		32 /* minimum possible */
++
++#define chan_rx_buf_len(port)	(port->frame_size / 8 * CHAN_RX_FRAMES * CHAN_RX_TRUNKS)
++#define chan_tx_buf_len(port) (port->frame_size / 8 * CHAN_TX_FRAMES * CHAN_TX_TRUNKS)
++
++/* Queue IDs */
++#define HSS0_CHL_RXTRIG_QUEUE	12	/* orig size = 32 dwords */
++#define HSS0_PKT_RX_QUEUE	13	/* orig size = 32 dwords */
++#define HSS0_PKT_TX0_QUEUE	14	/* orig size = 16 dwords */
++#define HSS0_PKT_TX1_QUEUE	15
++#define HSS0_PKT_TX2_QUEUE	16
++#define HSS0_PKT_TX3_QUEUE	17
++#define HSS0_PKT_RXFREE0_QUEUE	18	/* orig size = 16 dwords */
++#define HSS0_PKT_RXFREE1_QUEUE	19
++#define HSS0_PKT_RXFREE2_QUEUE	20
++#define HSS0_PKT_RXFREE3_QUEUE	21
++#define HSS0_PKT_TXDONE_QUEUE	22	/* orig size = 64 dwords */
++
++#define HSS1_CHL_RXTRIG_QUEUE	10
++#define HSS1_PKT_RX_QUEUE	0
++#define HSS1_PKT_TX0_QUEUE	5
++#define HSS1_PKT_TX1_QUEUE	6
++#define HSS1_PKT_TX2_QUEUE	7
++#define HSS1_PKT_TX3_QUEUE	8
++#define HSS1_PKT_RXFREE0_QUEUE	1
++#define HSS1_PKT_RXFREE1_QUEUE	2
++#define HSS1_PKT_RXFREE2_QUEUE	3
++#define HSS1_PKT_RXFREE3_QUEUE	4
++#define HSS1_PKT_TXDONE_QUEUE	9
++
++#define NPE_PKT_MODE_HDLC		0
++#define NPE_PKT_MODE_RAW		1
++#define NPE_PKT_MODE_56KMODE		2
++#define NPE_PKT_MODE_56KENDIAN_MSB	4
++
++/* PKT_PIPE_HDLC_CFG_WRITE flags */
++#define PKT_HDLC_IDLE_ONES		0x1 /* default = flags */
++#define PKT_HDLC_CRC_32			0x2 /* default = CRC-16 */
++#define PKT_HDLC_MSB_ENDIAN		0x4 /* default = LE */
++
++
++/* hss_config, PCRs */
++/* Frame sync sampling, default = active low */
++#define PCR_FRM_SYNC_ACTIVE_HIGH	0x40000000
++#define PCR_FRM_SYNC_FALLINGEDGE	0x80000000
++#define PCR_FRM_SYNC_RISINGEDGE		0xC0000000
++
++/* Frame sync pin: input (default) or output generated off a given clk edge */
++#define PCR_FRM_SYNC_OUTPUT_FALLING	0x20000000
++#define PCR_FRM_SYNC_OUTPUT_RISING	0x30000000
++
++/* Frame and data clock sampling on edge, default = falling */
++#define PCR_FCLK_EDGE_RISING		0x08000000
++#define PCR_DCLK_EDGE_RISING		0x04000000
++
++/* Clock direction, default = input */
++#define PCR_SYNC_CLK_DIR_OUTPUT		0x02000000
++
++/* Generate/Receive frame pulses, default = enabled */
++#define PCR_FRM_PULSE_DISABLED		0x01000000
++
++ /* Data rate is full (default) or half the configured clk speed */
++#define PCR_HALF_CLK_RATE		0x00200000
++
++/* Invert data between NPE and HSS FIFOs? (default = no) */
++#define PCR_DATA_POLARITY_INVERT	0x00100000
++
++/* TX/RX endianness, default = LSB */
++#define PCR_MSB_ENDIAN			0x00080000
++
++/* Normal (default) / open drain mode (TX only) */
++#define PCR_TX_PINS_OPEN_DRAIN		0x00040000
++
++/* No framing bit transmitted and expected on RX? (default = framing bit) */
++#define PCR_SOF_NO_FBIT			0x00020000
++
++/* Drive data pins? */
++#define PCR_TX_DATA_ENABLE		0x00010000
++
++/* Voice 56k type: drive the data pins low (default), high, high Z */
++#define PCR_TX_V56K_HIGH		0x00002000
++#define PCR_TX_V56K_HIGH_IMP		0x00004000
++
++/* Unassigned type: drive the data pins low (default), high, high Z */
++#define PCR_TX_UNASS_HIGH		0x00000800
++#define PCR_TX_UNASS_HIGH_IMP		0x00001000
++
++/* T1 @ 1.544MHz only: Fbit dictated in FIFO (default) or high Z */
++#define PCR_TX_FB_HIGH_IMP		0x00000400
++
++/* 56k data endiannes - which bit unused: high (default) or low */
++#define PCR_TX_56KE_BIT_0_UNUSED	0x00000200
++
++/* 56k data transmission type: 32/8 bit data (default) or 56K data */
++#define PCR_TX_56KS_56K_DATA		0x00000100
++
++/* hss_config, cCR */
++/* Number of packetized clients, default = 1 */
++#define CCR_NPE_HFIFO_2_HDLC		0x04000000
++#define CCR_NPE_HFIFO_3_OR_4HDLC	0x08000000
++
++/* default = no loopback */
++#define CCR_LOOPBACK			0x02000000
++
++/* HSS number, default = 0 (first) */
++#define CCR_SECOND_HSS			0x01000000
++
++
++/* hss_config, clkCR: main:10, num:10, denom:12 */
++#define CLK42X_SPEED_EXP	((0x3FF << 22) | (  2 << 12) |   15) /*65 KHz*/
++
++#define CLK42X_SPEED_512KHZ	((  130 << 22) | (  2 << 12) |   15)
++#define CLK42X_SPEED_1536KHZ	((   43 << 22) | ( 18 << 12) |   47)
++#define CLK42X_SPEED_1544KHZ	((   43 << 22) | ( 33 << 12) |  192)
++#define CLK42X_SPEED_2048KHZ	((   32 << 22) | ( 34 << 12) |   63)
++#define CLK42X_SPEED_4096KHZ	((   16 << 22) | ( 34 << 12) |  127)
++#define CLK42X_SPEED_8192KHZ	((    8 << 22) | ( 34 << 12) |  255)
++
++#define CLK46X_SPEED_512KHZ	((  130 << 22) | ( 24 << 12) |  127)
++#define CLK46X_SPEED_1536KHZ	((   43 << 22) | (152 << 12) |  383)
++#define CLK46X_SPEED_1544KHZ	((   43 << 22) | ( 66 << 12) |  385)
++#define CLK46X_SPEED_2048KHZ	((   32 << 22) | (280 << 12) |  511)
++#define CLK46X_SPEED_4096KHZ	((   16 << 22) | (280 << 12) | 1023)
++#define CLK46X_SPEED_8192KHZ	((    8 << 22) | (280 << 12) | 2047)
++
++
++/* hss_config, LUT entries */
++#define TDMMAP_UNASSIGNED	0
++#define TDMMAP_HDLC		1	/* HDLC - packetized */
++#define TDMMAP_VOICE56K		2	/* Voice56K - 7-bit channelized */
++#define TDMMAP_VOICE64K		3	/* Voice64K - 8-bit channelized */
++
++/* offsets into HSS config */
++#define HSS_CONFIG_TX_PCR	0x00 /* port configuration registers */
++#define HSS_CONFIG_RX_PCR	0x04
++#define HSS_CONFIG_CORE_CR	0x08 /* loopback control, HSS# */
++#define HSS_CONFIG_CLOCK_CR	0x0C /* clock generator control */
++#define HSS_CONFIG_TX_FCR	0x10 /* frame configuration registers */
++#define HSS_CONFIG_RX_FCR	0x14
++#define HSS_CONFIG_TX_LUT	0x18 /* channel look-up tables */
++#define HSS_CONFIG_RX_LUT	0x38
++
++
++/* NPE command codes */
++/* writes the ConfigWord value to the location specified by offset */
++#define PORT_CONFIG_WRITE		0x40
++
++/* triggers the NPE to load the contents of the configuration table */
++#define PORT_CONFIG_LOAD		0x41
++
++/* triggers the NPE to return an HssErrorReadResponse message */
++#define PORT_ERROR_READ			0x42
++
++/* reset NPE internal status and enable the HssChannelized operation */
++#define CHAN_FLOW_ENABLE		0x43
++#define CHAN_FLOW_DISABLE		0x44
++#define CHAN_IDLE_PATTERN_WRITE		0x45
++#define CHAN_NUM_CHANS_WRITE		0x46
++#define CHAN_RX_BUF_ADDR_WRITE		0x47
++#define CHAN_RX_BUF_CFG_WRITE		0x48
++#define CHAN_TX_BLK_CFG_WRITE		0x49
++#define CHAN_TX_BUF_ADDR_WRITE		0x4A
++#define CHAN_TX_BUF_SIZE_WRITE		0x4B
++#define CHAN_TSLOTSWITCH_ENABLE		0x4C
++#define CHAN_TSLOTSWITCH_DISABLE	0x4D
++
++/* downloads the gainWord value for a timeslot switching channel associated
++   with bypassNum */
++#define CHAN_TSLOTSWITCH_GCT_DOWNLOAD	0x4E
++
++/* triggers the NPE to reset internal status and enable the HssPacketized
++   operation for the flow specified by pPipe */
++#define PKT_PIPE_FLOW_ENABLE		0x50
++#define PKT_PIPE_FLOW_DISABLE		0x51
++#define PKT_NUM_PIPES_WRITE		0x52
++#define PKT_PIPE_FIFO_SIZEW_WRITE	0x53
++#define PKT_PIPE_HDLC_CFG_WRITE		0x54
++#define PKT_PIPE_IDLE_PATTERN_WRITE	0x55
++#define PKT_PIPE_RX_SIZE_WRITE		0x56
++#define PKT_PIPE_MODE_WRITE		0x57
++
++/* HDLC packet status values - desc->status */
++#define ERR_SHUTDOWN		1 /* stop or shutdown occurrance */
++#define ERR_HDLC_ALIGN		2 /* HDLC alignment error */
++#define ERR_HDLC_FCS		3 /* HDLC Frame Check Sum error */
++#define ERR_RXFREE_Q_EMPTY	4 /* RX-free queue became empty while receiving
++				     this packet (if buf_len < pkt_len) */
++#define ERR_HDLC_TOO_LONG	5 /* HDLC frame size too long */
++#define ERR_HDLC_ABORT		6 /* abort sequence received */
++#define ERR_DISCONNECTING	7 /* disconnect is in progress */
++
++#define CLOCK_EXT 0
++#define CLOCK_INT 1
++
++enum mode {MODE_HDLC = 0, MODE_RAW, MODE_G704};
++enum rx_tx_bit {
++	TX_BIT = 0,
++	RX_BIT = 1
++};
++enum chan_bit {
++	CHAN_0 = (1 << 0),
++	CHAN_1 = (1 << 1),
++	CHAN_2 = (1 << 2),
++	CHAN_3 = (1 << 3),
++	CHAN_4 = (1 << 4),
++	CHAN_5 = (1 << 5),
++	CHAN_6 = (1 << 6),
++	CHAN_7 = (1 << 7),
++	CHAN_8 = (1 << 8),
++	CHAN_9 = (1 << 9),
++	CHAN_10 = (1 << 10),
++	CHAN_11 = (1 << 11),
++	CHAN_12 = (1 << 12),
++	CHAN_13 = (1 << 13),
++	CHAN_14 = (1 << 14),
++	CHAN_15 = (1 << 15)
++};
++
++enum alignment { NOT_ALIGNED = 0, EVEN_FIRST, ODD_FIRST };
++
++#ifdef __ARMEB__
++typedef struct sk_buff buffer_t;
++#define free_buffer dev_kfree_skb
++#define free_buffer_irq dev_kfree_skb_irq
++#else
++typedef void buffer_t;
++#define free_buffer kfree
++#define free_buffer_irq kfree
++#endif
++
++struct hss_device {
++	struct port *port;
++	unsigned int open_count, excl_open;
++	unsigned long tx_loc, rx_loc; /* bytes */
++	unsigned long tx_frame, rx_frame; /* Frames */
++	u8 id, chan_count;
++	u8 log_channels[MAX_CHANNELS];
++
++  u8 *rx_buf;
++  u8 *tx_buf;
++
++	size_t rx_buffer_size;
++	size_t rx_period_size;
++	size_t tx_buffer_size;
++	size_t tx_period_size;
++
++  void (*rx_callback)(void *data);
++  void *rx_data;
++  void (*tx_callback)(void *data);
++  void *tx_data;
++  void *private_data;
++};
++
++extern struct hss_device *hss_handle[32];
++extern struct port *hss_port[2];
++
++struct port {
++	unsigned char init;
++
++	struct device *dev;
++
++	struct tasklet_struct task;
++	unsigned int id;
++	unsigned long chan_rx_bitmap;
++	unsigned long chan_tx_bitmap;
++	unsigned char chan_open;
++
++	/* the following fields must be protected by npe_lock */
++	enum mode mode;
++	unsigned int clock_type, clock_rate, loopback;
++	unsigned int frame_size, frame_sync_offset;
++	unsigned int next_rx_frame;
++
++	struct hss_device *chan_devices[MAX_CHAN_DEVICES];
++	u32 chan_tx_buf_phys, chan_rx_buf_phys;
++	u32	chan_tx_pointers_phys;
++	u32 *chan_tx_pointers;
++	u8 *chan_rx_buf;
++	u8 *chan_tx_buf;
++	u8 *tx_lists[CHAN_TX_LISTS][8];
++	u8 *rx_frames[8][CHAN_TX_LISTS];
++	unsigned int chan_open_count, hdlc_open;
++	unsigned int chan_started, initialized, just_set_offset;
++	unsigned int chan_last_rx, chan_last_tx;
++
++	/* assigned channels, may be invalid with given frame length or mode */
++	u8 channels[MAX_CHANNELS];
++	int msg_count;
++};
++
++/* NPE message structure */
++struct msg {
++#ifdef __ARMEB__
++	u8 cmd, unused, hss_port, index;
++	union {
++		struct { u8 data8a, data8b, data8c, data8d; };
++		struct { u16 data16a, data16b; };
++		struct { u32 data32; };
++	};
++#else
++	u8 index, hss_port, unused, cmd;
++	union {
++		struct { u8 data8d, data8c, data8b, data8a; };
++		struct { u16 data16b, data16a; };
++		struct { u32 data32; };
++	};
++#endif
++};
++
++#define rx_desc_phys(port, n)	((port)->desc_tab_phys +		\
++				 (n) * sizeof(struct desc))
++#define rx_desc_ptr(port, n)	(&(port)->desc_tab[n])
++
++#define tx_desc_phys(port, n)	((port)->desc_tab_phys +		\
++				 ((n) + RX_DESCS) * sizeof(struct desc))
++#define tx_desc_ptr(port, n)	(&(port)->desc_tab[(n) + RX_DESCS])
++
++int hss_prepare_chan(struct port *port);
++void hss_chan_stop(struct port *port);
++
++struct hss_device *hss_init(int id, int channel);
++int hss_chan_open(struct hss_device *hdev);
++int hss_chan_close(struct hss_device *hdev);
++
++int hss_set_tx_callback(struct hss_device *hdev, void (*tx_callback)(void *), void *tx_data);
++int hss_set_rx_callback(struct hss_device *hdev, void (*rx_callback)(void *), void *rx_data);
++int hss_tx_start(struct hss_device *hdev);
++int hss_tx_stop(struct hss_device *hdev);
++int hss_rx_start(struct hss_device *hdev);
++int hss_rx_stop(struct hss_device *hdev);
++
++int hss_config_rx_dma(struct hss_device *hdev, void *buf, size_t buffer_size, size_t period_size);
++int hss_config_tx_dma(struct hss_device *hdev, void *buf, size_t buffer_size, size_t period_size);
++unsigned long hss_curr_offset_rx(struct hss_device *hdev);
++unsigned long hss_curr_offset_tx(struct hss_device *hdev);
++
+--- a/arch/arm/mach-ixp4xx/avila-setup.c
++++ b/arch/arm/mach-ixp4xx/avila-setup.c
+@@ -333,6 +333,54 @@ static struct platform_device avila_gpio
+ 	.id     = -1,
+ };
+ 
++/*
++ * Audio Devices
++ */
++
++static struct platform_device avila_hss_device[] = {
++	{
++		.name = "gw_avila_hss",
++		.id = 0,
++	},{
++		.name = "gw_avila_hss",
++		.id = 1,
++	},{
++		.name = "gw_avila_hss",
++		.id = 2,
++	},{
++		.name = "gw_avila_hss",
++		.id = 3,
++	},
++};
++
++static struct platform_device avila_pcm_device[] = {
++	{
++		.name = "gw_avila-audio",
++		.id = 0,
++	},{
++		.name = "gw_avila-audio",
++		.id = 1,
++	},{
++		.name = "gw_avila-audio",
++		.id = 2,
++	},{
++		.name = "gw_avila-audio",
++		.id = 3,
++	}
++};
++
++static void setup_audio_devices(void) {
++	platform_device_register(&avila_hss_device[0]);
++	platform_device_register(&avila_hss_device[1]);
++	platform_device_register(&avila_hss_device[2]);
++	platform_device_register(&avila_hss_device[3]);
++
++	platform_device_register(&avila_pcm_device[0]);
++	platform_device_register(&avila_pcm_device[1]);
++	platform_device_register(&avila_pcm_device[2]);
++	platform_device_register(&avila_pcm_device[3]);
++}
++
+ static void __init avila_gw23xx_setup(void)
+ {
+ 	platform_device_register(&avila_npeb_device);
+@@ -509,6 +557,8 @@ static void __init avila_gw2365_setup(vo
+ 	avila_gpio_leds[0].gpio = 109;
+ 	avila_gpio_leds_data.num_leds = 5;
+ 	platform_device_register(&avila_gpio_leds_device);
++
++	setup_audio_devices();
+ }
+ 
+ static void __init avila_gw2369_setup(void)
+@@ -518,6 +568,8 @@ static void __init avila_gw2369_setup(vo
+ 
+ 	avila_npec_data.phy = 2;
+ 	platform_device_register(&avila_npec_device);
++
++	setup_audio_devices();
+ }
+ 
+ static void __init avila_gw2370_setup(void)
+@@ -655,6 +707,18 @@ static struct i2c_board_info __initdata
+ 		I2C_BOARD_INFO("24c08", 0x51),
+ 		.platform_data	= &avila_eeprom_info
+ 	},
++	{
++		I2C_BOARD_INFO("tlv320aic33", 0x1b),
++	},
++	{
++		I2C_BOARD_INFO("tlv320aic33", 0x1a),
++	},
++	{
++		I2C_BOARD_INFO("tlv320aic33", 0x19),
++	},
++	{
++		I2C_BOARD_INFO("tlv320aic33", 0x18),
++	},
+ };
+ 
+ static void __init avila_init(void)
+--- a/sound/soc/codecs/tlv320aic3x.c
++++ b/sound/soc/codecs/tlv320aic3x.c
+@@ -989,6 +989,22 @@ static int aic3x_set_dai_sysclk(struct s
+ 	return 0;
+ }
+ 
++static int aic3x_set_tdm_slot(struct snd_soc_dai *codec_dai,
++	unsigned int tx_mask, unsigned int rx_mask,
++	int slots, int width)
++{
++	struct snd_soc_codec *codec = codec_dai->codec;
++	u8 iface_creg;
++
++	iface_creg = snd_soc_read(codec, AIC3X_ASD_INTF_CTRLC);
++
++	iface_creg = slots * width;
++
++	snd_soc_write(codec, AIC3X_ASD_INTF_CTRLC, iface_creg);
++
++	return 0;
++}
++
+ static int aic3x_set_dai_fmt(struct snd_soc_dai *codec_dai,
+ 			     unsigned int fmt)
+ {
+@@ -1000,6 +1016,9 @@ static int aic3x_set_dai_fmt(struct snd_
+ 	iface_areg = snd_soc_read(codec, AIC3X_ASD_INTF_CTRLA) & 0x3f;
+ 	iface_breg = snd_soc_read(codec, AIC3X_ASD_INTF_CTRLB) & 0x3f;
+ 
++	iface_areg |= 0x30;
++	iface_breg |= 0x8;
++
+ 	/* set master/slave audio interface */
+ 	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+ 	case SND_SOC_DAIFMT_CBM_CFM:
+@@ -1231,6 +1250,7 @@ static struct snd_soc_dai_ops aic3x_dai_
+ 	.digital_mute	= aic3x_mute,
+ 	.set_sysclk	= aic3x_set_dai_sysclk,
+ 	.set_fmt	= aic3x_set_dai_fmt,
++	.set_tdm_slot	= aic3x_set_tdm_slot,
+ };
+ 
+ static struct snd_soc_dai_driver aic3x_dai = {
Index: trunk/target/linux/ixp4xx/patches-2.6.38/504-gw2369_support.patch
===================================================================
--- trunk/target/linux/ixp4xx/patches-2.6.38/504-gw2369_support.patch	(revision 0)
+++ trunk/target/linux/ixp4xx/patches-2.6.38/504-gw2369_support.patch	(revision 0)
@@ -0,0 +1,381 @@
+--- a/arch/arm/mach-ixp4xx/avila-setup.c
++++ b/arch/arm/mach-ixp4xx/avila-setup.c
+@@ -23,6 +23,7 @@
+ #include <linux/i2c.h>
+ #include <linux/i2c/at24.h>
+ #include <linux/leds.h>
++#include <linux/i2c/pca953x.h>
+ #include <linux/i2c-gpio.h>
+ #include <asm/types.h>
+ #include <asm/setup.h>
+@@ -32,6 +33,7 @@
+ #include <asm/irq.h>
+ #include <asm/mach/arch.h>
+ #include <asm/mach/flash.h>
++#include <linux/irq.h>
+ 
+ #define AVILA_SDA_PIN	7
+ #define AVILA_SCL_PIN	6
+@@ -126,58 +128,52 @@ static struct platform_device avila_uart
+ };
+ 
+ static struct resource avila_optional_uart_resources[] = {
+-  {
+-    .start  = 0x54000000,
+-    .end  = 0x54000fff,
+-    .flags  = IORESOURCE_MEM
+-  },
+-  {
+-    .start  = 0x55000000,
+-    .end  = 0x55000fff,
+-    .flags  = IORESOURCE_MEM
+-  },
+-  {
+-    .start  = 0x56000000,
+-    .end  = 0x56000fff,
+-    .flags  = IORESOURCE_MEM
+-  },
+-  {
+-    .start  = 0x57000000,
+-    .end  = 0x57000fff,
+-    .flags  = IORESOURCE_MEM
+-  }
++	{
++		.start  = 0x54000000,
++		.end  = 0x54000fff,
++		.flags  = IORESOURCE_MEM
++	},{
++		.start  = 0x55000000,
++		.end  = 0x55000fff,
++		.flags  = IORESOURCE_MEM
++	},{
++		.start  = 0x56000000,
++		.end  = 0x56000fff,
++		.flags  = IORESOURCE_MEM
++	},{
++		.start  = 0x57000000,
++		.end  = 0x57000fff,
++		.flags  = IORESOURCE_MEM
++	}
+ };
+ 
+ static struct plat_serial8250_port avila_optional_uart_data[] = {
+-  {
+-    .flags    = UPF_BOOT_AUTOCONF,
+-    .iotype   = UPIO_MEM,
+-    .regshift = 0,
+-    .uartclk  = 18432000,
+-    .rw_delay = 2,
+-  },
+-  {
+-    .flags    = UPF_BOOT_AUTOCONF,
+-    .iotype   = UPIO_MEM,
+-    .regshift = 0,
+-    .uartclk  = 18432000,
+-    .rw_delay = 2,
+-  },
+-  {
+-    .flags    = UPF_BOOT_AUTOCONF,
+-    .iotype   = UPIO_MEM,
+-    .regshift = 0,
+-    .uartclk  = 18432000,
+-    .rw_delay = 2,
+-  },
+-  {
+-    .flags    = UPF_BOOT_AUTOCONF,
+-    .iotype   = UPIO_MEM,
+-    .regshift = 0,
+-    .uartclk  = 18432000,
+-    .rw_delay = 2,
+-  },
+-  { },
++	{
++		.flags    = UPF_BOOT_AUTOCONF,
++		.iotype   = UPIO_MEM,
++		.regshift = 0,
++		.uartclk  = 18432000,
++		.rw_delay = 2,
++	},{
++		.flags    = UPF_BOOT_AUTOCONF,
++		.iotype   = UPIO_MEM,
++		.regshift = 0,
++		.uartclk  = 18432000,
++		.rw_delay = 2,
++	},{
++		.flags    = UPF_BOOT_AUTOCONF,
++		.iotype   = UPIO_MEM,
++		.regshift = 0,
++		.uartclk  = 18432000,
++		.rw_delay = 2,
++	},{
++		.flags    = UPF_BOOT_AUTOCONF,
++		.iotype   = UPIO_MEM,
++		.regshift = 0,
++		.uartclk  = 18432000,
++		.rw_delay = 2,
++	},
++	{ }
+ };
+ 
+ static struct platform_device avila_optional_uart = {
+@@ -191,11 +187,9 @@ static struct platform_device avila_opti
+ static struct resource avila_pata_resources[] = {
+ 	{
+ 		.flags	= IORESOURCE_MEM
+-	},
+-	{
++	},{
+ 		.flags	= IORESOURCE_MEM,
+-	},
+-	{
++	},{
+ 		.name	= "intrq",
+ 		.start	= IRQ_IXP4XX_GPIO12,
+ 		.end	= IRQ_IXP4XX_GPIO12,
+@@ -246,7 +240,28 @@ static struct gpio_led avila_gpio_leds[]
+ 		.name		= "user",  /* green led */
+ 		.gpio		= AVILA_GW23XX_LED_USER_GPIO,
+ 		.active_low	= 1,
+-	}
++	},
++	{
++		.name		= "radio1",  /* green led */
++		.gpio		= 104,
++		.active_low	= 1,
++	},
++	{
++		.name		= "radio2",  /* green led */
++		.gpio		= 105,
++		.active_low	= 1,
++	},
++	{
++		.name		= "radio3",  /* green led */
++		.gpio		= 106,
++		.active_low	= 1,
++	},
++	{
++		.name		= "radio4",  /* green led */
++		.gpio		= 107,
++		.active_low	= 1,
++	},
++
+ };
+ 
+ static struct gpio_led_platform_data avila_gpio_leds_data = {
+@@ -332,6 +347,17 @@ static void __init avila_gw2342_setup(vo
+ 	platform_device_register(&avila_npec_device);
+ 
+ 	platform_device_register(&avila_gpio_leds_device);
++
++	avila_pata_resources[0].start = IXP4XX_EXP_BUS_BASE(1);
++	avila_pata_resources[0].end = IXP4XX_EXP_BUS_END(1);
++
++	avila_pata_resources[1].start = IXP4XX_EXP_BUS_BASE(2);
++	avila_pata_resources[1].end = IXP4XX_EXP_BUS_END(2);
++
++	avila_pata_data.cs0_cfg = IXP4XX_EXP_CS1;
++	avila_pata_data.cs1_cfg = IXP4XX_EXP_CS2;
++
++	platform_device_register(&avila_pata);
+ }
+ 
+ static void __init avila_gw2345_setup(void)
+@@ -344,6 +370,17 @@ static void __init avila_gw2345_setup(vo
+ 	platform_device_register(&avila_npec_device);
+ 
+ 	platform_device_register(&avila_gpio_leds_device);
++
++	avila_pata_resources[0].start = IXP4XX_EXP_BUS_BASE(1);
++	avila_pata_resources[0].end = IXP4XX_EXP_BUS_END(1);
++
++	avila_pata_resources[1].start = IXP4XX_EXP_BUS_BASE(2);
++	avila_pata_resources[1].end = IXP4XX_EXP_BUS_END(2);
++
++	avila_pata_data.cs0_cfg = IXP4XX_EXP_CS1;
++	avila_pata_data.cs1_cfg = IXP4XX_EXP_CS2;
++
++	platform_device_register(&avila_pata);
+ }
+ 
+ static void __init avila_gw2347_setup(void)
+@@ -360,6 +397,17 @@ static void __init avila_gw2348_setup(vo
+ 	platform_device_register(&avila_npec_device);
+ 
+ 	platform_device_register(&avila_gpio_leds_device);
++
++	avila_pata_resources[0].start = IXP4XX_EXP_BUS_BASE(1);
++	avila_pata_resources[0].end = IXP4XX_EXP_BUS_END(1);
++
++	avila_pata_resources[1].start = IXP4XX_EXP_BUS_BASE(2);
++	avila_pata_resources[1].end = IXP4XX_EXP_BUS_END(2);
++
++	avila_pata_data.cs0_cfg = IXP4XX_EXP_CS1;
++	avila_pata_data.cs1_cfg = IXP4XX_EXP_CS2;
++
++	platform_device_register(&avila_pata);
+ }
+ 
+ static void __init avila_gw2353_setup(void)
+@@ -389,6 +437,17 @@ static void __init avila_gw2355_setup(vo
+ 	avila_latch_leds_data.num_leds = 5;
+ 	avila_latch_leds_data.mem = 0x54000000;
+ 	platform_device_register(&avila_latch_leds_device);
++
++	avila_pata_resources[0].start = IXP4XX_EXP_BUS_BASE(1);
++	avila_pata_resources[0].end = IXP4XX_EXP_BUS_END(1);
++
++	avila_pata_resources[1].start = IXP4XX_EXP_BUS_BASE(2);
++	avila_pata_resources[1].end = IXP4XX_EXP_BUS_END(2);
++
++	avila_pata_data.cs0_cfg = IXP4XX_EXP_CS1;
++	avila_pata_data.cs1_cfg = IXP4XX_EXP_CS2;
++
++	platform_device_register(&avila_pata);
+ }
+ 
+ static void __init avila_gw2357_setup(void)
+@@ -405,40 +464,62 @@ static void __init avila_gw2357_setup(vo
+ static void __init avila_gw2365_setup(void)
+ {
+ 	*IXP4XX_EXP_CS4 = 0xBFFF3C43;
+-  set_irq_type(IRQ_IXP4XX_GPIO0, IRQ_TYPE_EDGE_RISING);
+-  avila_optional_uart_data[0].mapbase = 0x54000000;
+-  avila_optional_uart_data[0].membase = (void __iomem *)ioremap(0x54000000, 0x0fff);
+-  avila_optional_uart_data[0].irq   = IRQ_IXP4XX_GPIO0;
+-
+-  *IXP4XX_EXP_CS5 = 0xBFFF3C43;
+-  set_irq_type(IRQ_IXP4XX_GPIO1, IRQ_TYPE_EDGE_RISING);
+-  avila_optional_uart_data[1].mapbase = 0x55000000;
+-  avila_optional_uart_data[1].membase = (void __iomem *)ioremap(0x55000000, 0x0fff);
+-  avila_optional_uart_data[1].irq   = IRQ_IXP4XX_GPIO1;
+-
+-  *IXP4XX_EXP_CS6 = 0xBFFF3C43;
+-  set_irq_type(IRQ_IXP4XX_GPIO2, IRQ_TYPE_EDGE_RISING);
+-  avila_optional_uart_data[2].mapbase = 0x56000000;
+-  avila_optional_uart_data[2].membase = (void __iomem *)ioremap(0x56000000, 0x0fff);
+-  avila_optional_uart_data[2].irq   = IRQ_IXP4XX_GPIO2;
+-
+-  *IXP4XX_EXP_CS7 = 0xBFFF3C43;
+-  set_irq_type(IRQ_IXP4XX_GPIO3, IRQ_TYPE_EDGE_RISING);
+-  avila_optional_uart_data[3].mapbase = 0x57000000;
+-  avila_optional_uart_data[3].membase = (void __iomem *)ioremap(0x57000000, 0x0fff);
+-  avila_optional_uart_data[3].irq   = IRQ_IXP4XX_GPIO3;
++	set_irq_type(IRQ_IXP4XX_GPIO0, IRQ_TYPE_EDGE_RISING);
++	avila_optional_uart_data[0].mapbase = 0x54000000;
++	avila_optional_uart_data[0].membase = (void __iomem *)ioremap(0x54000000, 0x0fff);
++	avila_optional_uart_data[0].irq   = IRQ_IXP4XX_GPIO0;
++
++	*IXP4XX_EXP_CS5 = 0xBFFF3C43;
++	set_irq_type(IRQ_IXP4XX_GPIO1, IRQ_TYPE_EDGE_RISING);
++	avila_optional_uart_data[1].mapbase = 0x55000000;
++	avila_optional_uart_data[1].membase = (void __iomem *)ioremap(0x55000000, 0x0fff);
++	avila_optional_uart_data[1].irq   = IRQ_IXP4XX_GPIO1;
++
++	*IXP4XX_EXP_CS6 = 0xBFFF3C43;
++	set_irq_type(IRQ_IXP4XX_GPIO2, IRQ_TYPE_EDGE_RISING);
++	avila_optional_uart_data[2].mapbase = 0x56000000;
++	avila_optional_uart_data[2].membase = (void __iomem *)ioremap(0x56000000, 0x0fff);
++	avila_optional_uart_data[2].irq   = IRQ_IXP4XX_GPIO2;
++
++	*IXP4XX_EXP_CS7 = 0xBFFF3C43;
++	set_irq_type(IRQ_IXP4XX_GPIO3, IRQ_TYPE_EDGE_RISING);
++	avila_optional_uart_data[3].mapbase = 0x57000000;
++	avila_optional_uart_data[3].membase = (void __iomem *)ioremap(0x57000000, 0x0fff);
++	avila_optional_uart_data[3].irq   = IRQ_IXP4XX_GPIO3;
+ 
+ 	platform_device_register(&avila_optional_uart);
+-	
++
+ 	avila_npeb_data.phy = 1;
+ 	platform_device_register(&avila_npeb_device);
+ 
+ 	avila_npec_data.phy = 2;
+ 	platform_device_register(&avila_npec_device);
+ 
++	avila_pata_resources[0].start = IXP4XX_EXP_BUS_BASE(1);
++	avila_pata_resources[0].end = IXP4XX_EXP_BUS_END(1);
++
++	avila_pata_resources[1].start = IXP4XX_EXP_BUS_BASE(2);
++	avila_pata_resources[1].end = IXP4XX_EXP_BUS_END(2);
++
++	avila_pata_data.cs0_cfg = IXP4XX_EXP_CS1;
++	avila_pata_data.cs1_cfg = IXP4XX_EXP_CS2;
++
++	platform_device_register(&avila_pata);
++
++	avila_gpio_leds[0].gpio = 109;
++	avila_gpio_leds_data.num_leds = 5;
+ 	platform_device_register(&avila_gpio_leds_device);
+ }
+ 
++static void __init avila_gw2369_setup(void)
++{
++	avila_npeb_data.phy = 1;
++	platform_device_register(&avila_npeb_device);
++
++	avila_npec_data.phy = 2;
++	platform_device_register(&avila_npec_device);
++}
++
+ static struct avila_board_info avila_boards[] __initdata = {
+ 	{
+ 		.model		= "GW2342",
+@@ -464,6 +545,9 @@ static struct avila_board_info avila_boa
+ 	}, {
+ 		.model		= "GW2365",
+ 		.setup		= avila_gw2365_setup,
++	}, {
++		.model		= "GW2369",
++		.setup		= avila_gw2369_setup,
+ 	}
+ };
+ 
+@@ -512,11 +596,22 @@ static struct at24_platform_data avila_e
+ 	.setup		= at24_setup,
+ };
+ 
++static struct pca953x_platform_data avila_pca_data = {
++	.gpio_base  = 100,
++};
++
+ static struct i2c_board_info __initdata avila_i2c_board_info[] = {
+ 	{
+ 		I2C_BOARD_INFO("ds1672", 0x68),
+ 	},
+ 	{
++		I2C_BOARD_INFO("gsp", 0x29),
++	},
++	{
++		I2C_BOARD_INFO("pca9555", 0x23),
++		.platform_data = &avila_pca_data,
++	},
++	{
+ 		I2C_BOARD_INFO("ad7418", 0x28),
+ 	},
+ 	{
+@@ -539,17 +634,6 @@ static void __init avila_init(void)
+ 
+ 	platform_add_devices(avila_devices, ARRAY_SIZE(avila_devices));
+ 
+-	avila_pata_resources[0].start = IXP4XX_EXP_BUS_BASE(1);
+-	avila_pata_resources[0].end = IXP4XX_EXP_BUS_END(1);
+-
+-	avila_pata_resources[1].start = IXP4XX_EXP_BUS_BASE(2);
+-	avila_pata_resources[1].end = IXP4XX_EXP_BUS_END(2);
+-
+-	avila_pata_data.cs0_cfg = IXP4XX_EXP_CS1;
+-	avila_pata_data.cs1_cfg = IXP4XX_EXP_CS2;
+-
+-	platform_device_register(&avila_pata);
+-
+ 	i2c_register_board_info(0, avila_i2c_board_info,
+ 			ARRAY_SIZE(avila_i2c_board_info));
+ 
+@@ -570,7 +654,6 @@ static int __init avila_model_setup(void
+ 						" -- defaults will be used\n");
+ 		avila_gw23xx_setup();
+ 	}
+-
+ 	return 0;
+ }
+ late_initcall(avila_model_setup);
Index: trunk/target/linux/ixp4xx/patches-2.6.38/502-gw2365-eth.patch
===================================================================
--- trunk/target/linux/ixp4xx/patches-2.6.38/502-gw2365-eth.patch	(revision 0)
+++ trunk/target/linux/ixp4xx/patches-2.6.38/502-gw2365-eth.patch	(revision 0)
@@ -0,0 +1,30 @@
+--- a/arch/arm/mach-ixp4xx/avila-setup.c
++++ b/arch/arm/mach-ixp4xx/avila-setup.c
+@@ -339,6 +339,17 @@ static void __init avila_gw2357_setup(vo
+ 	platform_device_register(&avila_latch_leds_device);
+ }
+ 
++static void __init avila_gw2365_setup(void)
++{
++	avila_npeb_data.phy = 1;
++	platform_device_register(&avila_npeb_device);
++
++	avila_npec_data.phy = 2;
++	platform_device_register(&avila_npec_device);
++
++	platform_device_register(&avila_gpio_leds_device);
++}
++
+ static struct avila_board_info avila_boards[] __initdata = {
+ 	{
+ 		.model		= "GW2342",
+@@ -361,6 +372,9 @@ static struct avila_board_info avila_boa
+ 	}, {
+ 		.model		= "GW2357",
+ 		.setup		= avila_gw2357_setup,
++	}, {
++		.model		= "GW2365",
++		.setup		= avila_gw2365_setup,
+ 	}
+ };
+ 
Index: trunk/target/linux/ixp4xx/config-default
===================================================================
--- trunk/target/linux/ixp4xx/config-default	(revision 27590)
+++ trunk/target/linux/ixp4xx/config-default	(working copy)
@@ -17,7 +17,7 @@
 CONFIG_ARM_L1_CACHE_SHIFT=5
 # CONFIG_ARM_THUMB is not set
 # CONFIG_ARPD is not set
-CONFIG_BKL=y
+# CONFIG_AUTO_IRQ_AFFINITY is not set
 CONFIG_BOUNCE=y
 CONFIG_CMDLINE="root=/dev/mtdblock2 rootfstype=squashfs,jffs2 noinitrd console=ttyS0,115200"
 CONFIG_CPU_32v5=y
@@ -33,6 +33,7 @@
 CONFIG_CPU_IXP46X=y
 CONFIG_CPU_PABRT_LEGACY=y
 CONFIG_CPU_TLB_V4WBI=y
+CONFIG_CPU_USE_DOMAINS=y
 CONFIG_CPU_XSCALE=y
 CONFIG_DEBUG_BUGVERBOSE=y
 # CONFIG_DEBUG_USER is not set
@@ -40,18 +41,19 @@
 CONFIG_DMABOUNCE=y
 CONFIG_DNOTIFY=y
 CONFIG_EEPROM_AT24=y
-# CONFIG_FPE_FASTFPE is not set
-# CONFIG_FPE_NWFPE is not set
 CONFIG_FRAME_POINTER=y
 CONFIG_GENERIC_ATOMIC64=y
 CONFIG_GENERIC_CLOCKEVENTS=y
 CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
 CONFIG_GENERIC_FIND_LAST_BIT=y
 CONFIG_GENERIC_GPIO=y
-CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+# CONFIG_GENERIC_HARDIRQS_NO_DEPRECATED is not set
+# CONFIG_GENERIC_PENDING_IRQ is not set
 CONFIG_GPIOLIB=y
 CONFIG_GPIO_DEVICE=y
 CONFIG_GPIO_GW_I2C_PLD=y
+CONFIG_GPIO_PCA953X=y
+# CONFIG_GPIO_PCA953X_IRQ is not set
 CONFIG_GPIO_SYSFS=y
 # CONFIG_HAMRADIO is not set
 CONFIG_HARDIRQS_SW_RESEND=y
@@ -60,11 +62,14 @@
 CONFIG_HAS_IOPORT=y
 CONFIG_HAVE_AOUT=y
 CONFIG_HAVE_ARCH_KGDB=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_HAVE_DMA_API_DEBUG=y
 CONFIG_HAVE_DYNAMIC_FTRACE=y
 CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
 CONFIG_HAVE_FUNCTION_TRACER=y
 CONFIG_HAVE_GENERIC_DMA_COHERENT=y
-# CONFIG_HAVE_GENERIC_HARDIRQS is not set
+CONFIG_HAVE_GENERIC_HARDIRQS=y
 CONFIG_HAVE_IDE=y
 CONFIG_HAVE_IRQ_WORK=y
 CONFIG_HAVE_KERNEL_GZIP=y
@@ -77,6 +82,8 @@
 CONFIG_HAVE_PERF_EVENTS=y
 CONFIG_HAVE_PROC_CPU=y
 CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_SCHED_CLOCK=y
+CONFIG_HAVE_SPARSE_IRQ=y
 CONFIG_HWMON=y
 # CONFIG_HWMON_DEBUG_CHIP is not set
 CONFIG_HWMON_VID=y
@@ -91,6 +98,7 @@
 CONFIG_INITRAMFS_SOURCE=""
 CONFIG_IP_PIMSM_V1=y
 CONFIG_IP_PIMSM_V2=y
+# CONFIG_IRQ_PER_CPU is not set
 # CONFIG_IWMMXT is not set
 CONFIG_IXP4XX_ETH=y
 # CONFIG_IXP4XX_INDIRECT_PCI is not set
@@ -129,6 +137,8 @@
 CONFIG_MACH_WG302V1=y
 CONFIG_MACH_WG302V2=y
 CONFIG_MACH_WRT300NV2=y
+# CONFIG_MFD_WL1273_CORE is not set
+CONFIG_MIGHT_HAVE_PCI=y
 CONFIG_MTD_CFI_ADV_OPTIONS=y
 # CONFIG_MTD_CFI_GEOMETRY is not set
 CONFIG_MTD_IXP4XX=y
@@ -137,7 +147,7 @@
 CONFIG_NEED_DMA_MAP_STATE=y
 CONFIG_NEED_PER_CPU_KM=y
 CONFIG_PAGEFLAGS_EXTENDED=y
-CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_PAGE_OFFSET=0x80000000
 CONFIG_PCI=y
 CONFIG_PERF_USE_VMALLOC=y
 CONFIG_PHYLIB=y
@@ -150,17 +160,22 @@
 CONFIG_RTC_DRV_X1205=y
 # CONFIG_SCSI_DMA is not set
 CONFIG_SENSORS_AD7418=y
+CONFIG_SENSORS_GSP=y
 CONFIG_SENSORS_MAX6650=y
 CONFIG_SENSORS_W83781D=y
-CONFIG_SERIAL_8250_NR_UARTS=4
-CONFIG_SERIAL_8250_RUNTIME_UARTS=4
+CONFIG_SERIAL_8250_NR_UARTS=20
+CONFIG_SERIAL_8250_PCI=y
+CONFIG_SERIAL_8250_RUNTIME_UARTS=20
 CONFIG_SPLIT_PTLOCK_CPUS=999999
 CONFIG_SYS_SUPPORTS_APM_EMULATION=y
 CONFIG_UID16=y
 CONFIG_USB_SUPPORT=y
 CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_VMSPLIT_2G=y
+# CONFIG_VMSPLIT_3G is not set
 CONFIG_VM_EVENT_COUNTERS=y
 CONFIG_WATCHDOG_NOWAYOUT=y
 CONFIG_XSCALE_PMU=y
+CONFIG_XZ_DEC=y
 CONFIG_ZBOOT_ROM_BSS=0x0
 CONFIG_ZBOOT_ROM_TEXT=0x0
Index: trunk/target/linux/ixp4xx/Makefile
===================================================================
--- trunk/target/linux/ixp4xx/Makefile	(revision 27590)
+++ trunk/target/linux/ixp4xx/Makefile	(working copy)
@@ -13,7 +13,7 @@
 MAINTAINER:=Imre Kaloz <kaloz@openwrt.org>
 SUBTARGETS=generic harddisk
 
-LINUX_VERSION:=2.6.37.6
+LINUX_VERSION:=2.6.38.8
 
 include $(INCLUDE_DIR)/target.mk
 
Index: trunk/target/linux/generic/patches-2.6.32/691-phy_rtl8366.patch
===================================================================
--- trunk/target/linux/generic/patches-2.6.32/691-phy_rtl8366.patch	(revision 27590)
+++ trunk/target/linux/generic/patches-2.6.32/691-phy_rtl8366.patch	(working copy)
@@ -1,6 +1,6 @@
 --- a/drivers/net/phy/Kconfig
 +++ b/drivers/net/phy/Kconfig
-@@ -141,4 +141,29 @@ config MDIO_GPIO
+@@ -143,4 +143,29 @@ config MDIO_GPIO
  	  To compile this driver as a module, choose M here: the module
  	  will be called mdio-gpio.
  
Index: trunk/target/linux/generic/patches-2.6.32/976-ssb_commit_settings_export.patch
===================================================================
--- trunk/target/linux/generic/patches-2.6.32/976-ssb_commit_settings_export.patch	(revision 27590)
+++ trunk/target/linux/generic/patches-2.6.32/976-ssb_commit_settings_export.patch	(working copy)
@@ -67,7 +67,7 @@
  	u32 base = 0;
 --- a/include/linux/ssb/ssb.h
 +++ b/include/linux/ssb/ssb.h
-@@ -675,6 +675,7 @@ extern int ssb_bus_may_powerdown(struct 
+@@ -675,6 +675,7 @@ extern int ssb_bus_may_powerdown(struct
   * Otherwise static always-on powercontrol will be used. */
  extern int ssb_bus_powerup(struct ssb_bus *bus, bool dynamic_pctl);
  
Index: trunk/target/linux/generic/patches-2.6.32/670-phy_ip175c.patch
===================================================================
--- trunk/target/linux/generic/patches-2.6.32/670-phy_ip175c.patch	(revision 27590)
+++ trunk/target/linux/generic/patches-2.6.32/670-phy_ip175c.patch	(working copy)
@@ -1,6 +1,6 @@
 --- a/drivers/net/phy/Kconfig
 +++ b/drivers/net/phy/Kconfig
-@@ -102,6 +102,10 @@ config ADM6996_PHY
+@@ -104,6 +104,10 @@ config ADM6996_PHY
  config MVSWITCH_PHY
  	tristate "Driver for Marvell 88E6060 switches"
  
Index: trunk/target/linux/generic/patches-2.6.32/066-block2mtd_probe.patch
===================================================================
--- trunk/target/linux/generic/patches-2.6.32/066-block2mtd_probe.patch	(revision 27590)
+++ trunk/target/linux/generic/patches-2.6.32/066-block2mtd_probe.patch	(working copy)
@@ -1,6 +1,6 @@
 --- a/drivers/mtd/devices/block2mtd.c
 +++ b/drivers/mtd/devices/block2mtd.c
-@@ -264,10 +264,12 @@ static int _open_bdev(struct block2mtd_d
+@@ -264,11 +264,13 @@ static int _open_bdev(struct block2mtd_d
  	bdev = open_bdev_exclusive(dev->devname, FMODE_READ|FMODE_WRITE, NULL);
  #ifndef MODULE
  	if (IS_ERR(bdev)) {
@@ -9,8 +9,9 @@
  		/* We might not have rootfs mounted at this point. Try
  		   to resolve the device name by other means. */
  
+-		dev_t devt = name_to_dev_t(dev->devname);
 +		wait_for_device_probe();
--		dev_t devt = name_to_dev_t(dev->devname);
 +		devt = name_to_dev_t(dev->devname);
  		if (devt) {
  			bdev = open_by_devnum(devt, FMODE_WRITE | FMODE_READ);
+ 		}
Index: trunk/target/linux/generic/patches-2.6.32/690-phy_rtl8306.patch
===================================================================
--- trunk/target/linux/generic/patches-2.6.32/690-phy_rtl8306.patch	(revision 27590)
+++ trunk/target/linux/generic/patches-2.6.32/690-phy_rtl8306.patch	(working copy)
@@ -1,6 +1,6 @@
 --- a/drivers/net/phy/Kconfig
 +++ b/drivers/net/phy/Kconfig
-@@ -110,6 +110,10 @@ config AR8216_PHY
+@@ -112,6 +112,10 @@ config AR8216_PHY
  	tristate "Driver for Atheros AR8216 switches"
  	select SWCONFIG
  
Index: trunk/target/linux/generic/patches-2.6.32/680-phy_ar8216.patch
===================================================================
--- trunk/target/linux/generic/patches-2.6.32/680-phy_ar8216.patch	(revision 27590)
+++ trunk/target/linux/generic/patches-2.6.32/680-phy_ar8216.patch	(working copy)
@@ -1,6 +1,6 @@
 --- a/drivers/net/phy/Kconfig
 +++ b/drivers/net/phy/Kconfig
-@@ -106,6 +106,10 @@ config IP17XX_PHY
+@@ -108,6 +108,10 @@ config IP17XX_PHY
  	tristate "Driver for IC+ IP17xx switches"
  	select SWCONFIG
  
Index: trunk/target/linux/generic/patches-2.6.32/660-phy_mvswitch.patch
===================================================================
--- trunk/target/linux/generic/patches-2.6.32/660-phy_mvswitch.patch	(revision 27590)
+++ trunk/target/linux/generic/patches-2.6.32/660-phy_mvswitch.patch	(working copy)
@@ -1,8 +1,8 @@
 --- a/drivers/net/phy/Kconfig
 +++ b/drivers/net/phy/Kconfig
-@@ -99,6 +99,9 @@ config ADM6996_PHY
- 	---help---
- 	  Currently supports the ADM6996F switch
+@@ -101,6 +101,9 @@ config ADM6996_PHY
+ 	  Currently supports the ADM6996FC and ADM6996M switches.
+ 	  Support for FC is very limited.
  
 +config MVSWITCH_PHY
 +	tristate "Driver for Marvell 88E6060 switches"
Index: trunk/target/linux/davinci/image/Makefile
===================================================================
--- trunk/target/linux/davinci/image/Makefile	(revision 0)
+++ trunk/target/linux/davinci/image/Makefile	(revision 0)
@@ -0,0 +1,35 @@
+# 
+# Copyright (C) 2008 OpenWrt.org
+#
+# This is free software, licensed under the GNU General Public License v2.
+# See /LICENSE for more information.
+#
+include $(TOPDIR)/rules.mk
+include $(INCLUDE_DIR)/image.mk
+
+define Image/Prepare
+	cp $(LINUX_DIR)/arch/arm/boot/uImage $(KDIR)/uImage
+endef
+
+define Image/BuildKernel
+	cp $(KDIR)/uImage $(BIN_DIR)/openwrt-$(BOARD)-uImage
+endef
+
+define Image/Build
+	$(call Image/Build/$(1),$(1))
+endef
+
+define Image/Build/jffs2-64k
+	dd if=$(KDIR)/root.$(1) of=$(BIN_DIR)/openwrt-$(BOARD)-$(1).img bs=65536 conv=sync
+endef
+
+define Image/Build/jffs2-128k
+	dd if=$(KDIR)/root.$(1) of=$(BIN_DIR)/openwrt-$(BOARD)-$(1).img bs=131072 conv=sync
+endef
+
+define Image/Build/squashfs
+	$(call prepare_generic_squashfs,$(KDIR)/root.squashfs)
+	dd if=$(KDIR)/root.$(1) of=$(BIN_DIR)/openwrt-$(BOARD)-$(1).img bs=131072 conv=sync
+endef
+
+$(eval $(call BuildImage))
Index: trunk/target/linux/davinci/config-2.6.32
===================================================================
--- trunk/target/linux/davinci/config-2.6.32	(revision 0)
+++ trunk/target/linux/davinci/config-2.6.32	(revision 0)
@@ -0,0 +1,272 @@
+CONFIG_AINTC=y
+CONFIG_ALIGNMENT_TRAP=y
+CONFIG_ARCH_DAVINCI=y
+# CONFIG_ARCH_DAVINCI_DA830 is not set
+# CONFIG_ARCH_DAVINCI_DA850 is not set
+# CONFIG_ARCH_DAVINCI_DM355 is not set
+# CONFIG_ARCH_DAVINCI_DM365 is not set
+CONFIG_ARCH_DAVINCI_DM644x=y
+# CONFIG_ARCH_DAVINCI_DM646x is not set
+CONFIG_ARCH_DAVINCI_DMx=y
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_ARM=y
+CONFIG_ARM_L1_CACHE_SHIFT=5
+CONFIG_ARM_THUMB=y
+# CONFIG_ARPD is not set
+CONFIG_BITREVERSE=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=1
+CONFIG_BLK_DEV_RAM_SIZE=32768
+CONFIG_BOUNCE=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_COMMON_CLKDEV=y
+CONFIG_COMPAT_BRK=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_CPU_32=y
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5TJ=y
+CONFIG_CPU_ARM926T=y
+# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+# CONFIG_CPU_ICACHE_DISABLE is not set
+CONFIG_CPU_PABRT_LEGACY=y
+CONFIG_CPU_TLB_V4WBI=y
+CONFIG_CRAMFS=y
+CONFIG_CRC_CCITT=m
+CONFIG_CRC_T10DIF=m
+# CONFIG_DAVINCI_AVNET_ENCODER is not set
+CONFIG_DAVINCI_ENC_MNGR=y
+CONFIG_DAVINCI_LOGICPD_ENCODER=y
+CONFIG_DAVINCI_MUX=y
+# CONFIG_DAVINCI_MUX_DEBUG is not set
+# CONFIG_DAVINCI_MUX_WARNINGS is not set
+CONFIG_DAVINCI_OSD=y
+# CONFIG_DAVINCI_RESET_CLOCKS is not set
+CONFIG_DAVINCI_VPBE_ENCODER=y
+CONFIG_DAVINCI_WATCHDOG=y
+# CONFIG_DEBUG_FS is not set
+# CONFIG_DEBUG_USER is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_DECOMPRESS_LZMA=y
+CONFIG_DEFAULT_AS=y
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_IOSCHED="anticipatory"
+CONFIG_DEFAULT_TCP_CONG="cubic"
+CONFIG_DEVKMEM=y
+# CONFIG_DM9000 is not set
+CONFIG_DNOTIFY=y
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_EEPROM_AT24=y
+CONFIG_ELF_CORE=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_ENC_MNGR_MAX_CHANNELS=1
+CONFIG_EXPORTFS=m
+CONFIG_EXT2_FS=y
+CONFIG_EXT3_FS=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+CONFIG_EXT3_FS_XATTR=y
+CONFIG_FAT_FS=y
+CONFIG_FB=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+CONFIG_FB_DAVINCI=y
+# CONFIG_FIRMWARE_EDID is not set
+CONFIG_FORCE_MAX_ZONEORDER=13
+CONFIG_FRAME_POINTER=y
+CONFIG_FS_MBCACHE=y
+# CONFIG_FW_LOADER is not set
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_GENERIC_FIND_LAST_BIT=y
+CONFIG_GENERIC_GPIO=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_GPIOLIB=y
+CONFIG_GPIO_DEVICE=y
+CONFIG_GPIO_PCA953X=y
+# CONFIG_HAMRADIO is not set
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_HAS_DMA=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAVE_AOUT=y
+CONFIG_HAVE_ARCH_KGDB=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_HAVE_IDE=y
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_HAVE_OPROFILE=y
+CONFIG_HWMON=y
+# CONFIG_HWMON_DEBUG_CHIP is not set
+CONFIG_HW_CONSOLE=y
+# CONFIG_HW_RANDOM is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_COMPAT=y
+CONFIG_I2C_DAVINCI=y
+# CONFIG_I2C_DESIGNWARE is not set
+CONFIG_I2C_HELPER_AUTO=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+CONFIG_INET_XFRM_MODE_BEET=y
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+CONFIG_INPUT=y
+# CONFIG_INPUT_MISC is not set
+CONFIG_IOSCHED_AS=y
+# CONFIG_IOSCHED_DEADLINE is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_BOOTP is not set
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_ISDN is not set
+CONFIG_JBD=y
+# CONFIG_LEDS is not set
+CONFIG_LEDS_GPIO=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+CONFIG_LOCKD=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_LSI_ET1011C_PHY=y
+CONFIG_LXT_PHY=y
+CONFIG_MACH_DAVINCI_EVM=y
+CONFIG_MACH_GW2361=y
+# CONFIG_MACH_SFFSDR is not set
+CONFIG_MEDIA_SUPPORT=y
+CONFIG_MEDIA_TUNER=y
+CONFIG_MEDIA_TUNER_MC44S803=y
+CONFIG_MEDIA_TUNER_MT20XX=y
+CONFIG_MEDIA_TUNER_SIMPLE=y
+CONFIG_MEDIA_TUNER_TDA8290=y
+CONFIG_MEDIA_TUNER_TDA9887=y
+CONFIG_MEDIA_TUNER_TEA5761=y
+CONFIG_MEDIA_TUNER_TEA5767=y
+CONFIG_MEDIA_TUNER_XC2028=y
+CONFIG_MEDIA_TUNER_XC5000=y
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MII is not set
+CONFIG_MINIX_FS=m
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_MSDOS_FS=y
+CONFIG_MTD_PHYSMAP=y
+# CONFIG_MTD_ROOTFS_ROOT_DEV is not set
+CONFIG_NETCONSOLE=y
+# CONFIG_NETCONSOLE_DYNAMIC is not set
+# CONFIG_NETDEV_1000 is not set
+CONFIG_NETPOLL=y
+# CONFIG_NETPOLL_TRAP is not set
+CONFIG_NET_POLL_CONTROLLER=y
+# CONFIG_NET_SCHED is not set
+CONFIG_NFSD=m
+CONFIG_NFS_FS=y
+CONFIG_NLS=y
+CONFIG_NLS_ASCII=m
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_NLS_UTF8=m
+CONFIG_NO_HZ=y
+CONFIG_OSC_CLK_FREQ=27000000
+# CONFIG_PACKET_MMAP is not set
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_PAGE_OFFSET=0xC0000000
+# CONFIG_PCI_SYSCALL is not set
+CONFIG_PHYLIB=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_POSIX_MQUEUE_SYSCTL=y
+CONFIG_PPP=m
+CONFIG_PPP_ASYNC=m
+CONFIG_PPP_DEFLATE=m
+# CONFIG_PPP_FILTER is not set
+# CONFIG_PPP_MULTILINK is not set
+CONFIG_PPP_SYNC_TTY=m
+CONFIG_PREEMPT=y
+# CONFIG_PREEMPT_NONE is not set
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_RD_GZIP=y
+# CONFIG_RD_LZMA is not set
+CONFIG_RESIZER=y
+CONFIG_ROOT_NFS=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_DS1672=y
+# CONFIG_SCSI_DMA is not set
+CONFIG_SENSORS_GSP=y
+# CONFIG_SERIAL_8250_EXTENDED is not set
+CONFIG_SERIAL_8250_NR_UARTS=3
+CONFIG_SERIAL_8250_RUNTIME_UARTS=3
+# CONFIG_SLAB is not set
+CONFIG_SLHC=m
+CONFIG_SLUB=y
+CONFIG_SLUB_DEBUG=y
+# CONFIG_SLUB_DEBUG_ON is not set
+# CONFIG_SLUB_STATS is not set
+CONFIG_SMB_FS=m
+# CONFIG_SOC_CAMERA_MT9T031 is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4096
+# CONFIG_STAGING is not set
+# CONFIG_STRIP_ASM_SYMS is not set
+CONFIG_SUNRPC=y
+# CONFIG_SWAP is not set
+# CONFIG_SYN_COOKIES is not set
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_TI_DAVINCI_EMAC=y
+# CONFIG_TREE_PREEMPT_RCU is not set
+CONFIG_TREE_RCU=y
+CONFIG_TUN=m
+CONFIG_UID16=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_VFAT_FS=y
+# CONFIG_VFP is not set
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_VIDEOBUF_DMA_CONTIG=y
+CONFIG_VIDEOBUF_GEN=y
+CONFIG_VIDEOBUF_VMALLOC=y
+CONFIG_VIDEO_CAPTURE_DRIVERS=y
+CONFIG_VIDEO_DAVINCI_DISPLAY=y
+CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_DM6446_CCDC=y
+CONFIG_VIDEO_MEDIA=y
+# CONFIG_VIDEO_THS7353 is not set
+# CONFIG_VIDEO_THS8200 is not set
+CONFIG_VIDEO_TVP514X=y
+CONFIG_VIDEO_TVP5150=y
+# CONFIG_VIDEO_TVP7002 is not set
+# CONFIG_VIDEO_V4L1_COMPAT is not set
+CONFIG_VIDEO_V4L2=y
+CONFIG_VIDEO_V4L2_COMMON=y
+CONFIG_VIDEO_VPFE_CAPTURE=y
+CONFIG_VIDEO_VPSS_SYSTEM=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_VT=y
+# CONFIG_VT_CONSOLE is not set
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+# CONFIG_WIRELESS is not set
+# CONFIG_WLAN_80211 is not set
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZLIB_DEFLATE=m
Index: trunk/target/linux/davinci/patches-2.6.32/203-gateworks_gw2361.patch
===================================================================
--- trunk/target/linux/davinci/patches-2.6.32/203-gateworks_gw2361.patch	(revision 0)
+++ trunk/target/linux/davinci/patches-2.6.32/203-gateworks_gw2361.patch	(revision 0)
@@ -0,0 +1,471 @@
+--- /dev/null
++++ b/arch/arm/mach-davinci/board-gateworks-2361.c
+@@ -0,0 +1,346 @@
++/*
++ * TI DaVinci EVM board support
++ *
++ * Author: Kevin Hilman, MontaVista Software, Inc. <source@mvista.com>
++ *
++ * 2007 (c) MontaVista Software, Inc. This file is licensed under
++ * the terms of the GNU General Public License version 2. This program
++ * is licensed "as is" without any warranty of any kind, whether express
++ * or implied.
++ */
++#include <linux/kernel.h>
++#include <linux/module.h>
++#include <linux/init.h>
++#include <linux/dma-mapping.h>
++#include <linux/platform_device.h>
++#include <linux/gpio.h>
++#include <linux/leds.h>
++#include <linux/memory.h>
++
++#include <linux/i2c.h>
++#include <linux/i2c/at24.h>
++#include <linux/i2c/pca953x.h>
++#include <linux/etherdevice.h>
++#include <linux/mtd/mtd.h>
++#include <linux/mtd/nand.h>
++#include <linux/mtd/partitions.h>
++#include <linux/mtd/physmap.h>
++#include <linux/io.h>
++#include <linux/phy.h>
++#include <linux/clk.h>
++#include <linux/videodev2.h>
++
++#include <media/tvp5150.h>
++
++#include <asm/setup.h>
++#include <asm/mach-types.h>
++
++#include <asm/mach/arch.h>
++#include <asm/mach/map.h>
++#include <asm/mach/flash.h>
++
++#include <mach/dm644x.h>
++#include <mach/common.h>
++#include <mach/i2c.h>
++#include <mach/serial.h>
++#include <mach/mux.h>
++#include <mach/psc.h>
++#include <mach/nand.h>
++#include <mach/mmc.h>
++#include <mach/emac.h>
++
++#define DM644X_EVM_PHY_MASK		(0x2)
++#define DM644X_EVM_MDIO_FREQUENCY	(2200000) /* PHY bus frequency */
++
++#define DAVINCI_CFC_ATA_BASE		  0x01C66000
++
++#define DAVINCI_ASYNC_EMIF_CONTROL_BASE   0x01e00000
++#define DAVINCI_ASYNC_EMIF_DATA_CE0_BASE  0x02000000
++#define DAVINCI_ASYNC_EMIF_DATA_CE1_BASE  0x04000000
++#define DAVINCI_ASYNC_EMIF_DATA_CE2_BASE  0x06000000
++#define DAVINCI_ASYNC_EMIF_DATA_CE3_BASE  0x08000000
++
++#define LXT971_PHY_ID	(0x001378e2)
++#define LXT971_PHY_MASK	(0xfffffff0)
++
++static struct mtd_partition gw2361_norflash_partitions[] = {
++	/* bootloader (UBL, U-Boot, etc) in first 5 sectors */
++	{
++		.name		= "bootloader",
++		.offset		= 0,
++		.size		= 6 * SZ_64K,
++		.mask_flags	= MTD_WRITEABLE, /* force read-only */
++	},
++	/* bootloader params in the next 1 sectors */
++	{
++		.name		= "params",
++		.offset		= 6 * SZ_64K,
++		.size		= SZ_128K,
++		.mask_flags	= 0,
++	},
++	/* kernel */
++	{
++		.name		= "kernel",
++		.offset		= 8 * SZ_64K,
++		.size		= SZ_2M,
++		.mask_flags	= 0
++	},
++	/* file system */
++	{
++		.name		= "rootfs",
++		.offset		= SZ_2M + (8 * SZ_64K),
++		.size		= SZ_16M + 0xD80000,
++		.mask_flags	= 0
++	}
++};
++
++static struct physmap_flash_data gw2361_norflash_data = {
++	.width		= 2,
++	.parts		= gw2361_norflash_partitions,
++	.nr_parts	= ARRAY_SIZE(gw2361_norflash_partitions),
++};
++
++/* NOTE: CFI probe will correctly detect flash part as 32M, but EMIF
++ * limits addresses to 16M, so using addresses past 16M will wrap */
++static struct resource gw2361_norflash_resource = {
++	.start		= DAVINCI_ASYNC_EMIF_DATA_CE0_BASE,
++	.end		= DAVINCI_ASYNC_EMIF_DATA_CE0_BASE + SZ_32M - 1,
++	.flags		= IORESOURCE_MEM,
++};
++
++static struct platform_device gw2361_norflash_device = {
++	.name		= "physmap-flash",
++	.id		= 0,
++	.dev		= {
++		.platform_data	= &gw2361_norflash_data,
++	},
++	.num_resources	= 1,
++	.resource	= &gw2361_norflash_resource,
++};
++
++#define TVP5150_STD_ALL	(V4L2_STD_NTSC | V4L2_STD_PAL)
++/* Inputs available at the TVP5150 */
++static struct v4l2_input tvp5150_inputs[] = {
++	{
++		.index = 0,
++		.name = "Composite",
++		.type = V4L2_INPUT_TYPE_CAMERA,
++		.std = TVP5150_STD_ALL,
++	},
++};
++
++/*
++ * this is the route info for connecting each input to decoder
++ * ouput that goes to vpfe. There is a one to one correspondence
++ * with tvp5150_inputs
++ */
++static struct vpfe_route tvp5150_routes[] = {
++	{
++		.input = TVP5150_COMPOSITE0,
++		.output = TVP5150_NORMAL,
++	},
++};
++
++static struct vpfe_subdev_info vpfe_sub_devs[] = {
++	{
++		.module_name = "tvp5150",
++		.grp_id = VPFE_SUBDEV_TVP5146,
++		.num_inputs = ARRAY_SIZE(tvp5150_inputs),
++		.inputs = tvp5150_inputs,
++		.routes = tvp5150_routes,
++		.can_route = 1,
++		.ccdc_if_params = {
++			.if_type = VPFE_BT656,
++			.hdpol = VPFE_PINPOL_POSITIVE,
++			.vdpol = VPFE_PINPOL_POSITIVE,
++		},
++		.board_info = {
++			I2C_BOARD_INFO("tvp5150", 0x5c),
++		},
++	},
++};
++
++static struct vpfe_config vpfe_cfg = {
++	.num_subdevs = ARRAY_SIZE(vpfe_sub_devs),
++	.sub_devs = vpfe_sub_devs,
++	.card_name = "DM6446 EVM",
++	.ccdc = "DM6446 CCDC",
++	.num_clocks = 2,
++	.clocks = {"vpss_master", "vpss_slave"},
++};
++
++static struct snd_platform_data dm644x_evm_snd_data;
++
++static struct pca953x_platform_data gw2361_pca_data = {
++	.gpio_base  = 100,
++};
++
++static struct gpio_led gw2361_gpio_leds[] = {
++	{
++		.name = "user",		/* green onboard led */
++		.gpio = 40,
++		.active_low = 1,
++	},
++	{
++		.name = "led1",		/* 2-pin Connector */
++		.gpio = 39,
++		.active_low = 1,
++	},
++	{
++		.name = "led2",		/* 2-pin Connector */
++		.gpio = 37,
++		.active_low = 1,
++	},
++	{
++		.name = "led3",		/* 2-pin Connector */
++		.gpio = 38,
++		.active_low = 1,
++	},
++};
++
++static struct gpio_led_platform_data gw2361_gpio_leds_data = {
++	.num_leds = 4,
++	.leds = gw2361_gpio_leds,
++};
++
++static struct platform_device gw2361_gpio_leds_device = {
++	.name = "leds-gpio",
++	.id = -1,
++	.dev.platform_data = &gw2361_gpio_leds_data,
++};
++
++/*----------------------------------------------------------------------*/
++
++/*----------------------------------------------------------------------*/
++
++/* Most of this EEPROM is unused, but U-Boot uses some data:
++ *  - 0x7f00, 6 bytes Ethernet Address
++ *  - 0x0039, 1 byte NTSC vs PAL (bit 0x80 == PAL)
++ *  - ... newer boards may have more
++ */
++
++static struct at24_platform_data eeprom_info = {
++	.byte_len	= (256*1024) / 8,
++	.page_size	= 64,
++	.flags		= AT24_FLAG_ADDR16,
++	.setup          = davinci_get_mac_addr,
++	.context	= (void *)0x100,
++};
++
++static struct i2c_board_info __initdata i2c_info[] =  {
++	{
++		I2C_BOARD_INFO("24c256", 0x50),
++		.platform_data	= &eeprom_info,
++	},
++	{
++		I2C_BOARD_INFO("tlv320aic33", 0x1b),
++	},
++	{
++		I2C_BOARD_INFO("ds1672", 0x68),
++	},
++	{
++		I2C_BOARD_INFO("gsp", 0x29),
++	},
++	{
++		I2C_BOARD_INFO("pca9555", 0x23),
++		.platform_data  = &gw2361_pca_data,
++	},
++};
++
++/* The msp430 uses a slow bitbanged I2C implementation (ergo 20 KHz),
++ * which requires 100 usec of idle bus after i2c writes sent to it.
++ */
++static struct davinci_i2c_platform_data i2c_pdata = {
++	.bus_freq	= 20 /* kHz */,
++	.bus_delay	= 100 /* usec */,
++};
++
++static void __init evm_init_i2c(void)
++{
++	davinci_init_i2c(&i2c_pdata);
++	i2c_register_board_info(1, i2c_info, ARRAY_SIZE(i2c_info));
++}
++
++static struct davinci_uart_config uart_config __initdata = {
++	.enabled_uarts = (1 << 0) | (1 << 1) | (1 << 2),
++};
++
++static void __init
++gw2361_map_io(void)
++{
++	/* setup input configuration for VPFE input devices */
++	dm644x_set_vpfe_config(&vpfe_cfg);
++	dm644x_init();
++}
++
++static struct resource gw2361_gpio_resources[] = {
++	{
++		.name = "gpio",
++		.flags = 0,
++	},
++};
++
++static struct platform_device gw2361_gpio = {
++	.name     = "GPIODEV",
++	.id     = -1,
++	.num_resources    = ARRAY_SIZE(gw2361_gpio_resources),
++	.resource   = gw2361_gpio_resources,
++};
++
++static struct platform_device *gw2361_devices[] __initdata = {
++	&gw2361_gpio,
++};
++
++static __init void gw2361_init(void)
++{
++	struct clk *aemif_clk;
++	struct clk *tpcc_clk;
++	struct clk *tptc0_clk;
++	struct clk *tptc1_clk;
++	struct clk *vpss_master_clk;
++	struct clk *vpss_slave_clk;
++	struct davinci_soc_info *soc_info = &davinci_soc_info;
++
++	aemif_clk = clk_get(NULL, "aemif");
++	clk_enable(aemif_clk);
++	tpcc_clk = clk_get(NULL, "tpcc");
++	clk_enable(tpcc_clk);
++	tptc0_clk = clk_get(NULL, "tptc0");
++	clk_enable(tptc0_clk);
++	tptc1_clk = clk_get(NULL, "tptc1");
++	clk_enable(tptc1_clk);
++	vpss_master_clk = clk_get(NULL, "vpss_master");
++	clk_enable(vpss_master_clk);
++	vpss_slave_clk = clk_get(NULL, "vpss_slave");
++	clk_enable(vpss_slave_clk);
++
++	platform_device_register(&gw2361_norflash_device);
++	platform_device_register(&gw2361_gpio_leds_device);
++	
++  platform_add_devices(gw2361_devices,
++						ARRAY_SIZE(gw2361_devices));
++	evm_init_i2c();
++
++	davinci_serial_init(&uart_config);
++	dm644x_init_asp(&dm644x_evm_snd_data);
++
++	soc_info->emac_pdata->phy_mask = DM644X_EVM_PHY_MASK;
++	soc_info->emac_pdata->mdio_max_freq = DM644X_EVM_MDIO_FREQUENCY;
++
++}
++
++static __init void gw2361_irq_init(void)
++{
++	davinci_irq_init();
++}
++
++MACHINE_START(GW2361, "Gateworks GW2361")
++	/* Maintainer: Gateworks Corp <clang@gateworks.com> */
++	.phys_io      = IO_PHYS,
++	.io_pg_offst  = (__IO_ADDRESS(IO_PHYS) >> 18) & 0xfffc,
++	.boot_params  = (DAVINCI_DDR_BASE + 0x100),
++	.map_io	      = gw2361_map_io,
++	.init_irq     = gw2361_irq_init,
++	.timer	      = &davinci_timer,
++	.init_machine = gw2361_init,
++MACHINE_END
+--- a/arch/arm/mach-davinci/dm644x.c
++++ b/arch/arm/mach-davinci/dm644x.c
+@@ -138,6 +138,30 @@ static struct clk dsp_clk = {
+ 	.usecount = 1,			/* REVISIT how to disable? */
+ };
+ 
++static struct clk tpcc_clk = {
++	.name = "tpcc",
++	.parent = &pll1_sysclk1,
++	.lpsc = DAVINCI_LPSC_TPCC,
++	.flags = PSC_DSP,
++	.usecount = 1,			/* REVISIT how to disable? */
++};
++
++static struct clk tptc0_clk = {
++	.name = "tptc0",
++	.parent = &pll1_sysclk1,
++	.lpsc = DAVINCI_LPSC_TPTC0,
++	.flags = PSC_DSP,
++	.usecount = 1,			/* REVISIT how to disable? */
++};
++
++static struct clk tptc1_clk = {
++	.name = "tptc1",
++	.parent = &pll1_sysclk1,
++	.lpsc = DAVINCI_LPSC_TPTC1,
++	.flags = PSC_DSP,
++	.usecount = 1,			/* REVISIT how to disable? */
++};
++
+ static struct clk arm_clk = {
+ 	.name = "arm",
+ 	.parent = &pll1_sysclk2,
+@@ -295,6 +319,9 @@ struct davinci_clk dm644x_clks[] = {
+ 	CLK(NULL, "pll2_sysclk2", &pll2_sysclk2),
+ 	CLK(NULL, "pll2_sysclkbp", &pll2_sysclkbp),
+ 	CLK(NULL, "dsp", &dsp_clk),
++	CLK(NULL, "tpcc", &tpcc_clk),
++	CLK(NULL, "tptc0", &tptc0_clk),
++	CLK(NULL, "tptc1", &tptc1_clk),
+ 	CLK(NULL, "arm", &arm_clk),
+ 	CLK(NULL, "vicp", &vicp_clk),
+ 	CLK(NULL, "vpss_master", &vpss_master_clk),
+--- a/arch/arm/mach-davinci/Kconfig
++++ b/arch/arm/mach-davinci/Kconfig
+@@ -65,6 +65,12 @@ config MACH_SFFSDR
+ 	  Say Y here to select the Lyrtech Small Form Factor
+ 	  Software Defined Radio (SFFSDR) board.
+ 
++config MACH_GW2361
++	bool "Gateworks GW2361 Board"
++	depends on ARCH_DAVINCI_DM644x
++	help
++	  Say Y here to select the Gateworks GW2361
++
+ config MACH_DAVINCI_DM355_EVM
+ 	bool "TI DM355 EVM"
+ 	default ARCH_DAVINCI_DM355
+--- a/arch/arm/mach-davinci/Makefile
++++ b/arch/arm/mach-davinci/Makefile
+@@ -28,6 +28,7 @@ obj-$(CONFIG_CP_INTC)			+= cp_intc.o
+ 
+ # Board specific
+ obj-$(CONFIG_MACH_DAVINCI_EVM)  	+= board-dm644x-evm.o
++obj-$(CONFIG_MACH_GW2361)		+= board-gateworks-2361.o
+ obj-$(CONFIG_MACH_SFFSDR)		+= board-sffsdr.o
+ obj-$(CONFIG_MACH_DAVINCI_DM355_EVM)	+= board-dm355-evm.o
+ obj-$(CONFIG_MACH_DM355_LEOPARD)	+= board-dm355-leopard.o
+--- a/include/media/davinci/vpfe_capture.h
++++ b/include/media/davinci/vpfe_capture.h
+@@ -68,6 +68,7 @@ enum vpfe_subdev_id {
+ 	VPFE_SUBDEV_TVP5146 = 1,
+ 	VPFE_SUBDEV_MT9T031 = 2,
+ 	VPFE_SUBDEV_TVP7002 = 3,
++	VPFE_SUBDEV_TVP5150 = 4,
+ };
+ 
+ struct vpfe_subdev_info {
+--- a/drivers/media/video/davinci/davinci_display.c
++++ b/drivers/media/video/davinci/davinci_display.c
+@@ -43,8 +43,8 @@
+ #define DM644X_EVM_CARD "DM644X EVM"
+ #define DM365_EVM_CARD  "DM365 EVM"
+ 
+-static u32 video2_numbuffers = 3;
+-static u32 video3_numbuffers = 3;
++static u32 video2_numbuffers = 2;
++static u32 video3_numbuffers = 2;
+ 
+ #define DAVINCI_DISPLAY_HD_BUF_SIZE (1280*720*2)
+ #define DAVINCI_DISPLAY_SD_BUF_SIZE (720*576*2)
+@@ -58,7 +58,7 @@ module_param(video3_numbuffers, uint, S_
+ module_param(video2_bufsize, uint, S_IRUGO);
+ module_param(video3_bufsize, uint, S_IRUGO);
+ 
+-#define DAVINCI_DEFAULT_NUM_BUFS 3
++#define DAVINCI_DEFAULT_NUM_BUFS 2
+ static struct buf_config_params display_buf_config_params = {
+ 	.min_numbuffers = DAVINCI_DEFAULT_NUM_BUFS,
+ 	.numbuffers[0] = DAVINCI_DEFAULT_NUM_BUFS,
+--- a/drivers/media/video/davinci/vpfe_capture.c
++++ b/drivers/media/video/davinci/vpfe_capture.c
+@@ -84,7 +84,7 @@
+ #define SECOND_IMAGE_SIZE_MAX	(640 * 480 * 2)
+ 
+ static int debug;
+-static u32 numbuffers = 3;
++static u32 numbuffers = 2;
+ static u32 bufsize = PAL_IMAGE_SIZE + SECOND_IMAGE_SIZE_MAX;
+ static int interface;
+ 
+@@ -133,8 +133,8 @@ struct ccdc_config {
+ 
+ /* data structures */
+ static struct vpfe_config_params config_params = {
+-	.min_numbuffers = 3,
+-	.numbuffers = 3,
++	.min_numbuffers = 2,
++	.numbuffers = 2,
+ 	.min_bufsize = 720 * 480 * 2,
+ 	.device_bufsize = 720 * 576 * 2,
+ };
Index: trunk/target/linux/davinci/patches-2.6.32/204-davinci_resizer.patch
===================================================================
--- trunk/target/linux/davinci/patches-2.6.32/204-davinci_resizer.patch	(revision 0)
+++ trunk/target/linux/davinci/patches-2.6.32/204-davinci_resizer.patch	(revision 0)
@@ -0,0 +1,2688 @@
+--- /dev/null
++++ b/arch/arm/mach-davinci/include/mach/davinci_resizer.h
+@@ -0,0 +1,368 @@
++/* *
++ * Copyright (C) 2006 Texas Instruments Inc
++ *
++ * This program is free software you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation either version 2 of the License, or
++ * (at your option) any later version.
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not,write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
++ */
++/* davinci_resizer.h file */
++
++#ifndef	DAVINVI_RESIZER_H
++#define	DAVINVI_RESIZER_H
++
++#ifdef __KERNEL__
++/* include Linux files */
++#include <mach/hardware.h>
++#include <linux/io.h>
++#include <linux/autoconf.h>
++#include <linux/module.h>
++#include <linux/moduleparam.h>
++#include <linux/init.h>
++#include <linux/kernel.h>	/*     printk() */
++#include <linux/slab.h>		/*     kmalloc() */
++#include <linux/fs.h>		/*     everything... */
++#include <linux/errno.h>	/*     error codes     */
++#include <linux/types.h>	/*     size_t */
++#include <linux/mm.h>
++#include <linux/kdev_t.h>
++#include <asm/page.h>
++#include <linux/cdev.h>
++#include <linux/string.h>
++#include <linux/tty.h>
++#include <linux/delay.h>
++#include <linux/fb.h>
++#include <linux/dma-mapping.h>
++#include <linux/interrupt.h>
++#include <linux/uaccess.h>
++#include <linux/ioport.h>
++#include <linux/version.h>
++#include <linux/irq.h>
++#include <mach/clock.h>
++#include <linux/errno.h>
++#include <linux/sched.h>
++#include <linux/err.h>
++#include <linux/proc_fs.h>
++#include <linux/sysctl.h>
++#ifdef CONFIG_PREEMPT_RT
++#include <linux/completion.h>
++#endif
++#endif				/* end of #ifdef __KERNEL__ */
++/* Definitions */
++
++/* ioctls definition */
++#pragma	pack(1)
++#define		RSZ_IOC_BASE			       'R'
++#define		RSZ_IOC_MAXNR				11
++
++/*Ioctl options which are to be passed while calling the ioctl*/
++#define	RSZ_REQBUF		_IOWR(RSZ_IOC_BASE, 1,  struct rsz_reqbufs_t*)
++#define	RSZ_QUERYBUF		_IOWR(RSZ_IOC_BASE, 2, struct rsz_buffer_t  *)
++#define	RSZ_S_PARAM		_IOWR(RSZ_IOC_BASE, 3, struct rsz_params_t *)
++#define	RSZ_G_PARAM		_IOWR(RSZ_IOC_BASE, 4, struct rsz_params_t *)
++#define	RSZ_RESIZE		_IOWR(RSZ_IOC_BASE, 5, struct rsz_resize_t *)
++#define	RSZ_G_STATUS		_IOWR(RSZ_IOC_BASE, 6, struct rsz_status_t *)
++#define	RSZ_S_PRIORITY		_IOWR(RSZ_IOC_BASE, 7, struct rsz_priority_t*)
++#define	RSZ_G_PRIORITY		_IOWR(RSZ_IOC_BASE, 9, struct rsz_priority_t*)
++#define	RSZ_GET_CROPSIZE	_IOWR(RSZ_IOC_BASE, 10, struct rsz_cropsize_t *)
++#define	RSZ_S_EXP		_IOWR(RSZ_IOC_BASE, 11, int*)
++#pragma	pack()
++/* End of ioctls */
++
++#define	RSZ_BUF_IN						0
++#define	RSZ_BUF_OUT						1
++#define	RSZ_YENH_DISABLE					0
++#define	RSZ_YENH_3TAP_HPF					1
++#define	RSZ_YENH_5TAP_HPF					2
++
++#ifdef __KERNEL__
++
++/* Defines and Constants*/
++#define	MAX_BUFFER						3
++#define	MAX_CHANNELS						16
++#define	MAX_PRIORITY						5
++#define	MIN_PRIORITY						0
++#define	DEFAULT_PRIORITY					3
++#define	MAX_IMAGE_WIDTH						1280
++#define	MAX_IMAGE_WIDTH_HIGH					640
++#define	MAX_IMAGE_HEIGHT					960
++#define	MAX_INPUT_BUFFERS					8
++#define	MAX_OUTPUT_BUFFERS					8
++#define	DRIVER_NAME						"Resizer"
++#define	FREE_BUFFER						0
++#define	ALIGNMENT						16
++#define	CHANNEL_BUSY						1
++#define	CHANNEL_FREE						0
++#define	PIXEL_EVEN						2
++#define	RATIO_MULTIPLIER					256
++
++/*Bit position	Macro*/
++/* macro for bit set and clear */
++#define	BITSET(variable, bit)		((variable) | (1<<bit))
++#define	BITRESET(variable, bit)		((variable) & (~(0x00000001<<(bit))))
++
++/* RSZ_CNT */
++#define	CSL_RESZ_RSZ_CNT_CBILIN_MASK			(0x20000000u)
++#define	CSL_RESZ_RSZ_CNT_CBILIN_SHIFT			(0x0000001Du)
++
++/*RSZ_OUT_VSIZE_SHIFT*/
++
++#define	RSZ_VSTPH_MASK					(0xfC7fffffu)
++#define	RSZ_HSTPH_MASK					(0xff8fffffu)
++
++#define	RSZ_CNT_VRSZ_MASK				(0xfff002ffu)
++#define	RSZ_CNT_HRSZ_MASK				(0xfffffc00u)
++/* OUT_SIZE	*/
++#define	RSZ_OUT_SIZE_VERT_MASK				(0xf800ffffu)
++#define	RSZ_OUT_SIZE_HORZ_MASK				(0xfffff800u)
++/* IN_START	*/
++
++#define	RSZ_IN_START_VERT_ST_MASK			(0xE000FFFFu)
++#define	RSZ_IN_START_HORZ_ST_MASK			(0xFFFFE000u)
++/* IN_SIZE */
++#define	RSZ_IN_SIZE_VERT_MASK				(0xe000ffffu)
++#define	RSZ_IN_SIZE_HORZ_MASK				(0xffffe000u)
++/* SDR_INOFF */
++#define	RSZ_SDR_INOFF_OFFSET_MASK			(0xffff0000u)
++#define	RSZ_SDR_OUTOFF_OFFSET_MASK			(0xffff0000u)
++ /**/
++#define	RSZ_UWORD_MASK					(0x03FF0000u)
++#define	RSZ_LWORD_MASK					(0x000003FFu)
++/* YENH	*/
++#define	RSZ_YEHN_CORE_MASK				(0xffffff00u)
++#define	RSZ_YEHN_SLOP_MASK				(0xfffff0ffu)
++#define	RSZ_YEHN_GAIN_MASK				(0xffff0fffu)
++#define	RSZ_YEHN_ALGO_MASK				(0xfffcffffu)
++/* Filter coeefceints */
++#define	RSZ_FILTER_COEFF0_MASK				(0xfffffc00u)
++#define	RSZ_FILTER_COEFF1_MASK				(0xfc00ffffu)
++#define	RSZ_CNT_CBILIN_MASK				(0x20000000u)
++#define	RSZ_CNT_INPTYP_MASK				(0x08000000u)
++#define	RSZ_CNT_PIXFMT_MASK				(0x04000000u)
++#define	RSZ_HSTP_SHIFT					20
++#define	RSZ_HRSZ_MASK					(0xfffffc00)
++#define	RSZ_VRSZ_MASK					(0xfff003ff)
++#define	RSZ_VRSZ_SHIFT					10
++/*///////Shifts*/
++#define	RSZ_OUT_VSIZE_SHIFT				16
++#define	SET_BIT_CBLIN					29
++#define	SET_BIT_INPUTRAM				28
++#define	INPUT_RAM					1
++#define	SET_BIT_INPTYP					27
++#define	SET_BIT_YCPOS					26
++#define	RSZ_VSTPH_SHIFT					23
++#define	RSZ_FILTER_COEFF_SHIFT				16
++#define	RSZ_YENH_TYPE_SHIFT				16
++#define	RSZ_YENH_GAIN_SHIFT				12
++#define	RSZ_YENH_SLOP_SHIFT				8
++#define	UP_RSZ_RATIO					64
++#define	DOWN_RSZ_RATIO					512
++#define	UP_RSZ_RATIO1					513
++#define	DOWN_RSZ_RATIO1					1024
++#define	SET_ENABLE_BIT					0
++#define	RSZ_IN_SIZE_VERT_SHIFT				16
++#define	MAX_HORZ_PIXEL_8BIT				31
++#define	MAX_HORZ_PIXEL_16BIT			15
++#define	BYTES_PER_PIXEL					2
++#define	 NUM_PHASES					8
++#define	 NUM_TAPS					4
++#define	 NUM_D2PH			4	/* for downsampling
++						2+x ~ 4x, numberof phases */
++#define	 NUM_D2TAPS			7	/* for downsampling
++						2+x ~ 4x,number of taps */
++#define	 NUM_COEFS (NUM_PHASES * NUM_TAPS)
++#define	ALIGN32						32
++#define	ADDRESS_FOUND					1
++#define	NEXT						1
++/*#define DEBUG							0*/
++#define	RESIZER_IOBASE_VADDR			IO_ADDRESS(0x01C70C00)
++#define	MAX_COEF_COUNTER				16
++#define	ZERO						0
++#define	FIRSTENTRY					0
++#define	SECONDENTRY					1
++#define	EMPTY						0
++#define	SUCESS						0
++#endif				/* end of #ifdef __KERNEL__ */
++#define	RSZ_INTYPE_YCBCR422_16BIT		0
++#define	RSZ_INTYPE_PLANAR_8BIT			1
++#define	RSZ_PIX_FMT_PLANAR			2	/* 8-bit planar input */
++#define	RSZ_PIX_FMT_UYVY			0	/*    cb:y:cr:y */
++#define	RSZ_PIX_FMT_YUYV			1	/*    y:cb:y:cr */
++#ifdef __KERNEL__
++#define	isbusy()				((regr(PCR)	& 0x02)>>1)
++/*///////Enumerations*/
++    enum config_done {
++	STATE_CONFIGURED,	/* Resizer driver configured by application */
++	STATE_NOT_CONFIGURED	/* Resizer driver not configured by
++				   application */
++};
++
++#endif				/* end of #ifdef __KERNEL__ */
++
++/*Structure Definitions*/
++/* To allocate the memory*/
++struct rsz_reqbufs_t {
++	int buf_type;		/* type of frame buffer */
++	int size;		/* size of the frame bufferto be allocated */
++	int count;		/* number of frame buffer to be allocated */
++};
++
++/* assed for quering the buffer to get physical address*/
++struct rsz_buffer_t {
++	int index;		/* buffer index number, 0 -> N-1 */
++	int buf_type;		/* buffer type, input or output */
++	int offset;		/* physical     address of the buffer,
++				   used in the mmap() system call */
++	int size;
++};
++
++/* used	to luma	enhancement options*/
++
++struct rsz_yenh_t {
++	int type;		/* represents luma enable or disable */
++	unsigned char gain;	/*represents gain */
++	unsigned char slop;	/*represents slop */
++	unsigned char core;	/* Represents core value */
++};
++
++/* Conatins	all	the	parameters for resizing	. This structure
++	is used	to configure resiser parameters*/
++struct rsz_params_t {
++	int in_hsize;		/* input frame horizontal size */
++	int in_vsize;		/* input frame vertical size */
++	int in_pitch;		/* offset between two rows of input frame */
++	int inptyp;		/* for determining 16 bit or 8 bit data */
++	int vert_starting_pixel;	/* for specifying vertical
++					   starting pixel in input */
++	int horz_starting_pixel;	/* for specyfing horizontal
++					   starting pixel in input */
++	int cbilin;		/* # defined, filter with luma or bi-linear
++				   interpolation */
++	int pix_fmt;		/* # defined, UYVY or YUYV */
++	int out_hsize;		/* output frame horizontal size */
++	int out_vsize;		/* output frame vertical size */
++	int out_pitch;		/* offset between two rows of output frame */
++	int hstph;		/* for specifying horizontal starting phase */
++	int vstph;		/* for specifying vertical starting phase */
++	short hfilt_coeffs[32];	/* horizontal filter coefficients */
++	short vfilt_coeffs[32];	/* vertical filter coefficients */
++	struct rsz_yenh_t yenh_params;
++};
++
++/* resize structure passed during the resize IOCTL*/
++struct rsz_resize_t {
++	struct rsz_buffer_t in_buf;
++	struct rsz_buffer_t out_buf;
++};
++
++/* Contains the status of hardware and channel*/
++struct rsz_status_t {
++	int chan_busy;		/* 1: channel is busy, 0: channel is not busy */
++	int hw_busy;		/*1: hardware  is busy, 0:
++				   hardware is not     busy */
++	int src;		/* # defined, can be either
++				   SD-RAM or CCDC/PREVIEWER */
++};
++
++/* structure to	set the priroity of the the channel*/
++struct rsz_priority_t {
++	int priority;		/* 0=>5, with 5 the highest priority */
++};
++
++/* Passed by application for getting crop size*/
++struct rsz_cropsize_t {
++	unsigned int hcrop;	/*number of pixels per line c
++				   ropped in output image */
++
++	unsigned int vcrop;	/*number of lines cropped
++				   in output image */
++};
++
++#ifdef __KERNEL__
++
++/*Register mapped structure which contains the every register
++information*/
++struct resizer_config_t {
++	int rsz_pcr;		/*pcr register mapping variable */
++	int rsz_in_start;	/* in_start register mapping variable */
++	int rsz_in_size;	/* in_size register mapping variable */
++	int rsz_out_size;	/* out_size register mapping variable */
++	int rsz_cnt;		/* rsz_cnt register mapping     variable */
++	int rsz_sdr_inadd;	/* sdr_inadd register mapping variable */
++	int rsz_sdr_inoff;	/* sdr_inoff register mapping variable */
++	int rsz_sdr_outadd;	/* sdr_outadd register mapping variable */
++	int rsz_sdr_outoff;	/* sdr_outbuff register mapping  variable */
++	int rsz_coeff_horz[16];	/* horizontal coefficients mapping array */
++	int rsz_coeff_vert[16];	/* vertical  coefficients mapping  array */
++	int rsz_yehn;		/* yehn(luma)register  mapping  variable */
++};
++
++/* Channel specific	structure contains information regarding
++the	every channel */
++struct channel_config_t {
++	struct resizer_config_t register_config;	/* instance
++				of register set mapping  structure */
++
++	void *input_buffer[MAX_INPUT_BUFFERS];	/* for storing input buffers
++						   pointers */
++
++	void *output_buffer[MAX_OUTPUT_BUFFERS];	/* for storing output
++							   buffers pointers */
++
++	int in_bufsize, out_bufsize; /* Contains input and output buffer size */
++
++	int status;		/* specifies whether the channel */
++	/* is busy or not */
++
++	int priority;		/* stores priority of the application */
++#ifdef CONFIG_PREEMPT_RT
++	struct completion channel_sem;
++#else
++	struct semaphore channel_sem;
++#endif
++	struct semaphore chanprotection_sem;
++	enum config_done config_state;
++};
++
++/*Global structure which contains information about	number of chanels
++and	protection variables */
++struct device_params_t {
++	int module_usage_count;	/* For counting no of channels
++				   created */
++	struct completion sem_isr;	/*Semaphore for interrupt */
++	struct semaphore array_sem;	/* Semaphore for array */
++	struct semaphore device_mutex;	/* mutex protecting device_params */
++	/* structure object */
++
++	struct channel_config_t *channel_configuration[MAX_CHANNELS];
++	/* Pointer to channel configuration */
++
++	int array_count;	/* for counting number of elements
++				   in arrray */
++};
++
++/*Functions Definition*/
++
++int malloc_buff(struct rsz_reqbufs_t *, struct channel_config_t *);
++int get_buf_address(struct rsz_buffer_t *, struct channel_config_t *);
++int rsz_start(struct rsz_resize_t *, struct channel_config_t *);
++int add_to_array(struct channel_config_t *rsz_configuration_channel);
++int delete_from_array(struct channel_config_t *rsz_configuration_channel);
++int rsz_set_params(struct rsz_params_t *, struct channel_config_t *);
++int rsz_get_params(struct rsz_params_t *, struct channel_config_t *);
++int free_buff(struct channel_config_t *rsz_configuration_channel);
++irqreturn_t rsz_isr(int, void *, struct pt_regs *);
++void rsz_calculate_crop(struct channel_config_t *rsz_conf_chan,
++			struct rsz_cropsize_t *
++						cropsize);
++#endif				/* end of #ifdef __KERNEL__ */
++
++#endif				/* End of #ifndef DAVINCI_RESIZER_H */
+--- /dev/null
++++ b/arch/arm/mach-davinci/include/mach/davinci_resizer_hw.h
+@@ -0,0 +1,58 @@
++/* *
++ * Copyright (C) 2006 Texas Instruments Inc
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
++ */
++/* davinci_resizer_hw.c file */
++#ifndef	DAVINCI_RESIZER_HW
++#define	DAVINCI_RESIZER_HW
++
++#include <mach/davinci_resizer.h>
++#include <mach/hardware.h>
++#include <linux/io.h>
++
++/* Register	offset mapping*/
++#define	RESIZER_IOBASE_VADDR	IO_ADDRESS(0x01C70C00)
++#define	PID					0x0000
++#define	PCR					0x0004
++#define	RSZ_CNT					0x0008
++#define	OUT_SIZE				0x000C
++#define	IN_START				0x0010
++#define	IN_SIZE					0x0014
++#define	SDR_INADD				0x0018
++#define	SDR_INOFF				0x001C
++#define	SDR_OUTADD				0x0020
++#define	SDR_OUTOFF				0x0024
++#define	HFILT10					0x0028
++#define	VFILT10					0x0068
++#define	COEFF_ADDRESS_OFFSET			0x04
++#define	YENH					0x00A8
++
++#define	VPSS_PCR				(0x3404-0x0C00)
++#define	SDR_REQ_EXP				(0x3508-0x0C00)
++
++/* Register	read/write */
++#define	regw(val, reg)		outl(val, ((reg) + RESIZER_IOBASE_VADDR))
++#define	regr(reg)		inl((reg) + RESIZER_IOBASE_VADDR)
++
++/* functions definition*/
++void rsz_hardware_setup(struct channel_config_t *rsz_conf_chan);
++int rsz_enable(struct channel_config_t *rsz_conf_chan);
++static inline void rsz_set_exp(int exp)
++{
++	regw(((exp & 0x3ff) << 10), SDR_REQ_EXP);
++}
++int rsz_writebuffer_status(void);
++#endif
+--- /dev/null
++++ b/drivers/char/davinci_resizer.c
+@@ -0,0 +1,1649 @@
++/* *
++ * Copyright (C) 2006 Texas Instruments Inc
++ *
++ * This program is free software you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option)any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not,write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
++ */
++/* davinci_resizer.c file */
++
++/* Copyright (c) 2008 Neuros Technology
++ * ported to udev for 2.6.23. -------- 03-06-2008 mgao@neuros
++ *
++ */
++
++/*Header files*/
++#include <linux/autoconf.h>
++#include <linux/module.h>
++#include <linux/init.h>
++#include <linux/kernel.h>
++#include <linux/slab.h>		/*     kmalloc() */
++#include <linux/fs.h>		/*     everything... */
++#include <linux/errno.h>	/*     error codes     */
++#include <linux/types.h>	/*     size_t */
++#include <linux/cdev.h>
++#include <linux/fb.h>
++#include <linux/dma-mapping.h>
++#include <linux/interrupt.h>
++#include <linux/uaccess.h>
++#include <linux/irq.h>
++#include <linux/io.h>
++#include <linux/err.h>
++#include <linux/device.h>
++#include <linux/platform_device.h>
++#include <mach/davinci_resizer_hw.h>
++#include <mach/davinci_resizer.h>
++
++#define	DRIVERNAME	"DaVinciResizer"
++#define EXTERN   extern
++
++MODULE_LICENSE("GPL");
++
++/*Global structute shared between all applications*/
++/*struct device_params device_config;*/
++struct device_params_t device_config;
++/* For registeration of	charatcer device*/
++static struct cdev c_dev;
++/* device structure	to make	entry in device*/
++static dev_t dev;
++/* for holding device entry*/
++EXTERN struct device *rsz_device;
++
++/* inline function to free reserver pages  */
++inline void rsz_free_pages(unsigned long addr, unsigned long bufsize)
++{
++	unsigned long size;
++	unsigned long tempaddr;
++	tempaddr = addr;
++	if (!addr)
++		return;
++	size = PAGE_SIZE << (get_order(bufsize));
++	while (size > 0) {
++		ClearPageReserved(virt_to_page(addr));
++		addr += PAGE_SIZE;
++		size -= PAGE_SIZE;
++	}
++	free_pages(tempaddr, get_order(bufsize));
++}
++
++/*
++=====================malloc_buff===========================
++Function to	allocate memory	to input and output	buffers
++*/
++int malloc_buff(struct rsz_reqbufs_t *reqbuff,
++				struct channel_config_t *rsz_conf_chan)
++{
++	/* For looping purpose */
++	int buf_index = ZERO;
++	/* For calculating the difference between new buffers to be allocated */
++	int diff;
++	/* for pointing to input or output buffer pointer */
++	int *buf_ptr, *buf_start;
++	/* To calculate no of max buffers; */
++	int maxbuffers;
++	/* to calculate number of buffers allocated */
++	unsigned int numbuffers = ZERO;
++	/* for storing buffer size */
++	int *buf_size;
++	/* to free the number of allocared buffers */
++	int free_index;
++	/* to make sure buffer pointer never swapped */
++	unsigned long adr;
++	unsigned long size;
++
++	dev_dbg(rsz_device, "%s E\n", __FUNCTION__);
++
++	/* assigning the buf_ptr to input buffer which is array of void
++	   pointer */
++	if (reqbuff->buf_type == RSZ_BUF_IN) {
++		dev_dbg(rsz_device, "Input buffer requested \n");
++		buf_ptr = (int *)rsz_conf_chan->input_buffer;
++		buf_size = &rsz_conf_chan->in_bufsize;
++		maxbuffers = MAX_INPUT_BUFFERS;
++	}
++
++	/* assigning the buf_ptr to output buffer which is array of
++	   void pointer */
++	else if (reqbuff->buf_type == RSZ_BUF_OUT) {
++		dev_dbg(rsz_device, "Output buffer requested \n");
++		buf_ptr = (int *)rsz_conf_chan->output_buffer;
++		buf_size = &rsz_conf_chan->out_bufsize;
++		maxbuffers = MAX_OUTPUT_BUFFERS;
++	} else {
++		dev_dbg(rsz_device, "Invalid type \n");
++		return -EINVAL;
++	}
++
++	/* Check the request for number of buffers */
++	if (reqbuff->count > maxbuffers)
++		return -EINVAL;
++
++	/* Counting the number of  buffers allocated */
++	dev_dbg(rsz_device, "The requested size of buffer is %d \n",
++		reqbuff->size);
++	buf_start = buf_ptr;
++	while (*(buf_ptr) != (int)NULL && numbuffers < maxbuffers) {
++		numbuffers++;
++		buf_ptr++;
++	}
++
++	buf_ptr = buf_start;
++
++	/* Free all     the     buffers if the count is zero */
++	if (reqbuff->count == FREE_BUFFER) {
++		/* Free all     the     buffers */
++		for (buf_index = ZERO; buf_index < numbuffers; buf_index++) {
++			/* free memory allocate for the image */
++			dev_dbg(rsz_device,
++				"Free all the allocated buffers \n");
++			/* Free buffers using free_pages */
++			rsz_free_pages(*buf_ptr, *buf_size);
++
++			/* assign buffer zero to indicate its free */
++			*buf_ptr = (int)NULL;
++			buf_ptr++;
++		}
++		return SUCESS;
++	}
++
++	/* If buffers are previously allocated, size has to be same */
++	if (numbuffers) {
++
++		if (reqbuff->size != *buf_size) {
++			for (buf_index = ZERO; buf_index < numbuffers;
++			     buf_index++) {
++				/* free memory allocate for the image */
++				/* Free buffers using free_pages */
++				rsz_free_pages(*buf_ptr, *buf_size);
++
++				/* assign buffer zero to indicate its free */
++				*buf_ptr = (int)NULL;
++				buf_ptr++;
++			}
++			numbuffers = ZERO;
++			buf_ptr = buf_start;
++		}
++
++	}
++
++	/* get the difference to know how mnay buffers to allocate */
++	dev_dbg(rsz_device, "The no of requested buffers are %d \n ",
++		reqbuff->count);
++	diff = numbuffers - reqbuff->count;
++	if (diff > ZERO) {
++		buf_ptr = buf_ptr + reqbuff->count;
++		for (buf_index = reqbuff->count; buf_index < numbuffers;
++		     buf_index++) {
++			/* if difference is positive than deallocate that
++			   much memory of input buff */
++
++			/* free buffer using free_pages */
++			rsz_free_pages(*buf_ptr, *buf_size);
++
++			/* assign buffer zero to indicate its free */
++			*buf_ptr = (int)NULL;
++			buf_ptr++;
++		}
++	} else {
++		/* make the difference positive */
++		diff = reqbuff->count - numbuffers;
++		buf_ptr = buf_ptr + numbuffers;
++		for (buf_index = numbuffers; buf_index < reqbuff->count;
++		     buf_index++) {
++
++			/* assign memory to buffer */
++			*buf_ptr =
++			    (int)(__get_free_pages
++				  (GFP_KERNEL | GFP_DMA,
++				   get_order(reqbuff->size)));
++
++			if (!(*buf_ptr)) {
++
++				buf_ptr = (buf_ptr - (buf_index - numbuffers));
++
++				for (free_index = numbuffers;
++				     free_index < buf_index; free_index++) {
++
++					rsz_free_pages(*buf_ptr, *buf_size);
++					buf_ptr++;
++
++				}
++				dev_dbg(rsz_device,
++					"requestbuffer:not enough memory");
++				return -ENOMEM;
++			}
++
++			adr = *buf_ptr;
++			size = PAGE_SIZE << (get_order(reqbuff->size));
++			while (size > 0) {
++				/* make sure the frame buffers
++				   are never swapped out of     memory */
++				SetPageReserved(virt_to_page(adr));
++				adr += PAGE_SIZE;
++				size -= PAGE_SIZE;
++			}
++
++			buf_ptr++;
++		}
++	}
++
++	/* set the buffer size to requested size */
++	/* this will be useful only when numbuffers = 0 */
++	*buf_size = reqbuff->size;
++
++	dev_dbg(rsz_device, "%s L\n", __FUNCTION__);
++
++	return SUCESS;
++}				/*     end     of function     Main_buff */
++
++/*====================get_buf_address===========================*/
++/* Function to query the  physical address of the buffer  requested by index*/
++
++int get_buf_address(struct rsz_buffer_t *buffer,
++					struct channel_config_t *rsz_conf_chan)
++{
++	int buffer_index = 0;
++
++	dev_dbg(rsz_device, "%s E\n", __FUNCTION__);
++
++	if (buffer == NULL)
++		return -EINVAL;
++
++	if (buffer->buf_type == RSZ_BUF_IN) {
++
++		/* Check the request for number of input buffers */
++		if (buffer->index > MAX_INPUT_BUFFERS)
++			return -EINVAL;
++		/*count number of input buffer allocated */
++		while ((rsz_conf_chan->input_buffer[buffer_index] != NULL)
++		       && (buffer_index < MAX_INPUT_BUFFERS))
++			buffer_index++;
++
++		/*checking the index requested */
++		if (buffer->index >= buffer_index) {
++			dev_dbg(rsz_device,
++				"Requested buffer not allocated \n");
++			return -EINVAL;
++		}
++
++		/* assignning the  input address to offset which will be
++		   used in mmap */
++		buffer->offset =
++		    ((int)(rsz_conf_chan->input_buffer[buffer->index]));
++		dev_dbg(rsz_device, "The query input offset is %x",
++			buffer->offset);
++
++	}
++
++	else if (buffer->buf_type == RSZ_BUF_OUT) {
++
++		/* Check the request for number of output buffers */
++		if (buffer->index > MAX_OUTPUT_BUFFERS)
++			return -EINVAL;
++
++		/* counting     number of output buffers */
++		while ((rsz_conf_chan->output_buffer[buffer_index] != NULL)
++		       && (buffer_index < MAX_OUTPUT_BUFFERS))
++			buffer_index++;
++
++		/* checking the index requested */
++		if (buffer->index >= buffer_index) {
++			dev_dbg(rsz_device,
++				"Requested buffer not allocated \n");
++			return -EINVAL;
++		}
++
++		/* assignning the output address to offset which will be
++		   used in mmap */
++		buffer->offset =
++		    ((int)(rsz_conf_chan->output_buffer[buffer->index]));
++
++		dev_dbg(rsz_device, "The query output offset is %x",
++			buffer->offset);
++
++	} else {
++		dev_dbg(rsz_device, "	Invalid	input type \n");
++		return -EINVAL;
++	}
++
++	/* look up physical     address of the buffer */
++	buffer->offset = virt_to_phys((void *)buffer->offset);
++	dev_dbg(rsz_device, "the physical offset returned after query \
++						is %x", buffer->offset);
++
++	dev_dbg(rsz_device, "%s L\n", __FUNCTION__);
++
++	return SUCESS;
++
++}				/*End of function      getBufferAddress */
++
++/*
++=====================rsz_start===========================
++ This function enable the resize bit after doing the hardware register
++ configuration after which resizing	will be	carried	on.
++*/
++int rsz_start(struct rsz_resize_t *resize,
++			  struct channel_config_t *rsz_conf_chan)
++{
++
++	/* Holds the input address to the resizer */
++	int in_address;
++	/* Holds the output     address to resizer */
++	int out_address;
++	/* Conatains the input put and output buffer allocated size */
++	int out_bufsize, in_bufsize;
++
++	/* Conatins the pitch and vertical size of input and output image */
++	int in_vsize, in_pitch, out_vsize, out_pitch;
++	/* holds the return value; */
++	int ret;
++	/* For calculating the number of input buffers allocated */
++	int buffer_in_index = ZERO;
++
++	/* For calculating the number of output buffers allocated */
++	int buffer_out_index = ZERO;
++
++	dev_dbg(rsz_device, "%s E\n", __FUNCTION__);
++	/* checking     the     configuartion status */
++	if (rsz_conf_chan->config_state) {
++		dev_dbg(rsz_device, "State not configured \n");
++		return -EINVAL;
++	}
++
++	/* Taking the inpitch of the image */
++	in_pitch =
++	    rsz_conf_chan->register_config.rsz_sdr_inoff
++	    & ~(RSZ_SDR_INOFF_OFFSET_MASK);
++	/* Taking the out pitch of image */
++	in_vsize =
++	    ((rsz_conf_chan->register_config.rsz_in_size
++	      & ~(RSZ_IN_SIZE_VERT_MASK)) >> RSZ_IN_SIZE_VERT_SHIFT);
++
++	in_bufsize = in_vsize * in_pitch;
++
++	/*getting the outpitch */
++	out_pitch =
++	    rsz_conf_chan->register_config.rsz_sdr_outoff
++	    & ~(RSZ_SDR_OUTOFF_OFFSET_MASK);
++	/* getting the vertical size  */
++	out_vsize =
++	    ((rsz_conf_chan->register_config.rsz_out_size
++	      & ~(RSZ_OUT_SIZE_VERT_MASK)) >> RSZ_OUT_VSIZE_SHIFT);
++
++	out_bufsize = out_vsize * out_pitch;
++
++	if (resize->in_buf.index < ZERO) {
++		/* assignning the address to the register configuration */
++		if (resize->in_buf.size >= in_bufsize) {
++			if (resize->in_buf.offset % 32)
++				return -EINVAL;
++
++			rsz_conf_chan->register_config.rsz_sdr_inadd =
++			    resize->in_buf.offset;
++		} else {
++			dev_err(rsz_device, " invalid size \n");
++			return -EINVAL;
++		}
++	} else {
++		if (resize->in_buf.index > MAX_INPUT_BUFFERS)
++			return -EINVAL;
++		/*count number of input buffer allocated */
++		while ((rsz_conf_chan->input_buffer[buffer_in_index] !=
++			NULL) && (buffer_in_index < MAX_INPUT_BUFFERS))
++			buffer_in_index++;
++
++		/*checking the index requested */
++		if (resize->in_buf.index >= buffer_in_index) {
++			dev_dbg(rsz_device,
++				"Requested buffer not allocated \n");
++			return -EINVAL;
++		}
++
++		in_address = virt_to_phys(((void *)
++					   rsz_conf_chan->
++					   input_buffer[resize->in_buf.index]));
++
++		rsz_conf_chan->register_config.rsz_sdr_inadd = in_address;
++	}
++
++	if (resize->out_buf.index < ZERO) {
++		if (resize->out_buf.size >= out_bufsize) {
++			if (resize->out_buf.offset % 32)
++				return -EINVAL;
++
++			rsz_conf_chan->register_config.rsz_sdr_outadd =
++			    resize->out_buf.offset;
++		} else {
++			dev_err(rsz_device, "Invalid	output size \n");
++			return -EINVAL;
++		}
++	} else {
++		if (resize->out_buf.index > MAX_OUTPUT_BUFFERS)
++			return -EINVAL;
++		/*count number of input buffer allocated */
++		while ((rsz_conf_chan->output_buffer[buffer_out_index] !=
++			NULL) && (buffer_out_index < MAX_OUTPUT_BUFFERS))
++			buffer_out_index++;
++
++		/*checking the index requested */
++		if (resize->out_buf.index >= buffer_out_index) {
++			dev_dbg(rsz_device,
++				"Requested buffer not allocated \n");
++			return -EINVAL;
++		}
++		out_address = virt_to_phys(((void *)
++					    (rsz_conf_chan->
++					     output_buffer[resize->out_buf.
++							   index])));
++		rsz_conf_chan->register_config.rsz_sdr_outadd = out_address;
++	}
++
++	/* Channel is busy */
++	dev_dbg(rsz_device, "\nThe physical add in rsz start is %x \n",
++		rsz_conf_chan->register_config.rsz_sdr_inadd);
++
++	rsz_conf_chan->status = CHANNEL_BUSY;
++
++	/* Function call to add the entry of application in array */
++	ret = add_to_array(rsz_conf_chan);
++
++	/*Function call to set up the hardware */
++	rsz_hardware_setup(rsz_conf_chan);
++
++	dev_dbg(rsz_device, "After Hardware Setup PCR = %x", regr(PCR));
++
++	/* Initialize the interrupt ISR to ZER0 */
++	device_config.sem_isr.done = ZERO;
++	/*Function call to enable resizer hardware */
++	ret = rsz_enable(rsz_conf_chan);
++
++	dev_dbg(rsz_device, "After ENABLE PCR = %x", regr(PCR));
++
++	/* Waiting for resizing to be complete */
++	wait_for_completion_interruptible(&(device_config.sem_isr));
++
++	rsz_conf_chan->status = CHANNEL_FREE;
++
++	if (rsz_writebuffer_status() != 0)
++		dev_err(rsz_device, "Error: Resizer write buffer overflow: \n");
++
++	delete_from_array(rsz_conf_chan);
++
++	dev_dbg(rsz_device, "%s L\n", __FUNCTION__);
++
++	return ret;
++}				/*End of function Start_Resize */
++
++/*
++=====================add_to_array===========================
++ Function to add the current channel configuration into	array
++according to priority.
++*/
++int add_to_array(struct channel_config_t *rsz_conf_chan)
++{
++	int array_index, device_index;
++
++	dev_dbg(rsz_device, "%s E\n", __FUNCTION__);
++
++	/* locking the configuartion aaray */
++	down_interruptible(&device_config.array_sem);
++
++	/* Add configuration to the     queue according to its priority */
++	if (device_config.array_count == EMPTY) {
++		/* If array     empty insert at top     position */
++		dev_dbg(rsz_device, "First request for resizing \n");
++		device_config.channel_configuration[device_config.array_count]
++		    = rsz_conf_chan;
++	} else {
++		/* Check the priority and insert according to the priority */
++		/* it will start from first     index */
++		for (array_index = SECONDENTRY;
++		     array_index < device_config.array_count; array_index++) {
++			if (device_config.
++			    channel_configuration[array_index]->priority <
++			    rsz_conf_chan->priority)
++				break;
++		}
++		/* Shift all the elements one step down in array */
++		/* IF firstelement and second have same prioroty than insert */
++		/* below first */
++		for (device_index = device_config.array_count;
++		     device_index > array_index; device_index--)
++			device_config.channel_configuration[device_index] =
++			    device_config.
++			    channel_configuration[device_index - NEXT];
++
++		device_config.channel_configuration[array_index] =
++		    rsz_conf_chan;
++	}
++
++	/* incrementing number of requests for resizing */
++	device_config.array_count++;
++	dev_dbg(rsz_device, "The total request for resizing are %d",
++		device_config.array_count);
++
++	if (device_config.array_count != SECONDENTRY) {
++		up(&device_config.array_sem);
++
++		/* if the request is pending that lock the request */
++#ifdef CONFIG_PREEMPT_RT
++		wait_for_completion_interruptible
++		    (&(rsz_conf_chan->channel_sem));
++#else
++		down_interruptible(&(rsz_conf_chan->channel_sem));
++#endif
++
++	} else {
++		up(&device_config.array_sem);
++	}
++
++	dev_dbg(rsz_device, "%s L\n", __FUNCTION__);
++
++	return SUCESS;
++}				/*  end of function addToarray */
++
++/*
++=====================delete_from_array===========================
++ Function	to delete the processed	array entry	form the array
++*/
++int delete_from_array(struct channel_config_t *rsz_conf_chan)
++{
++	int array_index = FIRSTENTRY, device_index;
++
++	dev_dbg(rsz_device, "%s E\n", __FUNCTION__);
++
++	down_interruptible(&(device_config.array_sem));
++
++	/*shift the     entried in array */
++	if (device_config.array_count != SECONDENTRY) {
++		/* decrementing the     request count */
++		device_config.array_count--;
++
++		/* Shift all the elements one step up in array */
++		for (device_index = array_index;
++		     device_index < device_config.array_count; device_index++)
++
++			device_config.channel_configuration[device_index] =
++			    device_config.
++			    channel_configuration[device_index + NEXT];
++
++		/* making last entry NULL; */
++		device_config.channel_configuration[device_index + NEXT] = NULL;
++	}
++	/* remove the top entry */
++	else {
++		dev_dbg(rsz_device, "\n Removing the first request");
++		device_config.array_count--;
++		device_config.channel_configuration[FIRSTENTRY] = NULL;
++	}
++
++	if (device_config.array_count != FIRSTENTRY) {
++		/* Get config having highest priority in array
++		   resizer_device.config
++		   and unlock config.sem of that config */
++
++		dev_dbg(rsz_device,
++			"Releasing array lock of the	second entry\n");
++#ifdef CONFIG_PREEMPT_RT
++		complete(&(device_config.channel_configuration
++			   [FIRSTENTRY]->channel_sem));
++#else
++		up(&(device_config.channel_configuration
++		     [FIRSTENTRY]->channel_sem));
++#endif
++		up(&(device_config.array_sem));
++	} else {
++		dev_dbg(rsz_device, "Releasing array lock	\n");
++		up(&(device_config.array_sem));
++	}
++
++	dev_dbg(rsz_device, "%s L\n", __FUNCTION__);
++
++	return SUCESS;
++}		/* end of function deleteFromarray */
++
++int rsz_set_params(struct rsz_params_t *params,
++				   struct channel_config_t *rsz_conf_chan)
++{
++	int coeffcounter;
++	int hrsz = ZERO;
++	int vrsz = ZERO;
++	int alignment = ZERO;
++	int hsize;
++	int vsize;
++
++	dev_dbg(rsz_device, "%s E\n", __FUNCTION__);
++
++	/* calculating the horizontal and vertical ratio */
++	vrsz = (params->in_vsize - NUM_D2TAPS) * RATIO_MULTIPLIER /
++	    (params->out_vsize - 1);
++	hrsz = ((params->in_hsize - NUM_D2TAPS) * RATIO_MULTIPLIER) /
++	    (params->out_hsize - 1);
++
++	/* recalculating Horizontal     ratio */
++	if (hrsz <= DOWN_RSZ_RATIO) {	/* 4-tap     8-phase filter */
++		hrsz = (params->in_hsize - NUM_TAPS) * RATIO_MULTIPLIER
++		    / (params->out_hsize - 1);
++		if (hrsz > DOWN_RSZ_RATIO)
++			hrsz = DOWN_RSZ_RATIO;
++		if (params->hstph > NUM_PHASES)
++			return -EINVAL;
++	} else if (hrsz >= UP_RSZ_RATIO1 && hrsz <= DOWN_RSZ_RATIO1) {
++		/* 7-tap        4-phase filter */
++		if (params->hstph > NUM_D2PH)
++			return -EINVAL;
++	}
++
++	/* recalculating vertical ratio */
++	if (vrsz <= DOWN_RSZ_RATIO) {	/* 4-tap     8-phase filter */
++		vrsz = (params->in_vsize - NUM_TAPS) * RATIO_MULTIPLIER /
++		    (params->out_vsize - 1);
++		if (vrsz > DOWN_RSZ_RATIO)
++			vrsz = DOWN_RSZ_RATIO;
++		if (params->vstph > NUM_PHASES)
++			return -EINVAL;
++	} else if (vrsz >= UP_RSZ_RATIO1 && vrsz <= DOWN_RSZ_RATIO1) {
++		if (params->vstph > NUM_D2PH)
++			return -EINVAL;
++	}
++
++	/* Fiiling the input pitch in the structure */
++	if ((params->in_pitch) % ALIGN32) {
++		dev_err(rsz_device, "Inavlid input pitch	%d \n",
++			params->in_pitch);
++		return -EINVAL;
++	}
++	rsz_conf_chan->register_config.rsz_sdr_inoff =
++	    ((params->in_pitch) & ~(RSZ_SDR_INOFF_OFFSET_MASK));
++
++	/* If vertical upsizing then */
++	if (vrsz < 256) {
++		/* checking     for     both types of format */
++		if (params->inptyp == RSZ_INTYPE_PLANAR_8BIT) {
++			alignment = ALIGNMENT;
++		} else if (params->inptyp == RSZ_INTYPE_YCBCR422_16BIT) {
++			alignment = (ALIGNMENT / 2);
++		} else {
++			dev_err(rsz_device, "Invalid input type	\n");
++		}
++		/* errror checking for output size */
++		if (!(((params->out_hsize % PIXEL_EVEN) == ZERO)
++		      && (params->out_hsize % alignment) == ZERO)) {
++			dev_err(rsz_device, "wrong hsize	\n");
++
++			return -EINVAL;
++		}
++	}
++	if (hrsz >= UP_RSZ_RATIO && hrsz <= DOWN_RSZ_RATIO) {
++		if (params->out_hsize > MAX_IMAGE_WIDTH) {
++			dev_err(rsz_device, "wrong width	\n");
++			return -EINVAL;
++		}
++
++	} else if (hrsz >= UP_RSZ_RATIO1 && hrsz <= DOWN_RSZ_RATIO1) {
++		if (params->out_hsize > MAX_IMAGE_WIDTH_HIGH) {
++			dev_err(rsz_device, "wrong width	\n");
++			return -EINVAL;
++		}
++	} else {
++		dev_err(rsz_device,
++			"horizontal scaling ratio invalid: %d, %d, %dn",
++			hrsz, params->in_hsize, params->out_hsize);
++		return -EINVAL;
++	}
++	if (vrsz < UP_RSZ_RATIO || vrsz > DOWN_RSZ_RATIO1) {
++		dev_err(rsz_device, "vertical scaling ratio invalid:%d,%d,%d\n",
++			vrsz, params->in_vsize, params->out_vsize);
++		return -EINVAL;
++	}
++	rsz_conf_chan->register_config.rsz_out_size =
++	    (params->out_hsize & ~(RSZ_OUT_SIZE_HORZ_MASK));
++
++	rsz_conf_chan->register_config.rsz_out_size |=
++	    ((params->out_vsize << RSZ_OUT_VSIZE_SHIFT) &
++	     ~(RSZ_OUT_SIZE_VERT_MASK));
++
++	dev_dbg(rsz_device, "The	outpitch in driver is %d",
++		params->out_pitch);
++	if ((params->out_pitch) % ALIGN32) {
++		dev_err(rsz_device, "Inavlid	output pitch \n");
++		return -EINVAL;
++	}
++	rsz_conf_chan->register_config.rsz_sdr_outoff =
++	    params->out_pitch & ~(RSZ_SDR_OUTOFF_OFFSET_MASK);
++
++	rsz_conf_chan->register_config.rsz_cnt = 0;
++	/* clear the rsz_cnt register */
++
++	/* Configuring the chrominance algorithm */
++	if (params->cbilin) {
++		rsz_conf_chan->register_config.rsz_cnt =
++		    BITSET(rsz_conf_chan->register_config.rsz_cnt,
++			   SET_BIT_CBLIN);
++		dev_dbg(rsz_device, "Setting chrominance algorithm bit \n");
++	}
++
++	/* Configuring the input source */
++	if (INPUT_RAM) {
++		dev_dbg(rsz_device, "Setting Input source as Ram \n");
++		rsz_conf_chan->register_config.rsz_cnt =
++		    BITSET(rsz_conf_chan->register_config.rsz_cnt,
++			   SET_BIT_INPUTRAM);
++	}
++	/* Configuring the input type */
++	if (params->inptyp == RSZ_INTYPE_PLANAR_8BIT) {
++		dev_dbg(rsz_device, "Setting pic format as 8 bit planar \n");
++		rsz_conf_chan->register_config.rsz_cnt =
++		    BITSET(rsz_conf_chan->register_config.rsz_cnt,
++			   SET_BIT_INPTYP);
++	} else {
++		dev_dbg(rsz_device,
++			"Setting pic format as 16 bit color seperated\n");
++		rsz_conf_chan->register_config.rsz_cnt =
++		    BITRESET(rsz_conf_chan->register_config.rsz_cnt,
++			     SET_BIT_INPTYP);
++
++		/* Configuring the chrominace position type */
++		if (params->pix_fmt == RSZ_PIX_FMT_UYVY) {
++
++			rsz_conf_chan->register_config.rsz_cnt =
++			    BITSET(rsz_conf_chan->register_config.rsz_cnt,
++				   SET_BIT_YCPOS);
++		} else if (params->pix_fmt == RSZ_PIX_FMT_YUYV) {
++			rsz_conf_chan->register_config.rsz_cnt =
++			    BITRESET(rsz_conf_chan->register_config.rsz_cnt,
++				     SET_BIT_YCPOS);
++		}
++
++	}
++
++	/* checking the validity of the horizontal phase value */
++	if (hrsz >= UP_RSZ_RATIO && hrsz <= DOWN_RSZ_RATIO) {
++		if (params->hstph > NUM_PHASES)
++			return -EINVAL;
++	} else if (hrsz >= UP_RSZ_RATIO && hrsz <= DOWN_RSZ_RATIO) {
++		if (params->hstph > NUM_D2PH)
++			return -EINVAL;
++	}
++
++	rsz_conf_chan->register_config.rsz_cnt |=
++	    ((params->hstph << RSZ_HSTP_SHIFT) & ~(RSZ_HSTPH_MASK));
++
++	/* checking     the     validity of     the     vertical phase value */
++	if (vrsz >= UP_RSZ_RATIO && hrsz <= DOWN_RSZ_RATIO) {
++		if (params->vstph > NUM_PHASES)
++			return -EINVAL;
++	} else if (vrsz >= UP_RSZ_RATIO && vrsz <= DOWN_RSZ_RATIO) {
++		if (params->vstph > NUM_D2PH)
++			return -EINVAL;
++	}
++
++	rsz_conf_chan->register_config.rsz_cnt |=
++	    ((params->vstph << RSZ_VSTPH_SHIFT) & ~(RSZ_VSTPH_MASK));
++
++	/* if input is from ram that vertical pixel should be zero */
++	if (INPUT_RAM)
++		params->vert_starting_pixel = ZERO;
++
++	/* Configuring the starting pixel in vertical direction */
++	rsz_conf_chan->register_config.rsz_in_start =
++	    (params->vert_starting_pixel << RSZ_IN_SIZE_VERT_SHIFT)
++	    & ~(RSZ_IN_START_VERT_ST_MASK);
++
++	/* if input is 8 bit that start pixel should be <= to than 31 */
++	if (params->inptyp == RSZ_INTYPE_PLANAR_8BIT) {
++		if (params->horz_starting_pixel > MAX_HORZ_PIXEL_8BIT)
++			return -EINVAL;
++	}
++	/* if input     is 16 bit that start pixel should be <= than 15 */
++	if (params->inptyp == RSZ_INTYPE_YCBCR422_16BIT) {
++		if (params->horz_starting_pixel > MAX_HORZ_PIXEL_16BIT)
++			return -EINVAL;
++	}
++
++	/* Configuring the      starting pixel in horizontal direction */
++	rsz_conf_chan->register_config.rsz_in_start |=
++	    params->horz_starting_pixel & ~(RSZ_IN_START_HORZ_ST_MASK);
++
++	for (coeffcounter = ZERO; coeffcounter < MAX_COEF_COUNTER;
++	     coeffcounter++) {
++		/* Configuration of     horizontal coefficients */
++		rsz_conf_chan->register_config.
++		    rsz_coeff_horz[coeffcounter] =
++		    (params->hfilt_coeffs[2 * coeffcounter]
++		     & ~(RSZ_FILTER_COEFF0_MASK));
++
++		/* Configuration of     horizontal coefficients */
++
++		rsz_conf_chan->register_config.
++		    rsz_coeff_horz[coeffcounter] |=
++		    ((params->hfilt_coeffs[2 * coeffcounter + NEXT]
++		      << RSZ_FILTER_COEFF_SHIFT) & ~(RSZ_FILTER_COEFF1_MASK));
++
++		/* Configuration of     Vertical coefficients */
++		rsz_conf_chan->register_config.
++		    rsz_coeff_vert[coeffcounter] =
++		    (params->
++		     vfilt_coeffs[2 *
++				  coeffcounter] & ~(RSZ_FILTER_COEFF0_MASK));
++
++		/* Configuration of Vertical coefficients */
++
++		rsz_conf_chan->register_config.
++		    rsz_coeff_vert[coeffcounter] |=
++		    ((params->
++		      vfilt_coeffs[2 * coeffcounter +
++				   NEXT] << RSZ_FILTER_COEFF_SHIFT) &
++		     ~(RSZ_FILTER_COEFF1_MASK));
++	}
++	/* Coefficinets of parameters for luma :- algo configuration */
++	rsz_conf_chan->register_config.rsz_yehn =
++	    ((params->yenh_params.type << RSZ_YENH_TYPE_SHIFT) &
++	     ~(RSZ_YEHN_ALGO_MASK));
++
++	/* Coefficinets of parameters for luma :- core configuration */
++	if (params->yenh_params.type) {
++		rsz_conf_chan->register_config.rsz_yehn |=
++		    params->yenh_params.core & ~(RSZ_YEHN_CORE_MASK);
++
++		/* Coefficinets of parameters for luma :- gain configuration */
++
++		rsz_conf_chan->register_config.rsz_yehn |=
++		    ((params->yenh_params.gain << RSZ_YENH_GAIN_SHIFT)
++		     & ~(RSZ_YEHN_GAIN_MASK));
++
++		/* Coefficinets of parameters for luma :- gain configuration */
++		rsz_conf_chan->register_config.rsz_yehn |=
++		    ((params->yenh_params.slop << RSZ_YENH_SLOP_SHIFT)
++		     & ~(RSZ_YEHN_SLOP_MASK));
++	}
++
++	/* Configuring the horizonatl ratio */
++	rsz_conf_chan->register_config.rsz_cnt |= ((hrsz - 1) & ~RSZ_HRSZ_MASK);
++
++	/* Configuring the vertical     ratio */
++	rsz_conf_chan->register_config.rsz_cnt |=
++	    (((vrsz - 1) << RSZ_VRSZ_SHIFT) & ~RSZ_VRSZ_MASK);
++
++	if (hrsz <= 512) {	/*4-tap filter */
++		hsize =
++		    ((32 * params->hstph + (params->out_hsize - 1) * hrsz +
++		      16) >> 8) + 7;
++	} else {
++		hsize =
++		    ((64 * params->hstph + (params->out_hsize - 1) * hrsz +
++		      32) >> 8) + 7;
++	}
++	dev_dbg(rsz_device, "hsize = %d\n", hsize);
++	if (vrsz <= 512) {	/*4-tap filter */
++		vsize =
++		    ((32 * params->vstph + (params->out_vsize - 1) * vrsz +
++		      16) >> 8) + 4;
++	} else {
++		vsize =
++		    ((64 * params->vstph + (params->out_vsize - 1) * vrsz +
++		      32) >> 8) + 7;
++	}
++	dev_dbg(rsz_device, "vsize = %d\n", vsize);
++	dev_dbg(rsz_device, "hrsz	= %d, vrsz = %d,\n", hrsz, vrsz);
++
++	/* Configuring the Horizontal size of inputframn in MMR */
++	rsz_conf_chan->register_config.rsz_in_size = hsize;
++	/*params->in_hsize; */
++
++	rsz_conf_chan->register_config.rsz_in_size |=
++	    ((vsize /*params->in_vsize */  << RSZ_IN_SIZE_VERT_SHIFT)
++	     & ~(RSZ_IN_SIZE_VERT_MASK));
++
++	/*Setting the configuration status */
++	dev_dbg(rsz_device, "Resizer State configured \n");
++	rsz_conf_chan->config_state = STATE_CONFIGURED;
++
++	dev_dbg(rsz_device, "%s L\n", __FUNCTION__);
++
++	return SUCESS;
++}				/*End of rsz_Set_Params */
++
++/* End of rsz_Set_Params*/
++/*
++=====================rsz_Get_Params===========================
++ Function to get the parameters	values
++*/
++int rsz_get_params(struct rsz_params_t *params,
++				   struct channel_config_t *rsz_conf_chan)
++{
++	int coeffcounter;
++
++	dev_dbg(rsz_device, "%s E\n", __FUNCTION__);
++
++	if (rsz_conf_chan->config_state) {
++		dev_dbg(rsz_device, "	state not configured \n");
++		return -EINVAL;
++	}
++
++	/* getting the horizontal size */
++	params->in_hsize =
++	    rsz_conf_chan->register_config.rsz_in_size &
++	    ~(RSZ_IN_SIZE_HORZ_MASK);
++	/* getting the vertical size */
++	params->in_vsize =
++	    ((rsz_conf_chan->register_config.rsz_in_size
++	      & ~(RSZ_IN_SIZE_VERT_MASK)) >> RSZ_IN_SIZE_VERT_SHIFT);
++
++	/* getting the input pitch */
++	params->in_pitch =
++	    rsz_conf_chan->register_config.rsz_sdr_inoff
++	    & ~(RSZ_SDR_INOFF_OFFSET_MASK);
++
++	/* getting the output horizontal size */
++	params->out_hsize =
++	    rsz_conf_chan->register_config.rsz_out_size
++	    & ~(RSZ_OUT_SIZE_HORZ_MASK);
++
++	/* getting the vertical size   */
++	params->out_vsize =
++	    ((rsz_conf_chan->register_config.rsz_out_size
++	      & ~(RSZ_OUT_SIZE_VERT_MASK)) >> RSZ_OUT_VSIZE_SHIFT);
++
++	/* getting the output pitch */
++	params->out_pitch =
++	    rsz_conf_chan->register_config.rsz_sdr_outoff
++	    & ~(RSZ_SDR_OUTOFF_OFFSET_MASK);
++
++	/* getting the chrominance algorithm  */
++	params->cbilin =
++	    ((rsz_conf_chan->register_config.rsz_cnt
++	      & RSZ_CNT_CBILIN_MASK) >> SET_BIT_CBLIN);
++
++	/* getting the input type */
++	params->inptyp =
++	    ((rsz_conf_chan->register_config.rsz_cnt
++	      & RSZ_CNT_INPTYP_MASK) >> SET_BIT_INPTYP);
++	/* getting the  starting pixel in horizontal direction */
++	params->horz_starting_pixel =
++	    ((rsz_conf_chan->register_config.rsz_in_start
++	      & ~(RSZ_IN_START_HORZ_ST_MASK)));
++	/* getting the  starting pixel in vertical direction */
++	params->vert_starting_pixel =
++	    ((rsz_conf_chan->register_config.rsz_in_start
++	      & ~(RSZ_IN_START_VERT_ST_MASK)) >> RSZ_IN_SIZE_VERT_SHIFT);
++
++	/* getting the horizontal starting phase */
++	params->hstph =
++	    ((rsz_conf_chan->register_config.rsz_cnt
++	      & ~(RSZ_HSTPH_MASK) >> RSZ_HSTP_SHIFT));
++
++	/* getting the vertical starting phase */
++	params->vstph =
++	    ((rsz_conf_chan->register_config.rsz_cnt
++	      & ~(RSZ_VSTPH_MASK) >> RSZ_VSTPH_SHIFT));
++
++	for (coeffcounter = ZERO; coeffcounter < MAX_COEF_COUNTER;
++	     coeffcounter++) {
++		/* getting the horizontal coefficients 0 */
++		params->hfilt_coeffs[2 * coeffcounter] =
++		    rsz_conf_chan->register_config.rsz_coeff_horz[coeffcounter]
++		    & ~(RSZ_FILTER_COEFF0_MASK);
++
++		/* getting the horizontal coefficients 1 */
++		params->hfilt_coeffs[2 * coeffcounter + NEXT] =
++		    ((rsz_conf_chan->register_config.
++		      rsz_coeff_horz[coeffcounter]
++		      & ~(RSZ_FILTER_COEFF1_MASK)) >> RSZ_FILTER_COEFF_SHIFT);
++
++		/* getting the vertical coefficients 0 */
++		params->vfilt_coeffs[2 * coeffcounter] =
++		    rsz_conf_chan->register_config.rsz_coeff_vert[coeffcounter]
++		    & ~(RSZ_FILTER_COEFF0_MASK);
++
++		/* getting the vertical coefficients 1 */
++		params->vfilt_coeffs[2 * coeffcounter + NEXT] =
++		    ((rsz_conf_chan->register_config.
++		      rsz_coeff_vert[coeffcounter]
++		      & ~(RSZ_FILTER_COEFF1_MASK)) >> RSZ_FILTER_COEFF_SHIFT);
++
++	}
++
++	/* getting the parameters for luma :- algo */
++	params->yenh_params.type =
++	    ((rsz_conf_chan->register_config.rsz_yehn
++	      & ~(RSZ_YEHN_ALGO_MASK)) >> RSZ_YENH_TYPE_SHIFT);
++
++	/* getting the parameters for luma :- core      */
++	params->yenh_params.core =
++	    (rsz_conf_chan->register_config.rsz_yehn & ~(RSZ_YEHN_CORE_MASK));
++
++	/* Coefficinets of parameters for luma :- gain  */
++	params->yenh_params.gain =
++	    ((rsz_conf_chan->register_config.rsz_yehn
++	      & ~(RSZ_YEHN_GAIN_MASK)) >> RSZ_YENH_GAIN_SHIFT);
++
++	/* Coefficinets of parameters for luma :- SLOP configuration */
++	params->yenh_params.slop =
++	    ((rsz_conf_chan->register_config.rsz_yehn
++	      & ~(RSZ_YEHN_SLOP_MASK)) >> RSZ_YENH_SLOP_SHIFT);
++
++	/* getting the input type */
++	params->pix_fmt =
++	    ((rsz_conf_chan->register_config.rsz_cnt
++	      & RSZ_CNT_PIXFMT_MASK) >> SET_BIT_YCPOS);
++
++	if (params->pix_fmt)
++		params->pix_fmt = RSZ_PIX_FMT_UYVY;
++	else
++		params->pix_fmt = RSZ_PIX_FMT_YUYV;
++
++	dev_dbg(rsz_device, "%s L\n", __FUNCTION__);
++	return SUCESS;
++}
++
++void rsz_calculate_crop(struct channel_config_t *rsz_conf_chan,
++			struct rsz_cropsize_t *cropsize)
++{
++	int luma_enable;
++	dev_dbg(rsz_device, "%s E\n", __FUNCTION__);
++
++	cropsize->hcrop = ZERO;
++	cropsize->vcrop = ZERO;
++
++	luma_enable =
++	    ((rsz_conf_chan->register_config.rsz_yehn
++	      & ~(RSZ_YEHN_ALGO_MASK)) >> RSZ_YENH_TYPE_SHIFT);
++
++	/* Luma enhancement reduces image width 1 pixels from left,right */
++	if (luma_enable)
++		cropsize->hcrop += 2;
++
++	dev_dbg(rsz_device, "%s L\n", __FUNCTION__);
++}
++
++/*
++=====================free_buff===========================
++ this	function free the input	and output buffers alloated
++*/
++int free_buff(struct channel_config_t *rsz_conf_chan)
++{
++	int buffercounter = ZERO;
++
++	dev_dbg(rsz_device, "%s E\n", __FUNCTION__);
++
++	/* Free all     the     input buffers */
++	while (rsz_conf_chan->input_buffer[buffercounter] != NULL
++	       && buffercounter < MAX_INPUT_BUFFERS) {
++		/* free the     memory */
++		rsz_free_pages((unsigned long)rsz_conf_chan->input_buffer
++			       [buffercounter], rsz_conf_chan->in_bufsize);
++		/* assign buffer zero to indicate its free */
++		rsz_conf_chan->input_buffer[buffercounter] = NULL;
++		buffercounter++;
++	}
++	buffercounter = ZERO;
++	/* free all the output buffers */
++	while (rsz_conf_chan->output_buffer[buffercounter] != NULL
++	       && buffercounter < MAX_INPUT_BUFFERS) {
++		/* free the memory */
++		rsz_free_pages((unsigned long)rsz_conf_chan->output_buffer
++			       [buffercounter], rsz_conf_chan->out_bufsize);
++		/*  assign buffer zero to indicate its  free */
++		rsz_conf_chan->output_buffer[buffercounter] = NULL;
++		buffercounter++;
++	}
++
++	dev_dbg(rsz_device, "%s L\n", __FUNCTION__);
++
++	return SUCESS;
++}
++
++/*
++=====================rsz_open===========================
++This function creates a channels.
++*/
++static int rsz_open(struct inode *inode, struct file *filp)
++{
++	struct channel_config_t *rsz_conf_chan;
++	int buffercounter;
++
++	dev_dbg(rsz_device, "%s E\n", __FUNCTION__);
++
++	if (filp->f_flags == O_NONBLOCK)
++		return -1;
++	/* if usage counter is greater than maximum supported channels
++	   return error */
++	if (device_config.module_usage_count >= MAX_CHANNELS) {
++		dev_err(rsz_device,
++			"\n modules usage count is greater than supported ");
++		return -EBUSY;
++	}
++
++	/* allocate     memory for a new configuration */
++	rsz_conf_chan = kmalloc(sizeof(struct channel_config_t), GFP_KERNEL);
++
++	if (rsz_conf_chan == NULL) {
++		dev_err(rsz_device,
++			"\n cannot allocate memory ro channel config");
++		return -ENOMEM;
++	}
++
++	dev_dbg(rsz_device,
++		"Malloc Done for channel configuration structure\n");
++
++	/* zeroing register     config */
++	memset(&(rsz_conf_chan->register_config), ZERO,
++	       sizeof(struct resizer_config_t));
++
++	/* increment usage counter */
++	/* Lock the     global variable and increment the counter */
++	down_interruptible(&device_config.device_mutex);
++	device_config.module_usage_count++;
++	up(&device_config.device_mutex);
++
++	/*STATE_NOT_CONFIGURED and priority to zero */
++	rsz_conf_chan->config_state = STATE_NOT_CONFIGURED;
++
++	/* Set priority to lowest for that configuration channel */
++	rsz_conf_chan->priority = MIN_PRIORITY;
++
++	rsz_conf_chan->status = CHANNEL_FREE;
++	/*Set configuration     structure's    input_buffer and output_buffer */
++	/*pointers to NULL */
++
++	for (buffercounter = ZERO; buffercounter < MAX_INPUT_BUFFERS;
++		  buffercounter++) {
++		/* Help to initialize the input buffer to zero */
++		rsz_conf_chan->input_buffer[buffercounter] = NULL;
++	}
++
++	for (buffercounter = ZERO; buffercounter < MAX_OUTPUT_BUFFERS;
++	     buffercounter++) {
++		/* Help to initialize the output buffer to zero */
++		rsz_conf_chan->output_buffer[buffercounter] = NULL;
++
++	}
++	dev_dbg(rsz_device, "Initializing	of channel done	\n");
++
++	/* Initializing of application mutex */
++#ifdef CONFIG_PREEMPT_RT
++	init_completion(&(rsz_conf_chan->channel_sem));
++	rsz_conf_chan->channel_sem.done = 0;
++#else
++	init_MUTEX_LOCKED(&(rsz_conf_chan->channel_sem));
++#endif
++	init_MUTEX(&(rsz_conf_chan->chanprotection_sem));
++	/* taking the configuartion     structure in private data */
++	filp->private_data = rsz_conf_chan;
++
++	dev_dbg(rsz_device, "%s L\n", __FUNCTION__);
++
++	return SUCESS;
++
++}				/*     End     of resizer open */
++
++/*
++=====================rsz_release===========================
++ The Function	is used	to release the number of resources occupied
++ by the channel
++*/
++static int rsz_release(struct inode *inode, struct file *filp)
++{
++
++	/* get the configuratin of this channel from private_date member of
++	   file */
++	int ret = 0;
++	struct channel_config_t *rsz_conf_chan =
++	    (struct channel_config_t *) filp->private_data;
++
++	dev_dbg(rsz_device, "%s E\n", __FUNCTION__);
++
++	ret = down_trylock(&(rsz_conf_chan->chanprotection_sem));
++	if (ret != 0) {
++
++		dev_dbg(rsz_device, "Channel in use", ret);
++		return -EBUSY;
++	}
++
++	/* It will free all the input and output buffers */
++	free_buff(rsz_conf_chan);
++
++	/* Decrements the module usage count; */
++	/* Lock the global variable and decrement variable */
++	down_interruptible(&device_config.device_mutex);
++	device_config.module_usage_count--;
++	up(&device_config.device_mutex);
++
++	kfree(rsz_conf_chan);
++
++	dev_dbg(rsz_device, "%s L\n", __FUNCTION__);
++
++	up(&(rsz_conf_chan->chanprotection_sem));
++
++	return SUCESS;
++}				/*  End     of function     resizer_release */
++
++/*
++=====================rsz_mmap===========================
++Function to map device memory into user	space
++ */ static int rsz_mmap(struct file *filp, struct vm_area_struct *vma)
++{
++
++	/* get the configuratin of this channel from private_date
++	   member of file */
++	/* for looping purpuse */
++	int buffercounter = ZERO;
++
++	/* for checking purpose */
++	int flag = ZERO;
++	/* Hold number of input and output buffer allocated */
++	int in_numbuffers = ZERO, out_numbuffers = ZERO;
++	int buffer_offset;
++
++	unsigned int offset = vma->vm_pgoff << PAGE_SHIFT;
++
++	struct channel_config_t *rsz_conf_chan =
++	    (struct channel_config_t *) filp->private_data;
++
++	dev_dbg(rsz_device, "%s E\n", __FUNCTION__);
++
++	/* Count the number of input buffers allocated */
++	while ((rsz_conf_chan->input_buffer[buffercounter]) != NULL) {
++		in_numbuffers++;
++		buffercounter++;
++	}
++	buffercounter = ZERO;
++
++	/* To Count the number of output buffers allocated */
++	while ((rsz_conf_chan->output_buffer[buffercounter]) != NULL) {
++		out_numbuffers++;
++		buffercounter++;
++	}
++
++	/*Find the input address which  is to be mapped */
++	for (buffercounter = ZERO; buffercounter < in_numbuffers;
++	     buffercounter++) {
++		buffer_offset =
++		    virt_to_phys(rsz_conf_chan->input_buffer[buffercounter]);
++		if (buffer_offset == offset) {
++			flag = ADDRESS_FOUND;
++			break;
++		}
++	}
++	/*Find the output address which is to be mapped */
++	if (flag == ZERO) {
++		for (buffercounter = ZERO; buffercounter < out_numbuffers;
++		     buffercounter++) {
++			buffer_offset =
++			    virt_to_phys(rsz_conf_chan->
++					 output_buffer[buffercounter]);
++			if (buffer_offset == offset) {
++				flag = ADDRESS_FOUND;
++				break;
++			}
++		}
++	}
++	/* The address to be mapped     is not found so return error */
++
++	if (flag == ZERO)
++		return -EAGAIN;
++
++	dev_dbg(rsz_device, "The address mapped via mmap");
++	/* map the address from user space to kernel space */
++	if (remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff,
++			    vma->vm_end - vma->vm_start, vma->vm_page_prot))
++		return -EAGAIN;
++
++	dev_dbg(rsz_device, "%s L\n", __FUNCTION__);
++
++	return SUCESS;
++
++}				/*     End     of Function     resizer_mmap */
++
++/*
++=====================rsz_ioctl===========================
++This function	will process IOCTL commands sent by
++the application	and
++control the device IO operations.
++*/
++static int rsz_ioctl(struct inode *inode, struct file *file,
++		     unsigned int cmd, unsigned long arg)
++{
++	int ret = ZERO;
++	/*get the configuratin of this channel from
++	   private_date member of file */
++	struct channel_config_t *rsz_conf_chan =
++	    (struct channel_config_t *) file->private_data;
++
++	/* Create the structures of
++	   different parameters passed by user */
++	struct rsz_priority_t *prio;
++	struct rsz_status_t *status;
++	struct rsz_resize_t *resize;
++
++	dev_dbg(rsz_device, "%s E\n", __FUNCTION__);
++
++	ret = down_trylock(&(rsz_conf_chan->chanprotection_sem));
++	if (ret != 0) {
++
++		dev_dbg(rsz_device, "Channel in use %i", ret);
++		return -EBUSY;
++	}
++
++	/* Before decoding check for correctness of cmd */
++	if (_IOC_TYPE(cmd) != RSZ_IOC_BASE) {
++		dev_err(rsz_device, "Bad	command	Value \n");
++		return -1;
++	}
++	if (_IOC_NR(cmd) > RSZ_IOC_MAXNR) {
++		dev_err(rsz_device, "Bad	command	Value\n");
++		return -1;
++	}
++
++	/*veryfying     access permission of commands */
++	if (_IOC_DIR(cmd) & _IOC_READ)
++		ret = !access_ok(VERIFY_WRITE, (void *)arg, _IOC_SIZE(cmd));
++	else if (_IOC_DIR(cmd) & _IOC_WRITE)
++		ret = !access_ok(VERIFY_READ, (void *)arg, _IOC_SIZE(cmd));
++	if (ret) {
++		dev_err(rsz_device, "access denied\n");
++		return -1;	/*error in access */
++	}
++
++	/* switch according     value of cmd */
++	switch (cmd) {
++		/*This ioctl is used to request frame buffers to be
++		   allocated by the RSZ module. The allocated buffers
++		   are channel  specific and can be     addressed
++		   by indexing */
++	case RSZ_REQBUF:
++
++		/* Function to allocate the memory to input
++		   or output buffer. */
++		ret = malloc_buff((struct rsz_reqbufs_t *) arg, rsz_conf_chan);
++		break;
++
++		/*This ioctl is used to query the physical address of a
++		   particular frame buffer. */
++	case RSZ_QUERYBUF:
++
++		/* Function     to query the  physical address of
++		   the buffer  requested by index. */
++		ret = get_buf_address((struct rsz_buffer_t *) arg,
++							  rsz_conf_chan);
++		break;
++
++		/* This ioctl is used to set the priority of the current
++		   logical channel. If multiple resizing     tasks from multiple
++		   logical channels are currently *pending, the task
++		   associated with the  highest priority logical channel
++		   will be executed first. */
++	case RSZ_S_PRIORITY:
++
++		dev_dbg(rsz_device, "\n resizer_Priority:start");
++		prio = (struct rsz_priority_t *) arg;
++		/* Check the prioroty range and assign the priority */
++		if (prio->priority > MAX_PRIORITY ||
++		    prio->priority < MIN_PRIORITY)
++			return -EINVAL;
++		else
++			rsz_conf_chan->priority = prio->priority;
++
++		dev_dbg(rsz_device, "\n resizer_Priority:end");
++		break;
++		/* This ioctl is used to get the priority of
++		   the current logic channel */
++	case RSZ_G_PRIORITY:
++
++		dev_dbg(rsz_device, "\n Get resizer_Priority:start");
++		prio = (struct rsz_priority_t *) arg;
++		/* Get the priority     from the channel */
++		prio->priority = rsz_conf_chan->priority;
++		dev_dbg(rsz_device, "\n Get resizer_Priority:end");
++		break;
++
++		/* This ioctl is used to set the parameters
++		   of the Resizer hardware, including input and output
++		   image size, horizontal    and     vertical poly-phase
++		   filter coefficients,luma enchancement filter coefficients
++		   etc */
++	case RSZ_S_PARAM:
++
++		/* Function to set the hardware configuration */
++		ret = rsz_set_params((struct rsz_params_t *) arg,
++							 rsz_conf_chan);
++		break;
++
++		/*This ioctl is used to get the Resizer hardware settings
++		   associated with the current logical channel represented
++		   by fd. */
++	case RSZ_G_PARAM:
++		/* Function to get the hardware configuration */
++		ret = rsz_get_params((struct rsz_params_t *) arg,
++							 rsz_conf_chan);
++		break;
++
++		/* This ioctl is used to check the current status
++		   of the Resizer hardware */
++	case RSZ_G_STATUS:
++		status = (struct rsz_status_t *) arg;
++		status->chan_busy = rsz_conf_chan->status;
++		status->hw_busy = isbusy();
++		status->src = INPUT_RAM;
++		break;
++
++		/*This ioctl submits a resizing task specified by the
++		   rsz_resize structure.The call can either be blocked until
++		   the task is completed or returned immediately based
++		   on the value of the blocking argument in the rsz_resize
++		   structure. If  it is blocking, the     status of the task
++		   can be checked by calling ioctl   RSZ_G_STATUS. Only one task
++		   can  be outstanding for each logical channel. */
++	case RSZ_RESIZE:
++
++		dev_dbg(rsz_device, "Beofre rsz_resize: PCR =%x", regr(PCR));
++		resize = (struct rsz_resize_t *) arg;
++
++		ret = rsz_start((struct rsz_resize_t *) arg, rsz_conf_chan);
++		break;
++
++	case RSZ_GET_CROPSIZE:
++
++		rsz_calculate_crop(rsz_conf_chan,
++						 (struct rsz_cropsize_t *) arg);
++		break;
++	case RSZ_S_EXP:
++		dev_dbg(rsz_device, "Before rsz_s_exp:SDR_REQ_EXP = %x",
++			regr(SDR_REQ_EXP));
++		rsz_set_exp(*((int *)arg));
++		break;
++
++	default:
++		dev_dbg(rsz_device, "resizer_ioctl: Invalid Command Value");
++		ret = -EINVAL;
++	}
++
++	dev_dbg(rsz_device, "%s L\n", __FUNCTION__);
++	up(&(rsz_conf_chan->chanprotection_sem));
++
++	return ret;
++}				/*End of function IOCTL */
++
++static struct file_operations rsz_fops = {
++	.owner = THIS_MODULE, .open = rsz_open, .release =
++	    rsz_release, .mmap = rsz_mmap, .ioctl = rsz_ioctl,
++};
++
++/*
++=====================rsz_isr===========================
++Function to register the Resizer character device	driver
++*/
++irqreturn_t rsz_isr(int irq, void *dev_id, struct pt_regs *regs)
++{
++
++	dev_dbg(rsz_device, "%s E\n", __FUNCTION__);
++
++	/* to suggest that resizing     has     been completed */
++	complete(&(device_config.sem_isr));
++
++	dev_dbg(rsz_device, "%s L\n", __FUNCTION__);
++
++	return IRQ_HANDLED;
++}
++static void resizer_platform_release(struct device *device)
++{
++	/* This is called when the reference count goes to zero */
++}
++static int __init resizer_probe(struct device *device)
++{
++	rsz_device = device;
++	return 0;
++}
++static int resizer_remove(struct device *device)
++{
++	return 0;
++}
++static struct class *rsz_class;
++
++static struct platform_device resizer_device = {
++	.name = "davinci_resizer", .id = 2, .dev = {
++						  .release =
++						  resizer_platform_release,}
++};
++
++static struct device_driver resizer_driver = {
++	.name = "davinci_resizer",
++	.bus = &platform_bus_type,
++	.probe = resizer_probe,
++	.remove = resizer_remove,
++};
++
++/*
++=====================rsz_init===========================
++function to	register resizer character driver
++*/
++static int __init rsz_init(void)
++{
++
++	int result;
++
++	device_config.module_usage_count = ZERO;
++	device_config.array_count = ZERO;
++
++	/* Register     the     driver in the kernel */
++
++	result = alloc_chrdev_region(&dev, ZERO, 1, DRIVER_NAME);
++	if (result < ZERO) {
++		printk(KERN_INFO, "\nDaVinciresizer: Module intialization \
++				failed.could not register character device");
++		return -ENODEV;
++	}
++	/* Initialize of character device */
++	cdev_init(&c_dev, &rsz_fops);
++	c_dev.owner = THIS_MODULE;
++	c_dev.ops = &rsz_fops;
++
++	/* addding character device */
++	result = cdev_add(&c_dev, dev, 1);
++
++	if (result) {
++		printk("NOtICE \nDaVinciresizer:Error %d adding Davinciresizer\
++				 ..error no:", result);
++		unregister_chrdev_region(dev, 1);
++		return result;
++	}
++
++	/* registeration of     character device */
++	register_chrdev(MAJOR(dev), DRIVER_NAME, &rsz_fops);
++
++	/* register driver as a platform driver */
++	if (driver_register(&resizer_driver) != 0) {
++		unregister_chrdev_region(dev, 1);
++		cdev_del(&c_dev);
++		return -EINVAL;
++	}
++
++	/* Register the drive as a platform device */
++	if (platform_device_register(&resizer_device) != 0) {
++		driver_unregister(&resizer_driver);
++		unregister_chrdev_region(dev, 1);
++		unregister_chrdev(MAJOR(dev), DRIVER_NAME);
++		cdev_del(&c_dev);
++		return -EINVAL;
++	}
++
++	rsz_class = class_create(THIS_MODULE, "davinci_resizer");
++
++	if (!rsz_class) {
++
++		platform_device_unregister(&resizer_device);
++		cdev_del(&c_dev);
++		unregister_chrdev(MAJOR(dev), DRIVER_NAME);
++
++		return -EIO;
++	}
++
++	/* register device class     */
++	device_create(rsz_class, NULL, dev, NULL, "%s", "davinci_resizer");
++
++	init_completion(&(device_config.sem_isr));
++
++	device_config.sem_isr.done = ZERO;
++
++	/* Initialize the device mutex */
++	init_MUTEX(&device_config.array_sem);
++	init_MUTEX(&device_config.device_mutex);
++
++	/* Set up the Interrupt handler for     resizer interrupt */
++
++	result = request_irq(IRQ_RSZINT, rsz_isr, 0,
++			     "dm644xresizer", (void *)NULL);
++	if (result < ZERO) {
++		printk("Cannot initialize IRQ \n");
++		platform_device_unregister(&resizer_device);
++		unregister_chrdev(MAJOR(dev), DRIVER_NAME);
++		return result;
++	}
++	rsz_set_exp(0xe);
++
++	return SUCESS;
++}				/* End   of function  resizer_init */
++
++/*
++=====================rsz_cleanup===========================
++Function	is called by the kernel. It	unregister the device.
++*/
++void __exit rsz_cleanup(void)
++{
++
++	unregister_chrdev_region(dev, 1);
++
++	/* remove class device */
++	device_destroy(rsz_class, dev);
++
++	/* destroy class */
++	class_destroy(rsz_class);
++
++	/* Remove platform driver */
++	driver_unregister(&resizer_driver);
++
++	/* disable interrupt */
++	free_irq(IRQ_RSZINT, (void *)NULL);
++
++	/* remove platform device */
++	platform_device_unregister(&resizer_device);
++
++	cdev_del(&c_dev);
++
++	/* unregistering the driver     from the kernel */
++	unregister_chrdev(MAJOR(dev), DRIVER_NAME);
++
++}				/* End  of function   resizer_cleanup */
++
++module_init(rsz_init) module_exit(rsz_cleanup)
+--- /dev/null
++++ b/drivers/char/davinci_resizer_hw.c
+@@ -0,0 +1,142 @@
++/* *
++ * Copyright (C) 2006 Texas Instruments Inc
++ *
++ * This program is free software you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA
++ */
++/* davinci_resizer_hw.c file */
++
++/*Header files*/
++
++#include <mach/davinci_resizer_hw.h>
++#include <linux/kernel.h>	/* printk()     */
++#include <linux/device.h>
++#include <mach/davinci_resizer.h>
++struct device *rsz_device;
++/*
++=====================rsz_hardware_setup===========================
++ Function	to set hardware	configuration registers
++*/
++
++void rsz_hardware_setup(struct channel_config_t *rsz_conf_chan)
++{
++	/* Counter to set the value     of horizonatl and vertical coeff */
++	int coeffcounter;
++	/* for getting the coefficient offset */
++	int coeffoffset = ZERO;
++
++	dev_dbg(rsz_device, "%s E\n", __FUNCTION__);
++
++	/* clear the VPSS_PCR register buffer overflow bits     */
++	regw(0x003c0000, VPSS_PCR);
++
++	/* setting the hardware register rszcnt */
++	regw(rsz_conf_chan->register_config.rsz_cnt, RSZ_CNT);
++
++	dev_dbg(rsz_device, "RSZ CNT : %x	regr = %x \n",
++		rsz_conf_chan->register_config.rsz_cnt, regr(RSZ_CNT));
++
++	/* setting the hardware register instart */
++	regw(rsz_conf_chan->register_config.rsz_in_start, IN_START);
++
++	dev_dbg(rsz_device, "In START	%x regr	= %x\n",
++		rsz_conf_chan->register_config.rsz_in_start, regr(IN_START));
++
++	/* setting the hardware register insize */
++	regw(rsz_conf_chan->register_config.rsz_in_size, IN_SIZE);
++
++	dev_dbg(rsz_device, "In size %x regr = %x\n",
++		rsz_conf_chan->register_config.rsz_in_size, regr(IN_SIZE));
++	/* setting the hardware register outsize */
++	regw(rsz_conf_chan->register_config.rsz_out_size, OUT_SIZE);
++
++	dev_dbg(rsz_device, "out	size %x	regr = %x\n",
++		rsz_conf_chan->register_config.rsz_out_size, regr(OUT_SIZE));
++
++	/* setting the hardware register inaddress */
++	regw(rsz_conf_chan->register_config.rsz_sdr_inadd, SDR_INADD);
++
++	dev_dbg(rsz_device, "in address %x regr =	%x\n",
++		rsz_conf_chan->register_config.rsz_sdr_inadd, regr(SDR_INADD));
++	/* setting the hardware register in     offset */
++	regw(rsz_conf_chan->register_config.rsz_sdr_inoff, SDR_INOFF);
++
++	dev_dbg(rsz_device, "in offset %x	regr = %x\n",
++		rsz_conf_chan->register_config.rsz_sdr_inoff, regr(SDR_INOFF));
++	/* setting the hardware register in     offset */
++	/* setting the hardware register out address */
++	regw(rsz_conf_chan->register_config.rsz_sdr_outadd, SDR_OUTADD);
++
++	dev_dbg(rsz_device, "out	addrsess %x	regr = %x\n",
++		rsz_conf_chan->register_config.rsz_sdr_outadd,
++		regr(SDR_OUTADD));
++
++	/* setting the hardware register in     offset */
++	/* setting the hardware register out offset */
++	regw(rsz_conf_chan->register_config.rsz_sdr_outoff, SDR_OUTOFF);
++
++	dev_dbg(rsz_device, "out	offset %x regr = %x\n",
++		rsz_conf_chan->register_config.rsz_sdr_outoff,
++		regr(SDR_OUTOFF));
++
++	/* setting the hardware register yehn */
++	regw(rsz_conf_chan->register_config.rsz_yehn, YENH);
++
++	dev_dbg(rsz_device, "yehn	 %x	regr = %x\n",
++		rsz_conf_chan->register_config.rsz_yehn, regr(YENH));
++
++	/* setting the hardware registers     of coefficients */
++	for (coeffcounter = ZERO; coeffcounter < MAX_COEF_COUNTER;
++	     coeffcounter++) {
++		regw(rsz_conf_chan->register_config.
++		     rsz_coeff_horz[coeffcounter], ((HFILT10 + coeffoffset)));
++
++		regw(rsz_conf_chan->register_config.
++		     rsz_coeff_vert[coeffcounter], ((VFILT10 + coeffoffset)));
++		coeffoffset = coeffoffset + COEFF_ADDRESS_OFFSET;
++	}
++
++	dev_dbg(rsz_device, "%s L\n", __FUNCTION__);
++
++}
++
++/*
++=====================rsz_enable===========================
++ Function to enable	the	resizer
++*/
++int rsz_enable(struct channel_config_t *rsz_conf_chan)
++{
++
++	dev_dbg(rsz_device, "%s E\n", __FUNCTION__);
++
++	/* Eanbling the resizer the setting enable bit */
++	rsz_conf_chan->register_config.rsz_pcr =
++	    BITSET(rsz_conf_chan->register_config.rsz_pcr, SET_ENABLE_BIT);
++
++	regw(rsz_conf_chan->register_config.rsz_pcr, PCR);
++
++	dev_dbg(rsz_device, "the value of pcr is %x \n", regr(PCR));
++
++	regw(0x003c0000, VPSS_PCR);
++
++	dev_dbg(rsz_device, "%s L\n", __FUNCTION__);
++
++	return SUCESS;
++}
++
++int rsz_writebuffer_status(void)
++{
++	dev_dbg(rsz_device, "VPSS_PCR: %x\n", regr(VPSS_PCR));
++	return ((regr(VPSS_PCR) >> 18) & 0xF);
++}
+--- a/drivers/char/Kconfig
++++ b/drivers/char/Kconfig
+@@ -1087,6 +1087,12 @@ config DM646x_PCI_TARGET_DRV
+                 This option builds driver for DM646x PCI target connected to
+                 the DM646x configured as PCI Host. Use 'M' to build as module.
+ 
++config RESIZER
++	tristate "DaVinci Resizer Driver"
++	default n
++	help
++		DaVinci Resizer Driver.
++
+ config HANGCHECK_TIMER
+ 	tristate "Hangcheck timer"
+ 	depends on X86 || IA64 || PPC64 || S390
+--- a/drivers/char/Makefile
++++ b/drivers/char/Makefile
+@@ -112,6 +112,9 @@ obj-$(CONFIG_IPMI_HANDLER)	+= ipmi/
+ 
+ obj-$(CONFIG_DM646x_PCI_TARGET_DRV) += dm646x_pci_targetdrv.o
+ 
++davinci_rsz_driver-objs		:= davinci_resizer_hw.o davinci_resizer.o
++obj-$(CONFIG_RESIZER)		+= davinci_rsz_driver.o
++
+ obj-$(CONFIG_HANGCHECK_TIMER)	+= hangcheck-timer.o
+ obj-$(CONFIG_TCG_TPM)		+= tpm/
+ 
+--- /dev/null
++++ b/include/media/davinci/davinci_resizer.h
+@@ -0,0 +1,368 @@
++/* *
++ * Copyright (C) 2006 Texas Instruments Inc
++ *
++ * This program is free software you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation either version 2 of the License, or
++ * (at your option) any later version.
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not,write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
++ */
++/* davinci_resizer.h file */
++
++#ifndef	DAVINVI_RESIZER_H
++#define	DAVINVI_RESIZER_H
++
++#ifdef __KERNEL__
++/* include Linux files */
++#include <mach/hardware.h>
++#include <linux/io.h>
++#include <linux/autoconf.h>
++#include <linux/module.h>
++#include <linux/moduleparam.h>
++#include <linux/init.h>
++#include <linux/kernel.h>	/*     printk() */
++#include <linux/slab.h>		/*     kmalloc() */
++#include <linux/fs.h>		/*     everything... */
++#include <linux/errno.h>	/*     error codes     */
++#include <linux/types.h>	/*     size_t */
++#include <linux/mm.h>
++#include <linux/kdev_t.h>
++#include <asm/page.h>
++#include <linux/cdev.h>
++#include <linux/string.h>
++#include <linux/tty.h>
++#include <linux/delay.h>
++#include <linux/fb.h>
++#include <linux/dma-mapping.h>
++#include <linux/interrupt.h>
++#include <linux/uaccess.h>
++#include <linux/ioport.h>
++#include <linux/version.h>
++#include <linux/irq.h>
++#include <mach/clock.h>
++#include <linux/errno.h>
++#include <linux/sched.h>
++#include <linux/err.h>
++#include <linux/proc_fs.h>
++#include <linux/sysctl.h>
++#ifdef CONFIG_PREEMPT_RT
++#include <linux/completion.h>
++#endif
++#endif				/* end of #ifdef __KERNEL__ */
++/* Definitions */
++
++/* ioctls definition */
++#pragma	pack(1)
++#define		RSZ_IOC_BASE			       'R'
++#define		RSZ_IOC_MAXNR				11
++
++/*Ioctl options which are to be passed while calling the ioctl*/
++#define	RSZ_REQBUF		_IOWR(RSZ_IOC_BASE, 1,  struct rsz_reqbufs_t*)
++#define	RSZ_QUERYBUF		_IOWR(RSZ_IOC_BASE, 2, struct rsz_buffer_t  *)
++#define	RSZ_S_PARAM		_IOWR(RSZ_IOC_BASE, 3, struct rsz_params_t *)
++#define	RSZ_G_PARAM		_IOWR(RSZ_IOC_BASE, 4, struct rsz_params_t *)
++#define	RSZ_RESIZE		_IOWR(RSZ_IOC_BASE, 5, struct rsz_resize_t *)
++#define	RSZ_G_STATUS		_IOWR(RSZ_IOC_BASE, 6, struct rsz_status_t *)
++#define	RSZ_S_PRIORITY		_IOWR(RSZ_IOC_BASE, 7, struct rsz_priority_t*)
++#define	RSZ_G_PRIORITY		_IOWR(RSZ_IOC_BASE, 9, struct rsz_priority_t*)
++#define	RSZ_GET_CROPSIZE	_IOWR(RSZ_IOC_BASE, 10, struct rsz_cropsize_t *)
++#define	RSZ_S_EXP		_IOWR(RSZ_IOC_BASE, 11, int*)
++#pragma	pack()
++/* End of ioctls */
++
++#define	RSZ_BUF_IN						0
++#define	RSZ_BUF_OUT						1
++#define	RSZ_YENH_DISABLE					0
++#define	RSZ_YENH_3TAP_HPF					1
++#define	RSZ_YENH_5TAP_HPF					2
++
++#ifdef __KERNEL__
++
++/* Defines and Constants*/
++#define	MAX_BUFFER						3
++#define	MAX_CHANNELS						16
++#define	MAX_PRIORITY						5
++#define	MIN_PRIORITY						0
++#define	DEFAULT_PRIORITY					3
++#define	MAX_IMAGE_WIDTH						1280
++#define	MAX_IMAGE_WIDTH_HIGH					640
++#define	MAX_IMAGE_HEIGHT					960
++#define	MAX_INPUT_BUFFERS					8
++#define	MAX_OUTPUT_BUFFERS					8
++#define	DRIVER_NAME						"Resizer"
++#define	FREE_BUFFER						0
++#define	ALIGNMENT						16
++#define	CHANNEL_BUSY						1
++#define	CHANNEL_FREE						0
++#define	PIXEL_EVEN						2
++#define	RATIO_MULTIPLIER					256
++
++/*Bit position	Macro*/
++/* macro for bit set and clear */
++#define	BITSET(variable, bit)		((variable) | (1<<bit))
++#define	BITRESET(variable, bit)		((variable) & (~(0x00000001<<(bit))))
++
++/* RSZ_CNT */
++#define	CSL_RESZ_RSZ_CNT_CBILIN_MASK			(0x20000000u)
++#define	CSL_RESZ_RSZ_CNT_CBILIN_SHIFT			(0x0000001Du)
++
++/*RSZ_OUT_VSIZE_SHIFT*/
++
++#define	RSZ_VSTPH_MASK					(0xfC7fffffu)
++#define	RSZ_HSTPH_MASK					(0xff8fffffu)
++
++#define	RSZ_CNT_VRSZ_MASK				(0xfff002ffu)
++#define	RSZ_CNT_HRSZ_MASK				(0xfffffc00u)
++/* OUT_SIZE	*/
++#define	RSZ_OUT_SIZE_VERT_MASK				(0xf800ffffu)
++#define	RSZ_OUT_SIZE_HORZ_MASK				(0xfffff800u)
++/* IN_START	*/
++
++#define	RSZ_IN_START_VERT_ST_MASK			(0xE000FFFFu)
++#define	RSZ_IN_START_HORZ_ST_MASK			(0xFFFFE000u)
++/* IN_SIZE */
++#define	RSZ_IN_SIZE_VERT_MASK				(0xe000ffffu)
++#define	RSZ_IN_SIZE_HORZ_MASK				(0xffffe000u)
++/* SDR_INOFF */
++#define	RSZ_SDR_INOFF_OFFSET_MASK			(0xffff0000u)
++#define	RSZ_SDR_OUTOFF_OFFSET_MASK			(0xffff0000u)
++ /**/
++#define	RSZ_UWORD_MASK					(0x03FF0000u)
++#define	RSZ_LWORD_MASK					(0x000003FFu)
++/* YENH	*/
++#define	RSZ_YEHN_CORE_MASK				(0xffffff00u)
++#define	RSZ_YEHN_SLOP_MASK				(0xfffff0ffu)
++#define	RSZ_YEHN_GAIN_MASK				(0xffff0fffu)
++#define	RSZ_YEHN_ALGO_MASK				(0xfffcffffu)
++/* Filter coeefceints */
++#define	RSZ_FILTER_COEFF0_MASK				(0xfffffc00u)
++#define	RSZ_FILTER_COEFF1_MASK				(0xfc00ffffu)
++#define	RSZ_CNT_CBILIN_MASK				(0x20000000u)
++#define	RSZ_CNT_INPTYP_MASK				(0x08000000u)
++#define	RSZ_CNT_PIXFMT_MASK				(0x04000000u)
++#define	RSZ_HSTP_SHIFT					20
++#define	RSZ_HRSZ_MASK					(0xfffffc00)
++#define	RSZ_VRSZ_MASK					(0xfff003ff)
++#define	RSZ_VRSZ_SHIFT					10
++/*///////Shifts*/
++#define	RSZ_OUT_VSIZE_SHIFT				16
++#define	SET_BIT_CBLIN					29
++#define	SET_BIT_INPUTRAM				28
++#define	INPUT_RAM					1
++#define	SET_BIT_INPTYP					27
++#define	SET_BIT_YCPOS					26
++#define	RSZ_VSTPH_SHIFT					23
++#define	RSZ_FILTER_COEFF_SHIFT				16
++#define	RSZ_YENH_TYPE_SHIFT				16
++#define	RSZ_YENH_GAIN_SHIFT				12
++#define	RSZ_YENH_SLOP_SHIFT				8
++#define	UP_RSZ_RATIO					64
++#define	DOWN_RSZ_RATIO					512
++#define	UP_RSZ_RATIO1					513
++#define	DOWN_RSZ_RATIO1					1024
++#define	SET_ENABLE_BIT					0
++#define	RSZ_IN_SIZE_VERT_SHIFT				16
++#define	MAX_HORZ_PIXEL_8BIT				31
++#define	MAX_HORZ_PIXEL_16BIT			15
++#define	BYTES_PER_PIXEL					2
++#define	 NUM_PHASES					8
++#define	 NUM_TAPS					4
++#define	 NUM_D2PH			4	/* for downsampling
++						2+x ~ 4x, numberof phases */
++#define	 NUM_D2TAPS			7	/* for downsampling
++						2+x ~ 4x,number of taps */
++#define	 NUM_COEFS (NUM_PHASES * NUM_TAPS)
++#define	ALIGN32						32
++#define	ADDRESS_FOUND					1
++#define	NEXT						1
++/*#define DEBUG							0*/
++#define	RESIZER_IOBASE_VADDR			IO_ADDRESS(0x01C70C00)
++#define	MAX_COEF_COUNTER				16
++#define	ZERO						0
++#define	FIRSTENTRY					0
++#define	SECONDENTRY					1
++#define	EMPTY						0
++#define	SUCESS						0
++#endif				/* end of #ifdef __KERNEL__ */
++#define	RSZ_INTYPE_YCBCR422_16BIT		0
++#define	RSZ_INTYPE_PLANAR_8BIT			1
++#define	RSZ_PIX_FMT_PLANAR			2	/* 8-bit planar input */
++#define	RSZ_PIX_FMT_UYVY			0	/*    cb:y:cr:y */
++#define	RSZ_PIX_FMT_YUYV			1	/*    y:cb:y:cr */
++#ifdef __KERNEL__
++#define	isbusy()				((regr(PCR)	& 0x02)>>1)
++/*///////Enumerations*/
++    enum config_done {
++	STATE_CONFIGURED,	/* Resizer driver configured by application */
++	STATE_NOT_CONFIGURED	/* Resizer driver not configured by
++				   application */
++};
++
++#endif				/* end of #ifdef __KERNEL__ */
++
++/*Structure Definitions*/
++/* To allocate the memory*/
++struct rsz_reqbufs_t {
++	int buf_type;		/* type of frame buffer */
++	int size;		/* size of the frame bufferto be allocated */
++	int count;		/* number of frame buffer to be allocated */
++};
++
++/* assed for quering the buffer to get physical address*/
++struct rsz_buffer_t {
++	int index;		/* buffer index number, 0 -> N-1 */
++	int buf_type;		/* buffer type, input or output */
++	int offset;		/* physical     address of the buffer,
++				   used in the mmap() system call */
++	int size;
++};
++
++/* used	to luma	enhancement options*/
++
++struct rsz_yenh_t {
++	int type;		/* represents luma enable or disable */
++	unsigned char gain;	/*represents gain */
++	unsigned char slop;	/*represents slop */
++	unsigned char core;	/* Represents core value */
++};
++
++/* Conatins	all	the	parameters for resizing	. This structure
++	is used	to configure resiser parameters*/
++struct rsz_params_t {
++	int in_hsize;		/* input frame horizontal size */
++	int in_vsize;		/* input frame vertical size */
++	int in_pitch;		/* offset between two rows of input frame */
++	int inptyp;		/* for determining 16 bit or 8 bit data */
++	int vert_starting_pixel;	/* for specifying vertical
++					   starting pixel in input */
++	int horz_starting_pixel;	/* for specyfing horizontal
++					   starting pixel in input */
++	int cbilin;		/* # defined, filter with luma or bi-linear
++				   interpolation */
++	int pix_fmt;		/* # defined, UYVY or YUYV */
++	int out_hsize;		/* output frame horizontal size */
++	int out_vsize;		/* output frame vertical size */
++	int out_pitch;		/* offset between two rows of output frame */
++	int hstph;		/* for specifying horizontal starting phase */
++	int vstph;		/* for specifying vertical starting phase */
++	short hfilt_coeffs[32];	/* horizontal filter coefficients */
++	short vfilt_coeffs[32];	/* vertical filter coefficients */
++	struct rsz_yenh_t yenh_params;
++};
++
++/* resize structure passed during the resize IOCTL*/
++struct rsz_resize_t {
++	struct rsz_buffer_t in_buf;
++	struct rsz_buffer_t out_buf;
++};
++
++/* Contains the status of hardware and channel*/
++struct rsz_status_t {
++	int chan_busy;		/* 1: channel is busy, 0: channel is not busy */
++	int hw_busy;		/*1: hardware  is busy, 0:
++				   hardware is not     busy */
++	int src;		/* # defined, can be either
++				   SD-RAM or CCDC/PREVIEWER */
++};
++
++/* structure to	set the priroity of the the channel*/
++struct rsz_priority_t {
++	int priority;		/* 0=>5, with 5 the highest priority */
++};
++
++/* Passed by application for getting crop size*/
++struct rsz_cropsize_t {
++	unsigned int hcrop;	/*number of pixels per line c
++				   ropped in output image */
++
++	unsigned int vcrop;	/*number of lines cropped
++				   in output image */
++};
++
++#ifdef __KERNEL__
++
++/*Register mapped structure which contains the every register
++information*/
++struct resizer_config_t {
++	int rsz_pcr;		/*pcr register mapping variable */
++	int rsz_in_start;	/* in_start register mapping variable */
++	int rsz_in_size;	/* in_size register mapping variable */
++	int rsz_out_size;	/* out_size register mapping variable */
++	int rsz_cnt;		/* rsz_cnt register mapping     variable */
++	int rsz_sdr_inadd;	/* sdr_inadd register mapping variable */
++	int rsz_sdr_inoff;	/* sdr_inoff register mapping variable */
++	int rsz_sdr_outadd;	/* sdr_outadd register mapping variable */
++	int rsz_sdr_outoff;	/* sdr_outbuff register mapping  variable */
++	int rsz_coeff_horz[16];	/* horizontal coefficients mapping array */
++	int rsz_coeff_vert[16];	/* vertical  coefficients mapping  array */
++	int rsz_yehn;		/* yehn(luma)register  mapping  variable */
++};
++
++/* Channel specific	structure contains information regarding
++the	every channel */
++struct channel_config_t {
++	struct resizer_config_t register_config;	/* instance
++				of register set mapping  structure */
++
++	void *input_buffer[MAX_INPUT_BUFFERS];	/* for storing input buffers
++						   pointers */
++
++	void *output_buffer[MAX_OUTPUT_BUFFERS];	/* for storing output
++							   buffers pointers */
++
++	int in_bufsize, out_bufsize; /* Contains input and output buffer size */
++
++	int status;		/* specifies whether the channel */
++	/* is busy or not */
++
++	int priority;		/* stores priority of the application */
++#ifdef CONFIG_PREEMPT_RT
++	struct completion channel_sem;
++#else
++	struct semaphore channel_sem;
++#endif
++	struct semaphore chanprotection_sem;
++	enum config_done config_state;
++};
++
++/*Global structure which contains information about	number of chanels
++and	protection variables */
++struct device_params_t {
++	int module_usage_count;	/* For counting no of channels
++				   created */
++	struct completion sem_isr;	/*Semaphore for interrupt */
++	struct semaphore array_sem;	/* Semaphore for array */
++	struct semaphore device_mutex;	/* mutex protecting device_params */
++	/* structure object */
++
++	struct channel_config_t *channel_configuration[MAX_CHANNELS];
++	/* Pointer to channel configuration */
++
++	int array_count;	/* for counting number of elements
++				   in arrray */
++};
++
++/*Functions Definition*/
++
++int malloc_buff(struct rsz_reqbufs_t *, struct channel_config_t *);
++int get_buf_address(struct rsz_buffer_t *, struct channel_config_t *);
++int rsz_start(struct rsz_resize_t *, struct channel_config_t *);
++int add_to_array(struct channel_config_t *rsz_configuration_channel);
++int delete_from_array(struct channel_config_t *rsz_configuration_channel);
++int rsz_set_params(struct rsz_params_t *, struct channel_config_t *);
++int rsz_get_params(struct rsz_params_t *, struct channel_config_t *);
++int free_buff(struct channel_config_t *rsz_configuration_channel);
++irqreturn_t rsz_isr(int, void *, struct pt_regs *);
++void rsz_calculate_crop(struct channel_config_t *rsz_conf_chan,
++			struct rsz_cropsize_t *
++						cropsize);
++#endif				/* end of #ifdef __KERNEL__ */
++
++#endif				/* End of #ifndef DAVINCI_RESIZER_H */
+--- /dev/null
++++ b/include/media/davinci/davinci_resizer_hw.h
+@@ -0,0 +1,58 @@
++/* *
++ * Copyright (C) 2006 Texas Instruments Inc
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
++ */
++/* davinci_resizer_hw.c file */
++#ifndef	DAVINCI_RESIZER_HW
++#define	DAVINCI_RESIZER_HW
++
++#include <mach/davinci_resizer.h>
++#include <mach/hardware.h>
++#include <linux/io.h>
++
++/* Register	offset mapping*/
++#define	RESIZER_IOBASE_VADDR	IO_ADDRESS(0x01C70C00)
++#define	PID					0x0000
++#define	PCR					0x0004
++#define	RSZ_CNT					0x0008
++#define	OUT_SIZE				0x000C
++#define	IN_START				0x0010
++#define	IN_SIZE					0x0014
++#define	SDR_INADD				0x0018
++#define	SDR_INOFF				0x001C
++#define	SDR_OUTADD				0x0020
++#define	SDR_OUTOFF				0x0024
++#define	HFILT10					0x0028
++#define	VFILT10					0x0068
++#define	COEFF_ADDRESS_OFFSET			0x04
++#define	YENH					0x00A8
++
++#define	VPSS_PCR				(0x3404-0x0C00)
++#define	SDR_REQ_EXP				(0x3508-0x0C00)
++
++/* Register	read/write */
++#define	regw(val, reg)		outl(val, ((reg) + RESIZER_IOBASE_VADDR))
++#define	regr(reg)		inl((reg) + RESIZER_IOBASE_VADDR)
++
++/* functions definition*/
++void rsz_hardware_setup(struct channel_config_t *rsz_conf_chan);
++int rsz_enable(struct channel_config_t *rsz_conf_chan);
++static inline void rsz_set_exp(int exp)
++{
++	regw(((exp & 0x3ff) << 10), SDR_REQ_EXP);
++}
++int rsz_writebuffer_status(void);
++#endif
Index: trunk/target/linux/davinci/patches-2.6.32/505-gateworks_gsp.patch
===================================================================
--- trunk/target/linux/davinci/patches-2.6.32/505-gateworks_gsp.patch	(revision 0)
+++ trunk/target/linux/davinci/patches-2.6.32/505-gateworks_gsp.patch	(revision 0)
@@ -0,0 +1,339 @@
+--- /dev/null
++++ b/drivers/hwmon/gsp.c
+@@ -0,0 +1,308 @@
++/*
++ * A hwmon driver for the Gateworks System Peripheral
++ * Copyright (C) 2009 Gateworks Corporation
++ *
++ * Author: Chris Lang <clang@gateworks.com>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License,
++ * as published by the Free Software Foundation - version 2.
++ */
++
++#include <linux/module.h>
++#include <linux/i2c.h>
++#include <linux/hwmon.h>
++#include <linux/hwmon-sysfs.h>
++#include <linux/err.h>
++#include <linux/slab.h>
++
++#define DRV_VERSION "0.2"
++
++enum chips { gsp };
++
++/* AD7418 registers */
++#define GSP_REG_TEMP_IN		0x00
++#define GSP_REG_VIN		0x02
++#define GSP_REG_3P3		0x05
++#define GSP_REG_BAT		0x08
++#define GSP_REG_5P0		0x0b
++#define GSP_REG_CORE		0x0e
++#define GSP_REG_CPU1		0x11
++#define GSP_REG_CPU2		0x14
++#define GSP_REG_DRAM		0x17
++#define GSP_REG_EXT_BAT		0x1a
++#define GSP_REG_IO1		0x1d
++#define GSP_REG_IO2 		0x20
++#define GSP_REG_PCIE		0x23
++#define GSP_REG_CURRENT		0x26
++#define GSP_FAN_0		0x2C
++#define GSP_FAN_1		0x2E
++#define GSP_FAN_2		0x30
++#define GSP_FAN_3		0x32
++#define GSP_FAN_4		0x34
++#define GSP_FAN_5		0x36
++
++struct gsp_sensor_info {
++	const char* name;
++	int reg;
++};
++
++static const struct gsp_sensor_info gsp_sensors[] = {
++	{"temp", GSP_REG_TEMP_IN},
++	{"vin", GSP_REG_VIN},
++	{"3p3", GSP_REG_3P3},
++	{"bat", GSP_REG_BAT},
++	{"5p0", GSP_REG_5P0},
++	{"core", GSP_REG_CORE},
++	{"cpu1", GSP_REG_CPU1},
++	{"cpu2", GSP_REG_CPU2},
++	{"dram", GSP_REG_DRAM},
++	{"ext_bat", GSP_REG_EXT_BAT},
++	{"io1", GSP_REG_IO1},
++	{"io2", GSP_REG_IO2},
++	{"pci2", GSP_REG_PCIE},
++	{"current", GSP_REG_CURRENT},
++	{"fan_point0", GSP_FAN_0},
++	{"fan_point1", GSP_FAN_1},
++	{"fan_point2", GSP_FAN_2},
++	{"fan_point3", GSP_FAN_3},
++	{"fan_point4", GSP_FAN_4},
++	{"fan_point5", GSP_FAN_5},
++};
++
++struct gsp_data {
++	struct device		*hwmon_dev;
++	struct attribute_group	attrs;
++	enum chips		type;
++};
++
++static int gsp_probe(struct i2c_client *client,
++			const struct i2c_device_id *id);
++static int gsp_remove(struct i2c_client *client);
++
++static const struct i2c_device_id gsp_id[] = {
++	{ "gsp", 0 },
++	{ }
++};
++MODULE_DEVICE_TABLE(i2c, gsp_id);
++
++static struct i2c_driver gsp_driver = {
++	.driver = {
++		.name	= "gsp",
++	},
++	.probe		= gsp_probe,
++	.remove		= gsp_remove,
++	.id_table	= gsp_id,
++};
++
++/* All registers are word-sized, except for the configuration registers.
++ * AD7418 uses a high-byte first convention. Do NOT use those functions to
++ * access the configuration registers CONF and CONF2, as they are byte-sized.
++ */
++static inline int gsp_read(struct i2c_client *client, u8 reg)
++{
++	unsigned int adc = 0;
++	if (reg == GSP_REG_TEMP_IN || reg > GSP_REG_CURRENT)
++	{
++		adc |= i2c_smbus_read_byte_data(client, reg);
++		adc |= i2c_smbus_read_byte_data(client, reg + 1) << 8;
++		return adc;
++	}
++	else
++	{
++		adc |= i2c_smbus_read_byte_data(client, reg);
++		adc |= i2c_smbus_read_byte_data(client, reg + 1) << 8;
++		adc |= i2c_smbus_read_byte_data(client, reg + 2) << 16;
++		return adc;
++	}
++}
++
++static inline int gsp_write(struct i2c_client *client, u8 reg, u16 value)
++{
++	i2c_smbus_write_byte_data(client, reg, value & 0xff);
++	i2c_smbus_write_byte_data(client, reg + 1, ((value >> 8) & 0xff));
++	return 1;
++}
++
++static ssize_t show_adc(struct device *dev, struct device_attribute *devattr,
++			char *buf)
++{
++	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
++	struct i2c_client *client = to_i2c_client(dev);
++	return sprintf(buf, "%d\n", gsp_read(client, gsp_sensors[attr->index].reg));
++}
++
++static ssize_t show_label(struct device *dev,
++			struct device_attribute *devattr, char *buf)
++{
++	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
++
++	return sprintf(buf, "%s\n", gsp_sensors[attr->index].name);
++}
++
++static ssize_t store_fan(struct device *dev,
++			struct device_attribute *devattr, const char *buf, size_t count)
++{
++	u16 val;
++	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
++	struct i2c_client *client = to_i2c_client(dev);
++	val = simple_strtoul(buf, NULL, 10);
++	gsp_write(client, gsp_sensors[attr->index].reg, val);
++	return count;
++}
++
++static SENSOR_DEVICE_ATTR(temp0_input, S_IRUGO, show_adc, NULL, 0);
++static SENSOR_DEVICE_ATTR(temp0_label, S_IRUGO, show_label, NULL, 0);
++
++static SENSOR_DEVICE_ATTR(in0_input, S_IRUGO, show_adc, NULL, 1);
++static SENSOR_DEVICE_ATTR(in0_label, S_IRUGO, show_label, NULL, 1);
++static SENSOR_DEVICE_ATTR(in1_input, S_IRUGO, show_adc, NULL, 2);
++static SENSOR_DEVICE_ATTR(in1_label, S_IRUGO, show_label, NULL, 2);
++static SENSOR_DEVICE_ATTR(in2_input, S_IRUGO, show_adc, NULL, 3);
++static SENSOR_DEVICE_ATTR(in2_label, S_IRUGO, show_label, NULL, 3);
++static SENSOR_DEVICE_ATTR(in3_input, S_IRUGO, show_adc, NULL, 4);
++static SENSOR_DEVICE_ATTR(in3_label, S_IRUGO, show_label, NULL, 4);
++static SENSOR_DEVICE_ATTR(in4_input, S_IRUGO, show_adc, NULL, 5);
++static SENSOR_DEVICE_ATTR(in4_label, S_IRUGO, show_label, NULL, 5);
++static SENSOR_DEVICE_ATTR(in5_input, S_IRUGO, show_adc, NULL, 6);
++static SENSOR_DEVICE_ATTR(in5_label, S_IRUGO, show_label, NULL, 6);
++static SENSOR_DEVICE_ATTR(in6_input, S_IRUGO, show_adc, NULL, 7);
++static SENSOR_DEVICE_ATTR(in6_label, S_IRUGO, show_label, NULL, 7);
++static SENSOR_DEVICE_ATTR(in7_input, S_IRUGO, show_adc, NULL, 8);
++static SENSOR_DEVICE_ATTR(in7_label, S_IRUGO, show_label, NULL, 8);
++static SENSOR_DEVICE_ATTR(in8_input, S_IRUGO, show_adc, NULL, 9);
++static SENSOR_DEVICE_ATTR(in8_label, S_IRUGO, show_label, NULL, 9);
++static SENSOR_DEVICE_ATTR(in9_input, S_IRUGO, show_adc, NULL, 10);
++static SENSOR_DEVICE_ATTR(in9_label, S_IRUGO, show_label, NULL, 10);
++static SENSOR_DEVICE_ATTR(in10_input, S_IRUGO, show_adc, NULL, 11);
++static SENSOR_DEVICE_ATTR(in10_label, S_IRUGO, show_label, NULL, 11);
++static SENSOR_DEVICE_ATTR(in11_input, S_IRUGO, show_adc, NULL, 12);
++static SENSOR_DEVICE_ATTR(in11_label, S_IRUGO, show_label, NULL, 12);
++static SENSOR_DEVICE_ATTR(in12_input, S_IRUGO, show_adc, NULL, 13);
++static SENSOR_DEVICE_ATTR(in12_label, S_IRUGO, show_label, NULL, 13);
++
++static SENSOR_DEVICE_ATTR(fan0_point0, S_IRUGO | S_IWUSR, show_adc, store_fan, 14);
++static SENSOR_DEVICE_ATTR(fan0_point1, S_IRUGO | S_IWUSR, show_adc, store_fan, 15);
++static SENSOR_DEVICE_ATTR(fan0_point2, S_IRUGO | S_IWUSR, show_adc, store_fan, 16);
++static SENSOR_DEVICE_ATTR(fan0_point3, S_IRUGO | S_IWUSR, show_adc, store_fan, 17);
++static SENSOR_DEVICE_ATTR(fan0_point4, S_IRUGO | S_IWUSR, show_adc, store_fan, 18);
++static SENSOR_DEVICE_ATTR(fan0_point5, S_IRUGO | S_IWUSR, show_adc, store_fan, 19);
++
++static struct attribute *gsp_attributes[] = {
++	&sensor_dev_attr_temp0_input.dev_attr.attr,
++	&sensor_dev_attr_in0_input.dev_attr.attr,
++	&sensor_dev_attr_in1_input.dev_attr.attr,
++	&sensor_dev_attr_in2_input.dev_attr.attr,
++	&sensor_dev_attr_in3_input.dev_attr.attr,
++	&sensor_dev_attr_in4_input.dev_attr.attr,
++	&sensor_dev_attr_in5_input.dev_attr.attr,
++	&sensor_dev_attr_in6_input.dev_attr.attr,
++	&sensor_dev_attr_in7_input.dev_attr.attr,
++	&sensor_dev_attr_in8_input.dev_attr.attr,
++	&sensor_dev_attr_in9_input.dev_attr.attr,
++	&sensor_dev_attr_in10_input.dev_attr.attr,
++	&sensor_dev_attr_in11_input.dev_attr.attr,
++	&sensor_dev_attr_in12_input.dev_attr.attr,
++
++	&sensor_dev_attr_temp0_label.dev_attr.attr,
++	&sensor_dev_attr_in0_label.dev_attr.attr,
++	&sensor_dev_attr_in1_label.dev_attr.attr,
++	&sensor_dev_attr_in2_label.dev_attr.attr,
++	&sensor_dev_attr_in3_label.dev_attr.attr,
++	&sensor_dev_attr_in4_label.dev_attr.attr,
++	&sensor_dev_attr_in5_label.dev_attr.attr,
++	&sensor_dev_attr_in6_label.dev_attr.attr,
++	&sensor_dev_attr_in7_label.dev_attr.attr,
++	&sensor_dev_attr_in8_label.dev_attr.attr,
++	&sensor_dev_attr_in9_label.dev_attr.attr,
++	&sensor_dev_attr_in10_label.dev_attr.attr,
++	&sensor_dev_attr_in11_label.dev_attr.attr,
++	&sensor_dev_attr_in12_label.dev_attr.attr,
++
++	&sensor_dev_attr_fan0_point0.dev_attr.attr,
++	&sensor_dev_attr_fan0_point1.dev_attr.attr,
++	&sensor_dev_attr_fan0_point2.dev_attr.attr,
++	&sensor_dev_attr_fan0_point3.dev_attr.attr,
++	&sensor_dev_attr_fan0_point4.dev_attr.attr,
++	&sensor_dev_attr_fan0_point5.dev_attr.attr,
++	NULL
++};
++
++
++static int gsp_probe(struct i2c_client *client,
++			 const struct i2c_device_id *id)
++{
++	struct i2c_adapter *adapter = client->adapter;
++	struct gsp_data *data;
++	int err;
++
++	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA |
++					I2C_FUNC_SMBUS_WORD_DATA)) {
++		err = -EOPNOTSUPP;
++		goto exit;
++	}
++
++	if (!(data = kzalloc(sizeof(struct gsp_data), GFP_KERNEL))) {
++		err = -ENOMEM;
++		goto exit;
++	}
++
++	i2c_set_clientdata(client, data);
++
++	data->type = id->driver_data;
++
++	switch (data->type) {
++	case 0:
++		data->attrs.attrs = gsp_attributes;
++		break;
++	}
++
++	dev_info(&client->dev, "%s chip found\n", client->name);
++
++	/* Register sysfs hooks */
++	if ((err = sysfs_create_group(&client->dev.kobj, &data->attrs)))
++		goto exit_free;
++
++	data->hwmon_dev = hwmon_device_register(&client->dev);
++	if (IS_ERR(data->hwmon_dev)) {
++		err = PTR_ERR(data->hwmon_dev);
++		goto exit_remove;
++	}
++
++	return 0;
++
++exit_remove:
++	sysfs_remove_group(&client->dev.kobj, &data->attrs);
++exit_free:
++	kfree(data);
++exit:
++	return err;
++}
++
++static int gsp_remove(struct i2c_client *client)
++{
++	struct gsp_data *data = i2c_get_clientdata(client);
++	hwmon_device_unregister(data->hwmon_dev);
++	sysfs_remove_group(&client->dev.kobj, &data->attrs);
++	kfree(data);
++	return 0;
++}
++
++static int __init gsp_init(void)
++{
++	return i2c_add_driver(&gsp_driver);
++}
++
++static void __exit gsp_exit(void)
++{
++	i2c_del_driver(&gsp_driver);
++}
++
++module_init(gsp_init);
++module_exit(gsp_exit);
++
++MODULE_AUTHOR("Chris Lang <clang@gateworks.com>");
++MODULE_DESCRIPTION("GSP HWMON driver");
++MODULE_LICENSE("GPL");
++MODULE_VERSION(DRV_VERSION);
++
+--- a/drivers/hwmon/Kconfig
++++ b/drivers/hwmon/Kconfig
+@@ -68,6 +68,15 @@ config SENSORS_ABITUGURU3
+ 	  This driver can also be built as a module.  If so, the module
+ 	  will be called abituguru3.
+ 
++config SENSORS_GSP
++  tristate "Gateworks System Peripheral"
++  depends on I2C && EXPERIMENTAL
++  help
++    If you say yes here you get support for the Gateworks System Peripherals.
++
++    This driver can also be built as a module. If so, the module
++    will be called gsp.
++
+ config SENSORS_AD7414
+ 	tristate "Analog Devices AD7414"
+ 	depends on I2C && EXPERIMENTAL
+--- a/drivers/hwmon/Makefile
++++ b/drivers/hwmon/Makefile
+@@ -19,6 +19,7 @@ obj-$(CONFIG_SENSORS_W83791D)	+= w83791d
+ 
+ obj-$(CONFIG_SENSORS_ABITUGURU)	+= abituguru.o
+ obj-$(CONFIG_SENSORS_ABITUGURU3)+= abituguru3.o
++obj-$(CONFIG_SENSORS_GSP)	+= gsp.o
+ obj-$(CONFIG_SENSORS_AD7414)	+= ad7414.o
+ obj-$(CONFIG_SENSORS_AD7418)	+= ad7418.o
+ obj-$(CONFIG_SENSORS_ADCXX)	+= adcxx.o
Index: trunk/target/linux/davinci/patches-2.6.32/205-tvp5150.patch
===================================================================
--- trunk/target/linux/davinci/patches-2.6.32/205-tvp5150.patch	(revision 0)
+++ trunk/target/linux/davinci/patches-2.6.32/205-tvp5150.patch	(revision 0)
@@ -0,0 +1,2162 @@
+--- a/drivers/media/video/tvp5150.c
++++ b/drivers/media/video/tvp5150.c
+@@ -1,1121 +1,1184 @@
+ /*
+- * tvp5150 - Texas Instruments TVP5150A/AM1 video decoder driver
++ * drivers/media/video/tvp5150.c
++ *
++ * TI TVP5146/47 decoder driver
++ *
++ * Copyright (C) 2008 Texas Instruments Inc
++ * Author: Vaibhav Hiremath <hvaibhav@ti.com>
++ *
++ * Contributors:
++ *     Sivaraj R <sivaraj@ti.com>
++ *     Brijesh R Jadav <brijesh.j@ti.com>
++ *     Hardik Shah <hardik.shah@ti.com>
++ *     Manjunath Hadli <mrh@ti.com>
++ *     Karicheri Muralidharan <m-karicheri2@ti.com>
++ *
++ * This package is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+  *
+- * Copyright (c) 2005,2006 Mauro Carvalho Chehab (mchehab@infradead.org)
+- * This code is placed under the terms of the GNU General Public License v2
+  */
+ 
+ #include <linux/i2c.h>
+-#include <linux/videodev2.h>
+ #include <linux/delay.h>
++#include <linux/videodev2.h>
++
+ #include <media/v4l2-device.h>
+-#include <media/tvp5150.h>
+-#include <media/v4l2-i2c-drv.h>
++#include <media/v4l2-common.h>
+ #include <media/v4l2-chip-ident.h>
++#include <media/tvp5150.h>
+ 
+ #include "tvp5150_reg.h"
+ 
+-MODULE_DESCRIPTION("Texas Instruments TVP5150A video decoder driver");
+-MODULE_AUTHOR("Mauro Carvalho Chehab");
+-MODULE_LICENSE("GPL");
++/* Module Name */
++#define tvp5150_MODULE_NAME		"tvp5150"
+ 
++/* Private macros for TVP */
++#define I2C_RETRY_COUNT                 (5)
++#define LOCK_RETRY_COUNT                (5)
++#define LOCK_RETRY_DELAY                (200)
++
++/* Debug functions */
++static int debug = 5;
++module_param(debug, bool, 0644);
++MODULE_PARM_DESC(debug, "Debug level (0-1)");
+ 
+-static int debug;
+-module_param(debug, int, 0);
+-MODULE_PARM_DESC(debug, "Debug level (0-2)");
++MODULE_AUTHOR("Chris Lang");
++MODULE_DESCRIPTION("TVP5150 linux decoder driver");
++MODULE_LICENSE("GPL");
+ 
+-/* supported controls */
+-static struct v4l2_queryctrl tvp5150_qctrl[] = {
+-	{
+-		.id = V4L2_CID_BRIGHTNESS,
+-		.type = V4L2_CTRL_TYPE_INTEGER,
+-		.name = "Brightness",
+-		.minimum = 0,
+-		.maximum = 255,
+-		.step = 1,
+-		.default_value = 128,
+-		.flags = 0,
+-	}, {
+-		.id = V4L2_CID_CONTRAST,
+-		.type = V4L2_CTRL_TYPE_INTEGER,
+-		.name = "Contrast",
+-		.minimum = 0,
+-		.maximum = 255,
+-		.step = 0x1,
+-		.default_value = 128,
+-		.flags = 0,
+-	}, {
+-		 .id = V4L2_CID_SATURATION,
+-		 .type = V4L2_CTRL_TYPE_INTEGER,
+-		 .name = "Saturation",
+-		 .minimum = 0,
+-		 .maximum = 255,
+-		 .step = 0x1,
+-		 .default_value = 128,
+-		 .flags = 0,
+-	}, {
+-		.id = V4L2_CID_HUE,
+-		.type = V4L2_CTRL_TYPE_INTEGER,
+-		.name = "Hue",
+-		.minimum = -128,
+-		.maximum = 127,
+-		.step = 0x1,
+-		.default_value = 0,
+-		.flags = 0,
+-	}
++/* enum tvp5150_std - enum for supported standards */
++enum tvp5150_std {
++	STD_NTSC_MJ = 0,
++	STD_PAL_BDGHIN,
++	STD_INVALID
++};
++
++/**
++ * struct tvp5150_std_info - Structure to store standard informations
++ * @width: Line width in pixels
++ * @height:Number of active lines
++ * @video_std: Value to write in REG_VIDEO_STD register
++ * @standard: v4l2 standard structure information
++ */
++struct tvp5150_std_info {
++	unsigned long width;
++	unsigned long height;
++	u8 video_std;
++	struct v4l2_standard standard;
+ };
+ 
+-struct tvp5150 {
++static struct tvp5150_reg tvp5150_reg_list_default[0x40];
++/**
++ * struct tvp5150_decoder - TVP5146/47 decoder object
++ * @sd: Subdevice Slave handle
++ * @tvp5150_regs: copy of hw's regs with preset values.
++ * @pdata: Board specific
++ * @ver: Chip version
++ * @streaming: TVP5146/47 decoder streaming - enabled or disabled.
++ * @pix: Current pixel format
++ * @num_fmts: Number of formats
++ * @fmt_list: Format list
++ * @current_std: Current standard
++ * @num_stds: Number of standards
++ * @std_list: Standards list
++ * @input: Input routing at chip level
++ * @output: Output routing at chip level
++ */
++struct tvp5150_decoder {
+ 	struct v4l2_subdev sd;
++	struct tvp5150_reg tvp5150_regs[ARRAY_SIZE(tvp5150_reg_list_default)];
++	const struct tvp5150_platform_data *pdata;
++
++	int ver;
++	int streaming;
+ 
+-	v4l2_std_id norm;	/* Current set standard */
++	struct v4l2_pix_format pix;
++	int num_fmts;
++	const struct v4l2_fmtdesc *fmt_list;
++
++	enum tvp5150_std current_std;
++	int num_stds;
++	struct tvp5150_std_info *std_list;
++	/* Input and Output Routing parameters */
+ 	u32 input;
+ 	u32 output;
+-	int enable;
+-	int bright;
+-	int contrast;
+-	int hue;
+-	int sat;
+ };
+ 
+-static inline struct tvp5150 *to_tvp5150(struct v4l2_subdev *sd)
+-{
+-	return container_of(sd, struct tvp5150, sd);
+-}
++/* tvp5150 default register values */
++static struct tvp5150_reg tvp5150_reg_list_default[] = {
++	{TOK_WRITE, TVP5150_VD_IN_SRC_SEL_1, 0x00},
++	{TOK_WRITE, TVP5150_ANAL_CHL_CTL, 0x15},
++	{TOK_WRITE, TVP5150_OP_MODE_CTL, 0x00},
++	{TOK_WRITE, TVP5150_MISC_CTL, 0x0d},
++	{TOK_WRITE, TVP5150_COLOR_KIL_THSH_CTL, 0x10},
++	{TOK_WRITE, TVP5150_LUMA_PROC_CTL_1, 0x60},
++	{TOK_WRITE, TVP5150_LUMA_PROC_CTL_2, 0x00},
++	{TOK_WRITE, TVP5150_BRIGHT_CTL, 0x80},
++	{TOK_WRITE, TVP5150_SATURATION_CTL, 0x80},
++	{TOK_WRITE, TVP5150_HUE_CTL, 0x80},
++	{TOK_WRITE, TVP5150_CONTRAST_CTL, 0x80},
++	{TOK_WRITE, TVP5150_DATA_RATE_SEL, 0x47},
++	{TOK_WRITE, TVP5150_LUMA_PROC_CTL_3, 0x00},
++	{TOK_WRITE, TVP5150_CONF_SHARED_PIN, 0x08},
++	{TOK_WRITE, TVP5150_ACT_VD_CROP_ST_MSB, 0x00},
++	{TOK_WRITE, TVP5150_ACT_VD_CROP_ST_LSB, 0x00},
++	{TOK_WRITE, TVP5150_ACT_VD_CROP_STP_MSB, 0x00},
++	{TOK_WRITE, TVP5150_ACT_VD_CROP_STP_LSB, 0x00},
++	{TOK_WRITE, TVP5150_GENLOCK, 0x01},
++	{TOK_WRITE, TVP5150_HORIZ_SYNC_START, 0x80},
++	{TOK_WRITE, TVP5150_VERT_BLANKING_START, 0x00},
++	{TOK_WRITE, TVP5150_VERT_BLANKING_STOP, 0x00},
++	{TOK_WRITE, TVP5150_CHROMA_PROC_CTL_1, 0x0c},
++	{TOK_WRITE, TVP5150_CHROMA_PROC_CTL_2, 0x14},
++	{TOK_WRITE, TVP5150_INT_RESET_REG_B, 0x00},
++	{TOK_WRITE, TVP5150_INT_ENABLE_REG_B, 0x00},
++	{TOK_WRITE, TVP5150_INTT_CONFIG_REG_B, 0x00},
++	{TOK_WRITE, TVP5150_VIDEO_STD, 0x00},
++	{TOK_WRITE, TVP5150_MACROVISION_ON_CTR, 0x0f},
++	{TOK_WRITE, TVP5150_MACROVISION_OFF_CTR, 0x01},
++	{TOK_WRITE, TVP5150_TELETEXT_FIL_ENA, 0x00},
++	{TOK_WRITE, TVP5150_INT_STATUS_REG_A, 0x00},
++	{TOK_WRITE, TVP5150_INT_ENABLE_REG_A, 0x00},
++	{TOK_WRITE, TVP5150_INT_CONF, 0x04},
++	{TOK_WRITE, TVP5150_FIFO_INT_THRESHOLD, 0x80},
++	{TOK_WRITE, TVP5150_FIFO_RESET, 0x00},
++	{TOK_WRITE, TVP5150_LINE_NUMBER_INT, 0x00},
++	{TOK_WRITE, TVP5150_PIX_ALIGN_REG_LOW, 0x4e},
++	{TOK_WRITE, TVP5150_PIX_ALIGN_REG_HIGH, 0x00},
++	{TOK_WRITE, TVP5150_FIFO_OUT_CTRL, 0x01},
++	{TOK_WRITE, TVP5150_FULL_FIELD_ENA, 0x00},
++	{TOK_WRITE, TVP5150_LINE_MODE_INI, 0x00},
++	{TOK_WRITE, TVP5150_FULL_FIELD_MODE_REG, 0x7f},
++	{TOK_TERM, 0, 0},
++};
++
++/**
++ * List of image formats supported by TVP5146/47 decoder
++ * Currently we are using 8 bit mode only, but can be
++ * extended to 10/20 bit mode.
++ */
++static const struct v4l2_fmtdesc tvp5150_fmt_list[] = {
++	{
++	 .index = 0,
++	 .type = V4L2_BUF_TYPE_VIDEO_CAPTURE,
++	 .flags = 0,
++	 .description = "8-bit UYVY 4:2:2 Format",
++	 .pixelformat = V4L2_PIX_FMT_UYVY,
++	},
++};
++
++/**
++ * Supported standards -
++ *
++ * Currently supports two standards only, need to add support for rest of the
++ * modes, like SECAM, etc...
++ */
++static struct tvp5150_std_info tvp5150_std_list[] = {
++	/* Standard: STD_NTSC_MJ */
++	[STD_NTSC_MJ] = {
++	 .width = NTSC_NUM_ACTIVE_PIXELS,
++	 .height = NTSC_NUM_ACTIVE_LINES,
++	 .video_std = VIDEO_STD_NTSC_MJ_BIT,
++	 .standard = {
++		      .index = 0,
++		      .id = V4L2_STD_NTSC,
++		      .name = "NTSC",
++		      .frameperiod = {1001, 30000},
++		      .framelines = 525
++		     },
++	/* Standard: STD_PAL_BDGHIN */
++	},
++	[STD_PAL_BDGHIN] = {
++	 .width = PAL_NUM_ACTIVE_PIXELS,
++	 .height = PAL_NUM_ACTIVE_LINES,
++	 .video_std = VIDEO_STD_PAL_BDGHIN_BIT,
++	 .standard = {
++		      .index = 1,
++		      .id = V4L2_STD_PAL,
++		      .name = "PAL",
++		      .frameperiod = {1, 25},
++		      .framelines = 625
++		     },
++	},
++	/* Standard: need to add for additional standard */
++};
+ 
+-static int tvp5150_read(struct v4l2_subdev *sd, unsigned char addr)
++
++static inline struct tvp5150_decoder *to_decoder(struct v4l2_subdev *sd)
+ {
+-	struct i2c_client *c = v4l2_get_subdevdata(sd);
+-	unsigned char buffer[1];
+-	int rc;
++	return container_of(sd, struct tvp5150_decoder, sd);
++}
+ 
+-	buffer[0] = addr;
+-	if (1 != (rc = i2c_master_send(c, buffer, 1)))
+-		v4l2_dbg(0, debug, sd, "i2c i/o error: rc == %d (should be 1)\n", rc);
+ 
+-	msleep(10);
++/**
++ * tvp5150_read_reg() - Read a value from a register in an TVP5146/47.
++ * @sd: ptr to v4l2_subdev struct
++ * @reg: TVP5146/47 register address
++ *
++ * Returns value read if successful, or non-zero (-1) otherwise.
++ */
++static int tvp5150_read_reg(struct v4l2_subdev *sd, u8 reg)
++{
++	int err, retry = 0;
++	struct i2c_client *client = v4l2_get_subdevdata(sd);
+ 
+-	if (1 != (rc = i2c_master_recv(c, buffer, 1)))
+-		v4l2_dbg(0, debug, sd, "i2c i/o error: rc == %d (should be 1)\n", rc);
++read_again:
+ 
+-	v4l2_dbg(2, debug, sd, "tvp5150: read 0x%02x = 0x%02x\n", addr, buffer[0]);
++	err = i2c_smbus_read_byte_data(client, reg);
++	if (err == -1) {
++		if (retry <= I2C_RETRY_COUNT) {
++			v4l2_warn(sd, "Read: retry ... %d\n", retry);
++			retry++;
++			msleep_interruptible(10);
++			goto read_again;
++		}
++	}
+ 
+-	return (buffer[0]);
++	return err;
+ }
+ 
+-static inline void tvp5150_write(struct v4l2_subdev *sd, unsigned char addr,
+-				 unsigned char value)
++/**
++ * dump_reg() - dump the register content of TVP5146/47.
++ * @sd: ptr to v4l2_subdev struct
++ * @reg: TVP5146/47 register address
++ */
++static void dump_reg(struct v4l2_subdev *sd, u8 reg)
+ {
+-	struct i2c_client *c = v4l2_get_subdevdata(sd);
+-	unsigned char buffer[2];
+-	int rc;
++	u32 val;
+ 
+-	buffer[0] = addr;
+-	buffer[1] = value;
+-	v4l2_dbg(2, debug, sd, "tvp5150: writing 0x%02x 0x%02x\n", buffer[0], buffer[1]);
+-	if (2 != (rc = i2c_master_send(c, buffer, 2)))
+-		v4l2_dbg(0, debug, sd, "i2c i/o error: rc == %d (should be 2)\n", rc);
++	val = tvp5150_read_reg(sd, reg);
++	v4l2_info(sd, "Reg(0x%.2X): 0x%.2X\n", reg, val);
+ }
+ 
+-static void dump_reg_range(struct v4l2_subdev *sd, char *s, u8 init,
+-				const u8 end, int max_line)
++/**
++ * tvp5150_write_reg() - Write a value to a register in TVP5146/47
++ * @sd: ptr to v4l2_subdev struct
++ * @reg: TVP5146/47 register address
++ * @val: value to be written to the register
++ *
++ * Write a value to a register in an TVP5146/47 decoder device.
++ * Returns zero if successful, or non-zero otherwise.
++ */
++static int tvp5150_write_reg(struct v4l2_subdev *sd, u8 reg, u8 val)
+ {
+-	int i = 0;
++	int err, retry = 0;
++	struct i2c_client *client = v4l2_get_subdevdata(sd);
+ 
+-	while (init != (u8)(end + 1)) {
+-		if ((i % max_line) == 0) {
+-			if (i > 0)
+-				printk("\n");
+-			printk("tvp5150: %s reg 0x%02x = ", s, init);
+-		}
+-		printk("%02x ", tvp5150_read(sd, init));
++write_again:
+ 
+-		init++;
+-		i++;
++	err = i2c_smbus_write_byte_data(client, reg, val);
++	if (err) {
++		if (retry <= I2C_RETRY_COUNT) {
++			v4l2_warn(sd, "Write: retry ... %d\n", retry);
++			retry++;
++			msleep_interruptible(10);
++			goto write_again;
++		}
+ 	}
+-	printk("\n");
++
++	return err;
+ }
+ 
+-static int tvp5150_log_status(struct v4l2_subdev *sd)
++/**
++ * tvp5150_write_regs() : Initializes a list of TVP5146/47 registers
++ * @sd: ptr to v4l2_subdev struct
++ * @reglist: list of TVP5146/47 registers and values
++ *
++ * Initializes a list of TVP5146/47 registers:-
++ *		if token is TOK_TERM, then entire write operation terminates
++ *		if token is TOK_DELAY, then a delay of 'val' msec is introduced
++ *		if token is TOK_SKIP, then the register write is skipped
++ *		if token is TOK_WRITE, then the register write is performed
++ * Returns zero if successful, or non-zero otherwise.
++ */
++static int tvp5150_write_regs(struct v4l2_subdev *sd,
++			      const struct tvp5150_reg reglist[])
+ {
+-	printk("tvp5150: Video input source selection #1 = 0x%02x\n",
+-			tvp5150_read(sd, TVP5150_VD_IN_SRC_SEL_1));
+-	printk("tvp5150: Analog channel controls = 0x%02x\n",
+-			tvp5150_read(sd, TVP5150_ANAL_CHL_CTL));
+-	printk("tvp5150: Operation mode controls = 0x%02x\n",
+-			tvp5150_read(sd, TVP5150_OP_MODE_CTL));
+-	printk("tvp5150: Miscellaneous controls = 0x%02x\n",
+-			tvp5150_read(sd, TVP5150_MISC_CTL));
+-	printk("tvp5150: Autoswitch mask= 0x%02x\n",
+-			tvp5150_read(sd, TVP5150_AUTOSW_MSK));
+-	printk("tvp5150: Color killer threshold control = 0x%02x\n",
+-			tvp5150_read(sd, TVP5150_COLOR_KIL_THSH_CTL));
+-	printk("tvp5150: Luminance processing controls #1 #2 and #3 = %02x %02x %02x\n",
+-			tvp5150_read(sd, TVP5150_LUMA_PROC_CTL_1),
+-			tvp5150_read(sd, TVP5150_LUMA_PROC_CTL_2),
+-			tvp5150_read(sd, TVP5150_LUMA_PROC_CTL_3));
+-	printk("tvp5150: Brightness control = 0x%02x\n",
+-			tvp5150_read(sd, TVP5150_BRIGHT_CTL));
+-	printk("tvp5150: Color saturation control = 0x%02x\n",
+-			tvp5150_read(sd, TVP5150_SATURATION_CTL));
+-	printk("tvp5150: Hue control = 0x%02x\n",
+-			tvp5150_read(sd, TVP5150_HUE_CTL));
+-	printk("tvp5150: Contrast control = 0x%02x\n",
+-			tvp5150_read(sd, TVP5150_CONTRAST_CTL));
+-	printk("tvp5150: Outputs and data rates select = 0x%02x\n",
+-			tvp5150_read(sd, TVP5150_DATA_RATE_SEL));
+-	printk("tvp5150: Configuration shared pins = 0x%02x\n",
+-			tvp5150_read(sd, TVP5150_CONF_SHARED_PIN));
+-	printk("tvp5150: Active video cropping start = 0x%02x%02x\n",
+-			tvp5150_read(sd, TVP5150_ACT_VD_CROP_ST_MSB),
+-			tvp5150_read(sd, TVP5150_ACT_VD_CROP_ST_LSB));
+-	printk("tvp5150: Active video cropping stop  = 0x%02x%02x\n",
+-			tvp5150_read(sd, TVP5150_ACT_VD_CROP_STP_MSB),
+-			tvp5150_read(sd, TVP5150_ACT_VD_CROP_STP_LSB));
+-	printk("tvp5150: Genlock/RTC = 0x%02x\n",
+-			tvp5150_read(sd, TVP5150_GENLOCK));
+-	printk("tvp5150: Horizontal sync start = 0x%02x\n",
+-			tvp5150_read(sd, TVP5150_HORIZ_SYNC_START));
+-	printk("tvp5150: Vertical blanking start = 0x%02x\n",
+-			tvp5150_read(sd, TVP5150_VERT_BLANKING_START));
+-	printk("tvp5150: Vertical blanking stop = 0x%02x\n",
+-			tvp5150_read(sd, TVP5150_VERT_BLANKING_STOP));
+-	printk("tvp5150: Chrominance processing control #1 and #2 = %02x %02x\n",
+-			tvp5150_read(sd, TVP5150_CHROMA_PROC_CTL_1),
+-			tvp5150_read(sd, TVP5150_CHROMA_PROC_CTL_2));
+-	printk("tvp5150: Interrupt reset register B = 0x%02x\n",
+-			tvp5150_read(sd, TVP5150_INT_RESET_REG_B));
+-	printk("tvp5150: Interrupt enable register B = 0x%02x\n",
+-			tvp5150_read(sd, TVP5150_INT_ENABLE_REG_B));
+-	printk("tvp5150: Interrupt configuration register B = 0x%02x\n",
+-			tvp5150_read(sd, TVP5150_INTT_CONFIG_REG_B));
+-	printk("tvp5150: Video standard = 0x%02x\n",
+-			tvp5150_read(sd, TVP5150_VIDEO_STD));
+-	printk("tvp5150: Chroma gain factor: Cb=0x%02x Cr=0x%02x\n",
+-			tvp5150_read(sd, TVP5150_CB_GAIN_FACT),
+-			tvp5150_read(sd, TVP5150_CR_GAIN_FACTOR));
+-	printk("tvp5150: Macrovision on counter = 0x%02x\n",
+-			tvp5150_read(sd, TVP5150_MACROVISION_ON_CTR));
+-	printk("tvp5150: Macrovision off counter = 0x%02x\n",
+-			tvp5150_read(sd, TVP5150_MACROVISION_OFF_CTR));
+-	printk("tvp5150: ITU-R BT.656.%d timing(TVP5150AM1 only)\n",
+-			(tvp5150_read(sd, TVP5150_REV_SELECT) & 1) ? 3 : 4);
+-	printk("tvp5150: Device ID = %02x%02x\n",
+-			tvp5150_read(sd, TVP5150_MSB_DEV_ID),
+-			tvp5150_read(sd, TVP5150_LSB_DEV_ID));
+-	printk("tvp5150: ROM version = (hex) %02x.%02x\n",
+-			tvp5150_read(sd, TVP5150_ROM_MAJOR_VER),
+-			tvp5150_read(sd, TVP5150_ROM_MINOR_VER));
+-	printk("tvp5150: Vertical line count = 0x%02x%02x\n",
+-			tvp5150_read(sd, TVP5150_VERT_LN_COUNT_MSB),
+-			tvp5150_read(sd, TVP5150_VERT_LN_COUNT_LSB));
+-	printk("tvp5150: Interrupt status register B = 0x%02x\n",
+-			tvp5150_read(sd, TVP5150_INT_STATUS_REG_B));
+-	printk("tvp5150: Interrupt active register B = 0x%02x\n",
+-			tvp5150_read(sd, TVP5150_INT_ACTIVE_REG_B));
+-	printk("tvp5150: Status regs #1 to #5 = %02x %02x %02x %02x %02x\n",
+-			tvp5150_read(sd, TVP5150_STATUS_REG_1),
+-			tvp5150_read(sd, TVP5150_STATUS_REG_2),
+-			tvp5150_read(sd, TVP5150_STATUS_REG_3),
+-			tvp5150_read(sd, TVP5150_STATUS_REG_4),
+-			tvp5150_read(sd, TVP5150_STATUS_REG_5));
+-
+-	dump_reg_range(sd, "Teletext filter 1",   TVP5150_TELETEXT_FIL1_INI,
+-			TVP5150_TELETEXT_FIL1_END, 8);
+-	dump_reg_range(sd, "Teletext filter 2",   TVP5150_TELETEXT_FIL2_INI,
+-			TVP5150_TELETEXT_FIL2_END, 8);
+-
+-	printk("tvp5150: Teletext filter enable = 0x%02x\n",
+-			tvp5150_read(sd, TVP5150_TELETEXT_FIL_ENA));
+-	printk("tvp5150: Interrupt status register A = 0x%02x\n",
+-			tvp5150_read(sd, TVP5150_INT_STATUS_REG_A));
+-	printk("tvp5150: Interrupt enable register A = 0x%02x\n",
+-			tvp5150_read(sd, TVP5150_INT_ENABLE_REG_A));
+-	printk("tvp5150: Interrupt configuration = 0x%02x\n",
+-			tvp5150_read(sd, TVP5150_INT_CONF));
+-	printk("tvp5150: VDP status register = 0x%02x\n",
+-			tvp5150_read(sd, TVP5150_VDP_STATUS_REG));
+-	printk("tvp5150: FIFO word count = 0x%02x\n",
+-			tvp5150_read(sd, TVP5150_FIFO_WORD_COUNT));
+-	printk("tvp5150: FIFO interrupt threshold = 0x%02x\n",
+-			tvp5150_read(sd, TVP5150_FIFO_INT_THRESHOLD));
+-	printk("tvp5150: FIFO reset = 0x%02x\n",
+-			tvp5150_read(sd, TVP5150_FIFO_RESET));
+-	printk("tvp5150: Line number interrupt = 0x%02x\n",
+-			tvp5150_read(sd, TVP5150_LINE_NUMBER_INT));
+-	printk("tvp5150: Pixel alignment register = 0x%02x%02x\n",
+-			tvp5150_read(sd, TVP5150_PIX_ALIGN_REG_HIGH),
+-			tvp5150_read(sd, TVP5150_PIX_ALIGN_REG_LOW));
+-	printk("tvp5150: FIFO output control = 0x%02x\n",
+-			tvp5150_read(sd, TVP5150_FIFO_OUT_CTRL));
+-	printk("tvp5150: Full field enable = 0x%02x\n",
+-			tvp5150_read(sd, TVP5150_FULL_FIELD_ENA));
+-	printk("tvp5150: Full field mode register = 0x%02x\n",
+-			tvp5150_read(sd, TVP5150_FULL_FIELD_MODE_REG));
+-
+-	dump_reg_range(sd, "CC   data",   TVP5150_CC_DATA_INI,
+-			TVP5150_CC_DATA_END, 8);
+-
+-	dump_reg_range(sd, "WSS  data",   TVP5150_WSS_DATA_INI,
+-			TVP5150_WSS_DATA_END, 8);
++	int err;
++	const struct tvp5150_reg *next = reglist;
+ 
+-	dump_reg_range(sd, "VPS  data",   TVP5150_VPS_DATA_INI,
+-			TVP5150_VPS_DATA_END, 8);
++	for (; next->token != TOK_TERM; next++) {
++		if (next->token == TOK_DELAY) {
++			msleep(next->val);
++			continue;
++		}
+ 
+-	dump_reg_range(sd, "VITC data",   TVP5150_VITC_DATA_INI,
+-			TVP5150_VITC_DATA_END, 10);
++		if (next->token == TOK_SKIP)
++			continue;
+ 
+-	dump_reg_range(sd, "Line mode",   TVP5150_LINE_MODE_INI,
+-			TVP5150_LINE_MODE_END, 8);
++		err = tvp5150_write_reg(sd, next->reg, (u8) next->val);
++		if (err) {
++			v4l2_err(sd, "Write failed. Err[%d]\n", err);
++			return err;
++		}
++	}
+ 	return 0;
+ }
+ 
+-/****************************************************************************
+-			Basic functions
+- ****************************************************************************/
+-
+-static inline void tvp5150_selmux(struct v4l2_subdev *sd)
+-{
+-	int opmode=0;
+-	struct tvp5150 *decoder = to_tvp5150(sd);
+-	int input = 0;
+-	unsigned char val;
++/**
++ * tvp5150_get_current_std() : Get the current standard detected by TVP5146/47
++ * @sd: ptr to v4l2_subdev struct
++ *
++ * Get current standard detected by TVP5146/47, STD_INVALID if there is no
++ * standard detected.
++ */
++static enum tvp5150_std tvp5150_get_current_std(struct v4l2_subdev *sd)
++{
++	u8 std;
+ 
+-	if ((decoder->output & TVP5150_BLACK_SCREEN) || !decoder->enable)
+-		input = 8;
++	v4l2_info(sd, "%s\n", __FUNCTION__);
+ 
+-	switch (decoder->input) {
+-	case TVP5150_COMPOSITE1:
+-		input |= 2;
+-		/* fall through */
+-	case TVP5150_COMPOSITE0:
+-		opmode=0x30;		/* TV Mode */
+-		break;
+-	case TVP5150_SVIDEO:
+-	default:
+-		input |= 1;
+-		opmode=0;		/* Auto Mode */
+-		break;
+-	}
++	msleep(LOCK_RETRY_DELAY);	
+ 
+-	v4l2_dbg(1, debug, sd, "Selecting video route: route input=%i, output=%i "
+-			"=> tvp5150 input=%i, opmode=%i\n",
+-			decoder->input, decoder->output,
+-			input, opmode);
+-
+-	tvp5150_write(sd, TVP5150_OP_MODE_CTL, opmode);
+-	tvp5150_write(sd, TVP5150_VD_IN_SRC_SEL_1, input);
+-
+-	/* Svideo should enable YCrCb output and disable GPCL output
+-	 * For Composite and TV, it should be the reverse
+-	 */
+-	val = tvp5150_read(sd, TVP5150_MISC_CTL);
+-	if (decoder->input == TVP5150_SVIDEO)
+-		val = (val & ~0x40) | 0x10;
+-	else
+-		val = (val & ~0x10) | 0x40;
+-	tvp5150_write(sd, TVP5150_MISC_CTL, val);
+-};
++	std = tvp5150_read_reg(sd, TVP5150_STATUS_REG_5);
+ 
+-struct i2c_reg_value {
+-	unsigned char reg;
+-	unsigned char value;
+-};
++	v4l2_info(sd, "Standard = %x\n", std);
+ 
+-/* Default values as sugested at TVP5150AM1 datasheet */
+-static const struct i2c_reg_value tvp5150_init_default[] = {
+-	{ /* 0x00 */
+-		TVP5150_VD_IN_SRC_SEL_1,0x00
+-	},
+-	{ /* 0x01 */
+-		TVP5150_ANAL_CHL_CTL,0x15
+-	},
+-	{ /* 0x02 */
+-		TVP5150_OP_MODE_CTL,0x00
+-	},
+-	{ /* 0x03 */
+-		TVP5150_MISC_CTL,0x01
+-	},
+-	{ /* 0x06 */
+-		TVP5150_COLOR_KIL_THSH_CTL,0x10
+-	},
+-	{ /* 0x07 */
+-		TVP5150_LUMA_PROC_CTL_1,0x60
+-	},
+-	{ /* 0x08 */
+-		TVP5150_LUMA_PROC_CTL_2,0x00
+-	},
+-	{ /* 0x09 */
+-		TVP5150_BRIGHT_CTL,0x80
+-	},
+-	{ /* 0x0a */
+-		TVP5150_SATURATION_CTL,0x80
+-	},
+-	{ /* 0x0b */
+-		TVP5150_HUE_CTL,0x00
+-	},
+-	{ /* 0x0c */
+-		TVP5150_CONTRAST_CTL,0x80
+-	},
+-	{ /* 0x0d */
+-		TVP5150_DATA_RATE_SEL,0x47
+-	},
+-	{ /* 0x0e */
+-		TVP5150_LUMA_PROC_CTL_3,0x00
+-	},
+-	{ /* 0x0f */
+-		TVP5150_CONF_SHARED_PIN,0x08
+-	},
+-	{ /* 0x11 */
+-		TVP5150_ACT_VD_CROP_ST_MSB,0x00
+-	},
+-	{ /* 0x12 */
+-		TVP5150_ACT_VD_CROP_ST_LSB,0x00
+-	},
+-	{ /* 0x13 */
+-		TVP5150_ACT_VD_CROP_STP_MSB,0x00
+-	},
+-	{ /* 0x14 */
+-		TVP5150_ACT_VD_CROP_STP_LSB,0x00
+-	},
+-	{ /* 0x15 */
+-		TVP5150_GENLOCK,0x01
+-	},
+-	{ /* 0x16 */
+-		TVP5150_HORIZ_SYNC_START,0x80
+-	},
+-	{ /* 0x18 */
+-		TVP5150_VERT_BLANKING_START,0x00
+-	},
+-	{ /* 0x19 */
+-		TVP5150_VERT_BLANKING_STOP,0x00
+-	},
+-	{ /* 0x1a */
+-		TVP5150_CHROMA_PROC_CTL_1,0x0c
+-	},
+-	{ /* 0x1b */
+-		TVP5150_CHROMA_PROC_CTL_2,0x14
+-	},
+-	{ /* 0x1c */
+-		TVP5150_INT_RESET_REG_B,0x00
+-	},
+-	{ /* 0x1d */
+-		TVP5150_INT_ENABLE_REG_B,0x00
+-	},
+-	{ /* 0x1e */
+-		TVP5150_INTT_CONFIG_REG_B,0x00
+-	},
+-	{ /* 0x28 */
+-		TVP5150_VIDEO_STD,0x00
+-	},
+-	{ /* 0x2e */
+-		TVP5150_MACROVISION_ON_CTR,0x0f
+-	},
+-	{ /* 0x2f */
+-		TVP5150_MACROVISION_OFF_CTR,0x01
+-	},
+-	{ /* 0xbb */
+-		TVP5150_TELETEXT_FIL_ENA,0x00
+-	},
+-	{ /* 0xc0 */
+-		TVP5150_INT_STATUS_REG_A,0x00
+-	},
+-	{ /* 0xc1 */
+-		TVP5150_INT_ENABLE_REG_A,0x00
+-	},
+-	{ /* 0xc2 */
+-		TVP5150_INT_CONF,0x04
+-	},
+-	{ /* 0xc8 */
+-		TVP5150_FIFO_INT_THRESHOLD,0x80
+-	},
+-	{ /* 0xc9 */
+-		TVP5150_FIFO_RESET,0x00
+-	},
+-	{ /* 0xca */
+-		TVP5150_LINE_NUMBER_INT,0x00
+-	},
+-	{ /* 0xcb */
+-		TVP5150_PIX_ALIGN_REG_LOW,0x4e
+-	},
+-	{ /* 0xcc */
+-		TVP5150_PIX_ALIGN_REG_HIGH,0x00
+-	},
+-	{ /* 0xcd */
+-		TVP5150_FIFO_OUT_CTRL,0x01
+-	},
+-	{ /* 0xcf */
+-		TVP5150_FULL_FIELD_ENA,0x00
+-	},
+-	{ /* 0xd0 */
+-		TVP5150_LINE_MODE_INI,0x00
+-	},
+-	{ /* 0xfc */
+-		TVP5150_FULL_FIELD_MODE_REG,0x7f
+-	},
+-	{ /* end of data */
+-		0xff,0xff
+-	}
+-};
+-
+-/* Default values as sugested at TVP5150AM1 datasheet */
+-static const struct i2c_reg_value tvp5150_init_enable[] = {
+-	{
+-		TVP5150_CONF_SHARED_PIN, 2
+-	},{	/* Automatic offset and AGC enabled */
+-		TVP5150_ANAL_CHL_CTL, 0x15
+-	},{	/* Activate YCrCb output 0x9 or 0xd ? */
+-		TVP5150_MISC_CTL, 0x6f
+-	},{	/* Activates video std autodetection for all standards */
+-		TVP5150_AUTOSW_MSK, 0x0
+-	},{	/* Default format: 0x47. For 4:2:2: 0x40 */
+-		TVP5150_DATA_RATE_SEL, 0x47
+-	},{
+-		TVP5150_CHROMA_PROC_CTL_1, 0x0c
+-	},{
+-		TVP5150_CHROMA_PROC_CTL_2, 0x54
+-	},{	/* Non documented, but initialized on WinTV USB2 */
+-		0x27, 0x20
+-	},{
+-		0xff,0xff
+-	}
+-};
++	switch (std & VIDEO_STD_MASK) {
++	case VIDEO_STD_NTSC_MJ_BIT:
++		return STD_NTSC_MJ;
+ 
+-struct tvp5150_vbi_type {
+-	unsigned int vbi_type;
+-	unsigned int ini_line;
+-	unsigned int end_line;
+-	unsigned int by_field :1;
+-};
++	case VIDEO_STD_PAL_BDGHIN_BIT:
++		return STD_PAL_BDGHIN;
+ 
+-struct i2c_vbi_ram_value {
+-	u16 reg;
+-	struct tvp5150_vbi_type type;
+-	unsigned char values[16];
+-};
+-
+-/* This struct have the values for each supported VBI Standard
+- * by
+- tvp5150_vbi_types should follow the same order as vbi_ram_default
+- * value 0 means rom position 0x10, value 1 means rom position 0x30
+- * and so on. There are 16 possible locations from 0 to 15.
+- */
++	default:
++		return STD_INVALID;
++	}
++	
++	return STD_INVALID;
++}
+ 
+-static struct i2c_vbi_ram_value vbi_ram_default[] =
++/* TVP5146/47 register dump function */
++static void tvp5150_reg_dump(struct v4l2_subdev *sd)
+ {
+-	/* FIXME: Current api doesn't handle all VBI types, those not
+-	   yet supported are placed under #if 0 */
+ #if 0
+-	{0x010, /* Teletext, SECAM, WST System A */
+-		{V4L2_SLICED_TELETEXT_SECAM,6,23,1},
+-		{ 0xaa, 0xaa, 0xff, 0xff, 0xe7, 0x2e, 0x20, 0x26,
+-		  0xe6, 0xb4, 0x0e, 0x00, 0x00, 0x00, 0x10, 0x00 }
+-	},
++	dump_reg(sd, REG_INPUT_SEL);
++	dump_reg(sd, REG_AFE_GAIN_CTRL);
++	dump_reg(sd, REG_VIDEO_STD);
++	dump_reg(sd, REG_OPERATION_MODE);
++	dump_reg(sd, REG_COLOR_KILLER);
++	dump_reg(sd, REG_LUMA_CONTROL1);
++	dump_reg(sd, REG_LUMA_CONTROL2);
++	dump_reg(sd, REG_LUMA_CONTROL3);
++	dump_reg(sd, REG_BRIGHTNESS);
++	dump_reg(sd, REG_CONTRAST);
++	dump_reg(sd, REG_SATURATION);
++	dump_reg(sd, REG_HUE);
++	dump_reg(sd, REG_CHROMA_CONTROL1);
++	dump_reg(sd, REG_CHROMA_CONTROL2);
++	dump_reg(sd, REG_COMP_PR_SATURATION);
++	dump_reg(sd, REG_COMP_Y_CONTRAST);
++	dump_reg(sd, REG_COMP_PB_SATURATION);
++	dump_reg(sd, REG_COMP_Y_BRIGHTNESS);
++	dump_reg(sd, REG_AVID_START_PIXEL_LSB);
++	dump_reg(sd, REG_AVID_START_PIXEL_MSB);
++	dump_reg(sd, REG_AVID_STOP_PIXEL_LSB);
++	dump_reg(sd, REG_AVID_STOP_PIXEL_MSB);
++	dump_reg(sd, REG_HSYNC_START_PIXEL_LSB);
++	dump_reg(sd, REG_HSYNC_START_PIXEL_MSB);
++	dump_reg(sd, REG_HSYNC_STOP_PIXEL_LSB);
++	dump_reg(sd, REG_HSYNC_STOP_PIXEL_MSB);
++	dump_reg(sd, REG_VSYNC_START_LINE_LSB);
++	dump_reg(sd, REG_VSYNC_START_LINE_MSB);
++	dump_reg(sd, REG_VSYNC_STOP_LINE_LSB);
++	dump_reg(sd, REG_VSYNC_STOP_LINE_MSB);
++	dump_reg(sd, REG_VBLK_START_LINE_LSB);
++	dump_reg(sd, REG_VBLK_START_LINE_MSB);
++	dump_reg(sd, REG_VBLK_STOP_LINE_LSB);
++	dump_reg(sd, REG_VBLK_STOP_LINE_MSB);
++	dump_reg(sd, REG_SYNC_CONTROL);
++	dump_reg(sd, REG_OUTPUT_FORMATTER1);
++	dump_reg(sd, REG_OUTPUT_FORMATTER2);
++	dump_reg(sd, REG_OUTPUT_FORMATTER3);
++	dump_reg(sd, REG_OUTPUT_FORMATTER4);
++	dump_reg(sd, REG_OUTPUT_FORMATTER5);
++	dump_reg(sd, REG_OUTPUT_FORMATTER6);
++	dump_reg(sd, REG_CLEAR_LOST_LOCK);
+ #endif
+-	{0x030, /* Teletext, PAL, WST System B */
+-		{V4L2_SLICED_TELETEXT_B,6,22,1},
+-		{ 0xaa, 0xaa, 0xff, 0xff, 0x27, 0x2e, 0x20, 0x2b,
+-		  0xa6, 0x72, 0x10, 0x00, 0x00, 0x00, 0x10, 0x00 }
+-	},
+-#if 0
+-	{0x050, /* Teletext, PAL, WST System C */
+-		{V4L2_SLICED_TELETEXT_PAL_C,6,22,1},
+-		{ 0xaa, 0xaa, 0xff, 0xff, 0xe7, 0x2e, 0x20, 0x22,
+-		  0xa6, 0x98, 0x0d, 0x00, 0x00, 0x00, 0x10, 0x00 }
+-	},
+-	{0x070, /* Teletext, NTSC, WST System B */
+-		{V4L2_SLICED_TELETEXT_NTSC_B,10,21,1},
+-		{ 0xaa, 0xaa, 0xff, 0xff, 0x27, 0x2e, 0x20, 0x23,
+-		  0x69, 0x93, 0x0d, 0x00, 0x00, 0x00, 0x10, 0x00 }
+-	},
+-	{0x090, /* Tetetext, NTSC NABTS System C */
+-		{V4L2_SLICED_TELETEXT_NTSC_C,10,21,1},
+-		{ 0xaa, 0xaa, 0xff, 0xff, 0xe7, 0x2e, 0x20, 0x22,
+-		  0x69, 0x93, 0x0d, 0x00, 0x00, 0x00, 0x15, 0x00 }
+-	},
+-	{0x0b0, /* Teletext, NTSC-J, NABTS System D */
+-		{V4L2_SLICED_TELETEXT_NTSC_D,10,21,1},
+-		{ 0xaa, 0xaa, 0xff, 0xff, 0xa7, 0x2e, 0x20, 0x23,
+-		  0x69, 0x93, 0x0d, 0x00, 0x00, 0x00, 0x10, 0x00 }
+-	},
+-	{0x0d0, /* Closed Caption, PAL/SECAM */
+-		{V4L2_SLICED_CAPTION_625,22,22,1},
+-		{ 0xaa, 0x2a, 0xff, 0x3f, 0x04, 0x51, 0x6e, 0x02,
+-		  0xa6, 0x7b, 0x09, 0x00, 0x00, 0x00, 0x27, 0x00 }
+-	},
+-#endif
+-	{0x0f0, /* Closed Caption, NTSC */
+-		{V4L2_SLICED_CAPTION_525,21,21,1},
+-		{ 0xaa, 0x2a, 0xff, 0x3f, 0x04, 0x51, 0x6e, 0x02,
+-		  0x69, 0x8c, 0x09, 0x00, 0x00, 0x00, 0x27, 0x00 }
+-	},
+-	{0x110, /* Wide Screen Signal, PAL/SECAM */
+-		{V4L2_SLICED_WSS_625,23,23,1},
+-		{ 0x5b, 0x55, 0xc5, 0xff, 0x00, 0x71, 0x6e, 0x42,
+-		  0xa6, 0xcd, 0x0f, 0x00, 0x00, 0x00, 0x3a, 0x00 }
+-	},
+-#if 0
+-	{0x130, /* Wide Screen Signal, NTSC C */
+-		{V4L2_SLICED_WSS_525,20,20,1},
+-		{ 0x38, 0x00, 0x3f, 0x00, 0x00, 0x71, 0x6e, 0x43,
+-		  0x69, 0x7c, 0x08, 0x00, 0x00, 0x00, 0x39, 0x00 }
+-	},
+-	{0x150, /* Vertical Interval Timecode (VITC), PAL/SECAM */
+-		{V4l2_SLICED_VITC_625,6,22,0},
+-		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f, 0x6d, 0x49,
+-		  0xa6, 0x85, 0x08, 0x00, 0x00, 0x00, 0x4c, 0x00 }
+-	},
+-	{0x170, /* Vertical Interval Timecode (VITC), NTSC */
+-		{V4l2_SLICED_VITC_525,10,20,0},
+-		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f, 0x6d, 0x49,
+-		  0x69, 0x94, 0x08, 0x00, 0x00, 0x00, 0x4c, 0x00 }
+-	},
+-#endif
+-	{0x190, /* Video Program System (VPS), PAL */
+-		{V4L2_SLICED_VPS,16,16,0},
+-		{ 0xaa, 0xaa, 0xff, 0xff, 0xba, 0xce, 0x2b, 0x0d,
+-		  0xa6, 0xda, 0x0b, 0x00, 0x00, 0x00, 0x60, 0x00 }
+-	},
+-	/* 0x1d0 User programmable */
+-
+-	/* End of struct */
+-	{ (u16)-1 }
+-};
++}
+ 
+-static int tvp5150_write_inittab(struct v4l2_subdev *sd,
+-				const struct i2c_reg_value *regs)
++/**
++ * tvp5150_configure() - Configure the TVP5146/47 registers
++ * @sd: ptr to v4l2_subdev struct
++ * @decoder: ptr to tvp5150_decoder structure
++ *
++ * Returns zero if successful, or non-zero otherwise.
++ */
++static int tvp5150_configure(struct v4l2_subdev *sd,
++		struct tvp5150_decoder *decoder)
+ {
+-	while (regs->reg != 0xff) {
+-		tvp5150_write(sd, regs->reg, regs->value);
+-		regs++;
+-	}
++	int err;
++	v4l2_info(sd, "%s\n", __FUNCTION__);
++
++	/* common register initialization */
++	err =
++	    tvp5150_write_regs(sd, decoder->tvp5150_regs);
++	if (err)
++		return err;
++
++	if (debug)
++		tvp5150_reg_dump(sd);
++
+ 	return 0;
+ }
+ 
+-static int tvp5150_vdp_init(struct v4l2_subdev *sd,
+-				const struct i2c_vbi_ram_value *regs)
++/**
++ * tvp5150_querystd() - V4L2 decoder interface handler for querystd
++ * @sd: pointer to standard V4L2 sub-device structure
++ * @std_id: standard V4L2 std_id ioctl enum
++ *
++ * Returns the current standard detected by TVP5146/47. If no active input is
++ * detected, returns -EINVAL
++ */
++static int tvp5150_querystd(struct v4l2_subdev *sd, v4l2_std_id *std_id)
+ {
+-	unsigned int i;
+-
+-	/* Disable Full Field */
+-	tvp5150_write(sd, TVP5150_FULL_FIELD_ENA, 0);
+-
+-	/* Before programming, Line mode should be at 0xff */
+-	for (i = TVP5150_LINE_MODE_INI; i <= TVP5150_LINE_MODE_END; i++)
+-		tvp5150_write(sd, i, 0xff);
++	struct tvp5150_decoder *decoder = to_decoder(sd);
++	enum tvp5150_std current_std;
++	enum tvp5150_input input_sel;
++	u8 sync_lock_status, lock_mask;
++
++	v4l2_info(sd, "%s\n", __FUNCTION__);
++	
++	/* get the current standard */
++	current_std = tvp5150_get_current_std(sd);
++	if (current_std == STD_INVALID)
++		return -EINVAL;
+ 
+-	/* Load Ram Table */
+-	while (regs->reg != (u16)-1) {
+-		tvp5150_write(sd, TVP5150_CONF_RAM_ADDR_HIGH, regs->reg >> 8);
+-		tvp5150_write(sd, TVP5150_CONF_RAM_ADDR_LOW, regs->reg);
++	input_sel = decoder->input;
+ 
+-		for (i = 0; i < 16; i++)
+-			tvp5150_write(sd, TVP5150_VDP_CONF_RAM_DATA, regs->values[i]);
++	switch (input_sel) {
++	case TVP5150_COMPOSITE1:
++	case TVP5150_COMPOSITE0:
++		lock_mask = STATUS_CLR_SUBCAR_LOCK_BIT |
++			STATUS_HORZ_SYNC_LOCK_BIT |
++			STATUS_VIRT_SYNC_LOCK_BIT;
++		break;
+ 
+-		regs++;
++	case TVP5150_SVIDEO:
++		lock_mask = STATUS_HORZ_SYNC_LOCK_BIT |
++			STATUS_VIRT_SYNC_LOCK_BIT;
++		break;
++	default:
++		return -EINVAL;
+ 	}
+-	return 0;
+-}
+ 
+-/* Fills VBI capabilities based on i2c_vbi_ram_value struct */
+-static int tvp5150_g_sliced_vbi_cap(struct v4l2_subdev *sd,
+-				struct v4l2_sliced_vbi_cap *cap)
+-{
+-	const struct i2c_vbi_ram_value *regs = vbi_ram_default;
+-	int line;
+-
+-	v4l2_dbg(1, debug, sd, "g_sliced_vbi_cap\n");
+-	memset(cap, 0, sizeof *cap);
+-
+-	while (regs->reg != (u16)-1 ) {
+-		for (line=regs->type.ini_line;line<=regs->type.end_line;line++) {
+-			cap->service_lines[0][line] |= regs->type.vbi_type;
+-		}
+-		cap->service_set |= regs->type.vbi_type;
++	/* check whether signal is locked */
++	sync_lock_status = tvp5150_read_reg(sd, TVP5150_STATUS_REG_1);
++	if (lock_mask != (sync_lock_status & lock_mask))
++		return -EINVAL;	/* No input detected */
+ 
+-		regs++;
+-	}
++	decoder->current_std = current_std;
++	*std_id = decoder->std_list[current_std].standard.id;
++
++	v4l2_dbg(1, debug, sd, "Current STD: %s",
++			decoder->std_list[current_std].standard.name);
+ 	return 0;
+ }
+ 
+-/* Set vbi processing
+- * type - one of tvp5150_vbi_types
+- * line - line to gather data
+- * fields: bit 0 field1, bit 1, field2
+- * flags (default=0xf0) is a bitmask, were set means:
+- *	bit 7: enable filtering null bytes on CC
+- *	bit 6: send data also to FIFO
+- *	bit 5: don't allow data with errors on FIFO
+- *	bit 4: enable ECC when possible
+- * pix_align = pix alignment:
+- *	LSB = field1
+- *	MSB = field2
+- */
+-static int tvp5150_set_vbi(struct v4l2_subdev *sd,
+-			const struct i2c_vbi_ram_value *regs,
+-			unsigned int type,u8 flags, int line,
+-			const int fields)
+-{
+-	struct tvp5150 *decoder = to_tvp5150(sd);
+-	v4l2_std_id std = decoder->norm;
+-	u8 reg;
+-	int pos=0;
+-
+-	if (std == V4L2_STD_ALL) {
+-		v4l2_err(sd, "VBI can't be configured without knowing number of lines\n");
+-		return 0;
+-	} else if (std & V4L2_STD_625_50) {
+-		/* Don't follow NTSC Line number convension */
+-		line += 3;
+-	}
++/**
++ * tvp5150_s_std() - V4L2 decoder interface handler for s_std
++ * @sd: pointer to standard V4L2 sub-device structure
++ * @std_id: standard V4L2 v4l2_std_id ioctl enum
++ *
++ * If std_id is supported, sets the requested standard. Otherwise, returns
++ * -EINVAL
++ */
++static int tvp5150_s_std(struct v4l2_subdev *sd, v4l2_std_id std_id)
++{
++	struct tvp5150_decoder *decoder = to_decoder(sd);
++	int err, i;
+ 
+-	if (line<6||line>27)
+-		return 0;
++	v4l2_info(sd, "%s\n", __FUNCTION__);
+ 
+-	while (regs->reg != (u16)-1 ) {
+-		if ((type & regs->type.vbi_type) &&
+-		    (line>=regs->type.ini_line) &&
+-		    (line<=regs->type.end_line)) {
+-			type=regs->type.vbi_type;
++	for (i = 0; i < decoder->num_stds; i++)
++		if (std_id & decoder->std_list[i].standard.id)
+ 			break;
+-		}
+ 
+-		regs++;
+-		pos++;
+-	}
+-	if (regs->reg == (u16)-1)
+-		return 0;
+-
+-	type=pos | (flags & 0xf0);
+-	reg=((line-6)<<1)+TVP5150_LINE_MODE_INI;
+-
+-	if (fields&1) {
+-		tvp5150_write(sd, reg, type);
+-	}
++	if ((i == decoder->num_stds) || (i == STD_INVALID))
++		return -EINVAL;
+ 
+-	if (fields&2) {
+-		tvp5150_write(sd, reg+1, type);
+-	}
++	err = tvp5150_write_reg(sd, TVP5150_VIDEO_STD,
++				decoder->std_list[i].video_std);
++	if (err)
++		return err;
++
++	decoder->current_std = i;
++	decoder->tvp5150_regs[TVP5150_VIDEO_STD].val =
++		decoder->std_list[i].video_std;
+ 
+-	return type;
++	v4l2_dbg(1, debug, sd, "Standard set to: %s",
++			decoder->std_list[i].standard.name);
++	return 0;
+ }
+ 
+-static int tvp5150_get_vbi(struct v4l2_subdev *sd,
+-			const struct i2c_vbi_ram_value *regs, int line)
++/**
++ * tvp5150_s_routing() - V4L2 decoder interface handler for s_routing
++ * @sd: pointer to standard V4L2 sub-device structure
++ * @input: input selector for routing the signal
++ * @output: output selector for routing the signal
++ * @config: config value. Not used
++ *
++ * If index is valid, selects the requested input. Otherwise, returns -EINVAL if
++ * the input is not supported or there is no active signal present in the
++ * selected input.
++ */
++static int tvp5150_s_routing(struct v4l2_subdev *sd,
++				u32 input, u32 output, u32 config)
+ {
+-	struct tvp5150 *decoder = to_tvp5150(sd);
+-	v4l2_std_id std = decoder->norm;
+-	u8 reg;
+-	int pos, type = 0;
++	struct tvp5150_decoder *decoder = to_decoder(sd);
++	int err;
++	int in = 0;
++	int opmode = 0;
+ 
+-	if (std == V4L2_STD_ALL) {
+-		v4l2_err(sd, "VBI can't be configured without knowing number of lines\n");
+-		return 0;
+-	} else if (std & V4L2_STD_625_50) {
+-		/* Don't follow NTSC Line number convension */
+-		line += 3;
+-	}
++	v4l2_info(sd, "%s\n", __FUNCTION__);
+ 
+-	if (line < 6 || line > 27)
+-		return 0;
+-
+-	reg = ((line - 6) << 1) + TVP5150_LINE_MODE_INI;
++	if ((decoder->output & TVP5150_BLACK_SCREEN) || !decoder->streaming)
++		in = 8;
+ 
+-	pos = tvp5150_read(sd, reg) & 0x0f;
+-	if (pos < 0x0f)
+-		type = regs[pos].type.vbi_type;
+-
+-	pos = tvp5150_read(sd, reg + 1) & 0x0f;
+-	if (pos < 0x0f)
+-		type |= regs[pos].type.vbi_type;
+-
+-	return type;
+-}
+-
+-static int tvp5150_set_std(struct v4l2_subdev *sd, v4l2_std_id std)
+-{
+-	struct tvp5150 *decoder = to_tvp5150(sd);
+-	int fmt = 0;
+-
+-	decoder->norm = std;
+-
+-	/* First tests should be against specific std */
+-
+-	if (std == V4L2_STD_ALL) {
+-		fmt = 0;	/* Autodetect mode */
+-	} else if (std & V4L2_STD_NTSC_443) {
+-		fmt = 0xa;
+-	} else if (std & V4L2_STD_PAL_M) {
+-		fmt = 0x6;
+-	} else if (std & (V4L2_STD_PAL_N | V4L2_STD_PAL_Nc)) {
+-		fmt = 0x8;
+-	} else {
+-		/* Then, test against generic ones */
+-		if (std & V4L2_STD_NTSC)
+-			fmt = 0x2;
+-		else if (std & V4L2_STD_PAL)
+-			fmt = 0x4;
+-		else if (std & V4L2_STD_SECAM)
+-			fmt = 0xc;
++	switch (decoder->input) {
++	case TVP5150_COMPOSITE1:
++		in |= 2;
++		/* fall through */
++	case TVP5150_COMPOSITE0:
++		opmode=0x30;    /* TV Mode */
++		break;
++	case TVP5150_SVIDEO:
++	default:
++		in |= 1;
++		opmode=0;   /* Auto Mode */
++		break;
+ 	}
+ 
+-	v4l2_dbg(1, debug, sd, "Set video std register to %d.\n", fmt);
+-	tvp5150_write(sd, TVP5150_VIDEO_STD, fmt);
++	tvp5150_write_reg(sd, TVP5150_OP_MODE_CTL, opmode);
++	tvp5150_write_reg(sd, TVP5150_VD_IN_SRC_SEL_1, in);
++    
+ 	return 0;
+ }
+ 
+-static int tvp5150_s_std(struct v4l2_subdev *sd, v4l2_std_id std)
++/**
++ * tvp5150_queryctrl() - V4L2 decoder interface handler for queryctrl
++ * @sd: pointer to standard V4L2 sub-device structure
++ * @qctrl: standard V4L2 v4l2_queryctrl structure
++ *
++ * If the requested control is supported, returns the control information.
++ * Otherwise, returns -EINVAL if the control is not supported.
++ */
++static int
++tvp5150_queryctrl(struct v4l2_subdev *sd, struct v4l2_queryctrl *qctrl)
+ {
+-	struct tvp5150 *decoder = to_tvp5150(sd);
++	int err = -EINVAL;
+ 
+-	if (decoder->norm == std)
+-		return 0;
+-
+-	return tvp5150_set_std(sd, std);
+-}
++	v4l2_info(sd, "%s\n", __FUNCTION__);
+ 
+-static int tvp5150_reset(struct v4l2_subdev *sd, u32 val)
+-{
+-	struct tvp5150 *decoder = to_tvp5150(sd);
+-	u8 msb_id, lsb_id, msb_rom, lsb_rom;
++	if (qctrl == NULL)
++		return err;
+ 
+-	msb_id = tvp5150_read(sd, TVP5150_MSB_DEV_ID);
+-	lsb_id = tvp5150_read(sd, TVP5150_LSB_DEV_ID);
+-	msb_rom = tvp5150_read(sd, TVP5150_ROM_MAJOR_VER);
+-	lsb_rom = tvp5150_read(sd, TVP5150_ROM_MINOR_VER);
+-
+-	if (msb_rom == 4 && lsb_rom == 0) { /* Is TVP5150AM1 */
+-		v4l2_info(sd, "tvp%02x%02xam1 detected.\n", msb_id, lsb_id);
+-
+-		/* ITU-T BT.656.4 timing */
+-		tvp5150_write(sd, TVP5150_REV_SELECT, 0);
+-	} else {
+-		if (msb_rom == 3 || lsb_rom == 0x21) { /* Is TVP5150A */
+-			v4l2_info(sd, "tvp%02x%02xa detected.\n", msb_id, lsb_id);
+-		} else {
+-			v4l2_info(sd, "*** unknown tvp%02x%02x chip detected.\n",
+-					msb_id, lsb_id);
+-			v4l2_info(sd, "*** Rom ver is %d.%d\n", msb_rom, lsb_rom);
+-		}
++	switch (qctrl->id) {
++	case V4L2_CID_BRIGHTNESS:
++		/* Brightness supported is (0-255), */
++		err = v4l2_ctrl_query_fill(qctrl, 0, 255, 1, 128);
++		break;
++	case V4L2_CID_CONTRAST:
++	case V4L2_CID_SATURATION:
++		/**
++		 * Saturation and Contrast supported is -
++		 *	Contrast: 0 - 255 (Default - 128)
++		 *	Saturation: 0 - 255 (Default - 128)
++		 */
++		err = v4l2_ctrl_query_fill(qctrl, 0, 255, 1, 128);
++		break;
++	case V4L2_CID_HUE:
++		/* Hue Supported is -
++		 *	Hue - -180 - +180 (Default - 0, Step - +180)
++		 */
++		err = v4l2_ctrl_query_fill(qctrl, -180, 180, 180, 0);
++		break;
++	case V4L2_CID_AUTOGAIN:
++		/**
++		 * Auto Gain supported is -
++		 * 	0 - 1 (Default - 1)
++		 */
++		err = v4l2_ctrl_query_fill(qctrl, 0, 1, 1, 1);
++		break;
++	default:
++		v4l2_err(sd, "invalid control id %d\n", qctrl->id);
++		return err;
+ 	}
+ 
+-	/* Initializes TVP5150 to its default values */
+-	tvp5150_write_inittab(sd, tvp5150_init_default);
+-
+-	/* Initializes VDP registers */
+-	tvp5150_vdp_init(sd, vbi_ram_default);
++	v4l2_dbg(1, debug, sd, "Query Control:%s: Min - %d, Max - %d, Def - %d",
++			qctrl->name, qctrl->minimum, qctrl->maximum,
++			qctrl->default_value);
+ 
+-	/* Selects decoder input */
+-	tvp5150_selmux(sd);
+-
+-	/* Initializes TVP5150 to stream enabled values */
+-	tvp5150_write_inittab(sd, tvp5150_init_enable);
++	return err;
++}
+ 
+-	/* Initialize image preferences */
+-	tvp5150_write(sd, TVP5150_BRIGHT_CTL, decoder->bright);
+-	tvp5150_write(sd, TVP5150_CONTRAST_CTL, decoder->contrast);
+-	tvp5150_write(sd, TVP5150_SATURATION_CTL, decoder->contrast);
+-	tvp5150_write(sd, TVP5150_HUE_CTL, decoder->hue);
++/**
++ * tvp5150_g_ctrl() - V4L2 decoder interface handler for g_ctrl
++ * @sd: pointer to standard V4L2 sub-device structure
++ * @ctrl: pointer to v4l2_control structure
++ *
++ * If the requested control is supported, returns the control's current
++ * value from the decoder. Otherwise, returns -EINVAL if the control is not
++ * supported.
++ */
++static int
++tvp5150_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
++{
++	struct tvp5150_decoder *decoder = to_decoder(sd);
+ 
+-	tvp5150_set_std(sd, decoder->norm);
+-	return 0;
+-};
++	v4l2_info(sd, "%s\n", __FUNCTION__);
+ 
+-static int tvp5150_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+-{
+-	v4l2_dbg(1, debug, sd, "g_ctrl called\n");
++	if (ctrl == NULL)
++		return -EINVAL;
+ 
+ 	switch (ctrl->id) {
+ 	case V4L2_CID_BRIGHTNESS:
+-		ctrl->value = tvp5150_read(sd, TVP5150_BRIGHT_CTL);
+-		return 0;
++		ctrl->value = decoder->tvp5150_regs[TVP5150_BRIGHT_CTL].val;
++		break;
+ 	case V4L2_CID_CONTRAST:
+-		ctrl->value = tvp5150_read(sd, TVP5150_CONTRAST_CTL);
+-		return 0;
++		ctrl->value = decoder->tvp5150_regs[TVP5150_CONTRAST_CTL].val;
++		break;
+ 	case V4L2_CID_SATURATION:
+-		ctrl->value = tvp5150_read(sd, TVP5150_SATURATION_CTL);
+-		return 0;
++		ctrl->value = decoder->tvp5150_regs[TVP5150_SATURATION_CTL].val;
++		break;
+ 	case V4L2_CID_HUE:
+-		ctrl->value = tvp5150_read(sd, TVP5150_HUE_CTL);
+-		return 0;
++		ctrl->value = decoder->tvp5150_regs[TVP5150_HUE_CTL].val;
++		if (ctrl->value == 0x7F)
++			ctrl->value = 180;
++		else if (ctrl->value == 0x80)
++			ctrl->value = -180;
++		else
++			ctrl->value = 0;
++
++		break;
++	case V4L2_CID_AUTOGAIN:
++		ctrl->value = decoder->tvp5150_regs[TVP5150_ANAL_CHL_CTL].val;
++		if ((ctrl->value & 0xf) == 0x5)
++			ctrl->value = 1;
++		else
++			ctrl->value = 0;
++
++		break;
++	default:
++		v4l2_err(sd, "invalid control id %d\n", ctrl->id);
++		return -EINVAL;
+ 	}
+-	return -EINVAL;
++
++	v4l2_dbg(1, debug, sd, "Get Control: ID - %d - %d",
++			ctrl->id, ctrl->value);
++	return 0;
+ }
+ 
+-static int tvp5150_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
++/**
++ * tvp5150_s_ctrl() - V4L2 decoder interface handler for s_ctrl
++ * @sd: pointer to standard V4L2 sub-device structure
++ * @ctrl: pointer to v4l2_control structure
++ *
++ * If the requested control is supported, sets the control's current
++ * value in HW. Otherwise, returns -EINVAL if the control is not supported.
++ */
++static int
++tvp5150_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+ {
+-	u8 i, n;
+-	n = ARRAY_SIZE(tvp5150_qctrl);
++	struct tvp5150_decoder *decoder = to_decoder(sd);
++	int err = -EINVAL, value;
+ 
+-	for (i = 0; i < n; i++) {
+-		if (ctrl->id != tvp5150_qctrl[i].id)
+-			continue;
+-		if (ctrl->value < tvp5150_qctrl[i].minimum ||
+-		    ctrl->value > tvp5150_qctrl[i].maximum)
+-			return -ERANGE;
+-		v4l2_dbg(1, debug, sd, "s_ctrl: id=%d, value=%d\n",
+-					ctrl->id, ctrl->value);
+-		break;
+-	}
++	v4l2_info(sd, "%s\n", __FUNCTION__);
++
++	if (ctrl == NULL)
++		return err;
++
++	value = ctrl->value;
+ 
+ 	switch (ctrl->id) {
+ 	case V4L2_CID_BRIGHTNESS:
+-		tvp5150_write(sd, TVP5150_BRIGHT_CTL, ctrl->value);
+-		return 0;
++		if (ctrl->value < 0 || ctrl->value > 255) {
++			v4l2_err(sd, "invalid brightness setting %d\n",
++					ctrl->value);
++			return -ERANGE;
++		}
++		err = tvp5150_write_reg(sd, TVP5150_BRIGHT_CTL,
++				value);
++		if (err)
++			return err;
++
++		decoder->tvp5150_regs[TVP5150_BRIGHT_CTL].val = value;
++		break;
+ 	case V4L2_CID_CONTRAST:
+-		tvp5150_write(sd, TVP5150_CONTRAST_CTL, ctrl->value);
+-		return 0;
++		if (ctrl->value < 0 || ctrl->value > 255) {
++			v4l2_err(sd, "invalid contrast setting %d\n",
++					ctrl->value);
++			return -ERANGE;
++		}
++		err = tvp5150_write_reg(sd, TVP5150_CONTRAST_CTL, value);
++		if (err)
++			return err;
++
++		decoder->tvp5150_regs[TVP5150_CONTRAST_CTL].val = value;
++		break;
+ 	case V4L2_CID_SATURATION:
+-		tvp5150_write(sd, TVP5150_SATURATION_CTL, ctrl->value);
+-		return 0;
++		if (ctrl->value < 0 || ctrl->value > 255) {
++			v4l2_err(sd, "invalid saturation setting %d\n",
++					ctrl->value);
++			return -ERANGE;
++		}
++		err = tvp5150_write_reg(sd, TVP5150_SATURATION_CTL, value);
++		if (err)
++			return err;
++
++		decoder->tvp5150_regs[TVP5150_SATURATION_CTL].val = value;
++		break;
+ 	case V4L2_CID_HUE:
+-		tvp5150_write(sd, TVP5150_HUE_CTL, ctrl->value);
+-		return 0;
+-	}
+-	return -EINVAL;
+-}
++		if (value == 180)
++			value = 0x7F;
++		else if (value == -180)
++			value = 0x80;
++		else if (value == 0)
++			value = 0;
++		else {
++			v4l2_err(sd, "invalid hue setting %d\n", ctrl->value);
++			return -ERANGE;
++		}
++		err = tvp5150_write_reg(sd, TVP5150_HUE_CTL, value);
++		if (err)
++			return err;
+ 
+-/****************************************************************************
+-			I2C Command
+- ****************************************************************************/
++		decoder->tvp5150_regs[TVP5150_HUE_CTL].val = value;
++		break;
++	case V4L2_CID_AUTOGAIN:
++		if (value == 1)
++			value = 0x05;
++		else if (value == 0)
++			value = 0x00;
++		else {
++			v4l2_err(sd, "invalid auto gain setting %d\n",
++					ctrl->value);
++			return -ERANGE;
++		}
++		err = tvp5150_write_reg(sd, TVP5150_ANAL_CHL_CTL, value);
++		if (err)
++			return err;
+ 
+-static int tvp5150_s_routing(struct v4l2_subdev *sd,
+-			     u32 input, u32 output, u32 config)
+-{
+-	struct tvp5150 *decoder = to_tvp5150(sd);
++		decoder->tvp5150_regs[TVP5150_ANAL_CHL_CTL].val = value;
++		break;
++	default:
++		v4l2_err(sd, "invalid control id %d\n", ctrl->id);
++		return err;
++	}
+ 
+-	decoder->input = input;
+-	decoder->output = output;
+-	tvp5150_selmux(sd);
+-	return 0;
++	v4l2_dbg(1, debug, sd, "Set Control: ID - %d - %d",
++			ctrl->id, ctrl->value);
++
++	return err;
+ }
+ 
+-static int tvp5150_s_fmt(struct v4l2_subdev *sd, struct v4l2_format *fmt)
++/**
++ * tvp5150_enum_fmt_cap() - V4L2 decoder interface handler for enum_fmt
++ * @sd: pointer to standard V4L2 sub-device structure
++ * @fmt: standard V4L2 VIDIOC_ENUM_FMT ioctl structure
++ *
++ * Implement the VIDIOC_ENUM_FMT ioctl to enumerate supported formats
++ */
++static int
++tvp5150_enum_fmt_cap(struct v4l2_subdev *sd, struct v4l2_fmtdesc *fmt)
+ {
+-	struct v4l2_sliced_vbi_format *svbi;
+-	int i;
++	struct tvp5150_decoder *decoder = to_decoder(sd);
++	int index;
+ 
+-	/* raw vbi */
+-	if (fmt->type == V4L2_BUF_TYPE_VBI_CAPTURE) {
+-		/* this is for capturing 36 raw vbi lines
+-		   if there's a way to cut off the beginning 2 vbi lines
+-		   with the tvp5150 then the vbi line count could be lowered
+-		   to 17 lines/field again, although I couldn't find a register
+-		   which could do that cropping */
+-		if (fmt->fmt.vbi.sample_format == V4L2_PIX_FMT_GREY)
+-			tvp5150_write(sd, TVP5150_LUMA_PROC_CTL_1, 0x70);
+-		if (fmt->fmt.vbi.count[0] == 18 && fmt->fmt.vbi.count[1] == 18) {
+-			tvp5150_write(sd, TVP5150_VERT_BLANKING_START, 0x00);
+-			tvp5150_write(sd, TVP5150_VERT_BLANKING_STOP, 0x01);
+-		}
+-		return 0;
+-	}
+-	if (fmt->type != V4L2_BUF_TYPE_SLICED_VBI_CAPTURE)
++	v4l2_info(sd, "%s\n", __FUNCTION__);
++
++	if (fmt == NULL)
+ 		return -EINVAL;
+-	svbi = &fmt->fmt.sliced;
+-	if (svbi->service_set != 0) {
+-		for (i = 0; i <= 23; i++) {
+-			svbi->service_lines[1][i] = 0;
+-			svbi->service_lines[0][i] =
+-				tvp5150_set_vbi(sd, vbi_ram_default,
+-				       svbi->service_lines[0][i], 0xf0, i, 3);
+-		}
+-		/* Enables FIFO */
+-		tvp5150_write(sd, TVP5150_FIFO_OUT_CTRL, 1);
+-	} else {
+-		/* Disables FIFO*/
+-		tvp5150_write(sd, TVP5150_FIFO_OUT_CTRL, 0);
+-
+-		/* Disable Full Field */
+-		tvp5150_write(sd, TVP5150_FULL_FIELD_ENA, 0);
+-
+-		/* Disable Line modes */
+-		for (i = TVP5150_LINE_MODE_INI; i <= TVP5150_LINE_MODE_END; i++)
+-			tvp5150_write(sd, i, 0xff);
+-	}
++
++	index = fmt->index;
++	if ((index >= decoder->num_fmts) || (index < 0))
++		/* Index out of bound */
++		return -EINVAL;
++
++	if (fmt->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
++		/* only capture is supported */
++		return -EINVAL;
++
++	memcpy(fmt, &decoder->fmt_list[index],
++		sizeof(struct v4l2_fmtdesc));
++
++	v4l2_dbg(1, debug, sd, "Current FMT: index - %d (%s)",
++			decoder->fmt_list[index].index,
++			decoder->fmt_list[index].description);
+ 	return 0;
+ }
+ 
+-static int tvp5150_g_fmt(struct v4l2_subdev *sd, struct v4l2_format *fmt)
++/**
++ * tvp5150_try_fmt_cap() - V4L2 decoder interface handler for try_fmt
++ * @sd: pointer to standard V4L2 sub-device structure
++ * @f: pointer to standard V4L2 VIDIOC_TRY_FMT ioctl structure
++ *
++ * Implement the VIDIOC_TRY_FMT ioctl for the CAPTURE buffer type. This
++ * ioctl is used to negotiate the image capture size and pixel format
++ * without actually making it take effect.
++ */
++static int
++tvp5150_try_fmt_cap(struct v4l2_subdev *sd, struct v4l2_format *f)
+ {
+-	struct v4l2_sliced_vbi_format *svbi;
+-	int i, mask = 0;
++	struct tvp5150_decoder *decoder = to_decoder(sd);
++	int ifmt;
++	struct v4l2_pix_format *pix;
++	enum tvp5150_std current_std;
++
++	v4l2_info(sd, "%s\n", __FUNCTION__);
+ 
+-	if (fmt->type != V4L2_BUF_TYPE_SLICED_VBI_CAPTURE)
++	if (f == NULL)
+ 		return -EINVAL;
+-	svbi = &fmt->fmt.sliced;
+-	memset(svbi, 0, sizeof(*svbi));
+ 
+-	for (i = 0; i <= 23; i++) {
+-		svbi->service_lines[0][i] =
+-			tvp5150_get_vbi(sd, vbi_ram_default, i);
+-		mask |= svbi->service_lines[0][i];
++	if (f->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
++		/* only capture is supported */
++		f->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
++
++	pix = &f->fmt.pix;
++
++	/* Calculate height and width based on current standard */
++	current_std = tvp5150_get_current_std(sd);
++	if (current_std == STD_INVALID)
++		return -EINVAL;
++
++	decoder->current_std = current_std;
++	pix->width = decoder->std_list[current_std].width;
++	pix->height = decoder->std_list[current_std].height;
++
++	for (ifmt = 0; ifmt < decoder->num_fmts; ifmt++) {
++		if (pix->pixelformat ==
++			decoder->fmt_list[ifmt].pixelformat)
++			break;
+ 	}
+-	svbi->service_set = mask;
++	if (ifmt == decoder->num_fmts)
++		/* None of the format matched, select default */
++		ifmt = 0;
++	pix->pixelformat = decoder->fmt_list[ifmt].pixelformat;
++
++	pix->field = V4L2_FIELD_INTERLACED;
++	pix->bytesperline = pix->width * 2;
++	pix->sizeimage = pix->bytesperline * pix->height;
++	pix->colorspace = V4L2_COLORSPACE_SMPTE170M;
++	pix->priv = 0;
++
++	v4l2_dbg(1, debug, sd, "Try FMT: pixelformat - %s, bytesperline - %d"
++			"Width - %d, Height - %d",
++			decoder->fmt_list[ifmt].description, pix->bytesperline,
++			pix->width, pix->height);
+ 	return 0;
+ }
+ 
+-
+-static int tvp5150_g_chip_ident(struct v4l2_subdev *sd,
+-				struct v4l2_dbg_chip_ident *chip)
++/**
++ * tvp5150_s_fmt_cap() - V4L2 decoder interface handler for s_fmt
++ * @sd: pointer to standard V4L2 sub-device structure
++ * @f: pointer to standard V4L2 VIDIOC_S_FMT ioctl structure
++ *
++ * If the requested format is supported, configures the HW to use that
++ * format, returns error code if format not supported or HW can't be
++ * correctly configured.
++ */
++static int
++tvp5150_s_fmt_cap(struct v4l2_subdev *sd, struct v4l2_format *f)
+ {
+-	int rev;
+-	struct i2c_client *client = v4l2_get_subdevdata(sd);
++	struct tvp5150_decoder *decoder = to_decoder(sd);
++	struct v4l2_pix_format *pix;
++	int rval;
+ 
+-	rev = tvp5150_read(sd, TVP5150_ROM_MAJOR_VER) << 8 |
+-	      tvp5150_read(sd, TVP5150_ROM_MINOR_VER);
++	v4l2_info(sd, "%s\n", __FUNCTION__);
+ 
+-	return v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_TVP5150,
+-					  rev);
+-}
++	if (f == NULL)
++		return -EINVAL;
+ 
++	if (f->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
++		/* only capture is supported */
++		return -EINVAL;
+ 
+-#ifdef CONFIG_VIDEO_ADV_DEBUG
+-static int tvp5150_g_register(struct v4l2_subdev *sd, struct v4l2_dbg_register *reg)
+-{
+-	struct i2c_client *client = v4l2_get_subdevdata(sd);
++	pix = &f->fmt.pix;
++	rval = tvp5150_try_fmt_cap(sd, f);
++	if (rval)
++		return rval;
+ 
+-	if (!v4l2_chip_match_i2c_client(client, &reg->match))
+-		return -EINVAL;
+-	if (!capable(CAP_SYS_ADMIN))
+-		return -EPERM;
+-	reg->val = tvp5150_read(sd, reg->reg & 0xff);
+-	reg->size = 1;
+-	return 0;
++		decoder->pix = *pix;
++
++	return rval;
+ }
+ 
+-static int tvp5150_s_register(struct v4l2_subdev *sd, struct v4l2_dbg_register *reg)
++/**
++ * tvp5150_g_fmt_cap() - V4L2 decoder interface handler for tvp5150_g_fmt_cap
++ * @sd: pointer to standard V4L2 sub-device structure
++ * @f: pointer to standard V4L2 v4l2_format structure
++ *
++ * Returns the decoder's current pixel format in the v4l2_format
++ * parameter.
++ */
++static int
++tvp5150_g_fmt_cap(struct v4l2_subdev *sd, struct v4l2_format *f)
+ {
+-	struct i2c_client *client = v4l2_get_subdevdata(sd);
++	struct tvp5150_decoder *decoder = to_decoder(sd);
+ 
+-	if (!v4l2_chip_match_i2c_client(client, &reg->match))
++	v4l2_info(sd, "%s\n", __FUNCTION__);
++
++	if (f == NULL)
++		return -EINVAL;
++
++	if (f->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
++		/* only capture is supported */
+ 		return -EINVAL;
+-	if (!capable(CAP_SYS_ADMIN))
+-		return -EPERM;
+-	tvp5150_write(sd, reg->reg & 0xff, reg->val & 0xff);
++
++	f->fmt.pix = decoder->pix;
++
++	v4l2_dbg(1, debug, sd, "Current FMT: bytesperline - %d"
++			"Width - %d, Height - %d",
++			decoder->pix.bytesperline,
++			decoder->pix.width, decoder->pix.height);
+ 	return 0;
+ }
+-#endif
+ 
+-static int tvp5150_g_tuner(struct v4l2_subdev *sd, struct v4l2_tuner *vt)
++/**
++ * tvp5150_g_parm() - V4L2 decoder interface handler for g_parm
++ * @sd: pointer to standard V4L2 sub-device structure
++ * @a: pointer to standard V4L2 VIDIOC_G_PARM ioctl structure
++ *
++ * Returns the decoder's video CAPTURE parameters.
++ */
++static int
++tvp5150_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *a)
+ {
+-	int status = tvp5150_read(sd, 0x88);
++	struct tvp5150_decoder *decoder = to_decoder(sd);
++	struct v4l2_captureparm *cparm;
++	enum tvp5150_std current_std;
++
++	v4l2_info(sd, "%s\n", __FUNCTION__);
++
++	if (a == NULL)
++		return -EINVAL;
++
++	if (a->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
++		/* only capture is supported */
++		return -EINVAL;
++
++	memset(a, 0, sizeof(*a));
++	a->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
++
++	/* get the current standard */
++	current_std = tvp5150_get_current_std(sd);
++	if (current_std == STD_INVALID)
++		return -EINVAL;
++
++	decoder->current_std = current_std;
++
++	cparm = &a->parm.capture;
++	cparm->capability = V4L2_CAP_TIMEPERFRAME;
++	cparm->timeperframe =
++		decoder->std_list[current_std].standard.frameperiod;
+ 
+-	vt->signal = ((status & 0x04) && (status & 0x02)) ? 0xffff : 0x0;
+ 	return 0;
+ }
+ 
+-static int tvp5150_queryctrl(struct v4l2_subdev *sd, struct v4l2_queryctrl *qc)
++/**
++ * tvp5150_s_parm() - V4L2 decoder interface handler for s_parm
++ * @sd: pointer to standard V4L2 sub-device structure
++ * @a: pointer to standard V4L2 VIDIOC_S_PARM ioctl structure
++ *
++ * Configures the decoder to use the input parameters, if possible. If
++ * not possible, returns the appropriate error code.
++ */
++static int
++tvp5150_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *a)
+ {
+-	int i;
++	struct tvp5150_decoder *decoder = to_decoder(sd);
++	struct v4l2_fract *timeperframe;
++	enum tvp5150_std current_std;
+ 
+-	v4l2_dbg(1, debug, sd, "queryctrl called\n");
++	v4l2_info(sd, "%s\n", __FUNCTION__);
+ 
+-	for (i = 0; i < ARRAY_SIZE(tvp5150_qctrl); i++)
+-		if (qc->id && qc->id == tvp5150_qctrl[i].id) {
+-			memcpy(qc, &(tvp5150_qctrl[i]),
+-			       sizeof(*qc));
+-			return 0;
+-		}
++	if (a == NULL)
++		return -EINVAL;
++
++	if (a->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
++		/* only capture is supported */
++		return -EINVAL;
++
++	timeperframe = &a->parm.capture.timeperframe;
++
++	/* get the current standard */
++	current_std = tvp5150_get_current_std(sd);
++	if (current_std == STD_INVALID)
++		return -EINVAL;
++
++	decoder->current_std = current_std;
++
++	*timeperframe =
++	    decoder->std_list[current_std].standard.frameperiod;
+ 
+-	return -EINVAL;
++	return 0;
+ }
+ 
+-/* ----------------------------------------------------------------------- */
++static int tvp5150_s_stream(struct v4l2_subdev *sd, int enable)
++{
++	int err = 0;
++	struct tvp5150_decoder *decoder = to_decoder(sd);
++
++	v4l2_info(sd, "%s\n", __FUNCTION__);
++	v4l2_info(sd, "decoder->streaming = %i\n", decoder->streaming);
++	
++	if (decoder->streaming || !enable)
++		return 0;
++		
++	err = tvp5150_configure(sd, decoder);
++	if (err)
++		return err;
++	
++	decoder->streaming = enable;
++	
++	return 0;
++}
+ 
+ static const struct v4l2_subdev_core_ops tvp5150_core_ops = {
+-	.log_status = tvp5150_log_status,
++	.queryctrl = tvp5150_queryctrl,
+ 	.g_ctrl = tvp5150_g_ctrl,
+ 	.s_ctrl = tvp5150_s_ctrl,
+-	.queryctrl = tvp5150_queryctrl,
+ 	.s_std = tvp5150_s_std,
+-	.reset = tvp5150_reset,
+-	.g_chip_ident = tvp5150_g_chip_ident,
+-#ifdef CONFIG_VIDEO_ADV_DEBUG
+-	.g_register = tvp5150_g_register,
+-	.s_register = tvp5150_s_register,
+-#endif
+-};
+-
+-static const struct v4l2_subdev_tuner_ops tvp5150_tuner_ops = {
+-	.g_tuner = tvp5150_g_tuner,
+ };
+ 
+ static const struct v4l2_subdev_video_ops tvp5150_video_ops = {
+ 	.s_routing = tvp5150_s_routing,
+-	.g_fmt = tvp5150_g_fmt,
+-	.s_fmt = tvp5150_s_fmt,
+-	.g_sliced_vbi_cap = tvp5150_g_sliced_vbi_cap,
++	.querystd = tvp5150_querystd,
++	.enum_fmt = tvp5150_enum_fmt_cap,
++	.g_fmt = tvp5150_g_fmt_cap,
++	.try_fmt = tvp5150_try_fmt_cap,
++	.s_fmt = tvp5150_s_fmt_cap,
++	.g_parm = tvp5150_g_parm,
++	.s_parm = tvp5150_s_parm,
++	.s_stream = tvp5150_s_stream,
+ };
+ 
+ static const struct v4l2_subdev_ops tvp5150_ops = {
+ 	.core = &tvp5150_core_ops,
+-	.tuner = &tvp5150_tuner_ops,
+ 	.video = &tvp5150_video_ops,
+ };
+ 
++static struct tvp5150_decoder tvp5150_dev = {
++	.streaming = 0,
++
++	.fmt_list = tvp5150_fmt_list,
++	.num_fmts = ARRAY_SIZE(tvp5150_fmt_list),
+ 
+-/****************************************************************************
+-			I2C Client & Driver
+- ****************************************************************************/
++	.pix = {
++		/* Default to NTSC 8-bit YUV 422 */
++		.width = NTSC_NUM_ACTIVE_PIXELS,
++		.height = NTSC_NUM_ACTIVE_LINES,
++		.pixelformat = V4L2_PIX_FMT_UYVY,
++		.field = V4L2_FIELD_INTERLACED,
++		.bytesperline = NTSC_NUM_ACTIVE_PIXELS * 2,
++		.sizeimage =
++		NTSC_NUM_ACTIVE_PIXELS * 2 * NTSC_NUM_ACTIVE_LINES,
++		.colorspace = V4L2_COLORSPACE_SMPTE170M,
++		},
++
++	.current_std = STD_NTSC_MJ,
++	.std_list = tvp5150_std_list,
++	.num_stds = ARRAY_SIZE(tvp5150_std_list),
+ 
+-static int tvp5150_probe(struct i2c_client *c,
+-			 const struct i2c_device_id *id)
++};
++
++/**
++ * tvp5150_probe() - decoder driver i2c probe handler
++ * @client: i2c driver client device structure
++ * @id: i2c driver id table
++ *
++ * Register decoder as an i2c client device and V4L2
++ * device.
++ */
++static int
++tvp5150_probe(struct i2c_client *client, const struct i2c_device_id *id)
+ {
+-	struct tvp5150 *core;
++	struct tvp5150_decoder *decoder;
+ 	struct v4l2_subdev *sd;
+ 
+ 	/* Check if the adapter supports the needed features */
+-	if (!i2c_check_functionality(c->adapter,
+-	     I2C_FUNC_SMBUS_READ_BYTE | I2C_FUNC_SMBUS_WRITE_BYTE_DATA))
++	if (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))
+ 		return -EIO;
+ 
+-	core = kzalloc(sizeof(struct tvp5150), GFP_KERNEL);
+-	if (!core) {
++	decoder = kzalloc(sizeof(*decoder), GFP_KERNEL);
++	if (!decoder)
+ 		return -ENOMEM;
+-	}
+-	sd = &core->sd;
+-	v4l2_i2c_subdev_init(sd, c, &tvp5150_ops);
+-	v4l_info(c, "chip found @ 0x%02x (%s)\n",
+-		 c->addr << 1, c->adapter->name);
+-
+-	core->norm = V4L2_STD_ALL;	/* Default is autodetect */
+-	core->input = TVP5150_COMPOSITE1;
+-	core->enable = 1;
+-	core->bright = 128;
+-	core->contrast = 128;
+-	core->hue = 0;
+-	core->sat = 128;
+ 
+-	if (debug > 1)
+-		tvp5150_log_status(sd);
++	/* Initialize the tvp5150_decoder with default configuration */
++	*decoder = tvp5150_dev;
++	/* Copy default register configuration */
++	memcpy(decoder->tvp5150_regs, tvp5150_reg_list_default,
++			sizeof(tvp5150_reg_list_default));
++
++	/* Register with V4L2 layer as slave device */
++	sd = &decoder->sd;
++	v4l2_i2c_subdev_init(sd, client, &tvp5150_ops);
++
++	v4l2_info(sd, "%s decoder driver registered !!\n", sd->name);
++
+ 	return 0;
++
+ }
+ 
+-static int tvp5150_remove(struct i2c_client *c)
++/**
++ * tvp5150_remove() - decoder driver i2c remove handler
++ * @client: i2c driver client device structure
++ *
++ * Unregister decoder as an i2c client device and V4L2
++ * device. Complement of tvp5150_probe().
++ */
++static int tvp5150_remove(struct i2c_client *client)
+ {
+-	struct v4l2_subdev *sd = i2c_get_clientdata(c);
+-
+-	v4l2_dbg(1, debug, sd,
+-		"tvp5150.c: removing tvp5150 adapter on address 0x%x\n",
+-		c->addr << 1);
++	struct v4l2_subdev *sd = i2c_get_clientdata(client);
++	struct tvp5150_decoder *decoder = to_decoder(sd);
+ 
+ 	v4l2_device_unregister_subdev(sd);
+-	kfree(to_tvp5150(sd));
++	kfree(decoder);
+ 	return 0;
+ }
+ 
+-/* ----------------------------------------------------------------------- */
+-
++/**
++ * I2C Device Table -
++ *
++ * name - Name of the actual device/chip.
++ * driver_data - Driver data
++ */
+ static const struct i2c_device_id tvp5150_id[] = {
+-	{ "tvp5150", 0 },
+-	{ }
++	{"tvp5150", 0},
++	{},
+ };
++
+ MODULE_DEVICE_TABLE(i2c, tvp5150_id);
+ 
+-static struct v4l2_i2c_driver_data v4l2_i2c_data = {
+-	.name = "tvp5150",
++static struct i2c_driver tvp5150_driver = {
++	.driver = {
++		.owner = THIS_MODULE,
++		.name = tvp5150_MODULE_NAME,
++	},
+ 	.probe = tvp5150_probe,
+ 	.remove = tvp5150_remove,
+ 	.id_table = tvp5150_id,
+ };
++
++static int __init tvp5150_init(void)
++{
++	return i2c_add_driver(&tvp5150_driver);
++}
++
++static void __exit tvp5150_exit(void)
++{
++	i2c_del_driver(&tvp5150_driver);
++}
++
++module_init(tvp5150_init);
++module_exit(tvp5150_exit);
+--- a/drivers/media/video/tvp5150_reg.h
++++ b/drivers/media/video/tvp5150_reg.h
+@@ -122,3 +122,22 @@
+ 
+ #define TVP5150_FULL_FIELD_MODE_REG 0xfc /* Full field mode register */
+ /* Reserved	FDh-FFh */
++
++#define VIDEO_STD_MASK							0x07
++#define VIDEO_STD_NTSC_MJ_BIT				0x01
++#define VIDEO_STD_PAL_BDGHIN_BIT		0x03
++
++#define STATUS_CLR_SUBCAR_LOCK_BIT	0x08
++#define STATUS_VIRT_SYNC_LOCK_BIT		0x04
++#define STATUS_HORZ_SYNC_LOCK_BIT		0x02
++
++#define TOK_WRITE                       (0)     /* token for write operation */
++#define TOK_TERM                        (1)     /* terminating token */
++#define TOK_DELAY                       (2)     /* delay token for reg list */
++#define TOK_SKIP                        (3)     /* token to skip a register */
++
++struct tvp5150_reg {
++	u8 token;
++	u8 reg;
++	u32 val;
++};
+--- a/include/media/tvp5150.h
++++ b/include/media/tvp5150.h
+@@ -21,14 +21,25 @@
+ #ifndef _TVP5150_H_
+ #define _TVP5150_H_
+ 
++/* Number of pixels and number of lines per frame for different standards */
++#define NTSC_NUM_ACTIVE_PIXELS    (720)
++#define NTSC_NUM_ACTIVE_LINES   (480)
++#define PAL_NUM_ACTIVE_PIXELS   (720)
++#define PAL_NUM_ACTIVE_LINES    (576)
++
+ /* TVP5150 HW inputs */
+-#define TVP5150_COMPOSITE0 0
+-#define TVP5150_COMPOSITE1 1
+-#define TVP5150_SVIDEO     2
++enum tvp5150_input {
++	TVP5150_COMPOSITE0 = 0x0,
++	TVP5150_COMPOSITE1,
++	TVP5150_SVIDEO,
++	INPUT_INVALID
++};
+ 
+-/* TVP5150 HW outputs */
+-#define TVP5150_NORMAL       0
+-#define TVP5150_BLACK_SCREEN 1
++enum tvp5150_output {
++	TVP5150_NORMAL = 0x0,
++	TVP5150_BLACK_SCREEN,
++	OUTPUT_INVALID
++};
+ 
+ #endif
+ 
Index: trunk/target/linux/davinci/patches-2.6.32/200-ti_davinci_psp.patch
===================================================================
--- trunk/target/linux/davinci/patches-2.6.32/200-ti_davinci_psp.patch	(revision 0)
+++ trunk/target/linux/davinci/patches-2.6.32/200-ti_davinci_psp.patch	(revision 0)
@@ -0,0 +1,77627 @@
+--- /dev/null
++++ b/drivers/media/video/davinci/davinci_enc_mngr.c
+@@ -0,0 +1,1166 @@
++/*
++ * Copyright (C) 2009 Texas Instruments Inc
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
++ */
++
++#include <linux/kernel.h>
++#include <linux/init.h>
++#include <linux/ctype.h>
++#include <linux/delay.h>
++#include <linux/device.h>
++#include <linux/attribute_container.h>
++#include <mach/hardware.h>
++#include <mach/mux.h>
++#include <mach/cputype.h>
++#include <mach/io.h>
++#include <asm/io.h>
++#include <media/davinci/davinci_enc.h>
++#include <media/davinci/vid_encoder_types.h>
++#include <media/davinci/vid_encoder_if.h>
++#include <media/davinci/davinci_enc_mngr.h>
++#include <media/davinci/davinci_platform.h>
++
++#define ISNULL(p)       ((NULL) == (p))
++
++static char *ch0_output = "";
++static char *ch1_output = "";
++static char *ch0_mode = "";
++static char *ch1_mode = "";
++module_param(ch0_output, charp, S_IRUGO);
++module_param(ch1_output, charp, S_IRUGO);
++module_param(ch0_mode, charp, S_IRUGO);
++module_param(ch1_mode, charp, S_IRUGO);
++
++struct vid_enc_device_mgr enc_dev[DAVINCI_ENC_MAX_CHANNELS];
++
++EXPORT_SYMBOL(enc_dev);
++extern struct enc_config davinci_enc_default[];
++extern char *davinci_outputs[];
++extern char *davinci_modes[];
++
++struct display_device {
++	struct module *owner;
++	struct device class_dev;
++	int channel;
++};
++
++static struct display_device *davinci_display_device[DAVINCI_ENC_MAX_CHANNELS];
++
++#define to_display_dev(cdev)	container_of(cdev, struct display_device, class_dev)
++
++static void display_class_release(struct device *cdev)
++{
++	struct display_device *dev = to_display_dev(cdev);
++
++	if (dev != NULL)
++		kfree(dev);
++}
++
++struct class display_class = {
++	.name = "davinci_display",
++	.owner	= THIS_MODULE,
++	.dev_release = display_class_release,
++};
++
++static ssize_t output_show(struct device *cdev, struct device_attribute *attr, char *buf)
++{
++	char name[VID_ENC_NAME_MAX_CHARS];
++	struct display_device *dev = to_display_dev(cdev);
++	int p, ret;
++
++	ret = davinci_enc_get_output(dev->channel, name);
++	if (ret < 0)
++		return ret;
++
++	p = sprintf(buf, name);
++	p += sprintf(buf + p, "\n");
++
++	return p;
++}
++
++static ssize_t
++output_store(struct device *cdev, struct device_attribute *attr, const char *buffer, size_t count)
++{
++	struct display_device *dev = to_display_dev(cdev);
++	char name[VID_ENC_NAME_MAX_CHARS];
++	int ret;
++
++	if (!buffer || (count == 0)|| (count > VID_ENC_NAME_MAX_CHARS))
++		return 0;
++
++	strncpy(name, buffer, count);
++	name[count - 1] = 0;
++	ret = davinci_enc_set_output(dev->channel, name);
++	if (ret < 0) {
++		return ret;
++	}
++
++	return count;
++}
++
++static ssize_t mode_show(struct device *cdev, struct device_attribute *attr, char *buf)
++{
++	struct display_device *dev = to_display_dev(cdev);
++	struct vid_enc_mode_info mode_info;
++	int p;
++	int ret;
++
++	ret = davinci_enc_get_mode(dev->channel, &mode_info);
++	if (ret < 0)
++		return ret;
++
++	p = sprintf(buf, mode_info.name);
++	p += sprintf(buf + p, "\n");
++
++	return p;
++}
++
++static ssize_t
++mode_store(struct device *cdev, struct device_attribute *attr, const char *buffer, size_t count)
++{
++	struct display_device *dev = to_display_dev(cdev);
++	char name[VID_ENC_NAME_MAX_CHARS];
++	struct vid_enc_mode_info mode_info;
++	int ret;
++
++	if (!buffer || (count == 0) || (count > VID_ENC_NAME_MAX_CHARS))
++		return 0;
++
++	strncpy(name, buffer, count);
++	name[count - 1] = 0;
++
++	ret = davinci_enc_get_mode(dev->channel, &mode_info);
++
++	if (ret < 0)
++		return ret;
++
++	mode_info.name = name;
++	ret = davinci_enc_set_mode(dev->channel, &mode_info);
++	if (ret < 0)
++		return ret;
++
++	return count;
++}
++
++static ssize_t enable_show(struct device *cdev, struct device_attribute *attr, char *buf)
++{
++	return 0;
++}
++
++static ssize_t
++enable_store(struct device *cdev, struct device_attribute *attr, const char *buffer, size_t count)
++{
++	struct display_device *dev = to_display_dev(cdev);
++	int enable_output_state, ret;
++
++	if (!buffer || (count == 0))
++		return 0;
++
++	if (strncmp(buffer, "on", 2) == 0)
++		enable_output_state = 1;
++	else if (strncmp(buffer, "off", 3) == 0)
++		enable_output_state = 0;
++	else
++		return -EINVAL;
++
++	ret = davinci_enc_enable_output(dev->channel, enable_output_state);
++	if (ret < 0)
++		return ret;
++
++	return count;
++}
++
++static ssize_t
++control_store(struct device *cdev, const char *buffer, size_t count,
++	      u8 ctrl)
++{
++	struct display_device *dev = to_display_dev(cdev);
++	int val;
++	int ret;
++
++	if (!buffer || (count == 0))
++		return 0;
++
++	val = simple_strtoul(buffer, NULL, 0);
++
++	ret = davinci_enc_set_control(dev->channel, ctrl, (char)val);
++	if (ret < 0)
++		return ret;
++	return count;
++}
++static ssize_t control_show(struct device *cdev, char *buf, u8 ctrl)
++{
++	struct display_device *dev = to_display_dev(cdev);
++	unsigned int p;
++	unsigned char val;
++	int ret;
++
++	ret = davinci_enc_get_control(dev->channel, ctrl, &val);
++	if (ret < 0)
++		return ret;
++
++	p = sprintf(buf, "%d", val);
++	p += sprintf(buf + p, "\n");
++
++	return p;
++}
++
++static ssize_t
++brightness_store(struct device *cdev, struct device_attribute *attr, const char *buffer, size_t count)
++{
++	return control_store(cdev, buffer, count, VID_ENC_CTRL_BRIGHTNESS);
++}
++static ssize_t brightness_show(struct device *cdev, struct device_attribute *attr, char *buf)
++{
++	return control_show(cdev, buf, VID_ENC_CTRL_BRIGHTNESS);
++}
++static ssize_t
++hue_store(struct device *cdev, struct device_attribute *attr, const char *buffer, size_t count)
++{
++	return control_store(cdev, buffer, count, VID_ENC_CTRL_HUE);
++}
++static ssize_t hue_show(struct device *cdev, struct device_attribute *attr, char *buf)
++{
++	return control_show(cdev, buf, VID_ENC_CTRL_HUE);
++}
++static ssize_t
++gain_store(struct device *cdev, struct device_attribute *attr, const char *buffer, size_t count)
++{
++	return control_store(cdev, buffer, count, VID_ENC_CTRL_GAIN);
++}
++static ssize_t gain_show(struct device *cdev, struct device_attribute *attr, char *buf)
++{
++	return control_show(cdev, buf, VID_ENC_CTRL_GAIN);
++}
++
++#define DECLARE_ATTR(_name, _mode, _show, _store)                  \
++{                                                               \
++	.attr   = { .name = __stringify(_name), .mode = _mode,	\
++		    .owner = THIS_MODULE },  			\
++	.show   = _show,                                        \
++	.store  = _store,                                       \
++}
++static struct device_attribute bl_device_attributes[] = {
++	DECLARE_ATTR(output, S_IRWXUGO, output_show, output_store),
++	DECLARE_ATTR(mode, S_IRWXUGO, mode_show, mode_store),
++	DECLARE_ATTR(enable, S_IRWXUGO, enable_show, enable_store),
++	DECLARE_ATTR(brightness, S_IRWXUGO, brightness_show, brightness_store),
++	DECLARE_ATTR(hue, S_IRWXUGO, hue_show, hue_store),
++	DECLARE_ATTR(gain, S_IRWXUGO, gain_show, gain_store)
++};
++
++static void *create_sysfs_files(int channel)
++{
++	struct display_device *dev;
++	int ret;
++	int i;
++
++	dev = kzalloc(sizeof(struct display_device), GFP_KERNEL);
++	if (!dev)
++		return NULL;
++
++	dev->owner = THIS_MODULE;
++	dev->channel = channel;
++	dev->class_dev.class = &display_class;
++	dev_set_name(&dev->class_dev, "ch%d", channel);
++	dev_set_drvdata(&dev->class_dev, dev);
++	ret = device_register(&dev->class_dev);
++	if (ret < 0) {
++		printk(KERN_ERR "DaVinci Enc Manager: Error in device_register\n");
++		kfree(dev);
++		return NULL;
++	}
++
++	for (i = 0; i < ARRAY_SIZE(bl_device_attributes); i++) {
++		ret = device_create_file(&dev->class_dev,
++					       &bl_device_attributes[i]);
++		if (ret < 0) {
++			while (--i >= 0)
++				device_remove_file(&dev->class_dev,
++							 &bl_device_attributes
++							 [i]);
++			dev_set_drvdata(&dev->class_dev, NULL);
++			device_unregister(&dev->class_dev);
++			return NULL;
++		}
++	}
++
++	return dev;
++}
++
++static void remove_sysfs_files(struct display_device *dev)
++{
++	int i;
++
++	for (i = 0; i < ARRAY_SIZE(bl_device_attributes); i++)
++		device_remove_file(&dev->class_dev,
++					 &bl_device_attributes[i]);
++
++	dev_set_drvdata(&dev->class_dev, NULL);
++	device_unregister(&dev->class_dev);
++}
++
++static void davinci_enc_check_options(void)
++{
++	int i;
++
++	i = 0;
++	while (*(davinci_modes[i]) != 0) {
++		if (*ch0_mode != 0 && !strcmp(ch0_mode, davinci_modes[i])) {
++			if (strcmp(ch0_mode, "ntsc") == 0
++			    || strcmp(ch0_mode, "pal") == 0)
++				strcpy(davinci_enc_default[0].mode,
++				       davinci_modes[i - 1]);
++			else
++				strcpy(davinci_enc_default[0].mode,
++				       davinci_modes[i]);
++		}
++		if (*ch1_mode != 0 &&
++		    (DAVINCI_ENC_MAX_CHANNELS > 1) &&
++		    !strcmp(ch1_mode, davinci_modes[i])) {
++			if (strcmp(ch1_mode, "ntsc") == 0
++			    || strcmp(ch1_mode, "pal") == 0)
++				strcpy(davinci_enc_default[1].mode,
++				       davinci_modes[i - 1]);
++			else
++				strcpy(davinci_enc_default[1].mode,
++				       davinci_modes[i]);
++		}
++		i++;
++	}
++
++	i = 0;
++	while (*(davinci_outputs[i]) != 0) {
++		if (*ch0_output != 0 && !strcmp(ch0_output, davinci_outputs[i]))
++			strcpy(davinci_enc_default[0].output,
++			       davinci_outputs[i]);
++
++		if (*ch1_output != 0 &&
++		    (DAVINCI_ENC_MAX_CHANNELS > 1) &&
++		    !strcmp(ch1_output, davinci_outputs[i]))
++			strcpy(davinci_enc_default[1].output,
++			       davinci_outputs[i]);
++		i++;
++	}
++	printk(KERN_NOTICE "ch0 default output \"%s\", mode \"%s\"\n",
++	       davinci_enc_default[0].output, davinci_enc_default[0].mode);
++	if (DAVINCI_ENC_MAX_CHANNELS > 1)
++		printk(KERN_NOTICE "ch1 default output \"%s\", mode \"%s\"\n",
++		       davinci_enc_default[1].output,
++		       davinci_enc_default[1].mode);
++	return;
++}
++
++/*
++ * vid_enc_mgr_init
++ */
++static int davinci_enc_mngr_init(void)
++{
++
++	int i, err = -EINVAL;
++	struct vid_enc_device_mgr *ptr = 0;
++
++
++	class_register(&display_class);
++
++	for (i = 0; i < DAVINCI_ENC_MAX_CHANNELS; i++) {
++		ptr = &enc_dev[i];
++
++		memset((void *)ptr, 0, sizeof(struct vid_enc_device_mgr));
++		init_MUTEX(&ptr->lock);
++
++		davinci_display_device[i] = create_sysfs_files(i);
++		if (!davinci_display_device[i]) {
++			printk(KERN_ERR
++			       "Could not create display control sysfs "
++			       "files for channel %d\n", i);
++			return -EINVAL;
++		}
++	}
++
++	davinci_enc_check_options();
++	err = 0;
++	return err;
++}
++
++/*
++ * vid_enc_mgr_cleanup
++ */
++static void davinci_enc_mngr_exit(void)
++{
++//Sandeep
++	int i;
++
++	for (i = 0; i < DAVINCI_ENC_MAX_CHANNELS; i++)
++		remove_sysfs_files(davinci_display_device[i]);
++
++	class_unregister(&display_class);
++
++	return;
++}
++
++/*
++ * davinci_get_cur_encoder: get current encoder on the specified channel
++ */
++static struct vid_encoder_device *davinci_get_cur_encoder(int channel)
++{
++	struct vid_enc_device_mgr *mgr;
++
++	if ((channel > DAVINCI_ENC_MAX_CHANNELS) || (channel < 0))
++		return NULL;
++
++	mgr = &enc_dev[channel];
++
++	if (mgr->current_encoder > mgr->num_encoders)
++		return NULL;
++
++	if (mgr->num_encoders == 0)
++		return NULL;
++
++	return mgr->encoder[mgr->current_encoder];
++}
++
++/**
++ * function davinci_enc_setparams
++ * @params: pointer to params structure.
++ * @channel: channel number.
++ * Returns: Zero if successful, or non-zero otherwise
++ *
++ * Description:
++ *   Set parameters at current active encoder. params will be defined by
++ * the specific encoder and used by user space applications to set encoder
++ * parameters.
++ */
++int davinci_enc_setparams(int channel, void *params)
++{
++	struct vid_encoder_device *cur_enc;
++
++	cur_enc = davinci_get_cur_encoder(channel);
++
++	if (NULL == cur_enc || NULL == cur_enc->params_ops || NULL == params)
++		return -EINVAL;
++
++	if (cur_enc->params_ops->setparams != NULL)
++		return cur_enc->params_ops->setparams(params, cur_enc);
++	else
++		return 0;
++}
++
++EXPORT_SYMBOL(davinci_enc_setparams);
++
++/**
++ * function davinci_enc_getparams
++ * @params: pointer to params structure.
++ * @channel: channel number, 0 for first channel and so forth
++ * Returns: Zero if successful, or non-zero otherwise
++ *
++ * Description:
++ * Get parameters at current active encoder. params will be defined by
++ * the specific encoder and used by user space applications to get encoder
++ * parameters.
++ */
++int davinci_enc_getparams(int channel, void *params)
++{
++	struct vid_encoder_device *cur_enc;
++
++	cur_enc = davinci_get_cur_encoder(channel);
++
++	if (NULL == cur_enc || NULL == cur_enc->params_ops || NULL == params)
++		return -EINVAL;
++
++	if (cur_enc->params_ops->getparams != NULL)
++		return cur_enc->params_ops->getparams(params, cur_enc);
++	else
++		return 0;
++}
++
++EXPORT_SYMBOL(davinci_enc_getparams);
++
++/**
++ * function davinci_enc_set_control
++ * @channel: channel number.
++ * @ctrl: davinci_vid_enc_control type
++ * @val:  control value to be set
++ * Returns: Zero if successful, or non-zero otherwise
++ *
++ * Description:
++ *   Set controls at the current encoder's output.
++ *
++ */
++int davinci_enc_set_control(int channel, enum vid_enc_ctrl_id ctrl, char val)
++{
++	struct vid_encoder_device *cur_enc;
++
++	cur_enc = davinci_get_cur_encoder(channel);
++
++	if (NULL == cur_enc || NULL == cur_enc->ctrl_ops)
++		return -EINVAL;
++
++	if (cur_enc->ctrl_ops->setcontrol != NULL)
++		return cur_enc->ctrl_ops->setcontrol(ctrl, val, cur_enc);
++	else
++		return 0;
++}
++
++EXPORT_SYMBOL(davinci_enc_set_control);
++
++/**
++ * function davinci_enc_get_control
++ * @channel: channel number.
++ * @ctrl: control type as per davinci_vid_enc_ctrl_type
++ * @val:  ptr to value that gets updated
++ * Returns: Zero if successful, or non-zero otherwise
++ *
++ * Description:
++ *   Get controls at the current encoder's output.
++ *
++ */
++int davinci_enc_get_control(int channel, enum vid_enc_ctrl_id ctrl, char *val)
++{
++	struct vid_encoder_device *cur_enc;
++
++	cur_enc = davinci_get_cur_encoder(channel);
++
++	if (NULL == cur_enc || NULL == cur_enc->ctrl_ops || NULL == val)
++		return -EINVAL;
++
++	if (cur_enc->ctrl_ops->getcontrol != NULL)
++		return cur_enc->ctrl_ops->getcontrol(ctrl, val, cur_enc);
++	else
++		return 0;
++}
++
++EXPORT_SYMBOL(davinci_enc_get_control);
++
++/**
++ * function davinci_enc_reset
++ * @channel: channel number. DAVINCI_ENC_MAX_CHANNELS set to 1
++ * Returns: Zero if successful, or non-zero otherwise
++ *
++ * Description:
++ *  Do a software Reset the current encoder. Some of the encoders require this.
++ * This shouldn't affect the contents of the registers configured already for
++ * for output, standard, control etc. If there is no support, encoder doesn't
++ * implement this API.
++ */
++int davinci_enc_reset(int channel)
++{
++	struct vid_encoder_device *cur_enc;
++
++	cur_enc = davinci_get_cur_encoder(channel);
++
++	if (NULL == cur_enc || NULL == cur_enc->misc_ops)
++		return -EINVAL;
++
++	if (cur_enc->misc_ops != NULL && cur_enc->misc_ops->reset != NULL)
++		return cur_enc->misc_ops->reset(cur_enc);
++	else
++		return 0;
++}
++
++EXPORT_SYMBOL(davinci_enc_reset);
++
++/**
++ * function davinci_enc_enable_output
++ * @channel: channel number. DAVINCI_ENC_MAX_CHANNELS set to 1
++ * @flag: flag to indicate enable or disable, 0 - disable, 1 - enable
++ * Returns: Zero if successful, or non-zero otherwise
++ *
++ * Description:
++*  Enable/Disable the current ouput. While the VPSS is configured for a
++ * video mode or graphics mode, you may observe noise on the display device
++ * due to timing changes. To avoid this, the output may be disabled during
++* configuration of the VENC or related hardware in the VPSS and re-enabled
++* using this API. This will switch the output DACs Off or On based on the
++* flag.
++ */
++int davinci_enc_enable_output(int channel, int flag)
++{
++	struct vid_encoder_device *cur_enc;
++
++	cur_enc = davinci_get_cur_encoder(channel);
++
++	if (NULL == cur_enc || NULL == cur_enc->misc_ops)
++		return -EINVAL;
++
++	if (cur_enc->misc_ops != NULL && cur_enc->misc_ops->enable != NULL)
++		return cur_enc->misc_ops->enable(flag, cur_enc);
++	else
++		return 0;
++}
++
++EXPORT_SYMBOL(davinci_enc_enable_output);
++
++/**
++ * function davinci_enc_set_output
++ * @channel: channel number.
++ * @output: ptr to output name string
++ * Returns: Zero if successful, or non-zero otherwise
++ *
++ * Description:
++ *   Set output - Set channel's output to the one identified by output string
++ * The encoder manager calls enumoutput() of each of the encoder to determine
++ * the encoder that supports this output and set this encoder as the current
++ * encoder. It calls setoutput() of the selected encoder. Encoder is expected
++ * set a default mode on this output internally. Manager calls the getmode()
++ * to get information about the mode to program the SoC hardware (VENC/DLCD
++ * for Davinci/DM355. During programing of the SoC hardware for timing, manager
++ * would call enable() to disable and re-enable the output of the encoder
++ * to avoid noise at the display. It may also call reset() to make sure the
++ * encoder is reset if required by the encoder hardware.
++ */
++int davinci_enc_set_output(int channel, char *output)
++{
++	int i, j, found = -1;
++	int err = -EINVAL;
++	struct vid_encoder_device *cur_enc, *new_enc = 0;
++	struct vid_enc_device_mgr *mgr = NULL;
++	char buf[VID_ENC_NAME_MAX_CHARS];
++
++	cur_enc = davinci_get_cur_encoder(channel);
++	if (NULL == cur_enc || NULL == output)
++		return err;
++
++	mgr = &enc_dev[channel];
++
++	/* enumerate the output for each encoder on this channel
++	   to find a matching one */
++	for (i = 0; i < mgr->num_encoders; i++) {
++		if (ISNULL(mgr->encoder[i]))
++			return err;
++
++		for (j = 0; j < mgr->encoder[i]->output_ops->count; j++) {
++			err =
++			    mgr->encoder[i]->output_ops->
++			    enumoutput(j, buf, mgr->encoder[i]);
++			if (err != 0)
++				return err;
++			if (strcmp(buf, output) == 0) {
++				found = i;
++				new_enc = mgr->encoder[i];
++				break;
++			}
++		}
++	}
++
++	if (found < 0) {
++		printk(KERN_ERR "output not found\n");
++		return -EINVAL;
++	}
++
++	/* found the encoder */
++	err = 0;
++	mgr->current_encoder = found;
++	if ((err = down_interruptible(&mgr->lock)) < 0)
++		return err;
++	err |= cur_enc->deinitialize(cur_enc);
++	err |= new_enc->initialize(new_enc, VID_ENC_FULL_INIT_FLAG);
++	err |= new_enc->output_ops->setoutput(output, new_enc);
++
++	if (err < 0) {
++		up(&mgr->lock);
++		return err;
++	}
++
++	/* get default mode */
++	err |= new_enc->mode_ops->getmode(&mgr->current_mode, new_enc);
++
++	if (new_enc->misc_ops != NULL && new_enc->misc_ops->enable != NULL)
++		err |= new_enc->misc_ops->enable(0, new_enc);
++
++	davinci_enc_set_mode_platform(channel, mgr);
++
++	/* Some encoders need a soft reset after configuring VENC, ex.
++	   ths8200
++	 */
++	if (new_enc->misc_ops != NULL && new_enc->misc_ops->reset != NULL)
++		err |= new_enc->misc_ops->reset(new_enc);
++
++	if (new_enc->misc_ops != NULL && new_enc->misc_ops->enable != NULL)
++		err |= new_enc->misc_ops->enable(1, new_enc);
++
++	if (0 == err)
++		strcpy(enc_dev[channel].current_output, output);
++
++	up(&mgr->lock);
++
++	return err;
++}
++
++EXPORT_SYMBOL(davinci_enc_set_output);
++
++/**
++ * function davinci_enc_set_mode
++ * @channel: channel number.
++ * @mode_info: ptr to vid_enc_mode_info structure
++ * Returns: Zero if successful, or non-zero otherwise
++ *
++ * Description:
++ *   set standard or non-standard mode at current encoder's active output.
++ * Encoder Manager first configure the VENC or associated SoC hardware
++ * before calling the setmode() API of the encoder. To do so, encoder Manager
++ * calls the getmode() to get the mode_info for this mode and configure the
++ * mode based on the timing information present in this structure.
++ */
++int davinci_enc_set_mode(int channel, struct vid_enc_mode_info *mode_info)
++{
++	struct vid_encoder_device *cur_enc;
++	struct vid_enc_device_mgr *mgr = 0;
++
++	int err = -EINVAL;
++
++	cur_enc = davinci_get_cur_encoder(channel);
++
++	if (NULL == cur_enc || NULL == cur_enc->mode_ops || NULL == mode_info)
++		return err;
++
++	mgr = &enc_dev[channel];
++
++	if (cur_enc->mode_ops->setmode != NULL) {
++		if ((err = down_interruptible(&mgr->lock)) < 0)
++			return err;
++		err = cur_enc->mode_ops->setmode(mode_info, cur_enc);
++		up(&mgr->lock);
++	} else
++		return err;
++
++	if (err < 0)
++		return err;
++
++	err = cur_enc->mode_ops->getmode(&mgr->current_mode, cur_enc);
++	if (err < 0)
++		return err;
++
++	err = 0;
++
++	if ((err = down_interruptible(&mgr->lock)) < 0)
++		return err;
++
++	if (cur_enc->misc_ops != NULL && cur_enc->misc_ops->enable != NULL)
++		err |= cur_enc->misc_ops->enable(0, cur_enc);
++
++	/* non-standard */
++	if (mgr->current_mode.std == 0) {
++		davinci_enc_set_display_timing(&mgr->current_mode);
++		up(&mgr->lock);
++		return err;
++	}
++
++	davinci_enc_set_mode_platform(channel, mgr);
++
++	if (cur_enc->misc_ops != NULL && cur_enc->misc_ops->reset != NULL)
++		err |= cur_enc->misc_ops->reset(cur_enc);
++
++	if (cur_enc->misc_ops != NULL && cur_enc->misc_ops->enable != NULL)
++		err |= cur_enc->misc_ops->enable(1, cur_enc);
++
++	up(&mgr->lock);
++
++	return err;
++}
++
++EXPORT_SYMBOL(davinci_enc_set_mode);
++
++/**
++ * function davinci_enc_get_mode
++ * @channel: channel number, starting index 0.
++ * @mode_info: ptr to vid_enc_mode_info structure
++ * This is updated by encoder manager
++ * Returns: Zero if successful, or non-zero otherwise
++ *
++ * Description:
++ *   get video or graphics mode at current encoder's active output.
++ *
++*/
++int davinci_enc_get_mode(int channel, struct vid_enc_mode_info *mode_info)
++{
++	struct vid_encoder_device *cur_enc;
++
++	cur_enc = davinci_get_cur_encoder(channel);
++
++	if (NULL == cur_enc || NULL == cur_enc->mode_ops || NULL == mode_info)
++		return -EINVAL;
++
++	if (cur_enc->mode_ops->getmode != NULL)
++		return cur_enc->mode_ops->getmode(mode_info, cur_enc);
++	else
++		return 0;
++}
++
++EXPORT_SYMBOL(davinci_enc_get_mode);
++
++/**
++ * function davinci_enc_get_output
++ * @channel: channel number.
++ * @output: ptr to array of char to hold output name.
++ * size VID_ENC_NAME_MAX_CHARS
++ * Returns: Zero if successful, or non-zero otherwise
++ *
++ * Description:
++ *   Get output - Get channel's output. User call this to get the current
++*   output name
++ */
++int davinci_enc_get_output(int channel, char *output)
++{
++	struct vid_encoder_device *cur_enc;
++
++	cur_enc = davinci_get_cur_encoder(channel);
++
++	if (NULL == cur_enc || NULL == cur_enc->output_ops || NULL == output)
++		return -EINVAL;
++
++	if (cur_enc->output_ops->getoutput != NULL)
++		return cur_enc->output_ops->getoutput(output, cur_enc);
++	else
++		return 0;
++}
++
++EXPORT_SYMBOL(davinci_enc_get_output);
++
++/**
++ * vid_enc_register_encoder
++ * @encoder: pointer to the encoder device structure
++ * Returns: Zero if successful, or non-zero otherwise
++ *
++ * Description:
++ * Register the encoder module with the encoder manager
++ * This is implemented by the encoder Manager
++ */
++int vid_enc_register_encoder(struct vid_encoder_device *encoder)
++{
++	int i, found = 0, err = 0;
++	int ch_id = 0;
++	struct vid_enc_device_mgr *mgr = 0;
++	struct vid_encoder_device *cur_enc = 0;
++	struct enc_config *enc_def = 0;
++	struct vid_enc_mode_info mode_info;
++	char buf[VID_ENC_NAME_MAX_CHARS];
++
++	if (ISNULL(encoder))
++		return -EINVAL;
++
++	memset(&mode_info, 0, sizeof(struct vid_enc_mode_info));
++	ch_id = encoder->channel_id;
++
++	if ((ch_id > DAVINCI_ENC_MAX_CHANNELS) || (ch_id < 0))
++		return -EINVAL;
++
++	mgr = &enc_dev[ch_id];
++
++	if (mgr->num_encoders > DAVINCI_ENC_MAX_ENCODERS)
++		return -EINVAL;
++
++	/* get module boot args */
++	enc_def = &davinci_enc_default[ch_id];
++
++	/* we'd assume only std mode being reqeusted from bootargs */
++	mode_info.name = enc_def->mode;
++	mode_info.std = 1;
++	if (mgr->num_encoders == 0) {
++
++		/* set default for the first encoder */
++		err = encoder->initialize(encoder, VID_ENC_FULL_INIT_FLAG);
++
++		if (err >= 0) {
++			/* see if this has output requested by default
++			   or bootarg */
++
++			for (i = 0; i < encoder->output_ops->count; i++) {
++				err =
++				    encoder->output_ops->enumoutput(i, buf,
++								    encoder);
++				if (err != 0)
++					return err;
++				if (strcmp(buf, enc_def->output) == 0) {
++					err =
++					    encoder->output_ops->
++					    setoutput(enc_def->output, encoder);
++					found = 1;
++					break;
++				}
++			}
++
++			if (found == 1) {
++				err =
++				    encoder->mode_ops->setmode(&mode_info,
++							       encoder);
++				if (err != 0) {
++					printk
++					    (KERN_ERR
++					     "Setmode failed, reset to encoder"
++					     " default...\n");
++					encoder->deinitialize(encoder);
++					encoder->initialize(encoder, 0);
++					err = 0;
++				}
++			}
++
++			mgr->encoder[mgr->num_encoders++] = encoder;
++			mgr->current_encoder = 0;
++			encoder->output_ops->getoutput(mgr->current_output,
++						       encoder);
++			encoder->mode_ops->getmode(&mgr->current_mode, encoder);
++			if ((err = down_interruptible(&mgr->lock)) < 0)
++				return err;
++			davinci_enc_set_mode_platform(ch_id, mgr);
++			if (encoder->misc_ops != NULL
++			    && encoder->misc_ops->reset != NULL)
++				err |= encoder->misc_ops->reset(encoder);
++			up(&mgr->lock);
++			if (encoder->misc_ops != NULL
++			    && encoder->misc_ops->enable != NULL)
++				encoder->misc_ops->enable(1, encoder);
++		}
++	} else {
++		/* If we have more than one encoder module, then we still
++		   want to make sure we can set to the default output and
++		   mode. If current one is not the default, try this new
++		   one. If still no luck, just use the newly registered
++		   one as default */
++		cur_enc = davinci_get_cur_encoder(ch_id);
++
++		if ((strcmp(mgr->current_output,
++			    enc_def->output) != 0) && (cur_enc != NULL)) {
++			cur_enc->deinitialize(cur_enc);
++
++			err = encoder->initialize(encoder,
++						  VID_ENC_FULL_INIT_FLAG);
++
++			if (err < 0) {
++				/* no change if new one cannot be
++				   initialized */
++				encoder->deinitialize(encoder);
++				cur_enc->initialize(cur_enc, 0);
++				return err;
++			}
++			/* look for matching output */
++			for (i = 0; i < encoder->output_ops->count; i++) {
++				err =
++				    encoder->output_ops->enumoutput(i, buf,
++								    encoder);
++				if (err != 0)
++					return err;
++				if (strcmp(buf, enc_def->output) == 0) {
++					err =
++					    encoder->output_ops->
++					    setoutput(enc_def->output, encoder);
++					found = 1;
++					break;
++				}
++			}
++
++			if (found == 1) {
++				err |=
++				    encoder->mode_ops->setmode(&mode_info,
++							       encoder);
++				/* setmode went wrong, try redo init */
++				if (err != 0) {
++					printk
++					    (KERN_ERR
++					     "Set output or mode failed, "
++					     "reset to encoder default...\n");
++					encoder->deinitialize(encoder);
++					encoder->initialize(encoder, 0);
++					err = 0;
++				}
++			}
++
++			mgr->encoder[mgr->num_encoders++] = encoder;
++			mgr->current_encoder = mgr->num_encoders - 1;
++			encoder->output_ops->getoutput(mgr->current_output,
++						       encoder);
++			encoder->mode_ops->getmode(&mgr->current_mode, encoder);
++			if ((err = down_interruptible(&mgr->lock)) < 0)
++				return err;
++			davinci_enc_set_mode_platform(ch_id, mgr);
++			if (encoder->misc_ops != NULL
++			    && encoder->misc_ops->reset != NULL)
++				err |= encoder->misc_ops->reset(encoder);
++			up(&mgr->lock);
++			if (encoder->misc_ops != NULL
++			    && encoder->misc_ops->enable != NULL)
++				encoder->misc_ops->enable(1, encoder);
++
++		} else if (strcmp(mgr->current_output, enc_def->output) == 0) {
++			/* no change in output or mode */
++			mgr->encoder[mgr->num_encoders++] = encoder;
++
++		}
++	}
++
++	return err;
++}
++
++EXPORT_SYMBOL(vid_enc_register_encoder);
++
++/**
++ * vid_enc_unregister_encoder
++ * @encoder: pointer to the encoder device structure
++ * Returns: Zero if successful, or non-zero otherwise
++ *
++ * Description:
++ * Register the encoder module with the encoder manager
++ * This is implemented by the encoder Manager
++ */
++int vid_enc_unregister_encoder(struct vid_encoder_device *encoder)
++{
++	int i, j = 0, err = -EINVAL, ch_id;
++	struct vid_enc_device_mgr *mgr = 0;
++
++	if (ISNULL(encoder))
++		return err;
++
++	ch_id = encoder->channel_id;
++
++	if ((ch_id > DAVINCI_ENC_MAX_CHANNELS) || (ch_id < 0))
++		return err;
++
++	mgr = &enc_dev[ch_id];
++
++	for (i = 0; i < mgr->num_encoders; i++) {
++		if (encoder == mgr->encoder[i]) {
++
++			mgr->encoder[i] = NULL;
++			for (j = i; j < mgr->num_encoders - 1; j++)
++				mgr->encoder[j] = mgr->encoder[j + 1];
++			mgr->num_encoders--;
++			err = 0;
++			break;
++		}
++	}
++	return err;
++
++}
++
++EXPORT_SYMBOL(vid_enc_unregister_encoder);
++
++/**
++ * davinci_enc_enable_vbi
++ * @flag: flag which tells whether to enable or disable raw vbi
++ * Returns: Zero if successful, or non-zero otherwise
++ *
++ * Description:
++ * This function is used to enable/disable RAW VBI sending in
++ * the encoder.
++ */
++int davinci_enc_enable_vbi(int channel, int flag)
++{
++	struct vid_encoder_device *cur_enc = NULL;
++
++	cur_enc = davinci_get_cur_encoder(channel);
++
++	if (NULL == cur_enc || NULL == cur_enc->enable_vbi)
++		return -EINVAL;
++
++	return cur_enc->enable_vbi(flag, cur_enc);
++}
++
++EXPORT_SYMBOL(davinci_enc_enable_vbi);
++
++/**
++ * davinci_enc_enable_hbi
++ * @flag: flag which tells whether to enable or disable raw hbi
++ * Returns: Zero if successful, or non-zero otherwise
++ *
++ * Description:
++ * This function is used to enable/disable RAW HBI sending in
++ * the encoder.
++ */
++int davinci_enc_enable_hbi(int channel, int flag)
++{
++	struct vid_encoder_device *cur_enc = NULL;
++
++	cur_enc = davinci_get_cur_encoder(channel);
++
++	if (NULL == cur_enc || NULL == cur_enc->enable_hbi)
++		return -EINVAL;
++
++	return cur_enc->enable_hbi(flag, cur_enc);
++}
++
++EXPORT_SYMBOL(davinci_enc_enable_hbi);
++
++/**
++ * davinci_enc_enable_sliced_vbi
++ * @channel: channel number.
++ * @encoder: pointer to the encoder device structure
++ * Returns: Zero if successful, or non-zero otherwise
++ *
++ * Description:
++ * Following funcion is used to enable support for
++ * sending set of sliced vbi services. Caller calls
++ * this function with pointer to the structure vid_enc_sliced_vbi_service
++ */
++int davinci_enc_enable_sliced_vbi(int channel,
++				  struct vid_enc_sliced_vbi_service *services)
++{
++	struct vid_encoder_device *cur_enc = NULL;
++
++	cur_enc = davinci_get_cur_encoder(channel);
++
++	if (NULL == cur_enc || NULL == cur_enc->set_vbi_services)
++		return -EINVAL;
++
++	return cur_enc->set_vbi_services(services, cur_enc);
++}
++
++EXPORT_SYMBOL(davinci_enc_enable_sliced_vbi);
++
++/**
++ * davinci_enc_write_sliced_vbi_data
++ * @encoder: pointer to the encoder device structure
++ * Returns: Zero if successful, or non-zero otherwise
++ *
++ * Description:
++ * Register the encoder module with the encoder manager
++ * This is implemented by the encoder Manager
++ */
++int davinci_enc_write_sliced_vbi_data(int channel,
++				      struct vid_enc_sliced_vbi_data *data)
++{
++	struct vid_encoder_device *cur_enc = NULL;
++
++	cur_enc = davinci_get_cur_encoder(channel);
++
++	if (NULL == cur_enc || NULL == cur_enc->write_vbi_data)
++		return -EINVAL;
++
++	return cur_enc->write_vbi_data(data, cur_enc);
++}
++
++EXPORT_SYMBOL(davinci_enc_write_sliced_vbi_data);
++
++int davinci_enc_get_sliced_cap(int channel,
++			       struct vid_enc_sliced_vbi_service *service)
++{
++	struct vid_encoder_device *cur_enc = NULL;
++
++	cur_enc = davinci_get_cur_encoder(channel);
++
++	if (NULL == cur_enc || NULL == cur_enc->get_sliced_cap)
++		return -EINVAL;
++
++	return cur_enc->get_sliced_cap(service, cur_enc);
++}
++
++EXPORT_SYMBOL(davinci_enc_get_sliced_cap);
++
++subsys_initcall(davinci_enc_mngr_init);
++module_exit(davinci_enc_mngr_exit);
++
++MODULE_LICENSE("GPL");
++MODULE_DESCRIPTION("DaVinci Encoder Manager");
++MODULE_AUTHOR("Texas Instruments");
+--- /dev/null
++++ b/arch/arm/mach-davinci/pci-generic.c
+@@ -0,0 +1,493 @@
++/*
++ * pci-generic.c
++ *  Description:
++ *  Generic part of PCI Host Driver for TI PCI Module. Note that though code in
++ *  this file is supposed to be 'generic' it might still require some tweaking
++ *  when porting to other boards/platform using same TI PCI Module
++ *
++ * Copyright (C) 2009 Texas Instruments Incorporated - http://www.ti.com/
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License as
++ * published by the Free Software Foundation version 2.
++ *
++ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
++ * kind, whether express or implied; without even the implied warranty
++ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ */
++
++#undef DEBUG
++
++#include <linux/kernel.h>               /* pr_ wrappers */
++#include <linux/pci.h>                  /* PCI data structures */
++#include <asm/mach/pci.h>               /* hw_pci */
++#include <linux/types.h>
++#include <linux/interrupt.h>
++#include <asm/irq.h>
++
++#include "pci.h"               		/* Configuration data */
++
++/*
++ *  PCI Register Offsets
++ */
++#define PCISTATSET                      0x010
++#define PCISTATCLR                      0x014
++#define PCIHINTSET                      0x020
++#define PCIHINTCLR                      0x024
++#define PCIBINTSET                      0x030
++#define PCIBINTCLR                      0x034
++#define PCIVENDEVMIR                    0x100
++#define PCICSRMIR                       0x104
++#define PCICLREVMIR                     0x108
++#define PCICLINEMIR                     0x10C
++#define PCIBARMSK(n)                    (0x110 + (4 * n))     /* 6 Registers */
++#define PCISUBIDMIR                     0x12C
++#define PCICPBPTRMIR                    0x134
++#define PCILGINTMIR                     0x13C
++#define PCISLVCNTL                      0x180
++#define PCIBARTRL(n)                    (0x1C0 + (4 * n))     /* 6 Registers */
++#define PCIBARMIR(n)                    (0x1E0 + (4 * n))     /* 6 Registers */
++#define PCIMCFGDAT                      0x300
++#define PCIMCFGADR                      0x304
++#define PCIMCFGCMD                      0x308
++#define PCIMSTCFG                       0x310
++#define PCIADDSUB(n)                    (0x314 + (4 * n))     /* 32 Registers */
++#define PCIVENDEVPRG                    0x394
++#define PCICLREVPRG                     0x39C
++#define PCISUBIDPRG                     0x3A0
++#define PCIMAXLGPRG                     0x3A4
++#define PCICFGDONE                      0x3AC
++
++#define PCI_WAIT_FOR_RDY()              pci_wait_for_rdy()
++
++#define CFG_PCIM_CMD_IO                 BIT(2)
++#define CFG_PCIM_CMD_CONFIG             (0)
++#define CFG_PCIM_CMD_READ               BIT(0)
++#define CFG_PCIM_CMD_WRITE              (0)
++
++/* Command Register Values */
++#define PCIM_INTA_DIS        BIT(10)    /* Don't pass interrupt on INTA */
++#define PCIM_SERR_EN         BIT(8)     /* Propagate error on SERR# */
++#define PCIM_PERR_EN         BIT(6)     /* Consider parity error */
++#define PCIM_MEMWRINV_EN     BIT(4)     /* Invalidate memory writes */
++#define PCIM_BUS_MASTER      BIT(2)     /* Set as PCI master */
++#define PCIM_MEMACC_EN       BIT(1)     /* Host as memory slave */
++#define PCIM_IOACC_EN        BIT(0)     /* Host as IO device */
++#define PCIM_SPLCYC_EN       BIT(3)     /* Could be used for sideband
++					   signalling (non-critical) */
++/* Default value used for CSMIR register */
++#define CFG_PCIM_CSR_VAL         (PCIM_SERR_EN | PCIM_MEMWRINV_EN	\
++					| PCIM_BUS_MASTER             	\
++					| PCIM_MEMACC_EN              	\
++					| PCIM_INTA_DIS)
++
++#define PCIM_MAX_LAT_SHIFT        (24)
++#define PCIM_MAX_LAT_MASK         (0xFF << PCIM_MAX_LAT_SHIFT)
++#define PCIM_MAX_LAT_VAL          (CFG_PCIM_MAX_LAT << PCIM_MAX_LAT_SHIFT)
++
++#define PCIM_MIN_GRANT_SHIFT      (16)
++#define PCIM_MIN_GRANT_MASK       (0xFF << PCIM_MIN_GRANT_SHIFT)
++#define PCIM_MIN_GRANT_VAL        (CFG_PCIM_MIN_GRANT \
++					<< PCIM_MIN_GRANT_SHIFT)
++
++/* Error mask for errors to check on CFG/IO */
++#define CFG_PCI_ERR_MASK	  ((0xf << 28) | (1 < 24))
++
++/* Protect PCI accesses (config/io read/writes) */
++static DEFINE_SPINLOCK(ti_pci_lock);
++
++static inline void dump_pci_status(u32 status)
++{
++	pr_debug("PCI: Error Status:\nData Parity Error: %d, "
++		"System Error: %d\nMaster Abort: %d, "
++		"Target Abort: %d\nParity Report: %d\n",
++		((status & BIT(31)) != 0), ((status & BIT(30)) != 0),
++		((status & BIT(29)) != 0), ((status & BIT(28)) != 0),
++		((status & BIT(24)) != 0));
++}
++
++/* ti_pci_setup
++ *  This function does Host controller configuration before bios starts PCI bus
++ *  enumeration (scan).
++ */
++int ti_pci_setup(int nr, struct pci_sys_data *sys)
++{
++	int i, bar_en = 0;
++	struct resource *res;
++
++	pr_info("PCI: Setting up Host Controller...\n");
++	pr_debug("PCI: PCIADDSUB[0] @%#x\n", (u32)PCI_REGV(PCIADDSUB(0)));
++
++	if (nr != 0)
++		return 0;
++
++	/* Make specified Host windows visible over PCI bus. This will enable
++	 * PCI Masters to perform DMA to Host System RAM (1:1 mapping of
++	 * course!).
++	 */
++	for (i = 0; i < 6; i++) {
++		u32 size = bar_cfg[i].bar_window_size;
++		u32 addr = bar_cfg[i].bar_window_phys;
++
++		if (size) {
++			/* Ensure size in 16 B to 2 GB range */
++			if (size < 16)
++				size = 16;
++			else if (size > 0x80000000)
++				size = 0x80000000;
++
++			if (size & (size - 1))
++				size = BIT(fls(size));
++
++			bar_en |= BIT(i);
++
++			/* 1:1 from PCI -> Host */
++			__raw_writel(addr, PCI_REGV(PCIBARTRL(i)));
++
++			/* Setup PCI BAR Mirror register to bus address (= phys)
++			 */
++			__raw_writel(addr, PCI_REGV(PCIBARMIR(i)));
++		}
++
++		/* Set writable bits - masking for size */
++		__raw_writel(~(size-1), PCI_REGV(PCIBARMSK(i)));
++	}
++
++	/* Enable applicable  BAR windows in Slave control register and Set
++	 * CFG_DONE to enable PCI access
++	 */
++	__raw_writel(((bar_en << 16) | 1), PCI_REGV(PCISLVCNTL));
++
++	/* IMPORTANT *** Change our class code from
++	 * PCI_BASE_CLASS_SIGNAL_PROCESSING(PCI_CLASS_SP_OTHER = 0x1180) to
++	 * PCI_CLASS_BRIDGE_HOST (0x0600) to prevent resource (BAR) assignment
++	 * to us. The PCI probe will be happy with whatever original BAR
++	 * settings we have!
++	 * If at all we want to restore the default class-subclass values, the
++	 * best place would be to set mirror register after returning from
++	 * pci_common_init () [in dm6467_pci_init()].
++	 */
++	__raw_writel(((__raw_readl(PCI_REGV(PCICLREVMIR)) & 0xffff)
++			| (PCI_CLASS_BRIDGE_HOST << 16)),
++			PCI_REGV(PCICLREVMIR));
++
++	/*
++	 * Set PHYADDR <-> BUSADDR mapping for accessing 256MB PCI space
++	 */
++
++	/* Using Direct 1:1 mapping of DMSoC <-> PCI memory space */
++	for (i = 0; i < CFG_PCIM_WINDOW_CNT; i++)
++		__raw_writel((CFG_PCIM_MEM_START + (CFG_PCIM_WINDOW_SZ*i)),
++				PCI_REGV(PCIADDSUB(i)));
++
++
++	/* Setup as PCI master */
++	pr_debug("PCI: Default PCICSRMIR = %x\n",
++			__raw_readl(PCI_REGV(PCICSRMIR)));
++
++	__raw_writel((__raw_readl(PCI_REGV(PCICSRMIR)) | CFG_PCIM_CSR_VAL),
++			PCI_REGV(PCICSRMIR));
++
++	pr_debug("PCI: New PCICSRMIR = %x\n",
++			__raw_readl(PCI_REGV(PCICSRMIR)));
++
++	__raw_writel(((__raw_readl(PCI_REGV(PCILGINTMIR))
++				& ~PCIM_MAX_LAT_MASK & ~PCIM_MIN_GRANT_MASK)
++				| PCIM_MAX_LAT_VAL | PCIM_MIN_GRANT_VAL),
++			PCI_REGV(PCILGINTMIR));
++
++	/*
++	 * Setup resources which will be used assign BARs to targets during
++	 * scanning
++	 */
++
++	/* Overwrite the resources which were set up by default by
++	 * pcibios_init_hw
++	 */
++	res = kzalloc(sizeof(*res) * 2, GFP_KERNEL);
++	if (res == NULL) {
++		panic("PCI: resource structure allocation failed.\n");
++		/* Not reached */
++		return 0;
++	}
++
++	res[0].start = PCIBIOS_MIN_IO;
++	res[0].end = PCIBIOS_MAX_IO;
++	res[0].name = "PCI I/O";
++	res[0].flags = IORESOURCE_IO;
++
++	res[1].start = CFG_PCIM_MEM_START;
++	res[1].end = CFG_PCIM_MEM_END;
++	res[1].name = "PCI Memory";
++	res[1].flags = IORESOURCE_MEM;
++
++	request_resource(&ioport_resource, &res[0]);
++	request_resource(&iomem_resource, &res[1]);
++
++	sys->resource[0] = &res[0];
++	sys->resource[1] = &res[1];
++	sys->resource[2] = NULL;
++
++	return 1;
++}
++
++static inline u32 get_config_addr(u8 bus, u16 devfn, int where)
++{
++	u32 addr;
++
++	/* Determine configuration cycle type depending upon the bus:
++	 * - TYPE 0 for PCI bus directly connected to host
++	 * - TYPE 1 for across bridge(s)
++	 */
++	if (bus == 0) {
++		/* TYPE 0 */
++		addr = BIT(11 + PCI_SLOT(devfn)) | (PCI_FUNC(devfn) << 8)
++			| (where & ~3);
++	} else {
++		/* TYPE 1 */
++		addr = (bus << 16) | (PCI_SLOT(devfn) << 11)
++			| (PCI_FUNC(devfn) << 8) | (where & ~3) | 1;
++	}
++
++	return addr;
++}
++
++static inline int get_byte_enables(u32 addr, u32 size)
++{
++	/*
++	 * Byte Enables (BE#[3:0]) will be generated taking into account AD[1:0]
++	 * and size of transaction (1-4 Byte). Refer following table:
++	 *  PCI_ADDR[1:0]       Starting Byte           BE#[3:0]
++	 * -----------------------------------------------------------------
++	 *  00                  Byte 0                  xxx0 (size = 1->4)
++	 *  01                  Byte 1                  xx01 (size = 1->3)
++	 *  10                  Byte 2                  x011 (size = 1->2)
++	 *  11                  Byte 3                  0111 (size = 1)
++	 *
++	 *  (Here 'x' can either be '0' (byte enabled) or '1' as required by
++	 *  'size')
++	 *
++	 *  As mentioned above, BE values are function of 'size' and AD[1:0] as
++	 *  well as size so we start by doing sanity check on combination of
++	 *  supplied parameters. We won't return any error as such, but any
++	 *  wrong combination will result into either all BE de-asserted or
++	 *  only/all possible BEs asserted. E.g.,
++	 *  size=0 -> All BEs de-asserted
++	 *  size>4 -> Only possible BEs de-asserted
++	 */
++
++	addr &= 3;
++
++	pr_debug("PCI: AD[1:0]:size = %01x:%01x, Byte enables = %#lx\n",
++			addr&3, size, (((BIT(size) - 1) << addr) & 0xf));
++
++	/* BE values are inverted for BE# */
++	return ((BIT(size) - 1) << addr) & 0xf;
++}
++
++/*
++ * Returns:
++ *  0   - When READY bit is not set within timeout, else non-zero.
++ */
++static inline int pci_wait_for_rdy(void)
++{
++	int wait_cnt = CFG_PCI_READY_WAITCNT;
++
++	/* Note : This function doesn't check aborts since the READY bit it set
++	 * when bus aborts happen. Need to verify this is true for all kinds of
++	 * PCI access errors.
++	 */
++	while (wait_cnt && !(__raw_readl(PCI_REGV(PCIMCFGCMD)) & BIT(31)))
++		wait_cnt--;
++
++	return (wait_cnt != 0);
++}
++
++static inline int pci_err(void)
++{
++	u32 status = __raw_readl(PCI_REGV(PCICSRMIR));
++	if (status & CFG_PCI_ERR_MASK) {
++		dump_pci_status(status);
++		return status >> 24;
++	} else {
++		return 0;
++	}
++}
++
++static inline int pci_cfgio_read(u32 addr, int size, u32 *value,
++					int be, int access_type)
++{
++	unsigned long flags;
++	int ret_val = 0;
++
++	spin_lock_irqsave(&ti_pci_lock, flags);
++
++	/* Check of READY. Continue even if not READY as we will catch the error
++	 * after operation. Same logic is applied for 'write' operation below...
++	 */
++	if (!PCI_WAIT_FOR_RDY())
++		pr_warning("PCI: CFG/IO not ready."
++			"Might need tuning CFG_PCI_READY_WAITCNT value.\n");
++
++	/* Clear aborts */
++	__raw_writel((__raw_readl(PCI_REGV(PCICSRMIR)) | (0xFF << 24)),
++			PCI_REGV(PCICSRMIR));
++
++	__raw_writel(addr, PCI_REGV(PCIMCFGADR));
++
++	__raw_writel((BIT(31) | ((access_type == PCI_ACCESS_TYPE_CFG)
++				? CFG_PCIM_CMD_CONFIG : CFG_PCIM_CMD_IO)
++			| CFG_PCIM_CMD_READ
++			| (be << 4)), PCI_REGV(PCIMCFGCMD));
++
++	/* Check for READY. */
++	ret_val = !PCI_WAIT_FOR_RDY();
++
++	if (pci_err()) {
++		pr_debug("PCI: CFG/IO Read @%#x Failed.\n", addr);
++		*value = ~0;
++		/* Clear aborts */
++		__raw_writel((__raw_readl(PCI_REGV(PCICSRMIR)) | (0xFF << 24)),
++				PCI_REGV(PCICSRMIR));
++		ret_val = -1;
++	} else {
++		*value = __raw_readl(PCI_REGV(PCIMCFGDAT));
++		pr_debug("PCI: Config/IO read done, value = %x\n", *value);
++	}
++
++	spin_unlock_irqrestore(&ti_pci_lock, flags);
++	return ret_val;
++}
++
++/*
++ * This is just a wrapper (exported) to provide BE value for I/O
++ */
++int ti_pci_io_read(u32 addr, int size, u32 *value)
++{
++	int ret_val = pci_cfgio_read(addr, size, value,
++					get_byte_enables(addr, size),
++					PCI_ACCESS_TYPE_IO);
++	*value >>= ((addr & 3)*8);
++	pr_debug("PCI: IO read @%#x = %#x\n", addr, *value);
++	return ret_val;
++}
++EXPORT_SYMBOL(ti_pci_io_read);
++
++static int ti_pci_read_config(struct pci_bus *bus, unsigned int devfn,
++				int where, int size, u32 *value)
++{
++	u8 bus_num = bus->number;
++
++	/* Sanity checks */
++	if ((bus_num == 0) && (PCI_SLOT(devfn) >= PCI_MAX_SLOTS))
++		return PCIBIOS_DEVICE_NOT_FOUND;
++
++	pr_debug("PCI: Reading config[%x] for device %04x:%02x:%02x ...",
++			where, bus_num, PCI_SLOT(devfn), PCI_FUNC(devfn));
++
++	if (pci_cfgio_read(get_config_addr(bus_num, devfn, where), size,
++				value, get_byte_enables(where, size),
++				PCI_ACCESS_TYPE_CFG)) {
++		/* Ignoring other error codes (> 0) */
++		pr_debug("failed.");
++		return PCIBIOS_DEVICE_NOT_FOUND;
++	} else {
++		*value >>= ((where & 3)*8);
++		pr_debug("done, value = %x\n", *value);
++		return PCIBIOS_SUCCESSFUL;
++	}
++}
++
++static int pci_cfgio_write(u32 addr, int size, u32 value,
++				int be, int access_type)
++{
++	unsigned long flags;
++	int ret_val = 0;
++
++	spin_lock_irqsave(&ti_pci_lock, flags);
++
++	/* Check of READY */
++	if (!PCI_WAIT_FOR_RDY())
++		pr_warning("PCI: CFG/IO not ready."
++			"Might need tuning CFG_PCI_READY_WAITCNT value.\n");
++
++	/* Clear aborts */
++	__raw_writel((__raw_readl(PCI_REGV(PCICSRMIR)) | (0xFF << 24)),
++			PCI_REGV(PCICSRMIR));
++
++	__raw_writel((value << ((addr & 3)*8)), PCI_REGV(PCIMCFGDAT));
++	__raw_writel(addr, PCI_REGV(PCIMCFGADR));
++
++	__raw_writel((0x80000000 | ((access_type == PCI_ACCESS_TYPE_CFG)
++					? CFG_PCIM_CMD_CONFIG : CFG_PCIM_CMD_IO)
++			| CFG_PCIM_CMD_WRITE | (be << 4)),
++			PCI_REGV(PCIMCFGCMD));
++
++	/* Check for READY. */
++	ret_val = !PCI_WAIT_FOR_RDY();
++
++	if (pci_err()) {
++		pr_debug("PCI: CFG/IO Write @%#x Failed\n", addr);
++		/* Clear aborts */
++		__raw_writel((__raw_readl(PCI_REGV(PCICSRMIR)) | (0xFF << 24)),
++				PCI_REGV(PCICSRMIR));
++		ret_val = -1;
++	} else {
++		pr_debug("PCI: Config/IO write done.\n");
++	}
++
++	spin_unlock_irqrestore(&ti_pci_lock, flags);
++	return ret_val;
++}
++
++/*
++ * This is just a wrapper (exported) to provide BE value for I/O
++ */
++int ti_pci_io_write(u32 addr, int size, u32 value)
++{
++	pr_debug("PCI: IO write @%#x = %#x\n", addr, value);
++	return pci_cfgio_write(addr, size, value,
++				get_byte_enables(addr, size),
++				PCI_ACCESS_TYPE_IO);
++}
++EXPORT_SYMBOL(ti_pci_io_write);
++
++static int ti_pci_write_config(struct pci_bus *bus, unsigned int devfn,
++				int where, int size, u32 value)
++{
++	u8 bus_num = bus->number;
++
++	/* Sanity checks */
++	if ((bus_num == 0) && (PCI_SLOT(devfn) >= PCI_MAX_SLOTS))
++		return PCIBIOS_DEVICE_NOT_FOUND;
++
++	pr_debug("PCI: Writing config[%x] = %x "
++			"for device %04x:%02x:%02x ...", where, value,
++			bus_num, PCI_SLOT(devfn), PCI_FUNC(devfn));
++
++	if (pci_cfgio_write(get_config_addr(bus_num, devfn, where),
++				size, value, get_byte_enables(where, size),
++				PCI_ACCESS_TYPE_CFG)) {
++		/* Ignoring other error codes (> 0) */
++		pr_debug("failed.\n");
++		return PCIBIOS_DEVICE_NOT_FOUND;
++	} else {
++		pr_debug("done.\n");
++		return PCIBIOS_SUCCESSFUL;
++	}
++}
++
++static struct pci_ops ti_pci_ops = {
++	.read	= ti_pci_read_config,
++	.write	= ti_pci_write_config,
++};
++
++struct pci_bus *ti_pci_scan(int nr, struct pci_sys_data *sys)
++{
++	pr_info("PCI: Starting PCI scan...\n");
++	if (nr == 0)
++		return pci_scan_bus(0, &ti_pci_ops, sys);
++
++	return NULL;
++}
+--- /dev/null
++++ b/drivers/media/video/davinci/dm355_aew_hw.c
+@@ -0,0 +1,141 @@
++/*
++ * Copyright (C) 2009 Texas Instruments Inc
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
++ */
++
++#include <media/davinci/dm355_aew.h>
++#include <media/davinci/dm355_aew_hw.h>
++#include <linux/device.h>
++
++extern struct device *aewdev;
++
++int aew_register_setup(struct aew_device *aew_dev)
++{
++	unsigned int pcr = 0, win1 = 0, winstart = 0, blkwin = 0, subwin = 0;
++
++	/* Set up the registers */
++	pcr = regr(AEWPCR);
++
++	/* Enable A Law */
++	if (aew_dev->config->alaw_enable == H3A_AEW_ENABLE)
++		pcr |= AEW_ALAW_EN;
++	else
++		pcr &= ~AEW_ALAW_EN;
++
++	/*Configure Saturation limit */
++	pcr &= ~AVE2LMT;
++	pcr |= aew_dev->config->saturation_limit << AEW_AVE2LMT_SHIFT;
++
++	/* Set Input Source */
++	pcr &= ~AEW_INP_SRC;
++	pcr |= (AEW_CCDC) << AEW_INP_SRC_SHIFT;
++
++	regw(pcr, AEWPCR);
++
++	/* Configure Window Width in AEWWIN1 register */
++	win1 = 0;
++	win1 |= ((AEW_SET_VAL(aew_dev->config->window_config.height)) <<
++		AEW_WINH_SHIFT);
++
++	/* Configure Window height in AEWWIN1 register */
++	win1 |= ((AEW_SET_VAL(aew_dev->config->window_config.width)) <<
++		AEW_WINW_SHIFT);
++
++	/* Configure Window vertical count in AEWWIN2 register */
++	win1 |= ((aew_dev->config->window_config).vt_cnt - 1) <<
++		AEW_VT_COUNT_SHIFT;
++
++	/* Configure Window horizontal count in AEWWIN1 register */
++	win1 |= ((aew_dev->config->window_config).hz_cnt - 1);
++
++	/* Configure Window vertical start in AEWWIN1 register */
++	regw(win1, AEWWIN1);
++
++	/* Window Start parameter configuration */
++	winstart &= ~WINSV;
++	winstart |= (aew_dev->config->window_config).vt_start <<
++			AEW_VT_START_SHIFT;
++
++	/* Configure Window horizontal start  in AEWWIN2 register */
++	winstart &= ~WINSH;
++	winstart |= (aew_dev->config->window_config).hz_start;
++	regw(winstart, AEWINSTART);
++
++	/* 
++	 * Window Line Increment configuration
++	 * Configure vertical line increment in AEWSUBWIN
++	 */
++	subwin &= ~AEWINCV;
++	subwin |= (AEW_SET_VAL(aew_dev->config->window_config.
++			 vt_line_incr) << AEW_LINE_INCR_SHIFT);
++
++	/* Configuring Horizontal Line increment in AEWSUBWIN */
++	subwin &= ~AEWINCH;
++	subwin |= (AEW_SET_VAL(aew_dev->config->window_config.hz_line_incr));
++
++	regw(subwin, AEWSUBWIN);
++
++	/* 
++	 * Black Window Configuration
++	 * Configure vertical start and height in AEWWINBLK
++	 */
++	blkwin &= ~BLKWINSV;
++	blkwin |= (aew_dev->config->blackwindow_config).
++			vt_start << AEW_BLKWIN_VT_START_SHIFT;
++
++	/* Configure height in Black window */
++	blkwin &= ~BLKWINH;
++	blkwin |= (AEW_SET_VAL(aew_dev->config->blackwindow_config.height));
++			regw(blkwin, AEWINBLK);
++
++	/* Set AFBUFST to Current buffer Physical Address */
++	regw((unsigned int)(virt_to_phys(aew_dev->buff_curr)), AEWBUFST);
++	dev_dbg(aewdev, "\n PCR is %x", regr(AEWPCR));
++	dev_dbg(aewdev, "\n SUBWIN is %x", regr(AEWSUBWIN));
++	dev_dbg(aewdev, "\n WINSTART is %x", regr(AEWINSTART));
++	dev_dbg(aewdev, "\n WINBLK is %x", regr(AEWINBLK));
++	dev_dbg(aewdev, "\n WIN1  is %x", regr(AEWWIN1));
++	dev_dbg(aewdev, "\n AEWBUST %x", regr(AEWBUFST));
++
++	AEW_SETGAMMAWD;
++
++	return 0;
++}
++
++/* Function to enable/ disable AEW Engine */
++inline void aew_engine_setup(int value)
++{
++	unsigned int pcr;
++
++	dev_dbg(aewdev, "\nAEW_REG(PCR) Before Setting %x", regr(AEWPCR));
++
++	/* Read Pcr Register */
++	pcr = regr(AEWPCR);
++	pcr &= ~AEW_EN;
++	pcr |= (value << AEW_EN_SHIFT);
++
++	/*Set AF_EN bit in PCR Register */
++	regw(pcr, AEWPCR);
++
++	dev_dbg(aewdev, "\nAfter Setting %d : PCR VALUE %x", value,
++		regr(AEWPCR));
++}
++
++/* Function used to set adddress */
++inline void aew_set_address(unsigned long address)
++{
++	regw(address, AEWBUFST);
++}
+--- a/arch/arm/mach-davinci/board-dm644x-evm.c
++++ b/arch/arm/mach-davinci/board-dm644x-evm.c
+@@ -238,8 +238,8 @@ static struct vpfe_route tvp5146_routes[
+ 
+ static struct vpfe_subdev_info vpfe_sub_devs[] = {
+ 	{
+-		.name = "tvp5146",
+-		.grp_id = 0,
++		.module_name = TVP514X_MODULE_NAME,
++		.grp_id = VPFE_SUBDEV_TVP5146,
+ 		.num_inputs = ARRAY_SIZE(tvp5146_inputs),
+ 		.inputs = tvp5146_inputs,
+ 		.routes = tvp5146_routes,
+@@ -261,6 +261,8 @@ static struct vpfe_config vpfe_cfg = {
+ 	.sub_devs = vpfe_sub_devs,
+ 	.card_name = "DM6446 EVM",
+ 	.ccdc = "DM6446 CCDC",
++	.num_clocks = 2,
++	.clocks = {"vpss_master", "vpss_slave"},
+ };
+ 
+ static struct platform_device rtc_dev = {
+--- a/drivers/regulator/Makefile
++++ b/drivers/regulator/Makefile
+@@ -26,4 +26,7 @@ obj-$(CONFIG_REGULATOR_AB3100) += ab3100
+ obj-$(CONFIG_REGULATOR_TPS65023) += tps65023-regulator.o
+ obj-$(CONFIG_REGULATOR_TPS6507X) += tps6507x-regulator.o
+ 
++obj-$(CONFIG_REGULATOR_TPS65023) += tps65023-regulator.o
++obj-$(CONFIG_REGULATOR_TPS6507X) += tps6507x-regulator.o
++
+ ccflags-$(CONFIG_REGULATOR_DEBUG) += -DDEBUG
+--- /dev/null
++++ b/include/media/davinci/dm3xx_ipipe.h
+@@ -0,0 +1,298 @@
++/*
++ * Copyright (C) 2008 Texas Instruments Inc
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
++ *
++ * Contains all ipipeif specific types used by applications and driver
++ */
++
++#ifndef _DM3XX_IPIPE_H
++#define _DM3XX_IPIPE_H
++/* Used to shift input image data based on the data lines connected
++ * to parallel port
++ */
++/* IPIPE base specific types */
++enum ipipeif_data_shift {
++	IPIPEIF_BITS15_2,
++	IPIPEIF_BITS14_1,
++	IPIPEIF_BITS13_0,
++	IPIPEIF_BITS12_0,
++	IPIPEIF_BITS11_0,
++	IPIPEIF_BITS10_0,
++	IPIPEIF_BITS9_0
++};
++
++enum ipipeif_clkdiv {
++	IPIPEIF_DIVIDE_HALF,
++	IPIPEIF_DIVIDE_THIRD,
++	IPIPEIF_DIVIDE_FOURTH,
++	IPIPEIF_DIVIDE_FIFTH,
++	IPIPEIF_DIVIDE_SIXTH,
++	IPIPEIF_DIVIDE_EIGHTH,
++	IPIPEIF_DIVIDE_SIXTEENTH,
++	IPIPEIF_DIVIDE_THIRTY
++};
++
++/* IPIPE 5.1 interface types */
++/* dpcm predicator for IPIPE 5.1 */
++enum ipipeif_dpcm_pred {
++	DPCM_SIMPLE_PRED,
++	DPCM_ADV_PRED
++};
++/* data shift for IPIPE 5.1 */
++enum ipipeif_5_1_data_shift {
++	IPIPEIF_5_1_BITS11_0,
++	IPIPEIF_5_1_BITS10_0,
++	IPIPEIF_5_1_BITS9_0,
++	IPIPEIF_5_1_BITS8_0,
++	IPIPEIF_5_1_BITS7_0,
++	IPIPEIF_5_1_BITS15_4,
++};
++
++/* clockdiv for IPIPE 5.1 */
++struct ipipeif_5_1_clkdiv {
++	unsigned char m;
++	unsigned char n;
++};
++
++/* DPC at the if for IPIPE 5.1 */
++struct ipipeif_dpc {
++	/* 0 - disable, 1 - enable */
++	unsigned char en;
++	/* threshold */
++	unsigned short thr;
++};
++
++enum ipipeif_decimation {
++	IPIPEIF_DECIMATION_OFF,
++	IPIPEIF_DECIMATION_ON
++};
++
++enum 	ipipeif_pixel_order {
++	IPIPEIF_CBCR_Y,
++	IPIPEIF_Y_CBCR
++};
++
++#ifdef __KERNEL__
++#include <linux/kernel.h>
++//#include <asm/arch/cpu.h>
++#include <mach/hardware.h>
++#include <asm/io.h>
++#include <media/davinci/vpss.h>
++#include <media/davinci/vpfe_types.h>
++
++enum ipipeif_clock {
++	PIXCEL_CLK,
++	SDRAM_CLK
++};
++
++enum ipipeif_pack_mode  {
++	IPIPEIF_PACK_16_BIT,
++	IPIPEIF_PACK_8_BIT
++};
++
++enum ipipe_oper_mode {
++	CONTINUOUS,
++	ONE_SHOT
++};
++
++enum ipipeif_5_1_pack_mode  {
++	IPIPEIF_5_1_PACK_16_BIT,
++	IPIPEIF_5_1_PACK_8_BIT,
++	IPIPEIF_5_1_PACK_8_BIT_A_LAW,
++	IPIPEIF_5_1_PACK_12_BIT
++};
++
++enum  ipipeif_avg_filter {
++	AVG_OFF,
++	AVG_ON
++};
++
++enum  ipipeif_input_source {
++	CCDC,
++	SDRAM_RAW,
++	CCDC_DARKFM,
++	SDRAM_YUV
++};
++
++enum ipipeif_ialaw {
++	ALAW_OFF,
++	ALAW_ON
++};
++
++struct ipipeif_base {
++	enum ipipeif_ialaw ialaw;
++	enum ipipeif_pack_mode pack_mode;
++	enum ipipeif_data_shift data_shift;
++	enum ipipeif_clkdiv clk_div;
++};
++
++enum  ipipeif_input_src1 {
++	SRC1_PARALLEL_PORT,
++	SRC1_SDRAM_RAW,
++	SRC1_ISIF_DARKFM,
++	SRC1_SDRAM_YUV
++};
++
++enum ipipeif_dpcm_type {
++	DPCM_8BIT_10BIT,
++	DPCM_8BIT_12BIT
++};
++
++struct ipipeif_dpcm_decomp {
++	unsigned char en;
++	enum ipipeif_dpcm_type type;
++	enum ipipeif_dpcm_pred pred;
++};
++
++enum ipipeif_dfs_dir {
++	IPIPEIF_PORT_MINUS_SDRAM,
++	IPIPEIF_SDRAM_MINUS_PORT
++};
++
++struct ipipeif_5_1 {
++	enum ipipeif_5_1_pack_mode pack_mode;
++	enum ipipeif_5_1_data_shift data_shift;
++	enum ipipeif_input_src1 source1;
++	struct ipipeif_5_1_clkdiv clk_div;
++	/* Defect pixel correction */
++	struct ipipeif_dpc dpc;
++	/* DPCM decompression */
++	struct ipipeif_dpcm_decomp dpcm;
++	/* ISIF port pixel order */
++	enum ipipeif_pixel_order pix_order;
++	/* interface parameters from isif */
++	struct vpfe_hw_if_param isif_port;
++	/* clipped to this value */
++	unsigned short clip;
++	/* Align HSync and VSync to rsz_start */
++	unsigned char align_sync;
++	/* resizer start position */
++	unsigned int rsz_start;
++	/* DF gain enable */
++	unsigned char df_gain_en;
++	/* DF gain value */
++	unsigned short df_gain;
++	/* DF gain threshold value */
++	unsigned short df_gain_thr;
++};
++
++/* ipipeif structures common to DM350 and DM365 used by ipipeif API */
++struct ipipeif {
++	enum ipipe_oper_mode mode;
++	enum ipipeif_input_source source;
++	enum ipipeif_clock clock_select;
++	unsigned int glob_hor_size;
++	unsigned int glob_ver_size;
++	unsigned int hnum;
++	unsigned int vnum;
++	unsigned int adofs;
++	unsigned char rsz;
++	enum ipipeif_decimation decimation;
++	enum ipipeif_avg_filter avg_filter;
++	unsigned short gain;
++	/* IPIPE 5.1 */
++	union var_part {
++		struct ipipeif_base if_base;
++		struct ipipeif_5_1  if_5_1;
++	} var;
++};
++
++/* IPIPEIF Register Offsets from the base address */
++#define IPIPEIF_ENABLE 			(0x00)
++#define IPIPEIF_GFG1			(0x04)
++#define IPIPEIF_PPLN			(0x08)
++#define IPIPEIF_LPFR			(0x0C)
++#define IPIPEIF_HNUM 			(0x10)
++#define IPIPEIF_VNUM    		(0x14)
++#define IPIPEIF_ADDRU   		(0x18)
++#define IPIPEIF_ADDRL   		(0x1C)
++#define IPIPEIF_ADOFS   		(0x20)
++#define IPIPEIF_RSZ   			(0x24)
++#define IPIPEIF_GAIN  	 		(0x28)
++
++/* Below registers are available only on IPIPE 5.1 */
++#define IPIPEIF_DPCM   			(0x2C)
++#define IPIPEIF_CFG2   			(0x30)
++#define IPIPEIF_INIRSZ 			(0x34)
++#define IPIPEIF_OCLIP  			(0x38)
++#define IPIPEIF_DTUDF  			(0x3C)
++#define IPIPEIF_CLKDIV			(0x40)
++#define IPIPEIF_DPC1  			(0x44)
++#define IPIPEIF_DPC2  			(0x48)
++#define IPIPEIF_DFSGVL			(0x4C)
++#define IPIPEIF_DFSGTH			(0x50)
++#define IPIPEIF_RSZ3A 			(0x54)
++#define IPIPEIF_INIRSZ3A		(0x58)
++#define IPIPEIF_RSZ_MIN			(16)
++#define IPIPEIF_RSZ_MAX			(112)
++#define IPIPEIF_RSZ_CONST		(16)
++#define SETBIT(reg, bit)   (reg = ((reg) | ((0x00000001)<<(bit))))
++#define RESETBIT(reg, bit) (reg = ((reg) & (~(0x00000001<<(bit)))))
++
++#define IPIPEIF_ADOFS_LSB_MASK 		(0x1FF)
++#define IPIPEIF_ADOFS_LSB_SHIFT		(5)
++#define IPIPEIF_ADOFS_MSB_MASK 		(0x200)
++#define IPIPEIF_ADDRU_MASK 		(0x7FF)
++#define IPIPEIF_ADDRL_SHIFT		(5)
++#define IPIPEIF_ADDRL_MASK		(0xFFFF)
++#define IPIPEIF_ADDRU_SHIFT		(21)
++#define IPIPEIF_ADDRMSB_SHIFT		(31)
++#define IPIPEIF_ADDRMSB_LEFT_SHIFT 	(10)
++
++/* CFG1 Masks and shifts */
++#define ONESHOT_SHIFT			(0)
++#define DECIM_SHIFT			(1)
++#define INPSRC_SHIFT			(2)
++#define CLKDIV_SHIFT			(4)
++#define AVGFILT_SHIFT			(7)
++#define PACK8IN_SHIFT			(8)
++#define IALAW_SHIFT			(9)
++#define CLKSEL_SHIFT			(10)
++#define DATASFT_SHIFT			(11)
++#define INPSRC1_SHIFT			(14)
++
++/* DPC2 */
++#define IPIPEIF_DPC2_EN_SHIFT		(12)
++#define IPIPEIF_DPC2_THR_MASK		(0xFFF)
++#define IPIPEIF_DF_GAIN_EN_SHIFT	(10)
++#define IPIPEIF_DF_GAIN_MASK		(0x3FF)
++#define IPIPEIF_DF_GAIN_THR_MASK	(0xFFF)
++/* DPCM */
++#define IPIPEIF_DPCM_BITS_SHIFT		(2)
++#define IPIPEIF_DPCM_PRED_SHIFT		(1)
++/* CFG2 */
++#define IPIPEIF_CFG2_HDPOL_SHIFT	(1)
++#define IPIPEIF_CFG2_VDPOL_SHIFT	(2)
++#define IPIPEIF_CFG2_YUV8_SHIFT		(6)
++#define	IPIPEIF_CFG2_YUV16_SHIFT	(3)
++#define	IPIPEIF_CFG2_YUV8P_SHIFT	(7)
++
++/* INIRSZ */
++#define IPIPEIF_INIRSZ_ALNSYNC_SHIFT	(13)
++#define IPIPEIF_INIRSZ_MASK		(0x1FFF)
++
++/* CLKDIV */
++#define IPIPEIF_CLKDIV_M_SHIFT		8
++
++int ipipeif_hw_setup(struct ipipeif *if_params);
++int ipipeif_set_address(struct ipipeif *if_params, unsigned int address);
++void ipipeif_set_enable(char en, unsigned int mode);
++u32 ipipeif_get_enable(void);
++void ipipeif_dump_register(void);
++
++#endif
++#endif
++
+--- a/arch/arm/mach-davinci/serial.c
++++ b/arch/arm/mach-davinci/serial.c
+@@ -84,8 +84,11 @@ int __init davinci_serial_init(struct da
+ 	 * You have to mux them off in device drivers later on if not needed.
+ 	 */
+ 	for (i = 0; i < DAVINCI_MAX_NR_UARTS; i++, p++) {
+-		if (!(info->enabled_uarts & (1 << i)))
+-			continue;
++		if (!cpu_is_davinci_dm355() &&
++			!cpu_is_davinci_dm365()) {
++			if (!(info->enabled_uarts & (1 << i)))
++				continue;
++		}
+ 
+ 		sprintf(name, "uart%d", i);
+ 		uart_clk = clk_get(dev, name);
+--- a/arch/arm/mach-davinci/include/mach/dm646x.h
++++ b/arch/arm/mach-davinci/include/mach/dm646x.h
+@@ -26,10 +26,20 @@
+ 
+ #define DM646X_ATA_REG_BASE		(0x01C66000)
+ 
++/* System module register offsets */
++#define PINMUX0				0x00
++#define PINMUX1				0x04
++#define BOOTCFG				0x14
++
+ void __init dm646x_init(void);
+ void __init dm646x_init_ide(void);
+ void __init dm646x_init_mcasp0(struct snd_platform_data *pdata);
+ void __init dm646x_init_mcasp1(struct snd_platform_data *pdata);
++void __init dm646x_init_cir_device(void);
++
++
++struct spi_board_info;
++void dm646x_init_spi0(struct spi_board_info *info, unsigned len);
+ 
+ void dm646x_video_init(void);
+ 
+@@ -88,4 +98,11 @@ struct vpif_capture_config {
+ void dm646x_setup_vpif(struct vpif_display_config *,
+ 		       struct vpif_capture_config *);
+ 
++void dm646x_video_init(void);
++
++struct vpif_output {
++	u16 id;
++	const char *name;
++};
++
+ #endif /* __ASM_ARCH_DM646X_H */
+--- a/arch/arm/mach-davinci/include/mach/io.h
++++ b/arch/arm/mach-davinci/include/mach/io.h
+@@ -17,7 +17,229 @@
+  * We don't actually have real ISA nor PCI buses, but there is so many
+  * drivers out there that might just work if we fake them...
+  */
++#if !defined CONFIG_PCI || defined __ASSEMBLER__
+ #define __io(a)			__typesafe_io(a)
++#else
++#include <mach/pci.h>
++/*
++ * Here we provide DMSoC to PCI I/O space access as PCI I/O is performed
++ * indirectly by accessing PCI IO Register.
++ *
++ * We will still use the default I/O (memory mapped for ARM)  for any access
++ * which is outside the allotted PCI I/O window. Note: In this case we replicate
++ * the default inx/outx behavior as found in include/asm-arm/io.h (except of
++ * course, addition of sequence point, which is not needed in our case).
++ */
++#define CFG_PCIM_IO_START               (PCIBIOS_MIN_IO)
++#define CFG_PCIM_IO_END                 0x4BFFFFFF
++
++#define	outb(v, p)			_davinci_outb(v, p)
++#define	outw(v, p)			_davinci_outw(v, p)
++#define	outl(v, p)			_davinci_outl(v, p)
++
++#define	outsb(p, d, l)			_davinci_outsb(p, d, l)
++#define	outsw(p, d, l)			_davinci_outsw(p, d, l)
++#define	outsl(p, d, l)			_davinci_outsl(p, d, l)
++
++#define	inb(p)				_davinci_inb(p)
++#define	inw(p)				_davinci_inw(p)
++#define	inl(p)				_davinci_inl(p)
++
++#define	insb(p, d, l)			_davinci_insb(p, d, l)
++#define	insw(p, d, l)			_davinci_insw(p, d, l)
++#define	insl(p, d, l)			_davinci_insl(p, d, l)
++
++#define IS_PCI_IO(p)			(((p) >= PCIBIOS_MIN_IO) \
++						&& ((p) <= PCIBIOS_MAX_IO))
++
++/*
++ * I/O Functions
++ */
++#define PCI_ACCESS_TYPE_CFG             0
++#define PCI_ACCESS_TYPE_IO              1
++extern int ti_pci_io_write(u32 addr, int size, u32 value);
++extern int ti_pci_io_read(u32 addr, int size, u32 *value);
++
++static inline void _davinci_outb(u8 value, u32 addr)
++{
++	if (IS_PCI_IO(addr))
++		ti_pci_io_write(addr, 1, (u32)value);
++	else
++		__raw_writeb(value, __typesafe_io(addr));
++}
++
++static inline void _davinci_outsb(u32 addr, const void *data, u32 blen)
++{
++	while (blen--)
++		_davinci_outb(*(const u8 *)data++, (u32)((u8 *)addr++));
++}
++
++static inline void _davinci_outw(u16 value, u32 addr)
++{
++	if (IS_PCI_IO(addr))
++		ti_pci_io_write(addr, 2, (u32)value);
++	else
++		__raw_writew(cpu_to_le16(value), __typesafe_io(addr));
++}
++
++static inline void _davinci_outsw(u32 addr, const void *data, u32 wlen)
++{
++	while (wlen--)
++		_davinci_outw(*(const u16 *)data++, (u32)((u16 *)addr++));
++}
++
++static inline void _davinci_outl(u32 value, u32 addr)
++{
++	if (IS_PCI_IO(addr))
++		ti_pci_io_write(addr, 4, (u32)value);
++	else
++		__raw_writel(cpu_to_le32(value), __typesafe_io(addr));
++}
++
++static inline void _davinci_outsl(u32 addr, const void *data, u32 llen)
++{
++	while (llen--)
++		_davinci_outl(*(const u32 *)data++, (u32)((u32 *)addr++));
++}
++
++static inline u8 _davinci_inb(u32 addr)
++{
++	if (IS_PCI_IO(addr)) {
++		u32 value;
++		ti_pci_io_read(addr, 1, &value);
++		return (u8)value;
++	} else {
++		return __raw_readb(__typesafe_io(addr));
++	}
++}
++
++static inline void _davinci_insb(u32 addr, void *data, u32 blen)
++{
++	while (blen--)
++		*(u8 *)data++ = _davinci_inb((u32)((u8 *)addr++));
++}
++
++static inline u16 _davinci_inw(u32 addr)
++{
++	if (IS_PCI_IO(addr)) {
++		u32 value;
++		ti_pci_io_read(addr, 2, &value);
++		return (u16)value;
++	} else {
++		return le16_to_cpu(__raw_readw(__typesafe_io(addr)));
++	}
++}
++
++static inline void _davinci_insw(u32 addr, void *data, u32 wlen)
++{
++	while (wlen--)
++		*(u16 *)data++ = _davinci_inw((u32)((u16 *)addr++));
++}
++
++static inline u32 _davinci_inl(u32 addr)
++{
++	if (IS_PCI_IO(addr)) {
++		u32 value;
++		ti_pci_io_read(addr, 4, &value);
++		return value;
++	} else {
++		return le32_to_cpu(__raw_readl(__typesafe_io(addr)));
++	}
++}
++
++static inline void _davinci_insl(u32 addr, void *data, u32 llen)
++{
++	while (llen--)
++		*(u32 *)data++ = _davinci_inl((u32)((u32 *)addr++));
++}
++
++static inline unsigned int _davinci_ioread8(void __iomem *port)
++{
++	return (unsigned int)_davinci_inb((unsigned long __force)port);
++}
++
++static inline void _davinci_ioread8_rep(void __iomem *port, void *dst,
++						unsigned long count)
++{
++	_davinci_insb((unsigned long __force)port, dst, count);
++}
++
++static inline unsigned int _davinci_ioread16(void __iomem *port)
++{
++	return (unsigned int)_davinci_inw((unsigned long __force)port);
++}
++
++static inline void _davinci_ioread16_rep(void __iomem *port, void *dst,
++						unsigned long count)
++{
++	_davinci_insw((unsigned long __force)port, dst, count);
++}
++
++static inline unsigned int _davinci_ioread32(void __iomem *port)
++{
++	return (unsigned int)_davinci_inl((unsigned long __force)port);
++}
++
++static inline void _davinci_ioread32_rep(void __iomem *port, void *dst,
++						unsigned long count)
++{
++	_davinci_insl((unsigned long __force)port, dst, count);
++}
++
++static inline void _davinci_iowrite8(u8 value, void __iomem *port)
++{
++	_davinci_outb(value, (unsigned long __force)port);
++}
++
++static inline void _davinci_iowrite8_rep(void __iomem *port, const void *src,
++					unsigned long count)
++{
++	_davinci_outsb((unsigned long __force)port, src, count);
++}
++
++static inline void _davinci_iowrite16(u16 value, void __iomem *port)
++{
++	_davinci_outw(value, (unsigned long __force)port);
++}
++
++static inline void _davinci_iowrite16_rep(void __iomem *port, const void *src,
++					unsigned long count)
++{
++	_davinci_outsw((unsigned long __force)port, src, count);
++}
++
++static inline void _davinci_iowrite32(u32 value, void __iomem *port)
++{
++	_davinci_outl(value, (unsigned long __force)port);
++}
++
++static inline void _davinci_iowrite32_rep(void __iomem *port, const void *src,
++					unsigned long count)
++{
++	_davinci_outsl((unsigned long __force)port, src, count);
++}
++
++#define ioread8(p)			_davinci_ioread8(p)
++#define ioread16(p)			_davinci_ioread16(p)
++#define ioread32(p)			_davinci_ioread32(p)
++
++#define iowrite8(v, p)			_davinci_iowrite8(v, p)
++#define iowrite16(v, p)			_davinci_iowrite16(v, p)
++#define iowrite32(v, p)			_davinci_iowrite32(v, p)
++
++#define ioread8_rep(p, d, c)		_davinci_ioread8_rep(p, d, c)
++#define ioread16_rep(p, d, c)		_davinci_ioread8_rep(p, d, c)
++#define ioread32_rep(p, d, c) 		_davinci_ioread8_rep(p, d, c)
++
++#define iowrite8_rep(p, s, c)		_davinci_iowrite8_rep(p, s, c)
++#define iowrite16_rep(p, s, c)		_davinci_iowrite16_rep(p, s, c)
++#define iowrite32_rep(p, s, c)		_davinci_iowrite32_rep(p, s, c)
++
++#define	ioport_map(port, nr)		((void __iomem *)port)
++#define	ioport_unmap(addr)
++
++#endif /* CONFIG_PCI */
++
+ #define __mem_pci(a)		(a)
+ #define __mem_isa(a)		(a)
+ 
+--- a/drivers/media/video/videobuf-dma-contig.c
++++ b/drivers/media/video/videobuf-dma-contig.c
+@@ -141,9 +141,11 @@ static int videobuf_dma_contig_user_get(
+ 	struct vm_area_struct *vma;
+ 	unsigned long prev_pfn, this_pfn;
+ 	unsigned long pages_done, user_address;
++	unsigned int offset;
+ 	int ret;
+ 
+-	mem->size = PAGE_ALIGN(vb->size);
++	offset = vb->baddr & ~PAGE_MASK;
++	mem->size = PAGE_ALIGN(vb->size + offset);
+ 	mem->is_userptr = 0;
+ 	ret = -EINVAL;
+ 
+@@ -166,7 +168,7 @@ static int videobuf_dma_contig_user_get(
+ 			break;
+ 
+ 		if (pages_done == 0)
+-			mem->dma_handle = this_pfn << PAGE_SHIFT;
++			mem->dma_handle = (this_pfn << PAGE_SHIFT) + offset;
+ 		else if (this_pfn != (prev_pfn + 1))
+ 			ret = -EFAULT;
+ 
+--- a/drivers/media/video/davinci/dm355_ccdc.c
++++ b/drivers/media/video/davinci/dm355_ccdc.c
+@@ -37,6 +37,7 @@
+ #include <linux/platform_device.h>
+ #include <linux/uaccess.h>
+ #include <linux/videodev2.h>
++#include <mach/mux.h>
+ #include <media/davinci/dm355_ccdc.h>
+ #include <media/davinci/vpss.h>
+ #include "dm355_ccdc_regs.h"
+@@ -64,7 +65,6 @@ static struct ccdc_params_raw ccdc_hw_pa
+ 	},
+ 	.config_params = {
+ 		.datasft = 2,
+-		.data_sz = CCDC_DATA_10BITS,
+ 		.mfilt1 = CCDC_NO_MEDIAN_FILTER1,
+ 		.mfilt2 = CCDC_NO_MEDIAN_FILTER2,
+ 		.alaw = {
+@@ -92,7 +92,7 @@ static struct ccdc_params_raw ccdc_hw_pa
+ 
+ /* Object for CCDC ycbcr mode */
+ static struct ccdc_params_ycbcr ccdc_hw_params_ycbcr = {
+-	.win = CCDC_WIN_PAL,
++	.win = CCDC_WIN_NTSC,
+ 	.pix_fmt = CCDC_PIXFMT_YCBCR_8BIT,
+ 	.frm_fmt = CCDC_FRMFMT_INTERLACED,
+ 	.fid_pol = VPFE_PINPOL_POSITIVE,
+@@ -105,7 +105,6 @@ static struct ccdc_params_ycbcr ccdc_hw_
+ 
+ static enum vpfe_hw_if_type ccdc_if_type;
+ static void *__iomem ccdc_base_addr;
+-static int ccdc_addr_size;
+ 
+ /* Raw Bayer formats */
+ static u32 ccdc_raw_bayer_pix_formats[] =
+@@ -126,12 +125,6 @@ static inline void regw(u32 val, u32 off
+ 	__raw_writel(val, ccdc_base_addr + offset);
+ }
+ 
+-static void ccdc_set_ccdc_base(void *addr, int size)
+-{
+-	ccdc_base_addr = addr;
+-	ccdc_addr_size = size;
+-}
+-
+ static void ccdc_enable(int en)
+ {
+ 	unsigned int temp;
+@@ -289,12 +282,6 @@ static int validate_ccdc_param(struct cc
+ 		return -EINVAL;
+ 	}
+ 
+-	if (ccdcparam->data_sz < CCDC_DATA_16BITS ||
+-	    ccdcparam->data_sz > CCDC_DATA_8BITS) {
+-		dev_dbg(dev, "Invalid value of data size\n");
+-		return -EINVAL;
+-	}
+-
+ 	if (ccdcparam->alaw.enable) {
+ 		if (ccdcparam->alaw.gama_wd < CCDC_GAMMA_BITS_13_4 ||
+ 		    ccdcparam->alaw.gama_wd > CCDC_GAMMA_BITS_09_0) {
+@@ -303,7 +290,7 @@ static int validate_ccdc_param(struct cc
+ 		}
+ 	}
+ 
+-	if (ccdcparam->blk_clamp.b_clamp_enable) {
++	if (ccdcparam->blk_clamp.enable) {
+ 		if (ccdcparam->blk_clamp.sample_pixel < CCDC_SAMPLE_1PIXELS ||
+ 		    ccdcparam->blk_clamp.sample_pixel > CCDC_SAMPLE_16PIXELS) {
+ 			dev_dbg(dev, "Invalid value of sample pixel\n");
+@@ -414,7 +401,7 @@ static void ccdc_config_black_clamp(stru
+ {
+ 	u32 val;
+ 
+-	if (!bclamp->b_clamp_enable) {
++	if (!bclamp->enable) {
+ 		/* configure DCSub */
+ 		regw(bclamp->dc_sub & CCDC_BLK_DC_SUB_MASK, DCSUB);
+ 		regw(0x0000, CLAMP);
+@@ -548,7 +535,7 @@ static int ccdc_config_vdfc(struct ccdc_
+  */
+ static void ccdc_config_csc(struct ccdc_csc *csc)
+ {
+-	u32 val1, val2;
++	u32 val1 = 0, val2;
+ 	int i;
+ 
+ 	if (!csc->enable)
+@@ -646,8 +633,7 @@ static int ccdc_config_raw(void)
+ 		((params->pix_fmt & CCDC_PIX_FMT_MASK) << CCDC_PIX_FMT_SHIFT));
+ 
+ 	/* set pack for alaw compression */
+-	if ((config_params->data_sz == CCDC_DATA_8BITS) ||
+-	     config_params->alaw.enable)
++	if (config_params->alaw.enable)
+ 		val |= CCDC_DATA_PACK_ENABLE;
+ 
+ 	/* Configure for LPF */
+@@ -720,8 +706,7 @@ static int ccdc_config_raw(void)
+ 		CCDC_HSIZE_FLIP_SHIFT;
+ 
+ 	/* If pack 8 is enable then 1 pixel will take 1 byte */
+-	if ((config_params->data_sz == CCDC_DATA_8BITS) ||
+-	     config_params->alaw.enable) {
++	if (config_params->alaw.enable) {
+ 		val |= (((params->win.width) + 31) >> 5) &
+ 			CCDC_HSIZE_VAL_MASK;
+ 
+@@ -770,7 +755,7 @@ static int ccdc_config_raw(void)
+ 	return 0;
+ }
+ 
+-static int ccdc_configure(void)
++static int ccdc_configure(int mode)
+ {
+ 	if (ccdc_if_type == VPFE_RAW_BAYER)
+ 		return ccdc_config_raw();
+@@ -875,8 +860,7 @@ static unsigned int ccdc_get_line_length
+ 	unsigned int len;
+ 
+ 	if (ccdc_if_type == VPFE_RAW_BAYER) {
+-		if ((config_params->alaw.enable) ||
+-		    (config_params->data_sz == CCDC_DATA_8BITS))
++		if (config_params->alaw.enable)
+ 			len = ccdc_hw_params_raw.win.width;
+ 		else
+ 			len = ccdc_hw_params_raw.win.width * 2;
+@@ -925,8 +909,11 @@ static int ccdc_set_hw_if_params(struct
+ 		ccdc_hw_params_ycbcr.vd_pol = params->vdpol;
+ 		ccdc_hw_params_ycbcr.hd_pol = params->hdpol;
+ 		break;
++	case VPFE_RAW_BAYER:
++		ccdc_hw_params_raw.vd_pol = params->vdpol;
++		ccdc_hw_params_raw.hd_pol = params->hdpol;
++		break;
+ 	default:
+-		/* TODO add support for raw bayer here */
+ 		return -EINVAL;
+ 	}
+ 	return 0;
+@@ -938,7 +925,6 @@ static struct ccdc_hw_device ccdc_hw_dev
+ 	.hw_ops = {
+ 		.open = ccdc_open,
+ 		.close = ccdc_close,
+-		.set_ccdc_base = ccdc_set_ccdc_base,
+ 		.enable = ccdc_enable,
+ 		.enable_out_to_sdram = ccdc_enable_output_to_sdram,
+ 		.set_hw_if_params = ccdc_set_hw_if_params,
+@@ -959,19 +945,89 @@ static struct ccdc_hw_device ccdc_hw_dev
+ 	},
+ };
+ 
+-static int dm355_ccdc_init(void)
++static int __init dm355_ccdc_probe(struct platform_device *pdev)
+ {
+-	printk(KERN_NOTICE "dm355_ccdc_init\n");
+-	if (vpfe_register_ccdc_device(&ccdc_hw_dev) < 0)
+-		return -1;
++	static resource_size_t  res_len;
++	struct resource	*res;
++	int status = 0;
++
++	/**
++	 * first try to register with vpfe. If not correct platform, then we
++	 * don't have to iomap
++	 */
++	status = vpfe_register_ccdc_device(&ccdc_hw_dev);
++	if (status < 0)
++		return status;
++
++	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
++	if (!res) {
++		status = -ENOENT;
++		goto fail_nores;
++	}
++	res_len = res->end - res->start + 1;
++
++	res = request_mem_region(res->start, res_len, res->name);
++	if (!res) {
++		status = -EBUSY;
++		goto fail_nores;
++	}
++
++	ccdc_base_addr = ioremap_nocache(res->start, res_len);
++	if (!ccdc_base_addr) {
++		status = -EBUSY;
++		goto fail;
++	}
++	/**
++	 * setup Mux configuration for vpfe input and register
++	 * vpfe capture platform device
++	 */
++	davinci_cfg_reg(DM355_VIN_PCLK);
++	davinci_cfg_reg(DM355_VIN_CAM_WEN);
++	davinci_cfg_reg(DM355_VIN_CAM_VD);
++	davinci_cfg_reg(DM355_VIN_CAM_HD);
++	davinci_cfg_reg(DM355_VIN_YIN_EN);
++	davinci_cfg_reg(DM355_VIN_CINL_EN);
++	davinci_cfg_reg(DM355_VIN_CINH_EN);
++
+ 	printk(KERN_NOTICE "%s is registered with vpfe.\n",
+ 		ccdc_hw_dev.name);
+ 	return 0;
++fail:
++	release_mem_region(res->start, res_len);
++fail_nores:
++	vpfe_unregister_ccdc_device(&ccdc_hw_dev);
++	return status;
++}
++
++static int dm355_ccdc_remove(struct platform_device *pdev)
++{
++	struct resource	*res;
++
++	iounmap(ccdc_base_addr);
++	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
++	if (res)
++		release_mem_region(res->start, res->end - res->start + 1);
++	vpfe_unregister_ccdc_device(&ccdc_hw_dev);
++	return 0;
++}
++
++static struct platform_driver dm355_ccdc_driver = {
++	.driver = {
++		.name	= "dm355_ccdc",
++		.owner = THIS_MODULE,
++	},
++	.remove = __devexit_p(dm355_ccdc_remove),
++	.probe = dm355_ccdc_probe,
++};
++
++static int dm355_ccdc_init(void)
++{
++	return platform_driver_register(&dm355_ccdc_driver);
+ }
+ 
+ static void dm355_ccdc_exit(void)
+ {
+-	vpfe_unregister_ccdc_device(&ccdc_hw_dev);
++	platform_driver_unregister(&dm355_ccdc_driver);
+ }
+ 
+ module_init(dm355_ccdc_init);
+--- /dev/null
++++ b/drivers/media/video/davinci/dm365_aew.c
+@@ -0,0 +1,813 @@
++/* *
++ * Copyright (C) 2009 Texas Instruments Inc
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
++ */
++
++#include <linux/module.h>
++#include <linux/init.h>
++#include <linux/kernel.h>
++#include <linux/slab.h>
++#include <linux/fs.h>
++#include <linux/errno.h>
++#include <linux/types.h>
++#include <linux/cdev.h>
++#include <linux/interrupt.h>
++#include <linux/dma-mapping.h>
++#include <linux/uaccess.h>
++#include <linux/platform_device.h>
++#include <linux/major.h>
++#include <media/davinci/dm365_a3_hw.h>
++#include <media/davinci/vpss.h>
++
++/* Global structure */
++static struct class *aew_class;
++struct aew_device *aew_dev_configptr;
++struct device *aewdev;
++/* device structure to make entry in device*/
++static dev_t dev;
++
++/* For registeration of charatcer device*/
++static struct cdev c_dev;
++
++int aew_validate_parameters(void)
++{
++	int result = 0;
++
++	/* Check horizontal Count */
++	if ((aew_dev_configptr->config->window_config.hz_cnt <
++	     AEW_WINDOW_HORIZONTAL_COUNT_MIN)
++	    || (aew_dev_configptr->config->window_config.hz_cnt >
++		AEW_WINDOW_HORIZONTAL_COUNT_MAX)) {
++		dev_err(aewdev, "\n Horizontal Count is incorrect");
++		result = -EINVAL;
++	}
++	/* Check Vertical Count */
++	if ((aew_dev_configptr->config->window_config.vt_cnt <
++	     AEW_WINDOW_VERTICAL_COUNT_MIN)
++	    || (aew_dev_configptr->config->window_config.vt_cnt >
++		AEW_WINDOW_VERTICAL_COUNT_MAX)) {
++		dev_err(aewdev, "\n Vertical Count is incorrect");
++		result = -EINVAL;
++	}
++	/* Check line increment */
++	if ((NOT_EVEN ==
++	     CHECK_EVEN(aew_dev_configptr->config->window_config.
++			    hz_line_incr))
++	    || (aew_dev_configptr->config->window_config.hz_line_incr <
++		AEW_HZ_LINEINCR_MIN)
++	    || (aew_dev_configptr->config->window_config.hz_line_incr >
++		AEW_HZ_LINEINCR_MAX)) {
++		dev_err(aewdev, "\n Invalid Parameters");
++		dev_err(aewdev, "\n Horizontal Line Increment is incorrect");
++		result = -EINVAL;
++	}
++	/* Check line increment */
++	if ((NOT_EVEN ==
++	     CHECK_EVEN(aew_dev_configptr->config->window_config.
++			    vt_line_incr))
++	    || (aew_dev_configptr->config->window_config.vt_line_incr <
++		AEW_VT_LINEINCR_MIN)
++	    || (aew_dev_configptr->config->window_config.vt_line_incr >
++		AEW_VT_LINEINCR_MAX)) {
++		dev_err(aewdev, "\n Invalid Parameters");
++		dev_err(aewdev, "\n Vertical Line Increment is incorrect");
++		result = -EINVAL;
++	}
++	/* Check width */
++	if ((NOT_EVEN ==
++	     CHECK_EVEN(aew_dev_configptr->config->window_config.width))
++	    || (aew_dev_configptr->config->window_config.width <
++		AEW_WIDTH_MIN)
++	    || (aew_dev_configptr->config->window_config.width >
++		AEW_WIDTH_MAX)) {
++		dev_err(aewdev, "\n Width is incorrect");
++
++		result = -EINVAL;
++	}
++	/* Check Height */
++	if ((NOT_EVEN ==
++	     CHECK_EVEN(aew_dev_configptr->config->window_config.height))
++	    || (aew_dev_configptr->config->window_config.height <
++		AEW_HEIGHT_MIN)
++	    || (aew_dev_configptr->config->window_config.height >
++		AEW_HEIGHT_MAX)) {
++		dev_err(aewdev, "\n height incorrect");
++		result = -EINVAL;
++	}
++	/* Check Horizontal Start */
++	if ((aew_dev_configptr->config->window_config.hz_start <
++	     AEW_HZSTART_MIN)
++	    || (aew_dev_configptr->config->window_config.hz_start >
++		AEW_HZSTART_MAX)) {
++		dev_err(aewdev, "\n horizontal start is  incorrect");
++		result = -EINVAL;
++	}
++	if ((aew_dev_configptr->config->window_config.vt_start >
++	     AEW_VTSTART_MAX)) {
++		dev_err(aewdev, "\n Vertical start is  incorrect");
++		result = -EINVAL;
++	}
++	if ((aew_dev_configptr->config->alaw_enable > H3A_AEW_ENABLE)
++	    || (aew_dev_configptr->config->alaw_enable < H3A_AEW_DISABLE)) {
++		dev_err(aewdev, "\n A Law setting is incorrect");
++		result = -EINVAL;
++	}
++	if (aew_dev_configptr->config->saturation_limit > AEW_AVELMT_MAX) {
++		dev_err(aewdev, "\n Saturation Limit is incorrect");
++		result = -EINVAL;
++	}
++	/* Check Black Window Height */
++	if (NOT_EVEN ==
++	    CHECK_EVEN(aew_dev_configptr->config->blackwindow_config.height)
++	    || (aew_dev_configptr->config->blackwindow_config.height <
++		AEW_BLKWINHEIGHT_MIN)
++	    || (aew_dev_configptr->config->blackwindow_config.height >
++		AEW_BLKWINHEIGHT_MAX)) {
++		dev_err(aewdev, "\n Black Window height incorrect");
++		result = -EINVAL;
++	}
++	/* Check Black Window Height */
++	if ((NOT_EVEN ==
++	     CHECK_EVEN(aew_dev_configptr->config->blackwindow_config.
++			    height))
++	    || (aew_dev_configptr->config->blackwindow_config.vt_start <
++		AEW_BLKWINVTSTART_MIN)
++	    || (aew_dev_configptr->config->blackwindow_config.vt_start >
++		AEW_BLKWINVTSTART_MAX)) {
++		dev_err(aewdev, "\n Black Window vertical Start is incorrect");
++		result = -EINVAL;
++	}
++
++	if (aew_dev_configptr->config->out_format < AEW_OUT_SUM_OF_SQUARES ||
++	    aew_dev_configptr->config->out_format > AEW_OUT_SUM_ONLY) {
++		dev_err(aewdev, "\n Invalid out_format");
++		result = -EINVAL;
++	}
++
++	if (aew_dev_configptr->config->sum_shift > AEW_SUMSHIFT_MAX) {
++		dev_err(aewdev, "\n sum_shift param is invalid, max = %d",
++			AEW_SUMSHIFT_MAX);
++		result = -EINVAL;
++	}
++
++	return result;
++}
++
++/* inline function to free reserver pages  */
++inline void aew_free_pages(unsigned long addr, unsigned long bufsize)
++{
++	unsigned long tempaddr;
++	unsigned long size;
++	tempaddr = addr;
++	if (!addr)
++		return;
++	size = PAGE_SIZE << (get_order(bufsize));
++	while (size > 0) {
++		ClearPageReserved(virt_to_page(addr));
++		addr += PAGE_SIZE;
++		size -= PAGE_SIZE;
++	}
++	free_pages(tempaddr, get_order(bufsize));
++}
++
++/* Function to perform hardware Configuration */
++int aew_hardware_setup(void)
++{
++	int result;
++	/* Size for buffer in bytes */
++	int buff_size = 0;
++	unsigned long adr;
++	unsigned long size;
++	unsigned int busyaew;
++
++	/* Get the value of PCR register */
++	busyaew = aew_get_hw_state();
++
++	/* If H3A Engine is busy then return */
++	if (busyaew == 1) {
++		dev_err(aewdev, "\n Error : AEW Engine is busy");
++		return -EBUSY;
++	}
++
++	result = aew_validate_parameters();
++	dev_dbg(aewdev, "Result =  %d\n", result);
++	if (result < 0) {
++		dev_err(aewdev, "Error : Parameters are incorrect \n");
++		return result;
++	}
++
++	/* Deallocate the previously allocated buffers */
++	if (aew_dev_configptr->buff_old)
++		aew_free_pages((unsigned long)aew_dev_configptr->buff_old,
++			       aew_dev_configptr->size_window);
++
++	if (aew_dev_configptr->buff_curr)
++		aew_free_pages((unsigned long)aew_dev_configptr->
++			       buff_curr, aew_dev_configptr->size_window);
++
++	if (aew_dev_configptr->buff_app)
++		aew_free_pages((unsigned long)aew_dev_configptr->
++			       buff_app, aew_dev_configptr->size_window);
++
++	/*
++	 * Allocat the buffers as per the new buffer size
++	 * Allocate memory for old buffer
++	 */
++	if (aew_dev_configptr->config->out_format == AEW_OUT_SUM_ONLY)
++		buff_size = (aew_dev_configptr->config->window_config.hz_cnt) *
++			    (aew_dev_configptr->config->window_config.vt_cnt) *
++				AEW_WINDOW_SIZE_SUM_ONLY;
++	else
++		buff_size = (aew_dev_configptr->config->window_config.hz_cnt) *
++			    (aew_dev_configptr->config->window_config.vt_cnt) *
++				AEW_WINDOW_SIZE;
++
++	aew_dev_configptr->buff_old =
++	    (void *)__get_free_pages(GFP_KERNEL | GFP_DMA,
++				     get_order(buff_size));
++
++	if (aew_dev_configptr->buff_old == NULL)
++		return -ENOMEM;
++
++	/* Make pges reserved so that they will be swapped out */
++	adr = (unsigned long)aew_dev_configptr->buff_old;
++	size = PAGE_SIZE << (get_order(buff_size));
++	while (size > 0) {
++		/*
++		 * make sure the frame buffers
++		 * are never swapped out of memory
++		 */
++		SetPageReserved(virt_to_page(adr));
++		adr += PAGE_SIZE;
++		size -= PAGE_SIZE;
++	}
++
++	/* Allocate memory for current buffer */
++	aew_dev_configptr->buff_curr =
++	    (void *)__get_free_pages(GFP_KERNEL | GFP_DMA,
++				     get_order(buff_size));
++
++	if (aew_dev_configptr->buff_curr == NULL) {
++
++		/*Free all  buffer that are allocated */
++		if (aew_dev_configptr->buff_old)
++			aew_free_pages((unsigned long)aew_dev_configptr->
++				       buff_old, buff_size);
++		return -ENOMEM;
++	}
++
++	/* Make pges reserved so that they will be swapped out */
++	adr = (unsigned long)aew_dev_configptr->buff_curr;
++	size = PAGE_SIZE << (get_order(buff_size));
++	while (size > 0) {
++		/*
++		 * make sure the frame buffers
++		 * are never swapped out of memory
++		 */
++		SetPageReserved(virt_to_page(adr));
++		adr += PAGE_SIZE;
++		size -= PAGE_SIZE;
++	}
++
++	/* Allocate memory for application buffer */
++	aew_dev_configptr->buff_app =
++	    (void *)__get_free_pages(GFP_KERNEL | GFP_DMA,
++				     get_order(buff_size));
++
++	if (aew_dev_configptr->buff_app == NULL) {
++		/* Free all  buffer that were allocated previously */
++		if (aew_dev_configptr->buff_old)
++			aew_free_pages((unsigned long)aew_dev_configptr->
++				       buff_old, buff_size);
++		if (aew_dev_configptr->buff_curr)
++			aew_free_pages((unsigned long)aew_dev_configptr->
++				       buff_curr, buff_size);
++		return -ENOMEM;
++	}
++
++	/* Make pages reserved so that they will be swapped out */
++	adr = (unsigned long)aew_dev_configptr->buff_app;
++	size = PAGE_SIZE << (get_order(buff_size));
++	while (size > 0) {
++		/*
++		 * make sure the frame buffers
++		 * are never swapped out of memory
++		 */
++		SetPageReserved(virt_to_page(adr));
++		adr += PAGE_SIZE;
++		size -= PAGE_SIZE;
++	}
++
++	/* Set the registers */
++	aew_register_setup(aewdev, aew_dev_configptr);
++	aew_dev_configptr->size_window = buff_size;
++	aew_dev_configptr->aew_config = H3A_AEW_CONFIG;
++
++	return 0;
++}
++
++/* This Function is called when driver is opened */
++static int aew_open(struct inode *inode, struct file *filp)
++{
++	/* Return if Device is in use (Single Channel Support is provided) */
++	if (aew_dev_configptr->in_use == AEW_IN_USE)
++		return -EBUSY;
++
++	/* Set the aew_dev_configptr structure */
++	aew_dev_configptr->config = NULL;
++
++	/* Allocate memory for configuration  structure of this channel */
++	aew_dev_configptr->config = (struct aew_configuration *)
++	    kmalloc(sizeof(struct aew_configuration), GFP_KERNEL);
++
++	if (aew_dev_configptr->config == NULL) {
++		dev_err(aewdev, "Error : Kmalloc fail\n");
++		return -ENOMEM;
++	}
++
++	/* Initiaze the wait queue */
++	init_waitqueue_head(&(aew_dev_configptr->aew_wait_queue));
++
++	/* Device is in use */
++	aew_dev_configptr->in_use = AEW_IN_USE;
++
++	/* No Hardware Set up done */
++	aew_dev_configptr->aew_config = H3A_AEW_CONFIG_NOT_DONE;
++
++	/* No statistics are available */
++	aew_dev_configptr->buffer_filled = 0;
++
++	/* Set Window Size to 0 */
++	aew_dev_configptr->size_window = 0;
++
++	/* Initialize the mutex */
++	mutex_init(&(aew_dev_configptr->read_blocked));
++
++	return 0;
++}
++
++static void aew_platform_release(struct device *device)
++{
++	/* This is called when the reference count goes to zero */
++}
++
++static int aew_probe(struct device *device)
++{
++	aewdev = device;
++	return 0;
++}
++
++static int aew_remove(struct device *device)
++{
++	return 0;
++}
++
++/* This Function is called when driver is closed */
++static int aew_release(struct inode *inode, struct file *filp)
++{
++	aew_engine_setup(aewdev, 0);
++	/* The Application has closed device so device is not in use */
++	aew_dev_configptr->in_use = AEW_NOT_IN_USE;
++
++	/* Release memory for configuration structure of this channel */
++	kfree(aew_dev_configptr->config);
++
++	/* Free Old Buffer */
++	if (aew_dev_configptr->buff_old)
++		aew_free_pages((unsigned long)aew_dev_configptr->buff_old,
++			       aew_dev_configptr->size_window);
++
++	/* Free Current Buffer */
++	if (aew_dev_configptr->buff_curr)
++		aew_free_pages((unsigned long)aew_dev_configptr->
++			       buff_curr, aew_dev_configptr->size_window);
++
++	/* Free Application Buffer */
++	if (aew_dev_configptr->buff_app)
++		aew_free_pages((unsigned long)aew_dev_configptr->buff_app,
++			       aew_dev_configptr->size_window);
++
++	aew_dev_configptr->buff_old = NULL;
++	aew_dev_configptr->buff_curr = NULL;
++	aew_dev_configptr->config = NULL;
++	aew_dev_configptr->buff_app = NULL;
++
++	return 0;
++}
++
++/*
++ * This function will process IOCTL commands sent by the application and
++ * control the devices IO operations.
++ */
++static int aew_ioctl(struct inode *inode, struct file *filep,
++		     unsigned int cmd, unsigned long arg)
++{
++	/* Stores Previous Configurations */
++	struct aew_configuration aewconfig = *(aew_dev_configptr->config);
++	int result = 0;
++
++	/* Decrement the semaphore */
++	result = mutex_lock_interruptible(&aew_dev_configptr->read_blocked);
++	if (result)
++		return result;
++
++	/*
++	 * Extract the type and number bitfields, and don't decode wrong cmds:
++	 * verify the magic number
++	 */
++	if (_IOC_TYPE(cmd) != AEW_MAGIC_NO) {
++		mutex_unlock(&aew_dev_configptr->read_blocked);
++		return -ENOTTY;
++	}
++
++	/* verify the command number */
++	if (_IOC_NR(cmd) > AEW_IOC_MAXNR) {
++		/* Release mutex in case of fault */
++		mutex_unlock(&aew_dev_configptr->read_blocked);
++		return -ENOTTY;
++	}
++
++	/* check for the permission of the operation */
++	if (_IOC_DIR(cmd) & _IOC_READ)
++		result =
++		    !access_ok(VERIFY_WRITE, (void __user *)arg,
++			       _IOC_SIZE(cmd));
++	else if (_IOC_DIR(cmd) & _IOC_WRITE)
++		result =
++		    !access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd));
++
++	if (result) {
++		/* Release mutex in case of fault */
++		mutex_unlock(&aew_dev_configptr->read_blocked);
++		return -EFAULT;
++	}
++
++	/* Switch according to IOCTL command */
++	switch (cmd) {
++		/*
++		 * This ioctl is used to perform hardware set up
++		 * and will set all the registers for AF engine
++		 */
++	case AEW_S_PARAM:
++
++		/* Copy config structure passed by user */
++		if (copy_from_user(aew_dev_configptr->config,
++				   (struct aew_configuration *)arg,
++				   sizeof(struct aew_configuration))) {
++			*(aew_dev_configptr->config) = aewconfig;
++			mutex_unlock(&aew_dev_configptr->read_blocked);
++			return -EFAULT;
++		}
++
++		/* Call aew_hardware_setup to perform register configuration */
++		result = aew_hardware_setup();
++		if (!result) {
++			/*
++			 * Hardware Set up is successful
++			 * Return the no of bytes required for buffer
++			 */
++			result = aew_dev_configptr->size_window;
++		} else {
++			/* Change Configuration Structure to original */
++			*(aew_dev_configptr->config) = aewconfig;
++			dev_err(aewdev, "Error : AEW_S_PARAM  failed\n");
++		}
++		break;
++
++		/* This ioctl is used to return parameters in user space */
++	case AEW_G_PARAM:
++		if (aew_dev_configptr->aew_config == H3A_AEW_CONFIG) {
++			if (copy_to_user
++			    ((struct aew_configuration *)arg,
++			     aew_dev_configptr->config,
++			     sizeof(struct aew_configuration))) {
++				mutex_unlock(&aew_dev_configptr->read_blocked);
++				return -EFAULT;
++			} else
++				result = aew_dev_configptr->size_window;
++		} else {
++			dev_err(aewdev,
++				"Error : AEW Hardware is not configured.\n");
++			result = -EINVAL;
++		}
++		break;
++
++		/* This ioctl is used to enable AEW Engine */
++	case AEW_ENABLE:
++		/* Enable AEW Engine if Hardware set up is done */
++		if (aew_dev_configptr->aew_config == H3A_AEW_CONFIG_NOT_DONE) {
++			dev_err(aewdev,
++				"Error : AEW Hardware is not configured.\n");
++			result = -EINVAL;
++		} else
++			/* Enable AF Engine */
++			aew_engine_setup(aewdev, 1);
++		break;
++
++		/* This ioctl is used to disable AEW Engine */
++	case AEW_DISABLE:
++		/* Disable AEW Engine */
++		aew_engine_setup(aewdev, 0);
++		break;
++
++		/* Invalid Command */
++	default:
++		dev_err(aewdev, "Error: It should not come here!!\n");
++		result = -ENOTTY;
++		break;
++	}
++
++	/* Release the mutex */
++	mutex_unlock(&aew_dev_configptr->read_blocked);
++
++	return result;
++}
++
++/* This function will return statistics to user */
++static ssize_t aew_read(struct file *filep, char *kbuff,
++			size_t size, loff_t *offset)
++{
++	void *buffer_temp;
++	int result = 0;
++	int ret;
++
++	/* Semaphore will return immediately if read call is busy */
++	ret = mutex_trylock(&(aew_dev_configptr->read_blocked));
++	if (!ret) {
++		dev_dbg(aewdev, "Read Call : busy  : %d\n", ret);
++		return -EBUSY;
++	}
++
++	/* First Check the size given by user */
++	if (size < aew_dev_configptr->size_window) {
++		/*
++		 * Return Failure to applicaiton
++		 * if size is less than required size
++		 */
++		dev_dbg(aewdev, "Error : Invalid size of buffer\n");
++		mutex_unlock(&(aew_dev_configptr->read_blocked));
++		return -EINVAL;
++	}
++
++	/*
++	 * The value of buffer_filled flag determines
++	 * the status of statistics
++	 */
++	if (aew_dev_configptr->buffer_filled == 0) {
++		/* Decrement the semaphore */
++		dev_dbg(aewdev, "READ CALL IS BLOCKED............\n");
++		/* Block the read call */
++		wait_event_interruptible_timeout(aew_dev_configptr->
++						 aew_wait_queue,
++						 aew_dev_configptr->
++						 buffer_filled, AEW_TIMEOUT);
++		dev_dbg(aewdev, "Read Call is unbloked and waking up.......\n");
++		dev_dbg(aewdev, "Buffer Filled.... %d\n",
++			aew_dev_configptr->buffer_filled);
++	}
++
++	if (aew_dev_configptr->buffer_filled == 1) {
++		/* Disable the interrupts and then swap the buffers */
++		dev_dbg(aewdev, "READING............\n");
++		disable_irq(6);
++
++		/* New Statistics are availaible */
++		aew_dev_configptr->buffer_filled = 0;
++
++		/* Swap application buffer and old buffer */
++		buffer_temp = aew_dev_configptr->buff_old;
++		aew_dev_configptr->buff_old = aew_dev_configptr->buff_app;
++		aew_dev_configptr->buff_app = buffer_temp;
++
++		/* Interrupts are enabled */
++		enable_irq(6);
++
++		/*
++		 * Copy the entire statistics located in application
++		 * buffer to user space
++		 */
++		if (copy_to_user(kbuff, aew_dev_configptr->buff_app,
++				 aew_dev_configptr->size_window)) {
++			dev_err(aewdev, "Error : Read Fault\n");
++			mutex_unlock(&(aew_dev_configptr->read_blocked));
++			return -EFAULT;
++		} else
++			result = aew_dev_configptr->size_window;
++
++		dev_dbg(aewdev, "Reading Done........................\n");
++	}
++
++	dev_dbg(aewdev, "APP BUFF VALUE %x\n",
++		(*((unsigned int *)(aew_dev_configptr->buff_app))));
++
++	/* release the mutex */
++	mutex_unlock(&(aew_dev_configptr->read_blocked));
++
++	return result;
++}
++
++/* This function will handle interrupt generated by H3A Engine. */
++static irqreturn_t aew_isr(int irq, void *dev_id)
++{
++	/* EN AF Bit */
++	unsigned int enaew;
++	/* Temporary Buffer for Swapping */
++	void *buffer_temp;
++
++	/* Get the value of PCR register */
++	enaew = aew_get_enable();
++
++	/* If AEW engine is not enabled, interrupt is not for AEW */
++	if (!enaew)
++		return IRQ_RETVAL(IRQ_NONE);
++
++	/*
++	 * Interrupt is generated by AEW, so Service the Interrupt
++	 * Swap current buffer and old buffer
++	 */
++	if (aew_dev_configptr) {
++		buffer_temp = aew_dev_configptr->buff_curr;
++		aew_dev_configptr->buff_curr = aew_dev_configptr->buff_old;
++		aew_dev_configptr->buff_old = buffer_temp;
++
++		/* Set the AEWBUFSTAT REgister to current buffer Address */
++		aew_set_address(aewdev, (unsigned
++			 long)(virt_to_phys(aew_dev_configptr->buff_curr)));
++
++		/*
++		 * Set buffer filled flag to indicate statistics are available
++		 */
++		aew_dev_configptr->buffer_filled = 1;
++
++		/* new statistics are available. Wake up the read call */
++		wake_up(&(aew_dev_configptr->aew_wait_queue));
++
++		return IRQ_RETVAL(IRQ_HANDLED);
++	}
++	return IRQ_RETVAL(IRQ_NONE);
++}
++
++/* file Operation Structure*/
++static const struct file_operations aew_fops = {
++	.owner = THIS_MODULE,
++	.open = aew_open,
++	.read = aew_read,
++	.ioctl = aew_ioctl,
++	.release = aew_release,
++};
++static struct platform_device aewdevice = {
++	.name = "dm365_aew",
++	.id = 2,
++	.dev = {
++		.release = aew_platform_release,
++		}
++};
++
++static struct device_driver aew_driver = {
++	.name = "dm365_aew",
++	.bus = &platform_bus_type,
++	.probe = aew_probe,
++	.remove = aew_remove,
++};
++
++#define DRIVERNAME  "DM365AEW"
++/* Function to register the AF character device driver. */
++int __init aew_init(void)
++{
++	int err;
++	int result = 0;
++
++	/*
++	 * Register the driver in the kernel
++	 * dynmically get the major number for the driver using
++	 * alloc_chrdev_region function
++	 */
++	result = alloc_chrdev_region(&dev, 0, 1, DRIVERNAME);
++
++	if (result < 0) {
++		printk(KERN_ERR "Error :  Could not register character device");
++		return -ENODEV;
++	}
++	printk(KERN_INFO "aew major#: %d, minor# %d\n", MAJOR(dev), MINOR(dev));
++	/* allocate memory for device structure and initialize it with 0 */
++	aew_dev_configptr =
++	    kmalloc(sizeof(struct aew_device), GFP_KERNEL);
++	if (!aew_dev_configptr) {
++		printk(KERN_ERR "Error : kmalloc fail");
++		unregister_chrdev_region(dev, AEW_NR_DEVS);
++		return -ENOMEM;
++
++	}
++
++	/* Initialize character device */
++	cdev_init(&c_dev, &aew_fops);
++	c_dev.owner = THIS_MODULE;
++	c_dev.ops = &aew_fops;
++	err = cdev_add(&c_dev, dev, 1);
++	if (err) {
++		printk(KERN_ERR "Error : Error in  Adding Davinci AEW");
++		unregister_chrdev_region(dev, AEW_NR_DEVS);
++		kfree(aew_dev_configptr);
++		return -err;
++	}
++	/* register driver as a platform driver */
++	if (driver_register(&aew_driver) != 0) {
++		unregister_chrdev_region(dev, 1);
++		cdev_del(&c_dev);
++		return -EINVAL;
++	}
++
++	/* Register the drive as a platform device */
++	if (platform_device_register(&aewdevice) != 0) {
++		driver_unregister(&aew_driver);
++		unregister_chrdev_region(dev, 1);
++		cdev_del(&c_dev);
++		return -EINVAL;
++	}
++
++	aew_class = class_create(THIS_MODULE, "dm365_aew");
++	if (!aew_class) {
++		printk(KERN_ERR "aew_init: error in creating device class\n");
++		driver_unregister(&aew_driver);
++		platform_device_unregister(&aewdevice);
++		unregister_chrdev_region(dev, 1);
++		unregister_chrdev(MAJOR(dev), DRIVERNAME);
++		cdev_del(&c_dev);
++		return -EINVAL;
++	}
++
++	device_create(aew_class, NULL, dev, NULL, "dm365_aew");
++
++	/* Set up the Interrupt handler for H3AINT interrupt */
++	result = request_irq(6, aew_isr, IRQF_SHARED, "dm365_h3a_aew",
++			     (void *)aew_dev_configptr);
++
++	if (result != 0) {
++		printk(KERN_ERR "Error : Request IRQ Failed");
++		unregister_chrdev_region(dev, AEW_NR_DEVS);
++		device_destroy(aew_class, dev);
++		class_destroy(aew_class);
++		kfree(aew_dev_configptr);
++		driver_unregister(&aew_driver);
++		platform_device_unregister(&aewdevice);
++		cdev_del(&c_dev);
++		return result;
++	}
++
++	/* Initialize device structure */
++	memset(aew_dev_configptr, 0, sizeof(struct aew_device));
++
++	aew_dev_configptr->in_use = AEW_NOT_IN_USE;
++	aew_dev_configptr->buffer_filled = 0;
++	printk(KERN_NOTICE "AEW Driver initialized\n");
++	return 0;
++}
++
++/*
++ * This Function is called by the kernel while unloading the driver
++ * This will unregister the Character Device Driver
++ */
++void __exit aew_cleanup(void)
++{
++	/* Device is in use */
++	if (aew_dev_configptr->in_use == AEW_IN_USE) {
++		printk(KERN_ERR "Error : Driver in use");
++		return;
++	}
++
++	free_irq(6, aew_dev_configptr);
++	/* Free device structure */
++	kfree(aew_dev_configptr);
++	aew_dev_configptr = NULL;
++	unregister_chrdev_region(dev, AEW_NR_DEVS);
++
++	driver_unregister(&aew_driver);
++
++	device_destroy(aew_class, dev);
++
++	class_destroy(aew_class);
++
++	platform_device_unregister(&aewdevice);
++
++	cdev_del(&c_dev);
++
++	/* unregistering the driver from the kernel */
++	unregister_chrdev(MAJOR(dev), DRIVERNAME);
++}
++
++module_init(aew_init)
++module_exit(aew_cleanup)
++MODULE_LICENSE("GPL");
+--- /dev/null
++++ b/drivers/media/video/davinci/dm355_af.c
+@@ -0,0 +1,851 @@
++/*
++ * Copyright (C) 2009 Texas Instruments Inc
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
++ */
++
++#include <linux/module.h>
++#include <linux/init.h>
++#include <linux/kernel.h>
++#include <linux/slab.h>
++#include <linux/fs.h>
++#include <linux/errno.h>
++#include <linux/types.h>
++#include <linux/cdev.h>
++#include <linux/interrupt.h>
++#include <linux/dma-mapping.h>
++#include <asm/uaccess.h>
++#include <linux/wait.h>
++#include <linux/platform_device.h>
++#include <linux/major.h>
++#include <linux/device.h>
++#include <media/davinci/dm355_af.h>
++#include <media/davinci/dm355_af_hw.h>
++#include <media/davinci/vpss.h>
++
++struct af_device *af_dev_configptr;
++static struct cdev c_dev;
++static struct class *af_class;
++static dev_t dev;
++struct device *afdev;
++
++/* Inline function to free reserver pages */
++void inline af_free_pages(unsigned long addr, unsigned long bufsize)
++{
++	unsigned long tempaddr;
++	unsigned long size;
++
++	tempaddr = addr;
++
++	if (!addr)
++		return;
++	size = PAGE_SIZE << (get_order(bufsize));
++
++	while (size > 0) {
++		ClearPageReserved(virt_to_page(addr));
++		addr += PAGE_SIZE;
++		size -= PAGE_SIZE;
++	}
++
++	free_pages(tempaddr, get_order(bufsize));
++}
++
++/* Function to check paxel parameters */
++static int af_validate_parameters(void)
++{
++	int result = 0;
++
++	/* Check horizontal Count */
++	if ((af_dev_configptr->config->paxel_config.hz_cnt <
++		AF_PAXEL_HORIZONTAL_COUNT_MIN) ||
++		(af_dev_configptr->config->paxel_config.hz_cnt >
++		AF_PAXEL_HORIZONTAL_COUNT_MAX)) {
++			dev_err(afdev, "\n Invalid Parameters");
++			dev_err(afdev, "\n Paxel Horizontal Count"
++				" is incorrect");
++			result = -EINVAL;
++	}
++
++	/* Check Vertical Count */
++	if ((af_dev_configptr->config->paxel_config.vt_cnt <
++		AF_PAXEL_VERTICAL_COUNT_MIN) ||
++		(af_dev_configptr->config->paxel_config.vt_cnt >
++		AF_PAXEL_VERTICAL_COUNT_MAX)) {
++			dev_err(afdev, "\n Invalid Parameters");
++			dev_err(afdev, "\n Paxel Vertical Count"
++				" is incorrect");
++			result = -EINVAL;
++	}
++
++	/* Check line increment */
++	if ((AF_NOT_EVEN ==
++		AF_CHECK_EVEN(
++		af_dev_configptr->config->paxel_config.line_incr)) ||
++		(af_dev_configptr->config->paxel_config.line_incr <
++		AF_LINE_INCR_MIN) ||
++		(af_dev_configptr->config->paxel_config.line_incr >
++		AF_LINE_INCR_MAX)) {
++			dev_err(afdev, "\n Invalid Parameters");
++			dev_err(afdev, "\n Paxel Line Increment"
++				" is incorrect");
++			result = -EINVAL;
++	}
++
++	/* Check width */
++	if ((AF_NOT_EVEN ==
++		AF_CHECK_EVEN(
++		af_dev_configptr->config->paxel_config.width)) ||
++		(af_dev_configptr->config->paxel_config.width <
++		AF_WIDTH_MIN) ||
++		(af_dev_configptr->config->paxel_config.width >
++		AF_WIDTH_MAX)) {
++			dev_err(afdev, "\n Invalid Parameters");
++			dev_err(afdev, "\n Paxel Width is incorrect");
++			result = -EINVAL;
++	}
++
++	/* Check Height */
++	if ((AF_NOT_EVEN ==
++		AF_CHECK_EVEN(
++		af_dev_configptr->config->paxel_config.height)) ||
++		(af_dev_configptr->config->paxel_config.height <
++		AF_HEIGHT_MIN) ||
++		(af_dev_configptr->config->paxel_config.height >
++		AF_HEIGHT_MAX)) {
++			dev_err(afdev, "\n Invalid Parameters");
++			dev_err(afdev, "\n Paxel Height is incorrect");
++			result = -EINVAL;
++	}
++
++	/* Check Horizontal Start */
++	if ((AF_NOT_EVEN ==
++		AF_CHECK_EVEN(
++		af_dev_configptr->config->paxel_config.hz_start)) ||
++		(af_dev_configptr->config->paxel_config.hz_start <
++		(af_dev_configptr->config->iir_config.hz_start_pos + 2)) ||
++		(af_dev_configptr->config->paxel_config.hz_start <
++		AF_HZSTART_MIN) ||
++		(af_dev_configptr->config->paxel_config.hz_start >
++		AF_HZSTART_MAX)) {
++			dev_err(afdev, "\n Invalid Parameters");
++			dev_err(afdev, "\n Paxel horizontal start" 
++				"is incorrect");
++			result = -EINVAL;
++	}
++
++	/* Check Vertical Start */
++	if ((af_dev_configptr->config->paxel_config.vt_start <
++		AF_VTSTART_MIN) ||
++		(af_dev_configptr->config->paxel_config.vt_start >
++		AF_VTSTART_MAX)) {
++			dev_err(afdev, "\n Invalid Parameters");
++			dev_err(afdev, "\n Paxel vertical start is incorrect");
++			result = -EINVAL;
++	}
++
++	/* Check Threshold  */
++	if ((af_dev_configptr->config->hmf_config.threshold >
++		AF_MEDTH_MAX) &&
++		(af_dev_configptr->config->hmf_config.enable ==
++		H3A_AF_ENABLE)) {
++			dev_err(afdev, "\n Invalid Parameters");
++			dev_err(afdev, "\n Horizontal Median Filter"
++				" Threshold is incorrect");
++			result = -EINVAL;
++	}
++
++	/* Check IIRSH start */
++	if (af_dev_configptr->config->iir_config.hz_start_pos >
++		AF_IIRSH_MAX) {
++			dev_err(afdev, "\n Invalid Parameters");
++			dev_err(afdev, "\n IIR FITLER  horizontal"
++				" start position is wrong");
++			result = -EINVAL;
++	}
++
++	/* Verify ALaw */
++	if ((af_dev_configptr->config->alaw_enable <
++		H3A_AF_DISABLE) ||
++		(af_dev_configptr->config->alaw_enable > H3A_AF_ENABLE)) {
++			dev_err(afdev, "\n Invalid Parameters");
++			dev_err(afdev, "\n ALaw Setting is incorrect");
++			result = -EINVAL;
++	}
++
++	/* Check RGB position */
++	if ((af_dev_configptr->config->rgb_pos < GR_GB_BAYER) ||
++		(af_dev_configptr->config->rgb_pos > RB_GG_CUSTOM)) {
++			dev_err(afdev, "\n Invalid Parameters");
++			dev_err(afdev, "\n RGB Position Setting is incorrect");
++			result = -EINVAL;
++	}
++
++	/* Verify Horizontal Median Filter Setting */
++	if ((af_dev_configptr->config->hmf_config.enable < H3A_AF_DISABLE) ||
++		(af_dev_configptr->config->hmf_config.enable >
++		H3A_AF_ENABLE)) {
++			dev_err(afdev, "\n Invalid Parameters");
++			dev_err(afdev, "\n Horizontal Median Filter"
++				" Setting is incorrect");
++			result = -EINVAL;
++	}
++
++	if (((af_dev_configptr->config->paxel_config.vt_cnt) *
++		(af_dev_configptr->config->paxel_config.height) +
++		(af_dev_configptr->config->paxel_config.vt_start)) > 156) {
++			dev_err(afdev, "\n Only 156 Lines are"
++				" supported for CCDC mode");
++			dev_err(afdev, "\n Paxel count * Height"
++				" + vertical Start should not exceed 156");
++			result = -EINVAL;
++	}
++
++	return result;
++}
++
++/* Function to perform hardware set up */
++int af_hardware_setup(void)
++{
++	int result;
++	int buff_size;
++	unsigned long adr, size;
++	unsigned int busyaf;
++
++	/* Get the value of PCR register */
++	busyaf = AF_GET_PCR;
++
++	/* Mask with BUSYAF bit */
++	busyaf = busyaf & AF_BUSYAF;
++
++	/* Shift it 15 times to get value of 1 or 0 */
++	busyaf = busyaf >> 15;
++
++	/*If busy bit is 1 then busy lock registers caanot be configured */
++	if (busyaf == 1) {
++		/* Hardware cannot be configure while engine is busy */
++		dev_err(afdev, "AF_register_setup_ERROR : Engine Busy");
++		dev_err(afdev, "\n Configuration cannot be done ");
++		return -EBUSY;
++	}
++
++	/*Check IIR Coefficient and start Values */
++	result = af_validate_parameters();
++
++	if (result < 0)
++		return result;
++
++	/* Compute buffer size */
++	buff_size =
++	    (af_dev_configptr->config->paxel_config.hz_cnt) *
++	    (af_dev_configptr->config->paxel_config.vt_cnt) * AF_PAXEL_SIZE;
++
++	/* Deallocate the previosu buffers */
++	if (af_dev_configptr->buff_old)
++		af_free_pages((unsigned long)af_dev_configptr->buff_old,
++			      af_dev_configptr->size_paxel);
++
++	/* Free current buffer */
++	if (af_dev_configptr->buff_curr)
++		af_free_pages((unsigned long)af_dev_configptr->buff_curr,
++			      af_dev_configptr->size_paxel);
++
++	/* Free application buffers */
++	if (af_dev_configptr->buff_app)
++		af_free_pages((unsigned long)af_dev_configptr->buff_app,
++			af_dev_configptr->size_paxel);
++
++	/* Reallocate the buffer as per new paxel configurations */
++	af_dev_configptr->buff_old =
++		(void *)__get_free_pages(GFP_KERNEL | GFP_DMA,
++		get_order(buff_size));
++
++	if (af_dev_configptr->buff_old == NULL)
++		return -ENOMEM;
++
++	/* allocate the memory for storing old statistics */
++	adr = (unsigned long)af_dev_configptr->buff_old;
++	size = PAGE_SIZE << (get_order(buff_size));
++	while (size > 0) {
++		/* make sure the frame buffers
++		   are never swapped out of memory */
++		SetPageReserved(virt_to_page(adr));
++		adr += PAGE_SIZE;
++		size -= PAGE_SIZE;
++	}
++
++	/*Allocate memory for current buffer */
++	af_dev_configptr->buff_curr =
++		(void *)__get_free_pages(GFP_KERNEL | GFP_DMA,
++		get_order(buff_size));
++
++	/* Free the previously allocated buffer */
++	if (af_dev_configptr->buff_curr == NULL) {
++		if (af_dev_configptr->buff_old)
++		af_free_pages((unsigned long)af_dev_configptr->
++				buff_old, buff_size);
++		return -ENOMEM;
++	}
++
++	adr = (unsigned long)af_dev_configptr->buff_curr;
++	size = PAGE_SIZE << (get_order(buff_size));
++
++	while (size > 0) {
++		/* make sure the frame buffers
++		   are never swapped out of memory */
++		SetPageReserved(virt_to_page(adr));
++		adr += PAGE_SIZE;
++		size -= PAGE_SIZE;
++	}
++
++	/*Allocate memory for old buffer */
++	af_dev_configptr->buff_app =
++		(void *)__get_free_pages(GFP_KERNEL | GFP_DMA,
++		get_order(buff_size));
++
++	if (af_dev_configptr->buff_app == NULL) {
++		/*Free the previously allocated buffer */
++		if (af_dev_configptr->buff_curr)
++			af_free_pages((unsigned long)af_dev_configptr->
++				      buff_curr, buff_size);
++		/*Free the previously allocated buffer */
++		if (af_dev_configptr->buff_old)
++			af_free_pages((unsigned long)af_dev_configptr->
++				      buff_old, buff_size);
++		return -ENOMEM;
++	}
++
++	adr = (unsigned long)af_dev_configptr->buff_app;
++	size = PAGE_SIZE << (get_order(buff_size));
++
++	while (size > 0) {
++		/* 
++		 * make sure the frame buffers
++		 * are never swapped out of memory
++		 */
++		SetPageReserved(virt_to_page(adr));
++		adr += PAGE_SIZE;
++		size -= PAGE_SIZE;
++	}
++
++	result = af_register_setup(af_dev_configptr);
++	if (result < 0)
++		return result;
++
++	af_dev_configptr->size_paxel = buff_size;
++
++	/*Set configuration flag to indicate HW setup done */
++	af_dev_configptr->af_config = H3A_AF_CONFIG;
++
++	return 0;
++}
++
++/*
++ * This function called when driver is opened.It creates Channel
++ * Configuration Structure
++ */
++static int af_open(struct inode *inode, struct file *filp)
++{
++	/*Return if device is in use */
++	if (af_dev_configptr->in_use == AF_IN_USE)
++		return -EBUSY;
++	af_dev_configptr->config = NULL;
++
++	/* Allocate memory for Device Structure */
++	af_dev_configptr->config = (struct af_configuration *)
++		kmalloc(sizeof(struct af_configuration), GFP_KERNEL);
++
++	if (af_dev_configptr->config == NULL) {
++		dev_err(afdev, "Error : Kmalloc fail\n");
++		return -ENOMEM;
++	}
++
++	/* Initialize the wait queue */
++	init_waitqueue_head(&(af_dev_configptr->af_wait_queue));
++
++	/* Driver is in use */
++	af_dev_configptr->in_use = AF_IN_USE;
++
++	/* Hardware is not set up */
++	af_dev_configptr->af_config = H3A_AF_CONFIG_NOT_DONE;
++	af_dev_configptr->buffer_filled = 0;
++
++	/* Initialize the mutex */
++	mutex_init(&(af_dev_configptr->read_blocked));
++
++	return 0;
++}
++
++/*
++ * This function called when driver is closed.
++ * It will deallocate all the buffers.
++ */
++static int af_release(struct inode *inode, struct file *filp)
++{
++	af_engine_setup(0);
++
++	/* Free all the buffers */
++	if (af_dev_configptr->buff_curr)
++		af_free_pages((unsigned long)af_dev_configptr->buff_curr,
++			      af_dev_configptr->size_paxel);
++
++	/* Free old buffer */
++	if (af_dev_configptr->buff_old)
++		af_free_pages((unsigned long)af_dev_configptr->buff_old,
++			      af_dev_configptr->size_paxel);
++
++	/* Free application buffer */
++	if (af_dev_configptr->buff_app)
++		af_free_pages((unsigned long)af_dev_configptr->buff_app,
++			      af_dev_configptr->size_paxel);
++
++	/* Release memory for configuration structure of this channel */
++	af_dev_configptr->buff_curr = NULL;
++	af_dev_configptr->buff_old = NULL;
++	af_dev_configptr->buff_app = NULL;
++
++	if (af_dev_configptr->config)
++		kfree(af_dev_configptr->config);
++
++	af_dev_configptr->config = NULL;
++
++	/* Device is not in use */
++	af_dev_configptr->in_use = AF_NOT_IN_USE;
++
++	return 0;
++}
++
++static void af_platform_release(struct device *device)
++{
++	/* This is called when the reference count goes to zero */
++}
++
++static int af_probe(struct device *device)
++{
++	afdev = device;
++	return 0;
++}
++
++static int af_remove(struct device *device)
++{
++	return 0;
++}
++
++/*
++ * This function will process IOCTL commands sent by the application and
++ * control the device IO operations.
++ */
++static int af_ioctl(struct inode *inode, struct file *filep,
++			unsigned int cmd, unsigned long arg)
++{
++	struct af_configuration afconfig = *(af_dev_configptr->config);
++	int result = 0;
++
++	/* Block the mutex while ioctl is called */
++	result = mutex_lock_interruptible(&af_dev_configptr->read_blocked);
++	if (result)
++		return result;
++
++	/*
++	 * Extract the type and number bitfields, and don't
++	 * decode wrong cmds return ENOTTY (inappropriate ioctl)
++	 */
++	if (_IOC_TYPE(cmd) != AF_MAGIC_NO) {
++		/* Release the mutex */
++		mutex_unlock(&af_dev_configptr->read_blocked);
++		return -ENOTTY;
++	}
++
++	if (_IOC_NR(cmd) > AF_IOC_MAXNR) {
++		/* Release the mutex */
++		mutex_unlock(&af_dev_configptr->read_blocked);
++		return -ENOTTY;
++	}
++
++	/*Use 'access_ok' to validate user space pointer */
++	if (_IOC_DIR(cmd) & _IOC_READ)
++		result =
++			!access_ok(VERIFY_WRITE, (void __user *)arg,
++			_IOC_SIZE(cmd));
++	else if (_IOC_DIR(cmd) & _IOC_WRITE)
++		result =
++			!access_ok(VERIFY_READ, (void __user *)arg,
++			_IOC_SIZE(cmd));
++
++	if (result) {
++		/* Release the mutex */
++		mutex_unlock(&af_dev_configptr->read_blocked);
++		return -EFAULT;
++	}
++
++	switch (cmd) {
++
++		/* 
++		 * This ioctl is used to perform hardware
++		 * set up for AF Engine
++		 * It will configura all the registers
++		 */
++	case AF_S_PARAM:
++		/* Copy params structure passed by user */
++		if (copy_from_user(af_dev_configptr->config,
++				   (struct af_configuration *)arg,
++				   sizeof(struct af_configuration))) {
++			/* Release the mutex */
++			mutex_unlock(&af_dev_configptr->read_blocked);
++			return -EFAULT;
++		}
++
++		/* Call AF_hardware_setup to perform register configuration */
++		result = af_hardware_setup();
++		if (!result) {
++			result = af_dev_configptr->size_paxel;
++		} else {
++			dev_err(afdev, "Error : AF_S_PARAM failed");
++			*(af_dev_configptr->config) = afconfig;
++		}
++		break;
++
++		/* This ioctl will get the paramters from application */
++	case AF_G_PARAM:
++		/* Check if Hardware is configured or not */
++		if (af_dev_configptr->af_config == H3A_AF_CONFIG) {
++			if (copy_to_user((struct af_configuration *)arg,
++					af_dev_configptr->config,
++					sizeof(struct af_configuration))) {
++					mutex_unlock(
++					&af_dev_configptr->read_blocked);
++				return -EFAULT;
++			} else
++				result = af_dev_configptr->size_paxel;
++		} else {
++			dev_dbg(afdev, "Error : AF Hardware not configured");
++			result = -EINVAL;
++		}
++
++		break;
++
++		/*
++		 * This ioctl will enable AF Engine
++		 * if hardware configuration is done
++		 */
++	case AF_ENABLE:
++		/* Check if hardware is configured or not */
++		if (af_dev_configptr->af_config == H3A_AF_CONFIG_NOT_DONE) {
++			dev_err(afdev, "Error : AF Hardware not configured");
++			result = -EINVAL;
++		} else
++			af_engine_setup(1);
++		break;
++
++		/* This ioctl will disable AF Engine */
++	case AF_DISABLE:
++		af_engine_setup(0);
++		break;
++
++	default:
++		dev_err(afdev, "Error : Invalid IOCTL!");
++		result = -ENOTTY;
++		break;
++	}
++
++	/* Before returning increment mutex */
++	mutex_unlock(&af_dev_configptr->read_blocked);
++
++	return result;
++}
++
++/* Function will return the statistics to user */
++ssize_t af_read(struct file * filep, char *kbuff, size_t size, loff_t * offset)
++{
++	void *buff_temp;
++	int result = 0;
++	int ret;
++
++	/* mutex will return immediately if read call is busy */
++	ret = mutex_lock_interruptible(&af_dev_configptr->read_blocked);
++	if (ret != 0) {
++		dev_err(afdev, "\n Read Call : busy");
++		return -EBUSY;
++	}
++
++	/* 
++	 * If no of bytes specified by the user is less
++	 * than that of buffer return error
++	 */
++	if (size < af_dev_configptr->size_paxel) {
++		dev_err(afdev, "\n Error : Invalid buffer size");
++		mutex_unlock(&(af_dev_configptr->read_blocked));
++		return -1;
++	}
++
++	/*
++	 * The value of bufffer_filled flag determines
++	 * the status of statistics
++	 */
++	if (af_dev_configptr->buffer_filled == 0) {
++		dev_dbg(afdev, "Read call is blocked ................");
++		/* Block the read call until 
++		 * new statistics are available
++		 * or timer expires
++		 */
++		wait_event_interruptible_timeout(af_dev_configptr->
++						 af_wait_queue,
++						 af_dev_configptr->
++						 buffer_filled, AF_TIMEOUT);
++		dev_dbg(afdev,
++			"\n Read Call Unblocked..........................");
++	}
++
++	if (af_dev_configptr->buffer_filled == 1) {
++		/* 
++		 * New Statistics are available
++		 * Disable the interrupts while
++		 * swapping the buffers */
++		dev_dbg(afdev, "\n Reading.............................");
++		disable_irq(4);
++
++		af_dev_configptr->buffer_filled = 0;
++
++		/* Swap application buffer and old buffer */
++		buff_temp = af_dev_configptr->buff_old;
++		af_dev_configptr->buff_old = af_dev_configptr->buff_app;
++		af_dev_configptr->buff_app = buff_temp;
++
++		dev_dbg(afdev, "\n Reading Done...........................");
++
++		/* Enable the interrupts  once swapping is done */
++		enable_irq(4);
++
++		/*
++		 * New Statistics are not availaible
++		 * copy the application buffer to user
++		 * Return the entire statistics to user
++		 */
++		if (copy_to_user(kbuff, af_dev_configptr->buff_app,
++				 af_dev_configptr->size_paxel)) {
++			/* Release the mutex in case of fault */
++			mutex_unlock(&(af_dev_configptr->read_blocked));
++			return -EFAULT;
++		} else
++			result = af_dev_configptr->size_paxel;
++	}
++
++	/* Release the mutex */
++	mutex_unlock(&(af_dev_configptr->read_blocked));
++	dev_dbg(afdev, "\n Read APPLICATION  BUFFER %d",
++		*((int *)((af_dev_configptr->buff_app))));
++
++	return result;
++}
++
++static irqreturn_t af_isr(int irq, void *dev_id)
++{
++	void *buff_temp;
++	int busyaf;
++
++	/* Get the value of PCR register */
++	busyaf = AF_GET_PCR;
++
++	/* If AF Engine has enabled, interrupt is not for AF */
++	if ((busyaf & 0x01) == 0)
++		return IRQ_RETVAL(IRQ_NONE);
++
++	/*
++	 * Service  the Interrupt
++	 * Set buffer filled flag to indicate
++	 * statistics are available
++	 * Swap current buffer and old buffer
++	 */
++	if (af_dev_configptr) {
++		buff_temp = af_dev_configptr->buff_curr;
++		af_dev_configptr->buff_curr = af_dev_configptr->buff_old;
++		af_dev_configptr->buff_old = buff_temp;
++
++		/* Set AF Buf st to current register address */
++		if (af_dev_configptr->buff_curr)
++			af_set_address((unsigned long)
++			       virt_to_phys(af_dev_configptr->buff_curr));
++
++		/* Wake up read as new statistics are available */
++		af_dev_configptr->buffer_filled = 1;
++		wake_up(&(af_dev_configptr->af_wait_queue));
++		return IRQ_RETVAL(IRQ_HANDLED);
++	}
++	return IRQ_RETVAL(IRQ_NONE);
++}
++
++/* File Operation Structure */
++static struct file_operations af_fops = {
++	.owner		= THIS_MODULE,
++	.open		= af_open,
++	.ioctl		= af_ioctl,
++	.read		= af_read,
++	.release	= af_release
++};
++static struct platform_device afdevice = {
++	.name	= "dm355_af",
++	.id	= 2,
++	.dev	= {
++		.release = af_platform_release,
++	}
++};
++
++static struct device_driver af_driver = {
++	.name	= "dm355_af",
++	.bus	= &platform_bus_type,
++	.probe	= af_probe,
++	.remove	= af_remove,
++};
++
++/* Function to register the AF character device driver. */
++#define DRIVERNAME  "DM355AF"
++int __init af_init(void)
++{
++	int err;
++	int result = 0;
++	unsigned int vpssclk;
++
++	/* 
++	 * Register the driver in the kernel
++	 * dynmically get the major number
++	 * for the driver using
++	 * alloc_chrdev_region function
++	 */
++	result = alloc_chrdev_region(&dev, 0, 1, DRIVERNAME);
++
++	if (result < 0) {
++		printk("Error :  Could not register character device");
++		return -ENODEV;
++	}
++
++	printk(KERN_INFO "af major#: %d, minor# %d\n", MAJOR(dev), MINOR(dev));
++
++	/* allocate memory for device structure and initialize it with 0 */
++	af_dev_configptr =
++		(struct af_device *)kmalloc(sizeof(struct af_device), GFP_KERNEL);
++	if (!af_dev_configptr) {
++		printk("Error : kmalloc fail");
++		unregister_chrdev_region(dev, AF_NR_DEVS);
++		return -ENOMEM;
++	}
++
++	/* Initialize character device */
++	cdev_init(&c_dev, &af_fops);
++	c_dev.owner = THIS_MODULE;
++	c_dev.ops = &af_fops;
++
++	err = cdev_add(&c_dev, dev, 1);
++	if (err) {
++		printk("Error : Error in  Adding Davinci AF");
++		unregister_chrdev_region(dev, AF_NR_DEVS);
++		if (af_dev_configptr)
++			kfree(af_dev_configptr);
++		return -err;
++	}
++
++	/* register driver as a platform driver */
++	if (driver_register(&af_driver) != 0) {
++		unregister_chrdev_region(dev, 1);
++		cdev_del(&c_dev);
++		return -EINVAL;
++	}
++
++	/* Register the drive as a platform device */
++	if (platform_device_register(&afdevice) != 0) {
++		driver_unregister(&af_driver);
++		unregister_chrdev_region(dev, 1);
++		cdev_del(&c_dev);
++		return -EINVAL;
++	}
++
++	af_class = class_create(THIS_MODULE, "dm355_af");
++	if (!af_class) {
++		printk("af_init: error in creating device class\n");
++		driver_unregister(&af_driver);
++		platform_device_unregister(&afdevice);
++		unregister_chrdev_region(dev, 1);
++		unregister_chrdev(MAJOR(dev), DRIVERNAME);
++		cdev_del(&c_dev);
++		return -EINVAL;
++	}
++
++	/* register device class */
++	device_create(af_class, NULL, dev, NULL, "dm355_af");
++
++	AF_SETGAMMAWD;
++
++	vpssclk = AF_GETCLKCTRL;
++	vpssclk |= (1 << 4);
++	AF_SETCLKCTRL(vpssclk);
++
++	/* Set up the Interrupt handler for H3AINT interrupt */
++	result = request_irq(4, af_isr, IRQF_SHARED, "dm355h3a_af",
++			(void *)af_dev_configptr);
++
++	if (result != 0) {
++		printk("Error : Request IRQ Failed");
++		unregister_chrdev_region(dev, AF_NR_DEVS);
++		if (af_dev_configptr)
++			kfree(af_dev_configptr);
++		device_destroy(af_class, dev);
++		class_destroy(af_class);
++		driver_unregister(&af_driver);
++		platform_device_unregister(&afdevice);
++		cdev_del(&c_dev);
++		return result;
++	}
++
++	/* Initialize device structure */
++	memset((unsigned char *)af_dev_configptr, 0, sizeof(struct af_device));
++
++	af_dev_configptr->in_use = AF_NOT_IN_USE;
++	af_dev_configptr->buffer_filled = 0;
++	return 0;
++}
++
++/*
++ * This function is called by the kernel while unloading the driver.
++ * It will unregister character device driver
++ */
++void __exit af_cleanup(void)
++{
++	/* Return if driver is busy */
++	if (af_dev_configptr->in_use == AF_IN_USE) {
++		printk("Error : Driver in use. Can't remove.");
++		return;
++	}
++
++	free_irq(4, af_dev_configptr);
++
++	/* Free device structure */
++	if (af_dev_configptr)
++		kfree(af_dev_configptr);
++
++	unregister_chrdev_region(dev, AF_NR_DEVS);
++
++	driver_unregister(&af_driver);
++
++	device_destroy(af_class, dev);
++
++	class_destroy(af_class);
++
++	platform_device_unregister(&afdevice);
++
++	/* Unregistering the driver from the kernel */
++	cdev_del(&c_dev);
++}
++
++module_init(af_init)
++module_exit(af_cleanup)
++MODULE_LICENSE("GPL");
+--- a/drivers/media/video/adv7343_regs.h
++++ b/drivers/media/video/adv7343_regs.h
+@@ -17,11 +17,21 @@
+ #define ADV7343_REGS_H
+ 
+ struct adv7343_std_info {
++	u8 set_std_reg;
++	u32 outputmode_val;
++	u32 standard_val2;
+ 	u32 standard_val3;
+ 	u32 fsc_val;
+ 	v4l2_std_id stdid;
+ };
+ 
++struct adv7343_output_info {
++	u32 output_type;
++	u32 num_std;
++	u32 dac_enable;
++	struct adv7343_std_info *std_info;
++};
++
+ /* Register offset macros */
+ #define ADV7343_POWER_MODE_REG		(0x00)
+ #define ADV7343_MODE_SELECT_REG		(0x01)
+@@ -182,4 +192,8 @@ struct adv7343_std_info {
+ #define ADV7343_GAIN_MIN	(0)
+ #define ADV7343_GAIN_DEF	(0)
+ 
++#define ADV7343_SVIDEO_NUM_STD 		(7)
++#define ADV7343_COMPOSITE_NUM_STD	(7)
++#define ADV7343_COMPONENT_NUM_STD	(13)
++
+ #endif
+--- a/drivers/char/Kconfig
++++ b/drivers/char/Kconfig
+@@ -1079,6 +1079,14 @@ config HPET_MMAP
+ 	  exposed to the user.  If this applies to your hardware,
+ 	  say N here.
+ 
++config DM646x_PCI_TARGET_DRV
++        tristate "DaVinci DM646x PCI Target Driver"
++        default n
++        depends on ARCH_DAVINCI_DM646x && PCI
++        help
++                This option builds driver for DM646x PCI target connected to
++                the DM646x configured as PCI Host. Use 'M' to build as module.
++
+ config HANGCHECK_TIMER
+ 	tristate "Hangcheck timer"
+ 	depends on X86 || IA64 || PPC64 || S390
+@@ -1124,6 +1132,71 @@ config DEVPORT
+ 	depends on ISA || PCI
+ 	default y
+ 
++config VDCE
++        tristate "DaVinci VDCE Driver"
++        default n
++        depends on ARCH_DAVINCI_DM646x
++        help
++                DaVinci VDCE Driver.
++
++config DM355_IPIPE
++	depends on ARCH_DAVINCI && ARCH_DAVINCI_DM355
++	tristate "DM355 IPIPE"
++	help
++	   DM355 IPIPE driver.This is the hardware module that
++	   implements imp_hw_interface for DM355. This hardware module provides
++	   previewer and resizer configuration functionality for image processing.
++
++config DM365_IPIPE
++	depends on ARCH_DAVINCI && ARCH_DAVINCI_DM365
++	tristate "DM365 IPIPE"
++	help
++	   DM365 IPIPE driver. This is the hardware module that
++	   implements imp_hw_interface for DM365. This hardware module provides
++	   previewer and resizer functionality for image processing.
++
++config IMP_PREVIEWER
++	depends on (DM355_IPIPE || DM365_IPIPE)
++	default n
++	tristate "IMP Previewer"
++	help
++	   Image Pipe (IMP) Previewer Driver. This previewer
++	   driver is used for converting Bayer RGB image to UYVY format. It also
++	   provides image tuning functionality by using different tuning modules
++	   available in the VPFE. This can be configured either in continuous
++	   mode or single shot mode. In continous mode, Bayer RGB data from CCDC is
++	   tuned on the fly and converted to UYVY format. In Single shot mode
++	   image is first captured from CCDC to SDRAM and then given to the
++	   previewer device for further processing as mentioned above.
++
++config IMP_RESIZER
++	depends on (DM355_IPIPE || DM365_IPIPE)
++	default n
++	tristate "IMP Resizer"
++	help
++	   Image Pipe (IMP) resizer driver. This resizer driver
++	   is needed to generate scaled up/down UYVY images. When chained
++	   with previewer, this can resize a Bayer RGB image/UYVY image.
++	   In standalone mode, this can resize only UYVY image. This device
++	   can be chained with the previewer device to configure the resizer
++	   at the output of the previewer hardware. This can also work in
++	   continuous and single shot mode similar to the previewer.
++
++config IMP_DEBUG
++	depends on (DM355_IPIPE || DM365_IPIPE)
++	bool "IMP Debug support"
++	default n
++	help
++	  Enable dumping of Image PIPE configuration to console
++
++config CIR
++        tristate "DaVinci CIR Driver"
++        default n
++        depends on ARCH_DAVINCI_DM646x
++        help
++                DaVinci CIR Driver.
++
++
+ source "drivers/s390/char/Kconfig"
+ 
+ endmenu
+--- /dev/null
++++ b/include/linux/cir.h
+@@ -0,0 +1,67 @@
++/*
++ * cir.h - Header file for the driver for Consumer Infrared (CIR)
++	   (on Davinci-HD EVM)
++ *
++ * Copyright (C) 2007  Texas Instruments, India
++ * Author: Suresh Rajashekara <suresh.r@ti.com>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License along
++ * with this program; if not, write to the Free Software Foundation, Inc.,
++ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
++ *
++ */
++
++#ifndef __CIR_H__
++#define __CIR_H__
++
++#ifdef __KERNEL__
++#include <linux/module.h>
++#include <linux/init.h>
++#include <linux/device.h>
++#include <linux/wait.h>
++#include <linux/completion.h>
++#include <linux/interrupt.h>
++#include <linux/err.h>
++#include <linux/uaccess.h>
++
++#include <mach/io.h>
++#include <asm/atomic.h>
++
++#define CIR_IOC_BASE     'C'
++#define CIRIOC_GET_SYS_CLOCK_FREQ_PRESCALER  _IOR(CIR_IOC_BASE, 1, int)
++#define CIRIOC_SET_SYS_CLOCK_FREQ_PRESCALER  _IOW(CIR_IOC_BASE, 2, int)
++#define CIRIOC_GET_ENCODING                  _IOR(CIR_IOC_BASE, 3, int)
++
++#define CIR_ENCODING_RC5   1
++
++#define CIR_MAJOR_NUMBER 253	/* This macro is currently not used. Define it
++				   to any value if you are using static minor
++				   numbers and use the same in cir.c */
++#define CIR_DEV_COUNT    1
++#endif
++
++#define CIR_IOC_MAGIC 'k'
++
++/* Only 3 Ioctls now. Update if adding new ioctl */
++#define CIR_IOC_MAXNR 2
++
++/* Ioctl to flush the buffers driver uses to store the keys received */
++#define CIR_FLUSH _IO(CIR_IOC_MAGIC, 0)
++
++/* Change the duration, within which, if another key is received is neglected */
++#define CIR_SET_REPEAT_DELAY _IOW(CIR_IOC_MAGIC, 1, int)
++
++/* Read the duration, within which, if another key is received is neglected */
++#define CIR_GET_REPEAT_DELAY _IOR(CIR_IOC_MAGIC, 2, int)
++
++#endif /* _CIR_H__ */
+--- a/drivers/spi/Makefile
++++ b/drivers/spi/Makefile
+@@ -34,6 +34,7 @@ obj-$(CONFIG_SPI_TXX9)			+= spi_txx9.o
+ obj-$(CONFIG_SPI_XILINX)		+= xilinx_spi.o
+ obj-$(CONFIG_SPI_SH_SCI)		+= spi_sh_sci.o
+ obj-$(CONFIG_SPI_STMP3XXX)		+= spi_stmp.o
++obj-$(CONFIG_SPI_DAVINCI)		+= davinci_spi.o
+ # 	... add above this line ...
+ 
+ # SPI protocol drivers (device/link on bus)
+--- a/drivers/mmc/core/sdio_ops.c
++++ b/drivers/mmc/core/sdio_ops.c
+@@ -19,6 +19,28 @@
+ #include "core.h"
+ #include "sdio_ops.h"
+ 
++int mmc_reset_sdio(struct mmc_host *host)
++{
++	struct mmc_command cmd;
++	int err = 0;
++
++	BUG_ON(!host);
++
++	memset(&cmd, 0, sizeof(struct mmc_command));
++
++	cmd.opcode = SD_IO_RW_DIRECT;
++	cmd.arg = 0x80000000;
++	cmd.arg |= (SDIO_CCCR_ABORT) << 9;
++	cmd.arg |= (1<<3);
++	cmd.flags = MMC_RSP_R5 | MMC_CMD_AC;
++
++	err = mmc_wait_for_cmd(host, &cmd, 0);
++	if (err)
++		return err;
++
++	return 0;
++}
++
+ int mmc_send_io_op_cond(struct mmc_host *host, u32 ocr, u32 *rocr)
+ {
+ 	struct mmc_command cmd;
+--- /dev/null
++++ b/drivers/media/video/davinci/avnetlcd_encoder.c
+@@ -0,0 +1,373 @@
++/*
++ * Copyright (C) 2008 Texas Instruments Inc
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
++ */
++/* logicpd_encoder.c. This is just a place holder for hardcoding all supported
++   modes timing. LogicPD timing signals are programmed by the encoder manager
++   based on this data.
++ */
++
++/* Kernel Specific header files */
++
++#include <linux/kernel.h>
++#include <linux/autoconf.h>
++#include <linux/init.h>
++#include <linux/ctype.h>
++#include <linux/delay.h>
++#include <media/davinci/vid_encoder_if.h>
++#include <media/davinci/avnetlcd_encoder.h>
++
++/* Function prototypes */
++static int avnetlcd_encoder_initialize(struct vid_encoder_device *enc,
++				       int flag);
++static int avnetlcd_encoder_deinitialize(struct vid_encoder_device *enc);
++
++static int avnetlcd_encoder_setmode(struct vid_enc_mode_info *mode_info,
++				    struct vid_encoder_device *enc);
++static int avnetlcd_encoder_getmode(struct vid_enc_mode_info *mode_info,
++				    struct vid_encoder_device *enc);
++
++static int avnetlcd_encoder_setoutput(char *output,
++				      struct vid_encoder_device *enc);
++static int avnetlcd_encoder_getoutput(char *output,
++				      struct vid_encoder_device *enc);
++
++static int avnetlcd_encoder_enumoutput(int index,
++				       char *output,
++				       struct vid_encoder_device *enc);
++
++static struct avnetlcd_encoder_config avnetlcd_encoder_configuration = {
++	.no_of_outputs = AVNETLCD_ENCODER_MAX_NO_OUTPUTS,
++	.output[0] = {
++		      .output_name = VID_ENC_OUTPUT_LCD1,
++		      .no_of_standard = AVNETLCD_ENCODER_GRAPHICS_NUM_STD,
++		      .standards[0] = {
++				       .name = VID_ENC_STD_800x480,
++				       .std = 1,
++				       .if_type = VID_ENC_IF_PRGB,
++				       .interlaced = 0,
++				       .xres = 800,
++				       .yres = 480,
++				       .fps = {60, 1},
++				       .left_margin = 85,
++				       .right_margin = 70,
++				       .upper_margin = 32,
++				       .lower_margin = 11,
++				       .hsync_len = 9,
++				       .vsync_len = 9,
++				       .flags = 0},
++		      },	/* hsync -ve, vsync -ve */
++};
++
++static struct avnetlcd_encoder_channel avnetlcd_encoder_channel_info = {
++	.params.outindex = 0,
++	.params.mode = VID_ENC_STD_800x480,
++	.enc_device = NULL
++};
++
++static struct vid_enc_output_ops outputs_ops = {
++	.count = AVNETLCD_ENCODER_MAX_NO_OUTPUTS,
++	.enumoutput = avnetlcd_encoder_enumoutput,
++	.setoutput = avnetlcd_encoder_setoutput,
++	.getoutput = avnetlcd_encoder_getoutput
++};
++
++static struct vid_enc_mode_ops modes_ops = {
++	.setmode = avnetlcd_encoder_setmode,
++	.getmode = avnetlcd_encoder_getmode,
++};
++
++static struct vid_encoder_device avnetlcd_encoder_dev = {
++	.name = "AVNETLCD_ENCODER",
++	.capabilities = 0,
++	.initialize = avnetlcd_encoder_initialize,
++	.mode_ops = &modes_ops,
++	.ctrl_ops = NULL,
++	.output_ops = &outputs_ops,
++	.params_ops = NULL,
++	.misc_ops = NULL,
++	.deinitialize = avnetlcd_encoder_deinitialize,
++};
++
++/*
++ * This function is called by the encoder manager to initialize
++ * avnetlcd encoder driver.
++ */
++static int avnetlcd_encoder_initialize(struct vid_encoder_device *enc, int flag)
++{
++	int err = 0, outindex;
++	char *std, *output;
++	if (NULL == enc) {
++		printk(KERN_ERR "enc:NULL Pointer\n");
++		return -EINVAL;
++	}
++	avnetlcd_encoder_channel_info.enc_device = (struct encoder_device *)enc;
++
++	/* call set standard */
++	std = avnetlcd_encoder_channel_info.params.mode;
++	outindex = avnetlcd_encoder_channel_info.params.outindex;
++	output = avnetlcd_encoder_configuration.output[outindex].output_name;
++	err |= avnetlcd_encoder_setoutput(output, enc);
++	if (err < 0) {
++		err = -EINVAL;
++		printk(KERN_ERR "Error occured in setoutput\n");
++		avnetlcd_encoder_deinitialize(enc);
++		return err;
++	}
++	printk(KERN_DEBUG "Avnetlcd Encoder initialized\n");
++	return err;
++}
++
++/* Function to de-initialize the encoder */
++static int avnetlcd_encoder_deinitialize(struct vid_encoder_device *enc)
++{
++	if (NULL == enc) {
++		printk(KERN_ERR "NULL Pointer\n");
++		return -EINVAL;
++	}
++	avnetlcd_encoder_channel_info.enc_device = NULL;
++	printk(KERN_DEBUG "Avnetlcd Encoder de-initialized\n");
++	return 0;
++}
++
++/* Following function is used to set the mode*/
++static int avnetlcd_encoder_setmode(struct vid_enc_mode_info *mode_info,
++				    struct vid_encoder_device *enc)
++{
++	int err = 0, outindex, i;
++	char *mode;
++	struct vid_enc_mode_info *my_mode_info = NULL;
++
++	if ((NULL == enc) || (NULL == mode_info)) {
++		printk(KERN_ERR "NULL Pointer\n");
++		return -EINVAL;
++	}
++	mode = mode_info->name;
++	if (NULL == mode) {
++		printk(KERN_ERR "NULL Pointer\n");
++		return -EINVAL;
++	}
++	printk(KERN_DEBUG "Start of avnetlcd_encoder_setmode..\n");
++	outindex = avnetlcd_encoder_channel_info.params.outindex;
++
++	if (mode_info->std) {
++		char *mymode = NULL;
++		/* This is a standard mode */
++		for (i = 0;
++		     i <
++		     avnetlcd_encoder_configuration.output[outindex].
++		     no_of_standard; i++) {
++			if (!strcmp
++			    (avnetlcd_encoder_configuration.output[outindex].
++			     standards[i].name, mode)) {
++				mymode =
++				    avnetlcd_encoder_configuration.
++				    output[outindex].standards[i].name;
++				break;
++			}
++		}
++		if ((i ==
++		     avnetlcd_encoder_configuration.output[outindex].
++		     no_of_standard) || (NULL == mymode)) {
++			printk(KERN_ERR "Invalid id...\n");
++			return -EINVAL;
++		}
++		/* Store the standard in global object of avnetlcd_encoder */
++		avnetlcd_encoder_channel_info.params.mode = mymode;
++		return 0;
++	} else {
++		/* Non- Standard mode. Check if we support it. If so
++		   save the timing info and return */
++		for (i = 0; i < AVNETLCD_ENCODER_GRAPHICS_NUM_STD; i++) {
++			if (!strcmp
++			    (avnetlcd_encoder_configuration.output[outindex].
++			     standards[i].name, VID_ENC_STD_NON_STANDARD)) {
++				my_mode_info =
++				    &avnetlcd_encoder_configuration.
++				    output[outindex].standards[i];
++				break;
++			}
++		}
++		if (my_mode_info) {
++			/* We support. So save timing info and return success
++			   interface type is same as what is currently is active
++			 */
++			my_mode_info->interlaced = mode_info->interlaced;
++			my_mode_info->xres = mode_info->xres;
++			my_mode_info->yres = mode_info->yres;
++			my_mode_info->fps = mode_info->fps;
++			my_mode_info->left_margin = mode_info->left_margin;
++			my_mode_info->right_margin = mode_info->right_margin;
++			my_mode_info->upper_margin = mode_info->upper_margin;
++			my_mode_info->lower_margin = mode_info->lower_margin;
++			my_mode_info->hsync_len = mode_info->hsync_len;
++			my_mode_info->vsync_len = mode_info->vsync_len;
++			my_mode_info->flags = mode_info->flags;
++			/*
++       * If we need to configure something in the encoder module,
++       * we need to do this here
++			 */
++			return 0;
++		}
++		printk(KERN_ERR "Mode not supported..\n");
++		return -EINVAL;
++	}
++	printk(KERN_DEBUG "</avnetlcd_encoder_setmode>\n");
++	return err;
++}
++
++/* Following function is used to get currently selected mode.*/
++static int avnetlcd_encoder_getmode(struct vid_enc_mode_info *mode_info,
++				    struct vid_encoder_device *enc)
++{
++	int err = 0, i, outindex;
++	if ((NULL == enc) || (NULL == mode_info)) {
++		printk(KERN_ERR "NULL Pointer\n");
++		return -EINVAL;
++	}
++	printk(KERN_DEBUG "<avnetlcd_encoder_getmode>\n");
++	outindex = avnetlcd_encoder_channel_info.params.outindex;
++	for (i = 0; i < AVNETLCD_ENCODER_GRAPHICS_NUM_STD; i++) {
++		if (!strcmp(avnetlcd_encoder_channel_info.params.mode,
++			    avnetlcd_encoder_configuration.output[outindex].
++			    standards[i].name)) {
++			memcpy(mode_info,
++			       &avnetlcd_encoder_configuration.output[outindex].
++			       standards[i], sizeof(struct vid_enc_mode_info));
++			break;
++		}
++	}
++	if (i == AVNETLCD_ENCODER_GRAPHICS_NUM_STD) {
++		printk(KERN_ERR "Wiered. No mode info\n");
++		return -EINVAL;
++	}
++	printk(KERN_DEBUG "</avnetlcd_encoder_getmode>\n");
++	return err;
++}
++
++/* For Avnetlcd, we have only one output, called LCD, we
++   always set this to this at init
++*/
++static int avnetlcd_encoder_setoutput(char *output,
++				      struct vid_encoder_device *enc)
++{
++	int err = 0;
++	struct vid_enc_mode_info *my_mode_info;
++	printk(KERN_DEBUG "<avnetlcd_encoder_setoutput>\n");
++	if (NULL == enc) {
++		printk(KERN_ERR "enc:NULL Pointer\n");
++		return -EINVAL;
++	}
++
++	/* check for null pointer */
++	if (output == NULL) {
++		printk(KERN_ERR "output: NULL Pointer.\n");
++		return -EINVAL;
++	}
++
++	/* Just check if the default output match with this output name */
++	if (strcmp
++	    (avnetlcd_encoder_configuration.output[0].output_name, output)) {
++		printk(KERN_ERR "no matching output found.\n");
++		return -EINVAL;
++	}
++	avnetlcd_encoder_channel_info.params.mode
++	    = avnetlcd_encoder_configuration.output[0].standards[0].name;
++
++	my_mode_info = &avnetlcd_encoder_configuration.output[0].standards[0];
++	err |= avnetlcd_encoder_setmode(my_mode_info, enc);
++	if (err < 0) {
++		printk(KERN_ERR "Error in setting default mode\n");
++		return err;
++	}
++	printk(KERN_DEBUG "</avnetlcd_encoder_setoutput>\n");
++	return err;
++}
++
++/* Following function is used to get output name of current output.*/
++static int avnetlcd_encoder_getoutput(char *output,
++				      struct vid_encoder_device *enc)
++{
++	int err = 0, index, len;
++	if (NULL == enc) {
++		printk(KERN_ERR "enc:NULL Pointer\n");
++		return -EINVAL;
++	}
++	printk(KERN_DEBUG "<avnetlcd_encoder_getoutput>\n");
++	/* check for null pointer */
++	if (output == NULL) {
++		printk(KERN_ERR "output:NULL Pointer.\n");
++		return -EINVAL;
++	}
++	index = avnetlcd_encoder_channel_info.params.outindex;
++	len = strlen(avnetlcd_encoder_configuration.output[index].output_name);
++	if (len > (VID_ENC_NAME_MAX_CHARS - 1))
++		len = VID_ENC_NAME_MAX_CHARS - 1;
++	strncpy(output,
++		avnetlcd_encoder_configuration.output[index].output_name, len);
++	output[len] = '\0';
++	printk(KERN_DEBUG "</avnetlcd_encoder_getoutput>\n");
++	return err;
++}
++
++/* Following function is used to enumerate outputs supported by the driver.
++   It fills in information in the output. */
++static int avnetlcd_encoder_enumoutput(int index, char *output,
++				       struct vid_encoder_device *enc)
++{
++	int err = 0;
++
++	printk(KERN_DEBUG "<avnetlcd_encoder_enumoutput>\n");
++	if (NULL == enc) {
++		printk(KERN_ERR "enc:NULL Pointer.\n");
++		return -EINVAL;
++	}
++	/* check for null pointer */
++	if (output == NULL) {
++		printk(KERN_ERR "output:NULL Pointer.\n");
++		return -EINVAL;
++	}
++	/* Only one output is available */
++	if (index >= avnetlcd_encoder_configuration.no_of_outputs)
++		return -EINVAL;
++
++	strncpy(output,
++		avnetlcd_encoder_configuration.output[index].output_name,
++		VID_ENC_NAME_MAX_CHARS);
++	printk(KERN_DEBUG "</avnetlcd_encoder_enumoutput>\n");
++	return err;
++}
++
++/* This function used to initialize the Avnetlcd encoder driver */
++static int avnetlcd_encoder_init(void)
++{
++	int err = 0;
++
++	err = vid_enc_register_encoder(&avnetlcd_encoder_dev);
++	printk(KERN_NOTICE "Avnetlcd encoder initialized\n");
++	return err;
++}
++
++/* Function used to cleanup Avnetlcd encoder driver */
++static void avnetlcd_encoder_cleanup(void)
++{
++	vid_enc_unregister_encoder(&avnetlcd_encoder_dev);
++}
++
++subsys_initcall_sync(avnetlcd_encoder_init);
++module_exit(avnetlcd_encoder_cleanup);
++
++MODULE_LICENSE("GPL");
+--- a/arch/arm/mach-davinci/include/mach/nand.h
++++ b/arch/arm/mach-davinci/include/mach/nand.h
+@@ -79,6 +79,10 @@ struct davinci_nand_pdata {		/* platform
+ 
+ 	/* e.g. NAND_BUSWIDTH_16 or NAND_USE_FLASH_BBT */
+ 	unsigned		options;
++
++	/* Main and mirror bbt descriptor overrides */
++	struct nand_bbt_descr	*bbt_td;
++	struct nand_bbt_descr	*bbt_md;
+ };
+ 
+ #endif	/* __ARCH_ARM_DAVINCI_NAND_H */
+--- a/drivers/net/davinci_emac.c
++++ b/drivers/net/davinci_emac.c
+@@ -2272,7 +2272,7 @@ static int emac_mii_reset(struct mii_bus
+ 	unsigned int clk_div;
+ 	int mdio_bus_freq = emac_bus_frequency;
+ 
+-	if (mdio_max_freq & mdio_bus_freq)
++	if (mdio_max_freq && mdio_bus_freq)
+ 		clk_div = ((mdio_bus_freq / mdio_max_freq) - 1);
+ 	else
+ 		clk_div = 0xFF;
+--- /dev/null
++++ b/include/media/davinci/dm355_af_hw.h
+@@ -0,0 +1,137 @@
++/*
++ * Copyright (C) 2009 Texas Instruments Inc
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
++ */
++
++#ifndef DM355_AF_DRIVER_HW_H
++#define DM355_AF_DRIVER_HW_H
++
++/* Include driver header file */
++#include "dm355_af.h"
++#include <mach/hardware.h>
++
++#ifdef __KERNEL__
++
++/* Register Offsets */
++#define AFPID		0x0		/*Peripheral Revision */
++#define AFPCR		0x00000004	/*Peripheral Control Register */
++#define AFPAX1		0x00000008	/*Setup for the Paxel Configuration */
++#define AFPAX2		0x0000000c	/*Setup for the Paxel Configuration */
++#define AFPAXSTART	0x00000010	/*Start Position for Engine Paxels */
++#define AFIIRSH		0x00000014	/*Start Position for IIRSH */
++#define AFBUFST		0x00000018	/*SDRAM/DDRAM Start address */
++
++/*IIR filter coefficient data for SET 0 */
++#define AFCOEF010	0x0000001c
++#define AFCOEF032	0x00000020	
++#define AFCOEF054	0x00000024	
++#define AFCOEF076	0x00000028	
++#define AFCOEF098	0x0000002c
++#define AFCOEF0010	0x00000030
++
++/*IIR filter coefficient data for SET 1 */
++#define AFCOEF110	0x00000034
++#define AFCOEF132	0x00000038
++#define AFCOEF154	0x0000003c
++#define AFCOEF176	0x00000040
++#define AFCOEF198	0x00000044
++#define AFCOEF1010	0x00000048
++
++#define AF_RSDR_ADDR	0x00000060	/*SDRAM/DDRAM Read Address */
++#define AF_RSDR_OFFSET	0x00000064	/*SDRAM/DDRAM Line Offset */
++#define AF_SDR_FRSIZE	0x00000068	/*Frame Size for SDRAM read data */
++
++#define AFCOEF_OFFSET	0x00000004	/* COEFFICIENT BASE ADDRESS */
++
++#define AF_SET_VAL(x)		(((x)/2)-1)
++#define AF_NOT_EVEN		1
++#define AF_CHECK_EVEN(x)	((x)%2)
++
++/* PID fields */
++#define AF_TID			(0xFF<<16)
++#define AF_CID			(0xFF<<8)
++#define AF_PREV			0xFF
++
++/* PCR fields */
++#define AVE2LMT			(0x3FF<<22)
++#define AF_INP_SRC		(1<<19)
++#define AF_BUSYAEWB		(1<<18)
++#define AEW_ALAW_EN		(1<<17)
++#define AEW_EN			(1<<16)
++#define AF_BUSYAF		(1<<15)
++#define FVMODE			(1<<14)
++#define RGBPOS			(0x7<<11)
++#define MED_TH			(0xFF<<3)
++#define AF_MED_EN		(1<<2)
++#define AF_ALAW_EN		(1<<1)
++#define AF_EN			(1<<0)
++
++#define AF_SETGAMMAWD	__raw_writel(0x00000010, IO_ADDRESS(0x01C70680))
++
++/* AFPAX1 fields */
++#define PAXW			(0x7F<<16)
++#define PAXH			0x7F
++
++#define AF_CCDC			0
++
++/* AFPAX2 fields */
++#define  AFINCV			(0xF<<13)
++#define  PAXVC			(0x7F<<6)
++#define  PAXHC			0x3F
++
++/* AFPAXSTART fields */
++#define  PAXSH			(0xFFF<<16)
++#define  PAXSV			0xFFF
++
++/* COEFFICIENT MASK */
++#define COEF_MASK0		0xFFF
++#define COEF_MASK1		(0xFFF<<16)
++
++/* SDRAM Frame Size */
++#define AF_SDR_FRSIZE_HSIZE	0xFFF
++#define AF_SDR_FRSIZE_VSIZE	(0xFFF<<16)
++#define AF_SDR_FRSIZE_BITSEL	(0x7<<28)
++
++/* BIT SHIFTS */
++#define AF_RGBPOS_SHIFT		11
++#define AF_MED_TH_SHIFT		3
++#define AF_PAXW_SHIFT		16
++#define AF_LINE_INCR_SHIFT	13
++#define AF_VT_COUNT_SHIFT	6
++#define AF_HZ_START_SHIFT	16
++#define AF_COEF_SHIFT		16
++#define AF_INP_SRC_SHIFT	19
++#define AF_GETFRAME_SIZE	(__raw_readl(IO_ADDRESS(0x01C70910)))
++#define AF_GETINIT_XY		(__raw_readl(IO_ADDRESS(0x01C70910)))
++#define AF_INTSTATBASE		(IO_ADDRESS(0x01C7080C))
++#define AF_EVNTSELADDR		(IO_ADDRESS(0x01C70814))
++#define	AF_CLKCTRL_ADDR		(IO_ADDRESS(0x01C70004))
++#define AF_GETCLKCTRL		__raw_readl(AF_CLKCTRL_ADDR)
++#define AF_SETCLKCTRL(val)	__raw_writel(val,AF_CLKCTRL_ADDR)
++
++/* Macros for register read and write */
++#define AF_IOBASE_VADDR		IO_ADDRESS(0x01c70080)
++#define regr(reg)		__raw_readl((reg)+AF_IOBASE_VADDR)
++#define regw(val,reg)		__raw_writel(val,(reg)+AF_IOBASE_VADDR)
++#define AF_GET_PCR		__raw_readl(AF_IOBASE_VADDR + AFPCR)
++#define AF_GETINTSTAT		__raw_readl(AF_INTSTATBASE)
++
++/* Function declaration */
++int af_register_setup(struct af_device *);
++void af_engine_setup(int);
++void af_set_address(unsigned long);
++#endif
++#endif
+--- /dev/null
++++ b/drivers/char/dm355_ipipe.c
+@@ -0,0 +1,2387 @@
++/*
++ * Copyright (C) 2005-2008 Texas Instruments Inc
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
++ */
++//#include <linux/config.h>
++#include <linux/module.h>
++#include <linux/init.h>
++#include <linux/string.h>
++#include <linux/kernel.h>
++#include <linux/slab.h>
++#include <linux/fs.h>
++#include <linux/errno.h>
++#include <linux/types.h>
++#include <linux/cdev.h>
++#include <linux/dma-mapping.h>
++#include <linux/interrupt.h>
++#include <linux/uaccess.h>
++#include <linux/mutex.h>
++#include <linux/device.h>
++#include <linux/videodev2.h>
++#include <media/davinci/dm355_ipipe.h>
++#include <media/davinci/imp_hw_if.h>
++#include <media/davinci/vpss.h>
++
++#include <mach/irqs.h>
++
++#include "dm355_ipipe_hw.h"
++#include "dm355_def_para.h"
++
++/* IPIPE module operation state */
++struct ipipe_oper_state {
++	/* Operation state in continuous mode */
++	unsigned int state;
++	/* Semaphore to protect the common hardware configuration */
++	struct mutex lock;
++	/* previewer config state */
++	unsigned int prev_config_state;
++	/* Shared configuration of the hardware */
++	struct ipipe_params *shared_config_param;
++	/* shared resource in use */
++	unsigned int resource_in_use;
++	/* resizer config state */
++	unsigned int rsz_config_state;
++	/* resizer chained with previewer */
++	unsigned int rsz_chained;
++	/* CCDC API related variables */
++	/* Buffer type, interleaved or field seperated for interlaced
++	 * scan
++	 */
++	unsigned int buffer_type;
++	/* frame format, 0 - interlaced, 1 - progressive */
++	unsigned int frame_format;
++	/* input pixel format */
++	enum imp_pix_formats in_pixel_format;
++	/* input pixel format */
++	enum imp_pix_formats out_pixel_format;
++};
++
++/* Operation mode of image processor (imp) */
++static u32 oper_mode = IMP_MODE_SINGLE_SHOT;
++module_param(oper_mode, uint, S_IRUGO);
++/* enable or disable serializer */
++static u32 en_serializer;
++module_param(en_serializer, uint, S_IRUGO);
++
++/* ipipe module operation state & configuration */
++static struct ipipe_oper_state oper_state;
++
++/* Pre-filter data */
++static struct prev_prefilter pf;
++static int validate_pf_params(struct device *dev);
++static int set_pf_params(struct device *dev, void *param, int len);
++static int get_pf_params(struct device *dev, void *param, int len);
++
++/* Defect pixel correction data */
++static struct prev_dfc dfc;
++static int validate_dfc_params(struct device *dev);
++static int set_dfc_params(struct device *dev, void *param, int len);
++static int get_dfc_params(struct device *dev, void *param, int len);
++
++/* Noise filter */
++static struct prev_nf nf;
++static int validate_nf_params(struct device *dev);
++static int set_nf_params(struct device *dev, void *param, int len);
++static int get_nf_params(struct device *dev, void *param, int len);
++
++/* White Balance */
++static struct prev_wb wb;
++static int validate_wb_params(struct device *dev);
++static int set_wb_params(struct device *dev, void *param, int len);
++static int get_wb_params(struct device *dev, void *param, int len);
++
++/* RGB2RGB conversion */
++static struct prev_rgb2rgb rgb2rgb;
++static int validate_rgb2rgb_params(struct device *dev);
++static int set_rgb2rgb_params(struct device *dev, void *param, int len);
++static int get_rgb2rgb_params(struct device *dev, void *param, int len);
++
++/* Gamma correction */
++static struct prev_gamma gamma;
++static int validate_gamma_params(struct device *dev);
++static int set_gamma_params(struct device *dev, void *param, int len);
++static int get_gamma_params(struct device *dev, void *param, int len);
++
++/* RGB2YUV conversion */
++static struct prev_rgb2yuv rgb2yuv;
++static int validate_rgb2yuv_params(struct device *dev);
++static int set_rgb2yuv_params(struct device *dev, void *param, int len);
++static int get_rgb2yuv_params(struct device *dev, void *param, int len);
++
++/* Lumina Adjustment */
++static struct prev_lum_adj lum_adj;
++static int validate_lum_adj_params(struct device *dev);
++static int set_lum_adj_params(struct device *dev, void *param, int len);
++static int get_lum_adj_params(struct device *dev, void *param, int len);
++
++/* YUV 422 conversion */
++static struct prev_yuv422_conv yuv422_conv;
++static int validate_yuv422_conv_params(struct device *dev);
++static int set_yuv422_conv_params(struct device *dev, void *param, int len);
++static int get_yuv422_conv_params(struct device *dev, void *param, int len);
++
++/* Edge Enhancement */
++static struct prev_yee yee;
++static int validate_yee_params(struct device *dev);
++static int set_yee_params(struct device *dev, void *param, int len);
++static int get_yee_params(struct device *dev, void *param, int len);
++
++/* False Color Suppression */
++static struct prev_fcs fcs;
++static int validate_fcs_params(struct device *dev);
++static int set_fcs_params(struct device *dev, void *param, int len);
++static int get_fcs_params(struct device *dev, void *param, int len);
++
++/* Tables for various tuning modules */
++struct ipipe_dfc_entry ipipe_dfc_table[MAX_SIZE_DFC];
++struct ipipe_gamma_entry ipipe_gamma_table_r[MAX_SIZE_GAMMA];
++struct ipipe_gamma_entry ipipe_gamma_table_b[MAX_SIZE_GAMMA];
++struct ipipe_gamma_entry ipipe_gamma_table_g[MAX_SIZE_GAMMA];
++struct ipipe_gamma_entry ipipe_gamma_table_all[MAX_SIZE_GAMMA];
++short ipipe_yee_table[MAX_SIZE_EEC];
++
++static struct prev_module_if prev_modules[PREV_MAX_MODULES] = {
++	{
++		.version = "3.1",
++		.module_id = PREV_PRE_FILTER,
++		.module_name = "Pre-filter",
++		.control = 0,
++		.path = (IMP_RAW2RAW | IMP_RAW2YUV),
++		.set = set_pf_params,
++		.get = get_pf_params
++	},
++	{
++		.version = "3.1",
++		.module_id = PREV_DFC,
++		.module_name = "Defect correction",
++		.control = 0,
++		.path = IMP_RAW2RAW | IMP_RAW2YUV,
++		.set = set_dfc_params,
++		.get = get_dfc_params
++	},
++	{
++		.version = "3.1",
++		.module_id = PREV_NF,
++		.module_name = "2-D Noise filter",
++		.control = 0,
++		.path = IMP_RAW2RAW | IMP_RAW2YUV,
++		.set = set_nf_params,
++		.get = get_nf_params
++	},
++	{
++		.version = "3.1",
++		.module_id = PREV_WB,
++		.module_name = "White balance",
++		.control = 0,
++		.path = IMP_RAW2RAW | IMP_RAW2YUV,
++		.set = set_wb_params,
++		.get = get_wb_params
++	},
++	{
++		.version = "3.1",
++		.module_id = PREV_RGB2RGB,
++		.module_name = "RGB-RGB Conversion",
++		.control = 0,
++		.path = IMP_RAW2YUV,
++		.set = set_rgb2rgb_params,
++		.get = get_rgb2rgb_params
++	},
++	{
++		.version = "3.1",
++		.module_id = PREV_GAMMA,
++		.module_name = "Gamma Correction",
++		.control = 0,
++		.path = IMP_RAW2YUV,
++		.set = set_gamma_params,
++		.get = get_gamma_params
++	},
++	{
++		.version = "3.1",
++		.module_id = PREV_RGB2YUV,
++		.module_name = "RGB-YCbCr conversion",
++		.control = 0,
++		.path = IMP_RAW2YUV,
++		.set = set_rgb2yuv_params,
++		.get = get_rgb2yuv_params
++	},
++	{
++		.version = "3.1",
++		.module_id = PREV_LUM_ADJ,
++		.module_name = "Luminance Adjustment",
++		.control = 1,
++		.path = IMP_RAW2YUV,
++		.set = set_lum_adj_params,
++		.get = get_lum_adj_params
++	},
++	{
++		.version = "3.1",
++		.module_id = PREV_YUV422_CONV,
++		.module_name = "YUV 422 conversion",
++		.control = 0,
++		.path = IMP_RAW2YUV,
++		.set = set_yuv422_conv_params,
++		.get = get_yuv422_conv_params
++	},
++	{
++		.version = "3.1",
++		.module_id = PREV_YEE,
++		.module_name = "Edge Enhancer",
++		.control = 1,
++		.path = IMP_YUV2YUV,
++		.set = set_yee_params,
++		.get = get_yee_params
++	},
++	{
++		.version = "3.1",
++		.module_id = PREV_FCS,
++		.module_name = "False Color Suppression",
++		.control = 1,
++		.path = IMP_YUV2YUV,
++		.set = set_fcs_params,
++		.get = get_fcs_params
++	}
++};
++
++/* function prototypes */
++static struct prev_module_if *prev_enum_preview_cap(struct device *dev,
++						    int index);
++static unsigned int prev_get_oper_mode(void);
++static unsigned int ipipe_get_oper_state(void);
++static void ipipe_set_oper_state(unsigned int state);
++static unsigned int ipipe_rsz_chain_state(void);
++static void *ipipe_alloc_config_block(struct device *dev, int shared);
++static void ipipe_dealloc_config_block(struct device *dev, void *config_block);
++static void ipipe_set_user_config_defaults(struct device *dev,
++					   enum imp_log_chan_t chan_type,
++					   unsigned int oper_mode,
++					   void *config);
++static int ipipe_set_preview_config(struct device *dev,
++				    unsigned int oper_mode,
++				    void *user_config, void *config);
++static int ipipe_set_resize_config(struct device *dev, unsigned int oper_mode,
++				   int resizer_chained,
++				   void *user_config, void *config);
++
++static void ipipe_enable(unsigned char en, void *config);
++static void ipipe_get_irq(struct irq_numbers *irq);
++static unsigned int ipipe_get_rsz_config_state(void);
++static int ipipe_do_hw_setup(struct device *dev, void *config);
++static unsigned int ipipe_get_prev_config_state(void);
++static void ipipe_lock_chain(void);
++static void ipipe_unlock_chain(void);
++static void ipipe_dealloc_user_config_block(struct device *dev,
++					    void *config_block);
++static void *ipipe_alloc_user_config_block(struct device *dev,
++					   enum imp_log_chan_t chan_type,
++					   unsigned int oper_mode, int *len);
++static int ipipe_update_outbuf1_address(void *config, unsigned int address);
++static int ipipe_update_outbuf2_address(void *config, unsigned int address);
++static int ipipe_set_ipipe_if_address(void *config, unsigned int address);
++
++/* IPIPE hardware limits */
++#define IPIPE_MAX_OUTPUT_WIDTH_A	1344
++#define IPIPE_MAX_OUTPUT_WIDTH_B	640
++
++/* Based on max resolution supported. QXGA */
++#define IPIPE_MAX_OUTPUT_HEIGHT_A	1536
++/* Based on max resolution supported. VGA */
++#define IPIPE_MAX_OUTPUT_HEIGHT_B	480
++#define RSZ_A	0
++#define RSZ_B	1
++
++/* Raw YUV formats */
++static u32 ipipe_raw_yuv_pix_formats[] =
++                {V4L2_PIX_FMT_UYVY};
++
++
++static int ipipe_enum_pix(u32 *pix, int i)
++{
++	if (i >= ARRAY_SIZE(ipipe_raw_yuv_pix_formats))
++		return -EINVAL;
++
++	*pix = ipipe_raw_yuv_pix_formats[i];
++	return 0;
++}
++static int ipipe_get_max_output_width(int rsz)
++{
++	if (rsz == RSZ_A)
++		return IPIPE_MAX_OUTPUT_WIDTH_A;
++	return IPIPE_MAX_OUTPUT_WIDTH_B;
++}
++
++static int ipipe_get_max_output_height(int rsz)
++{
++	if (rsz == RSZ_A)
++		return IPIPE_MAX_OUTPUT_HEIGHT_A;
++	return IPIPE_MAX_OUTPUT_HEIGHT_B;
++}
++
++static int ipipe_serialize(void)
++{
++	return en_serializer;
++}
++
++static void ipipe_dump_hw_config(void);
++/* APIs for CCDC driver */
++static int ipipe_set_input_win(struct imp_window *);
++static int ipipe_get_input_win(struct imp_window *);
++static int ipipe_set_in_pixel_format(enum imp_pix_formats);
++static int ipipe_set_out_pixel_format(enum imp_pix_formats);
++static int ipipe_set_buftype(unsigned char);
++static int ipipe_set_frame_format(unsigned char);
++static int ipipe_set_output_win(struct imp_window *win);
++static int ipipe_get_output_state(unsigned char out_sel);
++static int ipipe_get_line_length(unsigned char out_sel);
++static int ipipe_get_image_height(unsigned char out_sel);
++
++static struct imp_hw_interface dm355_ipipe_interface = {
++	.name = "DM355 IPIPE",
++	.owner = THIS_MODULE,
++	.prev_enum_modules = prev_enum_preview_cap,
++	.get_preview_oper_mode = prev_get_oper_mode,
++	.get_resize_oper_mode = prev_get_oper_mode,
++	.get_hw_state = ipipe_get_oper_state,
++	.set_hw_state = ipipe_set_oper_state,
++	.resizer_chain = ipipe_rsz_chain_state,
++	.lock_chain = ipipe_lock_chain,
++	.unlock_chain = ipipe_unlock_chain,
++	.serialize = ipipe_serialize,
++	.alloc_config_block = ipipe_alloc_config_block,
++	.dealloc_config_block = ipipe_dealloc_config_block,
++	.alloc_user_config_block = ipipe_alloc_user_config_block,
++	.dealloc_config_block = ipipe_dealloc_user_config_block,
++	.set_user_config_defaults = ipipe_set_user_config_defaults,
++	.set_preview_config = ipipe_set_preview_config,
++	.set_resizer_config = ipipe_set_resize_config,
++	.update_inbuf_address = ipipe_set_ipipe_if_address,
++	.update_outbuf1_address = ipipe_update_outbuf1_address,
++	.update_outbuf2_address = ipipe_update_outbuf2_address,
++	.enable = ipipe_enable,
++	.hw_setup = ipipe_do_hw_setup,
++	.get_preview_irq = ipipe_get_irq,
++	.get_rsz_irq = ipipe_get_irq,
++	.get_resizer_config_state = ipipe_get_rsz_config_state,
++	.get_previewer_config_state = ipipe_get_prev_config_state,
++	/* Below used by CCDC driver to set input and output params */
++	.set_input_win = ipipe_set_input_win,
++	.get_input_win = ipipe_get_input_win,
++	.set_in_pixel_format = ipipe_set_in_pixel_format,
++	.set_out_pixel_format = ipipe_set_out_pixel_format,
++	.set_buftype = ipipe_set_buftype,
++	.set_frame_format = ipipe_set_frame_format,
++	.set_output_win = ipipe_set_output_win,
++	.get_output_state = ipipe_get_output_state,
++	.get_line_length = ipipe_get_line_length,
++	.get_image_height = ipipe_get_image_height,
++	.get_max_output_width = ipipe_get_max_output_width,
++	.get_max_output_height = ipipe_get_max_output_height,
++	.enum_pix = ipipe_enum_pix,
++	/* debug function */
++	.dump_hw_config = ipipe_dump_hw_config,
++};
++
++static int ipipe_set_ipipe_if_address(void *config, unsigned int address)
++{
++	return (ipipe_set_ipipeif_address
++		((struct ipipe_params *)config, address));
++}
++
++static void ipipe_lock_chain(void)
++{
++	mutex_lock(&oper_state.lock);
++	oper_state.resource_in_use = 1;
++	mutex_unlock(&oper_state.lock);
++}
++
++static void ipipe_unlock_chain(void)
++{
++	mutex_lock(&oper_state.lock);
++	oper_state.resource_in_use = 0;
++	oper_state.prev_config_state = STATE_NOT_CONFIGURED;
++	oper_state.rsz_config_state = STATE_NOT_CONFIGURED;
++	oper_state.rsz_chained = 0;
++	mutex_unlock(&oper_state.lock);
++}
++static int ipipe_process_pix_fmts(enum ipipe_pix_formats in_pix_fmt,
++				  enum ipipe_pix_formats out_pix_fmt,
++				  struct ipipe_params *param)
++{
++	enum ipipe_pix_formats temp_pix_fmt;
++	char packed = 0, a_law = 0;
++
++	if (in_pix_fmt == IPIPE_BAYER_8BIT_PACK) {
++		temp_pix_fmt = IPIPE_BAYER;
++		packed = 1;
++	} else if (in_pix_fmt == IPIPE_BAYER_8BIT_PACK_ALAW) {
++		packed = 1;
++		a_law = 1;
++		temp_pix_fmt = IPIPE_BAYER;
++	} else if (in_pix_fmt == IPIPE_BAYER)
++		temp_pix_fmt = IPIPE_BAYER;
++	else if (in_pix_fmt == IPIPE_UYVY)
++		temp_pix_fmt = IPIPE_UYVY;
++	else
++		return -1;
++
++	if (temp_pix_fmt == IPIPE_BAYER)
++		if (out_pix_fmt == IPIPE_BAYER)
++			param->ipipe_dpaths_fmt = IPIPE_RAW2RAW;
++		else if (out_pix_fmt == IPIPE_UYVY)
++			param->ipipe_dpaths_fmt = IPIPE_RAW2YUV;
++		else
++			return -1;
++	else if ((temp_pix_fmt == IPIPE_UYVY) && (out_pix_fmt == IPIPE_UYVY))
++		param->ipipe_dpaths_fmt = IPIPE_YUV2YUV;
++	else
++		return -1;
++	if (packed)
++		param->ipipeif_param.pack_mode = EIGHT_BIT;
++	if (a_law)
++		param->ipipeif_param.ialaw = ALAW_ON;
++	return 0;
++}
++
++static int ipipe_do_hw_setup(struct device *dev, void *config)
++{
++	struct ipipe_params *param = (struct ipipe_params *)config;
++	int ret = 0;
++
++	dev_dbg(dev, "ipipe_do_hw_setup\n");
++	ret = mutex_lock_interruptible(&oper_state.lock);
++	if (ret)
++		return ret;
++	if ((ISNULL(config)) && (oper_mode == IMP_MODE_CONTINUOUS)) {
++		param = oper_state.shared_config_param;
++		/* continuous mode setup */
++		ipipe_process_pix_fmts(oper_state.in_pixel_format,
++				       oper_state.out_pixel_format,
++				       param);
++		param->rsz_rsc_param[0].rsz_h_dif =
++		    ((param->ipipe_hsz + 1) * 256) /
++		    (param->rsz_rsc_param[0].rsz_o_hsz + 1);
++		param->rsz_rsc_param[0].rsz_v_dif =
++		    ((param->ipipe_vsz + 1) * 256) /
++		    (param->rsz_rsc_param[0].rsz_o_vsz + 1);
++	}
++	ret = ipipe_hw_setup(param);
++	mutex_unlock(&oper_state.lock);
++	return ret;
++}
++static void ipipe_get_irq(struct irq_numbers *irq)
++{
++	irq->sdram = IRQ_DM355_IPIPE_SDR;
++	irq->update = -1;
++}
++
++static unsigned int ipipe_rsz_chain_state(void)
++{
++	return oper_state.rsz_chained;
++}
++
++#define CHECKRANGE(val, val1, val2) \
++	{ if (val < val1 || val > val2) \
++		return -1; }
++
++#define CHECKMORE(val, val1) \
++	{ if (val > val1) \
++		 return -1; }
++
++static int validate_pf_params(struct device *dev)
++{
++	CHECKMORE((pf.en), 1);
++	if (pf.en) {
++		CHECKMORE((pf.en_adapt_prefilter), 1);
++		CHECKMORE((pf.en_adapt_dotred), 1);
++		CHECKMORE((pf.pre_gain), 255);
++		CHECKMORE((pf.pre_shf), 15);
++		CHECKMORE((pf.pre_thr_g), 0x3fff);
++		CHECKMORE((pf.pre_thr_b), 0x3fff);
++		CHECKMORE((pf.pre_thr_1), 0x3fff);
++	}
++	return 0;
++}
++
++static int ipipe_update_outbuf1_address(void *config, unsigned int address)
++{
++	if ((ISNULL(config)) && (oper_mode == IMP_MODE_CONTINUOUS))
++		return (ipipe_set_resizer_address
++			(oper_state.shared_config_param, 0, address));
++	return (ipipe_set_resizer_address
++		((struct ipipe_params *)config, 0, address));
++}
++
++static int ipipe_update_outbuf2_address(void *config, unsigned int address)
++{
++	if ((ISNULL(config)) && (oper_mode == IMP_MODE_CONTINUOUS))
++		return (ipipe_set_resizer_address
++			(oper_state.shared_config_param, 1, address));
++	return (ipipe_set_resizer_address
++		((struct ipipe_params *)config, 1, address));
++}
++
++static void ipipe_enable(unsigned char en, void *config)
++{
++	unsigned char val = 0;
++
++	printk(KERN_DEBUG "ipipe_enable - begin, en = %d\n", val);
++	if (en)
++		val = 1;
++	if (en) {
++		//regw_vpss(0x79, VPSS_CLK);
++		
++		regw_ip(0xff, IRQ_EN);
++	} else
++		regw_ip(0x0, IRQ_EN);
++
++	if (oper_mode == IMP_MODE_CONTINUOUS) {
++		// TODO call vpss api here
++		vpss_enable_clock(VPSS_IPIPE_CLOCK, 1);
++		//while (regr_vpss(VPSS_PCR) & 4);
++		regw_if(val, IPIPEIF_ENABLE);
++		if (oper_state.shared_config_param->rsz_en[0])
++			rsz_enable(0, en);
++		if (oper_state.shared_config_param->rsz_en[1])
++			rsz_enable(1, en);
++		regw_ip(val, IPIPE_EN);
++	} else {
++		while (regr_ip(IPIPE_EN));
++		regw_ip(val, IPIPE_EN);
++
++		while (regr_if(IPIPEIF_ENABLE));
++		regw_if(val, IPIPEIF_ENABLE);
++	}
++	printk(KERN_DEBUG "ipipe_enable-end, en = %d\n", val);
++}
++static int set_pf_params(struct device *dev, void *param, int len)
++{
++	struct prev_prefilter *pf_param = (struct prev_prefilter *)param;
++
++	if (ISNULL(pf_param))
++		/* Copy defaults for pf */
++		memcpy((void *)&pf,
++			(void *)&dm355_pf_defaults,
++			sizeof(struct prev_prefilter));
++	else {
++		if (copy_from_user(&pf,
++			(struct prev_prefilter *)pf_param,
++			sizeof(struct prev_prefilter))) {
++			dev_err(dev,
++				"set_pf_params: Error in copy to kernel\n");
++			return -EFAULT;
++		}
++		if (validate_pf_params(dev) < 0)
++			return -EINVAL;
++	}
++
++	/* Now set the values in the hw */
++	return (ipipe_set_pf_regs(&pf));
++}
++static int get_pf_params(struct device *dev, void *param, int len)
++{
++	struct prev_prefilter *pf_param = (struct prev_prefilter *)param;
++
++	if (copy_to_user((struct prev_prefilter *)pf_param,
++		&pf,
++		sizeof(struct prev_prefilter))) {
++		dev_err(dev, "get_pf_params: Error in copy from kernel\n");
++		return -EFAULT;
++	}
++	return 0;
++}
++
++static int validate_dfc_params(struct device *dev)
++{
++	int i;
++
++	CHECKMORE(dfc.en, 1);
++	if (dfc.en) {
++		CHECKRANGE((dfc.dfc_size), 1, MAX_SIZE_DFC);
++		if ((dfc.en) && (ISNULL(dfc.table)))
++			return -1;
++		for (i = 0; i < dfc.dfc_size; i++) {
++			CHECKMORE((dfc.table[i].horz_pos), 0xfff);
++			CHECKMORE((dfc.table[i].vert_pos), 0xfff);
++		}
++	}
++	return 0;
++}
++
++static int set_dfc_params(struct device *dev, void *param, int len)
++{
++	struct prev_dfc dfc_param;
++	struct ipipe_dfc_entry *temp;
++
++	if (ISNULL(param)) {
++		/* Copy defaults for dfc */
++		temp = dfc.table;
++		memcpy((void *)&dfc,
++			(void *)&dm355_dfc_defaults,
++			sizeof(struct prev_dfc));
++		dfc.table = temp;
++	} else {
++		if (copy_from_user(&dfc_param,
++			(struct prev_dfc *)param,
++			sizeof(struct prev_dfc))) {
++			dev_err(dev,
++				"set_dfc_params: Error in copy to kernel\n");
++			return -EFAULT;
++		}
++
++		dfc.dfc_size = dfc_param.dfc_size;
++		dfc.en = dfc_param.en;
++		if (dfc.en) {
++			dfc.vert_copy_method = dfc_param.vert_copy_method;
++			if (copy_from_user(dfc.table,
++				(struct ipipe_dfc_entry *)dfc_param.table,
++				(dfc.dfc_size *
++				sizeof(struct ipipe_dfc_entry)))) {
++				dev_err(dev,
++					"set_dfc_params: Error in copying "
++					"dfc table to kernel\n");
++				return -EFAULT;
++			}
++			if (validate_dfc_params(dev) < 0)
++				return -EINVAL;
++		}
++	}
++	return (ipipe_set_dfc_regs(&dfc));
++}
++
++static int get_dfc_params(struct device *dev, void *param, int len)
++{
++	struct prev_dfc user_dfc;
++	struct prev_dfc *dfc_param = (struct prev_dfc *)param;
++
++	/* First copy to temp since we need to preserve the dfc table ptr */
++	if (copy_from_user(&user_dfc,
++		dfc_param, sizeof(struct prev_dfc))) {
++		dev_err(dev, "get_dfc_params: Error in copy to kernel\n");
++		return -EFAULT;
++	}
++	user_dfc.en = dfc.en;
++	if (dfc.en) {
++		user_dfc.vert_copy_method = dfc.vert_copy_method;
++		user_dfc.dfc_size = dfc.dfc_size;
++		if (ISNULL(user_dfc.table)) {
++			dev_err(dev,
++				"get_dfc_params:dfc table ptr is null."
++				" Allocate for max entry\n");
++			return -EINVAL;
++		}
++		if (copy_to_user(user_dfc.table,
++			dfc.table,
++			(user_dfc.dfc_size *
++			sizeof(struct ipipe_dfc_entry)))) {
++			dev_err(dev,
++				"get_dfc_params: Error in copy dfc table"
++				" to user\n");
++			return -EFAULT;
++		}
++	}
++	if (copy_to_user(dfc_param,
++		&user_dfc,
++		sizeof(struct prev_dfc))) {
++		dev_err(dev, "get_dfc_params: Error in copy to user\n");
++		return -EFAULT;
++	}
++	return 0;
++}
++
++static int validate_nf_params(struct device *dev)
++{
++	int i;
++
++	CHECKMORE((nf.en), 1);
++	if (nf.en) {
++		CHECKMORE((nf.shft_val), 3);
++		CHECKMORE((nf.spread_val), 3);
++		for (i = 0; i < IPIPE_NF_THR_TABLE_SIZE; i++)
++			CHECKMORE((nf.thr[i]), 0xfff);
++		for (i = 0; i < IPIPE_NF_STR_TABLE_SIZE; i++)
++			CHECKMORE((nf.str[i]), 31);
++	}
++	return 0;
++}
++
++static int set_nf_params(struct device *dev, void *param, int len)
++{
++	struct prev_nf *nf_param = (struct prev_nf *)param;
++
++	if (ISNULL(nf_param)) {
++		/* Copy defaults for nf */
++		memcpy((void *)&nf,
++		       (void *)&dm355_nf_defaults,
++			sizeof(struct prev_nf));
++		memset((void *)nf.thr, 0, IPIPE_NF_THR_TABLE_SIZE);
++		memset((void *)nf.str, 0, IPIPE_NF_THR_TABLE_SIZE);
++	} else {
++
++		if (copy_from_user(&nf,
++			nf_param,
++			sizeof(struct prev_nf))) {
++			dev_err(dev,
++				"set_nf_params: Error in copy to kernel\n");
++			return -EFAULT;
++		}
++		if (validate_nf_params(dev) < 0)
++			return -EINVAL;
++	}
++	/* Now set the values in the hw */
++	return (ipipe_set_d2f_nf_regs(&nf));
++}
++static int get_nf_params(struct device *dev, void *param, int len)
++{
++	struct prev_nf *nf_param = (struct prev_nf *)param;
++
++	if (copy_to_user((struct prev_nf *)nf_param,
++		&nf,
++		sizeof(struct prev_nf))) {
++		dev_err(dev, "get_nf_params: Error in copy from kernel\n");
++		return -EFAULT;
++	}
++	return 0;
++}
++
++static int validate_wb_params(struct device *dev)
++{
++	/* U10Q8 */
++	CHECKMORE((wb.dgn.integer), 3);
++	CHECKMORE((wb.dgn.decimal), 255);
++	/* U10Q7 */
++	CHECKMORE((wb.gain_r.integer), 7);
++	CHECKMORE((wb.gain_r.decimal), 127);
++	CHECKMORE((wb.gain_gr.integer), 7);
++	CHECKMORE((wb.gain_gr.decimal), 127);
++	CHECKMORE((wb.gain_gb.integer), 7);
++	CHECKMORE((wb.gain_gb.decimal), 127);
++	CHECKMORE((wb.gain_b.integer), 7);
++	CHECKMORE((wb.gain_b.decimal), 127);
++	return 0;
++}
++static int set_wb_params(struct device *dev, void *param, int len)
++{
++	struct prev_wb *wb_param = (struct prev_wb *)param;
++
++	dev_dbg(dev, "set_wb_params");
++	if (ISNULL(wb_param))
++		/* Copy defaults for wb */
++		memcpy((void *)&wb,
++			(void *)&dm355_wb_defaults,
++			sizeof(struct prev_wb));
++	else {
++		if (copy_from_user(&wb,
++			wb_param,
++			sizeof(struct prev_wb))) {
++			dev_err(dev,
++				"set_wb_params: Error in copy to kernel\n");
++			return -EFAULT;
++		}
++		if (validate_wb_params(dev) < 0)
++			return -EINVAL;
++	}
++
++	/* Now set the values in the hw */
++	return (ipipe_set_wb_regs(&wb));
++}
++static int get_wb_params(struct device *dev, void *param, int len)
++{
++	struct prev_wb *wb_param = (struct prev_wb *)param;
++
++	dev_dbg(dev, "get_wb_params\n");
++	if (copy_to_user((struct prev_wb *)wb_param,
++		&wb,
++		sizeof(struct prev_wb))) {
++		dev_err(dev, "get_wb_params: Error in copy from kernel\n");
++		return -EFAULT;
++	}
++	return 0;
++}
++
++static int validate_rgb2rgb_params(struct device *dev)
++{
++	CHECKMORE((rgb2rgb.coef_rr.decimal), 0xff);
++	CHECKMORE((rgb2rgb.coef_rr.integer), 0xf);
++	CHECKMORE((rgb2rgb.coef_gr.decimal), 0xff);
++	CHECKMORE((rgb2rgb.coef_gr.integer), 0xf);
++	CHECKMORE((rgb2rgb.coef_br.decimal), 0xff);
++	CHECKMORE((rgb2rgb.coef_br.integer), 0xf);
++	CHECKMORE((rgb2rgb.coef_rg.decimal), 0xff);
++	CHECKMORE((rgb2rgb.coef_rg.integer), 0xf);
++	CHECKMORE((rgb2rgb.coef_gg.decimal), 0xff);
++	CHECKMORE((rgb2rgb.coef_gg.integer), 0xf);
++	CHECKMORE((rgb2rgb.coef_bg.decimal), 0xff);
++	CHECKMORE((rgb2rgb.coef_bg.integer), 0xf);
++	CHECKMORE((rgb2rgb.coef_rb.decimal), 0xff);
++	CHECKMORE((rgb2rgb.coef_rb.integer), 0xf);
++	CHECKMORE((rgb2rgb.coef_gb.decimal), 0xff);
++	CHECKMORE((rgb2rgb.coef_gb.integer), 0xf);
++	CHECKMORE((rgb2rgb.coef_bb.decimal), 0xff);
++	CHECKMORE((rgb2rgb.coef_bb.integer), 0xf);
++	/* S14Q0 */
++	CHECKMORE((rgb2rgb.out_ofst_r), 0x3fff);
++	CHECKMORE((rgb2rgb.out_ofst_g), 0x3fff);
++	CHECKMORE((rgb2rgb.out_ofst_b), 0x3fff);
++	return 0;
++}
++static int set_rgb2rgb_params(struct device *dev, void *param, int len)
++{
++	struct prev_rgb2rgb *rgb2rgb_param = (struct prev_rgb2rgb *)param;
++
++	if (ISNULL(rgb2rgb_param))
++		/* Copy defaults for rgb2rgb conversion */
++		memcpy((void *)&rgb2rgb,
++		       (void *)&dm355_rgb2rgb_defaults,
++		       sizeof(struct prev_rgb2rgb));
++	else {
++		if (copy_from_user(&rgb2rgb,
++			rgb2rgb_param,
++			sizeof(struct prev_rgb2rgb))) {
++			dev_err(dev,
++				"set_rgb2rgb_params: Error in "
++				"copy to kernel\n");
++			return -EFAULT;
++		}
++		if (validate_rgb2rgb_params(dev) < 0)
++			return -EINVAL;
++	}
++	return (ipipe_set_rgb2rgb_regs(&rgb2rgb));
++}
++static int get_rgb2rgb_params(struct device *dev, void *param, int len)
++{
++	struct prev_rgb2rgb *rgb2rgb_param = (struct prev_rgb2rgb *)param;
++	if (copy_to_user((struct prev_rgb2rgb *)rgb2rgb_param,
++		&rgb2rgb,
++		sizeof(struct prev_rgb2rgb))) {
++		dev_err(dev, "get_rgb2rgb_params: Error in copy to user\n");
++		return -EFAULT;
++	}
++	return 0;
++}
++
++static int validate_gamma_params(struct device *dev)
++{
++	int table_size = 0, i;
++
++	CHECKMORE((gamma.bypass_r), 1);
++	CHECKMORE((gamma.bypass_b), 1);
++	CHECKMORE((gamma.bypass_g), 1);
++	if (gamma.tbl_sel == IPIPE_GAMMA_TBL_RAM) {
++		if (gamma.tbl_size == IPIPE_GAMMA_TBL_SZ_128)
++			table_size = 128;
++		else if (gamma.tbl_size == IPIPE_GAMMA_TBL_SZ_256)
++			table_size = 256;
++		else if (gamma.tbl_size == IPIPE_GAMMA_TBL_SZ_512)
++			table_size = 512;
++		if (!gamma.bypass_r) {
++			if (ISNULL(gamma.table_r))
++				return -1;
++			else {
++				for (i = 0; i < table_size; i++) {
++					CHECKMORE((gamma.table_r[i].
++						    slope), 0x3ff);
++					CHECKMORE((gamma.table_r[i].
++						    offset), 0x3ff);
++				}
++			}
++		}
++		if (!gamma.bypass_b) {
++			if (ISNULL(gamma.table_b))
++				return -1;
++			else {
++				for (i = 0; i < table_size; i++) {
++					CHECKMORE((gamma.table_b[i].
++						    slope), 0x3ff);
++					CHECKMORE((gamma.table_b[i].
++						    offset), 0x3ff);
++				}
++			}
++		}
++		if (!gamma.bypass_g) {
++			if (ISNULL(gamma.table_g))
++				return -1;
++			else {
++				for (i = 0; i < table_size; i++) {
++					CHECKMORE((gamma.table_g[i].
++						    slope), 0x3ff);
++					CHECKMORE((gamma.table_g[i].
++						    offset), 0x3ff);
++				}
++			}
++		}
++		if (!(ISNULL(gamma.table_rgb_all))) {
++			for (i = 0; i < table_size; i++) {
++				CHECKMORE((gamma.table_g[i].slope),
++						0x3ff);
++				CHECKMORE((gamma.table_g[i].offset),
++					   0x3ff);
++			}
++		}
++	}
++	return 0;
++}
++static int set_gamma_params(struct device *dev, void *param, int len)
++{
++	int table_size = 0;
++	struct prev_gamma user_gamma;
++	struct prev_gamma *gamma_param = (struct prev_gamma *)param;
++
++	if (ISNULL(gamma_param)) {
++		/* Copy defaults for gamma */
++		gamma.bypass_r = dm355_gamma_defaults.bypass_r;
++		gamma.bypass_g = dm355_gamma_defaults.bypass_g;
++		gamma.bypass_b = dm355_gamma_defaults.bypass_b;
++		gamma.tbl_sel = dm355_gamma_defaults.tbl_sel;
++		gamma.tbl_size = dm355_gamma_defaults.tbl_size;
++		/* By default, we bypass the gamma correction.
++		   So no values by default for tables
++		 */
++	} else {
++		if (copy_from_user(&user_gamma,
++			gamma_param,
++			sizeof(struct prev_gamma))) {
++			dev_err(dev,
++				"set_gamma_params: Error in copy to kernel\n");
++			return -EFAULT;
++		}
++		gamma.bypass_r = user_gamma.bypass_r;
++		gamma.bypass_b = user_gamma.bypass_b;
++		gamma.bypass_g = user_gamma.bypass_g;
++		gamma.tbl_sel = user_gamma.tbl_sel;
++		gamma.tbl_size = user_gamma.tbl_size;
++
++		if (user_gamma.tbl_sel == IPIPE_GAMMA_TBL_RAM) {
++			if (user_gamma.tbl_size == IPIPE_GAMMA_TBL_SZ_128)
++				table_size = 128;
++			else if (user_gamma.tbl_size == IPIPE_GAMMA_TBL_SZ_256)
++				table_size = 256;
++			else if (user_gamma.tbl_size == IPIPE_GAMMA_TBL_SZ_512)
++				table_size = 512;
++			else {
++				dev_err(dev,
++					"set_gamma_params: Invalid"
++					" table_size\n");
++				return -EINVAL;
++			}
++
++			if (!user_gamma.bypass_r) {
++				if (copy_from_user(gamma.table_r,
++					user_gamma.table_r,
++					(table_size *
++					sizeof(struct ipipe_gamma_entry)))) {
++					dev_err(dev,
++						"set_gamma_params: R-Error"
++						" in copy to kernel\n");
++					return -EFAULT;
++				}
++			}
++
++			if (!user_gamma.bypass_b) {
++				if (copy_from_user(gamma.table_b,
++					user_gamma.table_b,
++					(table_size *
++					sizeof(struct ipipe_gamma_entry)))) {
++					dev_err(dev,
++						"set_gamma_params: B-Error"
++						" in copy to kernel\n");
++					return -EFAULT;
++				}
++			}
++
++			if (!user_gamma.bypass_g) {
++				if (copy_from_user(gamma.table_g,
++					user_gamma.table_g,
++					(table_size *
++					sizeof(struct ipipe_gamma_entry)))) {
++					dev_err(dev,
++						"set_gamma_params: G-Error "
++						"in copy to kernel\n");
++					return -EFAULT;
++				}
++			}
++
++			if ((!ISNULL(user_gamma.table_rgb_all))) {
++				if (copy_from_user(gamma.table_rgb_all,
++					user_gamma.table_rgb_all,
++					(table_size *
++					sizeof(struct ipipe_gamma_entry)))) {
++					dev_err(dev,
++						"set_gamma_params: All-Error"
++						" in copy to kernel\n");
++					return -EFAULT;
++				}
++			}
++		}
++
++		if (validate_gamma_params(dev) < 0)
++			return -EINVAL;
++	}
++	return (ipipe_set_gamma_regs(&gamma));
++}
++static int get_gamma_params(struct device *dev, void *param, int len)
++{
++	int table_size = 0;
++	struct prev_gamma user_gamma;
++	struct prev_gamma *gamma_param = (struct prev_gamma *)param;
++
++	if (copy_from_user(&user_gamma,
++		gamma_param,
++		sizeof(struct prev_gamma))) {
++		dev_err(dev, "get_gamma_params: Error in copy to kernel\n");
++		return -EFAULT;
++	}
++
++	user_gamma.bypass_r = gamma.bypass_r;
++	user_gamma.bypass_g = gamma.bypass_g;
++	user_gamma.bypass_b = gamma.bypass_b;
++	user_gamma.tbl_sel = gamma.tbl_sel;
++	user_gamma.tbl_size = gamma.tbl_size;
++	if (gamma.tbl_sel == IPIPE_GAMMA_TBL_RAM) {
++		if (gamma.tbl_size == IPIPE_GAMMA_TBL_SZ_128)
++			table_size = 128;
++		else if (gamma.tbl_size == IPIPE_GAMMA_TBL_SZ_256)
++			table_size = 256;
++		else if (gamma.tbl_size == IPIPE_GAMMA_TBL_SZ_512)
++			table_size = 512;
++
++		if ((!gamma.bypass_r) && ((ISNULL(user_gamma.table_r)))) {
++			dev_err(dev,
++				"get_gamma_params: table ptr empty for R\n");
++			return -EINVAL;
++		} else {
++			if (copy_to_user(user_gamma.table_r,
++				gamma.table_r,
++				(table_size *
++				sizeof(struct ipipe_gamma_entry)))) {
++				dev_err(dev,
++					"set_gamma_params: R-Table Error in"
++					" copy to user\n");
++				return -EFAULT;
++			}
++		}
++
++		if ((!gamma.bypass_b) && ((ISNULL(user_gamma.table_b)))) {
++			dev_err(dev,
++				"get_gamma_params: table ptr empty for B\n");
++			return -EINVAL;
++		} else {
++			if (copy_to_user(user_gamma.table_b,
++				gamma.table_b,
++				(table_size *
++				sizeof(struct ipipe_gamma_entry)))) {
++				dev_err(dev,
++					"set_gamma_params: B-Table Error in"
++					" copy to user\n");
++				return -EFAULT;
++			}
++		}
++
++		if ((!gamma.bypass_g) && ((ISNULL(user_gamma.table_g)))) {
++			dev_err(dev,
++				"get_gamma_params: table ptr empty for G\n");
++			return -EINVAL;
++		} else {
++			if (copy_from_user(gamma.table_g,
++				user_gamma.table_g,
++				(table_size *
++				sizeof(struct ipipe_gamma_entry)))) {
++				dev_err(dev,
++					"set_gamma_params: G-Table"
++					"copy error\n");
++				return -EFAULT;
++			}
++		}
++
++		if (ISNULL(user_gamma.table_rgb_all)) {
++			dev_err(dev,
++				"get_gamma_params: table ptr empty "
++				"for RGB-all\n");
++			return -EINVAL;
++		} else {
++			if (copy_from_user(user_gamma.table_rgb_all,
++				gamma.table_rgb_all,
++				(table_size *
++				sizeof(struct ipipe_gamma_entry)))) {
++				dev_err(dev,
++					"set_gamma_params: RGB-all Table,"
++					" copy error\n");
++				return -EFAULT;
++			}
++		}
++	}
++	if (copy_to_user(gamma_param,
++		&user_gamma,
++		sizeof(struct prev_gamma))) {
++		dev_err(dev, "get_dfc_params: Error in copy from kernel\n");
++		return -EFAULT;
++	}
++	return 0;
++}
++
++static int validate_rgb2yuv_params(struct device *dev)
++{
++	/* S10Q8 */
++	CHECKMORE((rgb2yuv.coef_ry.decimal), 255);
++	CHECKMORE((rgb2yuv.coef_ry.integer), 3);
++	CHECKMORE((rgb2yuv.coef_gy.decimal), 255);
++	CHECKMORE((rgb2yuv.coef_gy.integer), 3);
++	CHECKMORE((rgb2yuv.coef_by.decimal), 255);
++	CHECKMORE((rgb2yuv.coef_by.integer), 3);
++	CHECKMORE((rgb2yuv.coef_rcb.decimal), 255);
++	CHECKMORE((rgb2yuv.coef_rcb.integer), 3);
++	CHECKMORE((rgb2yuv.coef_gcb.decimal), 255);
++	CHECKMORE((rgb2yuv.coef_gcb.integer), 3);
++	CHECKMORE((rgb2yuv.coef_bcb.decimal), 255);
++	CHECKMORE((rgb2yuv.coef_bcb.integer), 3);
++	CHECKMORE((rgb2yuv.coef_rcr.decimal), 255);
++	CHECKMORE((rgb2yuv.coef_rcr.integer), 3);
++	CHECKMORE((rgb2yuv.coef_gcr.decimal), 255);
++	CHECKMORE((rgb2yuv.coef_gcr.integer), 3);
++	CHECKMORE((rgb2yuv.coef_bcr.decimal), 255);
++	CHECKMORE((rgb2yuv.coef_bcr.integer), 3);
++	/* S9Q0 */
++	CHECKMORE((rgb2yuv.out_ofst_y), 0x1ff);
++	CHECKMORE((rgb2yuv.out_ofst_cb), 0x1ff);
++	CHECKMORE((rgb2yuv.out_ofst_cr), 0x1ff);
++	return 0;
++}
++static int set_rgb2yuv_params(struct device *dev, void *param, int len)
++{
++	struct prev_rgb2yuv *rgb2yuv_param = (struct prev_rgb2yuv *)param;
++
++	if (ISNULL(rgb2yuv_param))
++		/* Copy defaults for rgb2yuv conversion  */
++		memcpy((void *)&rgb2yuv,
++		       (void *)&dm355_rgb2yuv_defaults,
++		       sizeof(struct prev_rgb2yuv));
++	else {
++		if (copy_from_user(&rgb2yuv,
++			rgb2yuv_param,
++			sizeof(struct prev_rgb2yuv))) {
++			dev_err(dev,
++				"set_rgb2yuv_params: Error in copy from"
++				" user\n");
++			return -EFAULT;
++		}
++		if (validate_rgb2yuv_params(dev) < 0)
++			return -EINVAL;
++	}
++	return (ipipe_set_rgb2ycbcr_regs(&rgb2yuv));
++}
++static int get_rgb2yuv_params(struct device *dev, void *param, int len)
++{
++	struct prev_rgb2yuv *rgb2yuv_param = (struct prev_rgb2yuv *)param;
++
++	if (copy_to_user((struct prev_rgb2yuv *)rgb2yuv_param,
++		&rgb2yuv,
++		sizeof(struct prev_rgb2yuv))) {
++		dev_err(dev, "get_rgb2yuv_params: Error in"
++				" copy from kernel\n");
++		return -EFAULT;
++	}
++	return 0;
++}
++
++static int validate_lum_adj_params(struct device *dev)
++{
++	return 0;
++}
++
++static int set_lum_adj_params(struct device *dev, void *param, int len)
++{
++	struct prev_lum_adj *lum_adj_param = (struct prev_lum_adj *)param;
++
++	if (ISNULL(lum_adj_param))
++		/* Copy defaults for Luminance adjustments */
++		memcpy((void *)&lum_adj,
++		       (void *)&dm355_lum_adj_defaults,
++		       sizeof(struct prev_lum_adj));
++	else {
++		if (copy_from_user(&lum_adj,
++			lum_adj_param,
++			sizeof(struct prev_lum_adj))) {
++			dev_err(dev,
++				"set_lum_adj_params: Error in copy"
++				" from user\n");
++			return -EFAULT;
++		}
++		if (validate_lum_adj_params(dev) < 0)
++			return -EINVAL;
++	}
++	return (ipipe_set_lum_adj_regs(&lum_adj));
++}
++static int get_lum_adj_params(struct device *dev, void *param, int len)
++{
++	struct prev_lum_adj *lum_adj_param = (struct prev_lum_adj *)param;
++
++	if (copy_to_user(lum_adj_param,
++		&lum_adj,
++		sizeof(struct prev_lum_adj))) {
++		dev_err(dev, "get_lum_adj_params: Error in copy"
++				" from kernel\n");
++		return -EFAULT;
++	}
++	return 0;
++}
++
++static int validate_yuv422_conv_params(struct device *dev)
++{
++	CHECKMORE((yuv422_conv.en_chrom_lpf), 1);
++	return 0;
++}
++
++static int set_yuv422_conv_params(struct device *dev, void *param, int len)
++{
++	struct prev_yuv422_conv *yuv422_conv_param =
++	    (struct prev_yuv422_conv *)param;
++
++	if (ISNULL(yuv422_conv_param))
++		/* Copy defaults for yuv 422 conversion */
++		memcpy((void *)&yuv422_conv,
++		       (void *)&dm355_yuv422_conv_defaults,
++		       sizeof(struct prev_yuv422_conv));
++	else {
++		if (copy_from_user(&yuv422_conv,
++			yuv422_conv_param,
++			sizeof(struct prev_yuv422_conv))) {
++			dev_err(dev,
++				"set_yuv422_conv_params: Error in copy"
++				" from user\n");
++			return -EFAULT;
++		}
++		if (validate_yuv422_conv_params(dev) < 0)
++			return -EINVAL;
++	}
++	return (ipipe_set_yuv422_conv_regs(&yuv422_conv));
++}
++static int get_yuv422_conv_params(struct device *dev, void *param, int len)
++{
++	struct prev_yuv422_conv *yuv422_conv_param =
++	    (struct prev_yuv422_conv *)param;
++
++	if (copy_to_user(yuv422_conv_param,
++		&yuv422_conv,
++		sizeof(struct prev_yuv422_conv))) {
++		dev_err(dev,
++			"get_yuv422_conv_params: Error in copy"
++			" from kernel\n");
++		return -EFAULT;
++	}
++	return 0;
++}
++
++static int validate_yee_params(struct device *dev)
++{
++	CHECKMORE((yee.en), 1);
++	if (yee.en) {
++		CHECKMORE((yee.en_emf), 1);
++		CHECKMORE((yee.hpf_shft), 15);
++		CHECKMORE((yee.hpf_coef_00), 0x3ff);
++		CHECKMORE((yee.hpf_coef_01), 0x3ff);
++		CHECKMORE((yee.hpf_coef_02), 0x3ff);
++		CHECKMORE((yee.hpf_coef_10), 0x3ff);
++		CHECKMORE((yee.hpf_coef_11), 0x3ff);
++		CHECKMORE((yee.hpf_coef_12), 0x3ff);
++		CHECKMORE((yee.hpf_coef_20), 0x3ff);
++		CHECKMORE((yee.hpf_coef_21), 0x3ff);
++		CHECKMORE((yee.hpf_coef_22), 0x3ff);
++		if (ISNULL(yee.table)) {
++			dev_err(dev, "EE table ptr null\n");
++			return -1;
++		}
++	}
++	return 0;
++}
++static int set_yee_params(struct device *dev, void *param, int len)
++{
++	short *temp_table;
++	struct prev_yee user_yee;
++	struct prev_yee *yee_param = (struct prev_yee *)param;
++
++	if (ISNULL(yee_param)) {
++		temp_table = yee.table;
++		/* Copy defaults for ns */
++		memcpy((void *)&yee,
++		       (void *)&dm355_yee_defaults,
++			sizeof(struct prev_yee));
++		yee.table = temp_table;
++	} else {
++		if (copy_from_user(&user_yee,
++			yee_param,
++			sizeof(struct prev_yee))) {
++			dev_err(dev,
++				"set_yee_params: Error in copy from user\n");
++			return -EFAULT;
++		}
++		yee.en = user_yee.en;
++		if (user_yee.en) {
++			yee.en_emf = user_yee.en_emf;
++			yee.hpf_shft = user_yee.hpf_shft;
++			yee.hpf_coef_00 = user_yee.hpf_coef_00;
++			yee.hpf_coef_01 = user_yee.hpf_coef_01;
++			yee.hpf_coef_02 = user_yee.hpf_coef_02;
++			yee.hpf_coef_10 = user_yee.hpf_coef_10;
++			yee.hpf_coef_11 = user_yee.hpf_coef_11;
++			yee.hpf_coef_12 = user_yee.hpf_coef_12;
++			yee.hpf_coef_20 = user_yee.hpf_coef_20;
++			yee.hpf_coef_21 = user_yee.hpf_coef_21;
++			yee.hpf_coef_22 = user_yee.hpf_coef_22;
++
++			if (ISNULL(user_yee.table)) {
++				dev_err(dev, "get_yee_params: yee table"
++						" ptr null\n");
++				return -EINVAL;
++			}
++			if (copy_from_user(yee.table,
++				user_yee.table,
++				(MAX_SIZE_EEC * sizeof(short)))) {
++				dev_err(dev,
++					"set_yee_params: Error in copy"
++					" from user\n");
++				return -EFAULT;
++			}
++		}
++		if (validate_yee_params(dev) < 0)
++			return -EINVAL;
++	}
++	return (ipipe_set_ee_regs(&yee));
++}
++static int get_yee_params(struct device *dev, void *param, int len)
++{
++	struct prev_yee *yee_param = (struct prev_yee *)param;
++	struct prev_yee user_yee;
++
++	if (copy_from_user(&user_yee, yee_param, sizeof(struct prev_yee))) {
++		dev_err(dev, "get_yee_params: Error in copy to kernel\n");
++		return -EFAULT;
++	}
++	if (ISNULL(user_yee.table)) {
++		dev_err(dev, "get_yee_params: yee table ptr null\n");
++		return -EINVAL;
++	}
++	if (copy_to_user(user_yee.table,
++		yee.table,
++		(MAX_SIZE_EEC * sizeof(short)))) {
++		dev_err(dev, "get_yee_params: Error in copy from kernel\n");
++		return -EFAULT;
++	}
++	user_yee.en = yee.en;
++	user_yee.en_emf = yee.en_emf;
++	user_yee.hpf_shft = yee.hpf_shft;
++	user_yee.hpf_coef_00 = yee.hpf_coef_00;
++	user_yee.hpf_coef_01 = yee.hpf_coef_01;
++	user_yee.hpf_coef_02 = yee.hpf_coef_02;
++	user_yee.hpf_coef_10 = yee.hpf_coef_10;
++	user_yee.hpf_coef_11 = yee.hpf_coef_11;
++	user_yee.hpf_coef_12 = yee.hpf_coef_12;
++	user_yee.hpf_coef_20 = yee.hpf_coef_20;
++	user_yee.hpf_coef_21 = yee.hpf_coef_21;
++	user_yee.hpf_coef_22 = yee.hpf_coef_22;
++
++	if (copy_to_user(yee_param,
++		&user_yee,
++		sizeof(struct prev_yee))) {
++		dev_err(dev, "get_yee_params: Error in copy from kernel\n");
++		return -EFAULT;
++	}
++	return 0;
++}
++
++static int validate_fcs_params(struct device *dev)
++{
++	CHECKMORE((fcs.en), 1);
++	if (fcs.en) {
++		CHECKMORE((fcs.hpf_shft_y), 3);
++		CHECKMORE((fcs.gain_shft_c), 7);
++		CHECKMORE((fcs.thr), 255);
++		CHECKMORE((fcs.sgn), 255);
++		CHECKMORE((fcs.lth), 256);
++	}
++	return 0;
++}
++static int set_fcs_params(struct device *dev, void *param, int len)
++{
++	struct prev_fcs *fcs_param = (struct prev_fcs *)param;
++
++	if (ISNULL(fcs_param))
++		/* Copy defaults for ns */
++		memcpy((void *)&fcs,
++		       (void *)&dm355_fcs_defaults,
++			sizeof(struct prev_fcs));
++	else {
++		if (copy_from_user(&fcs,
++			fcs_param,
++			sizeof(struct prev_fcs))) {
++			dev_err(dev,
++				"set_fcs_params: Error in copy from user\n");
++			return -EFAULT;
++		}
++		if (validate_fcs_params(dev) < 0)
++			return -EINVAL;
++	}
++	return (ipipe_set_fcs_regs(&fcs));
++}
++static int get_fcs_params(struct device *dev, void *param, int len)
++{
++	struct prev_fcs *fcs_param = (struct prev_fcs *)param;
++
++	if (copy_to_user(fcs_param,
++		&fcs,
++		sizeof(struct prev_fcs))) {
++		dev_err(dev, "get_fcs_params: Error in copy from kernel\n");
++		return -EFAULT;
++	}
++	return 0;
++}
++
++static struct prev_module_if *prev_enum_preview_cap(struct device *dev,
++						    int index)
++{
++	dev_dbg(dev, "prev_enum_preview_cap: index = %d\n", index);
++	if ((index + 1) > PREV_MAX_MODULES)
++		return NULL;
++
++	return (&prev_modules[index]);
++}
++
++static unsigned int prev_get_oper_mode(void)
++{
++	return oper_mode;
++}
++
++static unsigned int ipipe_get_oper_state(void)
++{
++	return oper_state.state;
++}
++
++static void ipipe_set_oper_state(unsigned int state)
++{
++	mutex_lock(&oper_state.lock);
++	oper_state.state = state;
++	mutex_unlock(&oper_state.lock);
++}
++
++static unsigned int ipipe_get_prev_config_state(void)
++{
++	return oper_state.prev_config_state;
++}
++
++static unsigned int ipipe_get_rsz_config_state(void)
++{
++	return oper_state.rsz_config_state;
++}
++
++/* Use shared to allocate exclusive blocks as required
++ * by resize applications in single shot mode
++ */
++static void *ipipe_alloc_config_block(struct device *dev, int shared)
++{
++
++	struct ipipe_params *config_block;
++
++	if (shared) {
++		/* return common data block */
++		mutex_lock(&oper_state.lock);
++		if (oper_state.resource_in_use) {
++			dev_err(dev, "Shared resource in use\n");
++			mutex_unlock(&oper_state.lock);
++			return NULL;
++		}
++		mutex_unlock(&oper_state.lock);
++		return oper_state.shared_config_param;
++	} else {
++		config_block = kmalloc(sizeof(struct ipipe_params),
++					GFP_KERNEL);
++		if (ISNULL(config_block)) {
++			dev_err(dev,
++				"imp_alloc_config_block: failed"
++				" to allocate memory\n");
++		}
++	}
++	return config_block;
++}
++
++/* Used to free only non-shared config block allocated through
++ * imp_alloc_config_block
++ */
++static void ipipe_dealloc_config_block(struct device *dev, void *config_block)
++{
++	if (config_block) {
++		if (config_block != oper_state.shared_config_param)
++			kfree(config_block);
++		else
++			dev_err(dev, "Trying to free shared config block\n");
++	}
++}
++
++static void ipipe_dealloc_user_config_block(struct device *dev,
++					    void *config_block)
++{
++	kfree(config_block);
++}
++
++static void *ipipe_alloc_user_config_block(struct device *dev,
++					   enum imp_log_chan_t chan_type,
++					   unsigned int oper_mode, int *len)
++{
++	void *config = NULL;
++
++	if (oper_mode == IMP_MODE_SINGLE_SHOT) {
++		if (chan_type == IMP_PREVIEWER) {
++			config =
++			    kmalloc(sizeof(struct prev_single_shot_config),
++				    GFP_KERNEL);
++			*len = sizeof(struct prev_single_shot_config);
++		} else if (chan_type == IMP_RESIZER) {
++			config =
++			    kmalloc(sizeof(struct rsz_single_shot_config),
++				    GFP_KERNEL);
++			*len = sizeof(struct rsz_single_shot_config);
++		}
++
++	} else {
++		if (chan_type == IMP_PREVIEWER) {
++			config =
++			    kmalloc(sizeof(struct prev_continuous_config),
++				    GFP_KERNEL);
++			*len = sizeof(struct prev_continuous_config);
++		} else if (chan_type == IMP_RESIZER) {
++			config =
++			    kmalloc(sizeof(struct rsz_continuous_config),
++				    GFP_KERNEL);
++			*len = sizeof(struct rsz_continuous_config);
++		}
++	}
++	return config;
++}
++
++static void ipipe_set_user_config_defaults(struct device *dev,
++					   enum imp_log_chan_t chan_type,
++					   unsigned int oper_mode, void *config)
++{
++	dev_dbg(dev, "ipipe_set_user_config_defaults\n");
++	if (oper_mode == IMP_MODE_SINGLE_SHOT) {
++		if (chan_type == IMP_PREVIEWER) {
++			dev_dbg(dev, "SS-Preview\n");
++			/* preview channel in single shot mode */
++			memcpy(config,
++			       (void *)&dm355_prev_ss_config_defs,
++			       sizeof(struct prev_single_shot_config));
++		} else {
++			dev_dbg(dev, "SS-Resize\n");
++			/* resizer channel in single shot mode */
++			memcpy(config,
++			       (void *)&dm355_rsz_ss_config_defs,
++			       sizeof(struct rsz_single_shot_config));
++		}
++	} else if (oper_mode == IMP_MODE_CONTINUOUS) {
++		/* Continuous mode */
++		if (chan_type == IMP_PREVIEWER) {
++			dev_dbg(dev, "Cont Preview\n");
++			/* previewer defaults */
++			memcpy(config,
++			       (void *)&dm355_prev_cont_config_defs,
++			       sizeof(struct prev_continuous_config));
++		} else {
++			dev_dbg(dev, "Cont resize\n");
++			/* resizer defaults */
++			memcpy(config,
++			       (void *)&dm355_rsz_cont_config_defs,
++			       sizeof(struct rsz_continuous_config));
++		}
++	} else {
++		dev_err(dev, "Incorrect mode used\n");
++	}
++}
++
++static void ipipe_config_resize_out_param(struct ipipe_params *param,
++					  int index,
++					  struct rsz_ss_output_spec *output,
++					  unsigned char flag)
++{
++	if (output->enable) {
++		param->rsz_en[index] = ENABLE;
++		param->rsz_rsc_param[index].rsz_o_vsz = output->height - 1;
++		param->rsz_rsc_param[index].rsz_o_hsz = output->width - 1;
++		param->rsz_rsc_param[index].rsz_o_hst = output->hst;
++		if (flag) {
++			param->rsz_rsc_param[index].rsz_h_typ =
++			    output->h_intp_type;
++			param->rsz_rsc_param[index].rsz_h_lse_sel =
++			    output->h_lpf_lse_sel;
++			param->rsz_rsc_param[index].rsz_h_lpf =
++			    output->lpf_user_val;
++		}
++		param->ext_mem_param[index].rsz_sdr_oft = (output->width * 2);
++		param->ext_mem_param[index].rsz_sdr_ptr_s = output->vst;
++		param->ext_mem_param[index].rsz_sdr_ptr_e = output->height;
++	} else
++		param->rsz_en[index] = DISABLE;
++}
++
++/* Call this after setting IPIPE input size and resizer
++ * output size
++ */
++static void ipipe_config_resize_in_param(struct ipipe_params *param, int index)
++{
++	param->rsz_rsc_param[index].rsz_i_vst = param->ipipe_vst;
++	param->rsz_rsc_param[index].rsz_i_vsz = param->ipipe_vsz;
++	param->rsz_rsc_param[index].rsz_i_hst = param->ipipe_hst;
++	param->rsz_rsc_param[index].rsz_h_dif =
++	    ((param->ipipe_hsz + 1) * 256) /
++	    (param->rsz_rsc_param[index].rsz_o_hsz + 1);
++	param->rsz_rsc_param[index].rsz_v_dif =
++	    ((param->ipipe_vsz + 1) * 256) /
++	    (param->rsz_rsc_param[index].rsz_o_vsz + 1);
++}
++
++static int ipipe_set_resize_config(struct device *dev,
++				   unsigned int oper_mode,
++				   int resizer_chained,
++				   void *user_config, void *config)
++{
++	int ret = 0;
++	struct ipipe_params *param = (struct ipipe_params *)config;
++
++	dev_dbg(dev, "ipipe_set_resize_config\n");
++	if ((ISNULL(user_config)) || (ISNULL(config))) {
++		dev_err(dev, "Invalid user_config or config ptr\n");
++		return -EINVAL;
++	}
++
++	memcpy((void *)config,
++		(void *)&dm355_ipipe_defs,
++		sizeof(struct ipipe_params));
++
++	if (oper_mode == IMP_MODE_SINGLE_SHOT) {
++		/* resizer in standalone mode. In this mode if serializer
++		 *  is enabled, we need to set config params in the hw.
++		 */
++		struct rsz_single_shot_config *ss_config =
++		    (struct rsz_single_shot_config *)user_config;
++
++		if (resizer_chained) {
++			/* shared block */
++			if ((!ss_config->output1.enable) &&
++			    (!ss_config->output1.enable)) {
++				dev_err(dev,
++					"One of the resizer output"
++					" must be enabled\n");
++				return -EINVAL;
++			}
++			ret = mutex_lock_interruptible(&oper_state.lock);
++			if (ret)
++				return ret;
++			if (ss_config->output1.enable) {
++				if (ss_config->output1.pix_fmt != IPIPE_UYVY) {
++					dev_err(dev,
++						"output1:Only UYVY "
++						"supported\n");
++					mutex_unlock(&oper_state.lock);
++					return -EINVAL;
++				}
++				if ((ss_config->output1.width == 0) ||
++				    (ss_config->output1.height == 0)) {
++					dev_err(dev,
++						"output1:invalid width or "
++						"height\n");
++					mutex_unlock(&oper_state.lock);
++					return -EINVAL;
++				}
++				if (ss_config->output1.width % 16) {
++					dev_err(dev,
++						"output1:width to be a "
++						"multiple of 16\n");
++					mutex_unlock(&oper_state.lock);
++					return -EINVAL;
++				}
++			}
++
++			if (ss_config->output2.enable) {
++				if (ss_config->output2.pix_fmt != IPIPE_UYVY) {
++					dev_err(dev,
++						"output2:Only UYVY"
++						" supported\n");
++					mutex_unlock(&oper_state.lock);
++					return -EINVAL;
++				}
++				if ((ss_config->output2.width == 0) ||
++				    (ss_config->output2.height == 0)) {
++					dev_err(dev,
++						"output2:invalid width"
++						" or height\n");
++					mutex_unlock(&oper_state.lock);
++					return -EINVAL;
++				}
++				if (ss_config->output2.width % 16) {
++					dev_err(dev,
++						"output2:width to be a "
++						"multiple of 16\n");
++					mutex_unlock(&oper_state.lock);
++					return -EINVAL;
++				}
++			}
++
++			ipipe_config_resize_out_param(param, 0,
++						      &ss_config->output1, 1);
++			ipipe_config_resize_out_param(param, 1,
++						      &ss_config->output2, 1);
++
++			if (ss_config->en_flip_vert)
++				param->rsz_seq_vrv = ENABLE;
++			if (ss_config->en_flip_vert)
++				param->rsz_seq_hrv = ENABLE;
++			if (ss_config->chroma_sample_even)
++				param->rsz_seq_crv = ENABLE;
++			oper_state.rsz_chained = 1;
++			oper_state.rsz_config_state = STATE_CONFIGURED;
++			mutex_unlock(&oper_state.lock);
++		} else {
++			if ((ss_config->input.image_width == 0) ||
++			    (ss_config->input.image_height == 0)) {
++				dev_err(dev,
++					"input image width or "
++					"height invalid\n");
++				return -EINVAL;
++			}
++			if (ss_config->input.image_width % 16) {
++				dev_err(dev,
++					"input image width to "
++					"be a multiple of 16\n");
++				return -EINVAL;
++			}
++
++			param->ipipeif_param.source = SDRAM_YUV;
++			param->ipipeif_param.hnum =
++			    ss_config->input.image_width;
++			param->ipipeif_param.vnum =
++			    ss_config->input.image_height;
++			param->ipipeif_param.glob_hor_size =
++			    ss_config->input.ppln;
++			param->ipipeif_param.glob_ver_size =
++			    ss_config->input.lpfr;
++			param->ipipeif_param.clk_div = ss_config->input.clk_div;
++			if (!ss_config->input.line_length)
++				param->ipipeif_param.adofs =
++					ss_config->input.image_width * 2;
++			else
++				param->ipipeif_param.adofs =
++						ss_config->input.line_length;
++			/* adjust the line length to be a multiple of 32 */
++			param->ipipeif_param.adofs =
++				((param->ipipeif_param.adofs + 31) & ~0x1f);
++			param->ipipe_hsz = ss_config->input.image_width - 1;
++			if (ss_config->input.dec_en) {
++				if ((ss_config->input.rsz < 16) ||
++				    (ss_config->input.rsz > 112)) {
++					dev_err(dev,
++						"rsz range is 16 to 112\n");
++					return -EINVAL;
++				}
++				param->ipipeif_param.decimation =
++				    IPIPEIF_DECIMATION_ON;
++				param->ipipeif_param.rsz = ss_config->input.rsz;
++				param->ipipeif_param.avg_filter =
++				    (enum ipipeif_avg_filter)ss_config->input.
++				    avg_filter_en;
++				param->ipipe_hsz =
++				    (((ss_config->input.image_width * 16) /
++				      ss_config->input.rsz) - 1);
++			}
++			param->ipipe_vsz = ss_config->input.image_height - 1;
++			param->ipipe_dpaths_fmt = IPIPE_YUV2YUV;
++			/* TODO check if ipipe vsz and hsz are same as resizer
++			   input sizes */
++			ipipe_config_resize_out_param(param, 0,
++						      &ss_config->output1, 1);
++			ipipe_config_resize_out_param(param, 1,
++						      &ss_config->output2, 1);
++			/* Setup resizer input configuration */
++			if (param->rsz_en[0])
++				ipipe_config_resize_in_param(param, 0);
++
++			if (param->rsz_en[1])
++				ipipe_config_resize_in_param(param, 1);
++
++			if (ss_config->en_flip_vert)
++				param->rsz_seq_vrv = ENABLE;
++			if (ss_config->en_flip_vert)
++				param->rsz_seq_hrv = ENABLE;
++			if (ss_config->chroma_sample_even)
++				param->rsz_seq_crv = ENABLE;
++			if (!en_serializer)
++				ret = ipipe_hw_setup(config);
++		}
++
++	} else {
++		/* Continuous mode. This is a shared config block */
++		struct rsz_continuous_config *cont_config =
++		    (struct rsz_continuous_config *)user_config;
++
++		ret = mutex_lock_interruptible(&oper_state.lock);
++		if (ret)
++			return ret;
++		if (resizer_chained) {
++			if (!cont_config->en_output1) {
++				dev_err(dev, "enable resizer - 0\n");
++				mutex_unlock(&oper_state.lock);
++				return -EINVAL;
++			} else {
++				param->rsz_en[0] = ENABLE;
++				param->rsz_rsc_param[0].rsz_mode = CONTINUOUS;
++			}
++			if (cont_config->output2.enable) {
++				if (cont_config->output2.pix_fmt
++					!= IPIPE_UYVY) {
++					dev_err(dev, "Only UYVY supported\n");
++					mutex_unlock(&oper_state.lock);
++					return -EINVAL;
++				}
++				if ((cont_config->output2.width == 0) ||
++				    (cont_config->output2.height == 0)) {
++					dev_err(dev,
++						"output2:invalid width or"
++						" height\n");
++					mutex_unlock(&oper_state.lock);
++					return -EINVAL;
++				}
++				if (cont_config->output2.width % 16) {
++					dev_err(dev,
++						"width to be a multiple"
++						" of 16\n");
++					mutex_unlock(&oper_state.lock);
++					return -EINVAL;
++				}
++			}
++			ipipe_config_resize_out_param(param, 1,
++						      &cont_config->output2, 1);
++			if (cont_config->en_flip_vert)
++				param->rsz_seq_vrv = ENABLE;
++			if (cont_config->en_flip_vert)
++				param->rsz_seq_hrv = ENABLE;
++			if (cont_config->chroma_sample_even)
++				param->rsz_seq_crv = ENABLE;
++			if (cont_config->en_vaaf)
++				param->rsz_aal = ENABLE;
++			oper_state.rsz_chained = 1;
++		} else {
++			param->ipipeif_param.clock_select = PIXCEL_CLK;
++			param->ipipeif_param.source = CCDC;
++			param->ipipe_dpaths_fmt = IPIPE_YUV2YUV;
++			if (cont_config->input.dec_en) {
++				if ((cont_config->input.rsz < 16) ||
++				    (cont_config->input.rsz > 112)) {
++					dev_err(dev,
++						"rsz range is 16 to 112\n");
++					mutex_unlock(&oper_state.lock);
++					return -EINVAL;
++				}
++				param->ipipeif_param.decimation =
++				    IPIPEIF_DECIMATION_ON;
++				param->ipipeif_param.rsz =
++				    cont_config->input.rsz;
++				param->ipipeif_param.avg_filter =
++				    (enum ipipeif_avg_filter)cont_config->input.
++				    avg_filter_en;
++			}
++			param->ipipeif_param.mode = CONTINUOUS;
++			if (!cont_config->en_output1)
++				param->rsz_en[0] = DISABLE;
++			else
++				param->rsz_rsc_param[0].rsz_mode = CONTINUOUS;
++			if (cont_config->output2.enable) {
++				if (cont_config->output2.pix_fmt
++					!= IPIPE_UYVY) {
++					dev_err(dev, "Only UYVY supported\n");
++					mutex_unlock(&oper_state.lock);
++					return -EINVAL;
++				}
++				if ((cont_config->output2.width == 0) ||
++				    (cont_config->output2.height == 0)) {
++					dev_err(dev,
++						"output2:invalid width"
++						" or height\n");
++					mutex_unlock(&oper_state.lock);
++					return -EINVAL;
++				}
++				if (cont_config->output2.width % 16) {
++					dev_err(dev,
++						"width to be a multiple"
++						" of 16\n");
++					mutex_unlock(&oper_state.lock);
++					return -EINVAL;
++				}
++				param->rsz_rsc_param[1].rsz_mode = CONTINUOUS;
++			}
++			ipipe_config_resize_out_param(param, 1,
++						      &cont_config->output2, 1);
++			if (cont_config->en_flip_vert)
++				param->rsz_seq_vrv = ENABLE;
++			if (cont_config->en_flip_vert)
++				param->rsz_seq_hrv = ENABLE;
++			if (cont_config->chroma_sample_even)
++				param->rsz_seq_crv = ENABLE;
++			if (cont_config->en_vaaf)
++				param->rsz_aal = ENABLE;
++		}
++		oper_state.rsz_config_state = STATE_CONFIGURED;
++		mutex_unlock(&oper_state.lock);
++	}
++	return ret;
++}
++
++static void ipipe_config_resizer_bypass(struct ipipe_params *param)
++{
++	param->rsz_seq_seq = DISABLE;
++	param->rsz_seq_tmm = DISABLE;
++	param->rsz_aal = DISABLE;
++	param->rsz_rsc_param[0].rsz_v_phs = 0;
++	param->rsz_rsc_param[0].rsz_h_phs = 0;
++	param->rsz_rsc_param[0].rsz_v_dif = 256;
++	param->rsz_rsc_param[0].rsz_h_dif = 256;
++	param->rsz_rsc_param[0].rsz_h_lse_sel = RSZ_H_LPF_LSE_INTERN;
++	param->rsz_en[0] = ENABLE;
++	param->rsz_en[1] = DISABLE;
++}
++
++#ifdef CONFIG_IMP_DEBUG
++static void ipipe_dump_hw_config(void)
++{
++	printk(KERN_NOTICE "IPIPE Configuration context\n");
++	printk(KERN_NOTICE
++	       "**************************************************\n");
++	if (oper_mode == IMP_MODE_SINGLE_SHOT)
++		printk(KERN_NOTICE "Operation mode = SINGLE SHOT\n");
++	else
++		printk(KERN_NOTICE "Operation mode = CONTINUOUS\n");
++	if (oper_state.rsz_chained)
++		printk(KERN_NOTICE "Resizer chained\n");
++	else
++		printk(KERN_NOTICE "Resizer not chained\n");
++	if (en_serializer)
++		printk(KERN_NOTICE "Serializer is enabled\n");
++	else
++		printk(KERN_NOTICE "Serializer is diabled\n");
++	if (oper_mode != IMP_MODE_SINGLE_SHOT) {
++		if (oper_state.prev_config_state)
++			printk(KERN_NOTICE "Previewer is configured\n");
++		else
++			printk(KERN_NOTICE "Previewer is not configured\n");
++	}
++	if (oper_state.rsz_chained || (oper_mode != IMP_MODE_SINGLE_SHOT)) {
++		if (oper_state.rsz_config_state)
++			printk(KERN_NOTICE "Resizer is configured\n");
++		else
++			printk(KERN_NOTICE "Resizer is not configured\n");
++	}
++	ipipe_hw_dump_config();
++}
++#else
++static void ipipe_dump_hw_config(void)
++{
++}
++#endif
++static int ipipe_set_preview_config(struct device *dev,
++				    unsigned int oper_mode,
++				    void *user_config, void *config)
++{
++	int ret = 0;
++	struct ipipe_params *param = (struct ipipe_params *)config;
++
++	dev_err(dev, "ipipe_set_preview_config\n");
++	if ((ISNULL(user_config)) || (ISNULL(config))) {
++		dev_err(dev, "Invalid user_config or config ptr\n");
++		return -EINVAL;
++	}
++
++	if (!oper_state.rsz_chained) {
++		/* For chained resizer, defaults are set by resizer */
++		memcpy((void *)config,
++		       (void *)&dm355_ipipe_defs,
++			sizeof(struct ipipe_params));
++	}
++
++	/* shared block */
++	ret = mutex_lock_interruptible(&oper_state.lock);
++	if (ret)
++		return ret;
++	if (oper_mode == IMP_MODE_SINGLE_SHOT) {
++		/* previewer in standalone mode. In this mode if serializer
++		 * is enabled, we need to set config params in the hw.
++		 */
++		struct prev_single_shot_config *ss_config =
++		    (struct prev_single_shot_config *)user_config;
++		if ((ss_config->input.image_width == 0) ||
++		    (ss_config->input.image_height == 0)) {
++			dev_err(dev, "input image width or height invalid\n");
++			mutex_unlock(&oper_state.lock);
++			return -EINVAL;
++		}
++		if (ss_config->input.image_width % 16) {
++			dev_err(dev,
++				"input image width to be a multiple of 16\n");
++			mutex_unlock(&oper_state.lock);
++			return -EINVAL;
++		}
++
++		if (ipipe_process_pix_fmts(ss_config->input.pix_fmt,
++					   ss_config->output.pix_fmt,
++					   param) < 0) {
++			dev_err(dev, "error in input or output pix format\n");
++			mutex_unlock(&oper_state.lock);
++			return -EINVAL;
++		}
++		param->ipipe_dpaths_bypass = ss_config->bypass;
++		param->ipipeif_param.hnum = ss_config->input.image_width;
++		param->ipipeif_param.vnum = ss_config->input.image_height;
++		param->ipipeif_param.glob_hor_size = ss_config->input.ppln;
++		param->ipipeif_param.glob_ver_size = ss_config->input.lpfr;
++		param->ipipeif_param.clk_div = ss_config->input.clk_div;
++		if (!ss_config->input.line_length) {
++			/* Calculate the line length */
++			if ((param->ipipeif_param.ialaw) ||
++			    (param->ipipeif_param.pack_mode))
++				param->ipipeif_param.adofs =
++					ss_config->input.image_width;
++			else
++				param->ipipeif_param.adofs =
++					ss_config->input.image_width * 2;
++		} else
++			param->ipipeif_param.adofs =
++				ss_config->input.line_length;
++		/* Adjust adofs to be a multiple of 32 */
++		param->ipipeif_param.adofs =
++			((param->ipipeif_param.adofs + 31) & ~0x1f);
++		param->ipipe_vst = ss_config->input.vst;
++		param->ipipe_hst = ss_config->input.hst;
++		param->ipipe_colpat_olop = ss_config->input.colp_olop;
++		param->ipipe_colpat_olep = ss_config->input.colp_olep;
++		param->ipipe_colpat_elop = ss_config->input.colp_elop;
++		param->ipipe_colpat_elep = ss_config->input.colp_elep;
++		param->ipipe_hsz = ss_config->input.image_width - 1;
++		if (ss_config->input.dec_en) {
++			if ((ss_config->input.rsz < 16) ||
++			    (ss_config->input.rsz > 112)) {
++				dev_err(dev, "rsz range is 16 to 112\n");
++				mutex_unlock(&oper_state.lock);
++				return -EINVAL;
++			}
++			param->ipipeif_param.decimation = IPIPEIF_DECIMATION_ON;
++			param->ipipeif_param.rsz = ss_config->input.rsz;
++			param->ipipeif_param.avg_filter =
++			    (enum ipipeif_avg_filter)ss_config->input.
++			    avg_filter_en;
++			param->ipipe_hsz =
++			    (((ss_config->input.image_width * 16) /
++			      ss_config->input.rsz) - 1);
++		}
++		param->ipipe_vsz = ss_config->input.image_height - 1;
++		param->ipipeif_param.gain = ss_config->input.gain;
++		if (ss_config->input.pix_fmt == IPIPE_UYVY)
++			param->ipipeif_param.source = SDRAM_YUV;
++		else
++			param->ipipeif_param.source = SDRAM_RAW;
++
++		/* update the resize parameters */
++		if (oper_state.rsz_chained) {
++			if (param->rsz_en[0])
++				ipipe_config_resize_in_param(param, 0);
++			if (param->rsz_en[1])
++				ipipe_config_resize_in_param(param, 1);
++		} else {
++			/* Using IPIPE resizer as pass through */
++			param->rsz_rsc_param[0].rsz_o_vsz = param->ipipe_vsz;
++			param->rsz_rsc_param[0].rsz_o_hsz = param->ipipe_hsz;
++			param->rsz_rsc_param[0].rsz_o_hst = param->ipipe_hst;
++			param->ext_mem_param[0].rsz_sdr_oft =
++			    ss_config->input.image_width * 2;
++			param->ext_mem_param[0].rsz_sdr_ptr_s =
++			    param->ipipe_vst;
++			param->ext_mem_param[0].rsz_sdr_ptr_e =
++			    (ss_config->input.image_height);
++			ipipe_config_resizer_bypass(param);
++		}
++		if (!en_serializer)
++			ret = ipipe_hw_setup(config);
++	} else {
++		/* continuous mode */
++		struct prev_continuous_config *cont_config =
++		    (struct prev_continuous_config *)user_config;
++
++		param->ipipe_dpaths_bypass = cont_config->bypass;
++		if (cont_config->input.en_df_sub) {
++			dev_err(dev, "DF subtraction is not supported\n");
++			mutex_unlock(&oper_state.lock);
++			return -EINVAL;
++		}
++		param->ipipeif_param.source = CCDC;
++		param->ipipeif_param.clock_select = PIXCEL_CLK;
++		param->ipipeif_param.mode = CONTINUOUS;
++		if (cont_config->input.dec_en) {
++			if ((cont_config->input.rsz < 16) ||
++			    (cont_config->input.rsz > 112)) {
++				dev_err(dev, "rsz range is 16 to 112\n");
++				mutex_unlock(&oper_state.lock);
++				return -EINVAL;
++			}
++			param->ipipeif_param.decimation = IPIPEIF_DECIMATION_ON;
++			param->ipipeif_param.rsz = cont_config->input.rsz;
++			param->ipipeif_param.avg_filter =
++			    (enum ipipeif_avg_filter)cont_config->input.
++			    avg_filter_en;
++		}
++		/* update the resize parameters */
++		param->ipipe_mode = CONTINUOUS;
++		param->ipipe_colpat_olop = cont_config->input.colp_olop;
++		param->ipipe_colpat_olep = cont_config->input.colp_olep;
++		param->ipipe_colpat_elop = cont_config->input.colp_elop;
++		param->ipipe_colpat_elep = cont_config->input.colp_elep;
++		param->ipipeif_param.gain = cont_config->input.gain;
++		if (!oper_state.rsz_chained) {
++			param->rsz_en[0] = ENABLE;
++			param->rsz_rsc_param[0].rsz_mode = CONTINUOUS;
++			param->rsz_en[1] = DISABLE;
++		}
++		oper_state.prev_config_state = STATE_CONFIGURED;
++	}
++	mutex_unlock(&oper_state.lock);
++	return 0;
++}
++struct imp_hw_interface *imp_get_hw_if(void)
++{
++	return (&dm355_ipipe_interface);
++}
++EXPORT_SYMBOL(imp_get_hw_if);
++
++/* APIs for CCDC driver */
++static int ipipe_set_input_win(struct imp_window *win)
++{
++	int ret;
++	struct ipipe_params *param = oper_state.shared_config_param;
++
++	ret = mutex_lock_interruptible(&oper_state.lock);
++	if (ret)
++		return ret;
++	if (param->ipipeif_param.decimation) {
++		param->ipipe_hsz =
++		    ((win->width * 16) / param->ipipeif_param.rsz) - 1;
++	} else
++		param->ipipe_hsz = win->width - 1;
++	if (!oper_state.frame_format) {
++		param->ipipe_vsz = (win->height / 2) - 1;
++		param->ipipe_vst = (win->vst / 2);
++	} else {
++		param->ipipe_vsz = win->height - 1;
++		param->ipipe_vst = win->vst;
++	}
++	param->ipipe_hst = win->hst;
++	if (param->rsz_en[0]) {
++		param->rsz_rsc_param[0].rsz_i_vst = param->ipipe_vst;
++		param->rsz_rsc_param[0].rsz_i_vsz = param->ipipe_vsz;
++		param->rsz_rsc_param[0].rsz_i_hst = param->ipipe_hst;
++	}
++	if (param->rsz_en[1]) {
++		param->rsz_rsc_param[1].rsz_i_vst = param->ipipe_vst;
++		param->rsz_rsc_param[1].rsz_i_vsz = param->ipipe_vsz;
++		param->rsz_rsc_param[1].rsz_i_hst = param->ipipe_hst;
++	}
++	mutex_unlock(&oper_state.lock);
++	return 0;
++}
++static int ipipe_get_input_win(struct imp_window *win)
++{
++	int ret;
++	struct ipipe_params *param = oper_state.shared_config_param;
++
++	ret = mutex_lock_interruptible(&oper_state.lock);
++	if (ret)
++		return ret;
++	if (param->ipipeif_param.decimation)
++		win->width =
++		    ((param->ipipe_hsz + 1) * param->ipipeif_param.rsz) / 16;
++	else
++		win->width = param->ipipe_hsz + 1;
++	if (!oper_state.frame_format) {
++		win->height = (param->ipipe_vsz + 1) * 2;
++		win->vst = (param->ipipe_vst * 2);
++	} else {
++		win->height = param->ipipe_vsz + 1;
++		win->vst = param->ipipe_vst;
++	}
++	win->hst = param->ipipe_hst;
++	mutex_unlock(&oper_state.lock);
++	return 0;
++}
++
++static int ipipe_set_in_pixel_format(enum imp_pix_formats pix_fmt)
++{
++	int ret;
++
++	ret = mutex_lock_interruptible(&oper_state.lock);
++	if (ret)
++		return ret;
++	oper_state.in_pixel_format = pix_fmt;
++	mutex_unlock(&oper_state.lock);
++	return 0;
++}
++
++static int ipipe_set_out_pixel_format(enum imp_pix_formats pix_fmt)
++{
++	int ret;
++
++	ret = mutex_lock_interruptible(&oper_state.lock);
++	if (ret)
++		return ret;
++	oper_state.out_pixel_format = pix_fmt;
++	mutex_unlock(&oper_state.lock);
++	return 0;
++}
++
++static int ipipe_set_buftype(unsigned char buf_type)
++{
++	int ret;
++
++	ret = mutex_lock_interruptible(&oper_state.lock);
++	if (ret)
++		return ret;
++	oper_state.buffer_type = buf_type;
++	mutex_unlock(&oper_state.lock);
++	return 0;
++}
++
++static int ipipe_set_frame_format(unsigned char frm_fmt)
++{
++	int ret;
++
++	ret = mutex_lock_interruptible(&oper_state.lock);
++	if (ret)
++		return ret;
++	oper_state.frame_format = frm_fmt;
++	mutex_unlock(&oper_state.lock);
++	return 0;
++}
++
++static int ipipe_set_output_win(struct imp_window *win)
++{
++	int ret;
++	struct ipipe_params *param = oper_state.shared_config_param;
++	struct rsz_ss_output_spec output_specs;
++
++	if (!param->rsz_en[0]) {
++		printk(KERN_ERR "resizer output1 not enabled\n");
++		return -1;
++	}
++	output_specs.enable = 1;
++	output_specs.width = win->width;
++	/* Always set output height same as in height
++	   for de-interlacing
++	 */
++	output_specs.height = win->height;
++	output_specs.vst = win->vst;
++	output_specs.hst = win->hst;
++	ret = mutex_lock_interruptible(&oper_state.lock);
++	if (ret)
++		return ret;
++	ipipe_config_resize_out_param(param, 0, &output_specs, 0);
++	mutex_unlock(&oper_state.lock);
++	return 0;
++}
++static int ipipe_get_output_state(unsigned char out_sel)
++{
++	struct ipipe_params *param = oper_state.shared_config_param;
++
++	if ((out_sel != 0) && (out_sel != 1))
++		return 0;
++	return (param->rsz_en[out_sel]);
++}
++
++/* This should be called only after setting the output
++ * window params. This also assumes the corresponding
++ * output is configured prior to calling this.
++ */
++static int ipipe_get_line_length(unsigned char out_sel)
++{
++	struct ipipe_params *param = oper_state.shared_config_param;
++	int line_len;
++
++	if ((out_sel != 0) && (out_sel != 1))
++		return -1;
++	/* assume output is always UYVY. Change this if we
++	 * support RGB
++	 */
++	if (!param->rsz_en[out_sel])
++		return -1;
++
++	line_len = (param->rsz_rsc_param[out_sel].rsz_o_hsz + 1) * 2;
++
++	/* Adjust the length to 32 byte boundary */
++	line_len = ((line_len + 31) & ~0x1F);
++	return line_len;
++}
++
++static int ipipe_get_image_height(unsigned char out_sel)
++{
++	struct ipipe_params *param = oper_state.shared_config_param;
++	if ((out_sel != 0) && (out_sel != 1))
++		return -1;
++	/* assume output is always UYVY. Change this if we
++	 * support RGB
++	 */
++	if (!param->rsz_en[out_sel])
++		return -1;
++
++	return (param->rsz_rsc_param[out_sel].rsz_o_vsz + 1);
++}
++
++static int dm355_ipipe_init(void)
++{
++	oper_state.shared_config_param =
++		kmalloc(sizeof(struct ipipe_params), GFP_KERNEL);
++	if (ISNULL(oper_state.shared_config_param)) {
++		printk(KERN_ERR
++		       "dm355_ipipe_init: failed to allocate memory\n");
++		return -ENOMEM;
++	}
++	dfc.table = ipipe_dfc_table;
++	gamma.table_r = ipipe_gamma_table_r;
++	gamma.table_b = ipipe_gamma_table_b;
++	gamma.table_g = ipipe_gamma_table_g;
++	gamma.table_rgb_all = ipipe_gamma_table_all;
++	yee.table = ipipe_yee_table;
++	mutex_init(&oper_state.lock);
++	oper_state.state = CHANNEL_FREE;
++	oper_state.prev_config_state = STATE_NOT_CONFIGURED;
++	oper_state.rsz_config_state = STATE_NOT_CONFIGURED;
++	oper_state.frame_format = 1;
++	oper_state.in_pixel_format = IMP_BAYER;
++	oper_state.out_pixel_format = IMP_UYVY;
++	if (oper_mode == IMP_MODE_SINGLE_SHOT)
++		printk(KERN_NOTICE
++		       "DM355 IPIPE intialized in Single Shot mode\n");
++	else
++		printk(KERN_NOTICE
++		       "DM355 IPIPE intialized in Continuous mode\n");
++	return 0;
++}
++
++static void dm355_ipipe_cleanup(void)
++{
++	kfree(oper_state.shared_config_param);
++	printk(KERN_NOTICE "DM355 IPIPE harware module exited\n");
++}
++
++subsys_initcall(dm355_ipipe_init);
++module_exit(dm355_ipipe_cleanup);
++MODULE_LICENSE("GPL");
+--- /dev/null
++++ b/include/media/davinci/davinci_enc_mngr.h
+@@ -0,0 +1,56 @@
++
++/*
++ * Copyright (C) 2007 Texas Instruments Inc
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
++ */
++
++#ifndef DAVINCI_ENC_MNGR_H
++#define DAVINCI_ENC_MNGR_H
++
++#include <linux/kernel.h>
++#include <linux/init.h>
++#include <linux/ctype.h>
++#include <linux/delay.h>
++#include <linux/device.h>
++#include <mach/hardware.h>
++#include <mach/mux.h>
++#include <mach/cputype.h>
++#include <mach/io.h>
++#include <media/davinci/davinci_enc.h>
++#include <media/davinci/vid_encoder_types.h>
++#include <video/davinci_vpbe.h>
++
++#ifdef __KERNEL__
++
++#define DAVINCI_ENC_MAX_ENCODERS (4)
++
++struct vid_enc_device_mgr {
++	struct semaphore lock;
++	int num_encoders;	/* number of encoders in this channel */
++	int current_encoder;	/* index to current encoder */
++	char current_output[VID_ENC_NAME_MAX_CHARS];	/* current output */
++	struct vid_enc_mode_info current_mode;	/* current mode */
++	struct vid_encoder_device *encoder[DAVINCI_ENC_MAX_ENCODERS];
++};
++
++struct enc_config {
++	char output[VID_ENC_NAME_MAX_CHARS];
++	char mode[VID_ENC_NAME_MAX_CHARS];
++};
++
++#endif				/* __KERNEL__ */
++
++#endif
+--- a/arch/arm/configs/da850_omapl138_defconfig
++++ /dev/null
+@@ -1,1229 +0,0 @@
+-#
+-# Automatically generated make config: don't edit
+-# Linux kernel version: 2.6.30-davinci1
+-# Mon Jun 29 07:54:15 2009
+-#
+-CONFIG_ARM=y
+-CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+-CONFIG_GENERIC_GPIO=y
+-CONFIG_GENERIC_TIME=y
+-CONFIG_GENERIC_CLOCKEVENTS=y
+-CONFIG_MMU=y
+-# CONFIG_NO_IOPORT is not set
+-CONFIG_GENERIC_HARDIRQS=y
+-CONFIG_STACKTRACE_SUPPORT=y
+-CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+-CONFIG_LOCKDEP_SUPPORT=y
+-CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+-CONFIG_HARDIRQS_SW_RESEND=y
+-CONFIG_GENERIC_IRQ_PROBE=y
+-CONFIG_RWSEM_GENERIC_SPINLOCK=y
+-# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+-# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+-CONFIG_GENERIC_HWEIGHT=y
+-CONFIG_GENERIC_CALIBRATE_DELAY=y
+-CONFIG_ZONE_DMA=y
+-CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+-CONFIG_VECTORS_BASE=0xffff0000
+-CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+-
+-#
+-# General setup
+-#
+-CONFIG_EXPERIMENTAL=y
+-CONFIG_BROKEN_ON_SMP=y
+-CONFIG_LOCK_KERNEL=y
+-CONFIG_INIT_ENV_ARG_LIMIT=32
+-CONFIG_LOCALVERSION=""
+-CONFIG_LOCALVERSION_AUTO=y
+-# CONFIG_SWAP is not set
+-CONFIG_SYSVIPC=y
+-CONFIG_SYSVIPC_SYSCTL=y
+-CONFIG_POSIX_MQUEUE=y
+-CONFIG_POSIX_MQUEUE_SYSCTL=y
+-# CONFIG_BSD_PROCESS_ACCT is not set
+-# CONFIG_TASKSTATS is not set
+-# CONFIG_AUDIT is not set
+-
+-#
+-# RCU Subsystem
+-#
+-CONFIG_CLASSIC_RCU=y
+-# CONFIG_TREE_RCU is not set
+-# CONFIG_PREEMPT_RCU is not set
+-# CONFIG_TREE_RCU_TRACE is not set
+-# CONFIG_PREEMPT_RCU_TRACE is not set
+-CONFIG_IKCONFIG=y
+-CONFIG_IKCONFIG_PROC=y
+-CONFIG_LOG_BUF_SHIFT=14
+-CONFIG_GROUP_SCHED=y
+-CONFIG_FAIR_GROUP_SCHED=y
+-# CONFIG_RT_GROUP_SCHED is not set
+-CONFIG_USER_SCHED=y
+-# CONFIG_CGROUP_SCHED is not set
+-# CONFIG_CGROUPS is not set
+-CONFIG_SYSFS_DEPRECATED=y
+-CONFIG_SYSFS_DEPRECATED_V2=y
+-# CONFIG_RELAY is not set
+-# CONFIG_NAMESPACES is not set
+-CONFIG_BLK_DEV_INITRD=y
+-CONFIG_INITRAMFS_SOURCE=""
+-CONFIG_RD_GZIP=y
+-# CONFIG_RD_BZIP2 is not set
+-# CONFIG_RD_LZMA is not set
+-CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+-CONFIG_SYSCTL=y
+-CONFIG_ANON_INODES=y
+-CONFIG_EMBEDDED=y
+-CONFIG_UID16=y
+-CONFIG_SYSCTL_SYSCALL=y
+-CONFIG_KALLSYMS=y
+-# CONFIG_KALLSYMS_ALL is not set
+-# CONFIG_KALLSYMS_EXTRA_PASS is not set
+-# CONFIG_STRIP_ASM_SYMS is not set
+-CONFIG_HOTPLUG=y
+-CONFIG_PRINTK=y
+-CONFIG_BUG=y
+-CONFIG_ELF_CORE=y
+-CONFIG_BASE_FULL=y
+-CONFIG_FUTEX=y
+-CONFIG_EPOLL=y
+-CONFIG_SIGNALFD=y
+-CONFIG_TIMERFD=y
+-CONFIG_EVENTFD=y
+-CONFIG_SHMEM=y
+-CONFIG_AIO=y
+-CONFIG_VM_EVENT_COUNTERS=y
+-CONFIG_SLUB_DEBUG=y
+-CONFIG_COMPAT_BRK=y
+-# CONFIG_SLAB is not set
+-CONFIG_SLUB=y
+-# CONFIG_SLOB is not set
+-# CONFIG_PROFILING is not set
+-# CONFIG_MARKERS is not set
+-CONFIG_HAVE_OPROFILE=y
+-# CONFIG_KPROBES is not set
+-CONFIG_HAVE_KPROBES=y
+-CONFIG_HAVE_KRETPROBES=y
+-CONFIG_HAVE_CLK=y
+-# CONFIG_SLOW_WORK is not set
+-CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+-CONFIG_SLABINFO=y
+-CONFIG_RT_MUTEXES=y
+-CONFIG_BASE_SMALL=0
+-CONFIG_MODULES=y
+-# CONFIG_MODULE_FORCE_LOAD is not set
+-CONFIG_MODULE_UNLOAD=y
+-CONFIG_MODULE_FORCE_UNLOAD=y
+-CONFIG_MODVERSIONS=y
+-# CONFIG_MODULE_SRCVERSION_ALL is not set
+-CONFIG_BLOCK=y
+-# CONFIG_LBD is not set
+-# CONFIG_BLK_DEV_BSG is not set
+-# CONFIG_BLK_DEV_INTEGRITY is not set
+-
+-#
+-# IO Schedulers
+-#
+-CONFIG_IOSCHED_NOOP=y
+-CONFIG_IOSCHED_AS=y
+-# CONFIG_IOSCHED_DEADLINE is not set
+-# CONFIG_IOSCHED_CFQ is not set
+-CONFIG_DEFAULT_AS=y
+-# CONFIG_DEFAULT_DEADLINE is not set
+-# CONFIG_DEFAULT_CFQ is not set
+-# CONFIG_DEFAULT_NOOP is not set
+-CONFIG_DEFAULT_IOSCHED="anticipatory"
+-# CONFIG_FREEZER is not set
+-
+-#
+-# System Type
+-#
+-# CONFIG_ARCH_AAEC2000 is not set
+-# CONFIG_ARCH_INTEGRATOR is not set
+-# CONFIG_ARCH_REALVIEW is not set
+-# CONFIG_ARCH_VERSATILE is not set
+-# CONFIG_ARCH_AT91 is not set
+-# CONFIG_ARCH_CLPS711X is not set
+-# CONFIG_ARCH_EBSA110 is not set
+-# CONFIG_ARCH_EP93XX is not set
+-# CONFIG_ARCH_GEMINI is not set
+-# CONFIG_ARCH_FOOTBRIDGE is not set
+-# CONFIG_ARCH_NETX is not set
+-# CONFIG_ARCH_H720X is not set
+-# CONFIG_ARCH_IMX is not set
+-# CONFIG_ARCH_IOP13XX is not set
+-# CONFIG_ARCH_IOP32X is not set
+-# CONFIG_ARCH_IOP33X is not set
+-# CONFIG_ARCH_IXP23XX is not set
+-# CONFIG_ARCH_IXP2000 is not set
+-# CONFIG_ARCH_IXP4XX is not set
+-# CONFIG_ARCH_L7200 is not set
+-# CONFIG_ARCH_KIRKWOOD is not set
+-# CONFIG_ARCH_KS8695 is not set
+-# CONFIG_ARCH_NS9XXX is not set
+-# CONFIG_ARCH_LOKI is not set
+-# CONFIG_ARCH_MV78XX0 is not set
+-# CONFIG_ARCH_MXC is not set
+-# CONFIG_ARCH_ORION5X is not set
+-# CONFIG_ARCH_PNX4008 is not set
+-# CONFIG_ARCH_PXA is not set
+-# CONFIG_ARCH_MMP is not set
+-# CONFIG_ARCH_RPC is not set
+-# CONFIG_ARCH_SA1100 is not set
+-# CONFIG_ARCH_S3C2410 is not set
+-# CONFIG_ARCH_S3C64XX is not set
+-# CONFIG_ARCH_SHARK is not set
+-# CONFIG_ARCH_LH7A40X is not set
+-CONFIG_ARCH_DAVINCI=y
+-# CONFIG_ARCH_OMAP is not set
+-# CONFIG_ARCH_MSM is not set
+-# CONFIG_ARCH_W90X900 is not set
+-CONFIG_CP_INTC=y
+-
+-#
+-# TI DaVinci Implementations
+-#
+-
+-#
+-# DaVinci Core Type
+-#
+-# CONFIG_ARCH_DAVINCI_DM644x is not set
+-# CONFIG_ARCH_DAVINCI_DM355 is not set
+-# CONFIG_ARCH_DAVINCI_DM646x is not set
+-# CONFIG_ARCH_DAVINCI_DA830 is not set
+-CONFIG_ARCH_DAVINCI_DA850=y
+-CONFIG_ARCH_DAVINCI_DA8XX=y
+-# CONFIG_ARCH_DAVINCI_DM365 is not set
+-
+-#
+-# DaVinci Board Type
+-#
+-CONFIG_MACH_DAVINCI_DA850_EVM=y
+-CONFIG_DAVINCI_MUX=y
+-# CONFIG_DAVINCI_MUX_DEBUG is not set
+-# CONFIG_DAVINCI_MUX_WARNINGS is not set
+-CONFIG_DAVINCI_RESET_CLOCKS=y
+-
+-#
+-# Processor Type
+-#
+-CONFIG_CPU_32=y
+-CONFIG_CPU_ARM926T=y
+-CONFIG_CPU_32v5=y
+-CONFIG_CPU_ABRT_EV5TJ=y
+-CONFIG_CPU_PABRT_NOIFAR=y
+-CONFIG_CPU_CACHE_VIVT=y
+-CONFIG_CPU_COPY_V4WB=y
+-CONFIG_CPU_TLB_V4WBI=y
+-CONFIG_CPU_CP15=y
+-CONFIG_CPU_CP15_MMU=y
+-
+-#
+-# Processor Features
+-#
+-CONFIG_ARM_THUMB=y
+-# CONFIG_CPU_ICACHE_DISABLE is not set
+-# CONFIG_CPU_DCACHE_DISABLE is not set
+-# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+-# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+-# CONFIG_OUTER_CACHE is not set
+-CONFIG_COMMON_CLKDEV=y
+-
+-#
+-# Bus support
+-#
+-# CONFIG_PCI_SYSCALL is not set
+-# CONFIG_ARCH_SUPPORTS_MSI is not set
+-# CONFIG_PCCARD is not set
+-
+-#
+-# Kernel Features
+-#
+-CONFIG_TICK_ONESHOT=y
+-CONFIG_NO_HZ=y
+-CONFIG_HIGH_RES_TIMERS=y
+-CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+-CONFIG_VMSPLIT_3G=y
+-# CONFIG_VMSPLIT_2G is not set
+-# CONFIG_VMSPLIT_1G is not set
+-CONFIG_PAGE_OFFSET=0xC0000000
+-CONFIG_PREEMPT=y
+-CONFIG_HZ=100
+-CONFIG_AEABI=y
+-# CONFIG_OABI_COMPAT is not set
+-# CONFIG_ARCH_HAS_HOLES_MEMORYMODEL is not set
+-# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+-# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+-# CONFIG_HIGHMEM is not set
+-CONFIG_SELECT_MEMORY_MODEL=y
+-CONFIG_FLATMEM_MANUAL=y
+-# CONFIG_DISCONTIGMEM_MANUAL is not set
+-# CONFIG_SPARSEMEM_MANUAL is not set
+-CONFIG_FLATMEM=y
+-CONFIG_FLAT_NODE_MEM_MAP=y
+-CONFIG_PAGEFLAGS_EXTENDED=y
+-CONFIG_SPLIT_PTLOCK_CPUS=4096
+-# CONFIG_PHYS_ADDR_T_64BIT is not set
+-CONFIG_ZONE_DMA_FLAG=1
+-CONFIG_BOUNCE=y
+-CONFIG_VIRT_TO_BUS=y
+-CONFIG_UNEVICTABLE_LRU=y
+-CONFIG_HAVE_MLOCK=y
+-CONFIG_HAVE_MLOCKED_PAGE_BIT=y
+-CONFIG_LEDS=y
+-# CONFIG_LEDS_CPU is not set
+-CONFIG_ALIGNMENT_TRAP=y
+-
+-#
+-# Boot options
+-#
+-CONFIG_ZBOOT_ROM_TEXT=0x0
+-CONFIG_ZBOOT_ROM_BSS=0x0
+-CONFIG_CMDLINE=""
+-# CONFIG_XIP_KERNEL is not set
+-# CONFIG_KEXEC is not set
+-
+-#
+-# CPU Power Management
+-#
+-# CONFIG_CPU_IDLE is not set
+-
+-#
+-# Floating point emulation
+-#
+-
+-#
+-# At least one emulation must be selected
+-#
+-# CONFIG_VFP is not set
+-
+-#
+-# Userspace binary formats
+-#
+-CONFIG_BINFMT_ELF=y
+-# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+-CONFIG_HAVE_AOUT=y
+-# CONFIG_BINFMT_AOUT is not set
+-# CONFIG_BINFMT_MISC is not set
+-
+-#
+-# Power management options
+-#
+-# CONFIG_PM is not set
+-CONFIG_ARCH_SUSPEND_POSSIBLE=y
+-CONFIG_NET=y
+-
+-#
+-# Networking options
+-#
+-CONFIG_PACKET=y
+-# CONFIG_PACKET_MMAP is not set
+-CONFIG_UNIX=y
+-CONFIG_XFRM=y
+-# CONFIG_XFRM_USER is not set
+-# CONFIG_XFRM_SUB_POLICY is not set
+-# CONFIG_XFRM_MIGRATE is not set
+-# CONFIG_XFRM_STATISTICS is not set
+-# CONFIG_NET_KEY is not set
+-CONFIG_INET=y
+-# CONFIG_IP_MULTICAST is not set
+-# CONFIG_IP_ADVANCED_ROUTER is not set
+-CONFIG_IP_FIB_HASH=y
+-CONFIG_IP_PNP=y
+-CONFIG_IP_PNP_DHCP=y
+-# CONFIG_IP_PNP_BOOTP is not set
+-# CONFIG_IP_PNP_RARP is not set
+-# CONFIG_NET_IPIP is not set
+-# CONFIG_NET_IPGRE is not set
+-# CONFIG_ARPD is not set
+-# CONFIG_SYN_COOKIES is not set
+-# CONFIG_INET_AH is not set
+-# CONFIG_INET_ESP is not set
+-# CONFIG_INET_IPCOMP is not set
+-# CONFIG_INET_XFRM_TUNNEL is not set
+-CONFIG_INET_TUNNEL=m
+-CONFIG_INET_XFRM_MODE_TRANSPORT=y
+-CONFIG_INET_XFRM_MODE_TUNNEL=y
+-CONFIG_INET_XFRM_MODE_BEET=y
+-# CONFIG_INET_LRO is not set
+-CONFIG_INET_DIAG=y
+-CONFIG_INET_TCP_DIAG=y
+-# CONFIG_TCP_CONG_ADVANCED is not set
+-CONFIG_TCP_CONG_CUBIC=y
+-CONFIG_DEFAULT_TCP_CONG="cubic"
+-# CONFIG_TCP_MD5SIG is not set
+-CONFIG_IPV6=m
+-# CONFIG_IPV6_PRIVACY is not set
+-# CONFIG_IPV6_ROUTER_PREF is not set
+-# CONFIG_IPV6_OPTIMISTIC_DAD is not set
+-# CONFIG_INET6_AH is not set
+-# CONFIG_INET6_ESP is not set
+-# CONFIG_INET6_IPCOMP is not set
+-# CONFIG_IPV6_MIP6 is not set
+-# CONFIG_INET6_XFRM_TUNNEL is not set
+-# CONFIG_INET6_TUNNEL is not set
+-CONFIG_INET6_XFRM_MODE_TRANSPORT=m
+-CONFIG_INET6_XFRM_MODE_TUNNEL=m
+-CONFIG_INET6_XFRM_MODE_BEET=m
+-# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
+-CONFIG_IPV6_SIT=m
+-CONFIG_IPV6_NDISC_NODETYPE=y
+-# CONFIG_IPV6_TUNNEL is not set
+-# CONFIG_IPV6_MULTIPLE_TABLES is not set
+-# CONFIG_IPV6_MROUTE is not set
+-# CONFIG_NETWORK_SECMARK is not set
+-CONFIG_NETFILTER=y
+-# CONFIG_NETFILTER_DEBUG is not set
+-CONFIG_NETFILTER_ADVANCED=y
+-
+-#
+-# Core Netfilter Configuration
+-#
+-# CONFIG_NETFILTER_NETLINK_QUEUE is not set
+-# CONFIG_NETFILTER_NETLINK_LOG is not set
+-# CONFIG_NF_CONNTRACK is not set
+-# CONFIG_NETFILTER_XTABLES is not set
+-# CONFIG_IP_VS is not set
+-
+-#
+-# IP: Netfilter Configuration
+-#
+-# CONFIG_NF_DEFRAG_IPV4 is not set
+-# CONFIG_IP_NF_QUEUE is not set
+-# CONFIG_IP_NF_IPTABLES is not set
+-# CONFIG_IP_NF_ARPTABLES is not set
+-
+-#
+-# IPv6: Netfilter Configuration
+-#
+-# CONFIG_IP6_NF_QUEUE is not set
+-# CONFIG_IP6_NF_IPTABLES is not set
+-# CONFIG_IP_DCCP is not set
+-# CONFIG_IP_SCTP is not set
+-# CONFIG_TIPC is not set
+-# CONFIG_ATM is not set
+-# CONFIG_BRIDGE is not set
+-# CONFIG_NET_DSA is not set
+-# CONFIG_VLAN_8021Q is not set
+-# CONFIG_DECNET is not set
+-# CONFIG_LLC2 is not set
+-# CONFIG_IPX is not set
+-# CONFIG_ATALK is not set
+-# CONFIG_X25 is not set
+-# CONFIG_LAPB is not set
+-# CONFIG_ECONET is not set
+-# CONFIG_WAN_ROUTER is not set
+-# CONFIG_PHONET is not set
+-# CONFIG_NET_SCHED is not set
+-# CONFIG_DCB is not set
+-
+-#
+-# Network testing
+-#
+-# CONFIG_NET_PKTGEN is not set
+-# CONFIG_HAMRADIO is not set
+-# CONFIG_CAN is not set
+-# CONFIG_IRDA is not set
+-# CONFIG_BT is not set
+-# CONFIG_AF_RXRPC is not set
+-# CONFIG_WIRELESS is not set
+-# CONFIG_WIMAX is not set
+-# CONFIG_RFKILL is not set
+-# CONFIG_NET_9P is not set
+-
+-#
+-# Device Drivers
+-#
+-
+-#
+-# Generic Driver Options
+-#
+-CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+-CONFIG_STANDALONE=y
+-CONFIG_PREVENT_FIRMWARE_BUILD=y
+-# CONFIG_FW_LOADER is not set
+-# CONFIG_DEBUG_DRIVER is not set
+-# CONFIG_DEBUG_DEVRES is not set
+-# CONFIG_SYS_HYPERVISOR is not set
+-# CONFIG_CONNECTOR is not set
+-# CONFIG_MTD is not set
+-# CONFIG_PARPORT is not set
+-CONFIG_BLK_DEV=y
+-# CONFIG_BLK_DEV_COW_COMMON is not set
+-CONFIG_BLK_DEV_LOOP=m
+-# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+-# CONFIG_BLK_DEV_NBD is not set
+-CONFIG_BLK_DEV_RAM=y
+-CONFIG_BLK_DEV_RAM_COUNT=1
+-CONFIG_BLK_DEV_RAM_SIZE=32768
+-# CONFIG_BLK_DEV_XIP is not set
+-# CONFIG_CDROM_PKTCDVD is not set
+-# CONFIG_ATA_OVER_ETH is not set
+-CONFIG_MISC_DEVICES=y
+-# CONFIG_ICS932S401 is not set
+-# CONFIG_ENCLOSURE_SERVICES is not set
+-# CONFIG_ISL29003 is not set
+-# CONFIG_C2PORT is not set
+-
+-#
+-# EEPROM support
+-#
+-CONFIG_EEPROM_AT24=y
+-# CONFIG_EEPROM_LEGACY is not set
+-# CONFIG_EEPROM_93CX6 is not set
+-CONFIG_HAVE_IDE=y
+-# CONFIG_IDE is not set
+-
+-#
+-# SCSI device support
+-#
+-# CONFIG_RAID_ATTRS is not set
+-CONFIG_SCSI=m
+-CONFIG_SCSI_DMA=y
+-# CONFIG_SCSI_TGT is not set
+-# CONFIG_SCSI_NETLINK is not set
+-CONFIG_SCSI_PROC_FS=y
+-
+-#
+-# SCSI support type (disk, tape, CD-ROM)
+-#
+-CONFIG_BLK_DEV_SD=m
+-# CONFIG_CHR_DEV_ST is not set
+-# CONFIG_CHR_DEV_OSST is not set
+-# CONFIG_BLK_DEV_SR is not set
+-# CONFIG_CHR_DEV_SG is not set
+-# CONFIG_CHR_DEV_SCH is not set
+-
+-#
+-# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+-#
+-# CONFIG_SCSI_MULTI_LUN is not set
+-# CONFIG_SCSI_CONSTANTS is not set
+-# CONFIG_SCSI_LOGGING is not set
+-# CONFIG_SCSI_SCAN_ASYNC is not set
+-CONFIG_SCSI_WAIT_SCAN=m
+-
+-#
+-# SCSI Transports
+-#
+-# CONFIG_SCSI_SPI_ATTRS is not set
+-# CONFIG_SCSI_FC_ATTRS is not set
+-# CONFIG_SCSI_ISCSI_ATTRS is not set
+-# CONFIG_SCSI_SAS_LIBSAS is not set
+-# CONFIG_SCSI_SRP_ATTRS is not set
+-CONFIG_SCSI_LOWLEVEL=y
+-# CONFIG_ISCSI_TCP is not set
+-# CONFIG_LIBFC is not set
+-# CONFIG_LIBFCOE is not set
+-# CONFIG_SCSI_DEBUG is not set
+-# CONFIG_SCSI_DH is not set
+-# CONFIG_SCSI_OSD_INITIATOR is not set
+-# CONFIG_ATA is not set
+-# CONFIG_MD is not set
+-CONFIG_NETDEVICES=y
+-CONFIG_COMPAT_NET_DEV_OPS=y
+-# CONFIG_DUMMY is not set
+-# CONFIG_BONDING is not set
+-# CONFIG_MACVLAN is not set
+-# CONFIG_EQUALIZER is not set
+-CONFIG_TUN=m
+-# CONFIG_VETH is not set
+-CONFIG_PHYLIB=y
+-
+-#
+-# MII PHY device drivers
+-#
+-# CONFIG_MARVELL_PHY is not set
+-# CONFIG_DAVICOM_PHY is not set
+-# CONFIG_QSEMI_PHY is not set
+-CONFIG_LXT_PHY=y
+-# CONFIG_CICADA_PHY is not set
+-# CONFIG_VITESSE_PHY is not set
+-# CONFIG_SMSC_PHY is not set
+-# CONFIG_BROADCOM_PHY is not set
+-# CONFIG_ICPLUS_PHY is not set
+-# CONFIG_REALTEK_PHY is not set
+-# CONFIG_NATIONAL_PHY is not set
+-# CONFIG_STE10XP is not set
+-CONFIG_LSI_ET1011C_PHY=y
+-# CONFIG_FIXED_PHY is not set
+-# CONFIG_MDIO_BITBANG is not set
+-CONFIG_NET_ETHERNET=y
+-CONFIG_MII=y
+-# CONFIG_AX88796 is not set
+-# CONFIG_SMC91X is not set
+-# CONFIG_TI_DAVINCI_EMAC is not set
+-# CONFIG_DM9000 is not set
+-# CONFIG_ETHOC is not set
+-# CONFIG_SMC911X is not set
+-# CONFIG_SMSC911X is not set
+-# CONFIG_DNET is not set
+-# CONFIG_IBM_NEW_EMAC_ZMII is not set
+-# CONFIG_IBM_NEW_EMAC_RGMII is not set
+-# CONFIG_IBM_NEW_EMAC_TAH is not set
+-# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+-# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+-# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+-# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+-# CONFIG_B44 is not set
+-# CONFIG_NETDEV_1000 is not set
+-# CONFIG_NETDEV_10000 is not set
+-
+-#
+-# Wireless LAN
+-#
+-# CONFIG_WLAN_PRE80211 is not set
+-# CONFIG_WLAN_80211 is not set
+-
+-#
+-# Enable WiMAX (Networking options) to see the WiMAX drivers
+-#
+-# CONFIG_WAN is not set
+-# CONFIG_PPP is not set
+-# CONFIG_SLIP is not set
+-CONFIG_NETCONSOLE=y
+-# CONFIG_NETCONSOLE_DYNAMIC is not set
+-CONFIG_NETPOLL=y
+-CONFIG_NETPOLL_TRAP=y
+-CONFIG_NET_POLL_CONTROLLER=y
+-# CONFIG_ISDN is not set
+-
+-#
+-# Input device support
+-#
+-CONFIG_INPUT=y
+-# CONFIG_INPUT_FF_MEMLESS is not set
+-# CONFIG_INPUT_POLLDEV is not set
+-
+-#
+-# Userland interfaces
+-#
+-CONFIG_INPUT_MOUSEDEV=m
+-CONFIG_INPUT_MOUSEDEV_PSAUX=y
+-CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+-CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+-# CONFIG_INPUT_JOYDEV is not set
+-CONFIG_INPUT_EVDEV=m
+-CONFIG_INPUT_EVBUG=m
+-
+-#
+-# Input Device Drivers
+-#
+-CONFIG_INPUT_KEYBOARD=y
+-CONFIG_KEYBOARD_ATKBD=m
+-# CONFIG_KEYBOARD_SUNKBD is not set
+-# CONFIG_KEYBOARD_LKKBD is not set
+-CONFIG_KEYBOARD_XTKBD=m
+-# CONFIG_KEYBOARD_NEWTON is not set
+-# CONFIG_KEYBOARD_STOWAWAY is not set
+-CONFIG_KEYBOARD_GPIO=y
+-# CONFIG_INPUT_MOUSE is not set
+-# CONFIG_INPUT_JOYSTICK is not set
+-# CONFIG_INPUT_TABLET is not set
+-CONFIG_INPUT_TOUCHSCREEN=y
+-# CONFIG_TOUCHSCREEN_AD7879_I2C is not set
+-# CONFIG_TOUCHSCREEN_AD7879 is not set
+-# CONFIG_TOUCHSCREEN_FUJITSU is not set
+-# CONFIG_TOUCHSCREEN_GUNZE is not set
+-# CONFIG_TOUCHSCREEN_ELO is not set
+-# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+-# CONFIG_TOUCHSCREEN_MTOUCH is not set
+-# CONFIG_TOUCHSCREEN_INEXIO is not set
+-# CONFIG_TOUCHSCREEN_MK712 is not set
+-# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+-# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+-# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+-# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+-# CONFIG_TOUCHSCREEN_TSC2007 is not set
+-# CONFIG_INPUT_MISC is not set
+-
+-#
+-# Hardware I/O ports
+-#
+-CONFIG_SERIO=y
+-CONFIG_SERIO_SERPORT=y
+-CONFIG_SERIO_LIBPS2=y
+-# CONFIG_SERIO_RAW is not set
+-# CONFIG_GAMEPORT is not set
+-
+-#
+-# Character devices
+-#
+-CONFIG_VT=y
+-CONFIG_CONSOLE_TRANSLATIONS=y
+-# CONFIG_VT_CONSOLE is not set
+-CONFIG_HW_CONSOLE=y
+-# CONFIG_VT_HW_CONSOLE_BINDING is not set
+-CONFIG_DEVKMEM=y
+-# CONFIG_SERIAL_NONSTANDARD is not set
+-
+-#
+-# Serial drivers
+-#
+-CONFIG_SERIAL_8250=y
+-CONFIG_SERIAL_8250_CONSOLE=y
+-CONFIG_SERIAL_8250_NR_UARTS=3
+-CONFIG_SERIAL_8250_RUNTIME_UARTS=3
+-# CONFIG_SERIAL_8250_EXTENDED is not set
+-
+-#
+-# Non-8250 serial port support
+-#
+-CONFIG_SERIAL_CORE=y
+-CONFIG_SERIAL_CORE_CONSOLE=y
+-CONFIG_UNIX98_PTYS=y
+-# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+-CONFIG_LEGACY_PTYS=y
+-CONFIG_LEGACY_PTY_COUNT=256
+-# CONFIG_IPMI_HANDLER is not set
+-CONFIG_HW_RANDOM=m
+-# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+-# CONFIG_R3964 is not set
+-# CONFIG_RAW_DRIVER is not set
+-# CONFIG_TCG_TPM is not set
+-CONFIG_I2C=y
+-CONFIG_I2C_BOARDINFO=y
+-CONFIG_I2C_CHARDEV=y
+-CONFIG_I2C_HELPER_AUTO=y
+-
+-#
+-# I2C Hardware Bus support
+-#
+-
+-#
+-# I2C system bus drivers (mostly embedded / system-on-chip)
+-#
+-CONFIG_I2C_DAVINCI=y
+-# CONFIG_I2C_GPIO is not set
+-# CONFIG_I2C_OCORES is not set
+-# CONFIG_I2C_SIMTEC is not set
+-
+-#
+-# External I2C/SMBus adapter drivers
+-#
+-# CONFIG_I2C_PARPORT_LIGHT is not set
+-# CONFIG_I2C_TAOS_EVM is not set
+-
+-#
+-# Other I2C/SMBus bus drivers
+-#
+-# CONFIG_I2C_PCA_PLATFORM is not set
+-# CONFIG_I2C_STUB is not set
+-
+-#
+-# Miscellaneous I2C Chip support
+-#
+-# CONFIG_DS1682 is not set
+-# CONFIG_SENSORS_PCA9539 is not set
+-# CONFIG_SENSORS_MAX6875 is not set
+-# CONFIG_SENSORS_TSL2550 is not set
+-# CONFIG_I2C_DEBUG_CORE is not set
+-# CONFIG_I2C_DEBUG_ALGO is not set
+-# CONFIG_I2C_DEBUG_BUS is not set
+-# CONFIG_I2C_DEBUG_CHIP is not set
+-# CONFIG_SPI is not set
+-CONFIG_ARCH_REQUIRE_GPIOLIB=y
+-CONFIG_GPIOLIB=y
+-# CONFIG_DEBUG_GPIO is not set
+-# CONFIG_GPIO_SYSFS is not set
+-
+-#
+-# Memory mapped GPIO expanders:
+-#
+-
+-#
+-# I2C GPIO expanders:
+-#
+-# CONFIG_GPIO_MAX732X is not set
+-# CONFIG_GPIO_PCA953X is not set
+-CONFIG_GPIO_PCF857X=m
+-
+-#
+-# PCI GPIO expanders:
+-#
+-
+-#
+-# SPI GPIO expanders:
+-#
+-# CONFIG_W1 is not set
+-# CONFIG_POWER_SUPPLY is not set
+-# CONFIG_HWMON is not set
+-# CONFIG_THERMAL is not set
+-# CONFIG_THERMAL_HWMON is not set
+-CONFIG_WATCHDOG=y
+-# CONFIG_WATCHDOG_NOWAYOUT is not set
+-
+-#
+-# Watchdog Device Drivers
+-#
+-# CONFIG_SOFT_WATCHDOG is not set
+-# CONFIG_DAVINCI_WATCHDOG is not set
+-CONFIG_SSB_POSSIBLE=y
+-
+-#
+-# Sonics Silicon Backplane
+-#
+-# CONFIG_SSB is not set
+-
+-#
+-# Multifunction device drivers
+-#
+-# CONFIG_MFD_CORE is not set
+-# CONFIG_MFD_SM501 is not set
+-# CONFIG_MFD_ASIC3 is not set
+-# CONFIG_HTC_EGPIO is not set
+-# CONFIG_HTC_PASIC3 is not set
+-# CONFIG_TPS65010 is not set
+-# CONFIG_TWL4030_CORE is not set
+-# CONFIG_MFD_TMIO is not set
+-# CONFIG_MFD_T7L66XB is not set
+-# CONFIG_MFD_TC6387XB is not set
+-# CONFIG_MFD_TC6393XB is not set
+-# CONFIG_PMIC_DA903X is not set
+-# CONFIG_MFD_WM8400 is not set
+-# CONFIG_MFD_WM8350_I2C is not set
+-# CONFIG_MFD_PCF50633 is not set
+-
+-#
+-# Multimedia devices
+-#
+-
+-#
+-# Multimedia core support
+-#
+-# CONFIG_VIDEO_DEV is not set
+-# CONFIG_DVB_CORE is not set
+-# CONFIG_VIDEO_MEDIA is not set
+-
+-#
+-# Multimedia drivers
+-#
+-# CONFIG_DAB is not set
+-
+-#
+-# Graphics support
+-#
+-# CONFIG_VGASTATE is not set
+-# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+-# CONFIG_FB is not set
+-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+-
+-#
+-# Display device support
+-#
+-# CONFIG_DISPLAY_SUPPORT is not set
+-
+-#
+-# Console display driver support
+-#
+-# CONFIG_VGA_CONSOLE is not set
+-CONFIG_DUMMY_CONSOLE=y
+-CONFIG_SOUND=m
+-# CONFIG_SOUND_OSS_CORE is not set
+-CONFIG_SND=m
+-CONFIG_SND_TIMER=m
+-CONFIG_SND_PCM=m
+-CONFIG_SND_JACK=y
+-# CONFIG_SND_SEQUENCER is not set
+-# CONFIG_SND_MIXER_OSS is not set
+-# CONFIG_SND_PCM_OSS is not set
+-# CONFIG_SND_HRTIMER is not set
+-# CONFIG_SND_DYNAMIC_MINORS is not set
+-CONFIG_SND_SUPPORT_OLD_API=y
+-CONFIG_SND_VERBOSE_PROCFS=y
+-# CONFIG_SND_VERBOSE_PRINTK is not set
+-# CONFIG_SND_DEBUG is not set
+-CONFIG_SND_DRIVERS=y
+-# CONFIG_SND_DUMMY is not set
+-# CONFIG_SND_MTPAV is not set
+-# CONFIG_SND_SERIAL_U16550 is not set
+-# CONFIG_SND_MPU401 is not set
+-CONFIG_SND_ARM=y
+-CONFIG_SND_SOC=m
+-CONFIG_SND_DAVINCI_SOC=m
+-CONFIG_SND_SOC_I2C_AND_SPI=m
+-# CONFIG_SND_SOC_ALL_CODECS is not set
+-# CONFIG_SOUND_PRIME is not set
+-# CONFIG_HID_SUPPORT is not set
+-# CONFIG_USB_SUPPORT is not set
+-# CONFIG_MMC is not set
+-# CONFIG_MEMSTICK is not set
+-# CONFIG_ACCESSIBILITY is not set
+-# CONFIG_NEW_LEDS is not set
+-CONFIG_RTC_LIB=y
+-# CONFIG_RTC_CLASS is not set
+-# CONFIG_DMADEVICES is not set
+-# CONFIG_AUXDISPLAY is not set
+-# CONFIG_REGULATOR is not set
+-# CONFIG_UIO is not set
+-# CONFIG_STAGING is not set
+-
+-#
+-# File systems
+-#
+-CONFIG_EXT2_FS=y
+-# CONFIG_EXT2_FS_XATTR is not set
+-# CONFIG_EXT2_FS_XIP is not set
+-CONFIG_EXT3_FS=y
+-# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
+-CONFIG_EXT3_FS_XATTR=y
+-# CONFIG_EXT3_FS_POSIX_ACL is not set
+-# CONFIG_EXT3_FS_SECURITY is not set
+-# CONFIG_EXT4_FS is not set
+-CONFIG_JBD=y
+-# CONFIG_JBD_DEBUG is not set
+-CONFIG_FS_MBCACHE=y
+-# CONFIG_REISERFS_FS is not set
+-# CONFIG_JFS_FS is not set
+-# CONFIG_FS_POSIX_ACL is not set
+-CONFIG_FILE_LOCKING=y
+-CONFIG_XFS_FS=m
+-# CONFIG_XFS_QUOTA is not set
+-# CONFIG_XFS_POSIX_ACL is not set
+-# CONFIG_XFS_RT is not set
+-# CONFIG_XFS_DEBUG is not set
+-# CONFIG_OCFS2_FS is not set
+-# CONFIG_BTRFS_FS is not set
+-CONFIG_DNOTIFY=y
+-CONFIG_INOTIFY=y
+-CONFIG_INOTIFY_USER=y
+-# CONFIG_QUOTA is not set
+-# CONFIG_AUTOFS_FS is not set
+-CONFIG_AUTOFS4_FS=m
+-# CONFIG_FUSE_FS is not set
+-
+-#
+-# Caches
+-#
+-# CONFIG_FSCACHE is not set
+-
+-#
+-# CD-ROM/DVD Filesystems
+-#
+-# CONFIG_ISO9660_FS is not set
+-# CONFIG_UDF_FS is not set
+-
+-#
+-# DOS/FAT/NT Filesystems
+-#
+-CONFIG_FAT_FS=y
+-CONFIG_MSDOS_FS=y
+-CONFIG_VFAT_FS=y
+-CONFIG_FAT_DEFAULT_CODEPAGE=437
+-CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+-# CONFIG_NTFS_FS is not set
+-
+-#
+-# Pseudo filesystems
+-#
+-CONFIG_PROC_FS=y
+-CONFIG_PROC_SYSCTL=y
+-CONFIG_PROC_PAGE_MONITOR=y
+-CONFIG_SYSFS=y
+-CONFIG_TMPFS=y
+-# CONFIG_TMPFS_POSIX_ACL is not set
+-# CONFIG_HUGETLB_PAGE is not set
+-# CONFIG_CONFIGFS_FS is not set
+-CONFIG_MISC_FILESYSTEMS=y
+-# CONFIG_ADFS_FS is not set
+-# CONFIG_AFFS_FS is not set
+-# CONFIG_HFS_FS is not set
+-# CONFIG_HFSPLUS_FS is not set
+-# CONFIG_BEFS_FS is not set
+-# CONFIG_BFS_FS is not set
+-# CONFIG_EFS_FS is not set
+-CONFIG_CRAMFS=y
+-# CONFIG_SQUASHFS is not set
+-# CONFIG_VXFS_FS is not set
+-CONFIG_MINIX_FS=m
+-# CONFIG_OMFS_FS is not set
+-# CONFIG_HPFS_FS is not set
+-# CONFIG_QNX4FS_FS is not set
+-# CONFIG_ROMFS_FS is not set
+-# CONFIG_SYSV_FS is not set
+-# CONFIG_UFS_FS is not set
+-# CONFIG_NILFS2_FS is not set
+-CONFIG_NETWORK_FILESYSTEMS=y
+-CONFIG_NFS_FS=y
+-CONFIG_NFS_V3=y
+-# CONFIG_NFS_V3_ACL is not set
+-# CONFIG_NFS_V4 is not set
+-CONFIG_ROOT_NFS=y
+-CONFIG_NFSD=m
+-CONFIG_NFSD_V3=y
+-# CONFIG_NFSD_V3_ACL is not set
+-# CONFIG_NFSD_V4 is not set
+-CONFIG_LOCKD=y
+-CONFIG_LOCKD_V4=y
+-CONFIG_EXPORTFS=m
+-CONFIG_NFS_COMMON=y
+-CONFIG_SUNRPC=y
+-# CONFIG_RPCSEC_GSS_KRB5 is not set
+-# CONFIG_RPCSEC_GSS_SPKM3 is not set
+-CONFIG_SMB_FS=m
+-# CONFIG_SMB_NLS_DEFAULT is not set
+-# CONFIG_CIFS is not set
+-# CONFIG_NCP_FS is not set
+-# CONFIG_CODA_FS is not set
+-# CONFIG_AFS_FS is not set
+-
+-#
+-# Partition Types
+-#
+-CONFIG_PARTITION_ADVANCED=y
+-# CONFIG_ACORN_PARTITION is not set
+-# CONFIG_OSF_PARTITION is not set
+-# CONFIG_AMIGA_PARTITION is not set
+-# CONFIG_ATARI_PARTITION is not set
+-# CONFIG_MAC_PARTITION is not set
+-CONFIG_MSDOS_PARTITION=y
+-# CONFIG_BSD_DISKLABEL is not set
+-# CONFIG_MINIX_SUBPARTITION is not set
+-# CONFIG_SOLARIS_X86_PARTITION is not set
+-# CONFIG_UNIXWARE_DISKLABEL is not set
+-# CONFIG_LDM_PARTITION is not set
+-# CONFIG_SGI_PARTITION is not set
+-# CONFIG_ULTRIX_PARTITION is not set
+-# CONFIG_SUN_PARTITION is not set
+-# CONFIG_KARMA_PARTITION is not set
+-# CONFIG_EFI_PARTITION is not set
+-# CONFIG_SYSV68_PARTITION is not set
+-CONFIG_NLS=y
+-CONFIG_NLS_DEFAULT="iso8859-1"
+-CONFIG_NLS_CODEPAGE_437=y
+-# CONFIG_NLS_CODEPAGE_737 is not set
+-# CONFIG_NLS_CODEPAGE_775 is not set
+-# CONFIG_NLS_CODEPAGE_850 is not set
+-# CONFIG_NLS_CODEPAGE_852 is not set
+-# CONFIG_NLS_CODEPAGE_855 is not set
+-# CONFIG_NLS_CODEPAGE_857 is not set
+-# CONFIG_NLS_CODEPAGE_860 is not set
+-# CONFIG_NLS_CODEPAGE_861 is not set
+-# CONFIG_NLS_CODEPAGE_862 is not set
+-# CONFIG_NLS_CODEPAGE_863 is not set
+-# CONFIG_NLS_CODEPAGE_864 is not set
+-# CONFIG_NLS_CODEPAGE_865 is not set
+-# CONFIG_NLS_CODEPAGE_866 is not set
+-# CONFIG_NLS_CODEPAGE_869 is not set
+-# CONFIG_NLS_CODEPAGE_936 is not set
+-# CONFIG_NLS_CODEPAGE_950 is not set
+-# CONFIG_NLS_CODEPAGE_932 is not set
+-# CONFIG_NLS_CODEPAGE_949 is not set
+-# CONFIG_NLS_CODEPAGE_874 is not set
+-# CONFIG_NLS_ISO8859_8 is not set
+-# CONFIG_NLS_CODEPAGE_1250 is not set
+-# CONFIG_NLS_CODEPAGE_1251 is not set
+-CONFIG_NLS_ASCII=m
+-CONFIG_NLS_ISO8859_1=y
+-# CONFIG_NLS_ISO8859_2 is not set
+-# CONFIG_NLS_ISO8859_3 is not set
+-# CONFIG_NLS_ISO8859_4 is not set
+-# CONFIG_NLS_ISO8859_5 is not set
+-# CONFIG_NLS_ISO8859_6 is not set
+-# CONFIG_NLS_ISO8859_7 is not set
+-# CONFIG_NLS_ISO8859_9 is not set
+-# CONFIG_NLS_ISO8859_13 is not set
+-# CONFIG_NLS_ISO8859_14 is not set
+-# CONFIG_NLS_ISO8859_15 is not set
+-# CONFIG_NLS_KOI8_R is not set
+-# CONFIG_NLS_KOI8_U is not set
+-CONFIG_NLS_UTF8=m
+-# CONFIG_DLM is not set
+-
+-#
+-# Kernel hacking
+-#
+-# CONFIG_PRINTK_TIME is not set
+-CONFIG_ENABLE_WARN_DEPRECATED=y
+-CONFIG_ENABLE_MUST_CHECK=y
+-CONFIG_FRAME_WARN=1024
+-# CONFIG_MAGIC_SYSRQ is not set
+-# CONFIG_UNUSED_SYMBOLS is not set
+-CONFIG_DEBUG_FS=y
+-# CONFIG_HEADERS_CHECK is not set
+-CONFIG_DEBUG_KERNEL=y
+-# CONFIG_DEBUG_SHIRQ is not set
+-CONFIG_DETECT_SOFTLOCKUP=y
+-# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
+-CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+-CONFIG_DETECT_HUNG_TASK=y
+-# CONFIG_BOOTPARAM_HUNG_TASK_PANIC is not set
+-CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=0
+-CONFIG_SCHED_DEBUG=y
+-# CONFIG_SCHEDSTATS is not set
+-CONFIG_TIMER_STATS=y
+-# CONFIG_DEBUG_OBJECTS is not set
+-# CONFIG_SLUB_DEBUG_ON is not set
+-# CONFIG_SLUB_STATS is not set
+-CONFIG_DEBUG_PREEMPT=y
+-CONFIG_DEBUG_RT_MUTEXES=y
+-CONFIG_DEBUG_PI_LIST=y
+-# CONFIG_RT_MUTEX_TESTER is not set
+-# CONFIG_DEBUG_SPINLOCK is not set
+-CONFIG_DEBUG_MUTEXES=y
+-# CONFIG_DEBUG_LOCK_ALLOC is not set
+-# CONFIG_PROVE_LOCKING is not set
+-# CONFIG_LOCK_STAT is not set
+-# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+-# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+-# CONFIG_DEBUG_KOBJECT is not set
+-CONFIG_DEBUG_BUGVERBOSE=y
+-# CONFIG_DEBUG_INFO is not set
+-# CONFIG_DEBUG_VM is not set
+-# CONFIG_DEBUG_WRITECOUNT is not set
+-# CONFIG_DEBUG_MEMORY_INIT is not set
+-# CONFIG_DEBUG_LIST is not set
+-# CONFIG_DEBUG_SG is not set
+-# CONFIG_DEBUG_NOTIFIERS is not set
+-# CONFIG_BOOT_PRINTK_DELAY is not set
+-# CONFIG_RCU_TORTURE_TEST is not set
+-# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+-# CONFIG_BACKTRACE_SELF_TEST is not set
+-# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+-# CONFIG_FAULT_INJECTION is not set
+-# CONFIG_LATENCYTOP is not set
+-# CONFIG_SYSCTL_SYSCALL_CHECK is not set
+-# CONFIG_PAGE_POISONING is not set
+-CONFIG_HAVE_FUNCTION_TRACER=y
+-CONFIG_TRACING_SUPPORT=y
+-
+-#
+-# Tracers
+-#
+-# CONFIG_FUNCTION_TRACER is not set
+-# CONFIG_IRQSOFF_TRACER is not set
+-# CONFIG_PREEMPT_TRACER is not set
+-# CONFIG_SCHED_TRACER is not set
+-# CONFIG_CONTEXT_SWITCH_TRACER is not set
+-# CONFIG_EVENT_TRACER is not set
+-# CONFIG_BOOT_TRACER is not set
+-# CONFIG_TRACE_BRANCH_PROFILING is not set
+-# CONFIG_STACK_TRACER is not set
+-# CONFIG_KMEMTRACE is not set
+-# CONFIG_WORKQUEUE_TRACER is not set
+-# CONFIG_BLK_DEV_IO_TRACE is not set
+-# CONFIG_DYNAMIC_DEBUG is not set
+-# CONFIG_SAMPLES is not set
+-CONFIG_HAVE_ARCH_KGDB=y
+-# CONFIG_KGDB is not set
+-CONFIG_ARM_UNWIND=y
+-CONFIG_DEBUG_USER=y
+-CONFIG_DEBUG_ERRORS=y
+-# CONFIG_DEBUG_STACK_USAGE is not set
+-# CONFIG_DEBUG_LL is not set
+-
+-#
+-# Security options
+-#
+-# CONFIG_KEYS is not set
+-# CONFIG_SECURITY is not set
+-# CONFIG_SECURITYFS is not set
+-# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+-CONFIG_CRYPTO=y
+-
+-#
+-# Crypto core or helper
+-#
+-# CONFIG_CRYPTO_FIPS is not set
+-# CONFIG_CRYPTO_MANAGER is not set
+-# CONFIG_CRYPTO_MANAGER2 is not set
+-# CONFIG_CRYPTO_GF128MUL is not set
+-# CONFIG_CRYPTO_NULL is not set
+-# CONFIG_CRYPTO_CRYPTD is not set
+-# CONFIG_CRYPTO_AUTHENC is not set
+-# CONFIG_CRYPTO_TEST is not set
+-
+-#
+-# Authenticated Encryption with Associated Data
+-#
+-# CONFIG_CRYPTO_CCM is not set
+-# CONFIG_CRYPTO_GCM is not set
+-# CONFIG_CRYPTO_SEQIV is not set
+-
+-#
+-# Block modes
+-#
+-# CONFIG_CRYPTO_CBC is not set
+-# CONFIG_CRYPTO_CTR is not set
+-# CONFIG_CRYPTO_CTS is not set
+-# CONFIG_CRYPTO_ECB is not set
+-# CONFIG_CRYPTO_LRW is not set
+-# CONFIG_CRYPTO_PCBC is not set
+-# CONFIG_CRYPTO_XTS is not set
+-
+-#
+-# Hash modes
+-#
+-# CONFIG_CRYPTO_HMAC is not set
+-# CONFIG_CRYPTO_XCBC is not set
+-
+-#
+-# Digest
+-#
+-# CONFIG_CRYPTO_CRC32C is not set
+-# CONFIG_CRYPTO_MD4 is not set
+-# CONFIG_CRYPTO_MD5 is not set
+-# CONFIG_CRYPTO_MICHAEL_MIC is not set
+-# CONFIG_CRYPTO_RMD128 is not set
+-# CONFIG_CRYPTO_RMD160 is not set
+-# CONFIG_CRYPTO_RMD256 is not set
+-# CONFIG_CRYPTO_RMD320 is not set
+-# CONFIG_CRYPTO_SHA1 is not set
+-# CONFIG_CRYPTO_SHA256 is not set
+-# CONFIG_CRYPTO_SHA512 is not set
+-# CONFIG_CRYPTO_TGR192 is not set
+-# CONFIG_CRYPTO_WP512 is not set
+-
+-#
+-# Ciphers
+-#
+-# CONFIG_CRYPTO_AES is not set
+-# CONFIG_CRYPTO_ANUBIS is not set
+-# CONFIG_CRYPTO_ARC4 is not set
+-# CONFIG_CRYPTO_BLOWFISH is not set
+-# CONFIG_CRYPTO_CAMELLIA is not set
+-# CONFIG_CRYPTO_CAST5 is not set
+-# CONFIG_CRYPTO_CAST6 is not set
+-# CONFIG_CRYPTO_DES is not set
+-# CONFIG_CRYPTO_FCRYPT is not set
+-# CONFIG_CRYPTO_KHAZAD is not set
+-# CONFIG_CRYPTO_SALSA20 is not set
+-# CONFIG_CRYPTO_SEED is not set
+-# CONFIG_CRYPTO_SERPENT is not set
+-# CONFIG_CRYPTO_TEA is not set
+-# CONFIG_CRYPTO_TWOFISH is not set
+-
+-#
+-# Compression
+-#
+-# CONFIG_CRYPTO_DEFLATE is not set
+-# CONFIG_CRYPTO_ZLIB is not set
+-# CONFIG_CRYPTO_LZO is not set
+-
+-#
+-# Random Number Generation
+-#
+-# CONFIG_CRYPTO_ANSI_CPRNG is not set
+-# CONFIG_CRYPTO_HW is not set
+-# CONFIG_BINARY_PRINTF is not set
+-
+-#
+-# Library routines
+-#
+-CONFIG_BITREVERSE=y
+-CONFIG_GENERIC_FIND_LAST_BIT=y
+-CONFIG_CRC_CCITT=m
+-# CONFIG_CRC16 is not set
+-CONFIG_CRC_T10DIF=m
+-# CONFIG_CRC_ITU_T is not set
+-CONFIG_CRC32=y
+-# CONFIG_CRC7 is not set
+-# CONFIG_LIBCRC32C is not set
+-CONFIG_ZLIB_INFLATE=y
+-CONFIG_DECOMPRESS_GZIP=y
+-CONFIG_GENERIC_ALLOCATOR=y
+-CONFIG_HAS_IOMEM=y
+-CONFIG_HAS_IOPORT=y
+-CONFIG_HAS_DMA=y
+-CONFIG_NLATTR=y
+--- a/arch/arm/boot/compressed/head.S
++++ b/arch/arm/boot/compressed/head.S
+@@ -412,7 +412,11 @@ __setup_mmu:	sub	r3, r4, #16384		@ Page
+ 		orr	r1, r1, #3 << 10
+ 		add	r2, r3, #16384
+ 1:		cmp	r1, r9			@ if virt > start of RAM
++#ifdef CONFIG_CPU_DCACHE_WRITETHROUGH
++		orrhs	r1, r1, #0x08		@ set cacheable
++#else
+ 		orrhs	r1, r1, #0x0c		@ set cacheable, bufferable
++#endif
+ 		cmp	r1, r10			@ if virt > end of RAM
+ 		bichs	r1, r1, #0x0c		@ clear cacheable, bufferable
+ 		str	r1, [r0], #4		@ 1:1 mapping
+@@ -436,6 +440,11 @@ __setup_mmu:	sub	r3, r4, #16384		@ Page
+ 		mov	pc, lr
+ ENDPROC(__setup_mmu)
+ 
++__arm926ejs_mmu_cache_on:
++#ifdef CONFIG_CPU_DCACHE_WRITETHROUGH
++		mov	r0, #4			@ put dcache in WT mode
++		mcr	p15, 7, r0, c15, c0, 0
++#endif
+ __armv4_mmu_cache_on:
+ 		mov	r12, lr
+ #ifdef CONFIG_MMU
+@@ -654,6 +663,12 @@ proc_types:
+ 		W(b)	__armv4_mpu_cache_off
+ 		W(b)	__armv4_mpu_cache_flush
+ 
++		.word	0x41069260		@ ARM926EJ-S (v5TEJ)
++		.word	0xff0ffff0
++		b	__arm926ejs_mmu_cache_on
++		b	__armv4_mmu_cache_off
++		b	__armv5tej_mmu_cache_flush
++
+ 		.word	0x00007000		@ ARM7 IDs
+ 		.word	0x0000f000
+ 		mov	pc, lr
+--- a/drivers/media/video/mt9t031.c
++++ b/drivers/media/video/mt9t031.c
+@@ -13,13 +13,13 @@
+ #include <linux/i2c.h>
+ #include <linux/log2.h>
+ 
+-#include <media/v4l2-subdev.h>
++#include <media/v4l2-device.h>
++#include <media/v4l2-common.h>
+ #include <media/v4l2-chip-ident.h>
+-#include <media/soc_camera.h>
+ 
+ /* mt9t031 i2c address 0x5d
+- * The platform has to define i2c_board_info and link to it from
+- * struct soc_camera_link */
++ * The platform has to define i2c_board_info
++ * and call i2c_register_board_info() */
+ 
+ /* mt9t031 selected register addresses */
+ #define MT9T031_CHIP_VERSION		0x00
+@@ -47,45 +47,113 @@
+ #define MT9T031_MAX_HEIGHT		1536
+ #define MT9T031_MAX_WIDTH		2048
+ #define MT9T031_MIN_HEIGHT		2
+-#define MT9T031_MIN_WIDTH		18
++#define MT9T031_MIN_WIDTH		2
+ #define MT9T031_HORIZONTAL_BLANK	142
+ #define MT9T031_VERTICAL_BLANK		25
+ #define MT9T031_COLUMN_SKIP		32
+ #define MT9T031_ROW_SKIP		20
++#define MT9T031_DEFAULT_WIDTH		640
++#define MT9T031_DEFAULT_HEIGHT		480
+ 
+ #define MT9T031_BUS_PARAM	(SOCAM_PCLK_SAMPLE_RISING |	\
+ 	SOCAM_PCLK_SAMPLE_FALLING | SOCAM_HSYNC_ACTIVE_HIGH |	\
+ 	SOCAM_VSYNC_ACTIVE_HIGH | SOCAM_DATA_ACTIVE_HIGH |	\
+ 	SOCAM_MASTER | SOCAM_DATAWIDTH_10)
+ 
+-static const struct soc_camera_data_format mt9t031_colour_formats[] = {
++
++/* Debug functions */
++static int debug;
++module_param(debug, bool, 0644);
++MODULE_PARM_DESC(debug, "Debug level (0-1)");
++
++static const struct v4l2_fmtdesc mt9t031_formats[] = {
++	{
++		.index = 0,
++		.type = V4L2_BUF_TYPE_VIDEO_CAPTURE,
++		.description = "Bayer (sRGB) 10 bit",
++		.pixelformat = V4L2_PIX_FMT_SGRBG10,
++	},
++};
++static const unsigned int mt9t031_num_formats = ARRAY_SIZE(mt9t031_formats);
++
++static const struct v4l2_queryctrl mt9t031_controls[] = {
+ 	{
+-		.name		= "Bayer (sRGB) 10 bit",
+-		.depth		= 10,
+-		.fourcc		= V4L2_PIX_FMT_SGRBG10,
+-		.colorspace	= V4L2_COLORSPACE_SRGB,
++		.id		= V4L2_CID_VFLIP,
++		.type		= V4L2_CTRL_TYPE_BOOLEAN,
++		.name		= "Flip Vertically",
++		.minimum	= 0,
++		.maximum	= 1,
++		.step		= 1,
++		.default_value	= 0,
++	}, {
++		.id		= V4L2_CID_HFLIP,
++		.type		= V4L2_CTRL_TYPE_BOOLEAN,
++		.name		= "Flip Horizontally",
++		.minimum	= 0,
++		.maximum	= 1,
++		.step		= 1,
++		.default_value	= 0,
++	}, {
++		.id		= V4L2_CID_GAIN,
++		.type		= V4L2_CTRL_TYPE_INTEGER,
++		.name		= "Gain",
++		.minimum	= 0,
++		.maximum	= 127,
++		.step		= 1,
++		.default_value	= 64,
++		.flags		= V4L2_CTRL_FLAG_SLIDER,
++	}, {
++		.id		= V4L2_CID_EXPOSURE,
++		.type		= V4L2_CTRL_TYPE_INTEGER,
++		.name		= "Exposure",
++		.minimum	= 1,
++		.maximum	= 255,
++		.step		= 1,
++		.default_value	= 255,
++		.flags		= V4L2_CTRL_FLAG_SLIDER,
++	}, {
++		.id		= V4L2_CID_EXPOSURE_AUTO,
++		.type		= V4L2_CTRL_TYPE_BOOLEAN,
++		.name		= "Automatic Exposure",
++		.minimum	= 0,
++		.maximum	= 1,
++		.step		= 1,
++		.default_value	= 1,
+ 	}
+ };
++static const unsigned int mt9t031_num_controls = ARRAY_SIZE(mt9t031_controls);
+ 
+ struct mt9t031 {
+-	struct v4l2_subdev subdev;
+-	struct v4l2_rect rect;	/* Sensor window */
++	struct v4l2_subdev sd;
+ 	int model;	/* V4L2_IDENT_MT9T031* codes from v4l2-chip-ident.h */
++	unsigned char autoexposure;
+ 	u16 xskip;
+ 	u16 yskip;
+-	unsigned int gain;
+-	unsigned int exposure;
+-	unsigned char autoexposure;
++	u32 width;
++	u32 height;
++	unsigned short x_min;           /* Camera capabilities */
++	unsigned short y_min;
++	unsigned short x_current;       /* Current window location */
++	unsigned short y_current;
++	unsigned short width_min;
++	unsigned short width_max;
++	unsigned short height_min;
++	unsigned short height_max;
++	unsigned short y_skip_top;      /* Lines to skip at the top */
++	unsigned short gain;
++	unsigned short exposure;
+ };
+ 
+-static struct mt9t031 *to_mt9t031(const struct i2c_client *client)
++static inline struct mt9t031 *to_mt9t031(struct v4l2_subdev *sd)
+ {
+-	return container_of(i2c_get_clientdata(client), struct mt9t031, subdev);
++	return container_of(sd, struct mt9t031, sd);
+ }
+ 
+ static int reg_read(struct i2c_client *client, const u8 reg)
+ {
+-	s32 data = i2c_smbus_read_word_data(client, reg);
++	s32 data;
++
++	data = i2c_smbus_read_word_data(client, reg);
+ 	return data < 0 ? data : swab16(data);
+ }
+ 
+@@ -117,8 +185,9 @@ static int reg_clear(struct i2c_client *
+ 	return reg_write(client, reg, ret & ~data);
+ }
+ 
+-static int set_shutter(struct i2c_client *client, const u32 data)
++static int set_shutter(struct v4l2_subdev *sd, const u32 data)
+ {
++	struct i2c_client *client = v4l2_get_subdevdata(sd);
+ 	int ret;
+ 
+ 	ret = reg_write(client, MT9T031_SHUTTER_WIDTH_UPPER, data >> 16);
+@@ -129,9 +198,10 @@ static int set_shutter(struct i2c_client
+ 	return ret;
+ }
+ 
+-static int get_shutter(struct i2c_client *client, u32 *data)
++static int get_shutter(struct v4l2_subdev *sd, u32 *data)
+ {
+ 	int ret;
++	struct i2c_client *client = v4l2_get_subdevdata(sd);
+ 
+ 	ret = reg_read(client, MT9T031_SHUTTER_WIDTH_UPPER);
+ 	*data = ret << 16;
+@@ -143,9 +213,10 @@ static int get_shutter(struct i2c_client
+ 	return ret < 0 ? ret : 0;
+ }
+ 
+-static int mt9t031_idle(struct i2c_client *client)
++static int mt9t031_init(struct v4l2_subdev *sd, u32 val)
+ {
+ 	int ret;
++	struct i2c_client *client = v4l2_get_subdevdata(sd);
+ 
+ 	/* Disable chip output, synchronous option update */
+ 	ret = reg_write(client, MT9T031_RESET, 1);
+@@ -157,117 +228,93 @@ static int mt9t031_idle(struct i2c_clien
+ 	return ret >= 0 ? 0 : -EIO;
+ }
+ 
+-static int mt9t031_disable(struct i2c_client *client)
+-{
+-	/* Disable the chip */
+-	reg_clear(client, MT9T031_OUTPUT_CONTROL, 2);
+-
+-	return 0;
+-}
+-
+ static int mt9t031_s_stream(struct v4l2_subdev *sd, int enable)
+ {
+-	struct i2c_client *client = sd->priv;
+-	int ret;
+-
+-	if (enable)
+-		/* Switch to master "normal" mode */
+-		ret = reg_set(client, MT9T031_OUTPUT_CONTROL, 2);
+-	else
+-		/* Stop sensor readout */
+-		ret = reg_clear(client, MT9T031_OUTPUT_CONTROL, 2);
+-
+-	if (ret < 0)
+-		return -EIO;
+-
+-	return 0;
+-}
+-
+-static int mt9t031_set_bus_param(struct soc_camera_device *icd,
+-				 unsigned long flags)
+-{
+-	struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
+-
+-	/* The caller should have queried our parameters, check anyway */
+-	if (flags & ~MT9T031_BUS_PARAM)
+-		return -EINVAL;
+-
+-	if (flags & SOCAM_PCLK_SAMPLE_FALLING)
+-		reg_clear(client, MT9T031_PIXEL_CLOCK_CONTROL, 0x8000);
+-	else
+-		reg_set(client, MT9T031_PIXEL_CLOCK_CONTROL, 0x8000);
++	struct i2c_client *client = v4l2_get_subdevdata(sd);
+ 
++	/* Switch to master "normal" mode */
++	if (enable) {
++		if (reg_set(client, MT9T031_OUTPUT_CONTROL, 2) < 0)
++			return -EIO;
++	} else {
++	/* Switch to master "" mode */
++		if (reg_clear(client, MT9T031_OUTPUT_CONTROL, 2) < 0)
++			return -EIO;
++	}
+ 	return 0;
+ }
+ 
+-static unsigned long mt9t031_query_bus_param(struct soc_camera_device *icd)
++/* Round up minima and round down maxima */
++static void recalculate_limits(struct mt9t031 *mt9t031,
++			       u16 xskip, u16 yskip)
+ {
+-	struct soc_camera_link *icl = to_soc_camera_link(icd);
+-
+-	return soc_camera_apply_sensor_flags(icl, MT9T031_BUS_PARAM);
++	mt9t031->x_min = (MT9T031_COLUMN_SKIP + xskip - 1) / xskip;
++	mt9t031->y_min = (MT9T031_ROW_SKIP + yskip - 1) / yskip;
++	mt9t031->width_min = (MT9T031_MIN_WIDTH + xskip - 1) / xskip;
++	mt9t031->height_min = (MT9T031_MIN_HEIGHT + yskip - 1) / yskip;
++	mt9t031->width_max = MT9T031_MAX_WIDTH / xskip;
++	mt9t031->height_max = MT9T031_MAX_HEIGHT / yskip;
+ }
+ 
+-/* target must be _even_ */
+-static u16 mt9t031_skip(s32 *source, s32 target, s32 max)
++const struct v4l2_queryctrl *mt9t031_find_qctrl(u32 id)
+ {
+-	unsigned int skip;
++	int i;
+ 
+-	if (*source < target + target / 2) {
+-		*source = target;
+-		return 1;
++	for (i = 0; i < mt9t031_num_controls; i++) {
++		if (mt9t031_controls[i].id == id)
++			return &mt9t031_controls[i];
+ 	}
+-
+-	skip = min(max, *source + target / 2) / target;
+-	if (skip > 8)
+-		skip = 8;
+-	*source = target * skip;
+-
+-	return skip;
++	return NULL;
+ }
+ 
+-/* rect is the sensor rectangle, the caller guarantees parameter validity */
+-static int mt9t031_set_params(struct soc_camera_device *icd,
++static int mt9t031_set_params(struct v4l2_subdev *sd,
+ 			      struct v4l2_rect *rect, u16 xskip, u16 yskip)
+ {
+-	struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
+-	struct mt9t031 *mt9t031 = to_mt9t031(client);
++	struct mt9t031 *mt9t031 = to_mt9t031(sd);
++	struct i2c_client *client = v4l2_get_subdevdata(sd);
++
+ 	int ret;
+-	u16 xbin, ybin;
++	u16 xbin, ybin, width, height, left, top;
+ 	const u16 hblank = MT9T031_HORIZONTAL_BLANK,
+ 		vblank = MT9T031_VERTICAL_BLANK;
+ 
++	/* Make sure we don't exceed sensor limits */
++	if (rect->left + rect->width > mt9t031->width_max)
++		rect->left =
++		(mt9t031->width_max - rect->width) / 2 + mt9t031->x_min;
++
++	if (rect->top + rect->height > mt9t031->height_max)
++		rect->top =
++		(mt9t031->height_max - rect->height) / 2 + mt9t031->y_min;
++
++	width = rect->width * xskip;
++	height = rect->height * yskip;
++	left = rect->left * xskip;
++	top = rect->top * yskip;
++
+ 	xbin = min(xskip, (u16)3);
+ 	ybin = min(yskip, (u16)3);
+ 
+-	/*
+-	 * Could just do roundup(rect->left, [xy]bin * 2); but this is cheaper.
+-	 * There is always a valid suitably aligned value. The worst case is
+-	 * xbin = 3, width = 2048. Then we will start at 36, the last read out
+-	 * pixel will be 2083, which is < 2085 - first black pixel.
+-	 *
+-	 * MT9T031 datasheet imposes window left border alignment, depending on
+-	 * the selected xskip. Failing to conform to this requirement produces
+-	 * dark horizontal stripes in the image. However, even obeying to this
+-	 * requirement doesn't eliminate the stripes in all configurations. They
+-	 * appear "locally reproducibly," but can differ between tests under
+-	 * different lighting conditions.
+-	 */
++	v4l2_dbg(1, debug, sd, "xskip %u, width %u/%u, yskip %u,"
++		"height %u/%u\n", xskip, width, rect->width, yskip,
++		height, rect->height);
++
++	/* Could just do roundup(rect->left, [xy]bin * 2); but this is cheaper */
+ 	switch (xbin) {
+-	case 1:
+-		rect->left &= ~1;
+-		break;
+ 	case 2:
+-		rect->left &= ~3;
++		left = (left + 3) & ~3;
+ 		break;
+ 	case 3:
+-		rect->left = rect->left > roundup(MT9T031_COLUMN_SKIP, 6) ?
+-			(rect->left / 6) * 6 : roundup(MT9T031_COLUMN_SKIP, 6);
++		left = roundup(left, 6);
+ 	}
+ 
+-	rect->top &= ~1;
+-
+-	dev_dbg(&client->dev, "skip %u:%u, rect %ux%u@%u:%u\n",
+-		xskip, yskip, rect->width, rect->height, rect->left, rect->top);
++	switch (ybin) {
++	case 2:
++		top = (top + 3) & ~3;
++		break;
++	case 3:
++		top = roundup(top, 6);
++	}
+ 
+ 	/* Disable register update, reconfigure atomically */
+ 	ret = reg_set(client, MT9T031_OUTPUT_CONTROL, 1);
+@@ -288,146 +335,105 @@ static int mt9t031_set_params(struct soc
+ 			ret = reg_write(client, MT9T031_ROW_ADDRESS_MODE,
+ 					((ybin - 1) << 4) | (yskip - 1));
+ 	}
+-	dev_dbg(&client->dev, "new physical left %u, top %u\n",
+-		rect->left, rect->top);
++	v4l2_dbg(1, debug, sd, "new physical left %u, top %u\n", left, top);
+ 
+ 	/* The caller provides a supported format, as guaranteed by
+ 	 * icd->try_fmt_cap(), soc_camera_s_crop() and soc_camera_cropcap() */
+ 	if (ret >= 0)
+-		ret = reg_write(client, MT9T031_COLUMN_START, rect->left);
++		ret = reg_write(client, MT9T031_COLUMN_START, left);
+ 	if (ret >= 0)
+-		ret = reg_write(client, MT9T031_ROW_START, rect->top);
++		ret = reg_write(client, MT9T031_ROW_START, top);
+ 	if (ret >= 0)
+-		ret = reg_write(client, MT9T031_WINDOW_WIDTH, rect->width - 1);
++		ret = reg_write(client, MT9T031_WINDOW_WIDTH, width - 1);
+ 	if (ret >= 0)
+ 		ret = reg_write(client, MT9T031_WINDOW_HEIGHT,
+-				rect->height + icd->y_skip_top - 1);
++				height + mt9t031->y_skip_top - 1);
+ 	if (ret >= 0 && mt9t031->autoexposure) {
+-		unsigned int total_h = rect->height + icd->y_skip_top + vblank;
+-		ret = set_shutter(client, total_h);
++		ret = set_shutter(sd, height + mt9t031->y_skip_top + vblank);
+ 		if (ret >= 0) {
+ 			const u32 shutter_max = MT9T031_MAX_HEIGHT + vblank;
+ 			const struct v4l2_queryctrl *qctrl =
+-				soc_camera_find_qctrl(icd->ops,
+-						      V4L2_CID_EXPOSURE);
+-			mt9t031->exposure = (shutter_max / 2 + (total_h - 1) *
+-				 (qctrl->maximum - qctrl->minimum)) /
++				mt9t031_find_qctrl(V4L2_CID_EXPOSURE);
++			mt9t031->exposure = (shutter_max / 2 + (height +
++					 mt9t031->y_skip_top + vblank - 1) *
++					 (qctrl->maximum - qctrl->minimum)) /
+ 				shutter_max + qctrl->minimum;
+ 		}
+ 	}
+ 
+ 	/* Re-enable register update, commit all changes */
+-	if (ret >= 0)
+-		ret = reg_clear(client, MT9T031_OUTPUT_CONTROL, 1);
+-
+ 	if (ret >= 0) {
+-		mt9t031->rect = *rect;
+-		mt9t031->xskip = xskip;
+-		mt9t031->yskip = yskip;
++		ret = reg_clear(client, MT9T031_OUTPUT_CONTROL, 1);
++		/* update the values */
++		mt9t031->width	= rect->width,
++		mt9t031->height	= rect->height,
++		mt9t031->x_current = rect->left;
++		mt9t031->y_current = rect->top;
+ 	}
+-
+ 	return ret < 0 ? ret : 0;
+ }
+ 
+-static int mt9t031_s_crop(struct v4l2_subdev *sd, struct v4l2_crop *a)
+-{
+-	struct v4l2_rect rect = a->c;
+-	struct i2c_client *client = sd->priv;
+-	struct mt9t031 *mt9t031 = to_mt9t031(client);
+-	struct soc_camera_device *icd = client->dev.platform_data;
+-
+-	rect.width = ALIGN(rect.width, 2);
+-	rect.height = ALIGN(rect.height, 2);
+-
+-	soc_camera_limit_side(&rect.left, &rect.width,
+-		     MT9T031_COLUMN_SKIP, MT9T031_MIN_WIDTH, MT9T031_MAX_WIDTH);
+-
+-	soc_camera_limit_side(&rect.top, &rect.height,
+-		     MT9T031_ROW_SKIP, MT9T031_MIN_HEIGHT, MT9T031_MAX_HEIGHT);
+-
+-	return mt9t031_set_params(icd, &rect, mt9t031->xskip, mt9t031->yskip);
+-}
+-
+-static int mt9t031_g_crop(struct v4l2_subdev *sd, struct v4l2_crop *a)
+-{
+-	struct i2c_client *client = sd->priv;
+-	struct mt9t031 *mt9t031 = to_mt9t031(client);
+-
+-	a->c	= mt9t031->rect;
+-	a->type	= V4L2_BUF_TYPE_VIDEO_CAPTURE;
+-
+-	return 0;
+-}
+-
+-static int mt9t031_cropcap(struct v4l2_subdev *sd, struct v4l2_cropcap *a)
+-{
+-	a->bounds.left			= MT9T031_COLUMN_SKIP;
+-	a->bounds.top			= MT9T031_ROW_SKIP;
+-	a->bounds.width			= MT9T031_MAX_WIDTH;
+-	a->bounds.height		= MT9T031_MAX_HEIGHT;
+-	a->defrect			= a->bounds;
+-	a->type				= V4L2_BUF_TYPE_VIDEO_CAPTURE;
+-	a->pixelaspect.numerator	= 1;
+-	a->pixelaspect.denominator	= 1;
+-
+-	return 0;
+-}
+-
+-static int mt9t031_g_fmt(struct v4l2_subdev *sd, struct v4l2_format *f)
++static int mt9t031_set_fmt(struct v4l2_subdev *sd,
++			   struct v4l2_format *f)
+ {
+-	struct i2c_client *client = sd->priv;
+-	struct mt9t031 *mt9t031 = to_mt9t031(client);
+-	struct v4l2_pix_format *pix = &f->fmt.pix;
+-
+-	pix->width		= mt9t031->rect.width / mt9t031->xskip;
+-	pix->height		= mt9t031->rect.height / mt9t031->yskip;
+-	pix->pixelformat	= V4L2_PIX_FMT_SGRBG10;
+-	pix->field		= V4L2_FIELD_NONE;
+-	pix->colorspace		= V4L2_COLORSPACE_SRGB;
+-
+-	return 0;
+-}
+-
+-static int mt9t031_s_fmt(struct v4l2_subdev *sd, struct v4l2_format *f)
+-{
+-	struct i2c_client *client = sd->priv;
+-	struct mt9t031 *mt9t031 = to_mt9t031(client);
+-	struct soc_camera_device *icd = client->dev.platform_data;
+-	struct v4l2_pix_format *pix = &f->fmt.pix;
++	struct mt9t031 *mt9t031 = to_mt9t031(sd);
++	int ret;
+ 	u16 xskip, yskip;
+-	struct v4l2_rect rect = mt9t031->rect;
++	struct v4l2_rect rect = {
++		.left	= mt9t031->x_current,
++		.top	= mt9t031->y_current,
++		.width	= f->fmt.pix.width,
++		.height	= f->fmt.pix.height,
++	};
+ 
+ 	/*
+-	 * try_fmt has put width and height within limits.
+-	 * S_FMT: use binning and skipping for scaling
++	 * try_fmt has put rectangle within limits.
++	 * S_FMT - use binning and skipping for scaling, recalculate
++	 * limits, used for cropping
+ 	 */
+-	xskip = mt9t031_skip(&rect.width, pix->width, MT9T031_MAX_WIDTH);
+-	yskip = mt9t031_skip(&rect.height, pix->height, MT9T031_MAX_HEIGHT);
++	/* Is this more optimal than just a division? */
++	for (xskip = 8; xskip > 1; xskip--)
++		if (rect.width * xskip <= MT9T031_MAX_WIDTH)
++			break;
++
++	for (yskip = 8; yskip > 1; yskip--)
++		if (rect.height * yskip <= MT9T031_MAX_HEIGHT)
++			break;
++
++	recalculate_limits(mt9t031, xskip, yskip);
+ 
+-	/* mt9t031_set_params() doesn't change width and height */
+-	return mt9t031_set_params(icd, &rect, xskip, yskip);
++	ret = mt9t031_set_params(sd, &rect, xskip, yskip);
++	if (!ret) {
++		mt9t031->xskip = xskip;
++		mt9t031->yskip = yskip;
++	}
++	return ret;
+ }
+ 
+-/*
+- * If a user window larger than sensor window is requested, we'll increase the
+- * sensor window.
+- */
+-static int mt9t031_try_fmt(struct v4l2_subdev *sd, struct v4l2_format *f)
++static int mt9t031_try_fmt(struct v4l2_subdev *sd,
++			   struct v4l2_format *f)
+ {
+ 	struct v4l2_pix_format *pix = &f->fmt.pix;
+ 
+-	v4l_bound_align_image(
+-		&pix->width, MT9T031_MIN_WIDTH, MT9T031_MAX_WIDTH, 1,
+-		&pix->height, MT9T031_MIN_HEIGHT, MT9T031_MAX_HEIGHT, 1, 0);
++	if (pix->height < MT9T031_MIN_HEIGHT)
++		pix->height = MT9T031_MIN_HEIGHT;
++	if (pix->height > MT9T031_MAX_HEIGHT)
++		pix->height = MT9T031_MAX_HEIGHT;
++	if (pix->width < MT9T031_MIN_WIDTH)
++		pix->width = MT9T031_MIN_WIDTH;
++	if (pix->width > MT9T031_MAX_WIDTH)
++		pix->width = MT9T031_MAX_WIDTH;
+ 
++	pix->width &= ~0x01; /* has to be even */
++	pix->height &= ~0x01; /* has to be even */
+ 	return 0;
+ }
+ 
+-static int mt9t031_g_chip_ident(struct v4l2_subdev *sd,
+-				struct v4l2_dbg_chip_ident *id)
++static int mt9t031_get_chip_id(struct v4l2_subdev *sd,
++			       struct v4l2_dbg_chip_ident *id)
+ {
+-	struct i2c_client *client = sd->priv;
+-	struct mt9t031 *mt9t031 = to_mt9t031(client);
++	struct mt9t031 *mt9t031 = to_mt9t031(sd);
++	struct i2c_client *client = v4l2_get_subdevdata(sd);;
+ 
+ 	if (id->match.type != V4L2_CHIP_MATCH_I2C_ADDR)
+ 		return -EINVAL;
+@@ -442,10 +448,11 @@ static int mt9t031_g_chip_ident(struct v
+ }
+ 
+ #ifdef CONFIG_VIDEO_ADV_DEBUG
+-static int mt9t031_g_register(struct v4l2_subdev *sd,
+-			      struct v4l2_dbg_register *reg)
++static int mt9t031_get_register(struct v4l2_subdev *sd,
++				struct v4l2_dbg_register *reg)
+ {
+-	struct i2c_client *client = sd->priv;
++	struct i2c_client *client = v4l2_get_subdevdata(sd);;
++	struct mt9t031 *mt9t031 = to_mt9t031(sd);
+ 
+ 	if (reg->match.type != V4L2_CHIP_MATCH_I2C_ADDR || reg->reg > 0xff)
+ 		return -EINVAL;
+@@ -461,10 +468,11 @@ static int mt9t031_g_register(struct v4l
+ 	return 0;
+ }
+ 
+-static int mt9t031_s_register(struct v4l2_subdev *sd,
+-			      struct v4l2_dbg_register *reg)
++static int mt9t031_set_register(struct v4l2_subdev *sd,
++				struct v4l2_dbg_register *reg)
+ {
+-	struct i2c_client *client = sd->priv;
++	struct i2c_client *client = v4l2_get_subdevdata(sd);
++	struct mt9t031 *mt9t031 = to_mt9t031(sd);
+ 
+ 	if (reg->match.type != V4L2_CHIP_MATCH_I2C_ADDR || reg->reg > 0xff)
+ 		return -EINVAL;
+@@ -479,63 +487,53 @@ static int mt9t031_s_register(struct v4l
+ }
+ #endif
+ 
+-static const struct v4l2_queryctrl mt9t031_controls[] = {
+-	{
+-		.id		= V4L2_CID_VFLIP,
+-		.type		= V4L2_CTRL_TYPE_BOOLEAN,
+-		.name		= "Flip Vertically",
+-		.minimum	= 0,
+-		.maximum	= 1,
+-		.step		= 1,
+-		.default_value	= 0,
+-	}, {
+-		.id		= V4L2_CID_HFLIP,
+-		.type		= V4L2_CTRL_TYPE_BOOLEAN,
+-		.name		= "Flip Horizontally",
+-		.minimum	= 0,
+-		.maximum	= 1,
+-		.step		= 1,
+-		.default_value	= 0,
+-	}, {
+-		.id		= V4L2_CID_GAIN,
+-		.type		= V4L2_CTRL_TYPE_INTEGER,
+-		.name		= "Gain",
+-		.minimum	= 0,
+-		.maximum	= 127,
+-		.step		= 1,
+-		.default_value	= 64,
+-		.flags		= V4L2_CTRL_FLAG_SLIDER,
+-	}, {
+-		.id		= V4L2_CID_EXPOSURE,
+-		.type		= V4L2_CTRL_TYPE_INTEGER,
+-		.name		= "Exposure",
+-		.minimum	= 1,
+-		.maximum	= 255,
+-		.step		= 1,
+-		.default_value	= 255,
+-		.flags		= V4L2_CTRL_FLAG_SLIDER,
+-	}, {
+-		.id		= V4L2_CID_EXPOSURE_AUTO,
+-		.type		= V4L2_CTRL_TYPE_BOOLEAN,
+-		.name		= "Automatic Exposure",
+-		.minimum	= 0,
+-		.maximum	= 1,
+-		.step		= 1,
+-		.default_value	= 1,
+-	}
++
++static int mt9t031_get_control(struct v4l2_subdev *, struct v4l2_control *);
++static int mt9t031_set_control(struct v4l2_subdev *, struct v4l2_control *);
++static int mt9t031_queryctrl(struct v4l2_subdev *, struct v4l2_queryctrl *);
++
++static const struct v4l2_subdev_core_ops mt9t031_core_ops = {
++	.g_chip_ident = mt9t031_get_chip_id,
++	.init = mt9t031_init,
++	.queryctrl = mt9t031_queryctrl,
++	.g_ctrl	= mt9t031_get_control,
++	.s_ctrl	= mt9t031_set_control,
++#ifdef CONFIG_VIDEO_ADV_DEBUG
++	.get_register = mt9t031_get_register,
++	.set_register = mt9t031_set_register,
++#endif
+ };
+ 
+-static struct soc_camera_ops mt9t031_ops = {
+-	.set_bus_param		= mt9t031_set_bus_param,
+-	.query_bus_param	= mt9t031_query_bus_param,
+-	.controls		= mt9t031_controls,
+-	.num_controls		= ARRAY_SIZE(mt9t031_controls),
++static const struct v4l2_subdev_video_ops mt9t031_video_ops = {
++	.s_fmt = mt9t031_set_fmt,
++	.try_fmt = mt9t031_try_fmt,
++	.s_stream = mt9t031_s_stream,
+ };
+ 
+-static int mt9t031_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
++static const struct v4l2_subdev_ops mt9t031_ops = {
++	.core = &mt9t031_core_ops,
++	.video = &mt9t031_video_ops,
++};
++
++static int mt9t031_queryctrl(struct v4l2_subdev *sd,
++			    struct v4l2_queryctrl *qctrl)
+ {
+-	struct i2c_client *client = sd->priv;
+-	struct mt9t031 *mt9t031 = to_mt9t031(client);
++	const struct v4l2_queryctrl *temp_qctrl;
++
++	temp_qctrl = mt9t031_find_qctrl(qctrl->id);
++	if (!temp_qctrl) {
++		v4l2_err(sd, "control id %d not supported", qctrl->id);
++		return -EINVAL;
++	}
++	memcpy(qctrl, temp_qctrl, sizeof(*qctrl));
++	return 0;
++}
++
++static int mt9t031_get_control(struct v4l2_subdev *sd,
++			       struct v4l2_control *ctrl)
++{
++	struct i2c_client *client = v4l2_get_subdevdata(sd);
++	struct mt9t031 *mt9t031 = to_mt9t031(sd);
+ 	int data;
+ 
+ 	switch (ctrl->id) {
+@@ -554,28 +552,26 @@ static int mt9t031_g_ctrl(struct v4l2_su
+ 	case V4L2_CID_EXPOSURE_AUTO:
+ 		ctrl->value = mt9t031->autoexposure;
+ 		break;
+-	case V4L2_CID_GAIN:
+-		ctrl->value = mt9t031->gain;
+-		break;
+-	case V4L2_CID_EXPOSURE:
+-		ctrl->value = mt9t031->exposure;
+-		break;
+ 	}
+ 	return 0;
+ }
+ 
+-static int mt9t031_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
++static int mt9t031_set_control(struct v4l2_subdev *sd,
++			       struct v4l2_control *ctrl)
+ {
+-	struct i2c_client *client = sd->priv;
+-	struct mt9t031 *mt9t031 = to_mt9t031(client);
+-	struct soc_camera_device *icd = client->dev.platform_data;
+-	const struct v4l2_queryctrl *qctrl;
++	struct mt9t031 *mt9t031 = to_mt9t031(sd);
++	const struct v4l2_queryctrl *qctrl = NULL;
+ 	int data;
++	struct i2c_client *client = v4l2_get_subdevdata(sd);
+ 
+-	qctrl = soc_camera_find_qctrl(&mt9t031_ops, ctrl->id);
++	if (NULL == ctrl)
++		return -EINVAL;
+ 
+-	if (!qctrl)
++	qctrl = mt9t031_find_qctrl(ctrl->id);
++	if (!qctrl) {
++		v4l2_err(sd, "control id %d not supported", ctrl->id);
+ 		return -EINVAL;
++	}
+ 
+ 	switch (ctrl->id) {
+ 	case V4L2_CID_VFLIP:
+@@ -603,7 +599,7 @@ static int mt9t031_s_ctrl(struct v4l2_su
+ 			unsigned long range = qctrl->default_value - qctrl->minimum;
+ 			data = ((ctrl->value - qctrl->minimum) * 8 + range / 2) / range;
+ 
+-			dev_dbg(&client->dev, "Setting gain %d\n", data);
++			v4l2_dbg(1, debug, sd, "Setting gain %d\n", data);
+ 			data = reg_write(client, MT9T031_GLOBAL_GAIN, data);
+ 			if (data < 0)
+ 				return -EIO;
+@@ -615,16 +611,23 @@ static int mt9t031_s_ctrl(struct v4l2_su
+ 			unsigned long gain = ((ctrl->value - qctrl->default_value - 1) *
+ 					       1015 + range / 2) / range + 9;
+ 
+-			if (gain <= 32)		/* calculated gain 9..32 -> 9..32 */
++			if (gain <= 32)
++				/* calculated gain 9..32 -> 9..32 */
+ 				data = gain;
+-			else if (gain <= 64)	/* calculated gain 33..64 -> 0x51..0x60 */
++			else if (gain <= 64)
++				/* calculated gain 33..64 -> 0x51..0x60 */
+ 				data = ((gain - 32) * 16 + 16) / 32 + 80;
+ 			else
+-				/* calculated gain 65..1024 -> (1..120) << 8 + 0x60 */
++				/*
++				 * calculated gain 65..1024 -> (1..120) << 8 +
++				 * 0x60
++				 */
+ 				data = (((gain - 64 + 7) * 32) & 0xff00) | 0x60;
+ 
+-			dev_dbg(&client->dev, "Set gain from 0x%x to 0x%x\n",
+-				reg_read(client, MT9T031_GLOBAL_GAIN), data);
++			v4l2_dbg(1, debug, sd, "Setting gain from 0x%x to"
++				 "0x%x\n",
++				 reg_read(client, MT9T031_GLOBAL_GAIN), data);
++
+ 			data = reg_write(client, MT9T031_GLOBAL_GAIN, data);
+ 			if (data < 0)
+ 				return -EIO;
+@@ -635,18 +638,22 @@ static int mt9t031_s_ctrl(struct v4l2_su
+ 		break;
+ 	case V4L2_CID_EXPOSURE:
+ 		/* mt9t031 has maximum == default */
+-		if (ctrl->value > qctrl->maximum || ctrl->value < qctrl->minimum)
++		if (ctrl->value > qctrl->maximum ||
++		    ctrl->value < qctrl->minimum)
+ 			return -EINVAL;
+ 		else {
+-			const unsigned long range = qctrl->maximum - qctrl->minimum;
+-			const u32 shutter = ((ctrl->value - qctrl->minimum) * 1048 +
+-					     range / 2) / range + 1;
++			const unsigned long range =
++				qctrl->maximum - qctrl->minimum;
++			const u32 shutter =
++				((ctrl->value - qctrl->minimum) * 1048 +
++					range / 2) / range + 1;
+ 			u32 old;
+ 
+-			get_shutter(client, &old);
+-			dev_dbg(&client->dev, "Set shutter from %u to %u\n",
++			get_shutter(sd, &old);
++			v4l2_dbg(1, debug, sd,
++				"Setting shutter width from %u to %u\n",
+ 				old, shutter);
+-			if (set_shutter(client, shutter) < 0)
++			if (set_shutter(sd, shutter) < 0)
+ 				return -EIO;
+ 			mt9t031->exposure = ctrl->value;
+ 			mt9t031->autoexposure = 0;
+@@ -656,14 +663,15 @@ static int mt9t031_s_ctrl(struct v4l2_su
+ 		if (ctrl->value) {
+ 			const u16 vblank = MT9T031_VERTICAL_BLANK;
+ 			const u32 shutter_max = MT9T031_MAX_HEIGHT + vblank;
+-			unsigned int total_h = mt9t031->rect.height +
+-				icd->y_skip_top + vblank;
+-
+-			if (set_shutter(client, total_h) < 0)
++			if (set_shutter(sd, mt9t031->height +
++					mt9t031->y_skip_top + vblank) < 0)
+ 				return -EIO;
+-			qctrl = soc_camera_find_qctrl(icd->ops, V4L2_CID_EXPOSURE);
+-			mt9t031->exposure = (shutter_max / 2 + (total_h - 1) *
+-				 (qctrl->maximum - qctrl->minimum)) /
++
++			qctrl = mt9t031_find_qctrl(V4L2_CID_EXPOSURE);
++			mt9t031->exposure =
++				(shutter_max / 2 + (mt9t031->height +
++				mt9t031->y_skip_top + vblank - 1) *
++				(qctrl->maximum - qctrl->minimum)) /
+ 				shutter_max + qctrl->minimum;
+ 			mt9t031->autoexposure = 1;
+ 		} else
+@@ -675,12 +683,9 @@ static int mt9t031_s_ctrl(struct v4l2_su
+ 
+ /* Interface active, can use i2c. If it fails, it can indeed mean, that
+  * this wasn't our capture interface, so, we wait for the right one */
+-static int mt9t031_video_probe(struct i2c_client *client)
++static int mt9t031_detect(struct i2c_client *client, int *model)
+ {
+-	struct soc_camera_device *icd = client->dev.platform_data;
+-	struct mt9t031 *mt9t031 = to_mt9t031(client);
+ 	s32 data;
+-	int ret;
+ 
+ 	/* Enable the chip */
+ 	data = reg_write(client, MT9T031_CHIP_ENABLE, 1);
+@@ -691,9 +696,7 @@ static int mt9t031_video_probe(struct i2
+ 
+ 	switch (data) {
+ 	case 0x1621:
+-		mt9t031->model = V4L2_IDENT_MT9T031;
+-		icd->formats = mt9t031_colour_formats;
+-		icd->num_formats = ARRAY_SIZE(mt9t031_colour_formats);
++		*model = V4L2_IDENT_MT9T031;
+ 		break;
+ 	default:
+ 		dev_err(&client->dev,
+@@ -702,116 +705,80 @@ static int mt9t031_video_probe(struct i2
+ 	}
+ 
+ 	dev_info(&client->dev, "Detected a MT9T031 chip ID %x\n", data);
+-
+-	ret = mt9t031_idle(client);
+-	if (ret < 0)
+-		dev_err(&client->dev, "Failed to initialise the camera\n");
+-
+-	/* mt9t031_idle() has reset the chip to default. */
+-	mt9t031->exposure = 255;
+-	mt9t031->gain = 64;
+-
+-	return ret;
++	return 0;
+ }
+ 
+-static struct v4l2_subdev_core_ops mt9t031_subdev_core_ops = {
+-	.g_ctrl		= mt9t031_g_ctrl,
+-	.s_ctrl		= mt9t031_s_ctrl,
+-	.g_chip_ident	= mt9t031_g_chip_ident,
+-#ifdef CONFIG_VIDEO_ADV_DEBUG
+-	.g_register	= mt9t031_g_register,
+-	.s_register	= mt9t031_s_register,
+-#endif
+-};
+-
+-static struct v4l2_subdev_video_ops mt9t031_subdev_video_ops = {
+-	.s_stream	= mt9t031_s_stream,
+-	.s_fmt		= mt9t031_s_fmt,
+-	.g_fmt		= mt9t031_g_fmt,
+-	.try_fmt	= mt9t031_try_fmt,
+-	.s_crop		= mt9t031_s_crop,
+-	.g_crop		= mt9t031_g_crop,
+-	.cropcap	= mt9t031_cropcap,
+-};
+-
+-static struct v4l2_subdev_ops mt9t031_subdev_ops = {
+-	.core	= &mt9t031_subdev_core_ops,
+-	.video	= &mt9t031_subdev_video_ops,
+-};
+-
+ static int mt9t031_probe(struct i2c_client *client,
+ 			 const struct i2c_device_id *did)
+ {
+ 	struct mt9t031 *mt9t031;
+-	struct soc_camera_device *icd = client->dev.platform_data;
+-	struct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);
+-	struct soc_camera_link *icl;
++	struct v4l2_subdev *sd;
++	int pclk_pol;
+ 	int ret;
+ 
+-	if (!icd) {
+-		dev_err(&client->dev, "MT9T031: missing soc-camera data!\n");
+-		return -EINVAL;
++	if (!i2c_check_functionality(client->adapter,
++				     I2C_FUNC_SMBUS_WORD_DATA)) {
++		dev_warn(&client->dev,
++			 "I2C-Adapter doesn't support I2C_FUNC_SMBUS_WORD\n");
++		return -EIO;
+ 	}
+ 
+-	icl = to_soc_camera_link(icd);
+-	if (!icl) {
+-		dev_err(&client->dev, "MT9T031 driver needs platform data\n");
+-		return -EINVAL;
++	if (!client->dev.platform_data) {
++		dev_err(&client->dev, "No platform data!!\n");
++		return -ENODEV;
+ 	}
+ 
+-	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_WORD_DATA)) {
+-		dev_warn(&adapter->dev,
+-			 "I2C-Adapter doesn't support I2C_FUNC_SMBUS_WORD\n");
+-		return -EIO;
+-	}
++	pclk_pol = (int)client->dev.platform_data;
+ 
+ 	mt9t031 = kzalloc(sizeof(struct mt9t031), GFP_KERNEL);
+ 	if (!mt9t031)
+ 		return -ENOMEM;
+ 
+-	v4l2_i2c_subdev_init(&mt9t031->subdev, client, &mt9t031_subdev_ops);
+-
+-	/* Second stage probe - when a capture adapter is there */
+-	icd->ops		= &mt9t031_ops;
+-	icd->y_skip_top		= 0;
+-
+-	mt9t031->rect.left	= MT9T031_COLUMN_SKIP;
+-	mt9t031->rect.top	= MT9T031_ROW_SKIP;
+-	mt9t031->rect.width	= MT9T031_MAX_WIDTH;
+-	mt9t031->rect.height	= MT9T031_MAX_HEIGHT;
+-
+-	/* Simulated autoexposure. If enabled, we calculate shutter width
+-	 * ourselves in the driver based on vertical blanking and frame width */
++	ret = mt9t031_detect(client, &mt9t031->model);
++	if (ret)
++		goto clean;
++
++	mt9t031->x_min		= MT9T031_COLUMN_SKIP;
++	mt9t031->y_min		= MT9T031_ROW_SKIP;
++	mt9t031->width		= MT9T031_DEFAULT_WIDTH;
++	mt9t031->height		= MT9T031_DEFAULT_WIDTH;
++	mt9t031->x_current	= mt9t031->x_min;
++	mt9t031->y_current	= mt9t031->y_min;
++	mt9t031->width_min	= MT9T031_MIN_WIDTH;
++	mt9t031->width_max	= MT9T031_MAX_WIDTH;
++	mt9t031->height_min	= MT9T031_MIN_HEIGHT;
++	mt9t031->height_max	= MT9T031_MAX_HEIGHT;
++	mt9t031->y_skip_top	= 10;
+ 	mt9t031->autoexposure = 1;
+-
+ 	mt9t031->xskip = 1;
+ 	mt9t031->yskip = 1;
+ 
+-	mt9t031_idle(client);
+-
+-	ret = mt9t031_video_probe(client);
+-
+-	mt9t031_disable(client);
++	/* Register with V4L2 layer as slave device */
++	sd = &mt9t031->sd;
++	v4l2_i2c_subdev_init(sd, client, &mt9t031_ops);
++	if (!pclk_pol)
++		reg_clear(v4l2_get_subdevdata(sd),
++			  MT9T031_PIXEL_CLOCK_CONTROL, 0x8000);
++	else
++		reg_set(v4l2_get_subdevdata(sd),
++			MT9T031_PIXEL_CLOCK_CONTROL, 0x8000);
+ 
+-	if (ret) {
+-		icd->ops = NULL;
+-		i2c_set_clientdata(client, NULL);
+-		kfree(mt9t031);
+-	}
++	v4l2_info(sd, "%s decoder driver registered !!\n", sd->name);
++	return 0;
+ 
++clean:
++	kfree(mt9t031);
+ 	return ret;
+ }
+ 
+ static int mt9t031_remove(struct i2c_client *client)
+ {
+-	struct mt9t031 *mt9t031 = to_mt9t031(client);
+-	struct soc_camera_device *icd = client->dev.platform_data;
++	struct v4l2_subdev *sd = i2c_get_clientdata(client);
++	struct mt9t031 *mt9t031 = to_mt9t031(sd);
+ 
+-	icd->ops = NULL;
+-	i2c_set_clientdata(client, NULL);
+-	client->driver = NULL;
+-	kfree(mt9t031);
++	v4l2_device_unregister_subdev(sd);
+ 
++	kfree(mt9t031);
+ 	return 0;
+ }
+ 
+--- /dev/null
++++ b/drivers/char/cir.c
+@@ -0,0 +1,594 @@
++/*
++ * cir.c - Driver for Consumer Infrared (CIR) (on Davinci-HD EVM)
++ * Copyright (C) 2007  Texas Instruments,  India
++ * Author: Suresh Rajashekara <suresh.r@ti.com>
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License,  or
++ * (at your option) any later version.
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ * You should have received a copy of the GNU General Public License along
++ * with this program; if not,  write to the Free Software Foundation,  Inc.,
++ * 51 Franklin Street,  Fifth Floor,  Boston,  MA 02110-1301 USA.
++ */
++
++
++#include <linux/init.h>
++#include <linux/module.h>
++#include <linux/fs.h>
++#include <linux/cdev.h>
++#include <linux/jiffies.h>
++#include <linux/spinlock.h>
++#include <linux/clk.h>
++
++#include <linux/cir.h>
++#include <mach/cir_hw.h>
++
++
++#include<linux/platform_device.h>
++
++#define MODULE_NAME   "Consumer IR"
++
++/* Globals */
++static dev_t cir_dev;
++static u32 cir_major_number;
++static u32 cir_minor_number;
++static struct cdev cir_cdev;
++static atomic_t reference_count = ATOMIC_INIT(0);
++static DECLARE_MUTEX(mutex);
++
++static DEFINE_SPINLOCK(cir_lock);
++
++#define RAW_KEY_CODES 4
++/* If another key press is detected within this jiffies duration,  then the
++ * driver discards the key press. */
++static int repeat_delay;	/* Value in jiffies */
++
++#define MAX_KEYS_IN_BUFFER  4
++static s16 decoded_keys[MAX_KEYS_IN_BUFFER];
++static u8 raw_key_buf[RAW_KEY_CODES] = {0};
++
++static int key_read;
++static int key_write;
++static unsigned long next_key_time;
++u8 cir_key_idx;
++
++static void *__iomem cir_base_addr;
++
++DECLARE_COMPLETION(cir_keys);
++
++static u32 cir_reg_get(u32 reg);
++static void cir_reg_set(u32 reg,  u8 reg_value);
++static void cir_reset(void);
++static void configure_cir_registers(void);
++
++
++static struct class *cir_class;
++
++static int cir_flush(void)
++{
++	u32 i;
++
++	unsigned long flags;
++	spin_lock_irqsave(&cir_lock,  flags);
++
++	cir_reset();
++	configure_cir_registers();
++
++	key_read = 0;
++	key_write = 0;
++	cir_key_idx = 0;
++
++	for (i = 0; i < MAX_KEYS_IN_BUFFER; i++)
++		decoded_keys[i] = -1;
++
++	spin_unlock_irqrestore(&cir_lock,  flags);
++
++	return 0;
++}
++
++static s16 decode_cir_value(u8 *raw_cir_data)
++{
++	u16 i;
++	u32 acc;
++	u16 lowbit;
++	u16 highbit;
++	u16 cir_value = 0;
++
++	/* do the whole RC-5 decoding thing.. */
++	acc = (raw_cir_data[0] << 0)
++		| (raw_cir_data[1] << 8)
++		| (raw_cir_data[2] << 16)
++		| (raw_cir_data[3] << 24);
++
++	acc = acc >> 1;
++	for (i = 0 ; i < 16 ; i++) {
++		cir_value <<= 1;
++
++		/* Low & High bits */
++		lowbit  = (acc & 0x0002);
++		highbit = (acc & 0x0001);
++
++		/* One bit */
++		if ((highbit == 0) && (lowbit != 0))
++			cir_value |= 1;
++
++		acc = acc >> 2;
++	}
++
++
++	/* check if the start bit is valid */
++	if (cir_value & 0x8000)	{
++		/* good key received (hopefully),  tell everyone about it. */
++		return (cir_value >> 3) & 0xfff;
++	}
++
++	/* wrong key received.. */
++	return -1;
++}
++
++
++static inline s8 get_stored_key(s16 *key)
++{
++	s8 ret = -1;
++	unsigned long flags;
++
++	spin_lock_irqsave(&cir_lock,  flags);
++
++	if (decoded_keys[key_read] != -1) {
++		/* return valid key */
++		*key =  decoded_keys[key_read];
++		/*after the valid key is read, invalidate the buffer with -1 */
++		decoded_keys[key_read] = -1;
++		ret = 0;
++
++		if (++key_read >= MAX_KEYS_IN_BUFFER)
++			key_read = 0;
++		}
++
++	spin_unlock_irqrestore(&cir_lock,  flags);
++
++	return ret;
++}
++
++static inline void store_received_key(s16 key)
++{
++	unsigned long flags;
++
++
++	spin_lock_irqsave(&cir_lock,  flags);
++	/*store the decoded key into the buffer which will be read later*/
++	decoded_keys[key_write] = key;
++
++	if (++key_write >= MAX_KEYS_IN_BUFFER)
++			key_write = 0;
++
++	spin_unlock_irqrestore(&cir_lock,  flags);
++}
++
++ssize_t cir_read(struct file *file,  char __user *buff,  size_t size,  loff_t
++		  *loff)
++{
++	u16 key;
++
++	/* we only allow one key read at a time */
++	if (size != sizeof(u16)) {
++		printk(KERN_ERR "Invalid size requested for read\n");
++		return -EFAULT;
++	}
++
++begin:
++	if (get_stored_key(&key) != -1) {
++		/* there is a key to be read.. */
++		if (copy_to_user(buff,  &key,  sizeof(u16)) != 0)
++			return -EFAULT;
++	} else {
++		/* tell non blocking applications to come again */
++		if (file->f_flags & O_NONBLOCK) {
++			return -EAGAIN;
++		} else { /* ask blocking applications to sleep comfortably */
++			if (wait_for_completion_interruptible(&cir_keys))
++				return -ERESTARTSYS;
++			goto begin;
++		}
++	}
++
++	return size;
++}
++
++static u32 cir_reg_get(u32 reg)
++{
++	u32 reg_value;
++	u32 lcr = 0;
++	u32 preg32 = ((u32)cir_base_addr) + (reg & ~(USE_LCR_80|USE_LCR_BF));
++	u32 set_lcr_80 = ((u32)reg) & USE_LCR_80;
++	u32 set_lcr_bf = ((u32)reg) & USE_LCR_BF;
++
++	/* Set LCR if needed */
++	if (set_lcr_80) {
++		lcr = cir_reg_get(LCR);
++		cir_reg_set(LCR,  0x80);
++	}
++
++	if (set_lcr_bf) {
++		lcr = cir_reg_get(LCR);
++		cir_reg_set(LCR,  0xbf);
++	}
++
++	/* Get UART register */
++	reg_value = *(u32 *)(preg32);
++
++	/* Return LCR reg if necessary */
++	if (set_lcr_80 || set_lcr_bf)
++		cir_reg_set(LCR,  lcr);
++
++	return reg_value;
++}
++
++static void cir_reg_set(u32 reg,  u8 reg_value)
++{
++	u32 lcr = 0;
++	u32 preg32 = ((u32)cir_base_addr) + (reg & ~(USE_LCR_80|USE_LCR_BF));
++	u32 set_lcr_80 = ((u32)reg) & USE_LCR_80;
++	u32 set_lcr_bf = ((u32)reg) & USE_LCR_BF;
++
++	/* Set LCR if needed */
++	if (set_lcr_80) {
++		lcr = cir_reg_get(LCR);
++		cir_reg_set(LCR,  0x80);
++	}
++
++	if (set_lcr_bf) {
++		lcr = cir_reg_get(LCR);
++		cir_reg_set(LCR,  0xbf);
++	}
++
++	/* Set UART register */
++	*(u32 *)(preg32) = reg_value;
++
++	/* Return LCR reg if necessary */
++	if (set_lcr_80 || set_lcr_bf)
++		cir_reg_set(LCR,  lcr);
++}
++
++static void configure_cir_registers(void)
++{
++
++	/* Enable FIFO,  set the granularity to
++	   cause interrupt after 4 bytes in FIFO */
++	cir_reg_set(FCR,  0x1);
++	cir_reg_set(TLR,  0x10);
++	cir_reg_set(SCR,  0x80);
++
++	cir_reg_set(EFR,  0x10);
++	cir_reg_set(IER,  0);
++	cir_reg_set(MCR,  0);
++	cir_reg_set(EFR,  0);
++	cir_reg_set(LCR,  0);
++	cir_reg_set(MDR1,  0x07);
++	cir_reg_set(LCR,  0xbf);
++	cir_reg_set(IIR,  0x10);
++	cir_reg_set(LCR,  0x87);
++	cir_reg_set(IER,  0x05);
++	cir_reg_set(RHR,  0x35);
++	cir_reg_set(LCR,  0x06);
++	cir_reg_set(MCR,  0x01);
++	cir_reg_set(IER,  0x01);
++	cir_reg_set(EBLR,  0x05);
++	cir_reg_set(SFLSR,  0x01);
++	cir_reg_set(RESUME,  0x00);
++	cir_reg_set(SFREGL,  0x04);
++	cir_reg_set(SFREGH,  0x00);
++	cir_reg_set(LCR,  0x07);
++	cir_reg_set(CFPS,  56);
++	cir_reg_set(MDR2,  0x58);
++	cir_reg_set(MDR1,  0x06);
++}
++
++static void cir_reset(void)
++{
++	u32 val = 0;
++
++
++	cir_reg_set(EFR,  0x10);
++	cir_reg_set(IER,  0);
++	cir_reg_set(MCR,  0);
++	cir_reg_set(EFR,  0);
++	cir_reg_set(LCR,  0);
++	cir_reg_set(MDR1,  0x07);
++	cir_reg_get(RESUME);
++
++	/* disable FIFO and clear RX and TX fifos  */
++	val = cir_reg_get(FCR);
++	val &= 0xFE;
++	val |= 0x6;
++	cir_reg_set(FCR,  val);
++}
++
++int cir_open(struct inode *inode,  struct file *file)
++{
++	int i;
++
++	INIT_COMPLETION(cir_keys);
++	next_key_time = jiffies;
++
++	if (file->f_mode == FMODE_WRITE) {
++		printk(KERN_ERR "TX Not supported\n");
++		return -EACCES;
++	}
++
++	if (atomic_inc_return(&reference_count) > 1) {
++		atomic_dec(&reference_count);
++		return -EACCES;
++	}
++
++	for (i = 0; i < MAX_KEYS_IN_BUFFER; i++)
++		decoded_keys[i] = -1;
++
++	cir_reset();
++	configure_cir_registers();
++
++	return 0;
++}
++
++int cir_release(struct inode *inode,  struct file *file)
++{
++	complete_all(&cir_keys);
++	cir_reset();
++	atomic_dec(&reference_count);
++	return 0;
++}
++
++static irqreturn_t cir_irq_handler (int irq,  void *dev_id)
++{
++	s16 key;
++	/* loop while fifo not empty */
++	while ((cir_reg_get(LSR) & 0x1) != 1) {
++
++		raw_key_buf[cir_key_idx++] = cir_reg_get(RHR);
++
++		/* if all the codes necessary for for decode are received */
++		if (cir_key_idx == RAW_KEY_CODES) {
++			/* lets see if the debounce period is complete */
++			if (time_after(jiffies,  next_key_time)) {
++				/* .. go ahead and decode the value */
++				key = decode_cir_value(raw_key_buf);
++				if (key != -1) {
++					store_received_key(key);
++					next_key_time = jiffies + repeat_delay;
++				complete(&cir_keys);
++			}
++				else
++					cir_flush();
++			}
++			cir_key_idx = 0;
++		}
++	}
++
++	cir_reg_get(RESUME);
++
++	return IRQ_HANDLED;
++}
++
++int cir_ioctl(struct inode *inode,  struct file *filp,  unsigned int cmd,
++		unsigned long arg)
++{
++	int err = 0,  time_val = 0,  ret_val = 0;
++
++	if (_IOC_TYPE(cmd) != CIR_IOC_MAGIC)
++		return -ENOTTY;
++
++	if (_IOC_NR(cmd) > CIR_IOC_MAXNR)
++		return -ENOTTY;
++
++	if (_IOC_DIR(cmd) & _IOC_READ)
++		err = !access_ok(VERIFY_WRITE,  (void __user *)arg,
++				   _IOC_SIZE(cmd));
++	else if (_IOC_DIR(cmd) & _IOC_WRITE)
++		err =  !access_ok(VERIFY_READ,  (void __user *)arg,
++				   _IOC_SIZE(cmd));
++	if (err)
++		return -EFAULT;
++
++	switch (cmd) {
++
++	case CIR_FLUSH:
++		cir_flush();
++		return 0;
++
++		/* Value sent by user will be in ms,  we convert that */
++		/* to jiffies */
++	case CIR_SET_REPEAT_DELAY:
++		ret_val = __get_user(time_val,  (int __user *)arg);
++		if (ret_val == 0) {
++			repeat_delay = time_val/10;
++			return repeat_delay*10;
++		} else
++			return -EFAULT;
++		break;
++
++		/* Value returned from this ioctl has to be in ms */
++	case CIR_GET_REPEAT_DELAY:
++		ret_val = __put_user((repeat_delay*10),  (int __user *)arg);
++		if (ret_val == 0)
++			return 0;
++		else
++			return -EFAULT;
++		break;
++
++	default:
++		printk(KERN_ERR "Unknow IOCTL command\n");
++		break;
++	}
++
++	return -ENOTTY;
++}
++
++const static struct file_operations cir_fops = {
++	.owner   = THIS_MODULE,
++	.read    = cir_read,
++	.open    = cir_open,
++	.release = cir_release,
++	.ioctl   = cir_ioctl,
++};
++
++static int cir_probe(struct platform_device *pdev)
++{
++	s8 retval = 0;
++	struct clk *clkp;
++	struct device *temp = NULL;
++
++	static resource_size_t cir_res_len;
++	struct resource *res,  *irq;
++
++	cir_major_number = 0;
++	cir_minor_number = 0;
++	cir_class = NULL;
++
++	repeat_delay = 20;	/* in Jiffies */
++
++	cir_key_idx = 0;
++
++	clkp = clk_get(NULL,  "uart2");
++
++	if (IS_ERR(clkp)) {
++		printk(KERN_ERR "Unable to get the clock for CIR\n");
++		goto failure;
++	} else {
++		clk_enable(clkp);
++	}
++
++	if (cir_major_number) {	/* If major number is specified */
++		cir_dev = MKDEV(cir_major_number,  0);
++		retval = register_chrdev_region(cir_dev,
++						 CIR_DEV_COUNT,
++						 "cir");
++	} else {			/* If major number is not specified */
++		retval = alloc_chrdev_region(&cir_dev,
++					      cir_minor_number,
++					      CIR_DEV_COUNT,
++					      "cir");
++		cir_major_number = MAJOR(cir_dev);
++	}
++
++	if (retval < 0) {
++		printk(KERN_ERR "Unable to register the CIR device\n");
++		retval = -ENODEV;
++		goto failure;
++	} else {
++		printk(KERN_INFO "CIR device registered successfully \
++			  (Major = %d,  Minor = %d)",
++			  MAJOR(cir_dev),  MINOR(cir_dev));
++	}
++
++	res = platform_get_resource(pdev,  IORESOURCE_MEM, 0);
++	if (!res) {
++		retval = -ENODEV;
++		goto failure ;
++		}
++	cir_res_len = res->end - res->start + 1;
++
++	 res = request_mem_region(res->start,  cir_res_len,  res->name);
++	if (!res) {
++		retval = -EBUSY;
++		goto failure ;
++	}
++	cir_base_addr = ioremap_nocache(res->start, cir_res_len);
++	if (!cir_base_addr)
++		goto failure;
++
++	cdev_init(&cir_cdev,  &cir_fops);
++	cir_cdev.owner = THIS_MODULE;
++	cir_cdev.ops = &cir_fops;
++
++	/* You should not call cdev_add until your driver is completely ready to
++	   handle operations on the device*/
++	retval = cdev_add(&cir_cdev,  cir_dev,  CIR_DEV_COUNT);
++
++	if (retval) {
++		unregister_chrdev_region(cir_dev,  CIR_DEV_COUNT);
++		printk(KERN_ERR "Error %d adding CIR device\n",  retval);
++		goto failure;
++	}
++	irq = platform_get_resource(pdev,  IORESOURCE_IRQ,  0);
++	if (!irq) {
++		retval = -ENODEV;
++		goto failure;
++		}
++	retval = request_irq(irq->start,  cir_irq_handler,
++			     0,  pdev->name,
++			      NULL);
++	if (retval) {
++		unregister_chrdev_region(cir_dev,  CIR_DEV_COUNT);
++		cdev_del(&cir_cdev);
++		printk(KERN_ERR "Unable to register CIR IRQ %d\n",  irq->start);
++		goto failure;
++	}
++
++	cir_class = class_create(THIS_MODULE,  "cir");
++
++	if (IS_ERR(cir_class)) {
++		unregister_chrdev_region(cir_dev,  CIR_DEV_COUNT);
++		cdev_del(&cir_cdev);
++		goto failure;
++	}
++
++	cir_dev = MKDEV(cir_major_number,  0);
++
++	temp = device_create(cir_class,  NULL,  cir_dev,  NULL,  "cir");
++
++	spin_lock_init(&cir_lock);
++
++	return retval;
++
++ failure:
++	printk(KERN_ERR "CIR driver registration failed\n");
++	return retval;
++}
++
++static int cir_remove(struct platform_device *pdev)
++{
++	struct resource *res, *irq;
++	printk(KERN_INFO "Unregistering the CIR device");
++
++	irq = platform_get_resource(pdev,  IORESOURCE_IRQ,  0);
++	free_irq(irq->start,  NULL);
++	cir_dev = MKDEV(cir_major_number,  0);
++
++	device_destroy(cir_class, cir_dev);
++	class_destroy(cir_class);
++	cdev_del(&cir_cdev);
++	unregister_chrdev_region(cir_dev,  CIR_DEV_COUNT);
++
++	res = platform_get_resource(pdev,  IORESOURCE_MEM,  0);
++	release_mem_region(res->start,  resource_size(res));
++
++	return 0;
++}
++static struct platform_driver cir_driver = {
++	.probe  = cir_probe,
++	.remove = cir_remove,
++	.driver = {
++		.name = "cir",
++	.owner = THIS_MODULE,
++		},
++};
++
++static int __init cir_init(void)
++{
++       return platform_driver_register(&cir_driver);
++}
++
++static void __exit cir_exit(void)
++{
++platform_driver_unregister(&cir_driver);
++}
++module_init(cir_init);
++module_exit(cir_exit);
++
++MODULE_AUTHOR("Texas Instruments");
++MODULE_DESCRIPTION("Consumer Infrared (CIR) Driver");
++MODULE_LICENSE("GPL");
+--- /dev/null
++++ b/drivers/char/davinci_vdce.c
+@@ -0,0 +1,2756 @@
++/* *
++ * Copyright (C) 2007 Texas Instruments	Inc
++ *
++ * This	program	is free	software; you can redistribute it and/or modify
++ * it under the	terms of the GNU General Public	License	as published by
++ * the Free Software Foundation; either	version	2 of the License, or
++ * (at your option)any	later version.
++ *
++ * This	program	is distributed in the hope that	it will	be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not,write to the	Free Software
++ * Foundation, Inc., 59	Temple Place, Suite 330, Boston, MA  02111-1307	USA
++ */
++/* davinci_vdce.c	file */
++
++/*Header files*/
++#include <linux/kernel.h>
++#include <linux/fs.h>		/*     everything... */
++#include <linux/errno.h>	/*     error codes     */
++#include <linux/types.h>	/*     size_t */
++#include <linux/cdev.h>
++#include <linux/dma-mapping.h>
++#include <linux/interrupt.h>
++#include <asm/uaccess.h>
++#include <linux/device.h>
++#include <linux/platform_device.h>
++#include "davinci_vdce_hw.h"
++#include <linux/davinci_vdce.h>
++#include <linux/init.h>
++#include <asm/cacheflush.h>
++#include <mach/edma.h>
++#define TCINTEN_SHIFT               20
++#define ITCINTEN_SHIFT              21
++
++/* edma isr status tracking variable */
++volatile static int irqraised1 = 1;
++
++unsigned int vdce_counter = 0;
++unsigned int edma_counter = 0;
++#define	DRIVERNAME	"DavinciHD_vdce"
++#define VDCE_INTERRUPT	12
++
++MODULE_LICENSE("GPL");
++DECLARE_TASKLET(short_tasklet, process_bottomhalf, 0);
++
++/*Global structute shared between all applications
++  struct device_params device_config;*/
++device_params_t device_config;
++/* For registeration of	character device*/
++static struct cdev c_dev;
++/* device structure to make entry in device*/
++static dev_t dev;
++/* for holding device entry*/
++struct device *vdce_device = NULL;
++
++static u32 inter_bufsize = 1920 * 1080;
++module_param(inter_bufsize, uint, S_IRUGO);
++
++channel_config_t *vdce_current_chan = NULL;
++
++/* default values for various modes */
++#define COMMON_DEFAULT_PARAMS {VDCE_PROGRESSIVE, VDCE_FRAME_MODE, \
++VDCE_FRAME_MODE, VDCE_FRAME_MODE, VDCE_LUMA_CHROMA_ENABLE, \
++VDCE_TOP_BOT_ENABLE, 720, 480, 120, 60, 0, 0, 0, 0, 0, 720, 480, 0, 0, 0}
++
++#define RSZ_DEFAULT_PARAMS {VDCE_MODE_422, VDCE_CODECMODE_MPEG2_MPEG4, \
++VDCE_ALGO_TAP_4LINEAR_INTERPOLATION, VDCE_ALGO_TAP_4LINEAR_INTERPOLATION, \
++VDCE_FEATURE_DISABLE, VDCE_FEATURE_DISABLE, VDCE_ALFMODE_AUTOMATIC, 0}
++
++#define CCV_DEFAULT_PARAMS {VDCE_CCV_MODE_422_420, VDCE_CODECMODE_MPEG2_MPEG4, \
++VDCE_CODECMODE_MPEG2_MPEG4, VDCE_ALGO_TAP_4LINEAR_INTERPOLATION, \
++VDCE_ALGO_TAP_4LINEAR_INTERPOLATION }
++
++#define RMAP_DEFAULT_PARAMS {10, VDCE_FEATURE_ENABLE, 10, VDCE_FEATURE_ENABLE}
++
++#define BLEND_TABLE {0x36, 0x22, 0x91, 0xff}
++
++#define BLEND_DEFAULT_PARAMS {VDCE_MODE_422, BLEND_TABLE, BLEND_TABLE, \
++BLEND_TABLE, BLEND_TABLE}
++
++#define EPAD_DEFAULT_PARAMS {16, 8, 16, 8}
++
++#define PRECODEC_PARAMS	{RSZ_DEFAULT_PARAMS, CCV_DEFAULT_PARAMS}
++
++#define POSTCODEC_PARAMS {RSZ_DEFAULT_PARAMS, RMAP_DEFAULT_PARAMS, \
++BLEND_DEFAULT_PARAMS, CCV_DEFAULT_PARAMS}
++
++#define TRANSCODEC_PARAMS {RSZ_DEFAULT_PARAMS, RMAP_DEFAULT_PARAMS, \
++BLEND_DEFAULT_PARAMS, EPAD_DEFAULT_PARAMS, CCV_DEFAULT_PARAMS}
++
++/* Default pre-codec params */
++static vdce_params_t precodec_default_params = {
++	VDCE_OPERATION_PRE_CODECMODE,
++	0x5,
++	COMMON_DEFAULT_PARAMS,
++	.vdce_mode_params.precodec_params = PRECODEC_PARAMS
++};
++
++/* Default post-codec params */
++static vdce_params_t postcodec_default_params = {
++	VDCE_OPERATION_POST_CODECMODE,
++	0x1,
++	COMMON_DEFAULT_PARAMS,
++	.vdce_mode_params.postcodec_params.rsz_params = RSZ_DEFAULT_PARAMS,
++	.vdce_mode_params.postcodec_params.rmap_params = RMAP_DEFAULT_PARAMS,
++	.vdce_mode_params.postcodec_params.blend_params.blend_mode =
++	    VDCE_MODE_422,
++	.vdce_mode_params.postcodec_params.blend_params.bld_lut[0] =
++	    BLEND_TABLE,
++	.vdce_mode_params.postcodec_params.blend_params.bld_lut[1] =
++	    BLEND_TABLE,
++	.vdce_mode_params.postcodec_params.blend_params.bld_lut[2] =
++	    BLEND_TABLE,
++	.vdce_mode_params.postcodec_params.blend_params.bld_lut[3] =
++	    BLEND_TABLE,
++	.vdce_mode_params.postcodec_params.ccv_params = CCV_DEFAULT_PARAMS
++};
++
++/* Default trans-codec params */
++static vdce_params_t transcodec_default_params = {
++	VDCE_OPERATION_TRANS_CODECMODE,
++	0x1,
++	COMMON_DEFAULT_PARAMS,
++	.vdce_mode_params.transcodec_params.rsz_params = RSZ_DEFAULT_PARAMS,
++	.vdce_mode_params.transcodec_params.rmap_params = RMAP_DEFAULT_PARAMS,
++	.vdce_mode_params.transcodec_params.blend_params.blend_mode =
++	    VDCE_MODE_422,
++	.vdce_mode_params.transcodec_params.blend_params.bld_lut[0] =
++	    BLEND_TABLE,
++	.vdce_mode_params.transcodec_params.blend_params.bld_lut[1] =
++	    BLEND_TABLE,
++	.vdce_mode_params.transcodec_params.blend_params.bld_lut[2] =
++	    BLEND_TABLE,
++	.vdce_mode_params.transcodec_params.blend_params.bld_lut[3] =
++	    BLEND_TABLE,
++	.vdce_mode_params.transcodec_params.epad_params = EPAD_DEFAULT_PARAMS,
++	.vdce_mode_params.transcodec_params.ccv_params = CCV_DEFAULT_PARAMS
++};
++
++/* Default edgepadding params */
++static vdce_params_t epad_default_params = {
++	VDCE_OPERATION_EDGE_PADDING,
++	0x0,
++	COMMON_DEFAULT_PARAMS,
++	.vdce_mode_params.epad_params = EPAD_DEFAULT_PARAMS
++};
++
++/* Default resising params */
++static vdce_params_t rsz_default_params = {
++	VDCE_OPERATION_RESIZING,
++	0x0,
++	COMMON_DEFAULT_PARAMS,
++	.vdce_mode_params.rsz_params = RSZ_DEFAULT_PARAMS
++};
++
++/* Default CCV params */
++static vdce_params_t ccv_default_params = {
++	VDCE_OPERATION_CHROMINANCE_CONVERSION,
++	0x0,
++	COMMON_DEFAULT_PARAMS,
++	.vdce_mode_params.ccv_params = CCV_DEFAULT_PARAMS
++};
++
++/* Default blending params */
++static vdce_params_t blend_default_params = {
++	VDCE_OPERATION_BLENDING,
++	0x0,
++	COMMON_DEFAULT_PARAMS,
++	.vdce_mode_params.blend_params.blend_mode = VDCE_MODE_422,
++	.vdce_mode_params.blend_params.bld_lut[0] = BLEND_TABLE,
++	.vdce_mode_params.blend_params.bld_lut[1] = BLEND_TABLE,
++	.vdce_mode_params.blend_params.bld_lut[2] = BLEND_TABLE,
++	.vdce_mode_params.blend_params.bld_lut[3] = BLEND_TABLE
++};
++
++/* Default rangemapping params */
++static vdce_params_t rmap_default_params = {
++	VDCE_OPERATION_RANGE_MAPPING,
++	0x0,
++	COMMON_DEFAULT_PARAMS,
++	.vdce_mode_params.rmap_params = RMAP_DEFAULT_PARAMS
++};
++static int prcs_array_value[] = { 16, 32, 64, 128, 256 };
++
++/*
++ * vdce_free_pages : Function to free memory of buffers
++ */
++inline void vdce_free_pages(unsigned long addr, unsigned long bufsize)
++{
++	unsigned long size;
++	unsigned long tempaddr = addr;
++	if (!addr)
++		return;
++	size = PAGE_SIZE << (get_order(bufsize));
++	while (size > 0) {
++		ClearPageReserved(virt_to_page(addr));
++		addr += PAGE_SIZE;
++		size -= PAGE_SIZE;
++	}
++	free_pages(tempaddr, get_order(bufsize));
++}
++
++/*
++ * vdce_uservirt_to_phys : This inline function is used to
++ * convert user space virtual address to physical address.
++ */
++static inline unsigned long vdce_uservirt_to_phys(unsigned long virtp)
++{
++	unsigned long physp = 0;
++	struct mm_struct *mm = current->mm;
++	struct vm_area_struct *vma;
++	/* For kernel direct-mapped memory, take the easy way */
++	if (virtp >= PAGE_OFFSET)
++		physp = virt_to_phys((void *)virtp);
++
++	/* this will catch, kernel-allocated, mmaped-to-usermode addresses */
++	else if ((vma = find_vma(mm, virtp)) &&
++		 (vma->vm_flags & VM_IO) && (vma->vm_pgoff)) {
++		physp = (vma->vm_pgoff << PAGE_SHIFT) + (virtp - vma->vm_start);
++	}
++	/* otherwise, use get_user_pages() for general userland pages */
++	else {
++		int res, nr_pages = 1;
++		struct page *pages;
++		down_read(&current->mm->mmap_sem);
++
++		res = get_user_pages(current, current->mm,
++				     virtp, nr_pages, 1, 0, &pages, NULL);
++		up_read(&current->mm->mmap_sem);
++
++		if (res == nr_pages) {
++			physp =
++			    __pa(page_address(&pages[0]) +
++				 (virtp & ~PAGE_MASK));
++		} else {
++			dev_err(vdce_device,
++				" Unable to find phys addr for 0x%08lx\n",
++				virtp);
++			dev_err(vdce_device,
++				"get_user_pages() failed: %d\n", res);
++		}
++	}
++	return physp;
++}
++
++/*
++ * malloc_buff : Function to allocate memory to input
++ * and output buffers
++ */
++int malloc_buff(vdce_reqbufs_t * reqbuff, channel_config_t * vdce_conf_chan)
++{
++	/* for looping purpose */
++	int i = 0;
++	/* for pointing to input output buffer or bitmap pointer */
++	int *buf_ptr;
++	/* to calculate no of max buffers; */
++	int maxbuffers;
++	/* to calculate number of buffers allocated */
++	int numbuffers = 0;
++	/* for storing buffer size */
++	int *buf_size;
++	/* Stores requested buffer size */
++	unsigned int req_buffersize = 0;
++	/* to make sure buffer pointer never swapped */
++	unsigned long adr;
++	unsigned long size;
++	int multiplier;
++
++	dev_dbg(vdce_device, " <fn> malloc_buff Entering E </fn>\n");
++
++	dev_dbg(vdce_device, "Input buffer requested \n");
++	buf_ptr =
++	    (unsigned int *)vdce_conf_chan->vdce_buffer[reqbuff->
++							buf_type].buffers;
++	buf_size = &vdce_conf_chan->vdce_buffer[reqbuff->buf_type].size;
++	maxbuffers = MAX_BUFFERS;
++	numbuffers =
++	    vdce_conf_chan->vdce_buffer[reqbuff->buf_type].num_allocated;
++	if (reqbuff->buf_type > VDCE_BUF_BMP) {
++		dev_dbg(vdce_device, "Invalid type \n");
++		return -EINVAL;
++	}
++	multiplier = GET_DIVIDE_FACTOR(reqbuff->image_type);
++	req_buffersize =
++	    ((reqbuff->num_lines * reqbuff->bytes_per_line * multiplier) / 2);
++	/* check the request for number of buffers */
++	if (reqbuff->count > maxbuffers)
++		return -EINVAL;
++
++	/* free all the buffers if the count is zero */
++	if ((reqbuff->count == FREE_BUFFER) ||
++	    ((numbuffers != 0) && (req_buffersize != *buf_size))) {
++		/* free all the buffers */
++		free_num_buffers(buf_ptr, *buf_size, numbuffers);
++		return 0;
++	}
++	dev_dbg(vdce_device,
++		"The	no of requested	buffers	are %d \n ", reqbuff->count);
++	/* free the remainning buffers . ie total allocated is 7 requested is 5
++	   than free 2 buffers */
++	if ((numbuffers - reqbuff->count) > 0) {
++		buf_ptr = buf_ptr + reqbuff->count;
++		/* free the remainning buffers */
++		free_num_buffers(buf_ptr, *buf_size,
++				 (numbuffers - reqbuff->count));
++	} else {
++		buf_ptr = buf_ptr + numbuffers;
++		for (i = numbuffers; i < reqbuff->count; i++) {
++			/* assign memory to buffer */
++			*buf_ptr =
++			    (int)(__get_free_pages
++				  (GFP_KERNEL | GFP_DMA,
++				   get_order(req_buffersize)));
++			if (!(*buf_ptr)) {
++				reqbuff->count = numbuffers + i;
++				*buf_size = req_buffersize;
++				dev_dbg(vdce_device,
++					"requestbuffer:not enough memory");
++				return -ENOMEM;
++			}
++			adr = *buf_ptr;
++			size = PAGE_SIZE << (get_order(req_buffersize));
++			while (size > 0) {
++				/* make  sure the frame buffers
++				   are never swapped out of memory */
++				SetPageReserved(virt_to_page(adr));
++				adr += PAGE_SIZE;
++				size -= PAGE_SIZE;
++			}
++			buf_ptr++;
++		}
++	}
++	reqbuff->count = numbuffers + i;
++
++	vdce_conf_chan->vdce_buffer[reqbuff->buf_type].num_allocated =
++	    numbuffers + i;
++	/* set the buffer size to requested size */
++	/* this will be useful only when numbuffers = 0 */
++	*buf_size = req_buffersize;
++	dev_dbg(vdce_device, "<fn> malloc_buff Leaving </fn>\n");
++	return 0;
++}
++
++/*
++ * free_num_buffers :Function to free the number of
++ *  buffers specified by count
++ */
++int free_num_buffers(int *addr, unsigned long bufsize, unsigned long count)
++{
++	int i;
++	for (i = 0; i < count; i++) {
++		/* free memory allocate for the image */
++		dev_dbg(vdce_device, "Free all the allocated	buffers	\n");
++		/* free buffers using free_pages */
++		vdce_free_pages((int)*addr, bufsize);
++		/* assign buffer zero to indicate its free */
++		*addr = (int)NULL;
++		addr++;
++	}
++	return 0;
++}
++
++/*
++ * get_buf_address : Function to query the  physical address
++ * of the buffer  requested by index
++ */
++int get_buf_address(vdce_buffer_t * buffer, channel_config_t * vdce_conf_chan)
++{
++	dev_dbg(vdce_device, "<fn>get_buf_address Entering </fn>\n");
++	if (!buffer || !vdce_conf_chan) {
++		dev_err(vdce_device, "query_buffer: error in argument\n");
++		return -EINVAL;
++	}
++	if (buffer->buf_type > VDCE_BUF_BMP) {
++		dev_dbg(vdce_device, "Invalid type \n");
++		return -EINVAL;
++	}
++	/*checking the index requested */
++	if (buffer->index >=
++	    (vdce_conf_chan->vdce_buffer[buffer->buf_type].num_allocated)) {
++		dev_dbg(vdce_device, "Requested buffer not allocated	\n");
++		return -EINVAL;
++	}
++	/* assignning the  input address to offset which will be
++	   used in mmap */
++	buffer->offset =
++	    (unsigned int)vdce_conf_chan->vdce_buffer[buffer->buf_type].
++	    buffers[buffer->index];
++	buffer->size = vdce_conf_chan->vdce_buffer[buffer->buf_type].size;
++	buffer->offset = virt_to_phys((void *)buffer->offset);
++
++	dev_dbg(vdce_device, "the physical offset returned after query \
++						is %x", buffer->offset);
++	dev_dbg(vdce_device, "<fn>get_buf_address Leaving </fn>\n");
++	return 0;
++}
++
++/*
++ * free_buff : This function free the input and output buffers alloated
++ */
++int free_buff(channel_config_t * vdce_conf_chan)
++{
++	int buffercounter = 0;
++	int i;
++	dev_dbg(vdce_device, " <fn>free_buff E</fn>\n");
++	/* free all the  buffers */
++	for (i = 0; i < 3; i++) {
++		while ((vdce_conf_chan->vdce_buffer[i].
++			buffers[buffercounter] != NULL)
++		       && buffercounter < MAX_BUFFERS) {
++			/* free the memory */
++			vdce_free_pages((unsigned long)vdce_conf_chan->
++					vdce_buffer[i].buffers[buffercounter]
++					, vdce_conf_chan->vdce_buffer[i].size);
++			/* assign buffer zero to indicate its free */
++			vdce_conf_chan->vdce_buffer[i].
++			    buffers[buffercounter] = (unsigned long)NULL;
++			buffercounter++;
++		}
++		buffercounter = 0;
++	}
++	dev_dbg(vdce_device, "<fn> free_buff L</fn>\n");
++	return 0;
++}
++
++/*
++edma call back function.
++*/
++static void callback1(unsigned lch, u16 ch_status, void *data)
++{
++	switch(ch_status) {
++		case DMA_COMPLETE:
++			irqraised1 = 1;
++			break;
++		case DMA_CC_ERROR:
++			printk("Cannot Complete\n");
++			break;
++		default:
++			break;
++	}
++	if (unlikely(ch_status != DMA_COMPLETE)) {
++		printk("Cannot Complete\n");
++	}
++	irqraised1 = 1;
++	complete(&(device_config.edma_sem));
++}
++
++/* edma3 memcpy functiom which copies the luma data
++*/
++static int edma3_memcpy(int acnt, int bcnt, int ccnt,
++			vdce_address_start_t * vdce_start)
++{
++	int result = 0;
++	unsigned int dma_ch = 0, slot_num = 0;
++	int i, p = 0;
++	unsigned int Istestpassed = 0u;
++	unsigned int numenabled = 0;
++	unsigned int BRCnt = 0;
++	int srcbidx = 0;
++	int desbidx = 0;
++	int srccidx = 0;
++	int descidx = 0;
++	unsigned int numtimes = 0;
++	unsigned int src_inc = 0, dst_inc = 0;
++	struct edmacc_param param_set;
++
++	/* Setting up the SRC/DES Index */
++	srcbidx = vdce_start->src_horz_pitch;
++	desbidx = vdce_start->res_horz_pitch;
++
++	if (ccnt == 2 && (((bcnt != vdce_start->buffers[1].
++			    size / (vdce_start->res_horz_pitch * 4))) ||
++			  ((bcnt != vdce_start->buffers[0].
++			    size / (vdce_start->src_horz_pitch * 4))))) {
++
++		numtimes = 1;
++		srccidx = acnt;
++		descidx = acnt;
++		BRCnt = bcnt;
++		src_inc = 0;
++		dst_inc = 0;
++		ccnt = 1;
++	} else {
++		/* A Sync Transfer Mode */
++		srccidx = acnt;
++		descidx = acnt;
++		BRCnt = bcnt;
++		src_inc = 0;
++		dst_inc = 0;
++		numtimes = 0;
++	}
++	if (ccnt == 2 && ((bcnt == vdce_start->buffers[1].
++			   size / (vdce_start->res_horz_pitch * 4)))) {
++		bcnt = bcnt * 2;
++	}
++	src_inc = 0;
++	dst_inc = 0;
++
++	for (p = 0; p <= numtimes; p++) {
++		/* Allocate Any EDMA Channel*/
++		dma_ch = edma_alloc_channel(EDMA_CHANNEL_ANY, callback1, NULL,
++							EVENTQ_DEFAULT);
++		if (0 > dma_ch) {
++			dev_err(vdce_device, "Cannot Allocate Channel:%d\n",
++									dma_ch);
++			return dma_ch;
++		}
++
++		/* Set the Source EDMA Params */
++		edma_set_src(dma_ch, (unsigned long)(vdce_start->
++				buffers[0].offset + src_inc), INCR, W8BIT);
++		/* Set the Destination EDMA Params */
++		edma_set_dest(dma_ch, (unsigned long) (vdce_start->
++				buffers[1].offset + dst_inc), INCR, W8BIT);
++		/* Set the Source Index */
++		edma_set_src_index(dma_ch, srcbidx, srccidx);
++		/* Set the Destination Index */
++		edma_set_dest_index(dma_ch, desbidx, descidx);
++		/* Set the Transfer Params */
++		edma_set_transfer_params(dma_ch, acnt, bcnt, ccnt, BRCnt,
++								ABSYNC);
++		edma_read_slot(dma_ch, &param_set);
++		param_set.opt |= (1 << ITCINTEN_SHIFT);
++		param_set.opt |= (1 << TCINTEN_SHIFT);
++		param_set.opt |= EDMA_TCC(EDMA_CHAN_SLOT(dma_ch));
++		edma_write_slot(dma_ch, &param_set);
++
++		numenabled = 1;
++
++		for (i = 0; i < numenabled; i++) {
++			irqraised1 = 0;
++
++			/*
++			 * Now enable the transfer as calculated above.
++			 */
++			device_config.edma_sem.done = 0;
++			result = edma_start(dma_ch);
++			if (result != 0) {
++				dev_err(vdce_device, "dma start failed \n");
++				break;
++			}
++			result = wait_for_completion_interruptible(&(device_config.edma_sem));
++			if(result) {
++				wait_for_completion(&(device_config.edma_sem));
++			}
++
++			/* Check the status of the completed transfer */
++			if (irqraised1 < 0) {
++				/* Some error occured, break from the FOR loop. */
++				edma_stop(dma_ch);
++				edma_free_slot(slot_num);
++				edma_free_channel(dma_ch);
++				result = -EAGAIN;
++				break;
++			}
++		}
++		Istestpassed = 1;
++		edma_free_slot(slot_num);
++		edma_free_channel(dma_ch);
++
++		src_inc = vdce_start->buffers[0].size / 4;
++		dst_inc = vdce_start->buffers[1].size / 4;
++	}
++	return result;
++}
++
++/*
++ * vdce_set_address : This function is used to set the addres register
++ */
++int vdce_set_address(vdce_address_start_t * vdce_start,
++		     channel_config_t * vdce_conf_chan, int num_pass,
++		     unsigned int res_size, unsigned int address,
++		     unsigned int pitch)
++{
++
++	int no_of_lines = 0, no_of_lines_output = 0;
++	int divider;
++	unsigned int multiplier = 1;
++	unsigned int temp_lines = 1;
++	unsigned int src_vsp = 0;
++	unsigned int res_vsp = 0;
++	int res_mode, src_mode;
++	unsigned int src_pitch, res_pitch, src_address;
++	unsigned int flag = 0, buffer_index, res_address;
++
++	dev_dbg(vdce_device, "<fn> vdce_set_address	E </fn>\n");
++	/* Top field luma address is the src starting address */
++	src_address = vdce_start->buffers[0].offset;
++	src_pitch = vdce_start->src_horz_pitch;
++	/* For resizing set source mode for second pass equals result mode */
++	src_mode = vdce_conf_chan->get_params.common_params.src_mode;
++
++	if (vdce_conf_chan->num_pass == VDCE_MULTIPASS) {
++		if (num_pass == 1 &&
++		    (vdce_conf_chan->luma_chroma_phased == 0) &&
++		    vdce_conf_chan->mode_state == VDCE_OPERATION_RESIZING) {
++			src_mode =
++			    vdce_conf_chan->get_params.common_params.res_mode;
++		}
++	}
++	if (num_pass == 1) {
++		if (vdce_conf_chan->mode_state == VDCE_OPERATION_RESIZING) {
++			src_address = address;
++			src_pitch = vdce_start->res_horz_pitch;
++		} else {
++			src_pitch =
++			    vdce_conf_chan->register_config[0].
++			    vdce_res_strt_off_ytop;
++
++			src_address =
++			    vdce_conf_chan->
++			    register_config[0].vdce_res_strt_add_ytop;
++		}
++	}
++	vdce_conf_chan->register_config[num_pass].vdce_src_strt_add_ytop =
++	    src_address +
++	    (vdce_conf_chan->get_params.common_params.src_vsp_luminance *
++	     vdce_start->src_horz_pitch);
++	if (vdce_conf_chan->get_params.common_params.src_mode ==
++	    VDCE_FIELD_MODE) {
++		src_vsp =
++		    vdce_conf_chan->get_params.common_params.
++		    src_vsp_luminance * vdce_start->src_horz_pitch;
++	}
++	/* no of lines in horizonatl direction for top/bottom field data */
++	/* ie if v pitch is 48num_pass  than ytop will be of 240 lines */
++	if (vdce_conf_chan->image_type_in == VDCE_IMAGE_FMT_420) {
++		vdce_start->buffers[0].size =
++		    (vdce_start->buffers[0].size * 4) / 3;
++	}
++	no_of_lines = (vdce_start->buffers[0].size / (4));
++
++	if ((vdce_conf_chan->get_params.common_params.
++	     src_processing_mode == VDCE_INTERLACED)
++	    && (src_mode == VDCE_FRAME_MODE)) {
++		multiplier = 1;
++	}
++	/* offset would be horizontal luma size */
++	vdce_conf_chan->register_config[num_pass].vdce_src_add_ofst_ytop =
++	    src_pitch * multiplier;
++	/* offset configuration */
++	vdce_conf_chan->register_config[num_pass].vdce_src_add_ofst_ybot =
++	    src_pitch * multiplier;
++	vdce_conf_chan->register_config[num_pass].vdce_src_add_ofst_ctop =
++	    vdce_start->src_horz_pitch * multiplier;
++	vdce_conf_chan->register_config[num_pass].vdce_src_add_ofst_cbot =
++	    vdce_start->src_horz_pitch * multiplier;
++
++	/* configure bottom field luma addreess is ytop + (no_of_lines*hpitch) */
++	multiplier = src_pitch;
++	if (src_mode == VDCE_FIELD_MODE) {
++		temp_lines = no_of_lines;
++		multiplier = 1;
++	}
++	/* offset would be horizontal luma size */
++	vdce_conf_chan->register_config[num_pass].vdce_src_strt_add_ybot =
++	    (vdce_conf_chan->register_config[num_pass].
++	     vdce_src_strt_add_ytop + (temp_lines * multiplier));
++
++	if (num_pass == 1 && (src_mode == VDCE_FIELD_MODE)) {
++		vdce_conf_chan->register_config[num_pass].
++		    vdce_src_strt_add_ybot = vdce_conf_chan->
++		    register_config[0].vdce_res_strt_add_ybot;
++	}
++	src_address = vdce_start->buffers[0].offset +
++	    (vdce_conf_chan->get_params.common_params.src_vsp_luminance *
++	     src_pitch);
++	if (num_pass != 1) {
++		src_address = (src_address + ((no_of_lines * 2)));
++	}
++	vdce_conf_chan->register_config[num_pass].vdce_src_strt_add_ctop =
++	    (src_address);
++
++	divider = GET_CHROMA_DIVIDE_FACTOR(vdce_conf_chan->image_type_in);
++	if (src_mode == VDCE_FRAME_MODE) {
++		vdce_conf_chan->register_config[num_pass].
++		    vdce_src_strt_add_cbot =
++		    (vdce_conf_chan->register_config[num_pass].
++		     vdce_src_strt_add_ctop + vdce_start->src_horz_pitch);
++	} else {
++		vdce_conf_chan->register_config[num_pass].
++		    vdce_src_strt_add_cbot =
++		    (vdce_conf_chan->register_config[num_pass].
++		     vdce_src_strt_add_ctop + ((temp_lines * 2 / divider)));
++	}
++	/* bitmap offset configuration is bitmap hsize */
++	vdce_conf_chan->register_config[num_pass].
++	    vdce_src_strt_off_bmp_top = vdce_start->bmp_pitch;
++
++	vdce_conf_chan->register_config[num_pass].
++	    vdce_src_strt_off_bmp_bot = vdce_start->bmp_pitch;
++	/* bitmap starting address is starting address for bitmap offset */
++	vdce_conf_chan->register_config[num_pass].
++	    vdce_src_strt_add_bmp_top = vdce_start->buffers[2].offset;
++
++	/* bitmap bottom field starting address */
++	vdce_conf_chan->register_config[num_pass].
++	    vdce_src_strt_add_bmp_bot =
++	    vdce_conf_chan->register_config[num_pass].
++	    vdce_src_strt_add_bmp_top +
++	    (vdce_conf_chan->get_params.common_params.bmp_vsize / 2);
++
++	/* result address for top field */
++	if (vdce_conf_chan->image_type_out == VDCE_IMAGE_FMT_420) {
++		vdce_start->buffers[1].size =
++		    (vdce_start->buffers[1].size * 4) / 3;
++	}
++	no_of_lines_output = (vdce_start->buffers[1].size / (2));
++
++	res_mode = vdce_conf_chan->get_params.common_params.res_mode;
++	if (vdce_conf_chan->num_pass == VDCE_MULTIPASS) {
++		if (num_pass == 0 && (vdce_conf_chan->luma_chroma_phased == 0)) {
++			if (vdce_conf_chan->mode_state ==
++			    VDCE_OPERATION_BLENDING) {
++				res_mode = vdce_conf_chan->
++				    get_params.common_params.src_mode;
++				address = vdce_start->buffers[0].offset;
++			}
++			flag = 1;
++		}
++	}
++	buffer_index = (flag == 1) ? 0 : 1;
++	res_pitch = vdce_start->res_horz_pitch;
++	if (buffer_index == 0) {
++		res_pitch = pitch;
++
++	}
++	if (vdce_conf_chan->num_pass != VDCE_MULTIPASS) {
++		address = vdce_start->buffers[buffer_index].offset;
++	}
++
++	/* top field luma address is the src starting address */
++	vdce_conf_chan->register_config[num_pass].vdce_res_strt_add_ytop =
++	    address +
++	    (vdce_conf_chan->get_params.common_params.res_vsp_luminance *
++	     vdce_start->res_horz_pitch);
++	if (vdce_conf_chan->get_params.common_params.res_mode ==
++	    VDCE_FIELD_MODE) {
++		res_vsp =
++		    vdce_conf_chan->get_params.common_params.
++		    res_vsp_luminance * vdce_start->res_horz_pitch;
++	}
++	multiplier = 1;
++	/* offset would be horizontal luma size */
++	if ((vdce_conf_chan->get_params.common_params.
++	     src_processing_mode == VDCE_INTERLACED)
++	    && (vdce_conf_chan->get_params.common_params.res_mode ==
++		VDCE_FRAME_MODE)) {
++		multiplier = 1;
++	}
++	vdce_conf_chan->register_config[num_pass].vdce_res_strt_off_ytop =
++	    res_pitch * multiplier;
++	/* offset configuration */
++	vdce_conf_chan->register_config[num_pass].vdce_res_strt_off_ybot =
++	    res_pitch * multiplier;
++	vdce_conf_chan->register_config[num_pass].vdce_res_strt_off_ctop =
++	    vdce_start->res_horz_pitch * multiplier;
++	vdce_conf_chan->register_config[num_pass].vdce_res_strt_off_cbot =
++	    vdce_start->res_horz_pitch * multiplier;
++
++	/* no of lines in horizonatl direction for top/bottom field data */
++	/* ie if v pitch is 48num_pass  than ytop will be of 24num_pass lines */
++	dev_dbg(vdce_device, "The number of lines are %d\n\n",
++		no_of_lines_output);
++
++	/* configure bottom field luma addreess */
++	if (res_mode == VDCE_FRAME_MODE) {
++		vdce_conf_chan->
++		    register_config[num_pass].vdce_res_strt_add_ybot =
++		    (vdce_conf_chan->register_config[num_pass].
++		     vdce_res_strt_add_ytop + res_pitch);
++	} else {
++
++		if ((vdce_conf_chan->num_pass == VDCE_MULTIPASS) &&
++		    (num_pass == 0)
++		    && (vdce_conf_chan->luma_chroma_phased == 0)) {
++			if (vdce_conf_chan->mode_state ==
++			    VDCE_OPERATION_BLENDING) {
++
++				vdce_conf_chan->register_config[num_pass].
++				    vdce_res_strt_add_ybot =
++				    vdce_conf_chan->
++				    register_config[num_pass].
++				    vdce_src_strt_add_ybot;
++			} else {
++				vdce_conf_chan->register_config[num_pass].
++				    vdce_res_strt_add_ybot =
++				    (vdce_conf_chan->
++				     register_config[num_pass].
++				     vdce_res_strt_add_ytop) + (res_size / 4);
++			}
++
++		} else {
++
++			vdce_conf_chan->
++			    register_config[num_pass].
++			    vdce_res_strt_add_ybot =
++			    (vdce_conf_chan->register_config[num_pass].
++			     vdce_res_strt_add_ytop +
++			     (((no_of_lines_output / 2))));
++		}
++	}
++	/* configure top field chroma addreess */
++	res_address = vdce_start->buffers[1].offset +
++	    (vdce_conf_chan->get_params.common_params.res_vsp_luminance *
++	     vdce_start->res_horz_pitch);
++	if (flag == 0) {
++		res_address = (res_address + (no_of_lines_output));
++	}
++	vdce_conf_chan->register_config[num_pass].vdce_res_strt_add_ctop =
++	    (res_address);
++
++	/* configuration of cbottom */
++	divider = GET_CHROMA_DIVIDE_FACTOR(vdce_conf_chan->image_type_out);
++	if (res_mode == VDCE_FRAME_MODE) {
++		vdce_conf_chan->
++		    register_config[num_pass].vdce_res_strt_add_cbot =
++		    (vdce_conf_chan->register_config[num_pass].
++		     vdce_res_strt_add_ctop + vdce_start->res_horz_pitch);
++	} else {
++		vdce_conf_chan->
++		    register_config[num_pass].vdce_res_strt_add_cbot =
++		    (vdce_conf_chan->register_config[num_pass].
++		     vdce_res_strt_add_ctop + ((no_of_lines_output / divider)));
++	}
++	dev_dbg(vdce_device, "<fn	>Leaving out of	set address </fn>\n");
++	/* configure top field chroma addreess */
++	return 0;
++}
++
++/*
++ * vdce_set_multipass_address :This function is process in 4:2:2 format for
++ * resizing and blending mode
++ */
++int vdce_set_multipass_address(vdce_address_start_t * vdce_start,
++			       channel_config_t * vdce_conf_chan)
++{
++
++	static unsigned int temp_address, temp_hsz_pitch;
++	int ret = 0;
++	int temp_size;
++	int divider = 2;
++	int req_size = 0;
++	unsigned int address = 0, pitch = 0, res_size = 0;
++	dev_dbg(vdce_device,
++		"<fn>vdce_set_multipass_address	Entering\n</fn>");
++	/* initially this first pass , so we have this flag as started */
++	/* take the offset and pitch into temporary variables */
++	req_size = (vdce_conf_chan->get_params.common_params.
++		    src_hsz_luminance *
++		    vdce_conf_chan->get_params.common_params.src_vsz_luminance);
++	if (device_config.inter_size < req_size) {
++		dev_err(vdce_device,
++			"intermediate buffer size is less than required\n");
++		return -EINVAL;
++	}
++	temp_address = vdce_start->buffers[1].offset;
++	address = vdce_start->buffers[1].offset;
++	if (vdce_conf_chan->mode_state == VDCE_OPERATION_BLENDING) {
++		pitch = vdce_start->src_horz_pitch;
++	} else {
++		pitch = vdce_start->res_horz_pitch;
++	}
++	temp_hsz_pitch = vdce_start->res_horz_pitch;
++	vdce_start->res_horz_pitch =
++	    (vdce_conf_chan->get_params.common_params.dst_hsz_luminance);
++	temp_size = vdce_start->buffers[1].size;
++	res_size = temp_size;
++
++	vdce_start->buffers[1].size = ((device_config.inter_size * 2));
++
++	/* Since first we have to do 4:2:2 to 4:2:0  */
++	/* assign in intermediate address to output address */
++	vdce_start->buffers[1].offset =
++	    virt_to_phys(((void *)device_config.inter_buffer));
++	/* change the output size */
++	vdce_conf_chan->register_config[0].res_Y_sz =
++	    ((vdce_conf_chan->get_params.common_params.
++	      dst_hsz_luminance << RES_Y_HSZ_SHIFT)
++	     & (RES_Y_HSZ_MASK));
++	if (vdce_conf_chan->get_params.common_params.src_processing_mode ==
++	    VDCE_INTERLACED) {
++		divider = 4;
++	}
++	vdce_conf_chan->register_config[0].res_C_sz |=
++	    ((vdce_conf_chan->get_params.common_params.dst_vsz_luminance /
++	      divider << RES_C_VSZ_SHIFT) & (RES_C_VSZ_MASK));
++	if (vdce_conf_chan->mode_state == VDCE_OPERATION_RESIZING) {
++		vdce_conf_chan->register_config[1].vdce_ctrl =
++		    BITSET(vdce_conf_chan->register_config[1].
++			   vdce_ctrl, SET_CHROMA_ENABLE);
++		vdce_conf_chan->register_config[1].vdce_ctrl =
++		    BITRESET(vdce_conf_chan->register_config[1].
++			     vdce_ctrl, SET_LUMA_ENABLE);
++	} else {
++		vdce_conf_chan->register_config[0].vdce_ctrl =
++		    BITSET(vdce_conf_chan->register_config[0].
++			   vdce_ctrl, SET_CHROMA_ENABLE);
++		vdce_conf_chan->register_config[0].vdce_ctrl =
++		    BITRESET(vdce_conf_chan->register_config[0].
++			     vdce_ctrl, SET_LUMA_ENABLE);
++	}
++	/* assignning the address to the register configuration */
++	ret = vdce_set_address(vdce_start, vdce_conf_chan, 0,
++			       res_size, address, pitch);
++
++	/* second pass. configuration */
++	vdce_start->buffers[0].offset =
++	    virt_to_phys(((void *)device_config.inter_buffer));
++	/* configure input pitch */
++	vdce_start->src_horz_pitch =
++	    (vdce_conf_chan->get_params.common_params.dst_hsz_luminance);
++	vdce_start->buffers[0].size = ((device_config.inter_size * 2));
++	vdce_start->buffers[1].size = temp_size;
++	/*configure output pitch and address */
++	vdce_start->buffers[1].offset = temp_address;
++	vdce_start->res_horz_pitch = temp_hsz_pitch;
++
++	/* configure the addrress */
++	ret = vdce_set_address(vdce_start, vdce_conf_chan, 1,
++			       res_size, address, pitch);
++	/* configure input and output size */
++	vdce_conf_chan->register_config[1].src_Y_sz &= ~(SRC_Y_VSZ_MASK);
++	if (vdce_conf_chan->get_params.common_params.src_processing_mode ==
++	    VDCE_INTERLACED) {
++		divider = 2;
++	} else {
++		divider = 1;
++	}
++
++	vdce_conf_chan->register_config[0].res_Y_sz |=
++	    ((vdce_conf_chan->get_params.common_params.
++	      dst_vsz_luminance / divider << RES_Y_VSZ_SHIFT)
++	     & (RES_Y_VSZ_MASK));
++
++	vdce_conf_chan->register_config[1].src_Y_sz =
++	    ((vdce_conf_chan->get_params.common_params.dst_hsz_luminance
++	      << SRC_Y_HSZ_SHIFT) & (SRC_Y_HSZ_MASK));
++
++	vdce_conf_chan->register_config[1].src_C_sz =
++	    ((vdce_conf_chan->get_params.common_params.
++	      dst_hsz_luminance << SRC_C_HSZ_SHIFT) & (SRC_C_HSZ_MASK));
++
++	vdce_conf_chan->register_config[1].res_Y_sz |=
++	    ((vdce_conf_chan->get_params.common_params.
++	      dst_hsz_luminance << RES_Y_HSZ_SHIFT)
++	     & (RES_Y_HSZ_MASK));
++
++	if (vdce_conf_chan->get_params.common_params.src_processing_mode
++	    == VDCE_INTERLACED) {
++
++		vdce_conf_chan->register_config[1].res_Y_sz |=
++		    (((vdce_conf_chan->get_params.common_params.
++		       dst_vsz_luminance / 2) << RES_Y_VSZ_SHIFT) &
++		     (RES_Y_VSZ_MASK));
++		vdce_conf_chan->register_config[1].src_Y_sz |=
++		    ((vdce_conf_chan->get_params.common_params.
++		      dst_vsz_luminance / 2 << SRC_Y_VSZ_SHIFT) &
++		     (SRC_Y_VSZ_MASK));
++		vdce_conf_chan->register_config[1].src_C_sz |=
++		    ((vdce_conf_chan->get_params.common_params.
++		      dst_vsz_luminance / 4 << SRC_C_VSZ_SHIFT) &
++		     (SRC_C_VSZ_MASK));
++	} else {
++		vdce_conf_chan->register_config[1].res_Y_sz |=
++		    ((vdce_conf_chan->get_params.common_params.
++		      dst_vsz_luminance << RES_Y_VSZ_SHIFT) & (RES_Y_VSZ_MASK));
++		vdce_conf_chan->register_config[1].src_Y_sz |=
++		    ((vdce_conf_chan->get_params.common_params.
++		      dst_vsz_luminance << SRC_Y_VSZ_SHIFT) & (SRC_Y_VSZ_MASK));
++		vdce_conf_chan->register_config[1].src_C_sz |=
++		    ((vdce_conf_chan->get_params.common_params.
++		      dst_vsz_luminance / 2 << SRC_C_VSZ_SHIFT) &
++		     (SRC_C_VSZ_MASK));
++	}
++	/* function to enable hardware */
++	dev_dbg(vdce_device,
++		"<fn>vdce_set_multipass_address	Leaving\n</fn>");
++	return ret;
++}
++
++/*
++ * vdce_start : This function enable the resize bit after doing
++ * the hardware register configuration after which resizing
++ * will be carried on.
++ */
++int vdce_start(vdce_address_start_t * vdce_start,
++	       channel_config_t * vdce_conf_chan)
++{
++	/* holds the return value; */
++	int ret = 0;
++	/* conatains the input put and output buffer allocated size */
++	int bufsize[3];
++	int divider_in, divider_out, blend_enable, i;
++	int dst_hsz_luma = 0, dst_vsz_luma = 0;
++	int ccnt = 1;
++	unsigned int ccv_only = 0, luma_status = 0;
++
++	if(vdce_conf_chan->status == VDCE_CHAN_UNINITIALISED){
++		dev_err(vdce_device, "channel un-initialized\n");
++		return -EINVAL;
++	}
++
++	if((vdce_conf_chan->channel_mode == VDCE_MODE_NON_BLOCKING)
++	   && vdce_isbusy()){
++		return -EBUSY;
++	}
++
++	/* check tht hpitch and vpitch should be greater or equal
++	   than hsize and vsize */
++	if (vdce_start->src_horz_pitch <
++	    vdce_conf_chan->get_params.common_params.src_hsz_luminance) {
++		dev_err(vdce_device, "src horizontal pitch less than width \n");
++		return -EINVAL;
++	}
++	if (vdce_start->res_horz_pitch
++	    < vdce_conf_chan->get_params.common_params.dst_hsz_luminance) {
++		dev_err(vdce_device, "horizontal pitch less than width \n");
++		return -EINVAL;
++	}
++	divider_in = GET_DIVIDE_FACTOR(vdce_conf_chan->image_type_in);
++	divider_out = GET_DIVIDE_FACTOR(vdce_conf_chan->image_type_out);
++	/* check for the 8byte alignment for input address of
++	   ytop,ybot,ctop and cbot in both image format */
++
++	/* get the buffer size */
++	bufsize[VDCE_BUF_IN] =
++	    (vdce_start->src_horz_pitch *
++	     (vdce_conf_chan->get_params.common_params.src_vsz_luminance *
++	      divider_in / 2));
++	bufsize[VDCE_BUF_OUT] =
++	    (vdce_start->res_horz_pitch *
++	     (vdce_conf_chan->get_params.common_params.dst_vsz_luminance *
++	      divider_out) / 2);
++	if ((vdce_start->res_horz_pitch) % 0x8 != 0) {
++		dev_err(vdce_device, " invalid resultant pitch offset \n");
++		return -EINVAL;
++	}
++	if ((vdce_start->src_horz_pitch) % 0x8 != 0) {
++		dev_err(vdce_device, " invalid source  pitch offset \n");
++		return -EINVAL;
++	}
++	bufsize[VDCE_BUF_BMP] =
++	    (vdce_conf_chan->get_params.common_params.bmp_hsize *
++	     vdce_conf_chan->get_params.common_params.bmp_vsize) / 4;
++	blend_enable =
++	    BITGET(vdce_conf_chan->register_config[0].vdce_ctrl,
++		   SET_BLEND_ENABLE);
++	blend_enable |=
++	    BITGET(vdce_conf_chan->register_config[1].vdce_ctrl,
++		   SET_BLEND_ENABLE);
++	for (i = VDCE_BUF_IN; i <= VDCE_BUF_BMP; i++) {
++		if (i == VDCE_BUF_BMP && blend_enable != 1) {
++			continue;
++		}		/* user pointer case */
++		if (vdce_start->buffers[i].index < 0) {
++			/* assignning the address to the register conf  */
++			if (vdce_start->buffers[i].size < bufsize[i]) {
++				dev_err(vdce_device, " invalid size \n");
++				return -EINVAL;
++			}
++			if ((void *)vdce_start->buffers[i].virt_ptr == NULL) {
++				dev_err(vdce_device, " Address is NULL \n");
++				return -EINVAL;
++			}
++			/* user virtual pointer to physical address */
++			vdce_start->buffers[i].offset =
++			    vdce_uservirt_to_phys(vdce_start->buffers[i].
++						  virt_ptr /*offset */ );
++		} else {
++			/*checking the index requested */
++			if ((vdce_start->buffers[i].index)
++			    > ((vdce_conf_chan->vdce_buffer[i].
++				num_allocated - 1))) {
++				dev_err(vdce_device,
++					"Requested buffer not allocatedn");
++				return -EINVAL;
++			}
++			vdce_start->buffers[i].offset = virt_to_phys(((void *)
++					      vdce_conf_chan->vdce_buffer[i].
++					      buffers
++					      [vdce_start->
++					       buffers
++					       [i].
++					       index]));
++			vdce_start->buffers[i].size =
++			    vdce_conf_chan->vdce_buffer[i].size;
++		}
++		/* check alignment for ytop */
++		if (vdce_start->buffers[i].offset % 0x8 != 0) {
++			dev_err(vdce_device, "Address not 8 byte aligned \n");
++			return -EINVAL;
++		}
++	}
++	if (blend_enable) {
++		if ((vdce_start->bmp_pitch * 4) <
++		    vdce_conf_chan->get_params.common_params.bmp_hsize) {
++			dev_err(vdce_device, "bmp pitch less than width \n");
++			return -EINVAL;
++		}
++		if (vdce_start->bmp_pitch % 0x8 != 0) {
++			dev_err(vdce_device, " bmp pitch not aligned \n");
++			return -EINVAL;
++		}
++	}
++	/* check for the 8byte alignment for output address of
++	   ytop,ybot,ctop and cbot in both image format */
++	if ((((vdce_start->buffers[0].size) / 4) % 0x8) != 0) {
++		dev_err(vdce_device, " invalid src address  \n");
++		return -EINVAL;
++	}
++	if (((vdce_start->buffers[1].size) / 4) % 0x8) {
++		dev_err(vdce_device, " invalid resultant address \n");
++		return -EINVAL;
++	}
++
++	if ((vdce_conf_chan->num_pass == VDCE_MULTIPASS) &&
++	    (vdce_conf_chan->luma_chroma_phased == 0)) {
++		ret = vdce_set_multipass_address(vdce_start, vdce_conf_chan);
++		if (ret < 0) {
++			return -EINVAL;
++		}
++	} else {
++		/* assignning the address to the register configuration */
++		ret = vdce_set_address(vdce_start, vdce_conf_chan, 0, 0, 0, 0);
++
++		if (vdce_conf_chan->luma_chroma_phased == 1) {
++			memcpy(&vdce_conf_chan->register_config[1],
++			       &vdce_conf_chan->register_config[0],
++			       sizeof(struct vdce_hw_config));
++			vdce_conf_chan->register_config[0].vdce_ctrl =
++			    BITRESET(vdce_conf_chan->register_config[0].
++				     vdce_ctrl, SET_CHROMA_ENABLE);
++			vdce_conf_chan->register_config[1].vdce_ctrl =
++			    BITRESET(vdce_conf_chan->register_config[1].
++				     vdce_ctrl, SET_LUMA_ENABLE);
++		}
++	}
++
++
++	/* Check to see if channel is busy or not */
++	if(vdce_isbusy()) {
++		while(vdce_isbusy()){
++			schedule();
++		}
++	}
++	if(irqraised1 == 0) {
++		while(irqraised1 == 0) {
++			schedule();
++		}
++	}
++
++	/* Wait for getting access to the hardware */
++	wait_for_completion(&(device_config.device_access));
++
++	vdce_current_chan = vdce_conf_chan;
++
++	/* start the process */
++	vdce_conf_chan->vdce_complete = VDCE_PASS1_STARTED;
++	if (vdce_conf_chan->mode_state ==
++	    VDCE_OPERATION_CHROMINANCE_CONVERSION ||
++	    vdce_conf_chan->mode_state == VDCE_OPERATION_PRE_CODECMODE ||
++	    vdce_conf_chan->mode_state == VDCE_OPERATION_POST_CODECMODE ||
++	    vdce_conf_chan->mode_state == VDCE_OPERATION_TRANS_CODECMODE) {
++		vdce_conf_chan->edma_operation = 1;
++
++		luma_status = vdce_conf_chan->register_config[0].vdce_ctrl;
++		if ((luma_status & 0x6) == 0x6) {
++			vdce_conf_chan->edma_operation = 1;
++		} else {
++			vdce_conf_chan->edma_operation = 0;
++		}
++		if ((vdce_conf_chan->get_params.common_params.src_mode !=
++		     vdce_conf_chan->get_params.common_params.res_mode)) {
++			vdce_conf_chan->edma_operation = 0;
++		}
++		ccv_only = vdce_conf_chan->register_config[0].vdce_ctrl;
++		if (ccv_only & 0xb00) {
++			vdce_conf_chan->edma_operation = 0;
++		}
++		if (vdce_conf_chan->edma_operation == 1) {
++			vdce_conf_chan->register_config[0].vdce_ctrl =
++			    BITRESET(vdce_conf_chan->register_config[0].
++				     vdce_ctrl, SET_LUMA_ENABLE);
++		}
++	}
++	vdce_hw_setup(&vdce_conf_chan->register_config[0]);
++	/*function call to enable ge hardware */
++	ret = vdce_enable(&vdce_conf_chan->register_config[0]);
++
++	if (vdce_conf_chan->edma_operation == 1) {
++		dst_hsz_luma = vdce_conf_chan->
++		    get_params.common_params.dst_hsz_luminance;
++
++		dst_vsz_luma = vdce_conf_chan->
++		    get_params.common_params.dst_vsz_luminance;
++		if (vdce_conf_chan->get_params.common_params.src_mode ==
++		    VDCE_FIELD_MODE) {
++			ccnt = 2;
++			dst_vsz_luma = dst_vsz_luma / 2;
++		}
++		ret = edma3_memcpy(dst_hsz_luma, dst_vsz_luma,
++				   ccnt, vdce_start);
++		vdce_conf_chan->register_config[0].vdce_ctrl =
++		    BITSET(vdce_conf_chan->register_config[0].
++			   vdce_ctrl, SET_LUMA_ENABLE);
++	}
++
++	/* waiting for processing to be complete */
++	ret = wait_for_completion_interruptible(
++			&(device_config.sem_isr));
++	if(ret) {
++		wait_for_completion(&(device_config.sem_isr));
++	}
++
++	/* Release access to hardware completion */
++	complete(&(device_config.device_access));
++
++	dev_dbg(vdce_device, "<fn> vdce_start L</fn>\n");
++	return ret;
++}
++
++/*
++ * vdce_check_global_params : Function to check the error conditions
++ */
++int vdce_check_common_params(vdce_params_t * params)
++{
++	int ret = 0;
++	int hrsz_mag = 0, vrsz_mag = 0;
++	int i = 0, prcs = 0;
++	dev_dbg(vdce_device, "<fn>vdce_check_global_params E</fn>\n");
++	/* Checking the validity of various enums */
++	ret = CHECK_MODE_RANGE(params->vdce_mode, VDCE_OPERATION_BLENDING);
++	if (ret) {
++		dev_err(vdce_device, "Invalid mode\n");
++		return -EINVAL;
++	}
++	/* checking validity for precodec params */
++	if (params->vdce_mode == VDCE_OPERATION_POST_CODECMODE ||
++	    params->vdce_mode == VDCE_OPERATION_TRANS_CODECMODE) {
++		/* checking validity for postcodec params */
++		if ((params->modes_control & RSZ_ENABLE_MASK) ==
++		    (RSZ_ENABLE_MASK)
++		    && (params->modes_control & BLEND_ENABLE_MASK) ==
++		    (BLEND_ENABLE_MASK)) {
++			dev_err(vdce_device,
++				"Cannot	enable due to Hardware limitation \n");
++			return -EINVAL;
++
++		}
++	}
++	/* if resizing than check for resize ratio */
++	if ((params->vdce_mode == VDCE_OPERATION_RESIZING) ||
++	    ((params->vdce_mode == VDCE_OPERATION_PRE_CODECMODE) &&
++	     ((params->modes_control & RSZ_ENABLE_MASK) == (RSZ_ENABLE_MASK)))
++	    || ((params->vdce_mode == VDCE_OPERATION_POST_CODECMODE)
++		&& ((params->modes_control & RSZ_ENABLE_MASK) ==
++		    (RSZ_ENABLE_MASK)))
++	    || ((params->vdce_mode == VDCE_OPERATION_TRANS_CODECMODE)
++		&& ((params->modes_control & RSZ_ENABLE_MASK) ==
++		    (RSZ_ENABLE_MASK)))) {
++		hrsz_mag =
++		    (params->common_params.src_hsz_luminance * 256) /
++		    (params->common_params.dst_hsz_luminance);
++		vrsz_mag =
++		    (params->common_params.src_vsz_luminance * 256) /
++		    (params->common_params.dst_vsz_luminance);
++		/* checking horizontal phase */
++		if ((hrsz_mag < MIN_RSZ_MAG_RATIO) ||
++		    (hrsz_mag > MAX_RSZ_MAG_RATIO)) {
++			dev_err(vdce_device, "Invalid Horizontal ratio \n");
++			return -EINVAL;
++		}
++		/* checking vertical phase */
++		if ((vrsz_mag < MIN_RSZ_MAG_RATIO)
++		    || (vrsz_mag > MAX_RSZ_MAG_RATIO)) {
++			dev_err(vdce_device, "Invalid Vertical ratio \n");
++			return -EINVAL;
++		}
++	}
++	if ((params->vdce_mode == VDCE_OPERATION_RESIZING) &&
++	    (params->vdce_mode_params.rsz_params.
++	     rsz_op_mode == VDCE_CODECMODE_MPEG1)) {
++		dev_err(vdce_device,
++			" This facility not supported due to hardware \n\n");
++	}
++	if (params->common_params.prcs_unit_value == 0) {
++		prcs = hrsz_mag / 256;
++		for (i = 4; i >= 0; i--) {
++			if ((prcs_array_value[i] * prcs + 9) <= 256) {
++				break;
++			}
++		}
++		if (i < 0) {
++			i = 0;
++		}
++		prcs = prcs_array_value[i];
++	} else {
++		prcs = params->common_params.prcs_unit_value;
++	}
++	if (prcs > 256) {
++		return -EINVAL;
++	}
++	if (params->vdce_mode == VDCE_OPERATION_EDGE_PADDING) {
++		if ((params->vdce_mode_params.epad_params.hext_luma > prcs)
++		    || (params->vdce_mode_params.epad_params.hext_chroma >
++			prcs))
++			return -EINVAL;
++	}
++	if (params->common_params.src_processing_mode == VDCE_PROGRESSIVE) {
++		if ((params->common_params.src_mode == VDCE_FIELD_MODE) ||
++		    (params->common_params.res_mode == VDCE_FIELD_MODE)) {
++			dev_err(vdce_device, "Invalid Mode ratio \n");
++			return -EINVAL;
++		}
++	}
++	if (ret) {
++		dev_dbg(vdce_device, "Inavlid return \n");
++		return -EINVAL;
++	} else {
++		return 0;
++	}
++	dev_dbg(vdce_device, "<fn>vdce_check_global_params L</fn>\n");
++}
++
++/*
++ * vdce_set_size_fmt : Setting resizing parameters .
++ */
++int vdce_set_size_fmt(vdce_common_params_t * params,
++		      channel_config_t * vdce_conf_chan, int num_pass)
++{
++	int ret = 0;
++	int mode;
++	int prcs_nvalue = 0, i = 0;
++	int prcs = 0;
++	vdce_image_fmt_t src_image_type, divider = 1;
++	dev_dbg(vdce_device, "<fn>vdce_set_size_fmt	E</fn>\n");
++	/* setting luminance processing enable bit */
++	if (params->proc_control == VDCE_LUMA_ENABLE) {
++		vdce_conf_chan->register_config[num_pass].vdce_ctrl =
++		    BITSET(vdce_conf_chan->register_config[num_pass].
++			   vdce_ctrl, SET_LUMA_ENABLE);
++	} else if (params->proc_control == VDCE_CHROMA_ENABLE) {
++		vdce_conf_chan->register_config[num_pass].vdce_ctrl =
++		    BITSET(vdce_conf_chan->register_config[num_pass].
++			   vdce_ctrl, SET_CHROMA_ENABLE);
++	} else {
++		vdce_conf_chan->register_config[num_pass].vdce_ctrl =
++		    BITSET(vdce_conf_chan->register_config[num_pass].
++			   vdce_ctrl, SET_CHROMA_ENABLE);
++		vdce_conf_chan->register_config[num_pass].vdce_ctrl =
++		    BITSET(vdce_conf_chan->register_config[num_pass].
++			   vdce_ctrl, SET_LUMA_ENABLE);
++	}
++
++	/* setting input horizontal alf enable */
++	if (params->field_status == VDCE_TOP_ENABLE) {
++		vdce_conf_chan->register_config[num_pass].vdce_ctrl =
++		    BITSET(vdce_conf_chan->register_config[num_pass].
++			   vdce_ctrl, SET_TOP_ENABLE);
++	} else if (params->field_status == VDCE_BOTTOM_ENABLE) {
++		vdce_conf_chan->register_config[num_pass].vdce_ctrl =
++		    BITSET(vdce_conf_chan->register_config[num_pass].
++			   vdce_ctrl, SET_BOT_ENABLE);
++	} else {
++		vdce_conf_chan->register_config[num_pass].vdce_ctrl =
++		    BITSET(vdce_conf_chan->register_config[num_pass].
++			   vdce_ctrl, SET_BOT_ENABLE);
++		vdce_conf_chan->register_config[num_pass].vdce_ctrl =
++		    BITSET(vdce_conf_chan->register_config[num_pass].
++			   vdce_ctrl, SET_TOP_ENABLE);
++	}
++	/* setting src i/o mode */
++	if (params->src_mode == VDCE_FRAME_MODE) {
++		vdce_conf_chan->register_config[num_pass].vdce_ctrl =
++		    BITSET(vdce_conf_chan->register_config[num_pass].
++			   vdce_ctrl, SET_SRC_MODE);
++	} else {
++		vdce_conf_chan->register_config[num_pass].vdce_ctrl =
++		    BITRESET(vdce_conf_chan->register_config[num_pass].
++			     vdce_ctrl, SET_SRC_MODE);
++	}
++	/* setting res i/o mode */
++	if (params->res_mode == VDCE_FRAME_MODE) {
++		vdce_conf_chan->register_config[num_pass].vdce_ctrl =
++		    BITSET(vdce_conf_chan->register_config[num_pass].
++			   vdce_ctrl, SET_RES_MODE);
++	} else {
++		vdce_conf_chan->register_config[num_pass].vdce_ctrl =
++		    BITRESET(vdce_conf_chan->register_config[num_pass].
++			     vdce_ctrl, SET_RES_MODE);
++	}
++	if (num_pass == 1 &&
++	    (vdce_conf_chan->mode_state != VDCE_OPERATION_RESIZING)) {
++		if (params->src_mode == VDCE_FRAME_MODE) {
++			vdce_conf_chan->register_config[0].vdce_ctrl =
++			    BITSET(vdce_conf_chan->register_config[0].
++				   vdce_ctrl, SET_RES_MODE);
++		} else {
++
++			vdce_conf_chan->register_config[0].vdce_ctrl =
++			    BITRESET(vdce_conf_chan->register_config[0].
++				     vdce_ctrl, SET_RES_MODE);
++		}
++	}
++	if (num_pass == 1 &&
++	    (vdce_conf_chan->mode_state == VDCE_OPERATION_RESIZING)) {
++		if (params->res_mode == VDCE_FRAME_MODE) {
++			vdce_conf_chan->register_config[1].vdce_ctrl =
++			    BITSET(vdce_conf_chan->register_config[1].
++				   vdce_ctrl, SET_SRC_MODE);
++		} else {
++
++			vdce_conf_chan->register_config[1].vdce_ctrl =
++			    BITRESET(vdce_conf_chan->register_config[1].
++				     vdce_ctrl, SET_SRC_MODE);
++		}
++	}
++	/* setting bmp i/o mode */
++	if (params->src_bmp_mode == VDCE_FRAME_MODE) {
++		vdce_conf_chan->register_config[num_pass].vdce_ctrl =
++		    BITSET(vdce_conf_chan->register_config[num_pass].
++			   vdce_ctrl, SET_BMP_MODE);
++	} else {
++		vdce_conf_chan->register_config[num_pass].vdce_ctrl =
++		    BITRESET(vdce_conf_chan->register_config[num_pass].
++			     vdce_ctrl, SET_BMP_MODE);
++	}
++	/* setting bmp i/o mode */
++	if (params->src_processing_mode == VDCE_PROGRESSIVE) {
++		vdce_conf_chan->register_config[num_pass].vdce_ctrl =
++		    BITSET(vdce_conf_chan->register_config[num_pass].
++			   vdce_ctrl, SET_PRO_MODE);
++	} else {
++		/* atleat top field or bottom field should be configured for
++		   interlaced */
++		vdce_conf_chan->register_config[num_pass].vdce_ctrl =
++		    BITRESET(vdce_conf_chan->register_config[num_pass].
++			     vdce_ctrl, SET_PRO_MODE);
++	}
++	vdce_conf_chan->register_config[num_pass].vdce_req_sz =
++	    vdce_conf_chan->register_config[num_pass].
++	    vdce_req_sz & ~(VDCE_REQ_SZ_MASK);
++
++	vdce_conf_chan->register_config[num_pass].vdce_req_sz =
++	    (vdce_conf_chan->register_config[num_pass].vdce_req_sz |
++	     ((256) << VDCE_REQ_SZ_SHIFT));
++
++	if (params->prcs_unit_value == 0) {
++		prcs_nvalue =
++		    (params->src_hsz_luminance / (params->dst_hsz_luminance));
++		for (i = 4; i >= 0; i--) {
++			if ((prcs_array_value[i] * prcs_nvalue + 9) <= 256) {
++				break;
++			}
++		}
++		if (i < 0) {
++			i = 0;
++		}
++		prcs = prcs_array_value[i];
++	} else {
++		prcs = params->prcs_unit_value;
++	}
++	vdce_conf_chan->register_config[num_pass].vdce_prcs_unit_size =
++	    prcs & (VDCE_PRCS_UNIT_SIZE_MASK);
++
++	/* Configuration of luma size */
++	vdce_conf_chan->register_config[num_pass].src_Y_sz |=
++	    ((params->src_hsz_luminance << SRC_Y_HSZ_SHIFT) & (SRC_Y_HSZ_MASK));
++
++	if (params->src_processing_mode == VDCE_INTERLACED) {
++
++		vdce_conf_chan->register_config[num_pass].src_Y_sz |=
++		    ((params->
++		      src_vsz_luminance /
++		      2 << SRC_Y_VSZ_SHIFT) & (SRC_Y_VSZ_MASK));
++	} else {
++		vdce_conf_chan->register_config[num_pass].src_Y_sz |=
++		    ((params->
++		      src_vsz_luminance << SRC_Y_VSZ_SHIFT) & (SRC_Y_VSZ_MASK));
++	}
++
++	vdce_conf_chan->register_config[num_pass].res_Y_sz |=
++	    ((params->dst_hsz_luminance << RES_Y_HSZ_SHIFT) & (RES_Y_HSZ_MASK));
++
++	if (params->src_processing_mode == VDCE_INTERLACED) {
++		vdce_conf_chan->register_config[num_pass].res_Y_sz |=
++		    ((params->
++		      dst_vsz_luminance /
++		      2 << RES_Y_VSZ_SHIFT) & (RES_Y_VSZ_MASK));
++	} else {
++		vdce_conf_chan->register_config[num_pass].res_Y_sz |=
++		    ((params->
++		      dst_vsz_luminance << RES_Y_VSZ_SHIFT) & (RES_Y_VSZ_MASK));
++	}
++	/* Configuration of chroma size */
++	mode = ((vdce_conf_chan->register_config[num_pass].vdce_ctrl
++		 & VDCE_MODE_MASK) >> VDCE_MODE_SHIFT);
++
++	if ((vdce_conf_chan->mode_state == VDCE_OPERATION_PRE_CODECMODE) ||
++	    ((vdce_conf_chan->mode_state == VDCE_OPERATION_RESIZING) &&
++	     (mode == MODE_PRECODEC)) ||
++	    ((vdce_conf_chan->mode_state ==
++	      VDCE_OPERATION_CHROMINANCE_CONVERSION) &&
++	     (mode == MODE_PRECODEC)) || (mode == MODE_PRECODEC) ||
++	    (vdce_conf_chan->mode_state == VDCE_OPERATION_EDGE_PADDING)) {
++		src_image_type = VDCE_IMAGE_FMT_422;
++
++	} else {
++		src_image_type = VDCE_IMAGE_FMT_420;
++	}
++	/* mode is 420 so chroma value is reduced by 2 */
++	divider = (params->src_processing_mode == VDCE_INTERLACED) ? 4 : 2;
++	if (src_image_type == VDCE_IMAGE_FMT_420) {
++		divider = (params->
++			   src_processing_mode == VDCE_INTERLACED) ? 4 : 2;
++		vdce_conf_chan->register_config[num_pass].src_C_sz |=
++		    ((params->src_vsz_luminance / divider << SRC_C_VSZ_SHIFT)
++		     & (SRC_C_VSZ_MASK));
++	} else if (src_image_type == VDCE_IMAGE_FMT_422) {
++		divider = (params->
++			   src_processing_mode == VDCE_INTERLACED) ? 2 : 1;
++		vdce_conf_chan->register_config[num_pass].src_C_sz |=
++		    vdce_conf_chan->register_config[num_pass].src_C_sz |=
++		    ((params->src_vsz_luminance / divider << SRC_C_VSZ_SHIFT)
++		     & (SRC_C_VSZ_MASK));
++
++	} else {
++		return -EINVAL;
++	}
++
++	vdce_conf_chan->register_config[num_pass].src_C_sz |=
++	    ((params->src_hsz_luminance << SRC_C_HSZ_SHIFT) & (SRC_C_HSZ_MASK));
++
++	vdce_conf_chan->register_config[num_pass].res_C_sz |=
++	    ((params->dst_hsz_luminance << RES_C_HSZ_SHIFT) & (RES_C_HSZ_MASK));
++	if ((vdce_conf_chan->mode_state == VDCE_OPERATION_PRE_CODECMODE) ||
++	    (mode == MODE_TRANSCODEC) || (mode == MODE_PRECODEC)) {
++
++		divider = (params->
++			   src_processing_mode == VDCE_INTERLACED) ? 4 : 2;
++
++	} else {
++		divider = (params->
++			   src_processing_mode == VDCE_INTERLACED) ? 2 : 1;
++	}
++	vdce_conf_chan->register_config[num_pass].res_C_sz |=
++	    ((params->
++	      dst_vsz_luminance /
++	      divider << RES_C_VSZ_SHIFT) & (RES_C_VSZ_MASK));
++	/* Configuration of bitmap size */
++	divider = (params->src_processing_mode == VDCE_INTERLACED) ? 2 : 1;
++	vdce_conf_chan->register_config[num_pass].src_bmp_sz |=
++	    ((params->bmp_hsize << SRC_BMP_HSZ_SHIFT) & (SRC_BMP_HSZ_MASK));
++
++	vdce_conf_chan->register_config[num_pass].src_bmp_sz |=
++	    ((params->
++	      bmp_vsize / divider << SRC_BMP_VSZ_SHIFT) & (SRC_BMP_VSZ_MASK));
++
++	/* configuration for starting position */
++	vdce_conf_chan->register_config[num_pass].src_Y_strt_ps =
++	    params->src_hsp_luminance;
++	vdce_conf_chan->register_config[num_pass].src_C_strt_ps =
++	    params->src_hsp_luminance;
++	vdce_conf_chan->register_config[num_pass].res_Y_strt_ps =
++	    params->res_hsp_luminance;
++
++	vdce_conf_chan->register_config[num_pass].src_bmp_strt_ps |=
++	    ((params->bmp_hsp_bitmap) & (SRC_BMP_STRT_HPS_MASK));
++
++	vdce_conf_chan->register_config[num_pass].res_bmp_strt_ps |=
++	    ((params->res_hsp_bitmap) & (SRC_BMP_HSZ_MASK));
++
++	vdce_conf_chan->register_config[num_pass].res_bmp_strt_ps |=
++	    ((params->res_vsp_bitmap << RES_BMP_STRT_VPS_SHIFT)
++	     & (RES_BMP_STRT_VPS_MASK));
++	/* hardcoding the image format as raster scanning */
++	vdce_conf_chan->register_config[num_pass].vdce_sdr_fmt =
++	    VDCE_RASTER_SCANNING;
++
++	dev_dbg(vdce_device, "<fn>vdce_set_size_fmt	L\n</fn>");
++	return ret;
++}
++
++/*
++ * vdce_set_rmapparams : Setting range mapping parameters.
++ */
++int vdce_set_rmapparams(vdce_rmap_params_t * params,
++			channel_config_t * vdce_conf_chan, int index)
++{
++	int ret = 0;
++	dev_dbg(vdce_device, "<fn>vdce_set_rmmaparams E\n</fn>");
++	dev_dbg(vdce_device, "The	value s	%d\n", params->coeff_y);
++	if (params->rmap_yenable == VDCE_FEATURE_ENABLE) {
++		vdce_conf_chan->register_config[index].rgmp_ctrl =
++		    BITSET(vdce_conf_chan->register_config[index].
++			   rgmp_ctrl, SET_RMAP_YENABLE);
++
++		dev_dbg(vdce_device, "Entering and setting value \n");
++		vdce_conf_chan->register_config[index].rgmp_ctrl |=
++		    ((params->coeff_y) << RANGE_MAP_Y_SHIFT) & RANGE_MAP_Y_MASK;
++
++	} else {
++		vdce_conf_chan->register_config[index].rgmp_ctrl =
++		    BITRESET(vdce_conf_chan->register_config[index].
++			     rgmp_ctrl, SET_RMAP_YENABLE);
++	}
++	if (params->rmap_cenable == VDCE_FEATURE_ENABLE) {
++		vdce_conf_chan->register_config[index].rgmp_ctrl =
++		    BITSET(vdce_conf_chan->register_config[index].
++			   rgmp_ctrl, SET_RMAP_CENABLE);
++
++		vdce_conf_chan->register_config[index].rgmp_ctrl |=
++		    ((params->
++		      coeff_c) << (RANGE_MAP_C_SHIFT)) & RANGE_MAP_C_MASK;
++	} else {
++		vdce_conf_chan->register_config[index].rgmp_ctrl =
++		    BITRESET(vdce_conf_chan->register_config[index].
++			     rgmp_ctrl, SET_RMAP_CENABLE);
++	}
++	vdce_conf_chan->register_config[index].vdce_ctrl =
++	    BITSET(vdce_conf_chan->register_config[index].vdce_ctrl,
++		   SET_RMAP_ENABLE);
++	dev_dbg(vdce_device, "<fn>vdce_set_rmapparams L\n</fn>");
++	return ret;
++}
++
++/*
++ * vdce_set_rszparams : Setting resizing parameters .
++ */
++int vdce_set_rszparams(vdce_params_t * params,
++		       channel_config_t * vdce_conf_chan,
++		       vdce_mode_operation_t mode, int index)
++{
++	int ret = 0;
++	vdce_rsz_params_t rsz_params;
++	int hrsz_mag, vrsz_mag;
++	if (mode == VDCE_OPERATION_PRE_CODECMODE) {
++		rsz_params =
++		    (params->vdce_mode_params.precodec_params.rsz_params);
++	} else if (mode == VDCE_OPERATION_POST_CODECMODE) {
++		rsz_params =
++		    (params->vdce_mode_params.postcodec_params.rsz_params);
++	} else if (mode == VDCE_OPERATION_TRANS_CODECMODE) {
++		rsz_params =
++		    (params->vdce_mode_params.transcodec_params.rsz_params);
++	} else if (mode == VDCE_OPERATION_RESIZING) {
++		rsz_params = (params->vdce_mode_params.rsz_params);
++	} else {
++		memset(&rsz_params, 0, sizeof(rsz_params));
++	}
++
++	dev_dbg(vdce_device, "<fn>vdce_set_rszparams E\n</fn>");
++	/* setting input horizontal alf enable */
++	if (rsz_params.hrsz_alf_enable == VDCE_FEATURE_ENABLE) {
++		vdce_conf_chan->register_config[index].rsz_mode =
++		    BITSET(vdce_conf_chan->register_config[index].rsz_mode,
++			   SET_HRSZ_ALF_ENABLE);
++	} else {
++		vdce_conf_chan->register_config[index].rsz_mode =
++		    BITRESET(vdce_conf_chan->register_config[index].
++			     rsz_mode, SET_HRSZ_ALF_ENABLE);
++	}
++	/* setting input vertical alf format */
++	if (rsz_params.vrsz_alf_enable == VDCE_FEATURE_ENABLE) {
++		vdce_conf_chan->register_config[index].rsz_mode =
++		    BITSET(vdce_conf_chan->register_config[index].rsz_mode,
++			   SET_VRSZ_ALF_ENABLE);
++	} else {
++		vdce_conf_chan->register_config[index].rsz_mode =
++		    BITRESET(vdce_conf_chan->register_config[index].
++			     rsz_mode, SET_VRSZ_ALF_ENABLE);
++	}
++	/* setting H type */
++	if (rsz_params.vrsz_mode == VDCE_ALGO_TAP_4LINEAR_INTERPOLATION) {
++		vdce_conf_chan->register_config[index].rsz_mode =
++		    BITSET(vdce_conf_chan->register_config[index].rsz_mode,
++			   SET_RSZ_V_TYPE);
++	} else {
++		vdce_conf_chan->register_config[index].rsz_mode =
++		    BITRESET(vdce_conf_chan->register_config[index].
++			     rsz_mode, SET_RSZ_V_TYPE);
++	}
++	/* setting V type */
++	if (rsz_params.hrsz_mode == VDCE_ALGO_TAP_4LINEAR_INTERPOLATION) {
++		vdce_conf_chan->register_config[index].rsz_mode =
++		    BITSET(vdce_conf_chan->register_config[index].rsz_mode,
++			   SET_RSZ_H_TYPE);
++	} else {
++		vdce_conf_chan->register_config[index].rsz_mode =
++		    BITRESET(vdce_conf_chan->register_config[index].
++			     rsz_mode, SET_RSZ_H_TYPE);
++	}
++	/* setting V type */
++	if (rsz_params.hrsz_alf_mode == VDCE_ALFMODE_MANUAL) {
++		vdce_conf_chan->register_config[index].rsz_mode =
++		    BITSET(vdce_conf_chan->register_config[index].rsz_mode,
++			   SET_RSZ_H_ALF_mode);
++	} else {
++		vdce_conf_chan->register_config[index].rsz_mode =
++		    BITRESET(vdce_conf_chan->register_config[index].
++			     rsz_mode, SET_RSZ_H_ALF_mode);
++	}
++	/* setting intensity of resizer */
++	if ((rsz_params.hrsz_alf_mode == VDCE_ALFMODE_MANUAL)
++		&& (rsz_params.hrsz_alf_enable == VDCE_FEATURE_ENABLE)) {
++		if (rsz_params.hrsz_alf_intensity > MAX_RSZ_INTENSITY) {
++			rsz_params.hrsz_alf_intensity = MAX_RSZ_INTENSITY;
++		}
++		vdce_conf_chan->register_config[index].
++			rsz_alf_intensity |=
++			(((rsz_params.
++			   hrsz_alf_intensity) << RSZ_ALF_INTENSITY_SHIFT)
++			 & RSZ_ALF_INTENSITY_MASK);
++	} else {
++		vdce_conf_chan->register_config[index].rsz_alf_intensity = 0;
++	}
++	/* if resizer used check for the params */
++	hrsz_mag =
++	    (params->common_params.src_hsz_luminance *
++	     256) / (params->common_params.dst_hsz_luminance);
++	vdce_conf_chan->register_config[index].rsz_h_mag |=
++	    (((hrsz_mag) << RSZ_H_MAG_SHIFT) & (RSZ_H_MAG_MASK));
++	vrsz_mag =
++	    (params->common_params.src_vsz_luminance *
++	     256) / (params->common_params.dst_vsz_luminance);
++	vdce_conf_chan->register_config[index].rsz_v_mag |=
++	    (((vrsz_mag) << RSZ_V_MAG_SHIFT)) & (RSZ_V_MAG_MASK);
++
++	/* setting horizontal enable bit */
++	if (hrsz_mag >= 256) {
++		vdce_conf_chan->register_config[index].rsz_mode =
++		    BITSET(vdce_conf_chan->register_config[index].rsz_mode,
++			   SET_HRSZ_ENABLE);
++	} else {
++		vdce_conf_chan->register_config[index].rsz_mode =
++		    BITRESET(vdce_conf_chan->register_config[index].
++			     rsz_mode, SET_HRSZ_ENABLE);
++	}
++	/* setting vertical enable bit */
++	if (vrsz_mag >= 256) {
++		vdce_conf_chan->register_config[index].rsz_mode =
++		    BITSET(vdce_conf_chan->register_config[index].rsz_mode,
++			   SET_VRSZ_ENABLE);
++	} else {
++		vdce_conf_chan->register_config[index].rsz_mode =
++		    BITRESET(vdce_conf_chan->register_config[index].
++			     rsz_mode, SET_VRSZ_ENABLE);
++	}
++	vdce_conf_chan->register_config[index].vdce_ctrl =
++	    BITSET(vdce_conf_chan->register_config[index].vdce_ctrl,
++		   SET_RSZ_ENABLE);
++	dev_dbg(vdce_device, "<fn>vdce_set_rszparams L\n</fn>");
++	return ret;
++}
++
++/*
++ * vdce_set_epadparams : Setting EPAD parameters.
++ */
++int vdce_set_epadparams(vdce_epad_params_t * params,
++			channel_config_t * vdce_conf_chan, int index)
++{
++	int ret = 0;
++	dev_dbg(vdce_device, "<fn>vdce_set_epadparams E \n</fn>");
++	/* configuring luma vertical extension value */
++	vdce_conf_chan->register_config[index].epd_luma_width |=
++	    (((params->vext_luma) << EPD_Y_VEXT_SHIFT) & EPD_Y_VEXT_MASK);
++
++	/* configuring luma horizontal extension value */
++	vdce_conf_chan->register_config[index].epd_luma_width |=
++	    ((params->hext_luma) << (EPD_Y_HEXT_SHIFT)) & (EPD_Y_HEXT_MASK);
++
++	/* configuring chroma vertical extension value */
++	vdce_conf_chan->register_config[index].epd_chroma_width |=
++	    ((params->vext_chroma) << (EPD_C_VEXT_SHIFT)) & EPD_C_VEXT_MASK;
++
++	/* configuring chroma horizontal extension value */
++	vdce_conf_chan->register_config[index].epd_chroma_width |=
++	    (((params->hext_chroma) << EPD_C_HEXT_SHIFT) & EPD_C_HEXT_MASK);
++	dev_dbg(vdce_device, "<fn>vdce_set_epadparams L\n</fn>");
++	return ret;
++}
++
++/*
++ * vdce_set_ccvparams : Setting CCV parameters.
++ */
++int vdce_set_ccvparams(vdce_ccv_params_t * params,
++		       channel_config_t * vdce_conf_chan, int mode, int index)
++{
++	int ret = 0;
++	dev_dbg(vdce_device, "<fn>vdce_set_ccvparams E\n</fn>");
++	/* setting output format */
++	if (mode == MODE_PRECODEC || mode == MODE_TRANSCODEC) {
++		if (params->codec_mode_out == VDCE_CODECMODE_MPEG1) {
++			vdce_conf_chan->register_config[index].ccv_mode =
++			    BITSET(vdce_conf_chan->register_config[index].
++				   ccv_mode, SET_CCV_OUT_MPEG1);
++
++			vdce_conf_chan->register_config[index].vdce_ctrl =
++			    BITSET(vdce_conf_chan->register_config[index].
++				   vdce_ctrl, SET_CCV_ENABLE);
++
++		} else {
++			vdce_conf_chan->register_config[index].ccv_mode =
++			    BITRESET(vdce_conf_chan->
++				     register_config[index].ccv_mode,
++				     SET_CCV_OUT_MPEG1);
++		}
++	}
++	if (mode == MODE_POSTCODEC || mode == MODE_TRANSCODEC) {
++		/* setting input format */
++		if (params->codec_mode_in == VDCE_CODECMODE_MPEG1) {
++			vdce_conf_chan->register_config[index].ccv_mode =
++			    BITSET(vdce_conf_chan->register_config[index].
++				   ccv_mode, SET_CCV_IN_MPEG1);
++			vdce_conf_chan->register_config[index].vdce_ctrl =
++			    BITSET(vdce_conf_chan->register_config[index].
++				   vdce_ctrl, SET_CCV_ENABLE);
++		} else {
++			vdce_conf_chan->register_config[index].ccv_mode =
++			    BITRESET(vdce_conf_chan->
++				     register_config[index].ccv_mode,
++				     SET_CCV_IN_MPEG1);
++		}
++	}
++	/* setting H type */
++	if (params->hccv_type == VDCE_ALGO_TAP_4LINEAR_INTERPOLATION) {
++		vdce_conf_chan->register_config[index].ccv_mode =
++		    BITSET(vdce_conf_chan->register_config[index].ccv_mode,
++			   SET_CCV_H_TYPE);
++	} else {
++		vdce_conf_chan->register_config[index].ccv_mode =
++		    BITRESET(vdce_conf_chan->register_config[index].
++			     ccv_mode, SET_CCV_H_TYPE);
++	}
++	/* setting V type */
++	if (params->vccv_type == VDCE_ALGO_TAP_4LINEAR_INTERPOLATION) {
++		vdce_conf_chan->register_config[index].ccv_mode =
++		    BITSET(vdce_conf_chan->register_config[index].ccv_mode,
++			   SET_CCV_V_TYPE);
++	} else {
++		vdce_conf_chan->register_config[index].ccv_mode =
++		    BITRESET(vdce_conf_chan->register_config[index].
++			     ccv_mode, SET_CCV_V_TYPE);
++	}
++	vdce_conf_chan->register_config[index].vdce_ctrl |=
++	    ((mode << VDCE_MODE_SHIFT) & (VDCE_MODE_MASK));
++	dev_dbg(vdce_device, "<fn>vdce_get_ccvparams L\n</fn>");
++	return ret;
++}
++
++/*
++ * vdce_set_blendparams : Setting blending parameters.
++ */
++int vdce_set_blendparams(vdce_blend_params_t * params,
++			 channel_config_t * vdce_conf_chan, int mode, int index)
++{
++	int i = 0;
++	int ret = 0;
++	dev_dbg(vdce_device, "<fn>vdce_set_blendparams E\n</fn>");
++	for (i = 0; i < MAX_BLEND_TABLE; i++) {
++		/* configuring blend factor for zero blend value parameters */
++		vdce_conf_chan->register_config[index].bld_lut[i] |=
++		    ((params->bld_lut[i].
++		      blend_value) << BLD_LUT_FCT_SHIFT) & (BLD_LUT_FCT_MASK);
++
++		/* configuring Cr value for zero blend value parameters */
++		vdce_conf_chan->register_config[index].bld_lut[i] |=
++		    ((params->bld_lut[i].blend_cr) << BLD_LUT_CR_SHIFT) &
++		    (BLD_LUT_CR_MASK);
++
++		/* configuring cb value for zero blend value parameters */
++		vdce_conf_chan->register_config[index].bld_lut[i] |=
++		    ((params->bld_lut[i].blend_cb) << BLD_LUT_CB_SHIFT) &
++		    (BLD_LUT_CB_MASK);
++		/* configuring Y value for zero blend value parameters */
++		vdce_conf_chan->register_config[index].bld_lut[i] |=
++		    ((params->bld_lut[i].blend_y) << BLD_LUT_Y_SHIFT) &
++		    BLD_LUT_Y_MASK;
++	}
++	vdce_conf_chan->register_config[index].vdce_ctrl =
++	    BITSET(vdce_conf_chan->register_config[index].vdce_ctrl,
++		   SET_BLEND_ENABLE);
++	dev_dbg(vdce_device, "<fn>vdce_set_blendparams E\n</fn>");
++	return ret;
++}
++
++/*
++ * vdce_set_params : Function to set the ge parameters
++ */
++int vdce_set_params(vdce_params_t * params, channel_config_t * vdce_conf_chan)
++{
++	int ret = 0;
++	int pass_num = 0;
++	int mode;
++	vdce_ccv_params_t ccv_params;
++	dev_dbg(vdce_device, "<fn> vdce_set_params E\n</fn>");
++
++	memset(&(vdce_conf_chan->register_config[0]), 0,
++	       sizeof(vdce_hw_config_t));
++	memset(&(vdce_conf_chan->register_config[1]), 0,
++	       sizeof(vdce_hw_config_t));
++
++	vdce_conf_chan->status = VDCE_CHAN_UNINITIALISED;
++	vdce_conf_chan->mode_state = params->vdce_mode;
++	vdce_conf_chan->num_pass = VDCE_SINGLE_PASS;
++	/* configuration of Pre-codec mode */
++	if (params->vdce_mode == VDCE_OPERATION_PRE_CODECMODE) {
++		if (((params->modes_control & RSZ_ENABLE_MASK) ==
++		     (RSZ_ENABLE_MASK))) {
++			ret = vdce_set_rszparams(params, vdce_conf_chan,
++						 VDCE_OPERATION_PRE_CODECMODE,
++						 pass_num);
++		}
++		ret = vdce_set_ccvparams(&(params->vdce_mode_params.
++					   precodec_params.ccv_params),
++					 vdce_conf_chan, MODE_PRECODEC,
++					 pass_num);
++
++		vdce_conf_chan->register_config[pass_num].vdce_ctrl |=
++		    ((MODE_PRECODEC << VDCE_MODE_SHIFT) & (VDCE_MODE_MASK));
++
++	} else if (params->vdce_mode == VDCE_OPERATION_POST_CODECMODE) {
++		/* configuration of Post-codec mode */
++		/* setting resizing params and enabling it */
++		if (((params->modes_control & RSZ_ENABLE_MASK) ==
++		     (RSZ_ENABLE_MASK))) {
++			ret = vdce_set_rszparams(params, vdce_conf_chan,
++						 VDCE_OPERATION_POST_CODECMODE,
++						 pass_num);
++			if (params->vdce_mode_params.postcodec_params.
++			    ccv_params.codec_mode_in == VDCE_CODECMODE_MPEG1) {
++				vdce_conf_chan->luma_chroma_phased = 1;
++			}
++		}
++		ret =
++		    vdce_set_ccvparams(&
++				       (params->vdce_mode_params.
++					postcodec_params.ccv_params),
++				       vdce_conf_chan, MODE_POSTCODEC,
++				       pass_num);
++		/* setting range-mapping params and enabling it */
++		if (((params->modes_control & RMAP_ENABLE_MASK) ==
++		     (RMAP_ENABLE_MASK))) {
++			ret =
++			    vdce_set_rmapparams(&
++						(params->vdce_mode_params.
++						 postcodec_params.
++						 rmap_params),
++						vdce_conf_chan, pass_num);
++		}
++		/* setting blending params and enabling it */
++		if (((params->modes_control & BLEND_ENABLE_MASK) ==
++		     (BLEND_ENABLE_MASK))) {
++			ret =
++			    vdce_set_blendparams(&
++						 (params->vdce_mode_params.
++						  postcodec_params.
++						  blend_params),
++						 vdce_conf_chan,
++						 VDCE_OPERATION_POST_CODECMODE,
++						 pass_num);
++		}
++		vdce_conf_chan->register_config[pass_num].vdce_ctrl |=
++		    ((MODE_POSTCODEC << VDCE_MODE_SHIFT) & (VDCE_MODE_MASK));
++
++	} else if (params->vdce_mode == VDCE_OPERATION_TRANS_CODECMODE) {
++		/* Configuration of Trans-codec mode */
++		/* setting resizing params and enabling it */
++		if (((params->modes_control & RSZ_ENABLE_MASK) ==
++		     (RSZ_ENABLE_MASK))) {
++			ret = vdce_set_rszparams(params, vdce_conf_chan,
++						 VDCE_OPERATION_TRANS_CODECMODE,
++						 pass_num);
++			if (params->vdce_mode_params.transcodec_params.
++			    ccv_params.codec_mode_in == VDCE_CODECMODE_MPEG1) {
++				vdce_conf_chan->luma_chroma_phased = 1;
++			}
++		}
++		/* setting range-mapping params and enabling it */
++		if (((params->modes_control & RMAP_ENABLE_MASK) ==
++		     (RMAP_ENABLE_MASK))) {
++			ret =
++			    vdce_set_rmapparams(&
++						(params->vdce_mode_params.
++						 transcodec_params.
++						 rmap_params),
++						vdce_conf_chan, pass_num);
++		}
++		/* setting blend params and enabling it */
++		if (((params->modes_control & BLEND_ENABLE_MASK) ==
++		     (BLEND_ENABLE_MASK))) {
++			ret =
++			    vdce_set_blendparams(&
++						 (params->vdce_mode_params.
++						  transcodec_params.
++						  blend_params),
++						 vdce_conf_chan,
++						 VDCE_OPERATION_TRANS_CODECMODE,
++						 pass_num);
++		}
++		/* setting ccv params and enabling it */
++		if (((params->modes_control & CCV_ENABLE_MASK) ==
++		     (CCV_ENABLE_MASK))) {
++			ret =
++			    vdce_set_ccvparams(&
++					       (params->vdce_mode_params.
++						transcodec_params.
++						ccv_params),
++					       vdce_conf_chan,
++					       MODE_TRANSCODEC, pass_num);
++		}
++		vdce_conf_chan->register_config[pass_num].vdce_ctrl |=
++		    ((MODE_TRANSCODEC << VDCE_MODE_SHIFT) & (VDCE_MODE_MASK));
++
++	} else if (params->vdce_mode == VDCE_OPERATION_EDGE_PADDING) {
++		/* configuration of Edge-padding mode */
++		ret = vdce_set_epadparams(&(params->vdce_mode_params.
++					    epad_params)
++					  , vdce_conf_chan, pass_num);
++		vdce_conf_chan->register_config[pass_num].vdce_ctrl |=
++		    ((MODE_EPAD << VDCE_MODE_SHIFT) & (VDCE_MODE_MASK));
++	} else if (params->vdce_mode == VDCE_OPERATION_RESIZING) {
++		/* Configuration of Resizing mode */
++		if (params->vdce_mode_params.rsz_params.rsz_mode ==
++		    VDCE_MODE_422) {
++			memset(&ccv_params, 0, sizeof(vdce_ccv_params_t));
++			vdce_conf_chan->num_pass = VDCE_MULTIPASS;
++			/* set mode as pre-codec */
++			vdce_conf_chan->register_config[pass_num].
++			    vdce_ctrl |=
++			    ((MODE_PRECODEC << VDCE_MODE_SHIFT) &
++			     (VDCE_MODE_MASK));
++			ret =
++			    vdce_set_ccvparams(&ccv_params, vdce_conf_chan,
++					       MODE_PRECODEC, pass_num);
++			ret =
++			    vdce_set_rszparams(params, vdce_conf_chan,
++					       VDCE_OPERATION_RESIZING,
++					       pass_num);
++			pass_num = 1;
++			ret =
++			    vdce_set_ccvparams(&ccv_params, vdce_conf_chan,
++					       MODE_POSTCODEC, pass_num);
++
++			vdce_conf_chan->register_config[pass_num].
++			    vdce_ctrl |=
++			    ((MODE_POSTCODEC << VDCE_MODE_SHIFT) &
++			     (VDCE_MODE_MASK));
++		} else {
++			vdce_conf_chan->register_config[pass_num].
++			    vdce_ctrl |=
++			    ((MODE_TRANSCODEC << VDCE_MODE_SHIFT) &
++			     (VDCE_MODE_MASK));
++			ret = vdce_set_rszparams(params, vdce_conf_chan,
++						 VDCE_OPERATION_RESIZING,
++						 pass_num);
++			if (params->vdce_mode_params.rsz_params.
++			    rsz_op_mode == VDCE_CODECMODE_MPEG1) {
++				vdce_conf_chan->luma_chroma_phased = 1;
++			}
++		}
++	} else if (params->vdce_mode == VDCE_OPERATION_CHROMINANCE_CONVERSION) {
++		/* Configuration of CCV mode */
++		if (params->vdce_mode_params.ccv_params.conversion_type ==
++		    VDCE_CCV_MODE_420_422) {
++			ret =
++			    vdce_set_ccvparams(&
++					       (params->vdce_mode_params.
++						ccv_params),
++					       vdce_conf_chan,
++					       MODE_POSTCODEC, pass_num);
++		} else if (params->vdce_mode_params.ccv_params.
++			   conversion_type == VDCE_CCV_MODE_422_420) {
++			ret =
++			    vdce_set_ccvparams(&
++					       (params->vdce_mode_params.
++						ccv_params),
++					       vdce_conf_chan,
++					       MODE_PRECODEC, pass_num);
++		} else {
++			ret =
++			    vdce_set_ccvparams(&
++					       (params->vdce_mode_params.
++						ccv_params),
++					       vdce_conf_chan,
++					       MODE_TRANSCODEC, pass_num);
++		}
++	} else if (params->vdce_mode == VDCE_OPERATION_RANGE_MAPPING) {
++		/* Configuration of Range-mapping */
++		ret = vdce_set_rmapparams(&(params->vdce_mode_params.
++					    rmap_params), vdce_conf_chan,
++					  pass_num);
++		vdce_conf_chan->register_config[pass_num].vdce_ctrl |=
++		    ((MODE_TRANSCODEC << VDCE_MODE_SHIFT) & (VDCE_MODE_MASK));
++	} else if (params->vdce_mode == VDCE_OPERATION_BLENDING) {
++		/* Configuration of Blending mode */
++		if (params->vdce_mode_params.blend_params.blend_mode ==
++		    VDCE_MODE_422) {
++			memset(&ccv_params, 0, sizeof(vdce_ccv_params_t));
++			/* set mode as pre-codec */
++			vdce_conf_chan->num_pass = VDCE_MULTIPASS;
++			ret =
++			    vdce_set_ccvparams(&ccv_params, vdce_conf_chan,
++					       MODE_PRECODEC, pass_num);
++			vdce_conf_chan->register_config[pass_num].
++			    vdce_ctrl |=
++			    ((MODE_PRECODEC << VDCE_MODE_SHIFT) &
++			     (VDCE_MODE_MASK));
++			pass_num = 1;
++			ret =
++			    vdce_set_blendparams(&
++						 (params->vdce_mode_params.
++						  blend_params),
++						 vdce_conf_chan,
++						 MODE_POSTCODEC, 1);
++			ret =
++			    vdce_set_ccvparams(&ccv_params, vdce_conf_chan,
++					       MODE_POSTCODEC, pass_num);
++
++			vdce_conf_chan->register_config[pass_num].
++			    vdce_ctrl |=
++			    ((MODE_POSTCODEC << VDCE_MODE_SHIFT) &
++			     (VDCE_MODE_MASK));
++		} else {
++			vdce_conf_chan->register_config[pass_num].
++			    vdce_ctrl |=
++			    ((MODE_TRANSCODEC << VDCE_MODE_SHIFT) &
++			     (VDCE_MODE_MASK));
++
++			ret =
++			    vdce_set_blendparams(&
++						 (params->vdce_mode_params.
++						  blend_params),
++						 vdce_conf_chan,
++						 MODE_TRANSCODEC, 0);
++		}
++	} else {
++		/* error */
++		dev_err(vdce_device, "\n mode not supported ");
++		ret = -EINVAL;
++	}
++	if (pass_num == 0) {
++		vdce_set_size_fmt(&(params->common_params), vdce_conf_chan, 0);
++	} else {
++		vdce_set_size_fmt(&(params->common_params), vdce_conf_chan, 0);
++		vdce_set_size_fmt(&(params->common_params), vdce_conf_chan, 1);
++	}
++	mode = ((vdce_conf_chan->register_config[0].vdce_ctrl
++		 & VDCE_MODE_MASK) >> VDCE_MODE_SHIFT);
++
++	if ((vdce_conf_chan->mode_state == VDCE_OPERATION_PRE_CODECMODE) ||
++	    ((vdce_conf_chan->mode_state == VDCE_OPERATION_RESIZING) &&
++	     (vdce_conf_chan->num_pass == VDCE_MULTIPASS)) ||
++	    ((vdce_conf_chan->
++	      mode_state == VDCE_OPERATION_CHROMINANCE_CONVERSION) &&
++	     (vdce_conf_chan->num_pass == VDCE_MULTIPASS)) ||
++	    (mode == MODE_PRECODEC) ||
++	    (vdce_conf_chan->mode_state == VDCE_OPERATION_EDGE_PADDING)) {
++		vdce_conf_chan->image_type_in = VDCE_IMAGE_FMT_422;
++	} else {
++		vdce_conf_chan->image_type_in = VDCE_IMAGE_FMT_420;
++	}
++	if ((vdce_conf_chan->mode_state == VDCE_OPERATION_POST_CODECMODE)
++	    || ((vdce_conf_chan->mode_state == VDCE_OPERATION_RESIZING)
++		&& (vdce_conf_chan->num_pass == VDCE_MULTIPASS))
++	    ||
++	    ((vdce_conf_chan->mode_state ==
++	      VDCE_OPERATION_CHROMINANCE_CONVERSION)
++	     && (vdce_conf_chan->num_pass == VDCE_MULTIPASS))
++	    ||
++	    ((vdce_conf_chan->mode_state == VDCE_OPERATION_BLENDING
++	      && vdce_conf_chan->num_pass == VDCE_MULTIPASS)
++	     || mode == MODE_POSTCODEC)
++	    || (vdce_conf_chan->mode_state == VDCE_OPERATION_EDGE_PADDING)) {
++		vdce_conf_chan->image_type_out = VDCE_IMAGE_FMT_422;
++
++	} else {
++		vdce_conf_chan->image_type_out = VDCE_IMAGE_FMT_420;
++	}
++	if (vdce_conf_chan->luma_chroma_phased == 1) {
++		if (params->common_params.proc_control ==
++		    VDCE_LUMA_CHROMA_ENABLE) {
++			vdce_conf_chan->luma_chroma_phased = 1;
++			vdce_conf_chan->num_pass = VDCE_MULTIPASS;
++		} else {
++			vdce_conf_chan->luma_chroma_phased = 0;
++			vdce_conf_chan->num_pass = VDCE_SINGLE_PASS;
++		}
++
++	}
++	if (ret == 0) {
++		dev_dbg(vdce_device, "VDCE State configured \n");
++		memcpy(&vdce_conf_chan->get_params, params,
++		       sizeof(vdce_params_t));
++		vdce_conf_chan->status = VDCE_CHAN_PARAMS_INITIALISED;
++	}
++	dev_dbg(vdce_device, "<fn> vdce_set_params L\n</fn>");
++	return ret;
++}
++
++/*
++ * vdce_get_Params : Function to get the parameters values
++ */
++int vdce_get_params(vdce_params_t * params, channel_config_t * vdce_conf_chan)
++{
++	if (vdce_conf_chan->status == VDCE_CHAN_UNINITIALISED) {
++		dev_err(vdce_device, "2 State not configured \n");
++		return -EINVAL;
++	}
++	memcpy(params, &vdce_conf_chan->get_params, sizeof(vdce_params_t));
++	return 0;
++}
++
++/*
++ * vdce_get_status : This function gets a status of hardware and channel.
++ */
++int vdce_get_status(vdce_hw_status_t * hw_status,
++		    channel_config_t * vdce_conf_chan)
++{
++	dev_dbg(vdce_device, "<fn> vdce_Get_status E\n</fn>");
++	hw_status->chan_status = vdce_conf_chan->status;
++	dev_dbg(vdce_device, "<fn>vdce_Get_status E\n</fn>");
++	return 0;
++}
++
++/*
++ * vdce_get_status : This function used to get default params
++*/
++int vdce_get_default(vdce_params_t * def_params)
++{
++	vdce_params_t *vdce_temp_params = NULL;
++	if (def_params->vdce_mode == VDCE_OPERATION_PRE_CODECMODE) {
++		vdce_temp_params = &precodec_default_params;
++	} else if (def_params->vdce_mode == VDCE_OPERATION_POST_CODECMODE) {
++		vdce_temp_params = &postcodec_default_params;
++	} else if (def_params->vdce_mode == VDCE_OPERATION_TRANS_CODECMODE) {
++		vdce_temp_params = &transcodec_default_params;
++	} else if (def_params->vdce_mode == VDCE_OPERATION_EDGE_PADDING) {
++		vdce_temp_params = &epad_default_params;
++	} else if (def_params->vdce_mode == VDCE_OPERATION_RESIZING) {
++		vdce_temp_params = &rsz_default_params;
++	} else if (def_params->vdce_mode == VDCE_OPERATION_BLENDING) {
++		vdce_temp_params = &blend_default_params;
++	} else if (def_params->vdce_mode == VDCE_OPERATION_RANGE_MAPPING) {
++		vdce_temp_params = &rmap_default_params;
++	} else if (def_params->
++		   vdce_mode == VDCE_OPERATION_CHROMINANCE_CONVERSION) {
++		vdce_temp_params = &ccv_default_params;
++	}
++	memcpy(def_params, vdce_temp_params, sizeof(vdce_params_t));
++	return 0;
++
++}
++
++/*
++ * vdce_open : This function creates a channels.
++ */
++static int vdce_open(struct inode *inode, struct file *filp)
++{
++	channel_config_t *vdce_conf_chan = NULL;
++
++	dev_dbg(vdce_device, "<fn> vdce_open E\n</fn>");
++	/* if usage counter is greater than maximum supported channels
++	   return error */
++	/*if (device_config.module_usage_count >= MAX_CHANNELS) {
++		dev_err(vdce_device,
++			"\n modules usage count	is greater than	supported ");
++		return -EBUSY;
++	}*/
++	if (device_config.module_usage_count == 0) {
++		device_config.sem_isr.done = 0;
++	}
++	/* allocate memory for a new configuration */
++	vdce_conf_chan = kmalloc(sizeof(channel_config_t), GFP_KERNEL);
++
++	if (vdce_conf_chan == NULL) {
++		dev_err(vdce_device,
++			"cannot allocate memory ro channel config\n");
++		return -ENOMEM;
++	}
++	dev_dbg(vdce_device,
++		"Malloc	Done for channel configuration structure\n");
++	if (filp->f_flags == (O_NONBLOCK | O_RDWR)) {
++		vdce_conf_chan->channel_mode = VDCE_MODE_NON_BLOCKING;
++	}
++	/* zeroing register config */
++	memset(vdce_conf_chan, 0, sizeof(channel_config_t));
++	if (filp->f_flags == (O_NONBLOCK | O_RDWR)) {
++		vdce_conf_chan->channel_mode = VDCE_MODE_NON_BLOCKING;
++	}
++	vdce_conf_chan->status = VDCE_CHAN_UNINITIALISED;
++
++	/* increment usage counter */
++	/* Lock the global variable and increment the counter */
++	device_config.module_usage_count++;
++
++	/*STATE_NOT_CONFIGURED and priority to zero */
++	vdce_conf_chan->mode_state = VDCE_CHAN_UNINITIALISED;
++
++	dev_dbg(vdce_device, "Initializing of channel done \n");
++
++	/* taking the configuartion     structure in private data */
++	filp->private_data = vdce_conf_chan;
++
++	dev_dbg(vdce_device, "<fn> vdce_open L\n</fn>");
++
++	return 0;
++}
++
++/*
++ * vdce_release : The Function is used to release the number of
++ * resources occupied by the channel
++*/
++static int vdce_release(struct inode *inode, struct file *filp)
++{
++
++	/* get the configuratin of this channel from private_date member of
++	   file */
++	channel_config_t *vdce_conf_chan =
++	    (channel_config_t *) filp->private_data;
++
++	dev_dbg(vdce_device, "<fn> vdce_release E\n</fn>");
++
++	/* it will free all the input and output buffers */
++	free_buff(vdce_conf_chan);
++	/* decrements the module usage count; */
++	/* lock the global variable and decrement variable */
++	device_config.module_usage_count--;
++	kfree(vdce_conf_chan);
++	dev_dbg(vdce_device, "<fn> vdce_release L\n</fn>");
++	return 0;
++}
++
++/*
++ * vdce_mmap : Function to map device memory into user space
++ */
++static int vdce_mmap(struct file *filp, struct vm_area_struct *vma)
++{
++	/* get the configuratin of this channel from private_date
++	   member of file */
++	/* for looping purpuse */
++	int buffercounter = 0;
++	int i;
++	/* for checking purpose */
++	int flag = 0;
++	/* hold number of input and output buffer allocated */
++	int buffer_offset = 0;
++	unsigned int offset = vma->vm_pgoff << PAGE_SHIFT;
++
++	channel_config_t *vdce_conf_chan =
++	    (channel_config_t *) filp->private_data;
++
++	dev_dbg(vdce_device, "<fn> vdce_mmap E\n</fn>");
++
++	for (i = 0; i < 3; i++) {
++		/*find the input address which  is to be mapped */
++		for (buffercounter = 0; buffercounter <
++		     vdce_conf_chan->vdce_buffer[i].num_allocated;
++		     buffercounter++) {
++			buffer_offset =
++			    virt_to_phys(vdce_conf_chan->vdce_buffer[i].
++					 buffers[buffercounter]);
++			if (buffer_offset == offset) {
++				flag = 1;
++				break;
++			}
++		}
++		if (flag == 1) {
++			break;
++		}
++
++	}
++	/* the address to be mapped is not found so return error */
++	if (flag == 0)
++		return -EAGAIN;
++
++	dev_dbg(vdce_device, "The	address	mapped via mmap");
++	/* map the address from user space to kernel space */
++	if (remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff,
++			    vma->vm_end - vma->vm_start, vma->vm_page_prot)) {
++		return -EAGAIN;
++	}
++	dev_dbg(vdce_device, "<fn> vdce_mmap L\n</fn>");
++
++	return 0;
++}
++
++/*
++ * vdce_ioctl : This function will process IOCTL commands sent by
++ * the application and control .
++ */
++static int vdce_ioctl(struct inode *inode, struct file *file,
++		      unsigned int cmd, unsigned long arg)
++{
++	int ret = 0;
++	vdce_address_start_t start;
++	vdce_params_t params;
++	vdce_buffer_t buffer;
++	vdce_reqbufs_t reqbuff;
++	/*get the configuratin of this channel from
++	   private_date member of file */
++	channel_config_t *vdce_conf_chan =
++	    (channel_config_t *) file->private_data;
++
++	dev_dbg(vdce_device, " vdce_ioctl E\n");
++	/* before decoding check for correctness of cmd */
++	if (_IOC_TYPE(cmd) != VDCE_IOC_BASE) {
++		dev_err(vdce_device, "Bad command Value \n");
++		return -1;
++	}
++	if (_IOC_NR(cmd) > VDCE_IOC_MAXNR) {
++		dev_err(vdce_device, "Bad Command Value\n");
++		return -1;
++	}
++	/*veryfying access permission of commands */
++	if (_IOC_DIR(cmd) & _IOC_READ) {
++
++		ret = !access_ok(VERIFY_WRITE, (void *)arg, _IOC_SIZE(cmd));
++	} else if (_IOC_DIR(cmd) & _IOC_WRITE) {
++
++		ret = !access_ok(VERIFY_READ, (void *)arg, _IOC_SIZE(cmd));
++	}
++	if (ret) {
++		dev_err(vdce_device, "access denied\n");
++		return -1;	/*error in access */
++	}
++
++	/* switch according value of cmd */
++	switch (cmd) {
++		/*this ioctl is used to request frame buffers to be
++		   allocated by the ge module. The allocated buffers
++		   are channel  specific and can be     addressed
++		   by indexing */
++	case VDCE_REQBUF:
++		/* function to allocate the memory to input
++		   or output buffer. */
++		if (copy_from_user(&reqbuff, (vdce_reqbufs_t *) arg,
++				   sizeof(vdce_reqbufs_t))) {
++			ret = -EFAULT;
++			break;
++		}
++
++		ret = malloc_buff(&reqbuff, vdce_conf_chan);
++
++		if (copy_to_user((vdce_reqbufs_t *) arg,
++				 &reqbuff, sizeof(vdce_reqbufs_t)))
++			ret = -EFAULT;
++		break;
++		/*this ioctl is used to query the physical address of a
++		   particular frame buffer. */
++	case VDCE_QUERYBUF:
++		if (copy_from_user(&buffer, (vdce_buffer_t *) arg,
++				   sizeof(vdce_buffer_t))) {
++			ret = -EFAULT;
++			break;
++		}
++		ret = get_buf_address(&buffer, vdce_conf_chan);
++
++		if (copy_to_user((vdce_buffer_t *) arg,
++				 &buffer, sizeof(vdce_buffer_t)))
++			ret = -EFAULT;
++		break;
++
++		/* this ioctl is used to set the parameters
++		   of the GE hardware, parameters. */
++	case VDCE_SET_PARAMS:
++		/* function to set the hardware configuration */
++		if (copy_from_user(&params, (vdce_params_t *) arg,
++				   sizeof(vdce_params_t))) {
++			ret = -EFAULT;
++			break;
++		}
++		ret = vdce_check_common_params(&params);
++		if (0 == ret) {
++			ret = vdce_set_params(&params, vdce_conf_chan);
++		} else {
++			dev_err(vdce_device, "\n VDCE wrong parameters \n");
++		}
++		break;
++		/*this ioctl is used to get the GE hardware settings
++		   associated with the current logical channel represented
++		   by fd. */
++	case VDCE_GET_PARAMS:
++		/* function to get the hardware configuration */
++		ret = vdce_get_params((vdce_params_t *) arg, vdce_conf_chan);
++		break;
++	case VDCE_GET_DEFAULT:
++		/* this ioctl is used to get the default parameters
++		   of the ge hardware */
++		ret = vdce_get_default((vdce_params_t *) arg);
++		break;
++
++	case VDCE_START:
++		if (copy_from_user(&start, (vdce_address_start_t *) arg,
++				   sizeof(vdce_address_start_t))) {
++			ret = -EFAULT;
++			break;
++		}
++
++		ret = vdce_start(&start, vdce_conf_chan);
++		break;
++	default:
++		dev_dbg(vdce_device, "VDCE_ioctl: Invalid Command Value");
++		ret = -EINVAL;
++	}
++
++	dev_dbg(vdce_device, " vdce_ioctl L\n");
++
++	return ret;
++}
++static struct file_operations vdce_fops = {
++	.owner = THIS_MODULE,
++	.open = vdce_open,
++	.release = vdce_release,
++	.mmap = vdce_mmap,
++	.ioctl = vdce_ioctl,
++};
++
++/*
++ * vdce_isr : Function to register the ge character device driver
++ */
++irqreturn_t vdce_isr(int irq, void *dev_id)
++{
++        if (((vdce_current_chan->num_pass == VDCE_MULTIPASS) &&
++             (vdce_current_chan->vdce_complete == VDCE_PASS1_STARTED))) {
++                vdce_current_chan->vdce_complete = VDCE_PASS2_STARTED;
++
++                tasklet_schedule(&short_tasklet);
++
++        } else {
++                vdce_current_chan->vdce_complete = VDCE_COMPLETED;
++
++        }
++
++	if(vdce_current_chan->vdce_complete == VDCE_COMPLETED) {
++		complete(&(device_config.sem_isr));
++	}
++	return IRQ_HANDLED;
++}
++
++/*
++ * process_nonblock : Function to process_nonblocking call
++ */
++void process_bottomhalf(unsigned long ret)
++{
++	/* codec mode used */
++	channel_config_t *vdce_conf_chan =
++		vdce_current_chan;
++	int pass_num;
++	if (vdce_conf_chan->vdce_complete == VDCE_PASS2_STARTED) {
++		/* set 2 pass register configuration */
++		pass_num = 1;
++	} else {
++		vdce_conf_chan->vdce_complete = VDCE_PASS1_STARTED;
++		/* set 1 pass register configuration */
++		pass_num = 0;
++	}
++	/*function call to set up the hardware */
++	vdce_hw_setup(&vdce_conf_chan->register_config[pass_num]);
++
++	/*function call to enable ge hardware */
++	ret = vdce_enable(&vdce_conf_chan->register_config[pass_num]);
++
++	dev_dbg(vdce_device, "<fn> process_nonblock L</fn>\n");
++}
++static void vdce_platform_release(struct device *device)
++{
++	/* this is called when the reference count goes to zero */
++}
++static int __init vdce_probe(struct device *device)
++{
++	vdce_device = device;
++	return 0;
++}
++static int vdce_remove(struct device *device)
++{
++	return 0;
++}
++static struct class *vdce_class = NULL;
++
++static struct platform_device graphics_device = {
++	.name = DRIVERNAME,
++	.id = 2,
++	.dev = {
++	   .release = vdce_platform_release,
++	}
++};
++static struct device_driver vdce_driver = {
++	.name = DRIVERNAME,
++	.bus = &platform_bus_type,
++	.probe = vdce_probe,
++	.remove = vdce_remove,
++};
++
++/*
++ * vdce_init : Function to register ge character driver
++ */
++static int __init vdce_init(void)
++{
++	int result;
++	int adr;
++	int size;
++	struct device *temp =NULL;
++
++	device_config.module_usage_count = 0;
++
++	/* register the driver in the kernel */
++	result = alloc_chrdev_region(&dev, 0, 1, DRIVER_NAME);
++	if (result < 0) {
++		printk(KERN_ERR "\nDaVincige: Module intialization failed.\
++				could not register character device");
++		return -ENODEV;
++	}
++	/* initialize of character device */
++	cdev_init(&c_dev, &vdce_fops);
++	c_dev.owner = THIS_MODULE;
++	c_dev.ops = &vdce_fops;
++	/* addding character device */
++	result = cdev_add(&c_dev, dev, 1);
++	if (result) {
++		printk(KERN_ERR "NOtICE \nDaVincige:Error %d adding DavinciVDCE\
++				..error no:", result);
++		result = -EINVAL;
++		goto label1;
++	}
++	/* registeration of character device */
++	register_chrdev(MAJOR(dev), DRIVER_NAME, &vdce_fops);
++
++	/* register driver as a platform driver */
++	if (driver_register(&vdce_driver) != 0) {
++		result = -EINVAL;
++		goto label2;
++	}
++	/* register the drive as a platform device */
++	if (platform_device_register(&graphics_device) != 0) {
++		result = -EINVAL;
++		goto label3;
++	}
++	vdce_class = class_create(THIS_MODULE, DRIVERNAME);
++	if (IS_ERR(vdce_class)) {
++		result = -EIO;
++		goto label4;
++	}
++
++	temp = device_create(vdce_class, NULL, dev, NULL, DRIVERNAME);
++	if (IS_ERR(temp)) {
++		result = -EIO;
++        	goto label5;
++	}
++
++	init_completion(&(device_config.sem_isr));
++	init_completion(&(device_config.edma_sem));
++	init_completion(&(device_config.device_access));
++
++	device_config.sem_isr.done = 0;
++	device_config.edma_sem.done = 0;
++	device_config.device_access.done = 1;
++
++	/* initialize the device mutex */
++	device_config.irqlock = SPIN_LOCK_UNLOCKED;
++
++	/* set up the Interrupt handler for     ge interrupt */
++	result =
++		request_irq(VDCE_INTERRUPT, vdce_isr, 0,
++				"DavinciHD_VDCE", (void *)NULL);
++	if (result < 0) {
++		printk(KERN_ERR "Cannot initialize IRQ \n");
++		result = -EINVAL;
++		goto label6;
++
++	}
++
++	device_config.inter_size = inter_bufsize;
++	if (device_config.inter_size > 0) {
++		device_config.inter_buffer =
++			(void *)(__get_free_pages(GFP_KERNEL | GFP_DMA,
++						  get_order((device_config.
++							  inter_size))));
++		if (!(device_config.inter_buffer)) {
++			goto label6;
++		}
++
++		adr = (unsigned int)device_config.inter_buffer;
++		size = PAGE_SIZE << (get_order((device_config.inter_size)));
++		while (size > 0) {
++			/* make  sure the frame buffers
++			   are never swapped out of memory */
++			SetPageReserved(virt_to_page(adr));
++			adr += PAGE_SIZE;
++			size -= PAGE_SIZE;
++		}
++	}
++
++	result = vdce_enable_int();
++	if (result < 0) {
++		printk(KERN_ERR "Cannot init register \n");
++		result = -EINVAL;
++		goto label6;
++
++	} else {
++		result = 0;
++		goto done;
++	}
++label6:
++	device_destroy(vdce_class, dev);
++label5:
++	class_destroy(vdce_class);
++label4:
++	platform_device_unregister(&graphics_device);
++label3:
++	driver_unregister(&vdce_driver);
++label2:
++	cdev_del(&c_dev);
++	unregister_chrdev(MAJOR(dev), DRIVER_NAME);
++label1:
++	unregister_chrdev_region(dev, 1);
++
++done:
++	return result;
++}
++
++/*
++ * vdce_cleanup : Function is called by the kernel. It unregister
++ * the device.
++ */
++void __exit vdce_cleanup(void)
++{
++	device_destroy(vdce_class, dev);
++	if (device_config.inter_size > 0) {
++		vdce_free_pages((int)device_config.inter_buffer,
++				((device_config.inter_size)));
++	}
++	/* disable interrupt */
++	free_irq(VDCE_INTERRUPT, (void *)NULL);
++	/* destroy simple class */
++	class_destroy(vdce_class);
++	/* remove platform device */
++	platform_device_unregister(&graphics_device);
++	/* remove platform driver */
++	driver_unregister(&vdce_driver);
++	/* unregistering the driver from the kernel */
++	unregister_chrdev(MAJOR(dev), DRIVER_NAME);
++
++	cdev_del(&c_dev);
++
++	unregister_chrdev_region(dev, 1);
++
++}
++
++module_init(vdce_init)
++    module_exit(vdce_cleanup)
+--- a/arch/arm/configs/da830_omapl137_defconfig
++++ /dev/null
+@@ -1,1254 +0,0 @@
+-#
+-# Automatically generated make config: don't edit
+-# Linux kernel version: 2.6.30-rc2-davinci1
+-# Wed May 13 15:33:29 2009
+-#
+-CONFIG_ARM=y
+-CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+-CONFIG_GENERIC_GPIO=y
+-CONFIG_GENERIC_TIME=y
+-CONFIG_GENERIC_CLOCKEVENTS=y
+-CONFIG_MMU=y
+-# CONFIG_NO_IOPORT is not set
+-CONFIG_GENERIC_HARDIRQS=y
+-CONFIG_STACKTRACE_SUPPORT=y
+-CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+-CONFIG_LOCKDEP_SUPPORT=y
+-CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+-CONFIG_HARDIRQS_SW_RESEND=y
+-CONFIG_GENERIC_IRQ_PROBE=y
+-CONFIG_RWSEM_GENERIC_SPINLOCK=y
+-# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+-# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+-CONFIG_GENERIC_HWEIGHT=y
+-CONFIG_GENERIC_CALIBRATE_DELAY=y
+-CONFIG_ZONE_DMA=y
+-CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+-CONFIG_VECTORS_BASE=0xffff0000
+-CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+-
+-#
+-# General setup
+-#
+-CONFIG_EXPERIMENTAL=y
+-CONFIG_BROKEN_ON_SMP=y
+-CONFIG_LOCK_KERNEL=y
+-CONFIG_INIT_ENV_ARG_LIMIT=32
+-CONFIG_LOCALVERSION=""
+-CONFIG_LOCALVERSION_AUTO=y
+-# CONFIG_SWAP is not set
+-CONFIG_SYSVIPC=y
+-CONFIG_SYSVIPC_SYSCTL=y
+-CONFIG_POSIX_MQUEUE=y
+-CONFIG_POSIX_MQUEUE_SYSCTL=y
+-# CONFIG_BSD_PROCESS_ACCT is not set
+-# CONFIG_TASKSTATS is not set
+-# CONFIG_AUDIT is not set
+-
+-#
+-# RCU Subsystem
+-#
+-CONFIG_CLASSIC_RCU=y
+-# CONFIG_TREE_RCU is not set
+-# CONFIG_PREEMPT_RCU is not set
+-# CONFIG_TREE_RCU_TRACE is not set
+-# CONFIG_PREEMPT_RCU_TRACE is not set
+-CONFIG_IKCONFIG=y
+-CONFIG_IKCONFIG_PROC=y
+-CONFIG_LOG_BUF_SHIFT=14
+-CONFIG_GROUP_SCHED=y
+-CONFIG_FAIR_GROUP_SCHED=y
+-# CONFIG_RT_GROUP_SCHED is not set
+-CONFIG_USER_SCHED=y
+-# CONFIG_CGROUP_SCHED is not set
+-# CONFIG_CGROUPS is not set
+-CONFIG_SYSFS_DEPRECATED=y
+-CONFIG_SYSFS_DEPRECATED_V2=y
+-# CONFIG_RELAY is not set
+-# CONFIG_NAMESPACES is not set
+-CONFIG_BLK_DEV_INITRD=y
+-CONFIG_INITRAMFS_SOURCE=""
+-CONFIG_RD_GZIP=y
+-# CONFIG_RD_BZIP2 is not set
+-# CONFIG_RD_LZMA is not set
+-CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+-CONFIG_SYSCTL=y
+-CONFIG_ANON_INODES=y
+-CONFIG_EMBEDDED=y
+-CONFIG_UID16=y
+-CONFIG_SYSCTL_SYSCALL=y
+-CONFIG_KALLSYMS=y
+-# CONFIG_KALLSYMS_ALL is not set
+-# CONFIG_KALLSYMS_EXTRA_PASS is not set
+-# CONFIG_STRIP_ASM_SYMS is not set
+-CONFIG_HOTPLUG=y
+-CONFIG_PRINTK=y
+-CONFIG_BUG=y
+-CONFIG_ELF_CORE=y
+-CONFIG_BASE_FULL=y
+-CONFIG_FUTEX=y
+-CONFIG_EPOLL=y
+-CONFIG_SIGNALFD=y
+-CONFIG_TIMERFD=y
+-CONFIG_EVENTFD=y
+-CONFIG_SHMEM=y
+-CONFIG_AIO=y
+-CONFIG_VM_EVENT_COUNTERS=y
+-CONFIG_SLUB_DEBUG=y
+-CONFIG_COMPAT_BRK=y
+-# CONFIG_SLAB is not set
+-CONFIG_SLUB=y
+-# CONFIG_SLOB is not set
+-# CONFIG_PROFILING is not set
+-# CONFIG_MARKERS is not set
+-CONFIG_HAVE_OPROFILE=y
+-# CONFIG_KPROBES is not set
+-CONFIG_HAVE_KPROBES=y
+-CONFIG_HAVE_KRETPROBES=y
+-CONFIG_HAVE_CLK=y
+-# CONFIG_SLOW_WORK is not set
+-CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+-CONFIG_SLABINFO=y
+-CONFIG_RT_MUTEXES=y
+-CONFIG_BASE_SMALL=0
+-CONFIG_MODULES=y
+-# CONFIG_MODULE_FORCE_LOAD is not set
+-CONFIG_MODULE_UNLOAD=y
+-CONFIG_MODULE_FORCE_UNLOAD=y
+-CONFIG_MODVERSIONS=y
+-# CONFIG_MODULE_SRCVERSION_ALL is not set
+-CONFIG_BLOCK=y
+-# CONFIG_LBD is not set
+-# CONFIG_BLK_DEV_BSG is not set
+-# CONFIG_BLK_DEV_INTEGRITY is not set
+-
+-#
+-# IO Schedulers
+-#
+-CONFIG_IOSCHED_NOOP=y
+-CONFIG_IOSCHED_AS=y
+-# CONFIG_IOSCHED_DEADLINE is not set
+-# CONFIG_IOSCHED_CFQ is not set
+-CONFIG_DEFAULT_AS=y
+-# CONFIG_DEFAULT_DEADLINE is not set
+-# CONFIG_DEFAULT_CFQ is not set
+-# CONFIG_DEFAULT_NOOP is not set
+-CONFIG_DEFAULT_IOSCHED="anticipatory"
+-# CONFIG_FREEZER is not set
+-
+-#
+-# System Type
+-#
+-# CONFIG_ARCH_AAEC2000 is not set
+-# CONFIG_ARCH_INTEGRATOR is not set
+-# CONFIG_ARCH_REALVIEW is not set
+-# CONFIG_ARCH_VERSATILE is not set
+-# CONFIG_ARCH_AT91 is not set
+-# CONFIG_ARCH_CLPS711X is not set
+-# CONFIG_ARCH_EBSA110 is not set
+-# CONFIG_ARCH_EP93XX is not set
+-# CONFIG_ARCH_GEMINI is not set
+-# CONFIG_ARCH_FOOTBRIDGE is not set
+-# CONFIG_ARCH_NETX is not set
+-# CONFIG_ARCH_H720X is not set
+-# CONFIG_ARCH_IMX is not set
+-# CONFIG_ARCH_IOP13XX is not set
+-# CONFIG_ARCH_IOP32X is not set
+-# CONFIG_ARCH_IOP33X is not set
+-# CONFIG_ARCH_IXP23XX is not set
+-# CONFIG_ARCH_IXP2000 is not set
+-# CONFIG_ARCH_IXP4XX is not set
+-# CONFIG_ARCH_L7200 is not set
+-# CONFIG_ARCH_KIRKWOOD is not set
+-# CONFIG_ARCH_KS8695 is not set
+-# CONFIG_ARCH_NS9XXX is not set
+-# CONFIG_ARCH_LOKI is not set
+-# CONFIG_ARCH_MV78XX0 is not set
+-# CONFIG_ARCH_MXC is not set
+-# CONFIG_ARCH_ORION5X is not set
+-# CONFIG_ARCH_PNX4008 is not set
+-# CONFIG_ARCH_PXA is not set
+-# CONFIG_ARCH_MMP is not set
+-# CONFIG_ARCH_RPC is not set
+-# CONFIG_ARCH_SA1100 is not set
+-# CONFIG_ARCH_S3C2410 is not set
+-# CONFIG_ARCH_S3C64XX is not set
+-# CONFIG_ARCH_SHARK is not set
+-# CONFIG_ARCH_LH7A40X is not set
+-CONFIG_ARCH_DAVINCI=y
+-# CONFIG_ARCH_OMAP is not set
+-# CONFIG_ARCH_MSM is not set
+-# CONFIG_ARCH_W90X900 is not set
+-CONFIG_CP_INTC=y
+-
+-#
+-# TI DaVinci Implementations
+-#
+-
+-#
+-# DaVinci Core Type
+-#
+-# CONFIG_ARCH_DAVINCI_DM644x is not set
+-# CONFIG_ARCH_DAVINCI_DM646x is not set
+-# CONFIG_ARCH_DAVINCI_DM355 is not set
+-CONFIG_ARCH_DAVINCI_DA830=y
+-
+-#
+-# DaVinci Board Type
+-#
+-CONFIG_MACH_DAVINCI_DA830_EVM=y
+-CONFIG_DAVINCI_MUX=y
+-# CONFIG_DAVINCI_MUX_DEBUG is not set
+-# CONFIG_DAVINCI_MUX_WARNINGS is not set
+-CONFIG_DAVINCI_RESET_CLOCKS=y
+-
+-#
+-# Processor Type
+-#
+-CONFIG_CPU_32=y
+-CONFIG_CPU_ARM926T=y
+-CONFIG_CPU_32v5=y
+-CONFIG_CPU_ABRT_EV5TJ=y
+-CONFIG_CPU_PABRT_NOIFAR=y
+-CONFIG_CPU_CACHE_VIVT=y
+-CONFIG_CPU_COPY_V4WB=y
+-CONFIG_CPU_TLB_V4WBI=y
+-CONFIG_CPU_CP15=y
+-CONFIG_CPU_CP15_MMU=y
+-
+-#
+-# Processor Features
+-#
+-CONFIG_ARM_THUMB=y
+-# CONFIG_CPU_ICACHE_DISABLE is not set
+-# CONFIG_CPU_DCACHE_DISABLE is not set
+-CONFIG_CPU_DCACHE_WRITETHROUGH=y
+-# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+-# CONFIG_OUTER_CACHE is not set
+-CONFIG_COMMON_CLKDEV=y
+-
+-#
+-# Bus support
+-#
+-# CONFIG_PCI_SYSCALL is not set
+-# CONFIG_ARCH_SUPPORTS_MSI is not set
+-# CONFIG_PCCARD is not set
+-
+-#
+-# Kernel Features
+-#
+-CONFIG_TICK_ONESHOT=y
+-CONFIG_NO_HZ=y
+-CONFIG_HIGH_RES_TIMERS=y
+-CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+-CONFIG_VMSPLIT_3G=y
+-# CONFIG_VMSPLIT_2G is not set
+-# CONFIG_VMSPLIT_1G is not set
+-CONFIG_PAGE_OFFSET=0xC0000000
+-CONFIG_PREEMPT=y
+-CONFIG_HZ=100
+-CONFIG_AEABI=y
+-# CONFIG_OABI_COMPAT is not set
+-CONFIG_ARCH_FLATMEM_HAS_HOLES=y
+-# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+-# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+-# CONFIG_HIGHMEM is not set
+-CONFIG_SELECT_MEMORY_MODEL=y
+-CONFIG_FLATMEM_MANUAL=y
+-# CONFIG_DISCONTIGMEM_MANUAL is not set
+-# CONFIG_SPARSEMEM_MANUAL is not set
+-CONFIG_FLATMEM=y
+-CONFIG_FLAT_NODE_MEM_MAP=y
+-CONFIG_PAGEFLAGS_EXTENDED=y
+-CONFIG_SPLIT_PTLOCK_CPUS=4096
+-# CONFIG_PHYS_ADDR_T_64BIT is not set
+-CONFIG_ZONE_DMA_FLAG=1
+-CONFIG_BOUNCE=y
+-CONFIG_VIRT_TO_BUS=y
+-CONFIG_UNEVICTABLE_LRU=y
+-CONFIG_HAVE_MLOCK=y
+-CONFIG_HAVE_MLOCKED_PAGE_BIT=y
+-CONFIG_LEDS=y
+-# CONFIG_LEDS_CPU is not set
+-CONFIG_ALIGNMENT_TRAP=y
+-
+-#
+-# Boot options
+-#
+-CONFIG_ZBOOT_ROM_TEXT=0x0
+-CONFIG_ZBOOT_ROM_BSS=0x0
+-CONFIG_CMDLINE=""
+-# CONFIG_XIP_KERNEL is not set
+-# CONFIG_KEXEC is not set
+-
+-#
+-# CPU Power Management
+-#
+-# CONFIG_CPU_IDLE is not set
+-
+-#
+-# Floating point emulation
+-#
+-
+-#
+-# At least one emulation must be selected
+-#
+-# CONFIG_VFP is not set
+-
+-#
+-# Userspace binary formats
+-#
+-CONFIG_BINFMT_ELF=y
+-# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+-CONFIG_HAVE_AOUT=y
+-# CONFIG_BINFMT_AOUT is not set
+-# CONFIG_BINFMT_MISC is not set
+-
+-#
+-# Power management options
+-#
+-# CONFIG_PM is not set
+-CONFIG_ARCH_SUSPEND_POSSIBLE=y
+-CONFIG_NET=y
+-
+-#
+-# Networking options
+-#
+-CONFIG_PACKET=y
+-# CONFIG_PACKET_MMAP is not set
+-CONFIG_UNIX=y
+-CONFIG_XFRM=y
+-# CONFIG_XFRM_USER is not set
+-# CONFIG_XFRM_SUB_POLICY is not set
+-# CONFIG_XFRM_MIGRATE is not set
+-# CONFIG_XFRM_STATISTICS is not set
+-# CONFIG_NET_KEY is not set
+-CONFIG_INET=y
+-# CONFIG_IP_MULTICAST is not set
+-# CONFIG_IP_ADVANCED_ROUTER is not set
+-CONFIG_IP_FIB_HASH=y
+-CONFIG_IP_PNP=y
+-CONFIG_IP_PNP_DHCP=y
+-# CONFIG_IP_PNP_BOOTP is not set
+-# CONFIG_IP_PNP_RARP is not set
+-# CONFIG_NET_IPIP is not set
+-# CONFIG_NET_IPGRE is not set
+-# CONFIG_ARPD is not set
+-# CONFIG_SYN_COOKIES is not set
+-# CONFIG_INET_AH is not set
+-# CONFIG_INET_ESP is not set
+-# CONFIG_INET_IPCOMP is not set
+-# CONFIG_INET_XFRM_TUNNEL is not set
+-CONFIG_INET_TUNNEL=m
+-CONFIG_INET_XFRM_MODE_TRANSPORT=y
+-CONFIG_INET_XFRM_MODE_TUNNEL=y
+-CONFIG_INET_XFRM_MODE_BEET=y
+-# CONFIG_INET_LRO is not set
+-CONFIG_INET_DIAG=y
+-CONFIG_INET_TCP_DIAG=y
+-# CONFIG_TCP_CONG_ADVANCED is not set
+-CONFIG_TCP_CONG_CUBIC=y
+-CONFIG_DEFAULT_TCP_CONG="cubic"
+-# CONFIG_TCP_MD5SIG is not set
+-CONFIG_IPV6=m
+-# CONFIG_IPV6_PRIVACY is not set
+-# CONFIG_IPV6_ROUTER_PREF is not set
+-# CONFIG_IPV6_OPTIMISTIC_DAD is not set
+-# CONFIG_INET6_AH is not set
+-# CONFIG_INET6_ESP is not set
+-# CONFIG_INET6_IPCOMP is not set
+-# CONFIG_IPV6_MIP6 is not set
+-# CONFIG_INET6_XFRM_TUNNEL is not set
+-# CONFIG_INET6_TUNNEL is not set
+-CONFIG_INET6_XFRM_MODE_TRANSPORT=m
+-CONFIG_INET6_XFRM_MODE_TUNNEL=m
+-CONFIG_INET6_XFRM_MODE_BEET=m
+-# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
+-CONFIG_IPV6_SIT=m
+-CONFIG_IPV6_NDISC_NODETYPE=y
+-# CONFIG_IPV6_TUNNEL is not set
+-# CONFIG_IPV6_MULTIPLE_TABLES is not set
+-# CONFIG_IPV6_MROUTE is not set
+-# CONFIG_NETWORK_SECMARK is not set
+-CONFIG_NETFILTER=y
+-# CONFIG_NETFILTER_DEBUG is not set
+-CONFIG_NETFILTER_ADVANCED=y
+-
+-#
+-# Core Netfilter Configuration
+-#
+-# CONFIG_NETFILTER_NETLINK_QUEUE is not set
+-# CONFIG_NETFILTER_NETLINK_LOG is not set
+-# CONFIG_NF_CONNTRACK is not set
+-# CONFIG_NETFILTER_XTABLES is not set
+-# CONFIG_IP_VS is not set
+-
+-#
+-# IP: Netfilter Configuration
+-#
+-# CONFIG_NF_DEFRAG_IPV4 is not set
+-# CONFIG_IP_NF_QUEUE is not set
+-# CONFIG_IP_NF_IPTABLES is not set
+-# CONFIG_IP_NF_ARPTABLES is not set
+-
+-#
+-# IPv6: Netfilter Configuration
+-#
+-# CONFIG_IP6_NF_QUEUE is not set
+-# CONFIG_IP6_NF_IPTABLES is not set
+-# CONFIG_IP_DCCP is not set
+-# CONFIG_IP_SCTP is not set
+-# CONFIG_TIPC is not set
+-# CONFIG_ATM is not set
+-# CONFIG_BRIDGE is not set
+-# CONFIG_NET_DSA is not set
+-# CONFIG_VLAN_8021Q is not set
+-# CONFIG_DECNET is not set
+-# CONFIG_LLC2 is not set
+-# CONFIG_IPX is not set
+-# CONFIG_ATALK is not set
+-# CONFIG_X25 is not set
+-# CONFIG_LAPB is not set
+-# CONFIG_ECONET is not set
+-# CONFIG_WAN_ROUTER is not set
+-# CONFIG_PHONET is not set
+-# CONFIG_NET_SCHED is not set
+-# CONFIG_DCB is not set
+-
+-#
+-# Network testing
+-#
+-# CONFIG_NET_PKTGEN is not set
+-# CONFIG_HAMRADIO is not set
+-# CONFIG_CAN is not set
+-# CONFIG_IRDA is not set
+-# CONFIG_BT is not set
+-# CONFIG_AF_RXRPC is not set
+-# CONFIG_WIRELESS is not set
+-# CONFIG_WIMAX is not set
+-# CONFIG_RFKILL is not set
+-# CONFIG_NET_9P is not set
+-
+-#
+-# Device Drivers
+-#
+-
+-#
+-# Generic Driver Options
+-#
+-CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+-CONFIG_STANDALONE=y
+-CONFIG_PREVENT_FIRMWARE_BUILD=y
+-# CONFIG_FW_LOADER is not set
+-# CONFIG_DEBUG_DRIVER is not set
+-# CONFIG_DEBUG_DEVRES is not set
+-# CONFIG_SYS_HYPERVISOR is not set
+-# CONFIG_CONNECTOR is not set
+-# CONFIG_MTD is not set
+-# CONFIG_PARPORT is not set
+-CONFIG_BLK_DEV=y
+-# CONFIG_BLK_DEV_COW_COMMON is not set
+-CONFIG_BLK_DEV_LOOP=m
+-# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+-# CONFIG_BLK_DEV_NBD is not set
+-CONFIG_BLK_DEV_RAM=y
+-CONFIG_BLK_DEV_RAM_COUNT=1
+-CONFIG_BLK_DEV_RAM_SIZE=32768
+-# CONFIG_BLK_DEV_XIP is not set
+-# CONFIG_CDROM_PKTCDVD is not set
+-# CONFIG_ATA_OVER_ETH is not set
+-CONFIG_MISC_DEVICES=y
+-# CONFIG_ICS932S401 is not set
+-# CONFIG_ENCLOSURE_SERVICES is not set
+-# CONFIG_ISL29003 is not set
+-# CONFIG_C2PORT is not set
+-
+-#
+-# EEPROM support
+-#
+-CONFIG_EEPROM_AT24=y
+-# CONFIG_EEPROM_LEGACY is not set
+-# CONFIG_EEPROM_93CX6 is not set
+-CONFIG_HAVE_IDE=y
+-# CONFIG_IDE is not set
+-
+-#
+-# SCSI device support
+-#
+-# CONFIG_RAID_ATTRS is not set
+-CONFIG_SCSI=m
+-CONFIG_SCSI_DMA=y
+-# CONFIG_SCSI_TGT is not set
+-# CONFIG_SCSI_NETLINK is not set
+-CONFIG_SCSI_PROC_FS=y
+-
+-#
+-# SCSI support type (disk, tape, CD-ROM)
+-#
+-CONFIG_BLK_DEV_SD=m
+-# CONFIG_CHR_DEV_ST is not set
+-# CONFIG_CHR_DEV_OSST is not set
+-# CONFIG_BLK_DEV_SR is not set
+-# CONFIG_CHR_DEV_SG is not set
+-# CONFIG_CHR_DEV_SCH is not set
+-
+-#
+-# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+-#
+-# CONFIG_SCSI_MULTI_LUN is not set
+-# CONFIG_SCSI_CONSTANTS is not set
+-# CONFIG_SCSI_LOGGING is not set
+-# CONFIG_SCSI_SCAN_ASYNC is not set
+-CONFIG_SCSI_WAIT_SCAN=m
+-
+-#
+-# SCSI Transports
+-#
+-# CONFIG_SCSI_SPI_ATTRS is not set
+-# CONFIG_SCSI_FC_ATTRS is not set
+-# CONFIG_SCSI_ISCSI_ATTRS is not set
+-# CONFIG_SCSI_SAS_LIBSAS is not set
+-# CONFIG_SCSI_SRP_ATTRS is not set
+-CONFIG_SCSI_LOWLEVEL=y
+-# CONFIG_ISCSI_TCP is not set
+-# CONFIG_LIBFC is not set
+-# CONFIG_LIBFCOE is not set
+-# CONFIG_SCSI_DEBUG is not set
+-# CONFIG_SCSI_DH is not set
+-# CONFIG_SCSI_OSD_INITIATOR is not set
+-# CONFIG_ATA is not set
+-# CONFIG_MD is not set
+-CONFIG_NETDEVICES=y
+-CONFIG_COMPAT_NET_DEV_OPS=y
+-# CONFIG_DUMMY is not set
+-# CONFIG_BONDING is not set
+-# CONFIG_MACVLAN is not set
+-# CONFIG_EQUALIZER is not set
+-CONFIG_TUN=m
+-# CONFIG_VETH is not set
+-CONFIG_PHYLIB=y
+-
+-#
+-# MII PHY device drivers
+-#
+-# CONFIG_MARVELL_PHY is not set
+-# CONFIG_DAVICOM_PHY is not set
+-# CONFIG_QSEMI_PHY is not set
+-CONFIG_LXT_PHY=y
+-# CONFIG_CICADA_PHY is not set
+-# CONFIG_VITESSE_PHY is not set
+-# CONFIG_SMSC_PHY is not set
+-# CONFIG_BROADCOM_PHY is not set
+-# CONFIG_ICPLUS_PHY is not set
+-# CONFIG_REALTEK_PHY is not set
+-# CONFIG_NATIONAL_PHY is not set
+-# CONFIG_STE10XP is not set
+-CONFIG_LSI_ET1011C_PHY=y
+-# CONFIG_FIXED_PHY is not set
+-# CONFIG_MDIO_BITBANG is not set
+-CONFIG_NET_ETHERNET=y
+-CONFIG_MII=y
+-# CONFIG_AX88796 is not set
+-# CONFIG_SMC91X is not set
+-CONFIG_TI_DAVINCI_EMAC=y
+-# CONFIG_DM9000 is not set
+-# CONFIG_ETHOC is not set
+-# CONFIG_SMC911X is not set
+-# CONFIG_SMSC911X is not set
+-# CONFIG_DNET is not set
+-# CONFIG_IBM_NEW_EMAC_ZMII is not set
+-# CONFIG_IBM_NEW_EMAC_RGMII is not set
+-# CONFIG_IBM_NEW_EMAC_TAH is not set
+-# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+-# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+-# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+-# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+-# CONFIG_B44 is not set
+-# CONFIG_NETDEV_1000 is not set
+-# CONFIG_NETDEV_10000 is not set
+-
+-#
+-# Wireless LAN
+-#
+-# CONFIG_WLAN_PRE80211 is not set
+-# CONFIG_WLAN_80211 is not set
+-
+-#
+-# Enable WiMAX (Networking options) to see the WiMAX drivers
+-#
+-# CONFIG_WAN is not set
+-# CONFIG_PPP is not set
+-# CONFIG_SLIP is not set
+-CONFIG_NETCONSOLE=y
+-# CONFIG_NETCONSOLE_DYNAMIC is not set
+-CONFIG_NETPOLL=y
+-CONFIG_NETPOLL_TRAP=y
+-CONFIG_NET_POLL_CONTROLLER=y
+-# CONFIG_ISDN is not set
+-
+-#
+-# Input device support
+-#
+-CONFIG_INPUT=y
+-# CONFIG_INPUT_FF_MEMLESS is not set
+-# CONFIG_INPUT_POLLDEV is not set
+-
+-#
+-# Userland interfaces
+-#
+-CONFIG_INPUT_MOUSEDEV=m
+-CONFIG_INPUT_MOUSEDEV_PSAUX=y
+-CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+-CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+-# CONFIG_INPUT_JOYDEV is not set
+-CONFIG_INPUT_EVDEV=m
+-CONFIG_INPUT_EVBUG=m
+-
+-#
+-# Input Device Drivers
+-#
+-CONFIG_INPUT_KEYBOARD=y
+-CONFIG_KEYBOARD_ATKBD=m
+-# CONFIG_KEYBOARD_SUNKBD is not set
+-# CONFIG_KEYBOARD_LKKBD is not set
+-CONFIG_KEYBOARD_XTKBD=m
+-# CONFIG_KEYBOARD_NEWTON is not set
+-# CONFIG_KEYBOARD_STOWAWAY is not set
+-CONFIG_KEYBOARD_GPIO=y
+-# CONFIG_INPUT_MOUSE is not set
+-# CONFIG_INPUT_JOYSTICK is not set
+-# CONFIG_INPUT_TABLET is not set
+-CONFIG_INPUT_TOUCHSCREEN=y
+-# CONFIG_TOUCHSCREEN_AD7879_I2C is not set
+-# CONFIG_TOUCHSCREEN_AD7879 is not set
+-# CONFIG_TOUCHSCREEN_FUJITSU is not set
+-# CONFIG_TOUCHSCREEN_GUNZE is not set
+-# CONFIG_TOUCHSCREEN_ELO is not set
+-# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+-# CONFIG_TOUCHSCREEN_MTOUCH is not set
+-# CONFIG_TOUCHSCREEN_INEXIO is not set
+-# CONFIG_TOUCHSCREEN_MK712 is not set
+-# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+-# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+-# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+-# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+-# CONFIG_TOUCHSCREEN_TSC2007 is not set
+-# CONFIG_INPUT_MISC is not set
+-
+-#
+-# Hardware I/O ports
+-#
+-CONFIG_SERIO=y
+-CONFIG_SERIO_SERPORT=y
+-CONFIG_SERIO_LIBPS2=y
+-# CONFIG_SERIO_RAW is not set
+-# CONFIG_GAMEPORT is not set
+-
+-#
+-# Character devices
+-#
+-CONFIG_VT=y
+-CONFIG_CONSOLE_TRANSLATIONS=y
+-# CONFIG_VT_CONSOLE is not set
+-CONFIG_HW_CONSOLE=y
+-# CONFIG_VT_HW_CONSOLE_BINDING is not set
+-CONFIG_DEVKMEM=y
+-# CONFIG_SERIAL_NONSTANDARD is not set
+-
+-#
+-# Serial drivers
+-#
+-CONFIG_SERIAL_8250=y
+-CONFIG_SERIAL_8250_CONSOLE=y
+-CONFIG_SERIAL_8250_NR_UARTS=3
+-CONFIG_SERIAL_8250_RUNTIME_UARTS=3
+-# CONFIG_SERIAL_8250_EXTENDED is not set
+-
+-#
+-# Non-8250 serial port support
+-#
+-CONFIG_SERIAL_CORE=y
+-CONFIG_SERIAL_CORE_CONSOLE=y
+-CONFIG_UNIX98_PTYS=y
+-# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+-CONFIG_LEGACY_PTYS=y
+-CONFIG_LEGACY_PTY_COUNT=256
+-# CONFIG_IPMI_HANDLER is not set
+-CONFIG_HW_RANDOM=m
+-# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+-# CONFIG_R3964 is not set
+-# CONFIG_RAW_DRIVER is not set
+-# CONFIG_TCG_TPM is not set
+-CONFIG_I2C=y
+-CONFIG_I2C_BOARDINFO=y
+-CONFIG_I2C_CHARDEV=y
+-CONFIG_I2C_HELPER_AUTO=y
+-
+-#
+-# I2C Hardware Bus support
+-#
+-
+-#
+-# I2C system bus drivers (mostly embedded / system-on-chip)
+-#
+-CONFIG_I2C_DAVINCI=y
+-# CONFIG_I2C_GPIO is not set
+-# CONFIG_I2C_OCORES is not set
+-# CONFIG_I2C_SIMTEC is not set
+-
+-#
+-# External I2C/SMBus adapter drivers
+-#
+-# CONFIG_I2C_PARPORT_LIGHT is not set
+-# CONFIG_I2C_TAOS_EVM is not set
+-
+-#
+-# Other I2C/SMBus bus drivers
+-#
+-# CONFIG_I2C_PCA_PLATFORM is not set
+-# CONFIG_I2C_STUB is not set
+-
+-#
+-# Miscellaneous I2C Chip support
+-#
+-# CONFIG_DS1682 is not set
+-# CONFIG_SENSORS_PCA9539 is not set
+-# CONFIG_SENSORS_MAX6875 is not set
+-# CONFIG_SENSORS_TSL2550 is not set
+-# CONFIG_I2C_DEBUG_CORE is not set
+-# CONFIG_I2C_DEBUG_ALGO is not set
+-# CONFIG_I2C_DEBUG_BUS is not set
+-# CONFIG_I2C_DEBUG_CHIP is not set
+-# CONFIG_SPI is not set
+-CONFIG_ARCH_REQUIRE_GPIOLIB=y
+-CONFIG_GPIOLIB=y
+-# CONFIG_DEBUG_GPIO is not set
+-# CONFIG_GPIO_SYSFS is not set
+-
+-#
+-# Memory mapped GPIO expanders:
+-#
+-
+-#
+-# I2C GPIO expanders:
+-#
+-# CONFIG_GPIO_MAX732X is not set
+-# CONFIG_GPIO_PCA953X is not set
+-CONFIG_GPIO_PCF857X=m
+-
+-#
+-# PCI GPIO expanders:
+-#
+-
+-#
+-# SPI GPIO expanders:
+-#
+-# CONFIG_W1 is not set
+-# CONFIG_POWER_SUPPLY is not set
+-# CONFIG_HWMON is not set
+-# CONFIG_THERMAL is not set
+-# CONFIG_THERMAL_HWMON is not set
+-CONFIG_WATCHDOG=y
+-# CONFIG_WATCHDOG_NOWAYOUT is not set
+-
+-#
+-# Watchdog Device Drivers
+-#
+-# CONFIG_SOFT_WATCHDOG is not set
+-# CONFIG_DAVINCI_WATCHDOG is not set
+-CONFIG_SSB_POSSIBLE=y
+-
+-#
+-# Sonics Silicon Backplane
+-#
+-# CONFIG_SSB is not set
+-
+-#
+-# Multifunction device drivers
+-#
+-# CONFIG_MFD_CORE is not set
+-# CONFIG_MFD_SM501 is not set
+-# CONFIG_MFD_ASIC3 is not set
+-# CONFIG_HTC_EGPIO is not set
+-# CONFIG_HTC_PASIC3 is not set
+-# CONFIG_TPS65010 is not set
+-# CONFIG_TWL4030_CORE is not set
+-# CONFIG_MFD_TMIO is not set
+-# CONFIG_MFD_T7L66XB is not set
+-# CONFIG_MFD_TC6387XB is not set
+-# CONFIG_MFD_TC6393XB is not set
+-# CONFIG_PMIC_DA903X is not set
+-# CONFIG_MFD_WM8400 is not set
+-# CONFIG_MFD_WM8350_I2C is not set
+-# CONFIG_MFD_PCF50633 is not set
+-
+-#
+-# Multimedia devices
+-#
+-
+-#
+-# Multimedia core support
+-#
+-# CONFIG_VIDEO_DEV is not set
+-# CONFIG_DVB_CORE is not set
+-# CONFIG_VIDEO_MEDIA is not set
+-
+-#
+-# Multimedia drivers
+-#
+-# CONFIG_DAB is not set
+-
+-#
+-# Graphics support
+-#
+-# CONFIG_VGASTATE is not set
+-# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+-# CONFIG_FB is not set
+-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+-
+-#
+-# Display device support
+-#
+-# CONFIG_DISPLAY_SUPPORT is not set
+-
+-#
+-# Console display driver support
+-#
+-# CONFIG_VGA_CONSOLE is not set
+-CONFIG_DUMMY_CONSOLE=y
+-CONFIG_SOUND=m
+-# CONFIG_SOUND_OSS_CORE is not set
+-CONFIG_SND=m
+-CONFIG_SND_TIMER=m
+-CONFIG_SND_PCM=m
+-CONFIG_SND_JACK=y
+-# CONFIG_SND_SEQUENCER is not set
+-# CONFIG_SND_MIXER_OSS is not set
+-# CONFIG_SND_PCM_OSS is not set
+-# CONFIG_SND_HRTIMER is not set
+-# CONFIG_SND_DYNAMIC_MINORS is not set
+-CONFIG_SND_SUPPORT_OLD_API=y
+-CONFIG_SND_VERBOSE_PROCFS=y
+-# CONFIG_SND_VERBOSE_PRINTK is not set
+-# CONFIG_SND_DEBUG is not set
+-CONFIG_SND_DRIVERS=y
+-# CONFIG_SND_DUMMY is not set
+-# CONFIG_SND_MTPAV is not set
+-# CONFIG_SND_SERIAL_U16550 is not set
+-# CONFIG_SND_MPU401 is not set
+-CONFIG_SND_ARM=y
+-CONFIG_SND_SOC=m
+-CONFIG_SND_DAVINCI_SOC=m
+-CONFIG_SND_SOC_I2C_AND_SPI=m
+-# CONFIG_SND_SOC_ALL_CODECS is not set
+-# CONFIG_SOUND_PRIME is not set
+-# CONFIG_HID_SUPPORT is not set
+-# CONFIG_USB_SUPPORT is not set
+-# CONFIG_USB_MUSB_HOST is not set
+-# CONFIG_USB_MUSB_PERIPHERAL is not set
+-# CONFIG_USB_MUSB_OTG is not set
+-# CONFIG_USB_GADGET_MUSB_HDRC is not set
+-# CONFIG_USB_GADGET_AT91 is not set
+-# CONFIG_USB_GADGET_ATMEL_USBA is not set
+-# CONFIG_USB_GADGET_FSL_USB2 is not set
+-# CONFIG_USB_GADGET_LH7A40X is not set
+-# CONFIG_USB_GADGET_OMAP is not set
+-# CONFIG_USB_GADGET_PXA25X is not set
+-# CONFIG_USB_GADGET_PXA27X is not set
+-# CONFIG_USB_GADGET_S3C2410 is not set
+-# CONFIG_USB_GADGET_IMX is not set
+-# CONFIG_USB_GADGET_M66592 is not set
+-# CONFIG_USB_GADGET_AMD5536UDC is not set
+-# CONFIG_USB_GADGET_FSL_QE is not set
+-# CONFIG_USB_GADGET_CI13XXX is not set
+-# CONFIG_USB_GADGET_NET2280 is not set
+-# CONFIG_USB_GADGET_GOKU is not set
+-# CONFIG_USB_GADGET_DUMMY_HCD is not set
+-# CONFIG_USB_ZERO is not set
+-# CONFIG_USB_ETH is not set
+-# CONFIG_USB_GADGETFS is not set
+-# CONFIG_USB_FILE_STORAGE is not set
+-# CONFIG_USB_G_SERIAL is not set
+-# CONFIG_USB_MIDI_GADGET is not set
+-# CONFIG_USB_G_PRINTER is not set
+-# CONFIG_USB_CDC_COMPOSITE is not set
+-# CONFIG_MMC is not set
+-# CONFIG_MEMSTICK is not set
+-# CONFIG_ACCESSIBILITY is not set
+-# CONFIG_NEW_LEDS is not set
+-CONFIG_RTC_LIB=y
+-# CONFIG_RTC_CLASS is not set
+-# CONFIG_DMADEVICES is not set
+-# CONFIG_AUXDISPLAY is not set
+-# CONFIG_REGULATOR is not set
+-# CONFIG_UIO is not set
+-# CONFIG_STAGING is not set
+-
+-#
+-# File systems
+-#
+-CONFIG_EXT2_FS=y
+-# CONFIG_EXT2_FS_XATTR is not set
+-# CONFIG_EXT2_FS_XIP is not set
+-CONFIG_EXT3_FS=y
+-# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
+-CONFIG_EXT3_FS_XATTR=y
+-# CONFIG_EXT3_FS_POSIX_ACL is not set
+-# CONFIG_EXT3_FS_SECURITY is not set
+-# CONFIG_EXT4_FS is not set
+-CONFIG_JBD=y
+-# CONFIG_JBD_DEBUG is not set
+-CONFIG_FS_MBCACHE=y
+-# CONFIG_REISERFS_FS is not set
+-# CONFIG_JFS_FS is not set
+-# CONFIG_FS_POSIX_ACL is not set
+-CONFIG_FILE_LOCKING=y
+-CONFIG_XFS_FS=m
+-# CONFIG_XFS_QUOTA is not set
+-# CONFIG_XFS_POSIX_ACL is not set
+-# CONFIG_XFS_RT is not set
+-# CONFIG_XFS_DEBUG is not set
+-# CONFIG_OCFS2_FS is not set
+-# CONFIG_BTRFS_FS is not set
+-CONFIG_DNOTIFY=y
+-CONFIG_INOTIFY=y
+-CONFIG_INOTIFY_USER=y
+-# CONFIG_QUOTA is not set
+-# CONFIG_AUTOFS_FS is not set
+-CONFIG_AUTOFS4_FS=m
+-# CONFIG_FUSE_FS is not set
+-
+-#
+-# Caches
+-#
+-# CONFIG_FSCACHE is not set
+-
+-#
+-# CD-ROM/DVD Filesystems
+-#
+-# CONFIG_ISO9660_FS is not set
+-# CONFIG_UDF_FS is not set
+-
+-#
+-# DOS/FAT/NT Filesystems
+-#
+-CONFIG_FAT_FS=y
+-CONFIG_MSDOS_FS=y
+-CONFIG_VFAT_FS=y
+-CONFIG_FAT_DEFAULT_CODEPAGE=437
+-CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+-# CONFIG_NTFS_FS is not set
+-
+-#
+-# Pseudo filesystems
+-#
+-CONFIG_PROC_FS=y
+-CONFIG_PROC_SYSCTL=y
+-CONFIG_PROC_PAGE_MONITOR=y
+-CONFIG_SYSFS=y
+-CONFIG_TMPFS=y
+-# CONFIG_TMPFS_POSIX_ACL is not set
+-# CONFIG_HUGETLB_PAGE is not set
+-# CONFIG_CONFIGFS_FS is not set
+-CONFIG_MISC_FILESYSTEMS=y
+-# CONFIG_ADFS_FS is not set
+-# CONFIG_AFFS_FS is not set
+-# CONFIG_HFS_FS is not set
+-# CONFIG_HFSPLUS_FS is not set
+-# CONFIG_BEFS_FS is not set
+-# CONFIG_BFS_FS is not set
+-# CONFIG_EFS_FS is not set
+-CONFIG_CRAMFS=y
+-# CONFIG_SQUASHFS is not set
+-# CONFIG_VXFS_FS is not set
+-CONFIG_MINIX_FS=m
+-# CONFIG_OMFS_FS is not set
+-# CONFIG_HPFS_FS is not set
+-# CONFIG_QNX4FS_FS is not set
+-# CONFIG_ROMFS_FS is not set
+-# CONFIG_SYSV_FS is not set
+-# CONFIG_UFS_FS is not set
+-# CONFIG_NILFS2_FS is not set
+-CONFIG_NETWORK_FILESYSTEMS=y
+-CONFIG_NFS_FS=y
+-CONFIG_NFS_V3=y
+-# CONFIG_NFS_V3_ACL is not set
+-# CONFIG_NFS_V4 is not set
+-CONFIG_ROOT_NFS=y
+-CONFIG_NFSD=m
+-CONFIG_NFSD_V3=y
+-# CONFIG_NFSD_V3_ACL is not set
+-# CONFIG_NFSD_V4 is not set
+-CONFIG_LOCKD=y
+-CONFIG_LOCKD_V4=y
+-CONFIG_EXPORTFS=m
+-CONFIG_NFS_COMMON=y
+-CONFIG_SUNRPC=y
+-# CONFIG_RPCSEC_GSS_KRB5 is not set
+-# CONFIG_RPCSEC_GSS_SPKM3 is not set
+-CONFIG_SMB_FS=m
+-# CONFIG_SMB_NLS_DEFAULT is not set
+-# CONFIG_CIFS is not set
+-# CONFIG_NCP_FS is not set
+-# CONFIG_CODA_FS is not set
+-# CONFIG_AFS_FS is not set
+-
+-#
+-# Partition Types
+-#
+-CONFIG_PARTITION_ADVANCED=y
+-# CONFIG_ACORN_PARTITION is not set
+-# CONFIG_OSF_PARTITION is not set
+-# CONFIG_AMIGA_PARTITION is not set
+-# CONFIG_ATARI_PARTITION is not set
+-# CONFIG_MAC_PARTITION is not set
+-CONFIG_MSDOS_PARTITION=y
+-# CONFIG_BSD_DISKLABEL is not set
+-# CONFIG_MINIX_SUBPARTITION is not set
+-# CONFIG_SOLARIS_X86_PARTITION is not set
+-# CONFIG_UNIXWARE_DISKLABEL is not set
+-# CONFIG_LDM_PARTITION is not set
+-# CONFIG_SGI_PARTITION is not set
+-# CONFIG_ULTRIX_PARTITION is not set
+-# CONFIG_SUN_PARTITION is not set
+-# CONFIG_KARMA_PARTITION is not set
+-# CONFIG_EFI_PARTITION is not set
+-# CONFIG_SYSV68_PARTITION is not set
+-CONFIG_NLS=y
+-CONFIG_NLS_DEFAULT="iso8859-1"
+-CONFIG_NLS_CODEPAGE_437=y
+-# CONFIG_NLS_CODEPAGE_737 is not set
+-# CONFIG_NLS_CODEPAGE_775 is not set
+-# CONFIG_NLS_CODEPAGE_850 is not set
+-# CONFIG_NLS_CODEPAGE_852 is not set
+-# CONFIG_NLS_CODEPAGE_855 is not set
+-# CONFIG_NLS_CODEPAGE_857 is not set
+-# CONFIG_NLS_CODEPAGE_860 is not set
+-# CONFIG_NLS_CODEPAGE_861 is not set
+-# CONFIG_NLS_CODEPAGE_862 is not set
+-# CONFIG_NLS_CODEPAGE_863 is not set
+-# CONFIG_NLS_CODEPAGE_864 is not set
+-# CONFIG_NLS_CODEPAGE_865 is not set
+-# CONFIG_NLS_CODEPAGE_866 is not set
+-# CONFIG_NLS_CODEPAGE_869 is not set
+-# CONFIG_NLS_CODEPAGE_936 is not set
+-# CONFIG_NLS_CODEPAGE_950 is not set
+-# CONFIG_NLS_CODEPAGE_932 is not set
+-# CONFIG_NLS_CODEPAGE_949 is not set
+-# CONFIG_NLS_CODEPAGE_874 is not set
+-# CONFIG_NLS_ISO8859_8 is not set
+-# CONFIG_NLS_CODEPAGE_1250 is not set
+-# CONFIG_NLS_CODEPAGE_1251 is not set
+-CONFIG_NLS_ASCII=m
+-CONFIG_NLS_ISO8859_1=y
+-# CONFIG_NLS_ISO8859_2 is not set
+-# CONFIG_NLS_ISO8859_3 is not set
+-# CONFIG_NLS_ISO8859_4 is not set
+-# CONFIG_NLS_ISO8859_5 is not set
+-# CONFIG_NLS_ISO8859_6 is not set
+-# CONFIG_NLS_ISO8859_7 is not set
+-# CONFIG_NLS_ISO8859_9 is not set
+-# CONFIG_NLS_ISO8859_13 is not set
+-# CONFIG_NLS_ISO8859_14 is not set
+-# CONFIG_NLS_ISO8859_15 is not set
+-# CONFIG_NLS_KOI8_R is not set
+-# CONFIG_NLS_KOI8_U is not set
+-CONFIG_NLS_UTF8=m
+-# CONFIG_DLM is not set
+-
+-#
+-# Kernel hacking
+-#
+-# CONFIG_PRINTK_TIME is not set
+-CONFIG_ENABLE_WARN_DEPRECATED=y
+-CONFIG_ENABLE_MUST_CHECK=y
+-CONFIG_FRAME_WARN=1024
+-# CONFIG_MAGIC_SYSRQ is not set
+-# CONFIG_UNUSED_SYMBOLS is not set
+-CONFIG_DEBUG_FS=y
+-# CONFIG_HEADERS_CHECK is not set
+-CONFIG_DEBUG_KERNEL=y
+-# CONFIG_DEBUG_SHIRQ is not set
+-CONFIG_DETECT_SOFTLOCKUP=y
+-# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
+-CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+-CONFIG_DETECT_HUNG_TASK=y
+-# CONFIG_BOOTPARAM_HUNG_TASK_PANIC is not set
+-CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=0
+-CONFIG_SCHED_DEBUG=y
+-# CONFIG_SCHEDSTATS is not set
+-CONFIG_TIMER_STATS=y
+-# CONFIG_DEBUG_OBJECTS is not set
+-# CONFIG_SLUB_DEBUG_ON is not set
+-# CONFIG_SLUB_STATS is not set
+-CONFIG_DEBUG_PREEMPT=y
+-CONFIG_DEBUG_RT_MUTEXES=y
+-CONFIG_DEBUG_PI_LIST=y
+-# CONFIG_RT_MUTEX_TESTER is not set
+-# CONFIG_DEBUG_SPINLOCK is not set
+-CONFIG_DEBUG_MUTEXES=y
+-# CONFIG_DEBUG_LOCK_ALLOC is not set
+-# CONFIG_PROVE_LOCKING is not set
+-# CONFIG_LOCK_STAT is not set
+-# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+-# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+-# CONFIG_DEBUG_KOBJECT is not set
+-CONFIG_DEBUG_BUGVERBOSE=y
+-# CONFIG_DEBUG_INFO is not set
+-# CONFIG_DEBUG_VM is not set
+-# CONFIG_DEBUG_WRITECOUNT is not set
+-# CONFIG_DEBUG_MEMORY_INIT is not set
+-# CONFIG_DEBUG_LIST is not set
+-# CONFIG_DEBUG_SG is not set
+-# CONFIG_DEBUG_NOTIFIERS is not set
+-# CONFIG_BOOT_PRINTK_DELAY is not set
+-# CONFIG_RCU_TORTURE_TEST is not set
+-# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+-# CONFIG_BACKTRACE_SELF_TEST is not set
+-# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+-# CONFIG_FAULT_INJECTION is not set
+-# CONFIG_LATENCYTOP is not set
+-# CONFIG_SYSCTL_SYSCALL_CHECK is not set
+-# CONFIG_PAGE_POISONING is not set
+-CONFIG_HAVE_FUNCTION_TRACER=y
+-CONFIG_TRACING_SUPPORT=y
+-
+-#
+-# Tracers
+-#
+-# CONFIG_FUNCTION_TRACER is not set
+-# CONFIG_IRQSOFF_TRACER is not set
+-# CONFIG_PREEMPT_TRACER is not set
+-# CONFIG_SCHED_TRACER is not set
+-# CONFIG_CONTEXT_SWITCH_TRACER is not set
+-# CONFIG_EVENT_TRACER is not set
+-# CONFIG_BOOT_TRACER is not set
+-# CONFIG_TRACE_BRANCH_PROFILING is not set
+-# CONFIG_STACK_TRACER is not set
+-# CONFIG_KMEMTRACE is not set
+-# CONFIG_WORKQUEUE_TRACER is not set
+-# CONFIG_BLK_DEV_IO_TRACE is not set
+-# CONFIG_DYNAMIC_DEBUG is not set
+-# CONFIG_SAMPLES is not set
+-CONFIG_HAVE_ARCH_KGDB=y
+-# CONFIG_KGDB is not set
+-CONFIG_ARM_UNWIND=y
+-CONFIG_DEBUG_USER=y
+-CONFIG_DEBUG_ERRORS=y
+-# CONFIG_DEBUG_STACK_USAGE is not set
+-# CONFIG_DEBUG_LL is not set
+-
+-#
+-# Security options
+-#
+-# CONFIG_KEYS is not set
+-# CONFIG_SECURITY is not set
+-# CONFIG_SECURITYFS is not set
+-# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+-CONFIG_CRYPTO=y
+-
+-#
+-# Crypto core or helper
+-#
+-# CONFIG_CRYPTO_FIPS is not set
+-# CONFIG_CRYPTO_MANAGER is not set
+-# CONFIG_CRYPTO_MANAGER2 is not set
+-# CONFIG_CRYPTO_GF128MUL is not set
+-# CONFIG_CRYPTO_NULL is not set
+-# CONFIG_CRYPTO_CRYPTD is not set
+-# CONFIG_CRYPTO_AUTHENC is not set
+-# CONFIG_CRYPTO_TEST is not set
+-
+-#
+-# Authenticated Encryption with Associated Data
+-#
+-# CONFIG_CRYPTO_CCM is not set
+-# CONFIG_CRYPTO_GCM is not set
+-# CONFIG_CRYPTO_SEQIV is not set
+-
+-#
+-# Block modes
+-#
+-# CONFIG_CRYPTO_CBC is not set
+-# CONFIG_CRYPTO_CTR is not set
+-# CONFIG_CRYPTO_CTS is not set
+-# CONFIG_CRYPTO_ECB is not set
+-# CONFIG_CRYPTO_LRW is not set
+-# CONFIG_CRYPTO_PCBC is not set
+-# CONFIG_CRYPTO_XTS is not set
+-
+-#
+-# Hash modes
+-#
+-# CONFIG_CRYPTO_HMAC is not set
+-# CONFIG_CRYPTO_XCBC is not set
+-
+-#
+-# Digest
+-#
+-# CONFIG_CRYPTO_CRC32C is not set
+-# CONFIG_CRYPTO_MD4 is not set
+-# CONFIG_CRYPTO_MD5 is not set
+-# CONFIG_CRYPTO_MICHAEL_MIC is not set
+-# CONFIG_CRYPTO_RMD128 is not set
+-# CONFIG_CRYPTO_RMD160 is not set
+-# CONFIG_CRYPTO_RMD256 is not set
+-# CONFIG_CRYPTO_RMD320 is not set
+-# CONFIG_CRYPTO_SHA1 is not set
+-# CONFIG_CRYPTO_SHA256 is not set
+-# CONFIG_CRYPTO_SHA512 is not set
+-# CONFIG_CRYPTO_TGR192 is not set
+-# CONFIG_CRYPTO_WP512 is not set
+-
+-#
+-# Ciphers
+-#
+-# CONFIG_CRYPTO_AES is not set
+-# CONFIG_CRYPTO_ANUBIS is not set
+-# CONFIG_CRYPTO_ARC4 is not set
+-# CONFIG_CRYPTO_BLOWFISH is not set
+-# CONFIG_CRYPTO_CAMELLIA is not set
+-# CONFIG_CRYPTO_CAST5 is not set
+-# CONFIG_CRYPTO_CAST6 is not set
+-# CONFIG_CRYPTO_DES is not set
+-# CONFIG_CRYPTO_FCRYPT is not set
+-# CONFIG_CRYPTO_KHAZAD is not set
+-# CONFIG_CRYPTO_SALSA20 is not set
+-# CONFIG_CRYPTO_SEED is not set
+-# CONFIG_CRYPTO_SERPENT is not set
+-# CONFIG_CRYPTO_TEA is not set
+-# CONFIG_CRYPTO_TWOFISH is not set
+-
+-#
+-# Compression
+-#
+-# CONFIG_CRYPTO_DEFLATE is not set
+-# CONFIG_CRYPTO_ZLIB is not set
+-# CONFIG_CRYPTO_LZO is not set
+-
+-#
+-# Random Number Generation
+-#
+-# CONFIG_CRYPTO_ANSI_CPRNG is not set
+-# CONFIG_CRYPTO_HW is not set
+-# CONFIG_BINARY_PRINTF is not set
+-
+-#
+-# Library routines
+-#
+-CONFIG_BITREVERSE=y
+-CONFIG_GENERIC_FIND_LAST_BIT=y
+-CONFIG_CRC_CCITT=m
+-# CONFIG_CRC16 is not set
+-CONFIG_CRC_T10DIF=m
+-# CONFIG_CRC_ITU_T is not set
+-CONFIG_CRC32=y
+-# CONFIG_CRC7 is not set
+-# CONFIG_LIBCRC32C is not set
+-CONFIG_ZLIB_INFLATE=y
+-CONFIG_DECOMPRESS_GZIP=y
+-CONFIG_GENERIC_ALLOCATOR=y
+-CONFIG_HAS_IOMEM=y
+-CONFIG_HAS_IOPORT=y
+-CONFIG_HAS_DMA=y
+-CONFIG_NLATTR=y
+--- a/drivers/media/video/davinci/vpif.c
++++ b/drivers/media/video/davinci/vpif.c
+@@ -41,6 +41,11 @@ spinlock_t vpif_lock;
+ 
+ void __iomem *vpif_base;
+ 
++/* For module, capture and display driver will not get
++   reference to this variable unless it is exported */
++EXPORT_SYMBOL(vpif_base);
++
++
+ static inline void vpif_wr_bit(u32 reg, u32 bit, u32 val)
+ {
+ 	if (val)
+@@ -166,7 +171,6 @@ static void config_vpif_params(struct vp
+ 					vpifparams->iface.vd_pol);
+ 			vpif_wr_bit(reg, VPIF_CH_H_VALID_POLARITY_BIT,
+ 					vpifparams->iface.hd_pol);
+-
+ 			value = regr(reg);
+ 			/* Set data width */
+ 			value &= ((~(unsigned int)(0x3)) <<
+@@ -293,4 +297,3 @@ static int __init vpif_init(void)
+ }
+ subsys_initcall(vpif_init);
+ module_exit(vpif_exit);
+-
+--- a/include/media/davinci/dm355_ccdc.h
++++ b/include/media/davinci/dm355_ccdc.h
+@@ -71,16 +71,6 @@ enum ccdc_datasft {
+ 	CCDC_DATA_SHIFT_6BIT
+ };
+ 
+-enum ccdc_data_size {
+-	CCDC_DATA_16BITS,
+-	CCDC_DATA_15BITS,
+-	CCDC_DATA_14BITS,
+-	CCDC_DATA_13BITS,
+-	CCDC_DATA_12BITS,
+-	CCDC_DATA_11BITS,
+-	CCDC_DATA_10BITS,
+-	CCDC_DATA_8BITS
+-};
+ enum ccdc_mfilt1 {
+ 	CCDC_NO_MEDIAN_FILTER1,
+ 	CCDC_AVERAGE_FILTER1,
+@@ -103,8 +93,8 @@ struct ccdc_a_law {
+ 
+ /* structure for Black Clamping */
+ struct ccdc_black_clamp {
+-	/* only if bClampEnable is TRUE */
+-	unsigned char b_clamp_enable;
++	/* only if it is TRUE */
++	unsigned char enable;
+ 	/* only if bClampEnable is TRUE */
+ 	enum ccdc_sample_length sample_pixel;
+ 	/* only if bClampEnable is TRUE */
+@@ -222,8 +212,6 @@ struct ccdc_data_offset {
+ struct ccdc_config_params_raw {
+ 	/* data shift to be applied before storing */
+ 	enum ccdc_datasft datasft;
+-	/* data size value from 8 to 16 bits */
+-	enum ccdc_data_size data_sz;
+ 	/* median filter for sdram */
+ 	enum ccdc_mfilt1 mfilt1;
+ 	enum ccdc_mfilt2 mfilt2;
+@@ -254,7 +242,7 @@ struct ccdc_config_params_raw {
+ #ifdef __KERNEL__
+ #include <linux/io.h>
+ 
+-#define CCDC_WIN_PAL	{0, 0, 720, 576}
++#define CCDC_WIN_NTSC	{0, 0, 720, 480}
+ #define CCDC_WIN_VGA	{0, 0, 640, 480}
+ 
+ struct ccdc_params_ycbcr {
+--- /dev/null
++++ b/drivers/media/video/ths8200_regs.h
+@@ -0,0 +1,317 @@
++/*
++ * THS8200 encoder related structure and register definitions
++ *
++ * Copyright (C) 2009 Texas Instruments Incorporated - http://www.ti.com/
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License as
++ * published by the Free Software Foundation version 2.
++ *
++ * This program is distributed .as is. WITHOUT ANY WARRANTY of any
++ * kind, whether express or implied; without even the implied warranty
++ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ */
++
++#ifndef THS8200_REGS_H
++#define THS8200_REGS_H
++
++/* Register Macros */
++#define THS8200_VERSION                                 (0x02)
++#define THS8200_CHIP_CTL                                (0x03)
++#define THS8200_CSC_R11                                 (0x04)
++#define THS8200_CSC_R12                                 (0x05)
++#define THS8200_CSC_R21                                 (0x06)
++#define THS8200_CSC_R22                                 (0x07)
++#define THS8200_CSC_R31                                 (0x08)
++#define THS8200_CSC_R32                                 (0x09)
++#define THS8200_CSC_G11                                 (0x0a)
++#define THS8200_CSC_G12                                 (0x0b)
++#define THS8200_CSC_G21                                 (0x0c)
++#define THS8200_CSC_G22                                 (0x0d)
++#define THS8200_CSC_G31                                 (0x0e)
++#define THS8200_CSC_G32                                 (0x0f)
++#define THS8200_CSC_B11                                 (0x10)
++#define THS8200_CSC_B12                                 (0x11)
++#define THS8200_CSC_B21                                 (0x12)
++#define THS8200_CSC_B22                                 (0x13)
++#define THS8200_CSC_B31                                 (0x14)
++#define THS8200_CSC_B32                                 (0x15)
++#define THS8200_CSC_OFFS1                               (0x16)
++#define THS8200_CSC_OFFS12                              (0x17)
++#define THS8200_CSC_OFFS23                              (0x18)
++#define THS8200_CSC_OFFS3                               (0x19)
++#define THS8200_TST_CNTL1                               (0x1a)
++#define THS8200_TST_CNTL2                               (0x1b)
++#define THS8200_DATA_CNTL                               (0x1c)
++#define THS8200_DTG1_Y_SYNC1_LSB                        (0x1d)
++#define THS8200_DTG1_Y_SYNC2_LSB                        (0x1e)
++#define THS8200_DTG1_Y_SYNC3_LSB                        (0x1f)
++#define THS8200_DTG1_CBCR_SYNC1_LSB                     (0x20)
++#define THS8200_DTG1_CBCR_SYNC2_LSB                     (0x21)
++#define THS8200_DTG1_CBCR_SYNC3_LSB                     (0x22)
++#define THS8200_DTG1_Y_SYNC_MSB                         (0x23)
++#define THS8200_DTG1_CBCR_SYNC_MSB                      (0x24)
++#define THS8200_DTG1_SPEC_A                             (0x25)
++#define THS8200_DTG1_SPEC_B                             (0x26)
++#define THS8200_DTG1_SPEC_C                             (0x27)
++#define THS8200_DTG1_SPEC_D_LSB                         (0x28)
++#define THS8200_DTG1_SPEC_D1                            (0x29)
++#define THS8200_DTG1_SPEC_E_LSB                         (0x2a)
++#define THS8200_DTG1_SPEC_DEH_MSB                       (0x2b)
++#define THS8200_DTG1_SPEC_H_LSB                         (0x2c)
++#define THS8200_DTG1_SPEC_I_MSB                         (0x2d)
++#define THS8200_DTG1_SPEC_I_LSB                         (0x2e)
++#define THS8200_DTG1_SPEC_K_LSB                         (0x2f)
++#define THS8200_DTG1_SPEC_K_MSB                         (0x30)
++#define THS8200_DTG1_SPEC_K1                            (0x31)
++#define THS8200_DTG1_SPEC_G_LSB                         (0x32)
++#define THS8200_DTG1_SPEC_G_MSB                         (0x33)
++#define THS8200_DTG1_TOT_PIXELS_MSB                     (0x34)
++#define THS8200_DTG1_TOT_PIXELS_LSB                     (0x35)
++#define THS8200_DTG1_FLD_FLIP_LINECNT_MSB               (0x36)
++#define THS8200_DTG1_LINECNT_LSB                        (0x37)
++#define THS8200_DTG1_MODE                               (0x38)
++#define THS8200_DTG1_FRAME_FIELD_SZ_MSB                 (0x39)
++#define THS8200_DTG1_FRAME_SZ_LSB                       (0x3a)
++#define THS8200_DTG1_FIELD_SZ_LSB                       (0x3b)
++#define THS8200_DTG1_VESA_CBAR_SIZE                     (0x3c)
++#define THS8200_DAC_CNTL_MSB                            (0x3d)
++#define THS8200_DAC1_CNTL_LSB                           (0x3e)
++#define THS8200_DAC2_CNTL_LSB                           (0x3f)
++#define THS8200_DAC3_CNTL_LSB                           (0x40)
++#define THS8200_CSM_CLIP_GY_LOW                         (0x41)
++#define THS8200_CSM_CLIP_BCB_LOW                        (0x42)
++#define THS8200_CSM_CLIP_RCR_LOW                        (0x43)
++#define THS8200_CSM_CLIP_GY_HIGH                        (0x44)
++#define THS8200_CSM_CLIP_BCB_HIGH                       (0x45)
++#define THS8200_CSM_CLIP_RCR_HIGH                       (0x46)
++#define THS8200_CSM_SHIFT_GY                            (0x47)
++#define THS8200_CSM_SHIFT_BCB                           (0x48)
++#define THS8200_CSM_SHIFT_RCR                           (0x49)
++#define THS8200_CSM_GY_CNTL_MULT_MSB                    (0x4a)
++#define THS8200_CSM_MULT_BCB_RCR_MSB                    (0x4b)
++#define THS8200_CSM_MULT_GY_LSB                         (0x4c)
++#define THS8200_CSM_MULT_BCB_LSB                        (0x4d)
++#define THS8200_CSM_MULT_RCR_LSB                        (0x4e)
++#define THS8200_CSM_MULT_RCR_BCB_CNTL                   (0x4f)
++#define THS8200_CSM_MULT_RCR_LSB                        (0x4e)
++#define THS8200_DTG2_BP1_2_MSB                          (0x50)
++#define THS8200_DTG2_BP3_4_MSB                          (0x51)
++#define THS8200_DTG2_BP5_6_MSB                          (0x52)
++#define THS8200_DTG2_BP7_8_MSB                          (0x53)
++#define THS8200_DTG2_BP9_10_MSB                         (0x54)
++#define THS8200_DTG2_BP11_12_MSB                        (0x55)
++#define THS8200_DTG2_BP13_14_MSB                        (0x56)
++#define THS8200_DTG2_BP15_16_MSB                        (0x57)
++#define THS8200_DTG2_BP1_LSB                            (0x58)
++#define THS8200_DTG2_BP2_LSB                            (0x59)
++#define THS8200_DTG2_BP3_LSB                            (0x5a)
++#define THS8200_DTG2_BP4_LSB                            (0x5b)
++#define THS8200_DTG2_BP5_LSB                            (0x5c)
++#define THS8200_DTG2_BP6_LSB                            (0x5d)
++#define THS8200_DTG2_BP7_LSB                            (0x5e)
++#define THS8200_DTG2_BP8_LSB                            (0x5f)
++#define THS8200_DTG2_BP9_LSB                            (0x60)
++#define THS8200_DTG2_BP10_LSB                           (0x61)
++#define THS8200_DTG2_BP11_LSB                           (0x62)
++#define THS8200_DTG2_BP12_LSB                           (0x63)
++#define THS8200_DTG2_BP13_LSB                           (0x64)
++#define THS8200_DTG2_BP14_LSB                           (0x65)
++#define THS8200_DTG2_BP15_LSB                           (0x66)
++#define THS8200_DTG2_BP16_LSB                           (0x67)
++#define THS8200_DTG2_LINETYPE1                          (0x68)
++#define THS8200_DTG2_LINETYPE2                          (0x69)
++#define THS8200_DTG2_LINETYPE3                          (0x6a)
++#define THS8200_DTG2_LINETYPE4                          (0x6b)
++#define THS8200_DTG2_LINETYPE5                          (0x6c)
++#define THS8200_DTG2_LINETYPE6                          (0x6d)
++#define THS8200_DTG2_LINETYPE7                          (0x6e)
++#define THS8200_DTG2_LINETYPE8                          (0x6f)
++#define THS8200_DTG2_HLENGTH_LSB                        (0x70)
++#define THS8200_DTG2_HLENGTH_LSB_HDLY_MSB               (0x71)
++#define THS8200_DTG2_HLENGTH_HDLY_LSB                   (0x72)
++#define THS8200_DTG2_VLENGTH1_LSB                       (0x73)
++#define THS8200_DTG2_VLENGTH1_MSB_VDLY1_MSB             (0x74)
++#define THS8200_DTG2_VDLY1_LSB                          (0x75)
++#define THS8200_DTG2_VLENGTH2_LSB                       (0x76)
++#define THS8200_DTG2_VLENGTH2_MSB_VDLY2_MSB             (0x77)
++#define THS8200_DTG2_VDLY2_LSB                          (0x78)
++#define THS8200_DTG2_HS_IN_DLY_MSB                      (0x79)
++#define THS8200_DTG2_HS_IN_DLY_LSB                      (0x7a)
++#define THS8200_DTG2_VS_IN_DLY_MSB                      (0x7b)
++#define THS8200_DTG2_VS_IN_DLY_LSB                      (0x7c)
++#define THS8200_DTG2_PIXEL_CNT_MSB                      (0x7d)
++#define THS8200_DTG2_PIXEL_CNT_LSB                      (0x7e)
++#define THS8200_DTG2_LINE_CNT_MSB                       (0x7f)
++#define THS8200_DTG2_LINE_CNT_LSB                       (0x80)
++#define THS8200_DTG2_CNTL                               (0x82)
++#define THS8200_CGMS_CNTL_HEADER                        (0x83)
++#define THS8200_CGMS_PAYLOAD_MSB                        (0x84)
++#define THS8200_CGMS_PAYLOAD_LSB                        (0x85)
++#define THS8200_MISC_PPL_LSB                            (0x86)
++#define THS8200_MISC_PPL_MSB                            (0x87)
++#define THS8200_MISC_LPF_MSB                            (0x88)
++#define THS8200_MISC_LPF_LSB                            (0x89)
++
++/* Default values for the registers */
++#define THS8200_DTG1_Y_SYNC1_LSB_DEFAULT                (0xff)
++#define THS8200_DTG1_Y_SYNC2_LSB_DEFAULT                (0x49)
++#define THS8200_DTG1_Y_SYNC3_LSB_DEFAULT                (0xb6)
++#define THS8200_DTG1_CBCR_SYNC1_LSB_DEFAULT             (0xff)
++#define THS8200_DTG1_CBCR_SYNC2_LSB_DEFAULT             (0xff)
++#define THS8200_DTG1_CBCR_SYNC3_LSB_DEFAULT             (0xff)
++#define THS8200_DTG1_Y_SYNC_MSB_DEFAULT                 (0x13)
++#define THS8200_DTG1_CBCR_SYNC_MSB_DEFAULT              (0x15)
++#define THS8200_DTG1_SPEC_H_LSB_DEFAULT                 (0x0)
++#define THS8200_DTG1_SPEC_K_MSB_DEFAULT                 (0x0)
++#define THS8200_DTG1_FLD_FLIP_LINECNT_MSB_DEFAULT       (0x0)
++#define THS8200_DTG1_LINECNT_LSB_DEFAULT                (0x1)
++#define THS8200_DTG2_HS_IN_DLY_MSB_DEFAULT              (0x0)
++
++/* defaults for 720P HD */
++#define THS8200_DTG2_CNTL_720P_DEFAULT                  (0x1b)
++#define THS8200_DTG1_SPEC_A_720P_DEFAULT                (0x28)
++/* distance from end of active video to start of sync */
++#define THS8200_DTG1_SPEC_B_720P_DEFAULT                (0x46)
++#define THS8200_DTG1_SPEC_C_720P_DEFAULT                (0x28)
++#define THS8200_DTG1_SPEC_D_LSB_720P_DEFAULT            (0x2c)
++/* distance from Hsync to start of active video */
++#define THS8200_DTG1_SPEC_E_LSB_720P_DEFAULT            (0x2c)
++#define THS8200_DTG1_SPEC_DEH_MSB_720P_DEFAULT          (0xc0)
++#define THS8200_DTG1_SPEC_K_LSB_720P_DEFAULT            (0x46)
++#define THS8200_DTG1_TOT_PIXELS_MSB_720P_DEFAULT        (0x06)
++#define THS8200_DTG1_TOT_PIXELS_LSB_720P_DEFAULT        (0x72)
++#define THS8200_DTG1_MODE_720P_DEFAULT                  (0x82)
++#define THS8200_DTG1_FRAME_FIELD_SZ_MSB_720P_DEFAULT    (0x27)
++#define THS8200_DTG1_FRAME_SZ_LSB_720P_DEFAULT          (0xee)
++#define THS8200_DTG1_FIELD_SZ_LSB_720P_DEFAULT          (0xff)
++#define THS8200_DTG2_HS_IN_DLY_LSB_720P_DEFAULT         (0x60)
++#define THS8200_DTG2_VS_IN_DLY_MSB_720P_DEFAULT         (0x08)
++#define THS8200_DTG2_VS_IN_DLY_LSB_720P_DEFAULT         (0x06)
++
++/* defaults for 1080i HD */
++#define THS8200_TST_CNTL1_1080I_DEFAULT                 (0x0)
++#define THS8200_TST_CNTL2_1080I_DEFAULT                 (0x0)
++#define THS8200_CSM_GY_CNTL_MULT_MSB_1080I_DEFAULT      (0x0)
++#define THS8200_DTG2_CNTL_1080I_DEFAULT                 (0x1f)
++#define THS8200_DTG1_SPEC_A_1080I_DEFAULT               (0x2c)
++/* distance from end of active video to start of sync */
++#define THS8200_DTG1_SPEC_B_1080I_DEFAULT               (0x58)
++#define THS8200_DTG1_SPEC_C_1080I_DEFAULT               (0x2c)
++#define THS8200_DTG1_SPEC_D1_1080I_DEFAULT              (0x0)
++#define THS8200_DTG1_SPEC_D_LSB_1080I_DEFAULT           (0x84)
++/* distance from Hsync to start of active video */
++#define THS8200_DTG1_SPEC_E_LSB_1080I_DEFAULT           (0xc0)
++#define THS8200_DTG1_SPEC_DEH_MSB_1080I_DEFAULT         (0x0)
++#define THS8200_DTG1_SPEC_K_LSB_1080I_DEFAULT           (0x58)
++#define THS8200_DTG1_SPEC_G_LSB_1080I_DEFAULT           (0x58)
++#define THS8200_DTG1_SPEC_G_MSB_1080I_DEFAULT           (0x0)
++#define THS8200_DTG1_TOT_PIXELS_MSB_1080I_DEFAULT       (0x08)
++/* Total pixels per line */
++#define THS8200_DTG1_TOT_PIXELS_LSB_1080I_DEFAULT       (0x98)
++#define THS8200_DTG1_MODE_1080I_DEFAULT                 (0x81)
++#define THS8200_DTG1_FRAME_FIELD_SZ_MSB_1080I_DEFAULT   (0x42)
++#define THS8200_DTG1_FRAME_SZ_LSB_1080I_DEFAULT         (0x65)
++#define THS8200_DTG1_FIELD_SZ_LSB_1080I_DEFAULT         (0x33)
++#define THS8200_DTG2_HLENGTH_LSB_1080I_DEFAULT          (0x58)
++#define THS8200_DTG2_HLENGTH_LSB_HDLY_MSB_1080I_DEFAULT (0x0)
++#define THS8200_DTG2_HLENGTH_HDLY_LSB_1080I_DEFAULT     (0x0)
++#define THS8200_DTG2_VLENGTH1_LSB_1080I_DEFAULT         (0x05)
++#define THS8200_DTG2_VLENGTH1_MSB_VDLY1_MSB_1080I_DEFAULT (0x0)
++#define THS8200_DTG2_VDLY1_LSB_1080I_DEFAULT            (0x0)
++#define THS8200_DTG2_VLENGTH2_LSB_1080I_DEFAULT         (0x5)
++#define THS8200_DTG2_VDLY2_LSB_1080I_DEFAULT            (0x0)
++#define THS8200_DTG2_VLENGTH2_MSB_VDLY2_MSB_1080I_DEFAULT (0x0)
++#define THS8200_DTG2_VDLY1_LSB_1080I_DEFAULT            (0x0)
++#define THS8200_DTG2_HS_IN_DLY_LSB_1080I_DEFAULT        (0x44)
++#define THS8200_DTG2_VS_IN_DLY_MSB_1080I_DEFAULT        (0x0)
++#define THS8200_DTG2_VS_IN_DLY_LSB_1080I_DEFAULT        (0x1)
++
++/* MASKS */
++
++/* MODE VALUES */
++/* Reset */
++#define THS8200_CHIP_CNTL_RESET            (0x10)
++#define THS8200_CHIP_CNTL_RESET_NORMAL     (0x11)
++
++/* CSC bypass */
++#define THS8200_CSC_BYPASS_SHIFT           (0x1)
++#define THS8200_CSC_BYPASS                 (0x1)
++#define THS8200_CSC_UOF_CNTL               (0x1)
++
++/* data manager control input mode */
++#define THS8200_DATA_CNTL_MODE_20BIT_YCBCR (0x3)    /* 20 but YCbCr 4:2:2 */
++
++#define HD_720P60                           (0x00)
++#define HD_1080I60                          (0x01)
++#define NUM_MODES                           (2)
++#define NUM_MAX_REGS                        (100)
++
++#define THS8200_DTG1_MODE_MASK		    (0x0F)
++#define THS8200_DTG1_MODE_SHIFT		    (0x00)
++
++#define THS8200_DTG1_MODE_DTG_ON_MASK	    (0x80)
++#define THS8200_DTG1_MODE_DTG_ON_SHIFT	    (0x07)
++
++#define THS8200_DTG2_CNTL_IGNORE_FID_MASK   (0x80)
++#define THS8200_DTG2_CNTL_IGNORE_FID_SHIFT  (0x07)
++
++#define THS8200_DTG2_CNTL_EMD_TIMING_MASK   (0x20)
++#define THS8200_DTG2_CNTL_EMD_TIMING_SHIFT  (0x05)
++
++#define THS8200_DTG2_CNTL_RGB_MODE_MASK     (0x40)
++#define THS8200_DTG2_CNTL_RGB_MODE_SHIFT    (0x06)
++
++#define THS8200_DATA_CNTL_INTF_MASK	    (0x07)
++
++#define THS8200_HD_DELAY_DEFAULT	    (0x80)
++
++#define THS8200_CSC_OFFS3_CSC_BYPASS_MASK   (0x02)
++#define THS8200_CSC_OFFS3_CSC_BYPASS_SHIFT  (0x01)
++
++#define THS8200_CSC_OFFS3_UNDER_OVERFLOW_MASK (0x01)
++#define THS8200_CSC_OFFS3_UNDER_OVERFLOW_SHIFT (0x00)
++
++#define THS8200_DTG1_TOT_PIXELS_LSB_MASK    (0xFF)
++#define THS8200_DTG1_TOT_PIXELS_LSB_SHIFT   (0x00)
++#define THS8200_DTG1_TOT_PIXELS_MSB_MASK    (0x0F)
++#define THS8200_DTG1_TOT_PIXELS_MSB_SHIFT   (0x00)
++
++#define THS8200_DTG1_FRAME_SZ_LSB_MASK      (0xFF)
++#define THS8200_DTG1_FRAME_SZ_LSB_SHIFT	    (0x00)
++#define THS8200_DTG1_FRAME_SZ_MSB_MASK      (0x70)
++#define THS8200_DTG1_FRAME_SZ_MSB_SHIFT	    (0x04)
++
++#define THS8200_DTG1_FIELD_SZ_LSB_MASK      (0xFF)
++#define THS8200_DTG1_FIELD_SZ_LSB_SHIFT	    (0x00)
++#define THS8200_DTG1_FIELD_SZ_MSB_MASK      (0x07)
++#define THS8200_DTG1_FIELD_SZ_MSB_SHIFT	    (0x00)
++
++#define THS8200_DTG2_HS_IN_DLY_LSB_MASK	    (0xFF)
++#define THS8200_DTG2_HS_IN_DLY_LSB_SHIFT    (0x00)
++#define THS8200_DTG2_HS_IN_DLY_MSB_MASK     (0x0F)
++#define THS8200_DTG2_HS_IN_DLY_MSB_SHIFT    (0x00)
++
++#define THS8200_DTG2_VS_IN_DLY_LSB_MASK	    (0xFF)
++#define THS8200_DTG2_VS_IN_DLY_LSB_SHIFT    (0x00)
++#define THS8200_DTG2_VS_IN_DLY_MSB_MASK     (0x07)
++#define THS8200_DTG2_VS_IN_DLY_MSB_SHIFT    (0x00)
++
++#define THS8200_DTG1_SPEC_D_LSB_MASK        (0xFF)
++
++#define THS8200_DTG1_SPEC_G_LSB_MASK        (0xFF)
++#define THS8200_DTG1_SPEC_G_MSB_MASK        (0x0F)
++
++#define THS8200_DTG1_SPEC_E_LSB_MASK        (0xFF)
++#define THS8200_DTG1_SPEC_H_LSB_MASK	    (0xFF)
++#define THS8200_DTG1_SPEC_DEH_MSB_MASK      (0x03)
++
++#define THS8200_DTG1_SPEC_I_LSB_MASK	    (0xFF)
++#define THS8200_DTG1_SPEC_I_MSB_MASK        (0x0F)
++
++#define THS8200_DTG1_SPEC_K_LSB_MASK        (0xFF)
++#define THS8200_DTG1_SPEC_K_MSB_MASK	    (0x07)
++
++#endif
++
+--- /dev/null
++++ b/include/media/davinci/davinci_display.h
+@@ -0,0 +1,177 @@
++/*
++ * Copyright (C) 2005-2009 Texas Instruments Inc
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
++ */
++
++#ifndef DAVINCI_DISPLAY_H
++#define DAVINCI_DISPLAY_H
++
++#include <linux/ioctl.h>
++
++/* Application calls this ioctl for setting the C-plane buffer offset
++ * relative to the start of Y-plane buffer address
++ */
++#define VIDIOC_S_COFST	_IOWR('V', 200, int)
++
++#ifdef __KERNEL__
++
++/* Header files */
++#include <linux/videodev.h>
++#include <linux/videodev2.h>
++#include <media/v4l2-common.h>
++#include <media/videobuf-dma-contig.h>
++#include <video/davinci_osd.h>
++#include <media/davinci/vid_encoder_types.h>
++
++#define DAVINCI_DISPLAY_MAX_DEVICES 2
++
++enum davinci_display_device_id {
++	DAVINCI_DISPLAY_DEVICE_0,
++	DAVINCI_DISPLAY_DEVICE_1
++};
++
++#define DAVINCI_DISPLAY_MAJOR_RELEASE              1
++#define DAVINCI_DISPLAY_MINOR_RELEASE              0
++#define DAVINCI_DISPLAY_BUILD                      1
++#define DAVINCI_DISPLAY_VERSION_CODE ((DAVINCI_DISPLAY_MAJOR_RELEASE << 16) | \
++	(DAVINCI_DISPLAY_MINOR_RELEASE << 8)  | \
++	DAVINCI_DISPLAY_BUILD)
++
++#define DAVINCI_DISPLAY_VALID_FIELD(field)   ((V4L2_FIELD_NONE == field) || \
++	 (V4L2_FIELD_ANY == field) || (V4L2_FIELD_INTERLACED == field))
++
++/* Macros */
++#define ISNULL(p)       ((NULL) == (p))
++#define ISALIGNED(a)    (0 == (a % 8))
++
++/* Exp ratio numerator and denominator constants */
++#define DAVINCI_DISPLAY_H_EXP_RATIO_N   (9)
++#define DAVINCI_DISPLAY_H_EXP_RATIO_D   (8)
++#define DAVINCI_DISPLAY_V_EXP_RATIO_N   (6)
++#define DAVINCI_DISPLAY_V_EXP_RATIO_D   (5)
++
++/* Zoom multiplication factor */
++#define DAVINCI_DISPLAY_ZOOM_4X (4)
++#define DAVINCI_DISPLAY_ZOOM_2X (2)
++
++#define DAVINCI_DISPLAY_PIXELASPECT_NTSC 		{11, 10}
++#define DAVINCI_DISPLAY_PIXELASPECT_PAL  		{54, 59}
++#define DAVINCI_DISPLAY_PIXELASPECT_SP    	    {1, 1}
++
++/* settings for commonly used video formats */
++#define DAVINCI_DISPLAY_WIN_NTSC     {0, 0, 720, 480}
++#define DAVINCI_DISPLAY_WIN_PAL      {0, 0, 720, 576}
++#define DAVINCI_DISPLAY_WIN_640_480  {0, 0, 640, 480}
++#define DAVINCI_DISPLAY_WIN_640_400  {0, 0, 640, 400}
++#define DAVINCI_DISPLAY_WIN_640_350  {0, 0, 640, 350}
++#define DAVINCI_DISPLAY_WIN_720P  {0, 0, 1280, 720}
++#define DAVINCI_DISPLAY_WIN_1080I  {0, 0, 1920, 1080}
++
++/* Structures */
++struct display_layer_info {
++	int enable;
++	/* Layer ID used by Display Manager */
++	enum davinci_disp_layer id;
++	struct davinci_layer_config config;
++	enum davinci_zoom_factor h_zoom;
++	enum davinci_zoom_factor v_zoom;
++	enum davinci_h_exp_ratio h_exp;
++	enum davinci_v_exp_ratio v_exp;
++};
++
++/* display object structure */
++struct display_obj {
++	/* Buffer specific parameters
++	 * List of buffer pointers for storing frames
++	 */
++	u32 fbuffers[VIDEO_MAX_FRAME];
++	/* number of buffers in fbuffers */
++	u32 numbuffers;
++	/* Pointer pointing to current v4l2_buffer */
++	struct videobuf_buffer *curFrm;
++	/* Pointer pointing to next v4l2_buffer */
++	struct videobuf_buffer *nextFrm;
++	/* videobuf specific parameters
++	 * Buffer queue used in video-buf
++	 */
++	struct videobuf_queue buffer_queue;
++	/* Queue of filled frames */
++	struct list_head dma_queue;
++	/* Used in video-buf */
++	spinlock_t irqlock;
++	/* V4l2 specific parameters */
++	/* Identifies video device for this layer */
++	struct video_device *video_dev;
++	/* This field keeps track of type of buffer exchange mechanism user
++	 * has selected
++	 */
++	enum v4l2_memory memory;
++	/* Used to keep track of state of the priority */
++	struct v4l2_prio_state prio;
++	/* Used to store pixel format */
++	struct v4l2_pix_format pix_fmt;
++	enum v4l2_field buf_field;
++	/* Video layer configuration params */
++	struct display_layer_info layer_info;
++	/* vpbe specific parameters
++	 * enable window for display
++	 */
++	unsigned char window_enable;
++	/* number of open instances of the layer */
++	u32 usrs;
++	/* number of users performing IO */
++	u32 io_usrs;
++	/* Indicates id of the field which is being displayed */
++	u32 field_id;
++	/* Indicates whether streaming started */
++	u8 started;
++	/* Identifies device object */
++	enum davinci_display_device_id device_id;
++};
++
++/* File handle structure */
++struct davinci_fh {
++	/* pointer to layer object for opened device */
++	struct display_obj *layer;
++	/* Indicates whether this file handle is doing IO */
++	u8 io_allowed;
++	/* Used to keep track priority of this instance */
++	enum v4l2_priority prio;
++};
++
++/* vpbe device structure */
++struct davinci_display {
++	/* layer specifc parameters */
++	/* lock used to access this structure */
++	struct mutex lock;
++	/* Display mode information */
++	struct vid_enc_mode_info mode_info;
++	/* C-Plane offset from start of y-plane */
++	unsigned int cbcr_ofst;
++	/* interrupt callback */
++	struct davinci_disp_callback event_callback;
++	struct display_obj *dev[DAVINCI_DISPLAY_MAX_DEVICES];
++};
++
++struct buf_config_params {
++	u8 min_numbuffers;
++	u8 numbuffers[DAVINCI_DISPLAY_MAX_DEVICES];
++	u32 min_bufsize[DAVINCI_DISPLAY_MAX_DEVICES];
++	u32 layer_bufsize[DAVINCI_DISPLAY_MAX_DEVICES];
++};
++
++#endif				/* End of __KERNEL__ */
++#endif				/* DAVINCI_DISPLAY_H */
+--- a/arch/arm/mach-davinci/include/mach/mux.h
++++ b/arch/arm/mach-davinci/include/mach/mux.h
+@@ -94,6 +94,12 @@ enum davinci_dm646x_index {
+ 	/* ATA function */
+ 	DM646X_ATAEN,
+ 
++	/* PCI function */
++	DM646X_PCIEN,
++
++	/* HPI 32-bit */
++	DM646X_HPI32EN,
++
+ 	/* AUDIO Clock */
+ 	DM646X_AUDCK1,
+ 	DM646X_AUDCK0,
+@@ -114,6 +120,9 @@ enum davinci_dm646x_index {
+ 	DM646X_PTSIMUX_PARALLEL,
+ 	DM646X_PTSOMUX_SERIAL,
+ 	DM646X_PTSIMUX_SERIAL,
++
++	/* CIR control */
++	DM646X_CIR_UART2,
+ };
+ 
+ enum davinci_dm355_index {
+@@ -237,8 +246,8 @@ enum davinci_dm365_index {
+ 	DM365_EMAC_MDIO,
+ 	DM365_EMAC_MDCLK,
+ 
+-	/* Keypad */
+-	DM365_KEYPAD,
++	/* Key Scan */
++	DM365_KEYSCAN,
+ 
+ 	/* PWM */
+ 	DM365_PWM0,
+@@ -881,8 +890,8 @@ enum davinci_da850_index {
+ 	DA850_NEMA_CS_2,
+ 
+ 	/* GPIO function */
++	DA850_GPIO2_8,
+ 	DA850_GPIO2_15,
+-	DA850_GPIO8_10,
+ 	DA850_GPIO4_0,
+ 	DA850_GPIO4_1,
+ };
+--- a/drivers/mmc/host/Kconfig
++++ b/drivers/mmc/host/Kconfig
+@@ -251,6 +251,14 @@ config MMC_MVSDIO
+ 	  To compile this driver as a module, choose M here: the
+ 	  module will be called mvsdio.
+ 
++config MMC_DAVINCI
++        tristate "TI DAVINCI Multimedia Card Interface support"
++        depends on ARCH_DAVINCI
++        help
++          This selects the TI DAVINCI Multimedia card Interface.
++          If you have an DAVINCI board with a Multimedia Card slot,
++          say Y or M here.  If unsure, say N.
++
+ config MMC_SPI
+ 	tristate "MMC/SD/SDIO over SPI"
+ 	depends on SPI_MASTER && !HIGHMEM && HAS_DMA
+--- /dev/null
++++ b/drivers/char/dm646x_pci_targetdrv.c
+@@ -0,0 +1,822 @@
++/*
++ * dm646x_pci_targetdrv.c
++ *  Description:
++ *  DM6467 PCI Target driver.
++ *
++ *
++ * Copyright (C) 2009, Texas Instruments, Incorporated
++ *
++ *  This program is free software; you can distribute it and/or modify it
++ *  under the terms of the GNU General Public License (Version 2) as
++ *  published by the Free Software Foundation.
++ *
++ *  This program is distributed in the hope it will be useful, but WITHOUT
++ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
++ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
++ *  for more details.
++ *
++ *  You should have received a copy of the GNU General Public License along
++ *  with this program; if not, write to the Free Software Foundation, Inc.,
++ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
++ */
++
++
++/*******************************************************************************
++ *	LOCAL INCLUDE FILES
++ */
++#include <linux/init.h>
++#include <linux/module.h>
++#include <linux/kernel.h>	/**< debug */
++#include <linux/device.h>	/**< debug */
++#include <linux/slab.h> 	/**< kmalloc() */
++#include <linux/fs.h> 		/**< everything\ldots{} */
++#include <linux/types.h> 	/**< size_t */
++#include <linux/fcntl.h>	/**< O_ACCMODE */
++#include <linux/uaccess.h>
++#include <linux/ioport.h>	/**< For request_region, check_region etc */
++#include <linux/io.h>             /**< For ioremap_nocache */
++#include <linux/pci.h>
++#include <linux/delay.h>
++#include <linux/cdev.h>
++#include <linux/interrupt.h>
++#include <linux/version.h>
++#include <asm/irq.h>
++#include "dm646x_pci_targetdrv.h"
++
++
++/*******************************************************************************
++ *	LOCAL DEFINES
++ */
++#define DM646X_PCI_MODNAME      ("DM646x PCI Boot")
++#define DM646X_DEV_COUNT        (1)
++
++/* U-Boot size is limited to 512KB */
++#define DM646X_UBOOT_MAX_SIZE   (0x80000)
++
++/* Script/Communication Area is limited to 512KB */
++#define DM646X_COMM_MAX_SIZE    (0x80000)
++
++/* Linux image area is limited to 7MB */
++#define DM646X_LINUX_MAX_SIZE   (0x700000)
++
++/**
++ *    KERN_EMERG > KERN_ALERT > KERN_CRIT >
++ *    KERN_ERR > KERN_WARNING > KERN_INFO > KERN_DEBUG
++ */
++#define LOG_LEVEL               KERN_ALERT
++
++/*
++ * These macros provide the virtual address of PCI and device register at
++ * specified offset respectively. Use reg_virt initialized from MMR BAR base
++ * virtual mapping.
++ */
++#define PCI_REGV(reg)           ((reg_virt + DM6467PCI_PCIREG_BASE \
++					- DM6467PCI_MMRREG_BASE) + reg)
++#define DEV_REGV(reg)           ((reg_virt + DM6467PCI_DEVREG_BASE \
++					- DM6467PCI_MMRREG_BASE) + reg)
++
++
++/*******************************************************************************
++ *	ENUMERATED DATATYPES
++ */
++enum E_PCI_BAR {
++	  E_PCI_BAR_TCM_RAM	= 0 	/* 0x10010000 */
++	, E_PCI_BAR_EMIF_REGS		/* 0x20000000 */
++	, E_PCI_BAR_CHIP_MMR		/* 0x01C00000 */
++	, E_PCI_BAR_L2_RAM		/* 0x11810000 */
++	, E_PCI_BAR_DDR2_A	    	/* 0x80000000 */
++	, E_PCI_BAR_DDR2_B	    	/* 0x80800000 */
++	, E_PCI_BAR_MAX		    	/* max 6 in number */
++} EPciBar;
++/*******************************************************************************
++ *	LOCAL FUNCTION PROTOTYPES
++ */
++static int dm646x_pci_find_device(void);
++static int dm646x_pci_read_BAR(void);
++static int dm646x_pci_remap_BAR(u32 bar_number, u32 new_window);
++static void dm646x_pci_set_master(void);
++
++static ssize_t dm646x_pci_ioctl(struct inode *inode, struct file *filp,
++				unsigned int cmd, unsigned long arg);
++static int dm646x_pci_mmap(struct file *filp, struct vm_area_struct *vma);
++static int __init dm646x_pci_init(void);
++static void __exit dm646x_pci_cleanup(void);
++
++/*******************************************************************************
++ *	GLOBAL VARIABLES
++ */
++struct pci_dev *dm646x_pci_dev;
++u32  shrd_intr_var;
++
++u32  tcm_base        = 0, tcm_len         = 0;
++u32  emif_reg_base   = 0, emif_reg_len    = 0;
++u32  reg_base        = 0, reg_len         = 0;
++u32  l2_ram_base     = 0, l2_ram_len      = 0;
++u32  ddr2a_base      = 0, ddr2a_len       = 0;
++u32  ddr2b_base      = 0, ddr2b_len       = 0;
++
++u32	*tcm_virt;
++u32	*emif_virt;
++u32	reg_virt;
++u32	*ddr2a_virt;
++
++u32	*ddr2b_virt;
++u32  *comm_virt;
++u32  *linux_virt;
++
++static int dm646x_pci_major;	    	                /**< Major number */
++static struct cdev dm646x_pci_cdev;                     /**< CDev object */
++static struct class *dm646x_pci_class;
++static dev_t dm646x_dev_id;
++
++/**
++ *	Structure that declares the usual file
++ *	access functions
++ */
++static const struct file_operations dm646x_pci_fops = {
++	.owner =    THIS_MODULE,
++	.mmap  =    dm646x_pci_mmap,
++	.ioctl =    dm646x_pci_ioctl,
++};
++
++/* =============================================================================
++ *  @func   dm646x_pci_find_device
++ *
++ *  @desc   This function locates DM6467 PCI cards on system.
++ *
++ *  @modif  None.
++ *  ============================================================================
++ */
++static int dm646x_pci_find_device(void)
++{
++	struct pci_dev *dev = NULL;
++
++	while (NULL !=
++		(dev = pci_get_device(PCI_TI_VENDOR, PCI_TI_DEVICE, dev))) {
++		pr_info("dm646xpci: Found DM646x PCI device at 0x%08x\n",
++				(int)dev);
++		if ((dev->class >> 8) == PCI_CLASS_BRIDGE_HOST) {
++			pr_warning("dm646xpci: skipping DM646x PCI Host...");
++			continue;
++		}
++		dm646x_pci_dev = dev;
++		return 0;
++	}
++	pr_err("dm646xpci: No DM646x PCI Target found on bus\n");
++	return -1;
++}
++
++/* =============================================================================
++ *  @func   dm646x_pci_remap_BAR
++ *
++ *  @desc   This function changes the current mapping of the BAR registers
++ *
++ *  @modif  None.
++ *  ============================================================================
++ */
++static int dm646x_pci_remap_BAR(u32 bar_number, u32 new_window)
++{
++	/* switch on the requested BAR */
++	switch (bar_number) {
++	case E_PCI_BAR_TCM_RAM:
++	{
++		dev_info(&dm646x_pci_dev->dev,
++				"Original BAR-0 value\t= 0x%08x\n",
++				(int)__raw_readl(PCI_REGV(PCIBARTRL(0))));
++		__raw_writel(new_window, PCI_REGV(PCIBARTRL(0)));
++		dev_info(&dm646x_pci_dev->dev,
++				"New BAR-0 value\t= 0x%08x\n",
++				(int)__raw_readl(PCI_REGV(PCIBARTRL(0))));
++		break;
++	}
++	case E_PCI_BAR_EMIF_REGS:
++	{
++		dev_info(&dm646x_pci_dev->dev,
++				"Original BAR-1 value\t= 0x%08x\n",
++				(int)__raw_readl(PCI_REGV(PCIBARTRL(1))));
++		__raw_writel(new_window, PCI_REGV(PCIBARTRL(1)));
++		dev_info(&dm646x_pci_dev->dev,
++				"New BAR-1 value\t= 0x%08x\n",
++				(int)__raw_readl(PCI_REGV(PCIBARTRL(1))));
++		break;
++	}
++	case E_PCI_BAR_CHIP_MMR:
++	{
++		dev_info(&dm646x_pci_dev->dev,
++				"Original BAR-2 value\t= 0x%08x\n",
++				(int)__raw_readl(PCI_REGV(PCIBARTRL(2))));
++		__raw_writel(new_window, PCI_REGV(PCIBARTRL(2)));
++		dev_info(&dm646x_pci_dev->dev,
++				"New BAR-2 value\t= 0x%08x\n",
++				(int)__raw_readl(PCI_REGV(PCIBARTRL(2))));
++		break;
++	}
++	case E_PCI_BAR_L2_RAM:
++	{
++		dev_info(&dm646x_pci_dev->dev,
++				"Original BAR-3 value\t= 0x%08x\n",
++				(int)__raw_readl(PCI_REGV(PCIBARTRL(3))));
++		__raw_writel(new_window, PCI_REGV(PCIBARTRL(3)));
++		dev_info(&dm646x_pci_dev->dev,
++				"New BAR-3 value\t= 0x%08x\n",
++				(int)__raw_readl(PCI_REGV(PCIBARTRL(3))));
++		break;
++	}
++	case E_PCI_BAR_DDR2_A:
++	{
++		dev_info(&dm646x_pci_dev->dev,
++				"Original BAR-4 value\t= 0x%08x\n",
++				(int)__raw_readl(PCI_REGV(PCIBARTRL(4))));
++		__raw_writel(new_window, PCI_REGV(PCIBARTRL(4)));
++		dev_info(&dm646x_pci_dev->dev,
++				"New BAR-4 value =\t0x%08x\n",
++				(int)__raw_readl(PCI_REGV(PCIBARTRL(4))));
++		break;
++	}
++	case E_PCI_BAR_DDR2_B:
++	{
++		dev_info(&dm646x_pci_dev->dev,
++				"Original BAR-5 value\t= 0x%08x\n",
++				(int)__raw_readl(PCI_REGV(PCIBARTRL(5))));
++		__raw_writel(new_window, PCI_REGV(PCIBARTRL(5)));
++		dev_info(&dm646x_pci_dev->dev,
++				"New BAR-5 value =\t0x%08x\n",
++				(int)__raw_readl(PCI_REGV(PCIBARTRL(5))));
++		break;
++	}
++	default:
++	{
++		dev_err(&dm646x_pci_dev->dev, "Invalid BAR number\n");
++		return -1;
++	}
++	} /* switch(bar_number) */
++	return 0;
++}
++
++/* =============================================================================
++ *  @func   dm646x_pci_read_BAR
++ *
++ *  @desc   This function reads config.
++ *
++ *  @modif  None.
++ *  ============================================================================
++ */
++static int dm646x_pci_read_BAR(void)
++{
++	int index;
++	u32  bar_start[E_PCI_BAR_MAX];
++	u32  bar_len[E_PCI_BAR_MAX];
++	u32  bar_flags[E_PCI_BAR_MAX];
++
++	dev_info(&dm646x_pci_dev->dev, "BAR Configuration - \n\t   "
++			"Start\t|\tLength\t|\tFlags\n");
++	for (index = E_PCI_BAR_TCM_RAM; index < E_PCI_BAR_DDR2_A; index++) {
++		bar_start[index] = pci_resource_start(dm646x_pci_dev, index);
++		bar_len[index] = pci_resource_len(dm646x_pci_dev, index);
++		bar_flags[index] = pci_resource_flags(dm646x_pci_dev, index);
++
++		if (bar_flags[index] & IORESOURCE_IO) {
++			dev_err(&dm646x_pci_dev->dev,
++				"This driver does not support PCI IO.\n");
++			return -1;
++		}
++
++		dev_info(&dm646x_pci_dev->dev, "\t0x%08x\t|\t%d\t|\t0x%08x\n",
++				(int)bar_start[index], (int)bar_len[index],
++				(int)bar_flags[index]);
++	}
++
++
++	/* ---------------------------------------------------------------------
++	* Maintain information on L2 RAM  memory region
++	* ---------------------------------------------------------------------
++	*/
++	l2_ram_base = bar_start[E_PCI_BAR_L2_RAM];
++	l2_ram_len  = bar_len[E_PCI_BAR_L2_RAM];
++
++
++	/* ---------------------------------------------------------------------
++	* Map the ARM TCM RAM  memory region
++	* ---------------------------------------------------------------------
++	*/
++	tcm_base = bar_start[E_PCI_BAR_TCM_RAM];
++
++	/* Map the memory region. */
++	request_mem_region(tcm_base, bar_len[E_PCI_BAR_TCM_RAM], "DV-HD");
++
++	tcm_virt = ioremap_nocache(bar_start[E_PCI_BAR_TCM_RAM],
++					bar_len[E_PCI_BAR_TCM_RAM]);
++	if (!tcm_virt) {
++		dev_err(&dm646x_pci_dev->dev, "ARM TCM RAM memory could "
++				"not be remapped\n");
++		return -1;
++	}
++	dev_info(&dm646x_pci_dev->dev, "ARM TCM RAM memory mapped to 0x%08x\n",
++			(int)tcm_virt);
++	tcm_len = bar_len[E_PCI_BAR_TCM_RAM];
++
++	/* ---------------------------------------------------------------------
++	* Map the EMIF Memory Controller registers memory region
++	* ---------------------------------------------------------------------
++	*/
++	emif_reg_base = bar_start[E_PCI_BAR_EMIF_REGS];
++
++	/* Map the memory region. */
++	request_mem_region(emif_reg_base,
++				bar_len[E_PCI_BAR_EMIF_REGS], "DV-HD");
++
++	emif_virt = ioremap_nocache(bar_start[E_PCI_BAR_EMIF_REGS],
++					bar_len[E_PCI_BAR_EMIF_REGS]);
++	if (!emif_virt) {
++		dev_err(&dm646x_pci_dev->dev,
++				"DDR2 area could not be remapped\n");
++		return -1;
++	}
++	dev_info(&dm646x_pci_dev->dev, "DDR2 Memory mapped to 0x%08x\n",
++			(int)emif_virt);
++	emif_reg_len = bar_len[E_PCI_BAR_EMIF_REGS];
++
++	/* ---------------------------------------------------------------------
++	* Map the REG memory region
++	* ---------------------------------------------------------------------
++	*/
++	reg_base = bar_start[E_PCI_BAR_CHIP_MMR] ;
++
++	/* Map the memory region. */
++	request_mem_region(reg_base, bar_len[E_PCI_BAR_CHIP_MMR], "DV-HD");
++
++	reg_virt = (u32)ioremap_nocache(bar_start[E_PCI_BAR_CHIP_MMR],
++					bar_len[E_PCI_BAR_CHIP_MMR]) ;
++	if (!reg_virt) {
++		dev_err(&dm646x_pci_dev->dev,
++				"MMR registers could not be mapped\n");
++		return -1;
++	}
++	dev_info(&dm646x_pci_dev->dev, "MMR registers mapped to 0x%08x:%#x\n",
++			(int)reg_virt, bar_start[E_PCI_BAR_CHIP_MMR]);
++	reg_len = bar_len[E_PCI_BAR_CHIP_MMR];
++
++
++	/* ---------------------------------------------------------------------
++	* Change the mapping for the DDR2 BAR registers
++	* ---------------------------------------------------------------------
++	*/
++	if (0 != dm646x_pci_remap_BAR(E_PCI_BAR_DDR2_A, 0x82000000)) {
++		dev_err(&dm646x_pci_dev->dev,
++				"Remapping of BAR4 for DDR2-A failed\n");
++		return -1;
++	}
++
++	if (0 != dm646x_pci_remap_BAR(E_PCI_BAR_DDR2_B, 0x82800000)) {
++		dev_err(&dm646x_pci_dev->dev,
++				"Remapping of BAR4 for DDR2-B failed\n");
++		return -1;
++	}
++
++	for (index = E_PCI_BAR_DDR2_A; index < E_PCI_BAR_MAX; index++) {
++		bar_start[index] = pci_resource_start(dm646x_pci_dev, index);
++		bar_len[index] = pci_resource_len(dm646x_pci_dev, index);
++		bar_flags[index] = pci_resource_flags(dm646x_pci_dev, index);
++		dev_info(&dm646x_pci_dev->dev, "\t0x%08x\t|\t%d\t|\t0x%08x\n",
++				(int)bar_start[index], (int)bar_len[index],
++				(int)bar_flags[index]);
++	}
++
++	/* ---------------------------------------------------------------------
++	* Map the DDR2-A memory region
++	* ---------------------------------------------------------------------
++	*/
++	ddr2a_base = bar_start[E_PCI_BAR_DDR2_A] ;
++
++	/* Map the memory region. */
++	request_mem_region(ddr2a_base, bar_len[E_PCI_BAR_DDR2_A], "DV-HD");
++
++	ddr2a_virt = ioremap_nocache(bar_start[E_PCI_BAR_DDR2_A],
++					DM646X_UBOOT_MAX_SIZE);
++	if (!ddr2a_virt) {
++		dev_err(&dm646x_pci_dev->dev,
++				"DDR2 memory could not be mapped\n");
++		return -1;
++	}
++
++	comm_virt = ioremap_nocache(bar_start[E_PCI_BAR_DDR2_A]
++					+ DM646X_UBOOT_MAX_SIZE,
++					DM646X_COMM_MAX_SIZE);
++	if (!comm_virt) {
++		dev_err(&dm646x_pci_dev->dev,
++				"Communication/Script area failed to remap\n");
++		return -1;
++	}
++
++	linux_virt = ioremap_nocache((bar_start[E_PCI_BAR_DDR2_A]
++			+ DM646X_UBOOT_MAX_SIZE + DM646X_COMM_MAX_SIZE),
++			bar_len[E_PCI_BAR_DDR2_A] - DM646X_UBOOT_MAX_SIZE
++			- DM646X_COMM_MAX_SIZE);
++	if (!linux_virt) {
++		dev_err(&dm646x_pci_dev->dev,
++				"Error: Linux memory could not be remapped\n");
++		return -1;
++	}
++	dev_info(&dm646x_pci_dev->dev, "DDR2 memory mapped to 0x%08x\n",
++			(int)ddr2a_virt);
++	dev_info(&dm646x_pci_dev->dev,
++			"Communication/Script area mapped to 0x%08x\n",
++			(int)comm_virt);
++	dev_info(&dm646x_pci_dev->dev, "Linux area mapped to 0x%08x\n",
++			(int)linux_virt);
++
++	ddr2a_len = bar_len[E_PCI_BAR_DDR2_A];
++
++	/* ---------------------------------------------------------------------
++	* Map the DDR2-B memory region
++	* ---------------------------------------------------------------------
++	*/
++	ddr2b_base = bar_start[E_PCI_BAR_DDR2_B];
++
++	/* Map the memory region. */
++	request_mem_region(ddr2b_base, bar_len[E_PCI_BAR_DDR2_B], "DV-HD");
++
++	ddr2b_virt = ioremap_nocache(bar_start[E_PCI_BAR_DDR2_B],
++			bar_len[E_PCI_BAR_DDR2_B] - DM646X_COMM_MAX_SIZE);
++	if (!ddr2b_virt) {
++		dev_err(&dm646x_pci_dev->dev,
++				"DDR2 memory could not be remapped\n");
++		return -1;
++	}
++	dev_info(&dm646x_pci_dev->dev, "DDR2-B memory mapped to 0x%08x\n",
++			(int)ddr2b_virt);
++	ddr2b_len = bar_len[E_PCI_BAR_DDR2_B];
++
++	return 0;
++}
++
++/* =============================================================================
++ *  @func   dm646x_pci_set_master
++ *
++ *  @desc   This function makes the given device to be master.
++ *
++ *  @modif  None.
++ *  ============================================================================
++ */
++static void dm646x_pci_set_master(void)
++{
++	s32   ret_val ;
++	u16  cmd_val ;
++	struct pci_dev *dev = dm646x_pci_dev;
++
++	/*
++	 *  Set the desired PCI dev to be master, this internally sets the
++	 *  latency timer.
++	 */
++	pci_set_master(dev);
++	pci_write_config_byte(dev, PCI_LATENCY_TIMER, 0x80);
++
++	/* Add support memory write invalidate */
++	ret_val = pci_set_mwi(dev);
++
++	pci_read_config_word(dev, PCI_COMMAND, (u16 *) &cmd_val);
++
++	/* and set the master bit in command register. */
++	cmd_val |= (PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER | PCI_COMMAND_SERR);
++
++	pci_write_config_word(dev, PCI_COMMAND, cmd_val);
++}
++
++/* =============================================================================
++ *  @func  dm646x_pci_ioctl
++ *
++ *  @desc   This function provides the interface to the application code
++ *	        to transfer data to PCI mapped memory spaces. It will be used
++ *          to initially transfer the UBL code followed by the u-boot.bin
++ *	        file. This code largely depends on the handshaking done using
++ *	        the BootComplete flag.
++ *
++ *  @modif  None.
++ *  ============================================================================
++ */
++ssize_t dm646x_pci_ioctl(struct inode *inode, struct file *filp,
++				unsigned int cmd, unsigned long arg)
++{
++	int ret_val = 0 ;
++
++	switch (cmd) {
++	/**
++	*  1.  Run the UBL code on the ARM TCM IRAM
++	*/
++	case DM646X_PCI_RUN_TCM_IMG:
++	{
++		/* Copy the start location to predefined IRAM location */
++		tcm_virt[0x7E80/4] = 0x20;
++
++		/* Set the boot complete flag, BC flag */
++		__raw_writel(__raw_readl(DEV_REGV(BOOTSTAT)) | 0x1,
++					DEV_REGV(BOOTSTAT));
++
++		/* Wait until BC bit is cleared by the UBL */
++		while ((__raw_readl(DEV_REGV(BOOTSTAT)) & 0x1) == 0x1)
++			udelay(1000);
++
++		dev_info(&dm646x_pci_dev->dev,
++				"\nUBL completed its job; BC is cleared;"
++				" DDR2 is initialized\n");
++
++		return 0;
++	}
++
++	/**
++	*  2.  Remap BAR to a new location
++	*/
++	case DM646X_PCI_REMAP_BAR:
++	{
++		struct DM646x_Remap_Bar_Args *args
++				= (struct DM646x_Remap_Bar_Args *) arg;
++		dev_info(&dm646x_pci_dev->dev, "Remapping BAR%d to %#x...\n",
++				(int)args->bar_number, (int)args->new_window);
++		if (0 != dm646x_pci_remap_BAR(args->bar_number,
++					args->new_window)) {
++			dev_err(&dm646x_pci_dev->dev,
++				"Error: Remapping of BAR%d to 0x%08x failed\n",
++				(int)args->bar_number,
++				(int)args->new_window);
++			return -1;
++		}
++		return 0;
++	}
++
++	/**
++	*  3.  Indicate to the UBL where to find the U-Boot start location
++	*      and boot the image
++	*/
++	case DM646X_PCI_BOOT_IMAGE:
++	{
++		/* Copy the start location of U-boot to last IRAM location */
++		tcm_virt[0x7FFC/4] = (unsigned int)arg;
++
++		/* Set the boot complete flag, BC flag */
++		__raw_writel(__raw_readl(DEV_REGV(BOOTSTAT)) | 0x1,
++					DEV_REGV(BOOTSTAT));
++
++		break;
++	}
++
++	/**
++	*  4.  Generate an interrupt to the DM6467
++	*/
++	case DM646X_PCI_GEN_INTRPT:
++	{
++		dev_err(&dm646x_pci_dev->dev, "Generating interrupt on DM646x "
++				"target is not supported.\n");
++		ret_val = -1;
++		break;
++	}
++
++	/**
++	*  5. Send data to device using EDMA and shared PCI space
++	*/
++	case DM646X_PCI_EDMA_XFER:
++	{
++		dev_err(&dm646x_pci_dev->dev, "Initiating EDMA on PCI Target "
++				"from Host is not supported.\n");
++		ret_val = -1;
++		break;
++	}
++
++	default:
++		return -1;
++	}
++	return ret_val;
++}
++
++/* =============================================================================
++ *  @func   dm646x_pci_mmap
++ *
++ *  @desc   The mmap routine will provide method to allow applications
++ *          a direct access to the PCI mapped memory area
++ *
++ *  @modif  None
++ *  ============================================================================
++ */
++int dm646x_pci_mmap(struct file *filp, struct vm_area_struct *vma)
++{
++	switch ((int)vma->vm_pgoff) {
++	case E_PCI_BAR_TCM_RAM:
++		vma->vm_pgoff = tcm_base;
++		break;
++	case E_PCI_BAR_EMIF_REGS:
++		vma->vm_pgoff = emif_reg_base;
++		break;
++	case E_PCI_BAR_CHIP_MMR:
++		vma->vm_pgoff = reg_base;
++		break;
++	case E_PCI_BAR_L2_RAM:
++		vma->vm_pgoff = l2_ram_base;
++		break;
++	case E_PCI_BAR_DDR2_A:
++		vma->vm_pgoff = ddr2a_base;
++		break;
++	case E_PCI_BAR_DDR2_B:
++		vma->vm_pgoff = ddr2b_base;
++		break;
++	default:
++		return -EAGAIN;
++	}
++	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
++
++	if (remap_pfn_range(vma, vma->vm_start, (vma->vm_pgoff >> PAGE_SHIFT),
++			vma->vm_end - vma->vm_start, vma->vm_page_prot))
++		return -EAGAIN ;
++
++	vma->vm_pgoff = vma->vm_pgoff >> PAGE_SHIFT;
++	return 0 ;
++}
++
++/* =============================================================================
++ *  @func   dm646x_pci_init
++ *
++ *  @desc   This function will be called when this module is inserted. It
++ *	    will initialize the DM700 as a PCI device on the host machine
++ *	    and will then read the BAR addresses to configure the DDR to
++ *	    the PCI memory mapped area. Next, the host will initialize the
++ *	    DDR of DM700 device to allow copying of the uBoot binary.
++ *
++ *  @modif  None.
++ *  ============================================================================
++ */
++int __init dm646x_pci_init(void)
++{
++	int ret_val;
++
++	/* ---------------------------------------------------------------------
++	*  Find the DM646x device on the PCI bus
++	* ---------------------------------------------------------------------
++	*/
++	if (dm646x_pci_find_device())
++		return -1;
++
++	dev_warn(&dm646x_pci_dev->dev, "This driver supports booting the "
++			"first DM646x target found on the bus\n");
++
++	/* ---------------------------------------------------------------------
++	*  1.  Register a character driver to send data to this driver
++	* ---------------------------------------------------------------------
++	*/
++	ret_val = alloc_chrdev_region(&dm646x_dev_id, 1, 0, DM646X_PCI_MODFILE);
++	if (ret_val) {
++		dev_err(&dm646x_pci_dev->dev,
++				"could not allocate the character driver");
++		goto err_post_pci;
++	}
++	dm646x_pci_major = MAJOR(dm646x_dev_id);
++
++	/* ---------------------------------------------------------------------
++	*  2.  Create the node for access through the application
++	* ---------------------------------------------------------------------
++	*/
++	cdev_init(&dm646x_pci_cdev, &dm646x_pci_fops);
++	dm646x_pci_cdev.owner = THIS_MODULE;
++	dm646x_pci_cdev.ops = &dm646x_pci_fops;
++
++	ret_val = cdev_add(&dm646x_pci_cdev, dm646x_dev_id, DM646X_DEV_COUNT);
++	if (ret_val) {
++		dev_err(&dm646x_pci_dev->dev,
++				"Failed creation of node for PCI boot\n");
++		unregister_chrdev_region(dm646x_dev_id, DM646X_DEV_COUNT);
++		goto err_post_pci;
++	}
++	dev_info(&dm646x_pci_dev->dev, "Major number %d assigned\n",
++			dm646x_pci_major);
++
++	/* ---------------------------------------------------------------------
++	*  3.  Creation of a class structure for pseudo file system access
++	* ---------------------------------------------------------------------
++	*/
++	dm646x_pci_class = class_create(THIS_MODULE, DM646X_PCI_MODFILE);
++	if (!dm646x_pci_class) {
++		cdev_del(&dm646x_pci_cdev);
++		unregister_chrdev_region(dm646x_dev_id, DM646X_DEV_COUNT);
++		dev_err(&dm646x_pci_dev->dev,
++				"Failed to add device to sys fs\n");
++		ret_val = -1;
++		goto err_post_pci;
++	}
++	device_create(dm646x_pci_class, NULL, dm646x_dev_id,
++				NULL, DM646X_PCI_MODFILE);
++	dev_info(&dm646x_pci_dev->dev, "Added device to the sys file system\n");
++
++
++	/* ---------------------------------------------------------------------
++	*  5.  Enable the PCI device
++	* ---------------------------------------------------------------------
++	*/
++	ret_val = pci_enable_device(dm646x_pci_dev);
++	if (ret_val) {
++		dev_err(&dm646x_pci_dev->dev, "Failed to enable device.\n");
++		goto err_post_cdev;
++	}
++
++	/* ---------------------------------------------------------------------
++	*  6.  Set PCI as the bus master
++	* ---------------------------------------------------------------------
++	*/
++	dm646x_pci_set_master() ;
++
++	/* ---------------------------------------------------------------------
++	*  7.  Access DM646x BARs and mapped regions over PCI  bus
++	* ---------------------------------------------------------------------
++	*/
++	ret_val = dm646x_pci_read_BAR();
++	if (ret_val == -1) {
++		dev_err(&dm646x_pci_dev->dev, "Host device could not read the "
++				"DM646x BAR registers\n");
++		goto err_post_cdev;
++	}
++
++	/* ---------------------------------------------------------------------
++	*  8.  Populate the PCI driver data
++	* ---------------------------------------------------------------------
++	*/
++	pci_set_drvdata(dm646x_pci_dev, ddr2b_virt);
++
++	return 0 ;
++
++err_post_cdev:
++	class_destroy(dm646x_pci_class);
++	cdev_del(&dm646x_pci_cdev);
++	unregister_chrdev_region(dm646x_dev_id, DM646X_DEV_COUNT);
++
++err_post_pci:
++	pci_dev_put(dm646x_pci_dev);
++
++	return ret_val;
++}
++module_init(dm646x_pci_init);
++
++/* =============================================================================
++ *  @func   dm646x_pci_cleanup
++ *
++ *  @desc   This function will be called when this module is removed. It
++ *	    will release all mapped memory regions and will release all
++ *	    the PCI resources.
++ *
++ *  @modif  None.
++ *  ============================================================================
++ */
++void __exit dm646x_pci_cleanup(void)
++{
++	/* ---------------------------------------------------------------------
++	* Freeing the major number & other resources
++	* ---------------------------------------------------------------------
++	*/
++	device_destroy(dm646x_pci_class, dm646x_dev_id);
++	class_destroy(dm646x_pci_class);
++	cdev_del(&dm646x_pci_cdev);
++	unregister_chrdev_region(dm646x_dev_id, DM646X_DEV_COUNT);
++
++	/* ---------------------------------------------------------------------
++	* Unmap baseRegs region & release the reg region.
++	* ---------------------------------------------------------------------
++	*/
++	iounmap(tcm_virt);
++	release_mem_region(tcm_base, tcm_len);
++
++	/* ---------------------------------------------------------------------
++	* Unmap baseRegs region & release the reg region.
++	* ---------------------------------------------------------------------
++	*/
++	iounmap(ddr2a_virt);
++	iounmap(comm_virt);
++	iounmap(linux_virt);
++	release_mem_region(ddr2a_base, ddr2a_len);
++
++	/* ---------------------------------------------------------------------
++	* Unmap baseRegs region & release the reg region.
++	* ---------------------------------------------------------------------
++	*/
++	iounmap(ddr2b_virt);
++	release_mem_region(ddr2b_base, ddr2b_len);
++
++	/* ---------------------------------------------------------------------
++	* Unmap baseRegs region & release the reg region.
++	* ---------------------------------------------------------------------
++	*/
++	iounmap(emif_virt);
++	release_mem_region(emif_reg_base, emif_reg_len);
++
++	/* ---------------------------------------------------------------------
++	* Unmap baseRegs region & release the reg region.
++	* ---------------------------------------------------------------------
++	*/
++	iounmap((void *)reg_virt);
++	release_mem_region(reg_base, reg_len);
++
++	pci_disable_device(dm646x_pci_dev);
++
++	/* ---------------------------------------------------------------------
++	*	 Release the PCI device
++	* ---------------------------------------------------------------------
++	*/
++	pci_dev_put(dm646x_pci_dev);
++}
++module_exit(dm646x_pci_cleanup);
++MODULE_LICENSE("GPL");
++
+--- /dev/null
++++ b/drivers/spi/davinci_spi.c
+@@ -0,0 +1,1148 @@
++/*
++ * Copyright (C) 2009 Texas Instruments.
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
++ */
++
++#include <linux/interrupt.h>
++#include <linux/io.h>
++#include <linux/gpio.h>
++#include <linux/module.h>
++#include <linux/delay.h>
++#include <linux/platform_device.h>
++#include <linux/err.h>
++#include <linux/clk.h>
++#include <linux/dma-mapping.h>
++#include <linux/spi/spi.h>
++#include <linux/spi/spi_bitbang.h>
++
++#include <mach/spi.h>
++#include <mach/edma.h>
++
++#include "davinci_spi.h"
++
++static unsigned use_dma;
++
++#define	DAVINCI_SPI_NO_RESOURCE		((resource_size_t)-1)
++
++static void davinci_spi_rx_buf_u8(u32 data, struct davinci_spi *davinci_spi)
++{
++	u8 *rx = davinci_spi->rx;
++
++	*rx++ = (u8)data;
++	davinci_spi->rx = rx;
++}
++
++static void davinci_spi_rx_buf_u16(u32 data, struct davinci_spi *davinci_spi)
++{
++	u16 *rx = davinci_spi->rx;
++
++	*rx++ = (u16)data;
++	davinci_spi->rx = rx;
++}
++
++static u32 davinci_spi_tx_buf_u8(struct davinci_spi *davinci_spi)
++{
++	u32 data;
++	const u8 *tx = davinci_spi->tx;
++
++	data = *tx++;
++	davinci_spi->tx = tx;
++	return data;
++}
++
++static u32 davinci_spi_tx_buf_u16(struct davinci_spi *davinci_spi)
++{
++	u32 data;
++	const u16 *tx = davinci_spi->tx;
++
++	data = *tx++;
++	davinci_spi->tx = tx;
++	return data;
++}
++
++static inline void set_io_bits(void __iomem *addr, u32 bits)
++{
++	u32 v = ioread32(addr);
++
++	v |= bits;
++	iowrite32(v, addr);
++}
++
++static inline void clear_io_bits(void __iomem *addr, u32 bits)
++{
++	u32 v = ioread32(addr);
++
++	v &= ~bits;
++	iowrite32(v, addr);
++}
++
++static inline void set_fmt_bits(void __iomem *addr, u32 bits, int cs_num)
++{
++	set_io_bits(addr + SPIFMT0 + (0x4 * cs_num), bits);
++}
++
++static inline void clear_fmt_bits(void __iomem *addr, u32 bits, int cs_num)
++{
++	clear_io_bits(addr + SPIFMT0 + (0x4 * cs_num), bits);
++}
++
++static void davinci_spi_set_dma_req(const struct spi_device *spi, int enable)
++{
++	struct davinci_spi *davinci_spi = spi_master_get_devdata(spi->master);
++
++	if (enable)
++		set_io_bits(davinci_spi->base + SPIINT, SPIINT_DMA_REQ_EN);
++	else
++		clear_io_bits(davinci_spi->base + SPIINT, SPIINT_DMA_REQ_EN);
++}
++
++/*
++ * Interface to control the chip select signal
++ */
++static void davinci_spi_chipselect(struct spi_device *spi, int value)
++{
++	struct davinci_spi *davinci_spi;
++	struct davinci_spi_platform_data *pdata;
++	u32 data1_reg_val = 0;
++
++	davinci_spi = spi_master_get_devdata(spi->master);
++	pdata = davinci_spi->pdata;
++
++	/*
++	 * Board specific chip select logic decides the polarity and cs
++	 * line for the controller
++	 */
++	if (value == BITBANG_CS_INACTIVE) {
++		set_io_bits(davinci_spi->base + SPIDEF, CS_DEFAULT);
++
++		data1_reg_val |= CS_DEFAULT << SPIDAT1_CSNR_SHIFT;
++		iowrite32(data1_reg_val, davinci_spi->base + SPIDAT1);
++
++		while ((ioread32(davinci_spi->base + SPIBUF)
++					& SPIBUF_RXEMPTY_MASK) == 0)
++			cpu_relax();
++	}
++}
++
++/*
++ * davinci_spi_setup_transfer - This functions will determine transfer method
++ * @spi: spi device on which data transfer to be done
++ * @t: spi transfer in which transfer info is filled
++ *
++ * This function determines data transfer method (8/16/32 bit transfer).
++ * It will also set the SPI Clock Control register according to
++ * SPI slave device freq.
++ */
++static int davinci_spi_setup_transfer(struct spi_device *spi,
++		struct spi_transfer *t)
++{
++
++	struct davinci_spi *davinci_spi;
++	struct davinci_spi_platform_data *pdata;
++	u8 bits_per_word = 0;
++	u32 hz = 0, prescale;
++
++	davinci_spi = spi_master_get_devdata(spi->master);
++	pdata = davinci_spi->pdata;
++
++	if (t) {
++		bits_per_word = t->bits_per_word;
++		hz = t->speed_hz;
++	}
++
++	/* if bits_per_word is not set then set it default */
++	if (!bits_per_word)
++		bits_per_word = spi->bits_per_word;
++
++	/*
++	 * Assign function pointer to appropriate transfer method
++	 * 8bit, 16bit or 32bit transfer
++	 */
++	if (bits_per_word <= 8 && bits_per_word >= 2) {
++		davinci_spi->get_rx = davinci_spi_rx_buf_u8;
++		davinci_spi->get_tx = davinci_spi_tx_buf_u8;
++		davinci_spi->slave[spi->chip_select].bytes_per_word = 1;
++	} else if (bits_per_word <= 16 && bits_per_word >= 2) {
++		davinci_spi->get_rx = davinci_spi_rx_buf_u16;
++		davinci_spi->get_tx = davinci_spi_tx_buf_u16;
++		davinci_spi->slave[spi->chip_select].bytes_per_word = 2;
++	} else
++		return -EINVAL;
++
++	if (!hz)
++		hz = spi->max_speed_hz;
++
++	clear_fmt_bits(davinci_spi->base, SPIFMT_CHARLEN_MASK,
++			spi->chip_select);
++	set_fmt_bits(davinci_spi->base, bits_per_word & 0x1f,
++			spi->chip_select);
++
++	prescale = ((clk_get_rate(davinci_spi->clk) / hz) - 1) & 0xff;
++
++	clear_fmt_bits(davinci_spi->base, 0x0000ff00, spi->chip_select);
++	set_fmt_bits(davinci_spi->base, prescale << 8, spi->chip_select);
++
++	return 0;
++}
++
++static void davinci_spi_dma_rx_callback(unsigned lch, u16 ch_status, void *data)
++{
++	struct spi_device *spi = (struct spi_device *)data;
++	struct davinci_spi *davinci_spi;
++	struct davinci_spi_dma *davinci_spi_dma;
++	struct davinci_spi_platform_data *pdata;
++
++	davinci_spi = spi_master_get_devdata(spi->master);
++	davinci_spi_dma = &(davinci_spi->dma_channels[spi->chip_select]);
++	pdata = davinci_spi->pdata;
++
++	if (ch_status == DMA_COMPLETE)
++		edma_stop(davinci_spi_dma->dma_rx_channel);
++	else
++		edma_clean_channel(davinci_spi_dma->dma_rx_channel);
++
++	complete(&davinci_spi_dma->dma_rx_completion);
++	/* We must disable the DMA RX request */
++	davinci_spi_set_dma_req(spi, 0);
++
++}
++
++static void davinci_spi_dma_tx_callback(unsigned lch, u16 ch_status, void *data)
++{
++	struct spi_device *spi = (struct spi_device *)data;
++	struct davinci_spi *davinci_spi;
++	struct davinci_spi_dma *davinci_spi_dma;
++	struct davinci_spi_platform_data *pdata;
++
++	davinci_spi = spi_master_get_devdata(spi->master);
++	davinci_spi_dma = &(davinci_spi->dma_channels[spi->chip_select]);
++	pdata = davinci_spi->pdata;
++
++	if (ch_status == DMA_COMPLETE)
++		edma_stop(davinci_spi_dma->dma_tx_channel);
++	else
++		edma_clean_channel(davinci_spi_dma->dma_tx_channel);
++
++	complete(&davinci_spi_dma->dma_tx_completion);
++	/* We must disable the DMA TX request */
++	davinci_spi_set_dma_req(spi, 0);
++
++}
++
++static int davinci_spi_request_dma(struct spi_device *spi)
++{
++	struct davinci_spi *davinci_spi;
++	struct davinci_spi_dma *davinci_spi_dma;
++	struct davinci_spi_platform_data *pdata;
++	struct device *sdev;
++	int r;
++
++	davinci_spi = spi_master_get_devdata(spi->master);
++	davinci_spi_dma = &davinci_spi->dma_channels[spi->chip_select];
++	pdata = davinci_spi->pdata;
++	sdev = davinci_spi->bitbang.master->dev.parent;
++
++	r = edma_alloc_channel(davinci_spi_dma->dma_rx_sync_dev,
++				davinci_spi_dma_rx_callback, spi,
++				davinci_spi_dma->eventq);
++	if (r < 0) {
++		dev_dbg(sdev, "Unable to request DMA channel for MibSPI RX\n");
++		return -EAGAIN;
++	}
++	davinci_spi_dma->dma_rx_channel = r;
++	r = edma_alloc_channel(davinci_spi_dma->dma_tx_sync_dev,
++				davinci_spi_dma_tx_callback, spi,
++				davinci_spi_dma->eventq);
++	if (r < 0) {
++		edma_free_channel(davinci_spi_dma->dma_rx_channel);
++		davinci_spi_dma->dma_rx_channel = -1;
++		dev_dbg(sdev, "Unable to request DMA channel for MibSPI TX\n");
++		return -EAGAIN;
++	}
++	davinci_spi_dma->dma_tx_channel = r;
++
++	return 0;
++}
++
++/*
++ * davinci_spi_setup - This functions will set default transfer method
++ * @spi: spi device on which data transfer to be done
++ *
++ * This functions sets the default transfer method.
++ */
++
++static int davinci_spi_setup(struct spi_device *spi)
++{
++	int retval;
++	struct davinci_spi *davinci_spi;
++	struct davinci_spi_dma *davinci_spi_dma;
++
++	davinci_spi = spi_master_get_devdata(spi->master);
++
++	/* if bits per word length is zero then set it default 8 */
++	if (!spi->bits_per_word)
++		spi->bits_per_word = 8;
++
++	davinci_spi->slave[spi->chip_select].cmd_to_write = 0;
++
++	if (use_dma && davinci_spi->dma_channels) {
++		davinci_spi_dma = &davinci_spi->dma_channels[spi->chip_select];
++
++		if ((davinci_spi_dma->dma_rx_channel == -1)
++				|| (davinci_spi_dma->dma_tx_channel == -1)) {
++			retval = davinci_spi_request_dma(spi);
++			if (retval < 0)
++				return retval;
++		}
++	}
++
++	/*
++	 * SPI in DaVinci and DA8xx operate between
++	 * 600 KHz and 50 MHz
++	 */
++	if (spi->max_speed_hz < 600000 || spi->max_speed_hz > 50000000)
++		return -EINVAL;
++
++	/*
++	 * Set up SPIFMTn register, unique to this chipselect.
++	 *
++	 * NOTE: we could do all of these with one write.  Also, some
++	 * of the "version 2" features are found in chips that don't
++	 * support all of them...
++	 */
++	if (spi->mode & SPI_LSB_FIRST)
++		set_fmt_bits(davinci_spi->base, SPIFMT_SHIFTDIR_MASK,
++				spi->chip_select);
++	else
++		clear_fmt_bits(davinci_spi->base, SPIFMT_SHIFTDIR_MASK,
++				spi->chip_select);
++
++	if (spi->mode & SPI_CPOL)
++		set_fmt_bits(davinci_spi->base, SPIFMT_POLARITY_MASK,
++				spi->chip_select);
++	else
++		clear_fmt_bits(davinci_spi->base, SPIFMT_POLARITY_MASK,
++				spi->chip_select);
++
++	if (!(spi->mode & SPI_CPHA))
++		set_fmt_bits(davinci_spi->base, SPIFMT_PHASE_MASK,
++				spi->chip_select);
++	else
++		clear_fmt_bits(davinci_spi->base, SPIFMT_PHASE_MASK,
++				spi->chip_select);
++
++	/*
++	 * Version 1 hardware supports two basic SPI modes:
++	 *  - Standard SPI mode uses 4 pins, with chipselect
++	 *  - 3 pin SPI is a 4 pin variant without CS (SPI_NO_CS)
++	 *	(distinct from SPI_3WIRE, with just one data wire;
++	 *	or similar variants without MOSI or without MISO)
++	 *
++	 * Version 2 hardware supports an optional handshaking signal,
++	 * so it can support two more modes:
++	 *  - 5 pin SPI variant is standard SPI plus SPI_READY
++	 *  - 4 pin with enable is (SPI_READY | SPI_NO_CS)
++	 */
++
++	if (davinci_spi->version == SPI_VERSION_2) {
++		clear_fmt_bits(davinci_spi->base, SPIFMT_WDELAY_MASK,
++				spi->chip_select);
++		set_fmt_bits(davinci_spi->base,
++				(davinci_spi->pdata->wdelay
++						<< SPIFMT_WDELAY_SHIFT)
++					& SPIFMT_WDELAY_MASK,
++				spi->chip_select);
++
++		if (davinci_spi->pdata->odd_parity)
++			set_fmt_bits(davinci_spi->base,
++					SPIFMT_ODD_PARITY_MASK,
++					spi->chip_select);
++		else
++			clear_fmt_bits(davinci_spi->base,
++					SPIFMT_ODD_PARITY_MASK,
++					spi->chip_select);
++
++		if (davinci_spi->pdata->parity_enable)
++			set_fmt_bits(davinci_spi->base,
++					SPIFMT_PARITYENA_MASK,
++					spi->chip_select);
++		else
++			clear_fmt_bits(davinci_spi->base,
++					SPIFMT_PARITYENA_MASK,
++					spi->chip_select);
++
++		if (davinci_spi->pdata->wait_enable)
++			set_fmt_bits(davinci_spi->base,
++					SPIFMT_WAITENA_MASK,
++					spi->chip_select);
++		else
++			clear_fmt_bits(davinci_spi->base,
++					SPIFMT_WAITENA_MASK,
++					spi->chip_select);
++
++		if (davinci_spi->pdata->timer_disable)
++			set_fmt_bits(davinci_spi->base,
++					SPIFMT_DISTIMER_MASK,
++					spi->chip_select);
++		else
++			clear_fmt_bits(davinci_spi->base,
++					SPIFMT_DISTIMER_MASK,
++					spi->chip_select);
++	}
++
++	retval = davinci_spi_setup_transfer(spi, NULL);
++
++	return retval;
++}
++
++static void davinci_spi_cleanup(struct spi_device *spi)
++{
++	struct davinci_spi *davinci_spi = spi_master_get_devdata(spi->master);
++	struct davinci_spi_dma *davinci_spi_dma;
++
++	davinci_spi_dma = &davinci_spi->dma_channels[spi->chip_select];
++
++	if (use_dma && davinci_spi->dma_channels) {
++		davinci_spi_dma = &davinci_spi->dma_channels[spi->chip_select];
++
++		if ((davinci_spi_dma->dma_rx_channel != -1)
++				&& (davinci_spi_dma->dma_tx_channel != -1)) {
++			edma_free_channel(davinci_spi_dma->dma_tx_channel);
++			edma_free_channel(davinci_spi_dma->dma_rx_channel);
++		}
++	}
++}
++
++static int davinci_spi_bufs_prep(struct spi_device *spi,
++				 struct davinci_spi *davinci_spi)
++{
++	int op_mode = 0;
++
++	/*
++	 * REVISIT  unless devices disagree about SPI_LOOP or
++	 * SPI_READY (SPI_NO_CS only allows one device!), this
++	 * should not need to be done before each message...
++	 * optimize for both flags staying cleared.
++	 */
++
++	op_mode = SPIPC0_DIFUN_MASK
++		| SPIPC0_DOFUN_MASK
++		| SPIPC0_CLKFUN_MASK;
++	if (!(spi->mode & SPI_NO_CS))
++		op_mode |= 1 << spi->chip_select;
++	if (spi->mode & SPI_READY)
++		op_mode |= SPIPC0_SPIENA_MASK;
++
++	iowrite32(op_mode, davinci_spi->base + SPIPC0);
++
++	if (spi->mode & SPI_LOOP)
++		set_io_bits(davinci_spi->base + SPIGCR1,
++				SPIGCR1_LOOPBACK_MASK);
++	else
++		clear_io_bits(davinci_spi->base + SPIGCR1,
++				SPIGCR1_LOOPBACK_MASK);
++
++	return 0;
++}
++
++static int davinci_spi_check_error(struct davinci_spi *davinci_spi,
++				   int int_status)
++{
++	struct device *sdev = davinci_spi->bitbang.master->dev.parent;
++
++	if (int_status & SPIFLG_TIMEOUT_MASK) {
++		dev_dbg(sdev, "SPI Time-out Error\n");
++		return -ETIMEDOUT;
++	}
++	if (int_status & SPIFLG_DESYNC_MASK) {
++		dev_dbg(sdev, "SPI Desynchronization Error\n");
++		return -EIO;
++	}
++	if (int_status & SPIFLG_BITERR_MASK) {
++		dev_dbg(sdev, "SPI Bit error\n");
++		return -EIO;
++	}
++
++	if (davinci_spi->version == SPI_VERSION_2) {
++		if (int_status & SPIFLG_DLEN_ERR_MASK) {
++			dev_dbg(sdev, "SPI Data Length Error\n");
++			return -EIO;
++		}
++		if (int_status & SPIFLG_PARERR_MASK) {
++			dev_dbg(sdev, "SPI Parity Error\n");
++			return -EIO;
++		}
++		if (int_status & SPIFLG_OVRRUN_MASK) {
++			dev_dbg(sdev, "SPI Data Overrun error\n");
++			return -EIO;
++		}
++		if (int_status & SPIFLG_TX_INTR_MASK) {
++			dev_dbg(sdev, "SPI TX intr bit set\n");
++			return -EIO;
++		}
++		if (int_status & SPIFLG_BUF_INIT_ACTIVE_MASK) {
++			dev_dbg(sdev, "SPI Buffer Init Active\n");
++			return -EBUSY;
++		}
++	}
++
++	return 0;
++}
++
++/*
++ * davinci_spi_bufs - functions which will handle transfer data
++ * @spi: spi device on which data transfer to be done
++ * @t: spi transfer in which transfer info is filled
++ *
++ * This function will put data to be transferred into data register
++ * of SPI controller and then wait until the completion will be marked
++ * by the IRQ Handler.
++ */
++static int davinci_spi_bufs_pio(struct spi_device *spi, struct spi_transfer *t)
++{
++	struct davinci_spi *davinci_spi;
++	int int_status, count, ret;
++	u8 conv, tmp;
++	u32 tx_data, data1_reg_val;
++	u32 buf_val, flg_val;
++	struct davinci_spi_platform_data *pdata;
++
++	davinci_spi = spi_master_get_devdata(spi->master);
++	pdata = davinci_spi->pdata;
++
++	davinci_spi->tx = t->tx_buf;
++	davinci_spi->rx = t->rx_buf;
++
++	/* convert len to words bbased on bits_per_word */
++	conv = davinci_spi->slave[spi->chip_select].bytes_per_word;
++	davinci_spi->count = t->len / conv;
++
++	INIT_COMPLETION(davinci_spi->done);
++
++	ret = davinci_spi_bufs_prep(spi, davinci_spi);
++	if (ret)
++		return ret;
++
++	/* Enable SPI */
++	set_io_bits(davinci_spi->base + SPIGCR1, SPIGCR1_SPIENA_MASK);
++
++	iowrite32(0 | (pdata->c2tdelay << SPI_C2TDELAY_SHIFT) |
++			(pdata->t2cdelay << SPI_T2CDELAY_SHIFT),
++			davinci_spi->base + SPIDELAY);
++
++	count = davinci_spi->count;
++	data1_reg_val = pdata->cs_hold << SPIDAT1_CSHOLD_SHIFT;
++	tmp = ~(0x1 << spi->chip_select);
++
++	clear_io_bits(davinci_spi->base + SPIDEF, ~tmp);
++
++	data1_reg_val |= tmp << SPIDAT1_CSNR_SHIFT;
++
++	while ((ioread32(davinci_spi->base + SPIBUF)
++				& SPIBUF_RXEMPTY_MASK) == 0)
++		cpu_relax();
++
++	/* Determine the command to execute READ or WRITE */
++	if (t->tx_buf) {
++		clear_io_bits(davinci_spi->base + SPIINT, SPIINT_MASKALL);
++
++		while (1) {
++			tx_data = davinci_spi->get_tx(davinci_spi);
++
++			data1_reg_val &= ~(0xFFFF);
++			data1_reg_val |= (0xFFFF & tx_data);
++
++			buf_val = ioread32(davinci_spi->base + SPIBUF);
++			if ((buf_val & SPIBUF_TXFULL_MASK) == 0) {
++				iowrite32(data1_reg_val,
++						davinci_spi->base + SPIDAT1);
++
++				count--;
++			}
++			while (ioread32(davinci_spi->base + SPIBUF)
++					& SPIBUF_RXEMPTY_MASK)
++				cpu_relax();
++
++			/* getting the returned byte */
++			if (t->rx_buf) {
++				buf_val = ioread32(davinci_spi->base + SPIBUF);
++				davinci_spi->get_rx(buf_val, davinci_spi);
++			}
++			if (count <= 0)
++				break;
++		}
++	} else {
++		if (pdata->poll_mode) {
++			while (1) {
++				/* keeps the serial clock going */
++				if ((ioread32(davinci_spi->base + SPIBUF)
++						& SPIBUF_TXFULL_MASK) == 0)
++					iowrite32(data1_reg_val,
++						davinci_spi->base + SPIDAT1);
++
++				while (ioread32(davinci_spi->base + SPIBUF) &
++						SPIBUF_RXEMPTY_MASK)
++					cpu_relax();
++
++				flg_val = ioread32(davinci_spi->base + SPIFLG);
++				buf_val = ioread32(davinci_spi->base + SPIBUF);
++
++				davinci_spi->get_rx(buf_val, davinci_spi);
++
++				count--;
++				if (count <= 0)
++					break;
++			}
++		} else {	/* Receive in Interrupt mode */
++			int i;
++
++			for (i = 0; i < davinci_spi->count; i++) {
++				set_io_bits(davinci_spi->base + SPIINT,
++						SPIINT_BITERR_INTR
++						| SPIINT_OVRRUN_INTR
++						| SPIINT_RX_INTR);
++
++				iowrite32(data1_reg_val,
++						davinci_spi->base + SPIDAT1);
++
++				while (ioread32(davinci_spi->base + SPIINT) &
++						SPIINT_RX_INTR)
++					cpu_relax();
++			}
++			iowrite32((data1_reg_val & 0x0ffcffff),
++					davinci_spi->base + SPIDAT1);
++		}
++	}
++
++	/*
++	 * Check for bit error, desync error,parity error,timeout error and
++	 * receive overflow errors
++	 */
++	int_status = ioread32(davinci_spi->base + SPIFLG);
++
++	ret = davinci_spi_check_error(davinci_spi, int_status);
++	if (ret != 0)
++		return ret;
++
++	/* SPI Framework maintains the count only in bytes so convert back */
++	davinci_spi->count *= conv;
++
++	return t->len;
++}
++
++#define DAVINCI_DMA_DATA_TYPE_S8	0x01
++#define DAVINCI_DMA_DATA_TYPE_S16	0x02
++#define DAVINCI_DMA_DATA_TYPE_S32	0x04
++
++static int davinci_spi_bufs_dma(struct spi_device *spi, struct spi_transfer *t)
++{
++	struct davinci_spi *davinci_spi;
++	int int_status = 0;
++	int count;
++	u8 conv = 1;
++	u8 tmp;
++	u32 data1_reg_val;
++	struct davinci_spi_dma *davinci_spi_dma;
++	int word_len, data_type, ret;
++	unsigned long tx_reg, rx_reg;
++	struct davinci_spi_platform_data *pdata;
++	struct device *sdev;
++
++	davinci_spi = spi_master_get_devdata(spi->master);
++	pdata = davinci_spi->pdata;
++	sdev = davinci_spi->bitbang.master->dev.parent;
++
++	BUG_ON(davinci_spi->dma_channels == NULL);
++
++	davinci_spi_dma = &davinci_spi->dma_channels[spi->chip_select];
++
++	tx_reg = (unsigned long)davinci_spi->pbase + SPIDAT1;
++	rx_reg = (unsigned long)davinci_spi->pbase + SPIBUF;
++
++	/* used for macro defs */
++	davinci_spi->tx = t->tx_buf;
++	davinci_spi->rx = t->rx_buf;
++
++	/* convert len to words based on bits_per_word */
++	conv = davinci_spi->slave[spi->chip_select].bytes_per_word;
++	davinci_spi->count = t->len / conv;
++
++	INIT_COMPLETION(davinci_spi->done);
++
++	init_completion(&davinci_spi_dma->dma_rx_completion);
++	init_completion(&davinci_spi_dma->dma_tx_completion);
++
++	word_len = conv * 8;
++
++	if (word_len <= 8)
++		data_type = DAVINCI_DMA_DATA_TYPE_S8;
++	else if (word_len <= 16)
++		data_type = DAVINCI_DMA_DATA_TYPE_S16;
++	else if (word_len <= 32)
++		data_type = DAVINCI_DMA_DATA_TYPE_S32;
++	else
++		return -1;
++
++	ret = davinci_spi_bufs_prep(spi, davinci_spi);
++	if (ret)
++		return ret;
++
++	/* Put delay val if required */
++	iowrite32(0 | (pdata->c2tdelay << SPI_C2TDELAY_SHIFT) |
++			(pdata->t2cdelay << SPI_T2CDELAY_SHIFT),
++			davinci_spi->base + SPIDELAY);
++
++	count = davinci_spi->count;	/* the number of elements */
++	data1_reg_val = pdata->cs_hold << SPIDAT1_CSHOLD_SHIFT;
++
++	/* CD default = 0xFF */
++	tmp = ~(0x1 << spi->chip_select);
++
++	clear_io_bits(davinci_spi->base + SPIDEF, ~tmp);
++
++	data1_reg_val |= tmp << SPIDAT1_CSNR_SHIFT;
++
++	/* disable all interrupts for dma transfers */
++	clear_io_bits(davinci_spi->base + SPIINT, SPIINT_MASKALL);
++	/* Disable SPI to write configuration bits in SPIDAT */
++	clear_io_bits(davinci_spi->base + SPIGCR1, SPIGCR1_SPIENA_MASK);
++	iowrite32(data1_reg_val, davinci_spi->base + SPIDAT1);
++	/* Enable SPI */
++	set_io_bits(davinci_spi->base + SPIGCR1, SPIGCR1_SPIENA_MASK);
++
++	while ((ioread32(davinci_spi->base + SPIBUF)
++				& SPIBUF_RXEMPTY_MASK) == 0)
++		cpu_relax();
++
++
++	if (t->tx_buf != NULL) {
++		t->tx_dma = dma_map_single(&spi->dev, (void *)t->tx_buf, count,
++				DMA_TO_DEVICE);
++		if (dma_mapping_error(&spi->dev, t->tx_dma)) {
++			dev_dbg(sdev, "Couldn't DMA map a %d bytes TX buffer\n",
++					count);
++			return -1;
++		}
++		edma_set_transfer_params(davinci_spi_dma->dma_tx_channel, data_type,
++			count, 1, 0, ASYNC);
++		edma_set_dest(davinci_spi_dma->dma_tx_channel,
++				tx_reg, INCR, W8BIT);
++		edma_set_src(davinci_spi_dma->dma_tx_channel,
++				t->tx_dma, INCR, W8BIT);
++		edma_set_src_index(davinci_spi_dma->dma_tx_channel, data_type, 0);
++		edma_set_dest_index(davinci_spi_dma->dma_tx_channel, 0, 0);
++	} else {
++		/* We need TX clocking for RX transaction */
++		t->tx_dma = dma_map_single(&spi->dev,
++				(void *)davinci_spi->tmp_buf, count + 1,
++				DMA_TO_DEVICE);
++		if (dma_mapping_error(&spi->dev, t->tx_dma)) {
++			dev_dbg(sdev, "Couldn't DMA map a %d bytes TX tmp buffer\n",
++					count);
++			return -1;
++		}
++		edma_set_transfer_params(davinci_spi_dma->dma_tx_channel,
++				data_type, count + 1, 1, 0, ASYNC);
++		edma_set_dest(davinci_spi_dma->dma_tx_channel, tx_reg,
++				INCR, W8BIT);
++		edma_set_src(davinci_spi_dma->dma_tx_channel,
++				t->tx_dma, INCR, W8BIT);
++		edma_set_src_index(davinci_spi_dma->dma_tx_channel,
++				data_type, 0);
++		edma_set_dest_index(davinci_spi_dma->dma_tx_channel, 0, 0);
++	}
++
++	if (t->rx_buf != NULL) {
++		/* initiate transaction */
++		iowrite32(data1_reg_val, davinci_spi->base + SPIDAT1);
++
++		t->rx_dma = dma_map_single(&spi->dev, (void *)t->rx_buf, count,
++				DMA_FROM_DEVICE);
++		if (dma_mapping_error(&spi->dev, t->rx_dma)) {
++			dev_dbg(sdev, "Couldn't DMA map a %d bytes RX buffer\n",
++					count);
++			if (t->tx_buf != NULL)
++				dma_unmap_single(NULL, t->tx_dma,
++						 count, DMA_TO_DEVICE);
++			return -1;
++		}
++		edma_set_transfer_params(davinci_spi_dma->dma_rx_channel, data_type,
++				count, 1, 0, ASYNC);
++		edma_set_src(davinci_spi_dma->dma_rx_channel,
++				rx_reg, INCR, W8BIT);
++		edma_set_dest(davinci_spi_dma->dma_rx_channel,
++				t->rx_dma, INCR, W8BIT);
++		edma_set_src_index(davinci_spi_dma->dma_rx_channel, 0, 0);
++		edma_set_dest_index(davinci_spi_dma->dma_rx_channel, data_type, 0);
++	}
++
++	if ((t->tx_buf != NULL) || (t->rx_buf != NULL))
++		edma_start(davinci_spi_dma->dma_tx_channel);
++
++	if (t->rx_buf != NULL)
++		edma_start(davinci_spi_dma->dma_rx_channel);
++
++	if ((t->rx_buf != NULL) || (t->tx_buf != NULL))
++		davinci_spi_set_dma_req(spi, 1);
++
++	if (t->tx_buf != NULL)
++		wait_for_completion_interruptible(
++				&davinci_spi_dma->dma_tx_completion);
++
++	if (t->rx_buf != NULL)
++		wait_for_completion_interruptible(
++				&davinci_spi_dma->dma_rx_completion);
++
++	if (t->tx_buf != NULL)
++		dma_unmap_single(NULL, t->tx_dma, count, DMA_TO_DEVICE);
++	else
++		dma_unmap_single(NULL, t->tx_dma, count + 1, DMA_TO_DEVICE);
++
++	if (t->rx_buf != NULL)
++		dma_unmap_single(NULL, t->rx_dma, count, DMA_FROM_DEVICE);
++
++	/*
++	 * Check for bit error, desync error,parity error,timeout error and
++	 * receive overflow errors
++	 */
++	int_status = ioread32(davinci_spi->base + SPIFLG);
++
++	ret = davinci_spi_check_error(davinci_spi, int_status);
++	if (ret != 0)
++		return ret;
++
++	/* SPI Framework maintains the count only in bytes so convert back */
++	davinci_spi->count *= conv;
++
++	return t->len;
++}
++
++/*
++ * davinci_spi_irq - probe function for SPI Master Controller
++ * @irq: IRQ number for this SPI Master
++ * @context_data: structure for SPI Master controller davinci_spi
++ *
++ * ISR will determine that interrupt arrives either for READ or WRITE command.
++ * According to command it will do the appropriate action. It will check
++ * transfer length and if it is not zero then dispatch transfer command again.
++ * If transfer length is zero then it will indicate the COMPLETION so that
++ * davinci_spi_bufs function can go ahead.
++ */
++static irqreturn_t davinci_spi_irq(s32 irq, void *context_data)
++{
++	struct davinci_spi *davinci_spi = context_data;
++	u32 int_status, rx_data = 0;
++	irqreturn_t ret = IRQ_NONE;
++
++	int_status = ioread32(davinci_spi->base + SPIFLG);
++
++	while ((int_status & SPIFLG_RX_INTR_MASK)) {
++		if (likely(int_status & SPIFLG_RX_INTR_MASK)) {
++			ret = IRQ_HANDLED;
++
++			rx_data = ioread32(davinci_spi->base + SPIBUF);
++			davinci_spi->get_rx(rx_data, davinci_spi);
++
++			/* Disable Receive Interrupt */
++			iowrite32(~(SPIINT_RX_INTR | SPIINT_TX_INTR),
++					davinci_spi->base + SPIINT);
++		} else
++			(void)davinci_spi_check_error(davinci_spi, int_status);
++
++		int_status = ioread32(davinci_spi->base + SPIFLG);
++	}
++
++	return ret;
++}
++
++resource_size_t davinci_spi_get_dma_by_flag(struct platform_device *dev,
++		unsigned long flag)
++{
++	struct resource *r;
++	int i;
++
++	for (i = 0; i < 10; i++) {
++		r = platform_get_resource(dev, IORESOURCE_DMA, i);
++		if (r == NULL)
++			break;
++		if ((r->flags & flag) == flag)
++			return r->start;
++	}
++
++	return DAVINCI_SPI_NO_RESOURCE;
++}
++
++/*
++ * davinci_spi_probe - probe function for SPI Master Controller
++ * @pdev: platform_device structure which contains plateform specific data
++ *
++ * According to Linux Device Model this function will be invoked by Linux
++ * with plateform_device struct which contains the device specific info.
++ * This function will map the SPI controller's memory, register IRQ,
++ * Reset SPI controller and setting its registers to default value.
++ * It will invoke spi_bitbang_start to create work queue so that client driver
++ * can register transfer method to work queue.
++ */
++static int davinci_spi_probe(struct platform_device *pdev)
++{
++	struct spi_master *master;
++	struct davinci_spi *davinci_spi;
++	struct davinci_spi_platform_data *pdata;
++	struct resource *r, *mem;
++	resource_size_t dma_rx_chan = DAVINCI_SPI_NO_RESOURCE;
++	resource_size_t	dma_tx_chan = DAVINCI_SPI_NO_RESOURCE;
++	resource_size_t	dma_eventq = DAVINCI_SPI_NO_RESOURCE;
++	int i = 0, ret = 0;
++
++	pdata = pdev->dev.platform_data;
++	if (pdata == NULL) {
++		ret = -ENODEV;
++		goto err;
++	}
++
++	master = spi_alloc_master(&pdev->dev, sizeof(struct davinci_spi));
++	if (master == NULL) {
++		ret = -ENOMEM;
++		goto err;
++	}
++
++	dev_set_drvdata(&pdev->dev, master);
++
++	davinci_spi = spi_master_get_devdata(master);
++	if (davinci_spi == NULL) {
++		ret = -ENOENT;
++		goto free_master;
++	}
++
++	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
++	if (r == NULL) {
++		ret = -ENOENT;
++		goto free_master;
++	}
++
++	davinci_spi->pbase = r->start;
++	davinci_spi->region_size = resource_size(r);
++	davinci_spi->pdata = pdata;
++
++	mem = request_mem_region(r->start, davinci_spi->region_size,
++					pdev->name);
++	if (mem == NULL) {
++		ret = -EBUSY;
++		goto free_master;
++	}
++
++	davinci_spi->base = (struct davinci_spi_reg __iomem *)
++			ioremap(r->start, davinci_spi->region_size);
++	if (davinci_spi->base == NULL) {
++		ret = -ENOMEM;
++		goto release_region;
++	}
++
++	davinci_spi->irq = platform_get_irq(pdev, 0);
++	if (davinci_spi->irq <= 0) {
++		ret = -EINVAL;
++		goto unmap_io;
++	}
++
++	ret = request_irq(davinci_spi->irq, davinci_spi_irq, IRQF_DISABLED,
++			  dev_name(&pdev->dev), davinci_spi);
++	if (ret != 0) {
++		ret = -EAGAIN;
++		goto unmap_io;
++	}
++
++	/* Allocate tmp_buf for tx_buf */
++	davinci_spi->tmp_buf = kzalloc(SPI_BUFSIZ, GFP_KERNEL);
++	if (davinci_spi->tmp_buf == NULL) {
++		ret = -ENOMEM;
++		goto err1;
++	}
++
++	davinci_spi->bitbang.master = spi_master_get(master);
++	if (davinci_spi->bitbang.master == NULL) {
++		ret = -ENODEV;
++		goto free_tmp_buf;
++	}
++
++	davinci_spi->clk = clk_get(&pdev->dev, NULL);
++	if (IS_ERR(davinci_spi->clk)) {
++		ret = -ENODEV;
++		goto put_master;
++	}
++	clk_enable(davinci_spi->clk);
++
++
++	master->bus_num = pdev->id;
++	master->num_chipselect = pdata->num_chipselect;
++	master->setup = davinci_spi_setup;
++	master->cleanup = davinci_spi_cleanup;
++
++	davinci_spi->bitbang.chipselect = davinci_spi_chipselect;
++	davinci_spi->bitbang.setup_transfer = davinci_spi_setup_transfer;
++
++	davinci_spi->version = pdata->version;
++	use_dma = pdata->use_dma;
++
++	davinci_spi->bitbang.flags = SPI_NO_CS | SPI_LSB_FIRST | SPI_LOOP;
++	if (davinci_spi->version == SPI_VERSION_2)
++		davinci_spi->bitbang.flags |= SPI_READY;
++
++	if (use_dma) {
++		dma_rx_chan = davinci_spi_get_dma_by_flag(pdev,
++						IORESOURCE_DMA_RX_CHAN);
++		dma_tx_chan = davinci_spi_get_dma_by_flag(pdev,
++						IORESOURCE_DMA_TX_CHAN);
++		dma_eventq  = davinci_spi_get_dma_by_flag(pdev,
++						IORESOURCE_DMA_EVENT_Q);
++	}
++
++	if (!use_dma ||
++	    dma_rx_chan == DAVINCI_SPI_NO_RESOURCE ||
++	    dma_tx_chan == DAVINCI_SPI_NO_RESOURCE ||
++	    dma_eventq	== DAVINCI_SPI_NO_RESOURCE) {
++		davinci_spi->bitbang.txrx_bufs = davinci_spi_bufs_pio;
++		use_dma = 0;
++	} else {
++		davinci_spi->bitbang.txrx_bufs = davinci_spi_bufs_dma;
++		davinci_spi->dma_channels = kzalloc(master->num_chipselect
++				* sizeof(struct davinci_spi_dma), GFP_KERNEL);
++		if (davinci_spi->dma_channels == NULL) {
++			ret = -ENOMEM;
++			goto free_clk;
++		}
++
++		for (i = 0; i < master->num_chipselect; i++) {
++			davinci_spi->dma_channels[i].dma_rx_channel = -1;
++			davinci_spi->dma_channels[i].dma_rx_sync_dev =
++				dma_rx_chan;
++			davinci_spi->dma_channels[i].dma_tx_channel = -1;
++			davinci_spi->dma_channels[i].dma_tx_sync_dev =
++				dma_tx_chan;
++			davinci_spi->dma_channels[i].eventq = dma_eventq;
++		}
++		dev_info(&pdev->dev, "DaVinci SPI driver in EDMA mode\n"
++				"Using RX channel = %d , TX channel = %d and "
++				"event queue = %d", dma_rx_chan, dma_tx_chan,
++				dma_eventq);
++	}
++
++	davinci_spi->get_rx = davinci_spi_rx_buf_u8;
++	davinci_spi->get_tx = davinci_spi_tx_buf_u8;
++
++	init_completion(&davinci_spi->done);
++
++	/* Reset In/OUT SPI module */
++	iowrite32(0, davinci_spi->base + SPIGCR0);
++	udelay(100);
++	iowrite32(1, davinci_spi->base + SPIGCR0);
++
++	/* Clock internal */
++	if (davinci_spi->pdata->clk_internal)
++		set_io_bits(davinci_spi->base + SPIGCR1,
++				SPIGCR1_CLKMOD_MASK);
++	else
++		clear_io_bits(davinci_spi->base + SPIGCR1,
++				SPIGCR1_CLKMOD_MASK);
++
++	/* master mode default */
++	set_io_bits(davinci_spi->base + SPIGCR1, SPIGCR1_MASTER_MASK);
++
++	if (davinci_spi->pdata->intr_level)
++		iowrite32(SPI_INTLVL_1, davinci_spi->base + SPILVL);
++	else
++		iowrite32(SPI_INTLVL_0, davinci_spi->base + SPILVL);
++
++	ret = spi_bitbang_start(&davinci_spi->bitbang);
++	if (ret != 0)
++		goto free_clk;
++
++	dev_info(&pdev->dev, "Controller at 0x%p \n", davinci_spi->base);
++
++	if (!pdata->poll_mode)
++		dev_info(&pdev->dev, "Operating in interrupt mode"
++			" using IRQ %d\n", davinci_spi->irq);
++
++	return ret;
++
++free_clk:
++	clk_disable(davinci_spi->clk);
++	clk_put(davinci_spi->clk);
++put_master:
++	spi_master_put(master);
++free_tmp_buf:
++	kfree(davinci_spi->tmp_buf);
++err1:
++	free_irq(davinci_spi->irq, davinci_spi);
++unmap_io:
++	iounmap(davinci_spi->base);
++release_region:
++	release_mem_region(davinci_spi->pbase, davinci_spi->region_size);
++free_master:
++	kfree(master);
++err:
++	return ret;
++}
++
++/*
++ * davinci_spi_remove - remove function for SPI Master Controller
++ * @pdev: platform_device structure which contains plateform specific data
++ *
++ * This function will do the reverse action of davinci_spi_probe function
++ * It will free the IRQ and SPI controller's memory region.
++ * It will also call spi_bitbang_stop to destroy the work queue which was
++ * created by spi_bitbang_start.
++ */
++static int __exit davinci_spi_remove(struct platform_device *pdev)
++{
++	struct davinci_spi *davinci_spi;
++	struct spi_master *master;
++
++	master = dev_get_drvdata(&pdev->dev);
++	davinci_spi = spi_master_get_devdata(master);
++
++	spi_bitbang_stop(&davinci_spi->bitbang);
++
++	clk_disable(davinci_spi->clk);
++	clk_put(davinci_spi->clk);
++	spi_master_put(master);
++	kfree(davinci_spi->tmp_buf);
++	free_irq(davinci_spi->irq, davinci_spi);
++	iounmap(davinci_spi->base);
++	release_mem_region(davinci_spi->pbase, davinci_spi->region_size);
++
++	return 0;
++}
++
++static struct platform_driver davinci_spi_driver = {
++	.driver.name = "spi_davinci",
++	.remove = __exit_p(davinci_spi_remove),
++};
++
++static int __init davinci_spi_init(void)
++{
++	return platform_driver_probe(&davinci_spi_driver, davinci_spi_probe);
++}
++
++static void __exit davinci_spi_exit(void)
++{
++	platform_driver_unregister(&davinci_spi_driver);
++}
++
++module_init(davinci_spi_init);
++module_exit(davinci_spi_exit);
++
++MODULE_DESCRIPTION("TI DaVinci SPI Master Controller Driver");
++MODULE_LICENSE("GPL");
+--- /dev/null
++++ b/include/media/davinci/vid_encoder_if.h
+@@ -0,0 +1,287 @@
++/*
++ * Copyright (C) 2007 Texas Instruments Inc
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
++ *
++ * File: vid_encoder_if.h
++ * Description:
++ * ============
++ * This file defines the interface to allow abstraction of an encoder hardware
++ * to an encoder module. Each encoder module support one or more display
++ * channels. It registers with the encoder manager at init and
++ * unregisters at exit. Encoder modules implement a set of operations defines
++ * by this interface. For each display channel, encoder manager selects
++ * one of the encoder registered with it to support the user specified output
++ * and video/graphics modes on that output. First step is to set the output
++ * as requested by the user. To do so, encoder manager iterates through
++ * all supported encoders to match a given output name as requested by the user
++ * by calling enumoutput(). Once there is a match, this encoder is set as the
++ * current active encoder. Encoder manager calls initialize() to init the
++ * encoder and then calls setouput() set the output. If another encoder was
++ * active before this, encoder manager calls deinitialize() to make it
++ * inactive. Encoder must select a default mode for this output as part of
++ * setoutput() call. To set a mode, user call setmode(). All output names and
++ * mode names are defined in vid_encoder_types.h
++ */
++
++#ifndef VID_ENCODER_IF_H
++#define VID_ENCODER_IF_H
++
++#ifdef __KERNEL__
++#include <media/davinci/vid_encoder_types.h>
++
++struct vid_encoder_device;
++/**
++ * struct vid_enc_param_ops
++ * @setparams:
++ * @getparams:
++ *
++ * Description:
++ * Operation used for setting and getting encoder specific parameters.
++ * Operations are applied to the current encoder selected by the
++ * encoder manager
++ * @setparams: pointer to setparams function. This Set Encoder parameters.
++ *    @params - params structure type ptr declared by encoder
++ *    @enc - encoder device ptr
++ *    Returns - zero on success and non-zero otherwise
++ * @getparams: pointer to getparams function. This Get encoder parameters
++ *    @params - params structure type ptr declared by encoder
++ *    @enc - encoder device ptr
++ *    Returns - zero on success and non-zero otherwise
++ */
++struct vid_enc_param_ops {
++	int (*setparams) (void *params, struct vid_encoder_device * enc);
++	int (*getparams) (void *params, struct vid_encoder_device * enc);
++};
++
++/**
++ * struct vid_enc_mode_ops
++ * @setmode:
++ * @getmode:
++ *
++ * Description:
++ *  video/graphics mode ops structure. Operations are applied to the
++ *  current output selected by the encoder
++ * @setmode: Function pointer to setmode. set video/graphics mode or standard
++ *    for current output encoder first check if the std flag is present in the
++ *    mode_info. if yes, it will use name field to match a standard mode. If std
++ *    flag is reset, it may reject the command if non-standard mode
++ *    is not implemented. If non-standard mode is implemented, it would
++ *    save the timing information in the internal structure with a
++ *    key,VID_ENC_STD_NON_STANDARD as defined in vid_encoder_types.h
++ *    It is expected that only one such instance is defined in the video driver.
++ *    Please consider defining a mode in the vid_encoder_types.h
++ *    and use that instead if encoder is to be extended to support additional
++ *    modes not already supported by existing encoders.
++ *    mode_info - ptr to mode information structure.
++ *    enc - encoder device ptr.
++ *    Returns - zero on success and non-zero otherwise.
++ * @getmode: Function pointer to getmode. get current video/graphics mode
++ *    information at the outpu.t
++ *    mode_info - ptr to mode information structure.
++ *    enc - encoder device ptr.
++ *    Returns - zero on success and non-zero otherwise.
++ */
++struct vid_enc_mode_ops {
++	int (*setmode) (struct vid_enc_mode_info * mode_info,
++			struct vid_encoder_device * enc);
++	int (*getmode) (struct vid_enc_mode_info * mode_info,
++			struct vid_encoder_device * enc);
++};
++
++/**
++ * struct vid_enc_control_ops
++ * @setcontrol:
++ * @getcontrol:
++ *
++ * Description:
++ * Control ops structure. Control operations are performed for the current
++ * output. Control brightness, hue, contrast, saturation etc.
++ * @setcontrol: Function pointer to setcontrol. Set control value.
++ *   ctrl - control type.
++ *   val - value to be set for the control.
++ *   enc - ptr to encoder device.
++ *   Returns - zero on success and non-zero otherwise.
++ * @getcontrol: Function pointer to getcontrol. Get control value.
++ *   ctrl - control type.
++ *   val - ptr to value that gets updated
++ *   enc - ptr to encoder device
++ *   Returns - zero on success and non-zero otherwise
++ */
++struct vid_enc_control_ops {
++	int (*setcontrol) (enum vid_enc_ctrl_id ctrl,
++			   unsigned char val, struct vid_encoder_device * enc);
++	int (*getcontrol) (enum vid_enc_ctrl_id ctrl,
++			   unsigned char *val, struct vid_encoder_device * enc);
++};
++
++/**
++ * struct vid_enc_output_ops
++ * @count: Indicates number of outputs supported
++ * @enumoutput:
++ * @setoutput:
++ * @getoutput:
++ *
++ * Description:
++ * output ops structure. enumoutput() is called to iterate
++ * through all outputs supported by the encoder. Encoder manager ues
++ * this API to select an encoder based on the output to be supported.
++ * setoutput is called to set output at the encoder. getoutput is called
++ * for getting the current output at the encoder.
++ * @enumoutput:
++ *   Function pointer.
++ *   index - index of the output.
++ *   output - ptr to char array to hold output name.(size
++ *   		VID_ENC_NAME_MAX_CHARS).
++ *   enc - pointer to encoder device.
++ *   Returns - zero on success and non-zero otherwise.
++ *   enumerates the outputs supported by encoder. To iterate the output, caller
++ *   call this successively, starting with an index set to 0, and incrementing
++ *   the same until this function returns non-zero. Each time name of the output
++ *   at the given index is copied to output. Beware that this API assumes the
++*   passed in output array size is VID_ENC_NAME_MAX_CHARS.
++ * @setoutput:
++ *   Function pointer.
++ *   setoutput to the given output identifed by name. Encoder also must set a
++ *   default mode on the selected output.
++*   output - ptr to output name string.
++*   enc - pointer to encoder device.
++ *   Returns - zero on success and non-zero otherwise.
++ * @getoutput:
++ *   Function pointer.
++ *   getoutput returns name of current output selected at the encoder.
++ *   output - ptr to char array to hold the output name. (size
++ *   		VID_ENC_NAME_MAX_CHARS).
++ *   enc - pointer to encoder device.
++ *   Returns - zero on success and non-zero otherwise.
++ */
++struct vid_enc_output_ops {
++	int count;
++	int (*enumoutput) (int index,
++			   char *output, struct vid_encoder_device * enc);
++	int (*setoutput) (char *output, struct vid_encoder_device * enc);
++	int (*getoutput) (char *output, struct vid_encoder_device * enc);
++};
++
++/**
++ * struct vid_enc_misc_ops
++ * @reset:
++ * @enable: *
++ * Description:
++ *  misc ops structure. Applied for the current encoder selected by the
++ *  encoder manager
++ * @reset: Function pointer to reset.
++ *    For soft reset. Encoder may implement a soft reset that doesn't affect
++ *    any configured registers. Some of the encoder hardware may require
++ *    this if the input signal timings are changed after configuring it's
++ *    mode registers.
++ *    enc - ptr to encoder device.
++ *    Returns - zero on success and non-zero otherwise
++ * @enable: Function pointer to enable.
++ *    enable/disable output. To eliminate noise on the display during SoC mode
++ *    timing configuration, user may call this function to switch Off/On
++ *    the output. Encoder must implement this API call if there is a hardware
++ *    support for the same.
++ *    flag - 0 - disable, 1 - enable.
++ *    enc - ptr to encoder device.
++ *    Returns - zero on success and non-zero otherwise
++ */
++struct vid_enc_misc_ops {
++	int (*reset) (struct vid_encoder_device * enc);
++	int (*enable) (int flag, struct vid_encoder_device * enc);
++};
++
++/**
++ * struct vid_encoder_device
++ * @name: Name of the encoder device
++ * @channel_id:  Id of the channel to which encoder is connected
++ * @capabilities: encoder capabilities. This is only for VBI capabilities
++ * @initialize: Pointer to initialize function to initialize encoder
++ * @mode_ops: Set of functions pointers for standard related functions
++ * @ctrl_ops: Set of functions pointers for control related functions
++ * @output_ops: Set of functions pointers for output related functions
++ * @fmt_ops: Set of functions pointers for format related functions
++ * @params_ops: Set of functions pointers for params related functions
++ * @misc_ops: Set of functions pointers for miscellaneous functions functions
++ * @deinitialize: functions pointer to de-initialize functio
++ * @start_display: function to start display.
++ * @stop_display: function to stop display.
++ * @write_vbi_data: function to write sliced vbi data.
++ * @enable_vbi: Function to enable support for RAW VBI.
++ * @enable_hbi: Function to enable support for RAW HBI.
++ * @set_vbi_services: function to enable sliced vbi services
++ *
++ * Description:
++ * output ops structure
++ *   Channel_id is used when encoder support multiple channels. In this case
++ *   encoder module will use the channel id to select the channel for
++ *   which the operation applies.
++ *   initialize() called by encoder manager to initialize the encoder. Usually
++ *   called before invoking any operations on the encoder.flag may be used by
++ *   the encoder module to do different level of initialization. Encoder
++ *   module must set a default output and mode in this code.
++ *   deinitialize() called to deinitialize the current encoder that is active
++ *   before initializing the new encoder.
++ */
++struct vid_encoder_device {
++	u8 name[VID_ENC_NAME_MAX_CHARS];
++	int channel_id;
++	u32 capabilities;
++	int (*initialize) (struct vid_encoder_device * enc, int flag);
++	struct vid_enc_mode_ops *mode_ops;
++	struct vid_enc_control_ops *ctrl_ops;
++	struct vid_enc_output_ops *output_ops;
++	struct vid_enc_param_ops *params_ops;
++	struct vid_enc_misc_ops *misc_ops;
++	int (*write_vbi_data) (struct vid_enc_sliced_vbi_data * data,
++			       struct vid_encoder_device * enc);
++	int (*enable_vbi) (int flag, struct vid_encoder_device * enc);
++	int (*enable_hbi) (int flag, struct vid_encoder_device * enc);
++	int (*set_vbi_services) (struct vid_enc_sliced_vbi_service * services,
++				 struct vid_encoder_device * enc);
++	int (*get_sliced_cap) (struct vid_enc_sliced_vbi_service *,
++			       struct vid_encoder_device * enc);
++	int (*deinitialize) (struct vid_encoder_device * enc);
++	int (*start_display) (struct vid_encoder_device * enc);
++	int (*stop_display) (struct vid_encoder_device * enc);
++};
++
++/**
++ * vid_enc_register_encoder
++ * @encoder: pointer to the encoder device structure
++ * Returns: Zero if successful, or non-zero otherwise
++ *
++ * Description:
++ * Register the encoder module with the encoder manager
++ * This is implemented by the encoder Manager
++ */
++int vid_enc_register_encoder(struct vid_encoder_device
++			     *encoder);
++
++/**
++ * vid_enc_unregister_encoder
++ * @encoder: pointer to the encoder device structure
++ * Returns: Zero if successful, or non-zero otherwise
++ *
++ * Description:
++ * Unregister the encoder module with the encoder manager
++ * This is implemented by the encoder Manager
++ */
++int vid_enc_unregister_encoder(struct vid_encoder_device
++			       *encoder);
++
++#endif				/* #ifdef __KERNEL__ */
++
++#endif				/* #ifdef VID_ENCODER_IF_H */
+--- a/include/asm-generic/int-ll64.h
++++ b/include/asm-generic/int-ll64.h
+@@ -8,7 +8,7 @@
+ #ifndef _ASM_GENERIC_INT_LL64_H
+ #define _ASM_GENERIC_INT_LL64_H
+ 
+-#include <asm/bitsperlong.h>
++#include <asm-generic/bitsperlong.h>
+ 
+ #ifndef __ASSEMBLY__
+ /*
+--- /dev/null
++++ b/include/media/ths8200.h
+@@ -0,0 +1,21 @@
++/*
++ * THS8200 header file
++ *
++ * Copyright (C) 2009 Texas Instruments Incorporated - http://www.ti.com/
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License as
++ * published by the Free Software Foundation version 2.
++ *
++ * This program is distributed .as is. WITHOUT ANY WARRANTY of any
++ * kind, whether express or implied; without even the implied warranty
++ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ */
++
++#ifndef THS8200_H
++#define THS8200_H
++
++#define THS8200_COMPONENT_ID	(1)
++
++#endif				/* End of #ifndef THS8200_H */
+--- /dev/null
++++ b/include/media/davinci/vid_encoder_types.h
+@@ -0,0 +1,233 @@
++/*
++ * Copyright (C) 2007 Texas Instruments Inc
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
++ *
++ * vid_encoder_types.h
++ * This file contains data types which will be used across encoder manager
++ * , encoders and users of both interfaces */
++
++#ifndef VID_ENCODER_TYPES_H
++#define VID_ENCODER_TYPES_H
++
++#ifdef __KERNEL__
++
++/**
++ * enum vid_enc_init_flag
++ * @VID_ENC_I2C_BIND_FLAG: Only I2C bind
++ * @VID_ENC_FULL_INIT_FLAG: Full initialization
++ *
++ * Description:
++ * An enumeration of the encoder initialization flag.
++ */
++enum vid_enc_init_flag {
++	VID_ENC_I2C_BIND_FLAG,
++	VID_ENC_FULL_INIT_FLAG,
++};
++
++/**
++ * enum vid_enc_frame_type
++ * @VID_ENC_FRAME_INTERLACED: Interlaced frame
++ * @VID_ENC_FRAME_PROGRESSIVE: Progressive frame
++ *
++ * Description:
++ * An enumeration of the Frame Formats.
++ */
++enum vid_enc_frame_type {
++	VID_ENC_FRAME_INTERLACED,
++	VID_ENC_FRAME_PROGRESSIVE,
++};
++
++/** VID_ENC_NAME_MAX_CHARS
++ *
++ * Description:
++ * MAX characters in the name.
++ */
++#define VID_ENC_NAME_MAX_CHARS	30
++
++/**
++ * enum vid_enc_if_type
++ * @VID_ENC_IF_INT: for internal DAC
++ * @VID_ENC_IF_BT656: for BT656 input format
++ * @VID_ENC_IF_BT1120: for BT1120 input format
++ * @VID_ENC_IF_YCC8: for YCC8 input format
++ * @VID_ENC_IF_YCC16: for YCC16 input format
++ * @VID_ENC_IF_SRGB: for SRGB input format
++ * @VID_ENC_IF_PRGB: for PRGB input format
++ *
++ * Description:
++ * An enumeration of the encoder interface types.
++ *
++ */
++enum vid_enc_if_type {
++	VID_ENC_IF_INT,
++	VID_ENC_IF_BT656,
++	VID_ENC_IF_BT1120,
++	VID_ENC_IF_YCC8,
++	VID_ENC_IF_YCC16,
++	VID_ENC_IF_SRGB,
++	VID_ENC_IF_PRGB,
++};
++
++/**
++ * constant strings for standard names or mode names. All modules uses this to
++ * refer a specific standard or mode name
++ */
++#define VID_ENC_STD_NTSC         "NTSC"
++#define VID_ENC_STD_NTSC_RGB     "NTSC-RGB"
++#define VID_ENC_STD_PAL          "PAL"
++#define VID_ENC_STD_PAL_RGB      "PAL-RGB"
++#define VID_ENC_STD_720P_24      "720P-24"
++#define VID_ENC_STD_720P_25      "720P-25"
++#define VID_ENC_STD_720P_30      "720P-30"
++#define VID_ENC_STD_720P_50      "720P-50"
++#define VID_ENC_STD_720P_60      "720P-60"
++#define VID_ENC_STD_1080I_25     "1080I-25"
++#define VID_ENC_STD_1080I_30     "1080I-30"
++#define VID_ENC_STD_1080P_24	 "1080P-24"
++#define VID_ENC_STD_1080P_25     "1080P-25"
++#define VID_ENC_STD_1080P_30     "1080P-30"
++#define VID_ENC_STD_1080P_50     "1080P-50"
++#define VID_ENC_STD_1080P_60     "1080P-60"
++#define VID_ENC_STD_480P_60      "480P-60"
++#define VID_ENC_STD_576P_50      "576P-50"
++#define VID_ENC_STD_640x480      "640x480"
++#define VID_ENC_STD_640x400      "640x400"
++#define VID_ENC_STD_640x350      "640x350"
++#define VID_ENC_STD_800x480      "800x480"
++#define VID_ENC_STD_NON_STANDARD "NON-STANDARD"
++
++/**
++ * enum vid_enc_ctrl_id
++ * @VID_ENC_CTRL_GAIN: Gain control
++ * @VID_ENC_CTRL_BRIGHTNESS: Brighness control
++ * @VID_ENC_CTRL_CONTRAST: Contrast control
++ * @VID_ENC_CTRL_HUE: Hue control
++ * @VID_ENC_CTRL_SATURATION: Saturation Control
++ *
++ * Description:
++ * Constants used for control type IDs
++*/
++enum vid_enc_ctrl_id {
++	VID_ENC_CTRL_GAIN,
++	VID_ENC_CTRL_BRIGHTNESS,
++	VID_ENC_CTRL_CONTRAST,
++	VID_ENC_CTRL_HUE,
++	VID_ENC_CTRL_SATURATION,
++};
++
++/**
++ * constant strings for output names. All modules uses this to
++ * refer a specific output at the encoder hardware or VPBE analog output.
++ * May add additional output names as per following convention. First
++ * output of a type is always with out a suffix, and subsequent outputs
++ * of the same type is defined with suffix x increasing from 1 to max
++ * output names supported as shown below.
++ */
++#define VID_ENC_OUTPUT_COMPOSITE  "COMPOSITE"
++#define VID_ENC_OUTPUT_COMPOSITE1 "COMPOSITE1"
++#define VID_ENC_OUTPUT_SVIDEO     "SVIDEO"
++#define VID_ENC_OUTPUT_SVIDEO1    "SVIDEO1"
++#define	VID_ENC_OUTPUT_COMPONENT  "COMPONENT"
++#define	VID_ENC_OUTPUT_COMPONENT1 "COMPONENT1"
++#define VID_ENC_OUTPUT_LCD        "LCD"
++#define VID_ENC_OUTPUT_LCD1       "LCD1"
++
++/**
++ * struct vid_enc_fract
++ * @numerator: numerator part of a fractional number
++ * @denominator: denominator part of a fractional number
++ *
++ * Description:
++ *  Structure used to represent fractional numbers
++ */
++struct vid_enc_fract {
++	unsigned int numerator;
++	unsigned int denominator;
++};
++
++/* Set of macros for sliced vbi services */
++#define VID_ENC_SLICED_VBI_WSS_PAL	0x0001
++#define VID_ENC_SLICED_VBI_CGMS_NTSC	0x0002
++#define VID_ENC_SLICED_VBI_CC_NTSC	0x0004
++
++/**
++ * struct vid_enc_sliced_vbi_service
++ * @service_set: set of services to be enabled in encoder
++ * @line: line number of the field in which data for these
++ * services is to be included.
++ *
++ * Description:
++ *  Structure used to enable set of sliced VBI services in encoder
++ */
++struct vid_enc_sliced_vbi_data {
++
++	unsigned int service_id;
++	unsigned char field;
++	unsigned char data[48];
++};
++
++struct vid_enc_sliced_vbi_service {
++	unsigned short service_set;
++	unsigned int line[2][23];
++};
++
++/**
++ * struct vid_enc_mode_info
++ * @name: ptr to name string of the standard, "NTSC", "PAL" etc
++ * @std: standard or non-standard mode. 1 - standard, 0 - nonstandard
++ * @if_type: interface type used for this standard configuration
++ * @interlaced: 1 - interlaced, 0 - non interlaced/progressive
++ * @xres: x or horizontal resolution of the display
++ * @yres: y or vertical resolution of the display
++ * @fps: frame per second
++ * @left_margin: left margin of the display
++ * @right_margin: right margin of the display
++ * @upper_margin: upper margin of the display
++ * @lower_margin: lower margin of the display
++ * @hsync_len: h-sync length
++ * @vsync_len: v-sync length
++ * @flags: bit field: bit usage is documented below
++ *
++ * Description:
++ *  Structure holding timing and resolution information of a standard.
++ *  Notes
++ *  ------
++ *  if_type should be used only by encoder manager and encoder.
++ *  flags usage
++ *     b0 (LSB) - hsync polarity, 0 - negative, 1 - positive
++ *     b1       - vsync polarity, 0 - negative, 1 - positive
++ *     b2       - field id polarity, 0 - negative, 1  - positive
++ */
++struct vid_enc_mode_info {
++	unsigned char *name;
++	unsigned int std;
++	enum vid_enc_if_type if_type;
++	unsigned int interlaced;
++	unsigned int xres;
++	unsigned int yres;
++	struct vid_enc_fract fps;
++	unsigned int left_margin;
++	unsigned int right_margin;
++	unsigned int upper_margin;
++	unsigned int lower_margin;
++	unsigned int hsync_len;
++	unsigned int vsync_len;
++	unsigned int flags;
++};
++
++#endif				/* #ifdef __KERNEL__ */
++
++#endif				/* #ifdef VID_ENCODER_TYPES_H */
+--- a/drivers/media/video/davinci/vpss.c
++++ b/drivers/media/video/davinci/vpss.c
+@@ -38,13 +38,38 @@ MODULE_AUTHOR("Texas Instruments");
+ /* vpss BL register offsets */
+ #define DM355_VPSSBL_CCDCMUX		0x1c
+ /* vpss CLK register offsets */
+-#define DM355_VPSSCLK_CLKCTRL		0x04
++#define DM355_VPSSCLK_CLKCTRL		0x4
++#define DM355_VPSSBL_PCR		0x4
++#define DM355_VPSSBL_MEMCTRL		0x18
++
+ /* masks and shifts */
++#define DM365_PCCR 			0x04
++#define DM365_ISP_REG_BASE 		0x01c70000
++#define DM365_VPSS_REG_BASE 		0x01c70200
++#define DM365_VPBE_CLK_CTRL 		0x00
++#define DM365_ISP5_CCDCMUX 		0x20
++#define DM365_ISP5_PG_FRAME_SIZE 	0x28
++#define DM365_CCDC_PG_VD_POL_SHIFT 	0
++#define DM365_CCDC_PG_HD_POL_SHIFT 	1
++#define DM365_VPSS_INTSTAT		0x0C
++#define DM365_VPSS_INTSEL1		0x10
++
++
++#define VPSS_CLK_CTRL			0x01C40044
++#define CCD_SRC_SEL_MASK		(BIT_MASK(5) | BIT_MASK(4))
++#define CCD_SRC_SEL_SHIFT		4
++#define CCD_INT_SEL_MASK		(BIT_MASK(12) | BIT_MASK(11)|\
++					BIT_MASK(10) | BIT_MASK(9)  |\
++					BIT_MASK(8)  | BIT_MASK(4)  |\
++					BIT_MASK(3)  | BIT_MASK(2)  |\
++					BIT_MASK(1)  | BIT_MASK(0))
++
+ #define VPSS_HSSISEL_SHIFT		4
+ 
+-/*
++
++/**
+  * vpss operations. Depends on platform. Not all functions are available
+- * on all platforms. The api, first check if a functio is available before
++ * on all platforms. The api, first check if a function is available before
+  * invoking it. In the probe, the function ptrs are intialized based on
+  * vpss name. vpss name can be "dm355_vpss", "dm644x_vpss" etc.
+  */
+@@ -53,14 +78,21 @@ struct vpss_hw_ops {
+ 	int (*enable_clock)(enum vpss_clock_sel clock_sel, int en);
+ 	/* select input to ccdc */
+ 	void (*select_ccdc_source)(enum vpss_ccdc_source_sel src_sel);
+-	/* clear wbl overlflow bit */
++	/* clear wbl overflow bit */
+ 	int (*clear_wbl_overflow)(enum vpss_wbl_sel wbl_sel);
++	/* set sync polarity */
++	void (*set_sync_pol)(struct vpss_sync_pol);
++	/* set the PG_FRAME_SIZE register*/
++	void (*set_pg_frame_size)(struct vpss_pg_frame_size);
++	/* check and clear interrupt if occured */ 
++	int (*dma_complete_interrupt)(void);
+ };
+ 
+ /* vpss configuration */
+ struct vpss_oper_config {
+-	__iomem void *vpss_bl_regs_base;
+-	__iomem void *vpss_regs_base;
++	__iomem void *vpss_regs_base0;
++	__iomem void *vpss_regs_base1;
++	resource_size_t *vpss_regs_base2;
+ 	struct resource		*r1;
+ 	resource_size_t		len1;
+ 	struct resource		*r2;
+@@ -75,22 +107,32 @@ static struct vpss_oper_config oper_cfg;
+ /* register access routines */
+ static inline u32 bl_regr(u32 offset)
+ {
+-	return __raw_readl(oper_cfg.vpss_bl_regs_base + offset);
++	return __raw_readl(oper_cfg.vpss_regs_base0 + offset);
+ }
+ 
+ static inline void bl_regw(u32 val, u32 offset)
+ {
+-	__raw_writel(val, oper_cfg.vpss_bl_regs_base + offset);
++	__raw_writel(val, oper_cfg.vpss_regs_base0 + offset);
++}
++
++static inline u32 isp5_read(u32 offset)
++{
++	return __raw_readl(oper_cfg.vpss_regs_base0 + offset);
++}
++
++static inline void isp5_write(u32 val, u32 offset)
++{
++	__raw_writel(val, oper_cfg.vpss_regs_base0 + offset);
+ }
+ 
+ static inline u32 vpss_regr(u32 offset)
+ {
+-	return __raw_readl(oper_cfg.vpss_regs_base + offset);
++	return __raw_readl(oper_cfg.vpss_regs_base1 + offset);
+ }
+ 
+ static inline void vpss_regw(u32 val, u32 offset)
+ {
+-	__raw_writel(val, oper_cfg.vpss_regs_base + offset);
++	__raw_writel(val, oper_cfg.vpss_regs_base1 + offset);
+ }
+ 
+ static void dm355_select_ccdc_source(enum vpss_ccdc_source_sel src_sel)
+@@ -98,12 +140,54 @@ static void dm355_select_ccdc_source(enu
+ 	bl_regw(src_sel << VPSS_HSSISEL_SHIFT, DM355_VPSSBL_CCDCMUX);
+ }
+ 
++static void dm365_select_ccdc_source(enum vpss_ccdc_source_sel src_sel)
++{
++	u32 temp = isp5_read(DM365_ISP5_CCDCMUX) & ~CCD_SRC_SEL_MASK;
++
++	/* if we are using pattern generator, enable it */
++	if (src_sel == VPSS_PGLPBK || src_sel == VPSS_CCDCPG)
++		temp |= 0x08;
++
++	temp |= (src_sel << CCD_SRC_SEL_SHIFT);
++	isp5_write(temp, DM365_ISP5_CCDCMUX);
++}
++
++/**
++ *  dm365_dma_complete_interrupt - check and clear RSZ_INT_DMA 
++ *
++ *  This is called to update check and clear RSZ_INT_DMA interrupt
++ */
++int dm365_dma_complete_interrupt(void)
++{
++	u32 status;
++
++	status = isp5_read(DM365_VPSS_INTSTAT);	
++	/* Check and clear bit 15 */
++	if (status & 0x8000) {
++		status &= 0x8000;
++		isp5_write(status, DM365_VPSS_INTSTAT);
++		/* clear the interrupt */
++		return 0;
++	}
++	return 1;
++}
++
++int vpss_dma_complete_interrupt(void)
++{
++	if (!oper_cfg.hw_ops.dma_complete_interrupt)
++		return 2;
++	
++	return oper_cfg.hw_ops.dma_complete_interrupt(); 	
++}
++EXPORT_SYMBOL(vpss_dma_complete_interrupt);
++
+ int vpss_select_ccdc_source(enum vpss_ccdc_source_sel src_sel)
+ {
+ 	if (!oper_cfg.hw_ops.select_ccdc_source)
+ 		return -1;
+ 
+-	dm355_select_ccdc_source(src_sel);
++	oper_cfg.hw_ops.select_ccdc_source(src_sel);
++
+ 	return 0;
+ }
+ EXPORT_SYMBOL(vpss_select_ccdc_source);
+@@ -120,9 +204,182 @@ static int dm644x_clear_wbl_overflow(enu
+ 	mask = ~(mask << wbl_sel);
+ 	val = bl_regr(DM644X_SBL_PCR_VPSS) & mask;
+ 	bl_regw(val, DM644X_SBL_PCR_VPSS);
++
+ 	return 0;
+ }
+ 
++/**
++ *  vpss_pcr_control - common function for updating vpsssbl pcr register
++ *  @val: value to be written
++ *  @mask: bit mask
++ *  @shift: shift for mask and val 
++ *
++ *  This is called to update VPSSSBL PCR register
++ */
++static void vpss_pcr_control(int val, int mask, int shift)
++{
++	unsigned long flags;
++	u32 utemp;
++
++	spin_lock_irqsave(&oper_cfg.vpss_lock, flags);
++
++	utemp = bl_regr(DM355_VPSSBL_PCR);
++	mask <<= shift;
++	val <<= shift;
++	utemp &= (~mask);
++	utemp |= val;
++
++	bl_regw(utemp, DM355_VPSSBL_PCR);
++	spin_unlock_irqrestore(&oper_cfg.vpss_lock, flags);
++}
++
++/**
++ *  vpss_dm355_assign_wblctrl_master - select WBLCTRL/DDR2 read master 
++ *  @master: memory master
++ *
++ *  This is called to assign DDR2/WBLCTRL master. Use this in only DM355
++ */
++void vpss_dm355_assign_wblctrl_master(enum dm355_wblctrl master)
++{
++	/* WBLCTRL is bit 6 */
++	vpss_pcr_control(master, 1, 6);
++}
++EXPORT_SYMBOL(vpss_dm355_assign_wblctrl_master);
++
++/**
++ *  vpss_dm355_assign_rblctrl_master - select RBLCTRL/DDR2 read master 
++ *  @master: memory master
++ *
++ *  This is called to assign DDR2/RBLCTRL master. Use this in only DM355
++ */
++void vpss_dm355_assign_rblctrl_master(enum dm355_rblctrl master)
++{
++	/* RBLCTRL is bit 5 & 4 */
++	vpss_pcr_control(master, 3, 5);
++}
++EXPORT_SYMBOL(vpss_dm355_assign_rblctrl_master);
++
++/**
++ *  vpss_memory_control - common function for updating memory
++ *  control register
++ *  @en: enable/disable
++ *  @mask: bit mask
++ *
++ *  This is called to update memory control register
++ */
++static void vpss_mem_control(int en, u32 mask)
++{
++	unsigned long flags;
++	u32 utemp;
++
++	spin_lock_irqsave(&oper_cfg.vpss_lock, flags);
++	utemp = bl_regr(DM355_VPSSBL_MEMCTRL);
++	if (en)
++		utemp |= mask;
++	else
++		utemp &= (~mask);
++
++	bl_regw(utemp, DM355_VPSSBL_MEMCTRL);
++	spin_unlock_irqrestore(&oper_cfg.vpss_lock, flags);
++}
++
++/**
++ *  vpss_dm355_assign_dfc_memory_master - select dfc memory by IPIPE/CCDC
++ *  @master: memory master
++ *
++ *  This is called to assign dfc memory mastership to IPIPE or CCDC.
++ *  Use this in only DM355
++ */
++void vpss_dm355_assign_dfc_memory_master(enum dm355_dfc_mem_sel master)
++{
++	if (master == DM355_DFC_MEM_IPIPE)
++		vpss_mem_control(0, 0x1);
++	else
++		vpss_mem_control(1, 0x1);
++}
++EXPORT_SYMBOL(vpss_dm355_assign_dfc_memory_master);
++
++/**
++ *  vpss_dm355_ipipe_enable_any_address - IPIPE can use any address type 
++ *  @en: enable/disable non-aligned buffer address use.
++ *
++ *  This is called to allow IPIPE to use non-aligned buffer address.
++ *  Applicable only to DM355.
++ */
++void vpss_dm355_ipipe_enable_any_address(int en)
++{
++	if (en)
++		vpss_mem_control(1, 0x4);
++	else
++		vpss_mem_control(0, 0x4);
++}
++EXPORT_SYMBOL(vpss_dm355_ipipe_enable_any_address);
++
++/*
++ *  vpss_dm355_assign_int_memory_master - assign internal module memory 
++ *  @master: master for internal memory
++ *
++ *  This function will select the module that gets access to internal memory.
++ *  Choice is either IPIPE or CFALD. Applicable only on DM355
++ */
++void vpss_dm355_assign_int_memory_master(enum dm355_int_mem_sel master)
++{
++	if (master == DM355_INT_MEM_IPIPE)
++		vpss_mem_control(0, 0x2);
++	else
++		vpss_mem_control(1, 0x2);
++
++}
++EXPORT_SYMBOL(vpss_dm355_assign_int_memory_master);
++
++#if 0
++static void dm365_enable_irq(void)
++{
++	u32 current_val = isp5_read(DM365_VPSS_INTSEL1);
++	/*just enable INTSEL0 and INTSEL1 and leave everything else as is*/
++	current_val &= ~(CCD_INT_SEL_MASK);
++	current_val |= BIT_MASK(8);
++	isp5_write(current_val, DM365_VPSS_INTSEL1);
++}
++#endif
++
++void dm365_set_sync_pol(struct vpss_sync_pol sync)
++{
++	int val = 0;
++	val = isp5_read(DM365_ISP5_CCDCMUX);
++
++	val |= (sync.ccdpg_hdpol << DM365_CCDC_PG_HD_POL_SHIFT);
++	val |= (sync.ccdpg_vdpol << DM365_CCDC_PG_VD_POL_SHIFT);
++
++	isp5_write(val, DM365_ISP5_CCDCMUX);
++}
++
++void vpss_set_sync_pol(struct vpss_sync_pol sync)
++{
++	if (!oper_cfg.hw_ops.set_sync_pol)
++		return;
++
++	oper_cfg.hw_ops.set_sync_pol(sync);
++}
++EXPORT_SYMBOL(vpss_set_sync_pol);
++
++void dm365_set_pg_frame_size(struct vpss_pg_frame_size frame_size)
++{
++	int current_reg = ((frame_size.hlpfr >> 1) - 1) << 16;
++
++	current_reg |= (frame_size.pplen - 1);
++	isp5_write(current_reg, DM365_ISP5_PG_FRAME_SIZE);
++}
++
++void vpss_set_pg_frame_size(struct vpss_pg_frame_size frame_size)
++{
++	if (!oper_cfg.hw_ops.set_pg_frame_size)
++		return;
++
++	oper_cfg.hw_ops.set_pg_frame_size(frame_size);
++}
++EXPORT_SYMBOL(vpss_set_pg_frame_size);
++
+ int vpss_clear_wbl_overflow(enum vpss_wbl_sel wbl_sel)
+ {
+ 	if (!oper_cfg.hw_ops.clear_wbl_overflow)
+@@ -132,7 +389,7 @@ int vpss_clear_wbl_overflow(enum vpss_wb
+ }
+ EXPORT_SYMBOL(vpss_clear_wbl_overflow);
+ 
+-/*
++/**
+  *  dm355_enable_clock - Enable VPSS Clock
+  *  @clock_sel: CLock to be enabled/disabled
+  *  @en: enable/disable flag
+@@ -178,6 +435,93 @@ static int dm355_enable_clock(enum vpss_
+ 
+ 	vpss_regw(utemp, DM355_VPSSCLK_CLKCTRL);
+ 	spin_unlock_irqrestore(&oper_cfg.vpss_lock, flags);
++
++	return 0;
++}
++
++static int dm365_enable_clock(enum vpss_clock_sel clock_sel, int en)
++{
++	unsigned long flags;
++	u32 utemp, mask = 0x1, shift = 0, offset = DM365_PCCR;
++	u32 (*read)(u32 offset) = isp5_read;
++	void(*write)(u32 val, u32 offset) = isp5_write;
++
++	switch (clock_sel) {
++	case VPSS_BL_CLOCK:
++		break;
++	case VPSS_CCDC_CLOCK:
++		shift = 1;
++		break;
++	case VPSS_H3A_CLOCK:
++		shift = 2;
++		break;
++	case VPSS_RSZ_CLOCK:
++		shift = 3;
++		break;
++	case VPSS_IPIPE_CLOCK:
++		shift = 4;
++		break;
++	case VPSS_IPIPEIF_CLOCK:
++		shift = 5;
++		break;
++	case VPSS_PCLK_INTERNAL:
++		shift = 6;
++		break;
++	case VPSS_PSYNC_CLOCK_SEL:
++		shift = 7;
++		break;
++	case VPSS_VPBE_CLOCK:
++		read = vpss_regr;
++		write = vpss_regw;
++		offset = DM365_VPBE_CLK_CTRL;
++		break;
++	case VPSS_VENC_CLOCK_SEL:
++		shift = 2;
++		read = vpss_regr;
++		write = vpss_regw;
++		offset = DM365_VPBE_CLK_CTRL;
++		break;
++	case VPSS_LDC_CLOCK:
++		shift = 3;
++		read = vpss_regr;
++		write = vpss_regw;
++		offset = DM365_VPBE_CLK_CTRL;
++		break;
++	case VPSS_FDIF_CLOCK:
++		shift = 4;
++		read = vpss_regr;
++		write = vpss_regw;
++		offset = DM365_VPBE_CLK_CTRL;
++		break;
++	case VPSS_OSD_CLOCK_SEL:
++		shift = 6;
++		read = vpss_regr;
++		write = vpss_regw;
++		offset = DM365_VPBE_CLK_CTRL;
++		break;
++	case VPSS_LDC_CLOCK_SEL:
++		shift = 7;
++		read = vpss_regr;
++		write = vpss_regw;
++		offset = DM365_VPBE_CLK_CTRL;
++		break;
++	default:
++		printk(KERN_ERR "dm365_enable_clock: Invalid selector: %d\n",
++		       clock_sel);
++		return -1;
++	}
++
++	spin_lock_irqsave(&oper_cfg.vpss_lock, flags);
++	utemp = read(offset);
++	if (!en) {
++		mask = ~mask;
++		utemp &= (mask << shift);
++	} else
++		utemp |= (mask << shift);
++
++	write(utemp, offset);
++	spin_unlock_irqrestore(&oper_cfg.vpss_lock, flags);
++
+ 	return 0;
+ }
+ 
+@@ -192,7 +536,7 @@ EXPORT_SYMBOL(vpss_enable_clock);
+ 
+ static int __init vpss_probe(struct platform_device *pdev)
+ {
+-	int status, dm355 = 0;
++	int status, dm355 = 0, dm365 = 0;
+ 
+ 	if (!pdev->dev.platform_data) {
+ 		dev_err(&pdev->dev, "no platform data\n");
+@@ -202,6 +546,8 @@ static int __init vpss_probe(struct plat
+ 
+ 	if (!strcmp(oper_cfg.vpss_name, "dm355_vpss"))
+ 		dm355 = 1;
++	else if (!strcmp(oper_cfg.vpss_name, "dm365_vpss"))
++		dm365 = 1;
+ 	else if (strcmp(oper_cfg.vpss_name, "dm644x_vpss")) {
+ 		dev_err(&pdev->dev, "vpss driver not supported on"
+ 			" this platform\n");
+@@ -220,13 +566,13 @@ static int __init vpss_probe(struct plat
+ 	if (!oper_cfg.r1)
+ 		return -EBUSY;
+ 
+-	oper_cfg.vpss_bl_regs_base = ioremap(oper_cfg.r1->start, oper_cfg.len1);
+-	if (!oper_cfg.vpss_bl_regs_base) {
++	oper_cfg.vpss_regs_base0 = ioremap(oper_cfg.r1->start, oper_cfg.len1);
++	if (!oper_cfg.vpss_regs_base0) {
+ 		status = -EBUSY;
+ 		goto fail1;
+ 	}
+ 
+-	if (dm355) {
++	if (dm355 || dm365) {
+ 		oper_cfg.r2 = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+ 		if (!oper_cfg.r2) {
+ 			status = -ENOENT;
+@@ -241,9 +587,9 @@ static int __init vpss_probe(struct plat
+ 			goto fail2;
+ 		}
+ 
+-		oper_cfg.vpss_regs_base = ioremap(oper_cfg.r2->start,
++		oper_cfg.vpss_regs_base1 = ioremap(oper_cfg.r2->start,
+ 						  oper_cfg.len2);
+-		if (!oper_cfg.vpss_regs_base) {
++		if (!oper_cfg.vpss_regs_base1) {
+ 			status = -EBUSY;
+ 			goto fail3;
+ 		}
+@@ -252,9 +598,42 @@ static int __init vpss_probe(struct plat
+ 	if (dm355) {
+ 		oper_cfg.hw_ops.enable_clock = dm355_enable_clock;
+ 		oper_cfg.hw_ops.select_ccdc_source = dm355_select_ccdc_source;
+-	} else
++	} else if (dm365) {
++		oper_cfg.hw_ops.enable_clock = dm365_enable_clock;
++		oper_cfg.hw_ops.select_ccdc_source = dm365_select_ccdc_source;
++		oper_cfg.hw_ops.set_sync_pol = dm365_set_sync_pol;
++		oper_cfg.hw_ops.set_pg_frame_size = dm365_set_pg_frame_size;
++		oper_cfg.hw_ops.dma_complete_interrupt =
++				dm365_dma_complete_interrupt;
++
++	} else if (!strcmp(oper_cfg.vpss_name, "dm644x_vpss"))
+ 		oper_cfg.hw_ops.clear_wbl_overflow = dm644x_clear_wbl_overflow;
+ 
++	if (dm355) {
++		/*
++		 * These values being written to INTSEL and EVTSEL
++		 * registers match those in LSP 2.10
++		 */
++		bl_regw(0xff83ff10, 0x10);
++		bl_regw(0x7b3c0004, 0x14);
++	}
++	if (dm365) {
++		/**
++		 * These values being written to INTSEL and EVTSEL
++		 * registers match those in LSP 2.10
++		 */
++		isp5_write((isp5_read(0x4) | 0x0000007f), 0x4);
++		isp5_write((isp5_read(0x8) | 0x00000002), 0x8);
++		/* INT0, INT1, AF */
++		isp5_write((isp5_read(0x10) | 0x0b1f0100), 0x10);
++		/* AEW, RSZ_INT_DMA */
++		isp5_write((isp5_read(0x14) | 0x1f0a0f1f), 0x14);
++		/* VENC */
++		isp5_write((isp5_read(0x18) | 0x00000015), 0x18);
++		/* No event selected */
++		isp5_write((isp5_read(0x1c) | 0x00000000), 0x1c);
++	}
++
+ 	spin_lock_init(&oper_cfg.vpss_lock);
+ 	dev_info(&pdev->dev, "%s vpss probe success\n", oper_cfg.vpss_name);
+ 	return 0;
+@@ -262,7 +641,7 @@ static int __init vpss_probe(struct plat
+ fail3:
+ 	release_mem_region(oper_cfg.r2->start, oper_cfg.len2);
+ fail2:
+-	iounmap(oper_cfg.vpss_bl_regs_base);
++	iounmap(oper_cfg.vpss_regs_base0);
+ fail1:
+ 	release_mem_region(oper_cfg.r1->start, oper_cfg.len1);
+ 	return status;
+@@ -270,12 +649,14 @@ fail1:
+ 
+ static int vpss_remove(struct platform_device *pdev)
+ {
+-	iounmap(oper_cfg.vpss_bl_regs_base);
++	iounmap(oper_cfg.vpss_regs_base0);
+ 	release_mem_region(oper_cfg.r1->start, oper_cfg.len1);
+-	if (!strcmp(oper_cfg.vpss_name, "dm355_vpss")) {
+-		iounmap(oper_cfg.vpss_regs_base);
++	if (!strcmp(oper_cfg.vpss_name, "dm355_vpss") ||
++	    !strcmp(oper_cfg.vpss_name, "dm365_vpss")) {
++		iounmap(oper_cfg.vpss_regs_base1);
+ 		release_mem_region(oper_cfg.r2->start, oper_cfg.len2);
+ 	}
++
+ 	return 0;
+ }
+ 
+@@ -290,11 +671,19 @@ static struct platform_driver vpss_drive
+ 
+ static void vpss_exit(void)
+ {
++	iounmap(oper_cfg.vpss_regs_base2);
++	release_mem_region(*oper_cfg.vpss_regs_base2, 4);
+ 	platform_driver_unregister(&vpss_driver);
+ }
+ 
+ static int __init vpss_init(void)
+ {
++	if (request_mem_region(VPSS_CLK_CTRL, 4, "vpss_clock_control")) {
++		oper_cfg.vpss_regs_base2 = ioremap(VPSS_CLK_CTRL, 4);
++		__raw_writel(0x18, oper_cfg.vpss_regs_base2);
++	} else
++		return -EBUSY;
++
+ 	return platform_driver_register(&vpss_driver);
+ }
+ subsys_initcall(vpss_init);
+--- /dev/null
++++ b/include/linux/davinci_vdce.h
+@@ -0,0 +1,457 @@
++/* *
++ * Copyright (C) 2007 Texas Instruments	Inc
++ *
++ * This	program	is free	software; you can redistribute it and/or modify
++ * it under the	terms of the GNU General Public	License	as published by
++ * the Free Software Foundation; either	version	2 of the License, or
++ * (at your option any)	later version.
++ * This	program	is distributed in the hope that	it will	be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not,write to the	Free Software
++ * Foundation, Inc., 59	Temple Place, Suite 330, Boston, MA  02111-1307	 USA
++ */
++/* davinci_vdce.h	file */
++
++#ifndef	DAVINCI_VDCE_H
++#define	DAVINCI_VDCE_H
++#ifdef __KERNEL__
++/* include Linux files */
++#include <linux/interrupt.h>
++#include <linux/spinlock.h>
++#endif
++//#include <mach/davinci_vdce_hw.h>
++#define	  VDCE_IOC_BASE			   'G'
++#define	  VDCE_IOC_MAXNR			    9
++/* Ioctl options which are to be passed	while calling the ioctl	*/
++#define	VDCE_SET_PARAMS		 _IOWR(VDCE_IOC_BASE, 1, vdce_params_t)
++#define	VDCE_GET_PARAMS		 _IOR(VDCE_IOC_BASE, 2, vdce_params_t)
++#define	VDCE_START		 _IOWR(VDCE_IOC_BASE, 3, vdce_address_start_t)
++#define	VDCE_REQBUF		 _IOWR(VDCE_IOC_BASE, 4, vdce_reqbufs_t)
++#define	VDCE_QUERYBUF		 _IOWR(VDCE_IOC_BASE, 5, vdce_buffer_t)
++#define VDCE_GET_DEFAULT	 _IOWR(VDCE_IOC_BASE, 6, vdce_params_t)
++
++#define	VDCE_MAX_PRIORITY		  5
++#define	VDCE_MIN_PRIORITY		  0
++#define	VDCE_DEFAULT_PRIORITY		  0
++#define	MAX_BUFFERS			  8
++
++#define MAX_BLEND_TABLE 		  (4)
++
++#ifdef __KERNEL__
++#define	MAX_RSZ_INTENSITY		  128
++#define	MIN_RSZ_MAG_RATIO		  256
++#define	MAX_RSZ_MAG_RATIO		  2048
++#define	DRIVER_NAME			  "VDCE"
++#define	MAX_CHANNELS			  16
++#define	FIRSTENTRY			  0
++#define	SECONDENTRY			  1
++#define	EMPTY				  0
++#define	FREE_BUFFER			  0
++#define CHECK_MODE_RANGE(mode, limit)    ((mode < 0 || mode > limit)?1:0)
++#define GET_DIVIDE_FACTOR(format)	 ((format == 0)?3:4)
++#define GET_CHROMA_DIVIDE_FACTOR(format) ((format == 0)?4:2)
++#define GET_VAL(reg, mask, shift)
++#define RSZ_ENABLE_MASK			0x1
++#define BLEND_ENABLE_MASK		0x2
++#define RMAP_ENABLE_MASK		0x4
++#define CCV_ENABLE_MASK			0x8
++#endif
++
++/* enum	for selected VDCE mode */
++typedef enum vdce_mode_operation {
++	VDCE_OPERATION_PRE_CODECMODE = 0,/* set pre codec mode */
++	VDCE_OPERATION_POST_CODECMODE,	/* set post codec mode */
++	VDCE_OPERATION_TRANS_CODECMODE,	/* set trans codec mode */
++	VDCE_OPERATION_EDGE_PADDING,	/* enable edge padding */
++	VDCE_OPERATION_RESIZING,	/* For doing chrominance conversion */
++	VDCE_OPERATION_CHROMINANCE_CONVERSION,	/* For doing resizing */
++	VDCE_OPERATION_RANGE_MAPPING,	/* For doing range mapping */
++	VDCE_OPERATION_BLENDING		/* for doing blending */
++} vdce_mode_operation_t;
++
++/* enum	for enable disable status */
++typedef enum vdce_status {
++	VDCE_FEATURE_DISABLE = 0,	/* Suggest  disable status */
++	VDCE_FEATURE_ENABLE		/* Suggest Enable status   */
++} vdce_status_t;
++
++/* enum	for image_type */
++typedef enum vdce_image_type {
++	VDCE_BUF_IN = 0,	/* Suggest  buffer is of output type */
++	VDCE_BUF_OUT,		/* Suggest  buffer is of input type */
++	VDCE_BUF_BMP		/* Suggest  buffer is of bitmap type */
++} vdce_image_type_t;
++
++/* enum	to enable disable luma/chroma processing */
++typedef enum vdce_proc_control {
++	VDCE_LUMA_ENABLE = 0,	/* suggest luma processing is enable  */
++	VDCE_CHROMA_ENABLE,	/* suggest chroma processing is enable  */
++	VDCE_LUMA_CHROMA_ENABLE	/* suggest both processing is enable  */
++} vdce_proc_control_t;
++
++/* enum	to enable disable field	status */
++typedef enum vdce_field_status {
++	VDCE_TOP_ENABLE = 0,/* suggest top field processing is enable  */
++	VDCE_BOTTOM_ENABLE,/* suggest bottom field processing is enable */
++	VDCE_TOP_BOT_ENABLE/* suggest both processing is enable  */
++} vdce_field_status_t;
++
++/* enum	for codec mode */
++typedef enum vdce_codec_mode {
++	VDCE_CODECMODE_MPEG2_MPEG4 = 0,	/* suggest mpeg2 is selected */
++	VDCE_CODECMODE_MPEG1		/* suggest mpeg1 is selected */
++} vdce_codec_mode_t;
++
++/* ALF mode for	resizing */
++typedef enum vdce_alfmode {
++	VDCE_ALFMODE_AUTOMATIC = 0,	/* tap-4 */
++	VDCE_ALFMODE_MANUAL		/* tap linear */
++} vdce_alfmode_t;
++
++/* type	of algo*/
++typedef enum vdce_algo_type {
++	VDCE_ALGO_TAP_4CUBIC_CONVOLUTION = 0,	/* cubic convolution */
++	VDCE_ALGO_TAP_4LINEAR_INTERPOLATION	/* linear interpolation */
++} vdce_algo_type_t;
++
++/* for mode */
++typedef enum vdce_io_mode {
++	VDCE_FIELD_MODE = 0,	/* Indicate that field mode */
++	VDCE_FRAME_MODE		/* Indicate that frame mode */
++} vdce_io_mode_t;
++
++/* hardware and	channel	status */
++typedef enum vdce_processing_status {
++	VDCE_CHAN_FREE = 0,		/* channel free */
++	VDCE_CHAN_BUSY,			/* channel busy */
++	VDCE_CHAN_PENDING,		/* Request pending */
++	VDCE_CHAN_UNINITIALISED,	/* Parameters uninitialised */
++	VDCE_CHAN_PARAMS_INITIALISED,	/* Parameters initialised */
++} vdce_processing_status_t;
++
++/* processing mode of image */
++typedef enum vdce_processing_mode {
++	VDCE_INTERLACED = 0,		/* interlaced mode */
++	VDCE_PROGRESSIVE		/* progressive mode */
++} vdce_processing_mode_t;
++
++/* image format	*/
++typedef enum vdce_image_fmt {
++	VDCE_IMAGE_FMT_420 = 0,	    /* 4:2:0 image format */
++	VDCE_IMAGE_FMT_422 = 1	    /* 4:2:2 image format */
++} vdce_image_fmt_t;
++
++/*CCV operation	mode */
++typedef enum vdce_ccv_mode {
++	VDCE_CCV_MODE_422_420 = 0,	/* 4:2:2 to 4:2:0 */
++	VDCE_CCV_MODE_420_422,		/* 4:2:0 to 4:2:2 */
++	VDCE_CCV_MODE_420_420		/* 4:2:0 to 4:2:0 */
++} vdce_ccv_mode_t;
++
++/*Resize operation mode	*/
++typedef enum vdce_rsz_mode {
++	VDCE_MODE_420 = 0,	/* 4:2:2  */
++	VDCE_MODE_422,		/* 4:2:0 */
++} vdce_rsz_blend_mode_t;
++
++/* ---------------Interface Data structures-----------------------------------*/
++/* Structure to	configure the resize parameters	*/
++typedef struct vdce_rsz_params {
++	vdce_rsz_blend_mode_t rsz_mode;	/* Value will not be used in native */
++	/*Mode. It will be used for stanalone */
++	/*resizing only */
++	vdce_codec_mode_t rsz_op_mode;
++	vdce_algo_type_t hrsz_mode;/* To suggest horizontal resizing mode */
++					/*   eg convolution */
++	vdce_algo_type_t vrsz_mode;	/* To suggest Vertical resizing mode */
++					/* eg convolution */
++	vdce_status_t hrsz_alf_enable;	/* Suggest horizontal anti alias */
++					/*  filter is on */
++	vdce_status_t vrsz_alf_enable;	/* Suggest vertical anti alias filter */
++					/* is on */
++	vdce_alfmode_t hrsz_alf_mode;	/* Suggest the anti alias filter mode */
++	unsigned char hrsz_alf_intensity;/* Intensity for coefficients calc */
++} vdce_rsz_params_t;
++
++/* Structure to	configure the chrominance conversion parameters	*/
++typedef struct vdce_ccv_params {
++	vdce_ccv_mode_t conversion_type; /* Value will not be used in native */
++					/*Mode. It will be used for stanalone */
++					/*CCV only */
++	/* Below both parameters will be used only in case for trans codec */
++	vdce_codec_mode_t codec_mode_in;/* Type of input of codec conversion */
++					/*eg mpeg1 or other */
++	vdce_codec_mode_t codec_mode_out;/*Type of output of codec conversion */
++					/*eg mpeg2 or other */
++	vdce_algo_type_t hccv_type;	/* Chrominance conversion functional */
++					/*type selection bit (for horz) */
++	vdce_algo_type_t vccv_type;	/* Chrominance conversion functional */
++					/* type selection bit(for vert) */
++} vdce_ccv_params_t;
++
++/* Structure to	configure the range maping parameters */
++typedef struct vdce_rmap_params {
++
++	unsigned char coeff_y;		/* coeffcients of range mapping */
++					/*for Y component */
++	vdce_status_t rmap_yenable;	/* Suggest that luminance range */
++					/*mapping is enable */
++	unsigned char coeff_c;		/* coeffcients of range mapping for */
++					/* chroma component */
++	vdce_status_t rmap_cenable;	/* Suggest that chrominace range */
++					/* mapping is enable */
++} vdce_rmap_params_t;
++
++/* Structure to	configure the blending parameters */
++typedef struct blend_table {
++
++	unsigned char blend_cr;	/* blend value for cr component */
++	unsigned char blend_cb;	/* blend value for cb component */
++	unsigned char blend_y;	/* blend value for y component */
++	unsigned char blend_value;	/* Blend factor */
++} blend_table_t;
++
++typedef struct vdce_blend_params {
++	vdce_rsz_blend_mode_t blend_mode;
++	blend_table_t bld_lut[MAX_BLEND_TABLE];	/* 4 bitmap defined for blend */
++} vdce_blend_params_t;
++
++/* Structure to	configure edge padding parameters */
++typedef struct vdce_epad_params {
++
++	unsigned char vext_chroma;	/* Vertical extension value for */
++					/* chroma component */
++	unsigned char hext_chroma;	/* horizontal extension value for */
++					/*chroma component */
++	unsigned char vext_luma;	/* Vertical extension value for */
++					/* luma component */
++	unsigned char hext_luma;	/* horizontal extension value for */
++					/*chroma component */
++} vdce_epad_params_t;
++
++/* Structure to	configure input	output format and sizes	*/
++typedef struct vdce_common_params {
++
++	vdce_processing_mode_t src_processing_mode;/* source processing mode */
++						/*interlaced or progressive */
++	vdce_io_mode_t src_mode;	/* src mode field or frame  */
++	vdce_io_mode_t res_mode;	/* res mode field or frame  */
++	vdce_io_mode_t src_bmp_mode;	/* bmp mode field or frame */
++	vdce_proc_control_t proc_control;	/* Luminace processing */
++						/*enable or not */
++	vdce_field_status_t field_status;	/* Top field enable or not */
++
++	unsigned short src_hsz_luminance;/* input horizontal size for */
++					/*luminance component */
++	unsigned short src_vsz_luminance;/* input vertical size for */
++					/*luminance component */
++	unsigned short bmp_vsize;	/* input vertical size for */
++					/*bitmap component */
++	unsigned short bmp_hsize;	/* input horizontal size for */
++					/* bitmap component */
++	unsigned char src_hsp_luminance;/*horizontal starting position */
++					/* for luminance */
++	unsigned char src_vsp_luminance;/* vertical starting position */
++					/* for luminance */
++	unsigned char bmp_hsp_bitmap;	/* hrz starting position for */
++					/* bitmap */
++	unsigned char res_hsp_luminance;/* Hrz starting position for */
++					/*luminance component for res */
++	unsigned char res_vsp_luminance;/* Vertical starting position for */
++					/*luminance component for res */
++	unsigned short dst_hsz_luminance;/* Hrz starting size for */
++					/*luminance component for res */
++	unsigned short dst_vsz_luminance;/* Vertical size for */
++					/*   luminance */
++					/*component for result */
++	unsigned short res_hsp_bitmap;	/* Horizontal starting pos */
++					/*for bitmap component */
++	unsigned short res_vsp_bitmap;	/* vertical starting position */
++					/* for bitmap component */
++	unsigned short prcs_unit_value;/* Hold the prcs value by app */
++} vdce_common_params_t;
++
++/* precodec parameters configuration structure */
++typedef struct vdce_precodec_params {
++	vdce_rsz_params_t rsz_params;
++	vdce_ccv_params_t ccv_params;
++} vdce_precodec_params_t;
++
++/* postcodec parameters	configuration structure	*/
++typedef struct vdce_postcodec_params {
++	vdce_rsz_params_t rsz_params;
++	vdce_rmap_params_t rmap_params;
++	vdce_blend_params_t blend_params;
++	vdce_ccv_params_t ccv_params;
++} vdce_postcodec_params_t;
++
++/* transcodec parameters configuration structure */
++typedef struct vdce_transcodec_params {
++	vdce_rsz_params_t rsz_params;
++	vdce_rmap_params_t rmap_params;
++	vdce_blend_params_t blend_params;
++	vdce_epad_params_t epad_params;
++	vdce_ccv_params_t ccv_params;
++} vdce_transcodec_params_t;
++
++/* Passed for setting VDCE parameters */
++typedef struct vdce_params {
++	vdce_mode_operation_t vdce_mode;
++	/* Bits position for enabling the various sub-modes */
++	/* 1 bit defienes resizing 2 blending 3 range mapping and 4 ccv */
++	unsigned char modes_control;
++	vdce_common_params_t common_params;
++	union {
++		vdce_precodec_params_t precodec_params;
++		vdce_postcodec_params_t postcodec_params;
++		vdce_transcodec_params_t transcodec_params;
++		vdce_epad_params_t epad_params;
++		vdce_rsz_params_t rsz_params;
++		vdce_rmap_params_t rmap_params;
++		vdce_blend_params_t blend_params;
++		vdce_ccv_params_t ccv_params;
++	} vdce_mode_params;
++} vdce_params_t;
++
++/* status parameters structure */
++typedef struct vdce_hw_status {
++	vdce_processing_status_t chan_status;	/* get channel status */
++} vdce_hw_status_t;
++
++/* to allocate the memory*/
++typedef struct vdce_reqbufs {
++
++	vdce_image_type_t buf_type;	/* typeof frame buffer */
++	int count;		/* number of frame buffers to be allocated */
++	int num_lines;		/* Number of lines i.e.vertical pitch for */
++				/* luma componenet */
++	int bytes_per_line;	/* Number of lines i.e.horizontal pitch for */
++				/* luma componenet */
++	vdce_image_fmt_t image_type;	/* Input image format */
++} vdce_reqbufs_t;
++
++/* assessed for	quering	the buffer to get physical address*/
++typedef struct vdce_buffer {
++
++	int index;		/* buffer index number, 0 -> N-1 */
++	vdce_image_type_t buf_type;/* buffer type, input or output */
++	union {
++	unsigned int offset;	/* physical     address of the buffer, */
++	unsigned int virt_ptr;
++	};/* used in the mmap() system call */
++	int size;		/* size */
++} vdce_buffer_t;
++
++/* structure to	be passed while	VDCE oparation */
++typedef struct vdce_address_start {
++	/* 0 is input buffer 1 is output and 2 in bitmap buffer */
++	vdce_buffer_t buffers[3];
++	/* Horizontal and vertical pitch */
++	unsigned int src_horz_pitch;
++	unsigned int res_horz_pitch;
++	unsigned int bmp_pitch;
++} vdce_address_start_t;
++
++#ifdef __KERNEL__
++/* ---------------Driver Structures-------------------------------------------*/
++/* enum for suggesting num of passes required */
++typedef enum vdce_num_pass {
++	VDCE_SINGLE_PASS = 1,	/* VDCE driver will operate in single pass */
++	VDCE_MULTIPASS	/* VDCE driver will operate in Multipass pass */
++} vdce_num_pass_t;
++
++/* enum for suggesting channel mode */
++typedef enum vdce_mode {
++	VDCE_MODE_BLOCKING = 0,	/* channel opeend in blocking mode */
++	VDCE_MODE_NON_BLOCKING	/* channel opened in non-blocking */
++} vdce_mode_t;
++
++typedef enum vdce_start_status {
++	VDCE_PASS1_STARTED = 0,
++	VDCE_PASS2_STARTED,
++	VDCE_COMPLETED
++} vdce_start_status_t;
++
++/* Global structure in driver */
++typedef struct device_params {
++	int module_usage_count;	/* Keeps track of number of open chan */
++	struct completion sem_isr;	/* sem to indicate the completion */
++					/*in case for blocking call */
++	/*struct semaphore array_sem;*/	/* sem to protect array entry */
++	spinlock_t irqlock;
++	void *inter_buffer;	/* Address for inter buffer */
++	unsigned int inter_size; /* Size of intermediate buffer */
++	struct completion edma_sem;
++	struct completion device_access;
++} device_params_t;
++typedef struct vdce_buffer_info {
++	void *buffers[MAX_BUFFERS];
++	int size;
++	int num_allocated;
++} vdce_buffer_info_t;
++/* Channel specific device structure */
++typedef struct channel_config {
++	struct vdce_hw_config register_config[2];/* Instance of register */
++						/* mapping structure */
++	vdce_num_pass_t num_pass;		/* Single pass or multipass */
++	vdce_buffer_info_t vdce_buffer[3];
++	vdce_params_t get_params;	/*Instance for parameters send */
++						/* by application */
++	vdce_params_t get_params1;
++
++	vdce_mode_operation_t mode_state;	/* VDCE channel mode */
++	vdce_mode_t channel_mode;		/* Indiacte the blocking or */
++						/* non blocking */
++	int luma_chroma_phased;		/* if 1 indicates luma is phased */
++	vdce_processing_status_t status;	/* Indicates channel free/used*/
++	vdce_start_status_t vdce_complete;	/* To keep track of isr */
++	vdce_image_fmt_t image_type_out;	/* Input image type */
++	vdce_image_fmt_t image_type_in;		/* Output image type */
++	unsigned int edma_operation;		/* Keeps track whether edma
++						   operation is required for
++						   this channel. */
++
++} channel_config_t;
++
++typedef struct vdce_debug_info {
++	/* keeps track of number of interrupts */
++	int vdce_interrupt_count;
++	/* keeps track of number of non-block calls */
++	int vdce_nonblock_count;
++	/* keeps track of number of blocking calls */
++	int vdce_block_count;
++} vdce_debug_info_t;
++
++/* ---------------Function definition-----------------------------------------*/
++int malloc_buff(vdce_reqbufs_t *, channel_config_t *);
++int get_buf_address(vdce_buffer_t *, channel_config_t *);
++int free_buff(channel_config_t *);
++int vdce_set_multipass_address(vdce_address_start_t *, channel_config_t *);
++int vdce_set_address(vdce_address_start_t *, channel_config_t *,
++						 int, u32, u32, u32);
++int vdce_start(vdce_address_start_t *, channel_config_t *);
++int add_to_array(channel_config_t *);
++int delete_from_array(void);
++void process_bottomhalf(unsigned long);
++int vdce_get_default(vdce_params_t *);
++int vdce_check_common_params(vdce_params_t *);
++int vdce_set_size_fmt(vdce_common_params_t *, channel_config_t *, int);
++int vdce_set_rszparams(vdce_params_t *, channel_config_t *,
++		     vdce_mode_operation_t, int);
++int vdce_set_epadparams(vdce_epad_params_t *, channel_config_t *, int);
++int vdce_set_ccvparams(vdce_ccv_params_t *, channel_config_t *, int, int);
++int vdce_set_blendparams(vdce_blend_params_t *, channel_config_t *, int, int);
++int vdce_set_rmapparams(vdce_rmap_params_t *, channel_config_t *, int);
++int vdce_set_params(vdce_params_t *, channel_config_t *);
++int vdce_get_params(vdce_params_t *, channel_config_t *);
++int vdce_set_priority(int, channel_config_t *);
++int vdce_get_priority(int *, channel_config_t *);
++int vdce_get_status(vdce_hw_status_t *, channel_config_t *);
++int free_num_buffers(int *, unsigned long, unsigned long);
++irqreturn_t vdce_isr(int, void *);
++#endif
++#endif
+--- a/arch/arm/mach-davinci/include/mach/irqs.h
++++ b/arch/arm/mach-davinci/include/mach/irqs.h
+@@ -217,6 +217,7 @@
+ #define IRQ_DM365_SDIOINT0	23
+ #define IRQ_DM365_MMCINT1	27
+ #define IRQ_DM365_PWMINT3	28
++#define IRQ_DM365_RTCINT	29
+ #define IRQ_DM365_SDIOINT1	31
+ #define IRQ_DM365_SPIINT0_0	42
+ #define IRQ_DM365_SPIINT3_0	43
+--- /dev/null
++++ b/include/media/davinci/imp_resizer.h
+@@ -0,0 +1,68 @@
++/*
++ * Copyright (C) 2008-2009 Texas Instruments Inc
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
++ */
++
++/************************************************************************
++ * Description
++ * -----------
++ * Resizer device is used for upscale or downscale the YCbCr image to
++ * desired resolution.
++ * The channel operates in 2 modes :-
++ *   1. continuous mode. In this mode, the resizer modules are chained in
++ *      the data path from ISIF/CCDC and does resizing on the fly.
++ *      No IO allowed in this mode.
++ *   2. Single shot mode. In this mode, modules are configured to resize
++ *      the image stored in SDRAM.  Multiple IO instances are allowed in
++ *      this mode and each IO instance is allocated a logical channel.
++ *
++ * device name : davinci_resizer
++ ************************************************************************/
++
++#ifndef _IMP_RESIZER_H
++#define _IMP_RESIZER_H
++
++#include <linux/ioctl.h>
++#include <media/davinci/imp_common.h>
++
++/* ioctls definitions for resizer operations */
++#define RSZ_IOC_BASE		'R'
++#define RSZ_REQBUF		_IOWR(RSZ_IOC_BASE, 1, struct imp_reqbufs)
++#define RSZ_QUERYBUF		_IOWR(RSZ_IOC_BASE, 2, struct imp_buffer)
++#define RSZ_RESIZE		_IOWR(RSZ_IOC_BASE, 3, struct imp_convert)
++#define RSZ_S_CONFIG		_IOWR(RSZ_IOC_BASE, 4,\
++					struct rsz_channel_config)
++#define RSZ_G_CONFIG		_IOWR(RSZ_IOC_BASE, 5,\
++					struct rsz_channel_config)
++#define RSZ_S_OPER_MODE		_IOW(RSZ_IOC_BASE, 6, unsigned long)
++#define RSZ_G_OPER_MODE		_IOR(RSZ_IOC_BASE, 7, unsigned long)
++#define RSZ_G_PRIORITY		_IOR(RSZ_IOC_BASE, 8, unsigned long)
++#define RSZ_S_PRIORITY		_IOW(RSZ_IOC_BASE, 9, unsigned long)
++#define RSZ_RECONFIG		_IOWR(RSZ_IOC_BASE, 10, struct rsz_reconfig)
++/* only for debug purpose */
++#define RSZ_DUMP_HW_CONFIG	_IOW(RSZ_IOC_BASE, 11, unsigned long)
++#define RSZ_IOC_MAXNR		11
++
++#ifdef __KERNEL__
++
++struct rsz_device {
++	/* mutex lock for this device */
++	struct mutex lock;
++	/* number of users */
++	int users;
++};
++#endif
++#endif
+--- a/drivers/media/video/Kconfig
++++ b/drivers/media/video/Kconfig
+@@ -392,6 +392,15 @@ config VIDEO_TVP5150
+ 	  To compile this driver as a module, choose M here: the
+ 	  module will be called tvp5150.
+ 
++config VIDEO_TVP7002
++	tristate "Texas Instruments TVP7002 video decoder"
++	depends on VIDEO_V4L2 && I2C
++	---help---
++	  Support for the Texas Instruments TVP7002 video decoder.
++
++	  To compile this driver as a module, choose M here: the
++	  module will be called tvp7002.
++
+ config VIDEO_VPX3220
+ 	tristate "vpx3220a, vpx3216b & vpx3214c video decoders"
+ 	depends on VIDEO_V4L2 && I2C
+@@ -466,6 +475,29 @@ config VIDEO_THS7303
+ 	  To compile this driver as a module, choose M here: the
+ 	  module will be called ths7303.
+ 
++config VIDEO_THS7353
++	tristate "THS7353 Video Amplifier"
++	depends on I2C
++	help
++	  Support for TI THS7353 video amplifier
++
++	  To compile this driver as a module, choose M here: the
++	  module will be called ths7353.
++
++config VIDEO_THS7353_LUMA_CHANNEL
++	int "THS7353 channel number for Luma Input"
++	default 3
++	depends on VIDEO_THS7353
++	help
++	  Select the luma channel number for the THS7353 input.
++
++	  THS7353 has three identical channels. For the component
++	  interface, luma input will be connected to one of these
++	  channels and cb and cr will be connected to other channels
++	  This config option is used to select the luma input channel
++	  number. Possible values for this option are 1,2 or 3. Any
++	  other value will result in value 2.
++
+ config VIDEO_ADV7343
+ 	tristate "ADV7343 video encoder"
+ 	depends on I2C
+@@ -475,6 +507,15 @@ config VIDEO_ADV7343
+ 	  To compile this driver as a module, choose M here: the
+ 	  module will be called adv7343.
+ 
++config VIDEO_THS8200
++	tristate "THS8200 video encoder"
++	depends on I2C
++	help
++	  Support for Analog Devices I2C bus based THS8200 encoder.
++
++	  To compile this driver as a module, choose M here: the
++	  module will be called ths8200.
++
+ comment "Video improvement chips"
+ 
+ config VIDEO_UPD64031A
+@@ -507,7 +548,6 @@ config DISPLAY_DAVINCI_DM646X_EVM
+ 	depends on VIDEO_DEV && MACH_DAVINCI_DM6467_EVM
+ 	select VIDEOBUF_DMA_CONTIG
+ 	select VIDEO_DAVINCI_VPIF
+-	select VIDEO_ADV7343
+ 	select VIDEO_THS7303
+ 	help
+ 	  Support for DM6467 based display device.
+@@ -535,6 +575,77 @@ config VIDEO_DAVINCI_VPIF
+ 	  To compile this driver as a module, choose M here: the
+ 	  module will be called vpif.
+ 
++config VIDEO_DAVINCI_DISPLAY
++	tristate "Davinci V4L2 Video Display"
++	depends on VIDEO_DEV && ARCH_DAVINCI
++	select VIDEOBUF_VMALLOC
++	select DAVINCI_OSD
++	help
++	  V4L2 Display driver support for davinci.
++
++	  To compile this driver as a module, choose M here: the
++	  module will be called davinci_display.
++
++config DAVINCI_ENC_MNGR
++	tristate "Davinci Encoder Manager support"
++	depends on ARCH_DAVINCI
++	default y
++	help
++	  Enable support for the DaVinci Encoder Manager. This is responsible
++	  for managing output and video/graphics modes for davinci video drivers.
++
++	  To compile this driver as a module, choose M here: the
++	  module will be called davinci_enc_mngr
++
++config ENC_MNGR_MAX_CHANNELS
++	int "Max number of channels for Encoder Manager"
++	depends on DAVINCI_ENC_MNGR
++	default "2"
++	help
++	  Used to give max number of channels supported by encoder manager
++	  driver.
++
++config DAVINCI_OSD
++	tristate "Davinci Display Manager"
++	help
++	  Support for Davinci On-Screen Display Manager.
++
++	  To compile this driver as a module, choose M here: the
++	  module will be called davinci_osd.
++
++config DAVINCI_VPBE_ENCODER
++	tristate "Davinci VPBE Encoder support"
++	depends on DAVINCI_ENC_MNGR
++	default y
++	help
++	  Enable support for the DaVinci VPBE internal encoder. DaVinci VPBE
++	  has internal VENC and DAC to output analog SD outputs (composite,
++	  S-Video and Component video outputs).
++
++	  To compile this driver as a module, choose M here: the
++	  module will be called vpbe_encoder.
++
++config DAVINCI_LOGICPD_ENCODER
++	tristate "Logic PD Encoder support"
++	depends on (DAVINCI_ENC_MNGR)
++	default y
++	help
++	  Enable support for the Logic PD encoder.
++
++	  To compile this driver as a module, choose M here: the
++	  module will be called logicpd_encoder.
++
++config DAVINCI_AVNET_ENCODER
++	tristate "AVNET LCD Encoder support"
++	depends on (DAVINCI_ENC_MNGR)
++	default y
++	help
++	  Enable support for the DaVinci AVNET LCD encoder. It uses a Toshiba LTA070A321F
++	  800x480 WVGA LCD module.
++
++	  To compile this driver as a module, choose M here: the
++	  module will be called avnetlcd_encoder.
++
+ config VIDEO_VIVI
+ 	tristate "Virtual Video Driver"
+ 	depends on VIDEO_DEV && VIDEO_V4L2 && !SPARC32 && !SPARC64
+@@ -585,17 +696,69 @@ config VIDEO_DM355_CCDC
+ 	tristate "DM355 CCDC HW module"
+ 	depends on ARCH_DAVINCI_DM355 && VIDEO_VPFE_CAPTURE
+ 	select VIDEO_VPSS_SYSTEM
++	select MFD_DM355EVM_MSP
+ 	default y
+ 	help
+ 	   Enables DM355 CCD hw module. DM355 CCDC hw interfaces
+ 	   with decoder modules such as TVP5146 over BT656 or
+ 	   sensor module such as MT9T001 over a raw interface. This
+ 	   module configures the interface and CCDC/ISIF to do
+-	   video frame capture from a slave decoders
++	   video frame capture from a slave decoders. MFD_DM355EVM_MSP
++	   is enabled to select input to CCDC at run time.
+ 
+ 	   To compile this driver as a module, choose M here: the
+ 	   module will be called vpfe.
+ 
++config VIDEO_DM365_ISIF
++	tristate "DM365 CCDC/ISIF HW module"
++	depends on ARCH_DAVINCI_DM365 && VIDEO_VPFE_CAPTURE
++	default y
++	help
++	   Enables DM365 ISIF hw module. This is the hardware module for
++	   configuring ISIF in VPFE to capture Raw Bayer RGB data  from
++	   a image sensor or YUV data from a YUV source.
++
++config VIDEO_DM355_AF
++	tristate "DM355 Auto Focus Driver"
++	depends on ARCH_DAVINCI_DM355
++	default y
++	help
++	  DM355 Auto Focus Driver. Auto Focus driver is used to support
++	  control loop for Auto Focus. It collects metrics about the image or
++	  video data
++
++config VIDEO_DM355_AEW
++	tristate "DM355 Auto exposure /White Balance Driver"
++	depends on ARCH_DAVINCI_DM355
++	help
++	  DM355 Auto Exposure and Auto White Balance driver is used to support
++	  the control loops for Auto Exposure and Auto White Balance. It collects
++	  metrics about the image or video data
++
++config VIDEO_DM365_3A_HW
++	tristate "DM365 Auto Focus, Auto Exposure/ White Balance HW module"
++	depends on ARCH_DAVINCI_DM365
++	help
++	  DM365 Auto Focus, Auto Exposure and Auto White Balancing HW module
++
++config VIDEO_DM365_AF
++	tristate "DM365 Auto Focus Driver"
++	depends on ARCH_DAVINCI_DM365
++	select VIDEO_DM365_3A_HW
++	help
++	  DM365 Auto Focus Driver. Auto Focus driver is used to support
++	  control loop for Auto Focus. It collects metrics about the image or
++	  video data
++
++config VIDEO_DM365_AEW
++	tristate "DM365 Auto exposure /White Balance Driver"
++	depends on ARCH_DAVINCI_DM365
++	select VIDEO_DM365_3A_HW
++	help
++	  DM365 Auto Exposure and Auto White Balance driver is used to support
++	  the control loops for Auto Exposure and Auto White Balance. It collects
++	  metrics about the image or video data
++
+ source "drivers/media/video/bt8xx/Kconfig"
+ 
+ config VIDEO_PMS
+@@ -836,7 +999,7 @@ config SOC_CAMERA_MT9M111
+ 
+ config SOC_CAMERA_MT9T031
+ 	tristate "mt9t031 support"
+-	depends on SOC_CAMERA && I2C
++	depends on I2C
+ 	help
+ 	  This driver supports MT9T031 cameras from Micron.
+ 
+--- /dev/null
++++ b/drivers/char/davinci_vdce_hw.c
+@@ -0,0 +1,320 @@
++/* *
++ * Copyright (C) 2007 Texas Instruments	Inc
++ *
++ * This	program	is free	software; you can redistribute it and/or modify
++ * it under the	terms of the GNU General Public	License	as published by
++ * the Free Software Foundation; either	version	2 of the License, or
++ * (at your option) any	later version.
++ *
++ * This	program	is distributed in the hope that	it will	be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A	PARTICULAR PURPOSE.	 See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59	Temple Place, Suite 330, Boston, MA 02111-1307	USA
++ */
++/* davinci_vdce_hw.c	file */
++
++/*Header files*/
++#include "davinci_vdce_hw.h"
++#include <linux/davinci_vdce.h>
++#include <linux/kernel.h>	/* printk()     */
++#include <linux/device.h>
++
++extern struct device *vdce_device;
++
++/*
++ * vdce_hardware_setup :Function to set GE hardware configuration registers
++ */
++void vdce_hw_setup(vdce_hw_config_t * register_config)
++{
++	/* all devdbg will be removed after UT */
++	int status;
++	dev_dbg(vdce_device, " vdce_hw_setup E\n");
++
++	/* setting the hardware register GE ctrl */
++	regw(register_config->vdce_ctrl, VDCE_CTRL);
++	dev_dbg(vdce_device, "GE CTRL : %x	regr = %x \n",
++		register_config->vdce_ctrl, regr(VDCE_CTRL));
++
++	regw(register_config->vdce_emulation_ctrl, VDCE_EMULATION_CTRL);
++	dev_dbg(vdce_device, "VDCE_EMULATION_CTRL	%x regr	= %x\n",
++		register_config->vdce_emulation_ctrl,
++		regr(VDCE_EMULATION_CTRL));
++
++	/* setting the hardware register sdr_fmt */
++	regw(register_config->vdce_sdr_fmt, VDCE_SDR_FMT);
++	dev_dbg(vdce_device, "VDCE_SDR_FMT %x regr = %x\n",
++		register_config->vdce_sdr_fmt, regr(VDCE_SDR_FMT));
++
++	/* setting the hardware register req_sz */
++	regw(register_config->vdce_req_sz, VDCE_REQ_SZ);
++	dev_dbg(vdce_device, "VDCE_REQ_SZ %x	regr = %x\n",
++		register_config->vdce_req_sz, regr(VDCE_REQ_SZ));
++
++	regw(register_config->vdce_prcs_unit_size, VDCE_PRCS_UNIT_SIZE);
++	dev_dbg(vdce_device, "VDCE_PRCS_UNIT_SIZE :	%x	regr = %x \n",
++		register_config->vdce_prcs_unit_size,
++		regr(VDCE_PRCS_UNIT_SIZE));
++
++	regw(register_config->src_Y_strt_ps, SRC_Y_STRT_PS);
++	dev_dbg(vdce_device, "SRC_Y_STRT_PS : %x	regr = %x \n",
++		register_config->src_Y_strt_ps, regr(SRC_Y_STRT_PS));
++
++	regw(register_config->src_Y_sz, SRC_Y_SZ);
++	dev_dbg(vdce_device, "SRC_Y_SZ : %x	regr = %x \n",
++		register_config->src_Y_sz, regr(SRC_Y_SZ));
++
++	regw(register_config->src_C_strt_ps, SRC_C_STRT_PS);
++	dev_dbg(vdce_device, "SRC_C_STRT_PS : %x	regr = %x \n",
++		register_config->src_C_strt_ps, regr(SRC_C_STRT_PS));
++
++	regw(register_config->src_C_sz, SRC_C_SZ);
++	dev_dbg(vdce_device, "SRC_C_SZ : %x	regr = %x \n",
++		register_config->src_C_sz, regr(SRC_C_SZ));
++
++	regw(register_config->src_bmp_strt_ps, SRC_BMP_STRT_PS);
++	dev_dbg(vdce_device, "SRC_BMP_STRT_PS : %x	regr = %x \n",
++		register_config->src_bmp_strt_ps, regr(SRC_BMP_STRT_PS));
++
++	regw(register_config->src_bmp_sz, SRC_BMP_SZ);
++	dev_dbg(vdce_device, "SRC_BMP_SZ : %x	regr = %x \n",
++		register_config->src_bmp_sz, regr(SRC_BMP_SZ));
++
++	regw(register_config->res_Y_strt_ps, RES_Y_STRT_PS);
++	dev_dbg(vdce_device, "RES_Y_STRT_PS : %x	regr = %x \n",
++		register_config->res_Y_strt_ps, regr(RES_Y_STRT_PS));
++
++	regw(register_config->res_Y_sz, RES_Y_SZ);
++	dev_dbg(vdce_device, "RES_Y_SZ : %x	regr = %x \n",
++		register_config->res_Y_sz, regr(RES_Y_SZ));
++
++	regw(register_config->res_C_strt_ps, RES_C_STRT_PS);
++	dev_dbg(vdce_device, "RES_C_STRT_PS : %x	regr = %x \n",
++		register_config->res_C_strt_ps, regr(RES_C_STRT_PS));
++
++	regw(register_config->res_C_sz, RES_C_SZ);
++	dev_dbg(vdce_device, "RES_C_SZ : %x	regr = %x \n",
++		register_config->res_C_sz, regr(RES_C_SZ));
++
++	regw(register_config->res_bmp_strt_ps, RES_BMP_STRT_PS);
++	dev_dbg(vdce_device, "RES_BMP_STRT_PS : %x	regr = %x \n",
++		register_config->res_bmp_strt_ps, regr(RES_BMP_STRT_PS));
++
++	regw(register_config->rsz_mode, RSZ_MODE);
++	dev_dbg(vdce_device, "RSZ_MODE : %x	regr = %x \n",
++		register_config->rsz_mode, regr(RSZ_MODE));
++
++	regw(register_config->rsz_h_mag, RSZ_H_MAG);
++	dev_dbg(vdce_device, "RSZ_H_MAG :	%x	regr = %x \n",
++		register_config->rsz_h_mag, regr(RSZ_H_MAG));
++
++	regw(register_config->rsz_v_mag, RSZ_V_MAG);
++	dev_dbg(vdce_device, "RSZ_V_MAG :	%x	regr = %x \n",
++		register_config->rsz_v_mag, regr(RSZ_V_MAG));
++
++	regw(register_config->rsz_h_phase, RSZ_H_PHASE);
++	dev_dbg(vdce_device, "RSZ_H_PHASE	: %x	regr = %x \n",
++		register_config->rsz_h_phase, regr(RSZ_H_PHASE));
++
++	regw(register_config->rsz_v_phase, RSZ_V_PHASE);
++	dev_dbg(vdce_device, "RSZ_V_PHASE	: %x	regr = %x \n",
++		register_config->rsz_v_phase, regr(RSZ_V_PHASE));
++
++	regw(register_config->rsz_alf_intensity, RSZ_ALF_INTENSITY);
++	dev_dbg(vdce_device, "RSZ_ALF_INTENSITY :	%x	regr = %x \n",
++		register_config->rsz_alf_intensity, regr(RSZ_ALF_INTENSITY));
++
++	regw(register_config->ccv_mode, CCV_MODE);
++	dev_dbg(vdce_device, "CCV_MODE : %x	regr = %x \n",
++		register_config->ccv_mode, regr(CCV_MODE));
++
++	regw(register_config->bld_lut[0], BLD_LUT_00);
++	dev_dbg(vdce_device, "BLD_LUT_00 : %x	regr = %x \n",
++		register_config->bld_lut[0], regr(BLD_LUT_00));
++
++	regw(register_config->bld_lut[1], BLD_LUT_01);
++	dev_dbg(vdce_device, "BLD_LUT_01 : %x	regr = %x \n",
++		register_config->bld_lut[1], regr(BLD_LUT_01));
++
++	regw(register_config->bld_lut[2], BLD_LUT_02);
++	dev_dbg(vdce_device, "BLD_LUT_02 : %x	regr = %x \n",
++		register_config->bld_lut[2], regr(BLD_LUT_02));
++
++	regw(register_config->bld_lut[3], BLD_LUT_03);
++	dev_dbg(vdce_device, "BLD_LUT_03 : %x	regr = %x \n",
++		register_config->bld_lut[3], regr(BLD_LUT_03));
++
++	regw(register_config->rgmp_ctrl, RGMP_CTRL);
++	dev_dbg(vdce_device, "RGMP_CTRL :	%x	regr = %x \n",
++		register_config->rgmp_ctrl, regr(RGMP_CTRL));
++
++	regw(register_config->epd_luma_width, EPD_LUMA_WIDTH);
++	dev_dbg(vdce_device, "EPD_LUMA_WIDTH : %x	regr = %x \n",
++		register_config->epd_luma_width, regr(EPD_LUMA_WIDTH));
++
++	regw(register_config->epd_chroma_width, EPD_CHROMA_WIDTH);
++	dev_dbg(vdce_device, "EPD_CHROMA_WIDTH : %x	regr = %x \n",
++		register_config->epd_chroma_width, regr(EPD_CHROMA_WIDTH));
++
++	/* source addres for luma and chroma */
++	regw(register_config->vdce_src_strt_add_ytop, VDCE_SRC_STRT_ADD_YTOP);
++
++	dev_dbg(vdce_device, "VDCE_SRC_STRT_ADD_YTOP %x	regr = %x\n",
++		register_config->vdce_src_strt_add_ytop,
++		regr(VDCE_SRC_STRT_ADD_YTOP));
++
++	regw(register_config->vdce_src_strt_add_ctop, VDCE_SRC_STRT_ADD_CTOP);
++
++	dev_dbg(vdce_device, "VDCE_SRC_STRT_ADD_CTOP %x	regr = %x\n",
++		register_config->vdce_src_strt_add_ctop,
++		regr(VDCE_SRC_STRT_ADD_CTOP));
++
++	regw(register_config->vdce_src_strt_add_ybot, VDCE_SRC_STRT_ADD_YBOT);
++
++	dev_dbg(vdce_device, "VDCE_SRC_STRT_ADD_YBOT %x	regr = %x\n",
++		register_config->vdce_src_strt_add_ybot,
++		regr(VDCE_SRC_STRT_ADD_YBOT));
++
++	regw(register_config->vdce_src_strt_add_cbot, VDCE_SRC_STRT_ADD_CBOT);
++
++	dev_dbg(vdce_device, "VDCE_SRC_STRT_ADD_CBOT %x	regr = %x\n",
++		register_config->vdce_src_strt_add_cbot,
++		regr(VDCE_SRC_STRT_ADD_CBOT));
++
++	/* result address for luma and chroma */
++	regw(register_config->vdce_res_strt_add_ytop, VDCE_RES_STRT_ADD_YTOP);
++
++	dev_dbg(vdce_device, "VDCE_RES_STRT_ADD_YTOP %x	regr = %x\n",
++		register_config->vdce_res_strt_add_ytop,
++		regr(VDCE_RES_STRT_ADD_YTOP));
++
++	regw(register_config->vdce_res_strt_add_ctop, VDCE_RES_STRT_ADD_CTOP);
++	dev_dbg(vdce_device, "VDCE_RES_STRT_ADD_CTOP %x	regr = %x\n",
++		register_config->vdce_res_strt_add_ctop,
++		regr(VDCE_RES_STRT_ADD_CTOP));
++
++	regw(register_config->vdce_res_strt_add_ybot, VDCE_RES_STRT_ADD_YBOT);
++
++	dev_dbg(vdce_device, "VDCE_RES_STRT_ADD_YTOP %x	regr = %x\n",
++		register_config->vdce_res_strt_add_ybot,
++		regr(VDCE_RES_STRT_ADD_YBOT));
++
++	regw(register_config->vdce_res_strt_add_cbot, VDCE_RES_STRT_ADD_CBOT);
++	dev_dbg(vdce_device, "VDCE_RES_STRT_ADD_CBOT %x	regr = %x\n",
++		register_config->vdce_res_strt_add_cbot,
++		regr(VDCE_RES_STRT_ADD_CBOT));
++
++	/* source offset for luma and chroma */
++	regw(register_config->vdce_src_add_ofst_ytop, VDCE_SRC_STRT_OFF_YTOP);
++	dev_dbg(vdce_device, "VDCE_SRC_STRT_OFF_YTOP %x	regr = %x\n",
++		register_config->vdce_src_add_ofst_ytop,
++		regr(VDCE_SRC_STRT_OFF_YTOP));
++
++	regw(register_config->vdce_src_add_ofst_ctop, VDCE_SRC_STRT_OFF_CTOP);
++	dev_dbg(vdce_device, "VDCE_SRC_STRT_OFF_CTOP %x	regr = %x\n",
++		register_config->vdce_src_add_ofst_ctop,
++		regr(VDCE_SRC_STRT_OFF_CTOP));
++
++	regw(register_config->vdce_src_add_ofst_ybot, VDCE_SRC_STRT_OFF_YBOT);
++	dev_dbg(vdce_device, "VDCE_SRC_STRT_OFF_YBOT %x	regr = %x\n",
++		register_config->vdce_src_add_ofst_ybot,
++		regr(VDCE_SRC_STRT_OFF_YBOT));
++
++	regw(register_config->vdce_src_add_ofst_cbot, VDCE_SRC_STRT_OFF_CBOT);
++	dev_dbg(vdce_device, "VDCE_SRC_STRT_OFF_CBOT %x	regr = %x\n",
++		register_config->vdce_src_add_ofst_cbot,
++		regr(VDCE_SRC_STRT_OFF_CBOT));
++
++	/* result offset for luma and chroma */
++	regw(register_config->vdce_res_strt_off_ytop, VDCE_RES_STRT_OFF_YTOP);
++	dev_dbg(vdce_device, "VDCE_RES_STRT_OFF_YTOP %x	regr = %x\n",
++		register_config->vdce_res_strt_off_ytop,
++		regr(VDCE_RES_STRT_OFF_YTOP));
++
++	regw(register_config->vdce_res_strt_off_ctop, VDCE_RES_STRT_OFF_CTOP);
++	dev_dbg(vdce_device, "VDCE_RES_STRT_OFF_CTOP %x	regr = %x\n",
++		register_config->vdce_res_strt_off_ctop,
++		regr(VDCE_RES_STRT_OFF_CTOP));
++
++	regw(register_config->vdce_res_strt_off_ybot, VDCE_RES_STRT_OFF_YBOT);
++	dev_dbg(vdce_device, "VDCE_RES_STRT_OFF_YBOT %x	regr = %x\n",
++		register_config->vdce_res_strt_off_ybot,
++		regr(VDCE_RES_STRT_OFF_YBOT));
++
++	regw(register_config->vdce_res_strt_off_cbot, VDCE_RES_STRT_OFF_CBOT);
++	dev_dbg(vdce_device, "VDCE_RES_STRT_OFF_CBOT %x	regr = %x\n",
++		register_config->vdce_res_strt_off_cbot,
++		regr(VDCE_RES_STRT_OFF_CBOT));
++
++	/* bitmap address and offset for luma and chroma */
++	regw(register_config->vdce_src_strt_add_bmp_top,
++	     VDCE_SRC_STRT_ADD_BMP_TOP);
++	dev_dbg(vdce_device, "VDCE_SRC_STRT_ADD_BMP_TOP %x	regr = %x\n",
++		register_config->vdce_src_strt_add_bmp_top,
++		regr(VDCE_SRC_STRT_ADD_BMP_TOP));
++
++	regw(register_config->vdce_src_strt_add_bmp_bot,
++	     VDCE_SRC_STRT_ADD_BMP_BOT);
++	dev_dbg(vdce_device, "VDCE_SRC_STRT_ADD_BMP_BOT %x	regr = %x\n",
++		register_config->vdce_src_strt_add_bmp_bot,
++		regr(VDCE_SRC_STRT_ADD_BMP_BOT));
++
++	regw(register_config->vdce_src_strt_off_bmp_top,
++	     VDCE_SRC_STRT_OFF_BMP_TOP);
++	dev_dbg(vdce_device, "VDCE_SRC_STRT_OFF_BMP_TOP %x	regr = %x\n",
++		register_config->vdce_src_strt_off_bmp_top,
++		regr(VDCE_SRC_STRT_OFF_BMP_TOP));
++
++	regw(register_config->vdce_src_strt_off_bmp_bot,
++	     VDCE_SRC_STRT_OFF_BMP_BOT);
++
++	status = regr(VDCE_STATUS);
++	dev_dbg(vdce_device, "VDCE_SRC_STRT_OFF_BMP_BOT %x	regr = %x\n",
++		register_config->vdce_src_strt_off_bmp_bot,
++		regr(VDCE_SRC_STRT_OFF_BMP_BOT));
++	dev_dbg(vdce_device, "vdce_hw_setup L\n");
++}
++
++/*
++ * vdce_enable : Function to enable the	ge module
++ */
++int vdce_enable(vdce_hw_config_t * register_config)
++{
++	dev_dbg(vdce_device, " vdce_enable E\n");
++	/* enabling the resizer the setting enable bit */
++	register_config->vdce_ctrl =
++	    BITSET(register_config->vdce_ctrl, VDCE_ENABLE);
++
++	regw(register_config->vdce_ctrl, VDCE_CTRL);
++
++	register_config->vdce_ctrl =
++	    BITRESET(register_config->vdce_ctrl, VDCE_ENABLE);
++
++	dev_dbg(vdce_device, "vdce enable L\n");
++
++	return 0;
++}
++
++/*
++ * vdce_interrupt set : Function to set interrupt
++ */
++inline int vdce_enable_int(void)
++{
++	regw(1, VDCE_INTEN);
++	regw(1, VDCE_INTEN_SET);
++	/* Disable emulation control signal */
++	regw(1, VDCE_EMULATION_CTRL);
++	return 0;
++}
++
++/*
++ * vdce_clear_status : Function to clear the status
++ */
++inline int vdce_clear_status(void)
++{
++	regw(1, VDCE_STATUS_CLR);
++	return 0;
++}
+--- a/drivers/media/video/Makefile
++++ b/drivers/media/video/Makefile
+@@ -47,15 +47,18 @@ obj-$(CONFIG_VIDEO_ADV7170) += adv7170.o
+ obj-$(CONFIG_VIDEO_ADV7175) += adv7175.o
+ obj-$(CONFIG_VIDEO_ADV7180) += adv7180.o
+ obj-$(CONFIG_VIDEO_ADV7343) += adv7343.o
++obj-$(CONFIG_VIDEO_THS8200) += ths8200.o
+ obj-$(CONFIG_VIDEO_VPX3220) += vpx3220.o
+ obj-$(CONFIG_VIDEO_BT819) += bt819.o
+ obj-$(CONFIG_VIDEO_BT856) += bt856.o
+ obj-$(CONFIG_VIDEO_BT866) += bt866.o
+ obj-$(CONFIG_VIDEO_KS0127) += ks0127.o
+ obj-$(CONFIG_VIDEO_THS7303) += ths7303.o
++obj-$(CONFIG_VIDEO_THS7353) += ths7353.o
+ obj-$(CONFIG_VIDEO_VINO) += indycam.o
+ obj-$(CONFIG_VIDEO_TVP5150) += tvp5150.o
+ obj-$(CONFIG_VIDEO_TVP514X) += tvp514x.o
++obj-$(CONFIG_VIDEO_TVP7002) += tvp7002.o
+ obj-$(CONFIG_VIDEO_MSP3400) += msp3400.o
+ obj-$(CONFIG_VIDEO_CS5345) += cs5345.o
+ obj-$(CONFIG_VIDEO_CS53L32A) += cs53l32a.o
+--- a/drivers/input/misc/Makefile
++++ b/drivers/input/misc/Makefile
+@@ -12,6 +12,7 @@ obj-$(CONFIG_INPUT_BFIN_ROTARY)		+= bfin
+ obj-$(CONFIG_INPUT_CM109)		+= cm109.o
+ obj-$(CONFIG_INPUT_COBALT_BTNS)		+= cobalt_btns.o
+ obj-$(CONFIG_INPUT_DM355EVM)		+= dm355evm_keys.o
++obj-$(CONFIG_INPUT_DM365EVM)		+= dm365evm_keys.o
+ obj-$(CONFIG_HP_SDC_RTC)		+= hp_sdc_rtc.o
+ obj-$(CONFIG_INPUT_IXP4XX_BEEPER)	+= ixp4xx-beeper.o
+ obj-$(CONFIG_INPUT_KEYSPAN_REMOTE)	+= keyspan_remote.o
+--- a/arch/arm/mach-davinci/include/mach/da8xx.h
++++ b/arch/arm/mach-davinci/include/mach/da8xx.h
+@@ -11,12 +11,17 @@
+ #ifndef __ASM_ARCH_DAVINCI_DA8XX_H
+ #define __ASM_ARCH_DAVINCI_DA8XX_H
+ 
++#include <video/da8xx-fb.h>
++
+ #include <mach/serial.h>
+ #include <mach/edma.h>
+ #include <mach/i2c.h>
+ #include <mach/emac.h>
+ #include <mach/asp.h>
+ #include <mach/mmc.h>
++#include <mach/usb.h>
++
++extern void __iomem *da8xx_syscfg_base;
+ 
+ /*
+  * The cp_intc interrupt controller for the da8xx isn't in the same
+@@ -29,11 +34,14 @@
+ #define DA8XX_CP_INTC_SIZE	SZ_8K
+ #define DA8XX_CP_INTC_VIRT	(IO_VIRT - DA8XX_CP_INTC_SIZE - SZ_4K)
+ 
+-#define DA8XX_BOOT_CFG_BASE	(IO_PHYS + 0x14000)
++#define DA8XX_SYSCFG_BASE	(IO_PHYS + 0x14000)
++#define DA8XX_SYSCFG_VIRT(x)	(da8xx_syscfg_base + (x))
++#define DA8XX_JTAG_ID_REG	0x18
++#define DA8XX_CFGCHIP2_REG	0x184
++#define DA8XX_CFGCHIP3_REG	0x188
+ 
+ #define DA8XX_PSC0_BASE		0x01c10000
+ #define DA8XX_PLL0_BASE		0x01c11000
+-#define DA8XX_JTAG_ID_REG	0x01c14018
+ #define DA8XX_TIMER64P0_BASE	0x01c20000
+ #define DA8XX_TIMER64P1_BASE	0x01c21000
+ #define DA8XX_GPIO_BASE		0x01e26000
+@@ -71,13 +79,17 @@ void __init da850_init(void);
+ int da8xx_register_edma(void);
+ int da8xx_register_i2c(int instance, struct davinci_i2c_platform_data *pdata);
+ int da8xx_register_watchdog(void);
++int da8xx_register_usb11(struct da8xx_ohci_root_hub *pdata);
+ int da8xx_register_emac(void);
+-int da8xx_register_lcdc(void);
++int da8xx_register_lcdc(struct da8xx_lcdc_platform_data *pdata);
+ int da8xx_register_mmcsd0(struct davinci_mmc_config *config);
+-void __init da8xx_init_mcasp(int id, struct snd_platform_data *pdata);
++void __init da8xx_register_mcasp(int id, struct snd_platform_data *pdata);
++int da8xx_register_rtc(void);
+ 
+ extern struct platform_device da8xx_serial_device;
+ extern struct emac_platform_data da8xx_emac_pdata;
++extern struct da8xx_lcdc_platform_data sharp_lcd035q3dg01_pdata;
++extern struct da8xx_lcdc_platform_data sharp_lk043t1dg01_pdata;
+ 
+ extern const short da830_emif25_pins[];
+ extern const short da830_spi0_pins[];
+--- /dev/null
++++ b/include/media/davinci/dm365_ipipe.h
+@@ -0,0 +1,1357 @@
++/*
++ *
++ * Copyright (C) 2008 Texas Instruments Inc
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
++ *
++ * Feature description
++ * ===================
++ *
++ * VPFE hardware setup
++ *
++ * case 1: Capture to SDRAM with out IPIPE
++ * ****************************************
++ *
++ *            parallel
++ *                port
++ *
++ * Image sensor/       ________
++ * Yuv decoder    ---->| CCDC |--> SDRAM
++ *                     |______|
++ *
++ * case 2: Capture to SDRAM with IPIPE Preview modules in Continuous
++ *          (On the Fly mode)
++ *
++ * Image sensor/       ________    ____________________
++ * Yuv decoder    ---->| CCDC |--> | Previewer modules |--> SDRAM
++ *                     |______|    |___________________|
++ *
++ * case 3: Capture to SDRAM with IPIPE Preview modules  & Resizer
++ *         in continuous (On the Fly mode)
++ *
++ * Image sensor/       ________    _____________   ___________
++ * Yuv decoder    ---->| CCDC |--> | Previewer  |->| Resizer  |-> SDRAM
++ *                     |______|    |____________|  |__________|
++ *
++ * case 4: Capture to SDRAM with IPIPE Resizer
++ *         in continuous (On the Fly mode)
++ *
++ * Image sensor/       ________    ___________
++ * Yuv decoder    ---->| CCDC |--> | Resizer  |-> SDRAM
++ *                     |______|    |__________|
++ *
++ * case 5: Read from SDRAM and do preview and/or Resize
++ *         in Single shot mode
++ *
++ *                   _____________   ___________
++ *    SDRAM   ----> | Previewer  |->| Resizer  |-> SDRAM
++ *                  |____________|  |__________|
++ *
++ *
++ * Previewer allows fine tuning of the input image using different
++ * tuning modules in IPIPE. Some examples :- Noise filter, Defect
++ * pixel correction etc. It essentially operate on Bayer Raw data
++ * or YUV raw data. To do image tuning, application call,
++ * PREV_QUERY_CAP, and then call PREV_SET_PARAM to set parameter
++ * for a module.
++ *
++ *
++ * Resizer allows upscaling or downscaling a image to a desired
++ * resolution. There are 2 resizer modules. both operating on the
++ * same input image, but can have different output resolution.
++ */
++
++#ifndef DM365_IPIPE_H
++#define DM365_IPIPE_H
++
++#include <media/davinci/dm3xx_ipipe.h>
++
++/**********************************************************************
++**      Previewer API Structures
++**********************************************************************/
++
++/* Previewer module IDs used in PREV_SET/GET_PARAM IOCTL. Some
++ * modules can be also be updated during IPIPE operation. They are
++ * marked as control ID
++ */
++/* LUT based Defect Pixel Correction */
++#define PREV_LUTDPC		1
++/* On the fly (OTF) Defect Pixel Correction */
++#define PREV_OTFDPC		2
++/* Noise Filter - 1 */
++#define PREV_NF1 		3
++/* Noise Filter - 2 */
++#define PREV_NF2		4
++/* White Balance.  Also a control ID */
++#define PREV_WB			5
++/* 1st RGB to RBG Blend module */
++#define PREV_RGB2RGB_1		6
++/* 2nd RGB to RBG Blend module */
++#define PREV_RGB2RGB_2		7
++/* Gamma Correction */
++#define PREV_GAMMA		8
++/* 3D LUT color conversion */
++#define PREV_3D_LUT 		9
++/* RGB to YCbCr module */
++#define PREV_RGB2YUV 	   	10
++/* YUV 422 conversion module */
++#define PREV_YUV422_CONV   	11
++/* Luminance Adjustment module.  Also a control ID */
++#define PREV_LUM_ADJ	   	12
++/* Edge Enhancement */
++#define PREV_YEE           	13
++/* Green Imbalance Correction */
++#define PREV_GIC		14
++/* CFA Interpolation */
++#define PREV_CFA		15
++/* Chroma Artifact Reduction */
++#define PREV_CAR		16
++/* Chroma Gain Suppression */
++#define PREV_CGS		17
++/* Global brighness and contrast control */
++#define PREV_GBCE		18
++/* Last module ID */
++#define PREV_MAX_MODULES	18
++
++struct ipipe_float_u16 {
++	unsigned short integer;
++	unsigned short decimal;
++};
++
++struct ipipe_float_s16 {
++	short integer;
++	unsigned short decimal;
++};
++
++struct ipipe_float_u8 {
++	unsigned char integer;
++	unsigned char decimal;
++};
++
++struct ipipe_win {
++	/* vertical start line */
++	unsigned int vst;
++	/* horizontal start pixel */
++	unsigned int hst;
++	/* width */
++	unsigned int width;
++	/* height */
++	unsigned int height;
++};
++
++/* Copy method selection for vertical correction
++ *  Used when ipipe_dfc_corr_meth is PREV_DPC_CTORB_AFTER_HINT
++ */
++enum ipipe_dpc_corr_meth {
++	/* replace by black or white dot specified by repl_white */
++	IPIPE_DPC_REPL_BY_DOT = 0,
++	/* Copy from left */
++	IPIPE_DPC_CL,
++	/* Copy from right */
++	IPIPE_DPC_CR,
++	/* Horizontal interpolation */
++	IPIPE_DPC_H_INTP,
++	/* Vertical interpolation */
++	IPIPE_DPC_V_INTP,
++	/* Copy from top  */
++	IPIPE_DPC_CT,
++	/* Copy from bottom */
++	IPIPE_DPC_CB,
++	/* 2D interpolation */
++	IPIPE_DPC_2D_INTP,
++};
++
++struct ipipe_lutdpc_entry {
++	/* Horizontal position */
++	unsigned short horz_pos;
++	/* vertical position */
++	unsigned short vert_pos;
++	enum ipipe_dpc_corr_meth method;
++};
++
++#define MAX_SIZE_DPC 256
++/* Struct for configuring DPC module */
++struct prev_lutdpc {
++	/* 0 - disable, 1 - enable */
++	unsigned char en;
++	/* 0 - replace with black dot, 1 - white dot when correction
++	 * method is  IPIPE_DFC_REPL_BY_DOT=0,
++	 */
++	unsigned char repl_white;
++	/* number of entries in the correction table. Currently only
++	 * support upto 256 entries. infinite mode is not supported
++	 */
++	unsigned short dpc_size;
++	struct ipipe_lutdpc_entry *table;
++};
++
++enum ipipe_otfdpc_det_meth {
++	IPIPE_DPC_OTF_MIN_MAX,
++	IPIPE_DPC_OTF_MIN_MAX2
++};
++
++struct ipipe_otfdpc_thr {
++	unsigned short r;
++	unsigned short gr;
++	unsigned short gb;
++	unsigned short b;
++};
++
++enum ipipe_otfdpc_alg {
++	IPIPE_OTFDPC_2_0,
++	IPIPE_OTFDPC_3_0
++};
++
++struct prev_otfdpc_2_0 {
++	/* defect detection threshold for MIN_MAX2 method  (DPC 2.0 alg) */
++	struct ipipe_otfdpc_thr det_thr;
++	/* defect correction threshold for MIN_MAX2 method (DPC 2.0 alg) or
++	 * maximum value for MIN_MAX method
++	 */
++	struct ipipe_otfdpc_thr corr_thr;
++};
++
++struct prev_otfdpc_3_0 {
++	/* DPC3.0 activity adj shf. activity = (max2-min2) >> (6 -shf)
++	 */
++	unsigned char act_adj_shf;
++	/* DPC3.0 detection threshold, THR */
++	unsigned short det_thr;
++	/* DPC3.0 detection threshold slope, SLP */
++	unsigned short det_slp;
++	/* DPC3.0 detection threshold min, MIN */
++	unsigned short det_thr_min;
++	/* DPC3.0 detection threshold max, MAX */
++	unsigned short det_thr_max;
++	/* DPC3.0 correction threshold, THR */
++	unsigned short corr_thr;
++	/* DPC3.0 correction threshold slope, SLP */
++	unsigned short corr_slp;
++	/* DPC3.0 correction threshold min, MIN */
++	unsigned short corr_thr_min;
++	/* DPC3.0 correction threshold max, MAX */
++	unsigned short corr_thr_max;
++};
++
++struct prev_otfdpc {
++	/* 0 - disable, 1 - enable */
++	unsigned char en;
++	/* defect detection method */
++	enum ipipe_otfdpc_det_meth det_method;
++	/* Algorith used. Applicable only when IPIPE_DPC_OTF_MIN_MAX2 is
++	 * used
++	 */
++	enum ipipe_otfdpc_alg alg;
++	union {
++		/* if alg is IPIPE_OTFDPC_2_0 */
++		struct prev_otfdpc_2_0 dpc_2_0;
++		/* if alg is IPIPE_OTFDPC_3_0 */
++		struct prev_otfdpc_3_0 dpc_3_0;
++	} alg_cfg;
++};
++
++/* Threshold values table size */
++#define IPIPE_NF_THR_TABLE_SIZE 8
++/* Intensity values table size */
++#define IPIPE_NF_STR_TABLE_SIZE 8
++
++/* NF, sampling method for green pixels */
++enum ipipe_nf_sampl_meth {
++	/* Same as R or B */
++	IPIPE_NF_BOX,
++	/* Diamond mode */
++	IPIPE_NF_DIAMOND
++};
++
++/* Struct for configuring NF module */
++struct prev_nf {
++	/* 0 - disable, 1 - enable */
++	unsigned char en;
++	/* Sampling method for green pixels */
++	enum ipipe_nf_sampl_meth gr_sample_meth;
++	/* Down shift value in LUT reference address
++	 */
++	unsigned char shft_val;
++	/* Spread value in NF algorithm
++	 */
++	unsigned char spread_val;
++	/* Apply LSC gain to threshold. Enable this only if
++	 * LSC is enabled in ISIF
++	 */
++	unsigned char apply_lsc_gain;
++	/* Threshold values table */
++	unsigned short thr[IPIPE_NF_THR_TABLE_SIZE];
++	/* intensity values table */
++	unsigned char str[IPIPE_NF_STR_TABLE_SIZE];
++	/* Edge detection minimum threshold */
++	unsigned short edge_det_min_thr;
++	/* Edge detection maximum threshold */
++	unsigned short edge_det_max_thr;
++};
++
++enum ipipe_gic_alg {
++	IPIPE_GIC_ALG_CONST_GAIN,
++	IPIPE_GIC_ALG_ADAPT_GAIN
++};
++
++enum ipipe_gic_thr_sel {
++	IPIPE_GIC_THR_REG,
++	IPIPE_GIC_THR_NF
++};
++
++enum ipipe_gic_wt_fn_type {
++	/* Use difference as index */
++	IPIPE_GIC_WT_FN_TYP_DIF,
++	/* Use weight function as index */
++	IPIPE_GIC_WT_FN_TYP_HP_VAL
++};
++
++/* structure for Green Imbalance Correction */
++struct prev_gic {
++	/* 0 - disable, 1 - enable */
++	unsigned char en;
++	/* 0 - Constant gain , 1 - Adaptive gain algorithm */
++	enum ipipe_gic_alg gic_alg;
++	/* GIC gain or weight. Used for Constant gain and Adaptive algorithms
++	 */
++	unsigned short gain;
++	/* Threshold selection. GIC register values or NF2 thr table */
++	enum ipipe_gic_thr_sel thr_sel;
++	/* thr1. Used when thr_sel is  IPIPE_GIC_THR_REG */
++	unsigned short thr;
++	/* this value is used for thr2-thr1, thr3-thr2 or
++	 * thr4-thr3 when wt_fn_type is index. Otherwise it
++	 * is the
++	 */
++	unsigned short slope;
++	/* Apply LSC gain to threshold. Enable this only if
++	 * LSC is enabled in ISIF & thr_sel is IPIPE_GIC_THR_REG
++	 */
++	unsigned char apply_lsc_gain;
++	/* Multiply Nf2 threshold by this gain. Use this when thr_sel
++	 * is IPIPE_GIC_THR_NF
++	 */
++	struct ipipe_float_u8 nf2_thr_gain;
++	/* Weight function uses difference as index or high pass value.
++	 * Used for adaptive gain algorithm
++	 */
++	enum ipipe_gic_wt_fn_type wt_fn_type;
++};
++
++/* Struct for configuring WB module */
++struct prev_wb {
++	/* Offset (S12) for R */
++	short ofst_r;
++	/* Offset (S12) for Gr */
++	short ofst_gr;
++	/* Offset (S12) for Gb */
++	short ofst_gb;
++	/* Offset (S12) for B */
++	short ofst_b;
++	/* Gain (U13Q9) for Red */
++	struct ipipe_float_u16 gain_r;
++	/* Gain (U13Q9) for Gr */
++	struct ipipe_float_u16 gain_gr;
++	/* Gain (U13Q9) for Gb */
++	struct ipipe_float_u16 gain_gb;
++	/* Gain (U13Q9) for Blue */
++	struct ipipe_float_u16 gain_b;
++};
++
++enum ipipe_cfa_alg {
++	/* Algorithm is 2DirAC */
++	IPIPE_CFA_ALG_2DIRAC,
++	/* Algorithm is 2DirAC + Digital Antialiasing (DAA) */
++	IPIPE_CFA_ALG_2DIRAC_DAA,
++	/* Algorithm is DAA */
++	IPIPE_CFA_ALG_DAA
++};
++
++/* Structure for CFA Interpolation */
++struct prev_cfa {
++	/* 2DirAC or 2DirAC + DAA */
++	enum ipipe_cfa_alg alg;
++	/* 2Dir CFA HP value Low Threshold */
++	unsigned short hpf_thr_2dir;
++	/* 2Dir CFA HP value slope */
++	unsigned short hpf_slp_2dir;
++	/* 2Dir CFA HP mix threshold */
++	unsigned short hp_mix_thr_2dir;
++	/* 2Dir CFA HP mix slope */
++	unsigned short hp_mix_slope_2dir;
++	/* 2Dir Direction threshold */
++	unsigned short dir_thr_2dir;
++	/* 2Dir Direction slope */
++	unsigned short dir_slope_2dir;
++	/* 2Dir NonDirectional Weight */
++	unsigned short nd_wt_2dir;
++	/* DAA Mono Hue Fraction */
++	unsigned short hue_fract_daa;
++	/* DAA Mono Edge threshold */
++	unsigned short edge_thr_daa;
++	/* DAA Mono threshold minimum */
++	unsigned short thr_min_daa;
++	/* DAA Mono threshold slope */
++	unsigned short thr_slope_daa;
++	/* DAA Mono slope minimum */
++	unsigned short slope_min_daa;
++	/* DAA Mono slope slope */
++	unsigned short slope_slope_daa;
++	/* DAA Mono LP wight */
++	unsigned short lp_wt_daa;
++};
++
++/* Struct for configuring RGB2RGB blending module */
++struct prev_rgb2rgb {
++	/* Matrix coefficient for RR S12Q8 for ID = 1 and S11Q8 for ID = 2 */
++	struct ipipe_float_s16 coef_rr;
++	/* Matrix coefficient for GR S12Q8/S11Q8 */
++	struct ipipe_float_s16 coef_gr;
++	/* Matrix coefficient for BR S12Q8/S11Q8 */
++	struct ipipe_float_s16 coef_br;
++	/* Matrix coefficient for RG S12Q8/S11Q8 */
++	struct ipipe_float_s16 coef_rg;
++	/* Matrix coefficient for GG S12Q8/S11Q8 */
++	struct ipipe_float_s16 coef_gg;
++	/* Matrix coefficient for BG S12Q8/S11Q8 */
++	struct ipipe_float_s16 coef_bg;
++	/* Matrix coefficient for RB S12Q8/S11Q8 */
++	struct ipipe_float_s16 coef_rb;
++	/* Matrix coefficient for GB S12Q8/S11Q8 */
++	struct ipipe_float_s16 coef_gb;
++	/* Matrix coefficient for BB S12Q8/S11Q8 */
++	struct ipipe_float_s16 coef_bb;
++	/* Output offset for R S13/S11 */
++	int out_ofst_r;
++	/* Output offset for G S13/S11 */
++	int out_ofst_g;
++	/* Output offset for B S13/S11 */
++	int out_ofst_b;
++};
++
++#define MAX_SIZE_GAMMA 512
++
++enum ipipe_gamma_tbl_size {
++	IPIPE_GAMMA_TBL_SZ_64,
++	IPIPE_GAMMA_TBL_SZ_128,
++	IPIPE_GAMMA_TBL_SZ_256,
++	IPIPE_GAMMA_TBL_SZ_512
++};
++
++enum ipipe_gamma_tbl_sel {
++	IPIPE_GAMMA_TBL_RAM,
++	IPIPE_GAMMA_TBL_ROM
++};
++
++struct ipipe_gamma_entry {
++	/* 10 bit slope */
++	short slope;
++	/* 10 bit offset */
++	unsigned short offset;
++};
++
++/* Struct for configuring Gamma correction module */
++struct prev_gamma {
++	/* 0 - Enable Gamma correction for Red
++	 * 1 - bypass Gamma correction. Data is divided by 16
++	 */
++	unsigned char bypass_r;
++	/* 0 - Enable Gamma correction for Blue
++	 * 1 - bypass Gamma correction. Data is divided by 16
++	 */
++	unsigned char bypass_b;
++	/* 0 - Enable Gamma correction for Green
++	 * 1 - bypass Gamma correction. Data is divided by 16
++	 */
++	unsigned char bypass_g;
++	/* PREV_GAMMA_TBL_RAM or PREV_GAMMA_TBL_ROM */
++	enum ipipe_gamma_tbl_sel tbl_sel;
++	/* Table size for RAM gamma table.
++	 */
++	enum ipipe_gamma_tbl_size tbl_size;
++	/* R table */
++	struct ipipe_gamma_entry *table_r;
++	/* Blue table */
++	struct ipipe_gamma_entry *table_b;
++	/* Green table */
++	struct ipipe_gamma_entry *table_g;
++};
++
++#define MAX_SIZE_3D_LUT 	(729)
++
++struct ipipe_3d_lut_entry {
++	/* 10 bit entry for red */
++	unsigned short r;
++	/* 10 bit entry for green */
++	unsigned short g;
++	/* 10 bit entry for blue */
++	unsigned short b;
++};
++
++/* structure for 3D-LUT */
++struct prev_3d_lut {
++	/* enable/disable 3D lut */
++	unsigned char en;
++	/* 3D - LUT table entry */
++	struct ipipe_3d_lut_entry *table;
++};
++
++/* Struct for configuring Luminance Adjustment module */
++struct prev_lum_adj {
++	/* Brightness adjustments */
++	unsigned char brightness;
++	/* contrast adjustments */
++	unsigned char contrast;
++};
++
++/* Struct for configuring rgb2ycbcr module */
++struct prev_rgb2yuv {
++	/* Matrix coefficient for RY S12Q8 */
++	struct ipipe_float_s16 coef_ry;
++	/* Matrix coefficient for GY S12Q8 */
++	struct ipipe_float_s16 coef_gy;
++	/* Matrix coefficient for BY S12Q8 */
++	struct ipipe_float_s16 coef_by;
++	/* Matrix coefficient for RCb S12Q8 */
++	struct ipipe_float_s16 coef_rcb;
++	/* Matrix coefficient for GCb S12Q8 */
++	struct ipipe_float_s16 coef_gcb;
++	/* Matrix coefficient for BCb S12Q8 */
++	struct ipipe_float_s16 coef_bcb;
++	/* Matrix coefficient for RCr S12Q8 */
++	struct ipipe_float_s16 coef_rcr;
++	/* Matrix coefficient for GCr S12Q8 */
++	struct ipipe_float_s16 coef_gcr;
++	/* Matrix coefficient for BCr S12Q8 */
++	struct ipipe_float_s16 coef_bcr;
++	/* Output offset for R S11 */
++	int out_ofst_y;
++	/* Output offset for Cb S11 */
++	int out_ofst_cb;
++	/* Output offset for Cr S11 */
++	int out_ofst_cr;
++};
++
++enum ipipe_gbce_type {
++	IPIPE_GBCE_Y_VAL_TBL,
++	IPIPE_GBCE_GAIN_TBL
++};
++
++#define MAX_SIZE_GBCE_LUT 1024
++
++/* structure for Global brighness and Contrast */
++struct prev_gbce {
++	/* enable/disable GBCE */
++	unsigned char en;
++	/* Y - value table or Gain table */
++	enum ipipe_gbce_type type;
++	/* ptr to LUT for GBCE with 1024 entries */
++	unsigned short *table;
++};
++
++/* Chrominance position. Applicable only for YCbCr input
++ * Applied after edge enhancement
++ */
++enum ipipe_chr_pos {
++	/* Cositing, same position with luminance */
++	IPIPE_YUV422_CHR_POS_COSITE,
++	/* Centering, In the middle of luminance */
++	IPIPE_YUV422_CHR_POS_CENTRE
++};
++
++/* Struct for configuring yuv422 conversion module */
++struct prev_yuv422_conv {
++	/* Max Chrominance value */
++	unsigned char en_chrom_lpf;
++	/* 1 - enable LPF for chrminance, 0 - disable */
++	enum ipipe_chr_pos chrom_pos;
++};
++
++#define MAX_SIZE_YEE_LUT 1024
++
++enum ipipe_yee_merge_meth {
++	IPIPE_YEE_ABS_MAX,
++	IPIPE_YEE_EE_ES
++};
++
++/* Struct for configuring YUV Edge Enhancement module */
++struct prev_yee {
++	/* 1 - enable enhancement, 0 - disable */
++	unsigned char en;
++	/* enable/disable halo reduction in edge sharpner */
++	unsigned char en_halo_red;
++	/* Merge method between Edge Enhancer and Edge sharpner */
++	enum ipipe_yee_merge_meth merge_meth;
++	/* HPF Shift length */
++	unsigned char hpf_shft;
++	/* HPF Coefficient 00, S10 */
++	short hpf_coef_00;
++	/* HPF Coefficient 01, S10 */
++	short hpf_coef_01;
++	/* HPF Coefficient 02, S10 */
++	short hpf_coef_02;
++	/* HPF Coefficient 10, S10 */
++	short hpf_coef_10;
++	/* HPF Coefficient 11, S10 */
++	short hpf_coef_11;
++	/* HPF Coefficient 12, S10 */
++	short hpf_coef_12;
++	/* HPF Coefficient 20, S10 */
++	short hpf_coef_20;
++	/* HPF Coefficient 21, S10 */
++	short hpf_coef_21;
++	/* HPF Coefficient 22, S10 */
++	short hpf_coef_22;
++	/* Lower threshold before refering to LUT */
++	unsigned short yee_thr;
++	/* Edge sharpener Gain */
++	unsigned short es_gain;
++	/* Edge sharpener lowe threshold */
++	unsigned short es_thr1;
++	/* Edge sharpener upper threshold */
++	unsigned short es_thr2;
++	/* Edge sharpener gain on gradient */
++	unsigned short es_gain_grad;
++	/* Edge sharpener offset on gradient */
++	unsigned short es_ofst_grad;
++	/* Ptr to EE table. Must have 1024 entries */
++	short *table;
++};
++
++enum ipipe_car_meth {
++	/* Chromatic Gain Control */
++	IPIPE_CAR_CHR_GAIN_CTRL,
++	/* Dynamic switching between CHR_GAIN_CTRL
++	 * and MED_FLTR
++	 */
++	IPIPE_CAR_DYN_SWITCH,
++	/* Median Filter */
++	IPIPE_CAR_MED_FLTR
++};
++
++enum ipipe_car_hpf_type {
++	IPIPE_CAR_HPF_Y,
++	IPIPE_CAR_HPF_H,
++	IPIPE_CAR_HPF_V,
++	IPIPE_CAR_HPF_2D,
++	/* 2D HPF from YUV Edge Enhancement */
++	IPIPE_CAR_HPF_2D_YEE
++};
++
++struct ipipe_car_gain {
++	/* csup_gain */
++	unsigned char gain;
++	/* csup_shf. */
++	unsigned char shft;
++	/* gain minimum */
++	unsigned short gain_min;
++};
++
++/* Structure for Chromatic Artifact Reduction */
++struct prev_car {
++	/* enable/disable */
++	unsigned char en;
++	/* Gain control or Dynamic switching */
++	enum ipipe_car_meth meth;
++	/* Gain1 function configuration for Gain control */
++	struct ipipe_car_gain gain1;
++	/* Gain2 function configuration for Gain control */
++	struct ipipe_car_gain gain2;
++	/* HPF type used for CAR */
++	enum ipipe_car_hpf_type hpf;
++	/* csup_thr: HPF threshold for Gain control */
++	unsigned char hpf_thr;
++	/* Down shift value for hpf. 2 bits */
++	unsigned char hpf_shft;
++	/* switch limit for median filter */
++	unsigned char sw0;
++	/* switch coefficient for Gain control */
++	unsigned char sw1;
++};
++
++/* structure for Chromatic Gain Suppression */
++struct prev_cgs {
++	/* enable/disable */
++	unsigned char en;
++	/* gain1 bright side threshold */
++	unsigned char h_thr;
++	/* gain1 bright side slope */
++	unsigned char h_slope;
++	/* gain1 down shift value for bright side */
++	unsigned char h_shft;
++	/* gain1 bright side minimum gain */
++	unsigned char h_min;
++};
++
++/* various pixel formats supported */
++enum ipipe_pix_formats {
++	IPIPE_BAYER_8BIT_PACK,
++	IPIPE_BAYER_8BIT_PACK_ALAW,
++	IPIPE_BAYER_8BIT_PACK_DPCM,
++	IPIPE_BAYER_12BIT_PACK,
++	IPIPE_BAYER,		/* 16 bit */
++	IPIPE_UYVY,
++	IPIPE_YUYV,
++	IPIPE_RGB565,
++	IPIPE_RGB888,
++	IPIPE_YUV420SP,
++	IPIPE_420SP_Y,
++	IPIPE_420SP_C
++};
++
++enum ipipe_dpaths_bypass_t {
++	IPIPE_BYPASS_OFF,
++	IPIPE_BYPASS_ON
++};
++
++enum ipipe_colpat_t {
++	IPIPE_RED,
++	IPIPE_GREEN_RED,
++	IPIPE_GREEN_BLUE,
++	IPIPE_BLUE
++};
++
++enum down_scale_ave_sz {
++	IPIPE_DWN_SCALE_1_OVER_2,
++	IPIPE_DWN_SCALE_1_OVER_4,
++	IPIPE_DWN_SCALE_1_OVER_8,
++	IPIPE_DWN_SCALE_1_OVER_16,
++	IPIPE_DWN_SCALE_1_OVER_32,
++	IPIPE_DWN_SCALE_1_OVER_64,
++	IPIPE_DWN_SCALE_1_OVER_128,
++	IPIPE_DWN_SCALE_1_OVER_256
++};
++
++/* Max pixels allowed in the input. If above this either decimation
++ * or frame division mode to be enabled
++ */
++#define IPIPE_MAX_INPUT_WIDTH 2600
++
++/* Max pixels in resizer - A output. In downscale
++ * (DSCALE) mode, image quality is better, but has lesser
++ * maximum width allowed
++ */
++#define IPIPE_MAX_OUTPUT1_WIDTH_NORMAL 2176
++#define IPIPE_MAX_OUTPUT1_WIDTH_DSCALE 1088
++
++/* Max pixels in resizer - B output. In downscale
++ * (DSCALE) mode, image quality is better, but has lesser
++ * maximum width allowed
++ */
++#define IPIPE_MAX_OUTPUT2_WIDTH_NORMAL 1088
++#define IPIPE_MAX_OUTPUT2_WIDTH_DSCALE 544
++
++/* Structure for configuring Single Shot mode in the previewer
++ *   channel
++ */
++struct prev_ss_input_spec {
++	/* width of the image in SDRAM. */
++	unsigned int image_width;
++	/* height of the image in SDRAM */
++	unsigned int image_height;
++	/* line length. This will allow application to set a
++	 * different line length than that calculated based on
++	 * width. Set it to zero, if not used,
++	 */
++	unsigned int line_length;
++	/* vertical start position of the image
++	 * data to IPIPE
++	 */
++	unsigned int vst;
++	/* horizontal start position of the image
++	 * data to IPIPE
++	 */
++	unsigned int hst;
++	/* Global frame HD rate */
++	unsigned int ppln;
++	/* Global frame VD rate */
++	unsigned int lpfr;
++	/* dpcm predicator selection */
++	enum ipipeif_dpcm_pred pred;
++	/* clock divide to bring down the pixel clock */
++	struct ipipeif_5_1_clkdiv clk_div;
++	/* Shift data as per image sensor capture format
++	 * only applicable for RAW Bayer inputs
++	 */
++	enum ipipeif_5_1_data_shift data_shift;
++	/* Enable decimation 1 - enable, 0 - disable
++	 * This is used when image width is greater than
++	 * ipipe line buffer size
++	 */
++	enum ipipeif_decimation dec_en;
++	/* used when en_dec = 1. Resize ratio for decimation
++	 * when frame size is  greater than what hw can handle.
++	 * 16 to 112. IPIPE input width is calculated as follows.
++	 * width = image_width * 16/ipipeif_rsz. For example
++	 * if image_width is 1920 and user want to scale it down
++	 * to 1280, use ipipeif_rsz = 24. 1920*16/24 = 1280
++	 */
++	unsigned char rsz;
++	/* When input image width is greater that line buffer
++	 * size, use this to do resize using frame division. The
++	 * frame is divided into two vertical slices and resize
++	 * is performed on each slice. Use either frame division
++	 *  mode or decimation, NOT both
++	 */
++	unsigned char frame_div_mode_en;
++	/* Enable/Disable avg filter at IPIPEIF.
++	 * 1 - enable, 0 - disable
++	 */
++	unsigned char avg_filter_en;
++	/* Simple defect pixel correction based on a threshold value */
++	struct ipipeif_dpc dpc;
++	/* gain applied to the ipipeif output */
++	unsigned short gain;
++	/* clipped to this value at the ipipeif */
++	unsigned short clip;
++	/* Align HSync and VSync to rsz_start */
++	unsigned char align_sync;
++	/* ipipeif resize start position */
++	unsigned int rsz_start;
++	/* Input pixels formats
++	 */
++	enum ipipe_pix_formats pix_fmt;
++	/* pix order for YUV */
++	enum ipipeif_pixel_order pix_order;
++	/* Color pattern for odd line, odd pixel */
++	enum ipipe_colpat_t colp_olop;
++	/* Color pattern for odd line, even pixel */
++	enum ipipe_colpat_t colp_olep;
++	/* Color pattern for even line, odd pixel */
++	enum ipipe_colpat_t colp_elop;
++	/* Color pattern for even line, even pixel */
++	enum ipipe_colpat_t colp_elep;
++};
++
++struct prev_ss_output_spec {
++	/* output pixel format */
++	enum ipipe_pix_formats pix_fmt;
++};
++
++struct prev_single_shot_config {
++	/* Bypass image processing. RAW -> RAW */
++	enum ipipe_dpaths_bypass_t bypass;
++	/* Input specification for the image data */
++	struct prev_ss_input_spec input;
++	/* Output specification for the image data */
++	struct prev_ss_output_spec output;
++};
++
++struct prev_cont_input_spec {
++	/* 1 - enable, 0 - disable df subtraction */
++	unsigned char en_df_sub;
++	/* DF gain enable */
++	unsigned char en_df_gain;
++	/* DF gain value */
++	unsigned int df_gain;
++	/* DF gain threshold value */
++	unsigned short df_gain_thr;
++	/* Enable decimation 1 - enable, 0 - disable
++	 * This is used for bringing down the line size
++	 * to that supported by IPIPE. DM355 IPIPE
++	 * can process only 1344 pixels per line.
++	 */
++	enum ipipeif_decimation dec_en;
++	/* used when en_dec = 1. Resize ratio for decimation
++	 * when frame size is  greater than what hw can handle.
++	 * 16 to 112. IPIPE input width is calculated as follows.
++	 * width = image_width * 16/ipipeif_rsz. For example
++	 * if image_width is 1920 and user want to scale it down
++	 * to 1280, use ipipeif_rsz = 24. 1920*16/24 = 1280
++	 */
++	unsigned char rsz;
++	/* Enable/Disable avg filter at IPIPEIF.
++	 * 1 - enable, 0 - disable
++	 */
++	unsigned char avg_filter_en;
++	/* Gain applied at IPIPEIF. 1 - 1023. divided by 512.
++	 * So can be from 1/512 to  1/1023.
++	 */
++	unsigned short gain;
++	/* clipped to this value at the output of IPIPEIF */
++	unsigned short clip;
++	/* Align HSync and VSync to rsz_start */
++	unsigned char align_sync;
++	/* ipipeif resize start position */
++	unsigned int rsz_start;
++	/* Simple defect pixel correction based on a threshold value */
++	struct ipipeif_dpc dpc;
++	/* Color pattern for odd line, odd pixel */
++	enum ipipe_colpat_t colp_olop;
++	/* Color pattern for odd line, even pixel */
++	enum ipipe_colpat_t colp_olep;
++	/* Color pattern for even line, odd pixel */
++	enum ipipe_colpat_t colp_elop;
++	/* Color pattern for even line, even pixel */
++	enum ipipe_colpat_t colp_elep;
++};
++
++/* Structure for configuring Continuous mode in the previewer
++ * channel . In continuous mode, only following parameters are
++ * available for configuration from user. Rest are configured
++ * through S_CROP and S_FMT IOCTLs in CCDC driver. In this mode
++ * data to IPIPEIF comes from CCDC
++ */
++struct prev_continuous_config {
++	/* Bypass image processing. RAW -> RAW */
++	enum ipipe_dpaths_bypass_t bypass;
++	/* Input specification for the image data */
++	struct prev_cont_input_spec input;
++};
++
++/*******************************************************************
++**  Resizer API structures
++*******************************************************************/
++/* Interpolation types used for horizontal rescale */
++enum rsz_intp_t {
++	RSZ_INTP_CUBIC,
++	RSZ_INTP_LINEAR
++};
++
++/* Horizontal LPF intensity selection */
++enum rsz_h_lpf_lse_t {
++	RSZ_H_LPF_LSE_INTERN,
++	RSZ_H_LPF_LSE_USER_VAL
++};
++
++/* Structure for configuring resizer in single shot mode.
++ * This structure is used when operation mode of the
++ * resizer is single shot. The related IOCTL is
++ * RSZ_S_CONFIG & RSZ_G_CONFIG. When chained, data to
++ * resizer comes from previewer. When not chained, only
++ * UYVY data input is allowed for resizer operation.
++ * To operate on RAW Bayer data from CCDC, chain resizer
++ * with previewer by setting chain field in the
++ * rsz_channel_config structure.
++ */
++
++struct rsz_ss_input_spec {
++	/* width of the image in SDRAM. */
++	unsigned int image_width;
++	/* height of the image in SDRAM */
++	unsigned int image_height;
++	/* line length. This will allow application to set a
++	 * different line length than that calculated based on
++	 * width. Set it to zero, if not used,
++	 */
++	unsigned int line_length;
++	/* vertical start position of the image
++	 * data to IPIPE
++	 */
++	unsigned int vst;
++	/* horizontal start position of the image
++	 * data to IPIPE
++	 */
++	unsigned int hst;
++	/* Global frame HD rate */
++	unsigned int ppln;
++	/* Global frame VD rate */
++	unsigned int lpfr;
++	/* clock divide to bring down the pixel clock */
++	struct ipipeif_5_1_clkdiv clk_div;
++	/* Enable decimation 1 - enable, 0 - disable.
++	 * Used when input image width is greater than ipipe
++	 * line buffer size, this is enabled to do resize
++	 * at the input of the IPIPE to clip the size
++	 */
++	enum ipipeif_decimation dec_en;
++	/* used when en_dec = 1. Resize ratio for decimation
++	 * when frame size is  greater than what hw can handle.
++	 * 16 to 112. IPIPE input width is calculated as follows.
++	 * width = image_width * 16/ipipeif_rsz. For example
++	 * if image_width is 1920 and user want to scale it down
++	 * to 1280, use ipipeif_rsz = 24. 1920*16/24 = 1280
++	 */
++	unsigned char rsz;
++	/* When input image width is greater that line buffer
++	 * size, use this to do resize using frame division. The
++	 * frame is divided into two vertical slices and resize
++	 * is performed on each slice
++	 */
++	unsigned char frame_div_mode_en;
++	/* Enable/Disable avg filter at IPIPEIF.
++	 * 1 - enable, 0 - disable
++	 */
++	unsigned char avg_filter_en;
++	/* Align HSync and VSync to rsz_start */
++	unsigned char align_sync;
++	/* ipipeif resize start position */
++	unsigned int rsz_start;
++	/* Input pixels formats
++	 */
++	enum ipipe_pix_formats pix_fmt;
++};
++
++struct rsz_output_spec {
++	/* enable the resizer output */
++	unsigned char enable;
++	/* output pixel format. Has to be UYVY */
++	enum ipipe_pix_formats pix_fmt;
++	/* enable horizontal flip */
++	unsigned char h_flip;
++	/* enable vertical flip */
++	unsigned char v_flip;
++	/* width in pixels. must be multiple of 16. */
++	unsigned int width;
++	/* height in lines */
++	unsigned int height;
++	/* line start offset for y. */
++	unsigned int vst_y;
++	/* line start offset for c. Only for 420 */
++	unsigned int vst_c;
++	/* vertical rescale interpolation type, YCbCr or Luminance */
++	enum rsz_intp_t v_typ_y;
++	/* vertical rescale interpolation type for Chrominance */
++	enum rsz_intp_t v_typ_c;
++	/* vertical lpf intensity - Luminance */
++	unsigned char v_lpf_int_y;
++	/* vertical lpf intensity - Chrominance */
++	unsigned char v_lpf_int_c;
++	/* horizontal rescale interpolation types, YCbCr or Luminance  */
++	enum rsz_intp_t h_typ_y;
++	/* horizontal rescale interpolation types, Chrominance */
++	enum rsz_intp_t h_typ_c;
++	/* horizontal lpf intensity - Luminance */
++	unsigned char h_lpf_int_y;
++	/* horizontal lpf intensity - Chrominance */
++	unsigned char h_lpf_int_c;
++	/* Use down scale mode for scale down */
++	unsigned char en_down_scale;
++	/* if downscale, set the downscale more average size for horizontal
++	 * direction. Used only if output width and height is less than
++	 * input sizes
++	 */
++	enum down_scale_ave_sz h_dscale_ave_sz;
++	/* if downscale, set the downscale more average size for vertical
++	 * direction. Used only if output width and height is less than
++	 * input sizes
++	 */
++	enum down_scale_ave_sz v_dscale_ave_sz;
++	/* Y offset. If set, the offset would be added to the base address
++	 */
++	unsigned int user_y_ofst;
++	/* C offset. If set, the offset would be added to the base address
++	 */
++	unsigned int user_c_ofst;
++};
++
++/* In continuous mode, few parameters are set by ccdc driver. So only
++ * part of the output spec is available for user configuration
++ */
++struct rsz_part_output_spec {
++	/* enable the resizer output */
++	unsigned char enable;
++	/* enable horizontal flip */
++	unsigned char h_flip;
++	/* vertical rescale interpolation type, YCbCr or Luminance */
++	unsigned char v_flip;
++	/* vertical rescale interpolation type for Chrominance */
++	enum rsz_intp_t v_typ_y;
++	/* vertical rescale interpolation types  */
++	enum rsz_intp_t v_typ_c;
++	/* vertical lpf intensity - Luminance */
++	unsigned char v_lpf_int_y;
++	/* horizontal rescale interpolation types, YCbCr or Luminance  */
++	unsigned char v_lpf_int_c;
++	/* horizontal rescale interpolation types, Chrominance */
++	enum rsz_intp_t h_typ_y;
++	/* vertical lpf intensity - Chrominance */
++	enum rsz_intp_t h_typ_c;
++	/* horizontal lpf intensity - Luminance */
++	unsigned char h_lpf_int_y;
++	/* Use down scale mode for scale down */
++	unsigned char h_lpf_int_c;
++	/* horizontal lpf intensity - Chrominance */
++	unsigned char en_down_scale;
++	/* if downscale, set the downscale more average size for horizontal
++	 * direction. Used only if output width and height is less than
++	 * input sizes
++	 */
++	enum down_scale_ave_sz h_dscale_ave_sz;
++	/* if downscale, set the downscale more average size for vertical
++	 * direction. Used only if output width and height is less than
++	 * input sizes
++	 */
++	enum down_scale_ave_sz v_dscale_ave_sz;
++	/* Y offset. If set, the offset would be added to the base address
++	 */
++	unsigned int user_y_ofst;
++	/* C offset. If set, the offset would be added to the base address
++	 */
++	unsigned int user_c_ofst;
++};
++
++struct rsz_single_shot_config {
++	/* input spec of the image data (UYVY). non-chained
++	 * mode. Only valid when not chained. For chained
++	 * operation, previewer settings are used
++	 */
++	struct rsz_ss_input_spec input;
++	/* output spec of the image data coming out of resizer - 0(UYVY).
++	 */
++	struct rsz_output_spec output1;
++	/* output spec of the image data coming out of resizer - 1(UYVY).
++	 */
++	struct rsz_output_spec output2;
++	/* 0 , chroma sample at odd pixel, 1 - even pixel */
++	unsigned char chroma_sample_even;
++	unsigned char yuv_y_min;
++	unsigned char yuv_y_max;
++	unsigned char yuv_c_min;
++	unsigned char yuv_c_max;
++	enum ipipe_chr_pos out_chr_pos;
++};
++
++struct rsz_continuous_config {
++	/* A subset of output spec is configured by application.
++	 * Others such as size, position etc are set by CCDC driver
++	 */
++	struct rsz_part_output_spec output1;
++	struct rsz_output_spec output2;
++	/* output spec of the image data coming out of resizer - 1(UYVY).
++	 */
++	unsigned char chroma_sample_even;
++	/* 0 , chroma sample at odd pixel, 1 - even pixel */
++	unsigned char yuv_y_min;
++	unsigned char yuv_y_max;
++	unsigned char yuv_c_min;
++	unsigned char yuv_c_max;
++	enum ipipe_chr_pos out_chr_pos;
++};
++
++#ifdef __KERNEL__
++#include <media/davinci/imp_common.h>
++
++/* Used for driver storage */
++struct ipipe_otfdpc_2_0 {
++	/* 0 - disable, 1 - enable */
++	unsigned char en;
++	/* defect detection method */
++	enum ipipe_otfdpc_det_meth det_method;
++	/* Algorith used. Applicable only when IPIPE_DPC_OTF_MIN_MAX2 is
++	 * used
++	 */
++	enum ipipe_otfdpc_alg alg;
++	struct prev_otfdpc_2_0 otfdpc_2_0;
++};
++
++struct ipipe_otfdpc_3_0 {
++	/* 0 - disable, 1 - enable */
++	unsigned char en;
++	/* defect detection method */
++	enum ipipe_otfdpc_det_meth det_method;
++	/* Algorith used. Applicable only when IPIPE_DPC_OTF_MIN_MAX2 is
++	 * used
++	 */
++	enum ipipe_otfdpc_alg alg;
++	struct prev_otfdpc_3_0 otfdpc_3_0;
++};
++
++enum enable_disable_t {
++	DISABLE,
++	ENABLE
++};
++
++#define CEIL(a, b)	(((a) + (b-1)) / (b))
++#define IPIPE_MAX_PASSES	2
++
++struct f_div_pass {
++	unsigned int o_hsz;
++	unsigned int i_hps;
++	unsigned int h_phs;
++	unsigned int src_hps;
++	unsigned int src_hsz;
++};
++
++struct f_div_param {
++	unsigned char en;
++	unsigned int num_passes;
++	struct f_div_pass pass[IPIPE_MAX_PASSES];
++};
++
++/* Resizer Rescale Parameters*/
++struct ipipe_rsz_rescale_param {
++	enum ipipe_oper_mode mode;
++	enum enable_disable_t h_flip;
++	enum enable_disable_t v_flip;
++	enum enable_disable_t cen;
++	enum enable_disable_t yen;
++	unsigned short i_vps;
++	unsigned short i_hps;
++	unsigned short o_vsz;
++	unsigned short o_hsz;
++	unsigned short v_phs_y;
++	unsigned short v_phs_c;
++	unsigned short v_dif;
++	/* resize method - Luminance */
++	enum rsz_intp_t v_typ_y;
++	/* resize method - Chrominance */
++	enum rsz_intp_t v_typ_c;
++	/* vertical lpf intensity - Luminance */
++	unsigned char v_lpf_int_y;
++	/* vertical lpf intensity - Chrominance */
++	unsigned char v_lpf_int_c;
++	unsigned short h_phs;
++	unsigned short h_dif;
++	/* resize method - Luminance */
++	enum rsz_intp_t h_typ_y;
++	/* resize method - Chrominance */
++	enum rsz_intp_t h_typ_c;
++	/* horizontal lpf intensity - Luminance */
++	unsigned char h_lpf_int_y;
++	/* horizontal lpf intensity - Chrominance */
++	unsigned char h_lpf_int_c;
++	enum enable_disable_t dscale_en;
++	enum down_scale_ave_sz h_dscale_ave_sz;
++	enum down_scale_ave_sz v_dscale_ave_sz;
++	/* store the calculated frame division parameter */
++	struct f_div_param f_div;
++};
++
++enum ipipe_rsz_rgb_t {
++	OUTPUT_32BIT,
++	OUTPUT_16BIT
++};
++
++enum ipipe_rsz_rgb_msk_t {
++	NOMASK,
++	MASKLAST2
++};
++
++/* Resizer RGB Conversion Parameters */
++struct ipipe_rsz_resize2rgb {
++	enum enable_disable_t rgb_en;
++	enum ipipe_rsz_rgb_t rgb_typ;
++	enum ipipe_rsz_rgb_msk_t rgb_msk0;
++	enum ipipe_rsz_rgb_msk_t rgb_msk1;
++	unsigned int rgb_alpha_val;
++};
++
++/* Resizer External Memory Parameters */
++struct ipipe_ext_mem_param {
++	unsigned int rsz_sdr_oft_y;
++	unsigned int rsz_sdr_ptr_s_y;
++	unsigned int rsz_sdr_ptr_e_y;
++	unsigned int rsz_sdr_oft_c;
++	unsigned int rsz_sdr_ptr_s_c;
++	unsigned int rsz_sdr_ptr_e_c;
++	/* offset to be added to buffer start when flipping for y/ycbcr */
++	unsigned int flip_ofst_y;
++	/* offset to be added to buffer start when flipping for c */
++	unsigned int flip_ofst_c;
++	/* c offset for YUV 420SP */
++	unsigned int c_offset;
++	/* User Defined Y offset for YUV 420SP or YUV420ILE data */
++	unsigned int user_y_ofst;
++	/* User Defined C offset for YUV 420SP data */
++	unsigned int user_c_ofst;
++};
++
++enum rsz_data_source {
++	IPIPE_DATA,
++	IPIPEIF_DATA
++};
++
++/* data paths */
++enum ipipe_data_paths {
++	IPIPE_RAW2YUV,
++	/* Bayer RAW input to YCbCr output */
++	IPIPE_RAW2RAW,
++	/* Bayer Raw to Bayer output */
++	IPIPE_RAW2BOX,
++	/* Bayer Raw to Boxcar output */
++	IPIPE_YUV2YUV
++	/* YUV Raw to YUV Raw output */
++};
++
++enum rsz_src_img_fmt {
++	RSZ_IMG_422,
++	RSZ_IMG_420
++};
++
++struct rsz_common_params {
++	unsigned int vps;
++	unsigned int vsz;
++	unsigned int hps;
++	unsigned int hsz;
++	/* 420 or 422 */
++	enum rsz_src_img_fmt src_img_fmt;
++	/* Y or C when src_fmt is 420, 0 - y, 1 - c */
++	unsigned char y_c;
++	/* flip raw or ycbcr */
++	unsigned char raw_flip;
++	/* IPIPE or IPIPEIF data */
++	enum rsz_data_source source;
++	enum ipipe_dpaths_bypass_t passthrough;
++	unsigned char yuv_y_min;
++	unsigned char yuv_y_max;
++	unsigned char yuv_c_min;
++	unsigned char yuv_c_max;
++	enum enable_disable_t rsz_seq_crv;
++	enum ipipe_chr_pos out_chr_pos;
++};
++
++struct ipipe_params {
++	struct ipipeif ipipeif_param;
++	enum ipipe_oper_mode ipipe_mode;
++	/* input/output datapath through IPIPE */
++	enum ipipe_data_paths ipipe_dpaths_fmt;
++	/* color pattern register */
++	enum ipipe_colpat_t ipipe_colpat_elep;
++	enum ipipe_colpat_t ipipe_colpat_elop;
++	enum ipipe_colpat_t ipipe_colpat_olep;
++	enum ipipe_colpat_t ipipe_colpat_olop;
++	/* horizontal/vertical start, horizontal/vertical size
++	 * for both IPIPE and RSZ input
++	 */
++	unsigned int ipipe_vps;
++	unsigned int ipipe_vsz;
++	unsigned int ipipe_hps;
++	unsigned int ipipe_hsz;
++
++	struct rsz_common_params rsz_common;
++	struct ipipe_rsz_rescale_param rsz_rsc_param[2];
++	struct ipipe_rsz_resize2rgb rsz2rgb[2];
++	struct ipipe_ext_mem_param ext_mem_param[2];
++	enum enable_disable_t rsz_en[2];
++
++};
++
++void ipipe_hw_dump_config(void);
++int ipipe_hw_setup(struct ipipe_params *config);
++int ipipe_set_lutdpc_regs(struct prev_lutdpc *lutdpc);
++int ipipe_set_otfdpc_regs(struct prev_otfdpc *otfdpc);
++int ipipe_set_d2f_regs(unsigned int id, struct prev_nf *noise_filter);
++int ipipe_set_wb_regs(struct prev_wb *wb);
++int ipipe_set_gic_regs(struct prev_gic *gic);
++int ipipe_set_cfa_regs(struct prev_cfa *cfa);
++int ipipe_set_rgb2rgb_regs(unsigned int id, struct prev_rgb2rgb *rgb);
++int ipipe_set_gamma_regs(struct prev_gamma *gamma);
++int ipipe_set_3d_lut_regs(struct prev_3d_lut *lut_3d);
++int ipipe_set_lum_adj_regs(struct prev_lum_adj *lum_adj);
++int ipipe_set_rgb2ycbcr_regs(struct prev_rgb2yuv *yuv);
++int ipipe_set_yuv422_conv_regs(struct prev_yuv422_conv *conv);
++int ipipe_set_gbce_regs(struct prev_gbce *gbce);
++int ipipe_set_ee_regs(struct prev_yee *ee);
++int ipipe_set_car_regs(struct prev_car *car);
++int ipipe_set_cgs_regs(struct prev_cgs *cgs);
++int rsz_enable(int rsz_id, int enable);
++void rsz_src_enable(int enable);
++int rsz_set_output_address(struct ipipe_params *params,
++			      int resize_no, unsigned int address);
++int rsz_set_in_pix_format(unsigned char y_c);
++
++#endif
++#endif
+--- /dev/null
++++ b/arch/arm/configs/davinci_dm646x_defconfig
+@@ -0,0 +1,1956 @@
++#
++# Automatically generated make config: don't edit
++# Linux kernel version: 2.6.32-rc2-davinci1
++# Wed Oct 14 16:30:05 2009
++#
++CONFIG_ARM=y
++CONFIG_SYS_SUPPORTS_APM_EMULATION=y
++CONFIG_GENERIC_GPIO=y
++CONFIG_GENERIC_TIME=y
++CONFIG_GENERIC_CLOCKEVENTS=y
++CONFIG_GENERIC_HARDIRQS=y
++CONFIG_STACKTRACE_SUPPORT=y
++CONFIG_HAVE_LATENCYTOP_SUPPORT=y
++CONFIG_LOCKDEP_SUPPORT=y
++CONFIG_TRACE_IRQFLAGS_SUPPORT=y
++CONFIG_HARDIRQS_SW_RESEND=y
++CONFIG_GENERIC_IRQ_PROBE=y
++CONFIG_RWSEM_GENERIC_SPINLOCK=y
++CONFIG_GENERIC_HWEIGHT=y
++CONFIG_GENERIC_CALIBRATE_DELAY=y
++CONFIG_ZONE_DMA=y
++CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
++CONFIG_VECTORS_BASE=0xffff0000
++CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
++CONFIG_CONSTRUCTORS=y
++
++#
++# General setup
++#
++CONFIG_EXPERIMENTAL=y
++CONFIG_BROKEN_ON_SMP=y
++CONFIG_LOCK_KERNEL=y
++CONFIG_INIT_ENV_ARG_LIMIT=32
++CONFIG_LOCALVERSION=""
++CONFIG_LOCALVERSION_AUTO=y
++# CONFIG_SWAP is not set
++CONFIG_SYSVIPC=y
++CONFIG_SYSVIPC_SYSCTL=y
++CONFIG_POSIX_MQUEUE=y
++CONFIG_POSIX_MQUEUE_SYSCTL=y
++# CONFIG_BSD_PROCESS_ACCT is not set
++# CONFIG_TASKSTATS is not set
++# CONFIG_AUDIT is not set
++
++#
++# RCU Subsystem
++#
++CONFIG_TREE_RCU=y
++# CONFIG_TREE_PREEMPT_RCU is not set
++# CONFIG_RCU_TRACE is not set
++CONFIG_RCU_FANOUT=32
++# CONFIG_RCU_FANOUT_EXACT is not set
++# CONFIG_TREE_RCU_TRACE is not set
++CONFIG_IKCONFIG=y
++CONFIG_IKCONFIG_PROC=y
++CONFIG_LOG_BUF_SHIFT=14
++CONFIG_GROUP_SCHED=y
++CONFIG_FAIR_GROUP_SCHED=y
++# CONFIG_RT_GROUP_SCHED is not set
++CONFIG_USER_SCHED=y
++# CONFIG_CGROUP_SCHED is not set
++# CONFIG_CGROUPS is not set
++# CONFIG_SYSFS_DEPRECATED_V2 is not set
++# CONFIG_RELAY is not set
++# CONFIG_NAMESPACES is not set
++CONFIG_BLK_DEV_INITRD=y
++CONFIG_INITRAMFS_SOURCE=""
++CONFIG_RD_GZIP=y
++# CONFIG_RD_BZIP2 is not set
++# CONFIG_RD_LZMA is not set
++CONFIG_CC_OPTIMIZE_FOR_SIZE=y
++CONFIG_SYSCTL=y
++CONFIG_ANON_INODES=y
++CONFIG_EMBEDDED=y
++CONFIG_UID16=y
++CONFIG_SYSCTL_SYSCALL=y
++CONFIG_KALLSYMS=y
++# CONFIG_KALLSYMS_ALL is not set
++# CONFIG_KALLSYMS_EXTRA_PASS is not set
++CONFIG_HOTPLUG=y
++CONFIG_PRINTK=y
++CONFIG_BUG=y
++CONFIG_ELF_CORE=y
++CONFIG_BASE_FULL=y
++CONFIG_FUTEX=y
++CONFIG_EPOLL=y
++CONFIG_SIGNALFD=y
++CONFIG_TIMERFD=y
++CONFIG_EVENTFD=y
++CONFIG_SHMEM=y
++CONFIG_AIO=y
++
++#
++# Kernel Performance Events And Counters
++#
++CONFIG_VM_EVENT_COUNTERS=y
++CONFIG_SLUB_DEBUG=y
++CONFIG_COMPAT_BRK=y
++# CONFIG_SLAB is not set
++CONFIG_SLUB=y
++# CONFIG_SLOB is not set
++# CONFIG_PROFILING is not set
++CONFIG_HAVE_OPROFILE=y
++# CONFIG_KPROBES is not set
++CONFIG_HAVE_KPROBES=y
++CONFIG_HAVE_KRETPROBES=y
++CONFIG_HAVE_CLK=y
++
++#
++# GCOV-based kernel profiling
++#
++# CONFIG_GCOV_KERNEL is not set
++# CONFIG_SLOW_WORK is not set
++CONFIG_HAVE_GENERIC_DMA_COHERENT=y
++CONFIG_SLABINFO=y
++CONFIG_RT_MUTEXES=y
++CONFIG_BASE_SMALL=0
++CONFIG_MODULES=y
++# CONFIG_MODULE_FORCE_LOAD is not set
++CONFIG_MODULE_UNLOAD=y
++CONFIG_MODULE_FORCE_UNLOAD=y
++CONFIG_MODVERSIONS=y
++# CONFIG_MODULE_SRCVERSION_ALL is not set
++CONFIG_BLOCK=y
++CONFIG_LBDAF=y
++# CONFIG_BLK_DEV_BSG is not set
++# CONFIG_BLK_DEV_INTEGRITY is not set
++
++#
++# IO Schedulers
++#
++CONFIG_IOSCHED_NOOP=y
++CONFIG_IOSCHED_AS=y
++# CONFIG_IOSCHED_DEADLINE is not set
++# CONFIG_IOSCHED_CFQ is not set
++CONFIG_DEFAULT_AS=y
++# CONFIG_DEFAULT_DEADLINE is not set
++# CONFIG_DEFAULT_CFQ is not set
++# CONFIG_DEFAULT_NOOP is not set
++CONFIG_DEFAULT_IOSCHED="anticipatory"
++# CONFIG_FREEZER is not set
++
++#
++# System Type
++#
++CONFIG_MMU=y
++# CONFIG_ARCH_AAEC2000 is not set
++# CONFIG_ARCH_INTEGRATOR is not set
++# CONFIG_ARCH_REALVIEW is not set
++# CONFIG_ARCH_VERSATILE is not set
++# CONFIG_ARCH_AT91 is not set
++# CONFIG_ARCH_CLPS711X is not set
++# CONFIG_ARCH_GEMINI is not set
++# CONFIG_ARCH_EBSA110 is not set
++# CONFIG_ARCH_EP93XX is not set
++# CONFIG_ARCH_FOOTBRIDGE is not set
++# CONFIG_ARCH_MXC is not set
++# CONFIG_ARCH_STMP3XXX is not set
++# CONFIG_ARCH_NETX is not set
++# CONFIG_ARCH_H720X is not set
++# CONFIG_ARCH_NOMADIK is not set
++# CONFIG_ARCH_IOP13XX is not set
++# CONFIG_ARCH_IOP32X is not set
++# CONFIG_ARCH_IOP33X is not set
++# CONFIG_ARCH_IXP23XX is not set
++# CONFIG_ARCH_IXP2000 is not set
++# CONFIG_ARCH_IXP4XX is not set
++# CONFIG_ARCH_L7200 is not set
++# CONFIG_ARCH_KIRKWOOD is not set
++# CONFIG_ARCH_LOKI is not set
++# CONFIG_ARCH_MV78XX0 is not set
++# CONFIG_ARCH_ORION5X is not set
++# CONFIG_ARCH_MMP is not set
++# CONFIG_ARCH_KS8695 is not set
++# CONFIG_ARCH_NS9XXX is not set
++# CONFIG_ARCH_W90X900 is not set
++# CONFIG_ARCH_PNX4008 is not set
++# CONFIG_ARCH_PXA is not set
++# CONFIG_ARCH_MSM is not set
++# CONFIG_ARCH_RPC is not set
++# CONFIG_ARCH_SA1100 is not set
++# CONFIG_ARCH_S3C2410 is not set
++# CONFIG_ARCH_S3C64XX is not set
++# CONFIG_ARCH_S5PC1XX is not set
++# CONFIG_ARCH_SHARK is not set
++# CONFIG_ARCH_LH7A40X is not set
++# CONFIG_ARCH_U300 is not set
++CONFIG_ARCH_DAVINCI=y
++# CONFIG_ARCH_OMAP is not set
++# CONFIG_ARCH_BCMRING is not set
++CONFIG_AINTC=y
++CONFIG_ARCH_DAVINCI_DMx=y
++
++#
++# TI DaVinci Implementations
++#
++
++#
++# DaVinci Core Type
++#
++# CONFIG_ARCH_DAVINCI_DM644x is not set
++# CONFIG_ARCH_DAVINCI_DM355 is not set
++CONFIG_ARCH_DAVINCI_DM646x=y
++# CONFIG_ARCH_DAVINCI_DA830 is not set
++# CONFIG_ARCH_DAVINCI_DA850 is not set
++# CONFIG_ARCH_DAVINCI_DM365 is not set
++
++#
++# DaVinci Board Type
++#
++CONFIG_MACH_DAVINCI_DM6467_EVM=y
++CONFIG_DAVINCI_MUX=y
++CONFIG_DAVINCI_MUX_DEBUG=y
++CONFIG_DAVINCI_MUX_WARNINGS=y
++CONFIG_DAVINCI_RESET_CLOCKS=y
++CONFIG_OSC_CLK_FREQ=27000000
++
++#
++# Processor Type
++#
++CONFIG_CPU_32=y
++CONFIG_CPU_ARM926T=y
++CONFIG_CPU_32v5=y
++CONFIG_CPU_ABRT_EV5TJ=y
++CONFIG_CPU_PABRT_NOIFAR=y
++CONFIG_CPU_CACHE_VIVT=y
++CONFIG_CPU_COPY_V4WB=y
++CONFIG_CPU_TLB_V4WBI=y
++CONFIG_CPU_CP15=y
++CONFIG_CPU_CP15_MMU=y
++
++#
++# Processor Features
++#
++CONFIG_ARM_THUMB=y
++# CONFIG_CPU_ICACHE_DISABLE is not set
++# CONFIG_CPU_DCACHE_DISABLE is not set
++# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
++# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
++CONFIG_ARM_L1_CACHE_SHIFT=5
++CONFIG_COMMON_CLKDEV=y
++CONFIG_FORCE_MAX_ZONEORDER=13
++
++#
++# Bus support
++#
++# CONFIG_PCI is not set
++# CONFIG_PCI_SYSCALL is not set
++# CONFIG_ARCH_SUPPORTS_MSI is not set
++# CONFIG_PCCARD is not set
++
++#
++# Kernel Features
++#
++CONFIG_TICK_ONESHOT=y
++CONFIG_NO_HZ=y
++CONFIG_HIGH_RES_TIMERS=y
++CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
++CONFIG_VMSPLIT_3G=y
++# CONFIG_VMSPLIT_2G is not set
++# CONFIG_VMSPLIT_1G is not set
++CONFIG_PAGE_OFFSET=0xC0000000
++# CONFIG_PREEMPT_NONE is not set
++# CONFIG_PREEMPT_VOLUNTARY is not set
++CONFIG_PREEMPT=y
++CONFIG_HZ=100
++CONFIG_AEABI=y
++# CONFIG_OABI_COMPAT is not set
++# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
++# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
++# CONFIG_HIGHMEM is not set
++CONFIG_SELECT_MEMORY_MODEL=y
++CONFIG_FLATMEM_MANUAL=y
++# CONFIG_DISCONTIGMEM_MANUAL is not set
++# CONFIG_SPARSEMEM_MANUAL is not set
++CONFIG_FLATMEM=y
++CONFIG_FLAT_NODE_MEM_MAP=y
++CONFIG_PAGEFLAGS_EXTENDED=y
++CONFIG_SPLIT_PTLOCK_CPUS=4096
++# CONFIG_PHYS_ADDR_T_64BIT is not set
++CONFIG_ZONE_DMA_FLAG=1
++CONFIG_BOUNCE=y
++CONFIG_VIRT_TO_BUS=y
++CONFIG_HAVE_MLOCK=y
++CONFIG_HAVE_MLOCKED_PAGE_BIT=y
++# CONFIG_KSM is not set
++CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
++CONFIG_LEDS=y
++# CONFIG_LEDS_CPU is not set
++CONFIG_ALIGNMENT_TRAP=y
++# CONFIG_UACCESS_WITH_MEMCPY is not set
++
++#
++# Boot options
++#
++CONFIG_ZBOOT_ROM_TEXT=0x0
++CONFIG_ZBOOT_ROM_BSS=0x0
++CONFIG_CMDLINE=""
++# CONFIG_XIP_KERNEL is not set
++# CONFIG_KEXEC is not set
++
++#
++# CPU Power Management
++#
++# CONFIG_CPU_IDLE is not set
++
++#
++# Floating point emulation
++#
++
++#
++# At least one emulation must be selected
++#
++# CONFIG_VFP is not set
++
++#
++# Userspace binary formats
++#
++CONFIG_BINFMT_ELF=y
++# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
++CONFIG_HAVE_AOUT=y
++# CONFIG_BINFMT_AOUT is not set
++# CONFIG_BINFMT_MISC is not set
++
++#
++# Power management options
++#
++# CONFIG_PM is not set
++CONFIG_ARCH_SUSPEND_POSSIBLE=y
++CONFIG_NET=y
++
++#
++# Networking options
++#
++CONFIG_PACKET=y
++# CONFIG_PACKET_MMAP is not set
++CONFIG_UNIX=y
++CONFIG_XFRM=y
++# CONFIG_XFRM_USER is not set
++# CONFIG_XFRM_SUB_POLICY is not set
++# CONFIG_XFRM_MIGRATE is not set
++# CONFIG_XFRM_STATISTICS is not set
++# CONFIG_NET_KEY is not set
++CONFIG_INET=y
++# CONFIG_IP_MULTICAST is not set
++# CONFIG_IP_ADVANCED_ROUTER is not set
++CONFIG_IP_FIB_HASH=y
++CONFIG_IP_PNP=y
++CONFIG_IP_PNP_DHCP=y
++# CONFIG_IP_PNP_BOOTP is not set
++# CONFIG_IP_PNP_RARP is not set
++# CONFIG_NET_IPIP is not set
++# CONFIG_NET_IPGRE is not set
++# CONFIG_ARPD is not set
++# CONFIG_SYN_COOKIES is not set
++# CONFIG_INET_AH is not set
++# CONFIG_INET_ESP is not set
++# CONFIG_INET_IPCOMP is not set
++# CONFIG_INET_XFRM_TUNNEL is not set
++CONFIG_INET_TUNNEL=m
++CONFIG_INET_XFRM_MODE_TRANSPORT=y
++CONFIG_INET_XFRM_MODE_TUNNEL=y
++CONFIG_INET_XFRM_MODE_BEET=y
++# CONFIG_INET_LRO is not set
++CONFIG_INET_DIAG=y
++CONFIG_INET_TCP_DIAG=y
++# CONFIG_TCP_CONG_ADVANCED is not set
++CONFIG_TCP_CONG_CUBIC=y
++CONFIG_DEFAULT_TCP_CONG="cubic"
++# CONFIG_TCP_MD5SIG is not set
++CONFIG_IPV6=m
++# CONFIG_IPV6_PRIVACY is not set
++# CONFIG_IPV6_ROUTER_PREF is not set
++# CONFIG_IPV6_OPTIMISTIC_DAD is not set
++# CONFIG_INET6_AH is not set
++# CONFIG_INET6_ESP is not set
++# CONFIG_INET6_IPCOMP is not set
++# CONFIG_IPV6_MIP6 is not set
++# CONFIG_INET6_XFRM_TUNNEL is not set
++# CONFIG_INET6_TUNNEL is not set
++CONFIG_INET6_XFRM_MODE_TRANSPORT=m
++CONFIG_INET6_XFRM_MODE_TUNNEL=m
++CONFIG_INET6_XFRM_MODE_BEET=m
++# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
++CONFIG_IPV6_SIT=m
++CONFIG_IPV6_NDISC_NODETYPE=y
++# CONFIG_IPV6_TUNNEL is not set
++# CONFIG_IPV6_MULTIPLE_TABLES is not set
++# CONFIG_IPV6_MROUTE is not set
++# CONFIG_NETWORK_SECMARK is not set
++CONFIG_NETFILTER=y
++# CONFIG_NETFILTER_DEBUG is not set
++CONFIG_NETFILTER_ADVANCED=y
++
++#
++# Core Netfilter Configuration
++#
++# CONFIG_NETFILTER_NETLINK_QUEUE is not set
++# CONFIG_NETFILTER_NETLINK_LOG is not set
++# CONFIG_NF_CONNTRACK is not set
++# CONFIG_NETFILTER_XTABLES is not set
++# CONFIG_IP_VS is not set
++
++#
++# IP: Netfilter Configuration
++#
++# CONFIG_NF_DEFRAG_IPV4 is not set
++# CONFIG_IP_NF_QUEUE is not set
++# CONFIG_IP_NF_IPTABLES is not set
++# CONFIG_IP_NF_ARPTABLES is not set
++
++#
++# IPv6: Netfilter Configuration
++#
++# CONFIG_IP6_NF_QUEUE is not set
++# CONFIG_IP6_NF_IPTABLES is not set
++# CONFIG_IP_DCCP is not set
++# CONFIG_IP_SCTP is not set
++# CONFIG_RDS is not set
++# CONFIG_TIPC is not set
++# CONFIG_ATM is not set
++# CONFIG_BRIDGE is not set
++# CONFIG_NET_DSA is not set
++# CONFIG_VLAN_8021Q is not set
++# CONFIG_DECNET is not set
++# CONFIG_LLC2 is not set
++# CONFIG_IPX is not set
++# CONFIG_ATALK is not set
++# CONFIG_X25 is not set
++# CONFIG_LAPB is not set
++# CONFIG_ECONET is not set
++# CONFIG_WAN_ROUTER is not set
++# CONFIG_PHONET is not set
++# CONFIG_IEEE802154 is not set
++# CONFIG_NET_SCHED is not set
++# CONFIG_DCB is not set
++
++#
++# Network testing
++#
++# CONFIG_NET_PKTGEN is not set
++# CONFIG_HAMRADIO is not set
++# CONFIG_CAN is not set
++# CONFIG_IRDA is not set
++# CONFIG_BT is not set
++# CONFIG_AF_RXRPC is not set
++# CONFIG_WIRELESS is not set
++# CONFIG_WIMAX is not set
++# CONFIG_RFKILL is not set
++# CONFIG_NET_9P is not set
++
++#
++# Device Drivers
++#
++
++#
++# Generic Driver Options
++#
++CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
++# CONFIG_DEVTMPFS is not set
++CONFIG_STANDALONE=y
++CONFIG_PREVENT_FIRMWARE_BUILD=y
++# CONFIG_FW_LOADER is not set
++# CONFIG_DEBUG_DRIVER is not set
++# CONFIG_DEBUG_DEVRES is not set
++# CONFIG_SYS_HYPERVISOR is not set
++# CONFIG_CONNECTOR is not set
++CONFIG_MTD=y
++# CONFIG_MTD_DEBUG is not set
++# CONFIG_MTD_TESTS is not set
++# CONFIG_MTD_CONCAT is not set
++CONFIG_MTD_PARTITIONS=y
++# CONFIG_MTD_REDBOOT_PARTS is not set
++# CONFIG_MTD_CMDLINE_PARTS is not set
++# CONFIG_MTD_AFS_PARTS is not set
++# CONFIG_MTD_AR7_PARTS is not set
++
++#
++# User Modules And Translation Layers
++#
++CONFIG_MTD_CHAR=y
++CONFIG_MTD_BLKDEVS=y
++CONFIG_MTD_BLOCK=y
++# CONFIG_FTL is not set
++# CONFIG_NFTL is not set
++# CONFIG_INFTL is not set
++# CONFIG_RFD_FTL is not set
++# CONFIG_SSFDC is not set
++# CONFIG_MTD_OOPS is not set
++
++#
++# RAM/ROM/Flash chip drivers
++#
++CONFIG_MTD_CFI=y
++# CONFIG_MTD_JEDECPROBE is not set
++CONFIG_MTD_GEN_PROBE=y
++# CONFIG_MTD_CFI_ADV_OPTIONS is not set
++CONFIG_MTD_MAP_BANK_WIDTH_1=y
++CONFIG_MTD_MAP_BANK_WIDTH_2=y
++CONFIG_MTD_MAP_BANK_WIDTH_4=y
++# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
++# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
++# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
++CONFIG_MTD_CFI_I1=y
++CONFIG_MTD_CFI_I2=y
++# CONFIG_MTD_CFI_I4 is not set
++# CONFIG_MTD_CFI_I8 is not set
++CONFIG_MTD_CFI_INTELEXT=y
++CONFIG_MTD_CFI_AMDSTD=y
++# CONFIG_MTD_CFI_STAA is not set
++CONFIG_MTD_CFI_UTIL=y
++# CONFIG_MTD_RAM is not set
++# CONFIG_MTD_ROM is not set
++# CONFIG_MTD_ABSENT is not set
++
++#
++# Mapping drivers for chip access
++#
++# CONFIG_MTD_COMPLEX_MAPPINGS is not set
++CONFIG_MTD_PHYSMAP=y
++# CONFIG_MTD_PHYSMAP_COMPAT is not set
++# CONFIG_MTD_ARM_INTEGRATOR is not set
++# CONFIG_MTD_PLATRAM is not set
++
++#
++# Self-contained MTD device drivers
++#
++# CONFIG_MTD_DATAFLASH is not set
++# CONFIG_MTD_M25P80 is not set
++# CONFIG_MTD_SST25L is not set
++# CONFIG_MTD_SLRAM is not set
++# CONFIG_MTD_PHRAM is not set
++# CONFIG_MTD_MTDRAM is not set
++# CONFIG_MTD_BLOCK2MTD is not set
++
++#
++# Disk-On-Chip Device Drivers
++#
++# CONFIG_MTD_DOC2000 is not set
++# CONFIG_MTD_DOC2001 is not set
++# CONFIG_MTD_DOC2001PLUS is not set
++CONFIG_MTD_NAND=y
++# CONFIG_MTD_NAND_VERIFY_WRITE is not set
++# CONFIG_MTD_NAND_ECC_SMC is not set
++# CONFIG_MTD_NAND_MUSEUM_IDS is not set
++# CONFIG_MTD_NAND_GPIO is not set
++CONFIG_MTD_NAND_IDS=y
++# CONFIG_MTD_NAND_DISKONCHIP is not set
++# CONFIG_MTD_NAND_NANDSIM is not set
++# CONFIG_MTD_NAND_PLATFORM is not set
++# CONFIG_MTD_ALAUDA is not set
++CONFIG_MTD_NAND_DAVINCI=y
++# CONFIG_MTD_ONENAND is not set
++
++#
++# LPDDR flash memory drivers
++#
++# CONFIG_MTD_LPDDR is not set
++
++#
++# UBI - Unsorted block images
++#
++# CONFIG_MTD_UBI is not set
++# CONFIG_PARPORT is not set
++CONFIG_BLK_DEV=y
++# CONFIG_BLK_DEV_COW_COMMON is not set
++CONFIG_BLK_DEV_LOOP=y
++# CONFIG_BLK_DEV_CRYPTOLOOP is not set
++# CONFIG_BLK_DEV_NBD is not set
++# CONFIG_BLK_DEV_UB is not set
++CONFIG_BLK_DEV_RAM=y
++CONFIG_BLK_DEV_RAM_COUNT=1
++CONFIG_BLK_DEV_RAM_SIZE=65536
++# CONFIG_BLK_DEV_XIP is not set
++# CONFIG_CDROM_PKTCDVD is not set
++# CONFIG_ATA_OVER_ETH is not set
++# CONFIG_MG_DISK is not set
++CONFIG_MISC_DEVICES=y
++# CONFIG_ICS932S401 is not set
++# CONFIG_ENCLOSURE_SERVICES is not set
++# CONFIG_ISL29003 is not set
++# CONFIG_C2PORT is not set
++
++#
++# EEPROM support
++#
++CONFIG_EEPROM_AT24=y
++CONFIG_EEPROM_AT25=y
++# CONFIG_EEPROM_LEGACY is not set
++# CONFIG_EEPROM_MAX6875 is not set
++# CONFIG_EEPROM_93CX6 is not set
++CONFIG_HAVE_IDE=y
++CONFIG_IDE=y
++
++#
++# Please see Documentation/ide/ide.txt for help/info on IDE drives
++#
++CONFIG_IDE_XFER_MODE=y
++CONFIG_IDE_TIMINGS=y
++# CONFIG_BLK_DEV_IDE_SATA is not set
++CONFIG_IDE_GD=y
++CONFIG_IDE_GD_ATA=y
++# CONFIG_IDE_GD_ATAPI is not set
++# CONFIG_BLK_DEV_IDECD is not set
++# CONFIG_BLK_DEV_IDETAPE is not set
++# CONFIG_IDE_TASK_IOCTL is not set
++CONFIG_IDE_PROC_FS=y
++
++#
++# IDE chipset support/bugfixes
++#
++# CONFIG_BLK_DEV_PLATFORM is not set
++CONFIG_BLK_DEV_IDEDMA_SFF=y
++CONFIG_BLK_DEV_PALMCHIP_BK3710=y
++CONFIG_BLK_DEV_IDEDMA=y
++
++#
++# SCSI device support
++#
++# CONFIG_RAID_ATTRS is not set
++CONFIG_SCSI=y
++CONFIG_SCSI_DMA=y
++# CONFIG_SCSI_TGT is not set
++# CONFIG_SCSI_NETLINK is not set
++CONFIG_SCSI_PROC_FS=y
++
++#
++# SCSI support type (disk, tape, CD-ROM)
++#
++CONFIG_BLK_DEV_SD=y
++# CONFIG_CHR_DEV_ST is not set
++# CONFIG_CHR_DEV_OSST is not set
++# CONFIG_BLK_DEV_SR is not set
++# CONFIG_CHR_DEV_SG is not set
++# CONFIG_CHR_DEV_SCH is not set
++# CONFIG_SCSI_MULTI_LUN is not set
++# CONFIG_SCSI_CONSTANTS is not set
++# CONFIG_SCSI_LOGGING is not set
++# CONFIG_SCSI_SCAN_ASYNC is not set
++CONFIG_SCSI_WAIT_SCAN=m
++
++#
++# SCSI Transports
++#
++# CONFIG_SCSI_SPI_ATTRS is not set
++# CONFIG_SCSI_FC_ATTRS is not set
++# CONFIG_SCSI_ISCSI_ATTRS is not set
++# CONFIG_SCSI_SAS_LIBSAS is not set
++# CONFIG_SCSI_SRP_ATTRS is not set
++CONFIG_SCSI_LOWLEVEL=y
++# CONFIG_ISCSI_TCP is not set
++# CONFIG_LIBFC is not set
++# CONFIG_LIBFCOE is not set
++# CONFIG_SCSI_DEBUG is not set
++# CONFIG_SCSI_DH is not set
++# CONFIG_SCSI_OSD_INITIATOR is not set
++CONFIG_ATA=y
++# CONFIG_ATA_NONSTANDARD is not set
++CONFIG_ATA_VERBOSE_ERROR=y
++CONFIG_SATA_PMP=y
++CONFIG_ATA_SFF=y
++# CONFIG_SATA_MV is not set
++# CONFIG_PATA_PLATFORM is not set
++# CONFIG_MD is not set
++CONFIG_NETDEVICES=y
++# CONFIG_DUMMY is not set
++# CONFIG_BONDING is not set
++# CONFIG_MACVLAN is not set
++# CONFIG_EQUALIZER is not set
++CONFIG_TUN=y
++# CONFIG_VETH is not set
++CONFIG_PHYLIB=y
++
++#
++# MII PHY device drivers
++#
++# CONFIG_MARVELL_PHY is not set
++# CONFIG_DAVICOM_PHY is not set
++# CONFIG_QSEMI_PHY is not set
++CONFIG_LXT_PHY=y
++# CONFIG_CICADA_PHY is not set
++# CONFIG_VITESSE_PHY is not set
++# CONFIG_SMSC_PHY is not set
++# CONFIG_BROADCOM_PHY is not set
++# CONFIG_ICPLUS_PHY is not set
++# CONFIG_REALTEK_PHY is not set
++# CONFIG_NATIONAL_PHY is not set
++# CONFIG_STE10XP is not set
++CONFIG_LSI_ET1011C_PHY=y
++# CONFIG_FIXED_PHY is not set
++# CONFIG_MDIO_BITBANG is not set
++CONFIG_NET_ETHERNET=y
++CONFIG_MII=y
++# CONFIG_AX88796 is not set
++# CONFIG_SMC91X is not set
++CONFIG_TI_DAVINCI_EMAC=y
++CONFIG_DM9000=y
++CONFIG_DM9000_DEBUGLEVEL=4
++# CONFIG_DM9000_FORCE_SIMPLE_PHY_POLL is not set
++# CONFIG_ENC28J60 is not set
++# CONFIG_ETHOC is not set
++# CONFIG_SMC911X is not set
++# CONFIG_SMSC911X is not set
++# CONFIG_DNET is not set
++# CONFIG_IBM_NEW_EMAC_ZMII is not set
++# CONFIG_IBM_NEW_EMAC_RGMII is not set
++# CONFIG_IBM_NEW_EMAC_TAH is not set
++# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
++# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
++# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
++# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
++# CONFIG_B44 is not set
++# CONFIG_KS8842 is not set
++# CONFIG_KS8851 is not set
++# CONFIG_NETDEV_1000 is not set
++# CONFIG_NETDEV_10000 is not set
++CONFIG_WLAN=y
++# CONFIG_WLAN_PRE80211 is not set
++# CONFIG_WLAN_80211 is not set
++
++#
++# Enable WiMAX (Networking options) to see the WiMAX drivers
++#
++
++#
++# USB Network Adapters
++#
++# CONFIG_USB_CATC is not set
++# CONFIG_USB_KAWETH is not set
++# CONFIG_USB_PEGASUS is not set
++# CONFIG_USB_RTL8150 is not set
++# CONFIG_USB_USBNET is not set
++# CONFIG_WAN is not set
++CONFIG_PPP=y
++# CONFIG_PPP_MULTILINK is not set
++# CONFIG_PPP_FILTER is not set
++CONFIG_PPP_ASYNC=y
++CONFIG_PPP_SYNC_TTY=y
++CONFIG_PPP_DEFLATE=y
++# CONFIG_PPP_BSDCOMP is not set
++# CONFIG_PPP_MPPE is not set
++# CONFIG_PPPOE is not set
++# CONFIG_PPPOL2TP is not set
++# CONFIG_SLIP is not set
++CONFIG_SLHC=y
++CONFIG_NETCONSOLE=y
++# CONFIG_NETCONSOLE_DYNAMIC is not set
++CONFIG_NETPOLL=y
++CONFIG_NETPOLL_TRAP=y
++CONFIG_NET_POLL_CONTROLLER=y
++# CONFIG_ISDN is not set
++# CONFIG_PHONE is not set
++
++#
++# Input device support
++#
++CONFIG_INPUT=y
++# CONFIG_INPUT_FF_MEMLESS is not set
++# CONFIG_INPUT_POLLDEV is not set
++
++#
++# Userland interfaces
++#
++# CONFIG_INPUT_MOUSEDEV is not set
++# CONFIG_INPUT_JOYDEV is not set
++CONFIG_INPUT_EVDEV=y
++CONFIG_INPUT_EVBUG=y
++
++#
++# Input Device Drivers
++#
++CONFIG_INPUT_KEYBOARD=y
++# CONFIG_KEYBOARD_ADP5588 is not set
++CONFIG_KEYBOARD_ATKBD=m
++# CONFIG_QT2160 is not set
++# CONFIG_KEYBOARD_LKKBD is not set
++CONFIG_KEYBOARD_GPIO=y
++# CONFIG_KEYBOARD_MATRIX is not set
++# CONFIG_KEYBOARD_LM8323 is not set
++# CONFIG_KEYBOARD_MAX7359 is not set
++# CONFIG_KEYBOARD_NEWTON is not set
++# CONFIG_KEYBOARD_OPENCORES is not set
++# CONFIG_KEYBOARD_STOWAWAY is not set
++# CONFIG_KEYBOARD_SUNKBD is not set
++CONFIG_KEYBOARD_XTKBD=m
++# CONFIG_INPUT_MOUSE is not set
++# CONFIG_INPUT_JOYSTICK is not set
++# CONFIG_INPUT_TABLET is not set
++CONFIG_INPUT_TOUCHSCREEN=y
++# CONFIG_TOUCHSCREEN_ADS7846 is not set
++# CONFIG_TOUCHSCREEN_AD7877 is not set
++# CONFIG_TOUCHSCREEN_AD7879_I2C is not set
++# CONFIG_TOUCHSCREEN_AD7879_SPI is not set
++# CONFIG_TOUCHSCREEN_AD7879 is not set
++# CONFIG_TOUCHSCREEN_EETI is not set
++# CONFIG_TOUCHSCREEN_FUJITSU is not set
++# CONFIG_TOUCHSCREEN_GUNZE is not set
++# CONFIG_TOUCHSCREEN_ELO is not set
++# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
++# CONFIG_TOUCHSCREEN_MCS5000 is not set
++# CONFIG_TOUCHSCREEN_MTOUCH is not set
++# CONFIG_TOUCHSCREEN_INEXIO is not set
++# CONFIG_TOUCHSCREEN_MK712 is not set
++# CONFIG_TOUCHSCREEN_PENMOUNT is not set
++# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
++# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
++# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
++# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
++# CONFIG_TOUCHSCREEN_TSC2007 is not set
++# CONFIG_TOUCHSCREEN_W90X900 is not set
++# CONFIG_INPUT_MISC is not set
++
++#
++# Hardware I/O ports
++#
++CONFIG_SERIO=y
++CONFIG_SERIO_SERPORT=y
++CONFIG_SERIO_LIBPS2=y
++# CONFIG_SERIO_RAW is not set
++# CONFIG_GAMEPORT is not set
++
++#
++# Character devices
++#
++CONFIG_VT=y
++CONFIG_CONSOLE_TRANSLATIONS=y
++# CONFIG_VT_CONSOLE is not set
++CONFIG_HW_CONSOLE=y
++# CONFIG_VT_HW_CONSOLE_BINDING is not set
++CONFIG_DEVKMEM=y
++# CONFIG_SERIAL_NONSTANDARD is not set
++
++#
++# Serial drivers
++#
++CONFIG_SERIAL_8250=y
++CONFIG_SERIAL_8250_CONSOLE=y
++CONFIG_SERIAL_8250_NR_UARTS=3
++CONFIG_SERIAL_8250_RUNTIME_UARTS=3
++# CONFIG_SERIAL_8250_EXTENDED is not set
++
++#
++# Non-8250 serial port support
++#
++# CONFIG_SERIAL_MAX3100 is not set
++CONFIG_SERIAL_CORE=y
++CONFIG_SERIAL_CORE_CONSOLE=y
++CONFIG_UNIX98_PTYS=y
++# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
++CONFIG_LEGACY_PTYS=y
++CONFIG_LEGACY_PTY_COUNT=256
++# CONFIG_IPMI_HANDLER is not set
++# CONFIG_HW_RANDOM is not set
++# CONFIG_R3964 is not set
++# CONFIG_RAW_DRIVER is not set
++# CONFIG_TCG_TPM is not set
++CONFIG_VDCE=y
++CONFIG_CIR=y
++CONFIG_I2C=y
++CONFIG_I2C_BOARDINFO=y
++CONFIG_I2C_COMPAT=y
++CONFIG_I2C_CHARDEV=y
++CONFIG_I2C_HELPER_AUTO=y
++
++#
++# I2C Hardware Bus support
++#
++
++#
++# I2C system bus drivers (mostly embedded / system-on-chip)
++#
++CONFIG_I2C_DAVINCI=y
++# CONFIG_I2C_DESIGNWARE is not set
++# CONFIG_I2C_GPIO is not set
++# CONFIG_I2C_OCORES is not set
++# CONFIG_I2C_SIMTEC is not set
++
++#
++# External I2C/SMBus adapter drivers
++#
++# CONFIG_I2C_PARPORT_LIGHT is not set
++# CONFIG_I2C_TAOS_EVM is not set
++# CONFIG_I2C_TINY_USB is not set
++
++#
++# Other I2C/SMBus bus drivers
++#
++# CONFIG_I2C_PCA_PLATFORM is not set
++# CONFIG_I2C_STUB is not set
++
++#
++# Miscellaneous I2C Chip support
++#
++# CONFIG_DS1682 is not set
++# CONFIG_SENSORS_TSL2550 is not set
++# CONFIG_I2C_DEBUG_CORE is not set
++# CONFIG_I2C_DEBUG_ALGO is not set
++# CONFIG_I2C_DEBUG_BUS is not set
++# CONFIG_I2C_DEBUG_CHIP is not set
++CONFIG_SPI=y
++# CONFIG_SPI_DEBUG is not set
++CONFIG_SPI_MASTER=y
++
++#
++# SPI Master Controller Drivers
++#
++CONFIG_SPI_DAVINCI=y
++CONFIG_SPI_BITBANG=y
++CONFIG_SPI_GPIO=y
++
++#
++# SPI Protocol Masters
++#
++# CONFIG_SPI_SPIDEV is not set
++# CONFIG_SPI_TLE62X0 is not set
++
++#
++# PPS support
++#
++# CONFIG_PPS is not set
++CONFIG_ARCH_REQUIRE_GPIOLIB=y
++CONFIG_GPIOLIB=y
++# CONFIG_DEBUG_GPIO is not set
++# CONFIG_GPIO_SYSFS is not set
++
++#
++# Memory mapped GPIO expanders:
++#
++
++#
++# I2C GPIO expanders:
++#
++# CONFIG_GPIO_MAX732X is not set
++# CONFIG_GPIO_PCA953X is not set
++CONFIG_GPIO_PCF857X=y
++
++#
++# PCI GPIO expanders:
++#
++
++#
++# SPI GPIO expanders:
++#
++# CONFIG_GPIO_MAX7301 is not set
++# CONFIG_GPIO_MCP23S08 is not set
++# CONFIG_GPIO_MC33880 is not set
++
++#
++# AC97 GPIO expanders:
++#
++# CONFIG_W1 is not set
++# CONFIG_POWER_SUPPLY is not set
++CONFIG_HWMON=y
++# CONFIG_HWMON_VID is not set
++# CONFIG_HWMON_DEBUG_CHIP is not set
++
++#
++# Native drivers
++#
++# CONFIG_SENSORS_AD7414 is not set
++# CONFIG_SENSORS_AD7418 is not set
++# CONFIG_SENSORS_ADCXX is not set
++# CONFIG_SENSORS_ADM1021 is not set
++# CONFIG_SENSORS_ADM1025 is not set
++# CONFIG_SENSORS_ADM1026 is not set
++# CONFIG_SENSORS_ADM1029 is not set
++# CONFIG_SENSORS_ADM1031 is not set
++# CONFIG_SENSORS_ADM9240 is not set
++# CONFIG_SENSORS_ADT7462 is not set
++# CONFIG_SENSORS_ADT7470 is not set
++# CONFIG_SENSORS_ADT7473 is not set
++# CONFIG_SENSORS_ADT7475 is not set
++# CONFIG_SENSORS_ATXP1 is not set
++# CONFIG_SENSORS_DS1621 is not set
++# CONFIG_SENSORS_F71805F is not set
++# CONFIG_SENSORS_F71882FG is not set
++# CONFIG_SENSORS_F75375S is not set
++# CONFIG_SENSORS_G760A is not set
++# CONFIG_SENSORS_GL518SM is not set
++# CONFIG_SENSORS_GL520SM is not set
++# CONFIG_SENSORS_IT87 is not set
++# CONFIG_SENSORS_LM63 is not set
++# CONFIG_SENSORS_LM70 is not set
++# CONFIG_SENSORS_LM75 is not set
++# CONFIG_SENSORS_LM77 is not set
++# CONFIG_SENSORS_LM78 is not set
++# CONFIG_SENSORS_LM80 is not set
++# CONFIG_SENSORS_LM83 is not set
++# CONFIG_SENSORS_LM85 is not set
++# CONFIG_SENSORS_LM87 is not set
++# CONFIG_SENSORS_LM90 is not set
++# CONFIG_SENSORS_LM92 is not set
++# CONFIG_SENSORS_LM93 is not set
++# CONFIG_SENSORS_LTC4215 is not set
++# CONFIG_SENSORS_LTC4245 is not set
++# CONFIG_SENSORS_LM95241 is not set
++# CONFIG_SENSORS_MAX1111 is not set
++# CONFIG_SENSORS_MAX1619 is not set
++# CONFIG_SENSORS_MAX6650 is not set
++# CONFIG_SENSORS_PC87360 is not set
++# CONFIG_SENSORS_PC87427 is not set
++# CONFIG_SENSORS_PCF8591 is not set
++# CONFIG_SENSORS_SHT15 is not set
++# CONFIG_SENSORS_DME1737 is not set
++# CONFIG_SENSORS_SMSC47M1 is not set
++# CONFIG_SENSORS_SMSC47M192 is not set
++# CONFIG_SENSORS_SMSC47B397 is not set
++# CONFIG_SENSORS_ADS7828 is not set
++# CONFIG_SENSORS_THMC50 is not set
++# CONFIG_SENSORS_TMP401 is not set
++# CONFIG_SENSORS_TMP421 is not set
++# CONFIG_SENSORS_VT1211 is not set
++# CONFIG_SENSORS_W83781D is not set
++# CONFIG_SENSORS_W83791D is not set
++# CONFIG_SENSORS_W83792D is not set
++# CONFIG_SENSORS_W83793 is not set
++# CONFIG_SENSORS_W83L785TS is not set
++# CONFIG_SENSORS_W83L786NG is not set
++# CONFIG_SENSORS_W83627HF is not set
++# CONFIG_SENSORS_W83627EHF is not set
++# CONFIG_SENSORS_LIS3_SPI is not set
++# CONFIG_THERMAL is not set
++CONFIG_WATCHDOG=y
++# CONFIG_WATCHDOG_NOWAYOUT is not set
++
++#
++# Watchdog Device Drivers
++#
++# CONFIG_SOFT_WATCHDOG is not set
++CONFIG_DAVINCI_WATCHDOG=y
++
++#
++# USB-based Watchdog Cards
++#
++# CONFIG_USBPCWATCHDOG is not set
++CONFIG_SSB_POSSIBLE=y
++
++#
++# Sonics Silicon Backplane
++#
++# CONFIG_SSB is not set
++
++#
++# Multifunction device drivers
++#
++# CONFIG_MFD_CORE is not set
++# CONFIG_MFD_SM501 is not set
++# CONFIG_MFD_ASIC3 is not set
++# CONFIG_HTC_EGPIO is not set
++# CONFIG_HTC_PASIC3 is not set
++# CONFIG_TPS65010 is not set
++# CONFIG_TWL4030_CORE is not set
++# CONFIG_MFD_TMIO is not set
++# CONFIG_MFD_T7L66XB is not set
++# CONFIG_MFD_TC6387XB is not set
++# CONFIG_MFD_TC6393XB is not set
++# CONFIG_PMIC_DA903X is not set
++# CONFIG_MFD_WM8400 is not set
++# CONFIG_MFD_WM831X is not set
++# CONFIG_MFD_WM8350_I2C is not set
++# CONFIG_MFD_PCF50633 is not set
++# CONFIG_MFD_MC13783 is not set
++# CONFIG_AB3100_CORE is not set
++# CONFIG_EZX_PCAP is not set
++# CONFIG_REGULATOR is not set
++CONFIG_MEDIA_SUPPORT=y
++
++#
++# Multimedia core support
++#
++CONFIG_VIDEO_DEV=y
++CONFIG_VIDEO_V4L2_COMMON=y
++# CONFIG_VIDEO_ALLOW_V4L1 is not set
++# CONFIG_VIDEO_V4L1_COMPAT is not set
++# CONFIG_DVB_CORE is not set
++CONFIG_VIDEO_MEDIA=y
++
++#
++# Multimedia drivers
++#
++# CONFIG_MEDIA_ATTACH is not set
++CONFIG_MEDIA_TUNER=y
++# CONFIG_MEDIA_TUNER_CUSTOMISE is not set
++CONFIG_MEDIA_TUNER_SIMPLE=y
++CONFIG_MEDIA_TUNER_TDA8290=y
++CONFIG_MEDIA_TUNER_TDA9887=y
++CONFIG_MEDIA_TUNER_TEA5761=y
++CONFIG_MEDIA_TUNER_TEA5767=y
++CONFIG_MEDIA_TUNER_MT20XX=y
++CONFIG_MEDIA_TUNER_XC2028=y
++CONFIG_MEDIA_TUNER_XC5000=y
++CONFIG_MEDIA_TUNER_MC44S803=y
++CONFIG_VIDEO_V4L2=y
++CONFIG_VIDEOBUF_GEN=y
++CONFIG_VIDEOBUF_DMA_CONTIG=y
++CONFIG_VIDEO_CAPTURE_DRIVERS=y
++# CONFIG_VIDEO_ADV_DEBUG is not set
++# CONFIG_VIDEO_FIXED_MINOR_RANGES is not set
++# CONFIG_VIDEO_HELPER_CHIPS_AUTO is not set
++
++#
++# Encoders/decoders and other helper chips
++#
++
++#
++# Audio decoders
++#
++# CONFIG_VIDEO_TVAUDIO is not set
++# CONFIG_VIDEO_TDA7432 is not set
++# CONFIG_VIDEO_TDA9840 is not set
++# CONFIG_VIDEO_TDA9875 is not set
++# CONFIG_VIDEO_TEA6415C is not set
++# CONFIG_VIDEO_TEA6420 is not set
++# CONFIG_VIDEO_MSP3400 is not set
++# CONFIG_VIDEO_CS5345 is not set
++# CONFIG_VIDEO_CS53L32A is not set
++# CONFIG_VIDEO_M52790 is not set
++# CONFIG_VIDEO_TLV320AIC23B is not set
++# CONFIG_VIDEO_WM8775 is not set
++# CONFIG_VIDEO_WM8739 is not set
++# CONFIG_VIDEO_VP27SMPX is not set
++
++#
++# RDS decoders
++#
++# CONFIG_VIDEO_SAA6588 is not set
++
++#
++# Video decoders
++#
++# CONFIG_VIDEO_ADV7180 is not set
++# CONFIG_VIDEO_BT819 is not set
++# CONFIG_VIDEO_BT856 is not set
++# CONFIG_VIDEO_BT866 is not set
++# CONFIG_VIDEO_KS0127 is not set
++# CONFIG_VIDEO_OV7670 is not set
++# CONFIG_VIDEO_MT9V011 is not set
++# CONFIG_VIDEO_TCM825X is not set
++# CONFIG_VIDEO_SAA7110 is not set
++# CONFIG_VIDEO_SAA711X is not set
++# CONFIG_VIDEO_SAA717X is not set
++# CONFIG_VIDEO_TVP514X is not set
++# CONFIG_VIDEO_TVP5150 is not set
++CONFIG_VIDEO_TVP7002=y
++# CONFIG_VIDEO_VPX3220 is not set
++
++#
++# Video and audio decoders
++#
++# CONFIG_VIDEO_CX25840 is not set
++
++#
++# MPEG video encoders
++#
++# CONFIG_VIDEO_CX2341X is not set
++
++#
++# Video encoders
++#
++# CONFIG_VIDEO_SAA7127 is not set
++# CONFIG_VIDEO_SAA7185 is not set
++# CONFIG_VIDEO_ADV7170 is not set
++# CONFIG_VIDEO_ADV7175 is not set
++CONFIG_VIDEO_THS7303=y
++CONFIG_VIDEO_THS7353=y
++CONFIG_VIDEO_THS7353_LUMA_CHANNEL=2
++CONFIG_VIDEO_ADV7343=y
++# CONFIG_VIDEO_THS8200 is not set
++
++#
++# Video improvement chips
++#
++# CONFIG_VIDEO_UPD64031A is not set
++# CONFIG_VIDEO_UPD64083 is not set
++CONFIG_DISPLAY_DAVINCI_DM646X_EVM=y
++CONFIG_CAPTURE_DAVINCI_DM646X_EVM=y
++CONFIG_VIDEO_DAVINCI_VPIF=y
++# CONFIG_VIDEO_DAVINCI_DISPLAY is not set
++# CONFIG_DAVINCI_ENC_MNGR is not set
++# CONFIG_DAVINCI_OSD is not set
++# CONFIG_VIDEO_VIVI is not set
++# CONFIG_VIDEO_VPSS_SYSTEM is not set
++# CONFIG_VIDEO_VPFE_CAPTURE is not set
++# CONFIG_VIDEO_SAA5246A is not set
++# CONFIG_VIDEO_SAA5249 is not set
++# CONFIG_SOC_CAMERA is not set
++# CONFIG_SOC_CAMERA_MT9T031 is not set
++# CONFIG_V4L_USB_DRIVERS is not set
++# CONFIG_RADIO_ADAPTERS is not set
++# CONFIG_DAB is not set
++
++#
++# Graphics support
++#
++# CONFIG_VGASTATE is not set
++# CONFIG_VIDEO_OUTPUT_CONTROL is not set
++# CONFIG_FB is not set
++# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
++
++#
++# Display device support
++#
++# CONFIG_DISPLAY_SUPPORT is not set
++
++#
++# Console display driver support
++#
++# CONFIG_VGA_CONSOLE is not set
++CONFIG_DUMMY_CONSOLE=y
++CONFIG_SOUND=y
++# CONFIG_SOUND_OSS_CORE is not set
++CONFIG_SND=y
++CONFIG_SND_TIMER=y
++CONFIG_SND_PCM=y
++CONFIG_SND_JACK=y
++# CONFIG_SND_SEQUENCER is not set
++# CONFIG_SND_MIXER_OSS is not set
++# CONFIG_SND_PCM_OSS is not set
++# CONFIG_SND_HRTIMER is not set
++# CONFIG_SND_DYNAMIC_MINORS is not set
++CONFIG_SND_SUPPORT_OLD_API=y
++CONFIG_SND_VERBOSE_PROCFS=y
++# CONFIG_SND_VERBOSE_PRINTK is not set
++# CONFIG_SND_DEBUG is not set
++# CONFIG_SND_RAWMIDI_SEQ is not set
++# CONFIG_SND_OPL3_LIB_SEQ is not set
++# CONFIG_SND_OPL4_LIB_SEQ is not set
++# CONFIG_SND_SBAWE_SEQ is not set
++# CONFIG_SND_EMU10K1_SEQ is not set
++CONFIG_SND_DRIVERS=y
++# CONFIG_SND_DUMMY is not set
++# CONFIG_SND_MTPAV is not set
++# CONFIG_SND_SERIAL_U16550 is not set
++# CONFIG_SND_MPU401 is not set
++CONFIG_SND_ARM=y
++CONFIG_SND_SPI=y
++CONFIG_SND_USB=y
++# CONFIG_SND_USB_AUDIO is not set
++# CONFIG_SND_USB_CAIAQ is not set
++CONFIG_SND_SOC=y
++CONFIG_SND_DAVINCI_SOC=y
++CONFIG_SND_DAVINCI_SOC_MCASP=y
++CONFIG_SND_DM6467_SOC_EVM=y
++CONFIG_SND_SOC_I2C_AND_SPI=y
++# CONFIG_SND_SOC_ALL_CODECS is not set
++CONFIG_SND_SOC_SPDIF=y
++CONFIG_SND_SOC_TLV320AIC3X=y
++# CONFIG_SOUND_PRIME is not set
++CONFIG_HID_SUPPORT=y
++CONFIG_HID=y
++# CONFIG_HIDRAW is not set
++
++#
++# USB Input Devices
++#
++CONFIG_USB_HID=y
++# CONFIG_HID_PID is not set
++# CONFIG_USB_HIDDEV is not set
++
++#
++# Special HID drivers
++#
++CONFIG_HID_A4TECH=m
++CONFIG_HID_APPLE=m
++CONFIG_HID_BELKIN=m
++CONFIG_HID_CHERRY=m
++CONFIG_HID_CHICONY=m
++CONFIG_HID_CYPRESS=m
++# CONFIG_HID_DRAGONRISE is not set
++CONFIG_HID_EZKEY=m
++# CONFIG_HID_KYE is not set
++CONFIG_HID_GYRATION=m
++# CONFIG_HID_TWINHAN is not set
++# CONFIG_HID_KENSINGTON is not set
++CONFIG_HID_LOGITECH=m
++# CONFIG_LOGITECH_FF is not set
++# CONFIG_LOGIRUMBLEPAD2_FF is not set
++CONFIG_HID_MICROSOFT=m
++CONFIG_HID_MONTEREY=m
++# CONFIG_HID_NTRIG is not set
++CONFIG_HID_PANTHERLORD=m
++# CONFIG_PANTHERLORD_FF is not set
++CONFIG_HID_PETALYNX=m
++CONFIG_HID_SAMSUNG=m
++CONFIG_HID_SONY=m
++CONFIG_HID_SUNPLUS=m
++# CONFIG_HID_GREENASIA is not set
++# CONFIG_HID_SMARTJOYPLUS is not set
++# CONFIG_HID_TOPSEED is not set
++# CONFIG_HID_THRUSTMASTER is not set
++# CONFIG_HID_ZEROPLUS is not set
++CONFIG_USB_SUPPORT=y
++CONFIG_USB_ARCH_HAS_HCD=y
++# CONFIG_USB_ARCH_HAS_OHCI is not set
++# CONFIG_USB_ARCH_HAS_EHCI is not set
++CONFIG_USB=y
++# CONFIG_USB_DEBUG is not set
++# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
++
++#
++# Miscellaneous USB options
++#
++CONFIG_USB_DEVICEFS=y
++CONFIG_USB_DEVICE_CLASS=y
++# CONFIG_USB_DYNAMIC_MINORS is not set
++# CONFIG_USB_OTG is not set
++# CONFIG_USB_OTG_WHITELIST is not set
++# CONFIG_USB_OTG_BLACKLIST_HUB is not set
++CONFIG_USB_MON=y
++# CONFIG_USB_WUSB is not set
++# CONFIG_USB_WUSB_CBAF is not set
++
++#
++# USB Host Controller Drivers
++#
++# CONFIG_USB_C67X00_HCD is not set
++# CONFIG_USB_OXU210HP_HCD is not set
++# CONFIG_USB_ISP116X_HCD is not set
++# CONFIG_USB_ISP1760_HCD is not set
++# CONFIG_USB_ISP1362_HCD is not set
++# CONFIG_USB_SL811_HCD is not set
++# CONFIG_USB_R8A66597_HCD is not set
++# CONFIG_USB_HWA_HCD is not set
++CONFIG_USB_MUSB_HDRC=y
++CONFIG_USB_MUSB_SOC=y
++
++#
++# DaVinci 35x, 36x, 644x USB support
++#
++CONFIG_USB_MUSB_HOST=y
++# CONFIG_USB_MUSB_PERIPHERAL is not set
++# CONFIG_USB_MUSB_OTG is not set
++# CONFIG_MUSB_SCHEDULE_INTR_EP is not set
++# CONFIG_USB_GADGET_MUSB_HDRC is not set
++CONFIG_USB_MUSB_HDRC_HCD=y
++CONFIG_MUSB_PIO_ONLY=y
++# CONFIG_USB_MUSB_DEBUG is not set
++
++#
++# USB Device Class drivers
++#
++# CONFIG_USB_ACM is not set
++# CONFIG_USB_PRINTER is not set
++# CONFIG_USB_WDM is not set
++# CONFIG_USB_TMC is not set
++
++#
++# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
++#
++
++#
++# also be needed; see USB_STORAGE Help for more info
++#
++CONFIG_USB_STORAGE=y
++CONFIG_USB_STORAGE_DEBUG=y
++# CONFIG_USB_STORAGE_DATAFAB is not set
++# CONFIG_USB_STORAGE_FREECOM is not set
++# CONFIG_USB_STORAGE_ISD200 is not set
++# CONFIG_USB_STORAGE_USBAT is not set
++# CONFIG_USB_STORAGE_SDDR09 is not set
++# CONFIG_USB_STORAGE_SDDR55 is not set
++# CONFIG_USB_STORAGE_JUMPSHOT is not set
++# CONFIG_USB_STORAGE_ALAUDA is not set
++# CONFIG_USB_STORAGE_ONETOUCH is not set
++# CONFIG_USB_STORAGE_KARMA is not set
++# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
++# CONFIG_USB_LIBUSUAL is not set
++
++#
++# USB Imaging devices
++#
++# CONFIG_USB_MDC800 is not set
++# CONFIG_USB_MICROTEK is not set
++
++#
++# USB port drivers
++#
++# CONFIG_USB_SERIAL is not set
++
++#
++# USB Miscellaneous drivers
++#
++# CONFIG_USB_EMI62 is not set
++# CONFIG_USB_EMI26 is not set
++# CONFIG_USB_ADUTUX is not set
++# CONFIG_USB_SEVSEG is not set
++# CONFIG_USB_RIO500 is not set
++# CONFIG_USB_LEGOTOWER is not set
++# CONFIG_USB_LCD is not set
++# CONFIG_USB_BERRY_CHARGE is not set
++# CONFIG_USB_LED is not set
++# CONFIG_USB_CYPRESS_CY7C63 is not set
++# CONFIG_USB_CYTHERM is not set
++# CONFIG_USB_IDMOUSE is not set
++# CONFIG_USB_FTDI_ELAN is not set
++# CONFIG_USB_APPLEDISPLAY is not set
++# CONFIG_USB_SISUSBVGA is not set
++# CONFIG_USB_LD is not set
++# CONFIG_USB_TRANCEVIBRATOR is not set
++# CONFIG_USB_IOWARRIOR is not set
++CONFIG_USB_TEST=y
++# CONFIG_USB_ISIGHTFW is not set
++# CONFIG_USB_VST is not set
++CONFIG_USB_GADGET=y
++# CONFIG_USB_GADGET_DEBUG is not set
++CONFIG_USB_GADGET_DEBUG_FILES=y
++CONFIG_USB_GADGET_DEBUG_FS=y
++CONFIG_USB_GADGET_VBUS_DRAW=2
++CONFIG_USB_GADGET_SELECTED=y
++# CONFIG_USB_GADGET_AT91 is not set
++# CONFIG_USB_GADGET_ATMEL_USBA is not set
++# CONFIG_USB_GADGET_FSL_USB2 is not set
++# CONFIG_USB_GADGET_LH7A40X is not set
++# CONFIG_USB_GADGET_OMAP is not set
++# CONFIG_USB_GADGET_PXA25X is not set
++# CONFIG_USB_GADGET_R8A66597 is not set
++# CONFIG_USB_GADGET_PXA27X is not set
++# CONFIG_USB_GADGET_S3C_HSOTG is not set
++# CONFIG_USB_GADGET_IMX is not set
++# CONFIG_USB_GADGET_S3C2410 is not set
++CONFIG_USB_GADGET_M66592=y
++CONFIG_USB_M66592=y
++# CONFIG_USB_GADGET_AMD5536UDC is not set
++# CONFIG_USB_GADGET_FSL_QE is not set
++# CONFIG_USB_GADGET_CI13XXX is not set
++# CONFIG_USB_GADGET_NET2280 is not set
++# CONFIG_USB_GADGET_GOKU is not set
++# CONFIG_USB_GADGET_LANGWELL is not set
++# CONFIG_USB_GADGET_DUMMY_HCD is not set
++CONFIG_USB_GADGET_DUALSPEED=y
++# CONFIG_USB_ZERO is not set
++# CONFIG_USB_AUDIO is not set
++CONFIG_USB_ETH=y
++CONFIG_USB_ETH_RNDIS=y
++# CONFIG_USB_ETH_EEM is not set
++# CONFIG_USB_GADGETFS is not set
++# CONFIG_USB_FILE_STORAGE is not set
++# CONFIG_USB_G_SERIAL is not set
++# CONFIG_USB_MIDI_GADGET is not set
++# CONFIG_USB_G_PRINTER is not set
++# CONFIG_USB_CDC_COMPOSITE is not set
++
++#
++# OTG and related infrastructure
++#
++CONFIG_USB_OTG_UTILS=y
++# CONFIG_USB_GPIO_VBUS is not set
++CONFIG_NOP_USB_XCEIV=y
++CONFIG_MMC=y
++# CONFIG_MMC_DEBUG is not set
++# CONFIG_MMC_UNSAFE_RESUME is not set
++
++#
++# MMC/SD/SDIO Card Drivers
++#
++CONFIG_MMC_BLOCK=y
++# CONFIG_MMC_BLOCK_BOUNCE is not set
++# CONFIG_SDIO_UART is not set
++# CONFIG_MMC_TEST is not set
++
++#
++# MMC/SD/SDIO Host Controller Drivers
++#
++# CONFIG_MMC_SDHCI is not set
++# CONFIG_MMC_AT91 is not set
++# CONFIG_MMC_ATMELMCI is not set
++CONFIG_MMC_DAVINCI=y
++# CONFIG_MMC_SPI is not set
++# CONFIG_MEMSTICK is not set
++CONFIG_NEW_LEDS=y
++CONFIG_LEDS_CLASS=y
++
++#
++# LED drivers
++#
++# CONFIG_LEDS_PCA9532 is not set
++CONFIG_LEDS_GPIO=y
++CONFIG_LEDS_GPIO_PLATFORM=y
++# CONFIG_LEDS_LP3944 is not set
++# CONFIG_LEDS_PCA955X is not set
++# CONFIG_LEDS_DAC124S085 is not set
++# CONFIG_LEDS_BD2802 is not set
++
++#
++# LED Triggers
++#
++CONFIG_LEDS_TRIGGERS=y
++CONFIG_LEDS_TRIGGER_TIMER=y
++# CONFIG_LEDS_TRIGGER_IDE_DISK is not set
++CONFIG_LEDS_TRIGGER_HEARTBEAT=y
++# CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
++# CONFIG_LEDS_TRIGGER_GPIO is not set
++# CONFIG_LEDS_TRIGGER_DEFAULT_ON is not set
++
++#
++# iptables trigger is under Netfilter config (LED target)
++#
++# CONFIG_ACCESSIBILITY is not set
++CONFIG_RTC_LIB=y
++CONFIG_RTC_CLASS=y
++CONFIG_RTC_HCTOSYS=y
++CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
++# CONFIG_RTC_DEBUG is not set
++
++#
++# RTC interfaces
++#
++CONFIG_RTC_INTF_SYSFS=y
++CONFIG_RTC_INTF_PROC=y
++CONFIG_RTC_INTF_DEV=y
++# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
++# CONFIG_RTC_DRV_TEST is not set
++
++#
++# I2C RTC drivers
++#
++# CONFIG_RTC_DRV_DS1307 is not set
++# CONFIG_RTC_DRV_DS1374 is not set
++# CONFIG_RTC_DRV_DS1672 is not set
++# CONFIG_RTC_DRV_MAX6900 is not set
++# CONFIG_RTC_DRV_RS5C372 is not set
++# CONFIG_RTC_DRV_ISL1208 is not set
++# CONFIG_RTC_DRV_X1205 is not set
++# CONFIG_RTC_DRV_PCF8563 is not set
++# CONFIG_RTC_DRV_PCF8583 is not set
++# CONFIG_RTC_DRV_M41T80 is not set
++# CONFIG_RTC_DRV_S35390A is not set
++# CONFIG_RTC_DRV_FM3130 is not set
++# CONFIG_RTC_DRV_RX8581 is not set
++# CONFIG_RTC_DRV_RX8025 is not set
++
++#
++# SPI RTC drivers
++#
++# CONFIG_RTC_DRV_M41T94 is not set
++# CONFIG_RTC_DRV_DS1305 is not set
++# CONFIG_RTC_DRV_DS1390 is not set
++# CONFIG_RTC_DRV_MAX6902 is not set
++# CONFIG_RTC_DRV_R9701 is not set
++# CONFIG_RTC_DRV_RS5C348 is not set
++# CONFIG_RTC_DRV_DS3234 is not set
++# CONFIG_RTC_DRV_PCF2123 is not set
++
++#
++# Platform RTC drivers
++#
++# CONFIG_RTC_DRV_CMOS is not set
++# CONFIG_RTC_DRV_DS1286 is not set
++# CONFIG_RTC_DRV_DS1511 is not set
++# CONFIG_RTC_DRV_DS1553 is not set
++# CONFIG_RTC_DRV_DS1742 is not set
++# CONFIG_RTC_DRV_STK17TA8 is not set
++# CONFIG_RTC_DRV_M48T86 is not set
++# CONFIG_RTC_DRV_M48T35 is not set
++# CONFIG_RTC_DRV_M48T59 is not set
++# CONFIG_RTC_DRV_BQ4802 is not set
++# CONFIG_RTC_DRV_V3020 is not set
++
++#
++# on-CPU RTC drivers
++#
++# CONFIG_DMADEVICES is not set
++# CONFIG_AUXDISPLAY is not set
++# CONFIG_UIO is not set
++
++#
++# TI VLYNQ
++#
++# CONFIG_STAGING is not set
++
++#
++# File systems
++#
++CONFIG_EXT2_FS=y
++# CONFIG_EXT2_FS_XATTR is not set
++# CONFIG_EXT2_FS_XIP is not set
++CONFIG_EXT3_FS=y
++# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
++CONFIG_EXT3_FS_XATTR=y
++# CONFIG_EXT3_FS_POSIX_ACL is not set
++# CONFIG_EXT3_FS_SECURITY is not set
++# CONFIG_EXT4_FS is not set
++CONFIG_JBD=y
++# CONFIG_JBD_DEBUG is not set
++CONFIG_FS_MBCACHE=y
++# CONFIG_REISERFS_FS is not set
++# CONFIG_JFS_FS is not set
++# CONFIG_FS_POSIX_ACL is not set
++CONFIG_XFS_FS=m
++# CONFIG_XFS_QUOTA is not set
++# CONFIG_XFS_POSIX_ACL is not set
++# CONFIG_XFS_RT is not set
++# CONFIG_XFS_DEBUG is not set
++# CONFIG_GFS2_FS is not set
++# CONFIG_OCFS2_FS is not set
++# CONFIG_BTRFS_FS is not set
++# CONFIG_NILFS2_FS is not set
++CONFIG_FILE_LOCKING=y
++CONFIG_FSNOTIFY=y
++CONFIG_DNOTIFY=y
++CONFIG_INOTIFY=y
++CONFIG_INOTIFY_USER=y
++# CONFIG_QUOTA is not set
++# CONFIG_AUTOFS_FS is not set
++CONFIG_AUTOFS4_FS=m
++# CONFIG_FUSE_FS is not set
++
++#
++# Caches
++#
++# CONFIG_FSCACHE is not set
++
++#
++# CD-ROM/DVD Filesystems
++#
++# CONFIG_ISO9660_FS is not set
++# CONFIG_UDF_FS is not set
++
++#
++# DOS/FAT/NT Filesystems
++#
++CONFIG_FAT_FS=y
++CONFIG_MSDOS_FS=y
++CONFIG_VFAT_FS=y
++CONFIG_FAT_DEFAULT_CODEPAGE=437
++CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
++# CONFIG_NTFS_FS is not set
++
++#
++# Pseudo filesystems
++#
++CONFIG_PROC_FS=y
++CONFIG_PROC_SYSCTL=y
++CONFIG_PROC_PAGE_MONITOR=y
++CONFIG_SYSFS=y
++CONFIG_TMPFS=y
++# CONFIG_TMPFS_POSIX_ACL is not set
++# CONFIG_HUGETLB_PAGE is not set
++# CONFIG_CONFIGFS_FS is not set
++CONFIG_MISC_FILESYSTEMS=y
++# CONFIG_ADFS_FS is not set
++# CONFIG_AFFS_FS is not set
++# CONFIG_HFS_FS is not set
++# CONFIG_HFSPLUS_FS is not set
++# CONFIG_BEFS_FS is not set
++# CONFIG_BFS_FS is not set
++# CONFIG_EFS_FS is not set
++CONFIG_JFFS2_FS=y
++CONFIG_JFFS2_FS_DEBUG=0
++CONFIG_JFFS2_FS_WRITEBUFFER=y
++# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
++# CONFIG_JFFS2_SUMMARY is not set
++# CONFIG_JFFS2_FS_XATTR is not set
++# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
++CONFIG_JFFS2_ZLIB=y
++# CONFIG_JFFS2_LZO is not set
++CONFIG_JFFS2_RTIME=y
++# CONFIG_JFFS2_RUBIN is not set
++CONFIG_CRAMFS=y
++# CONFIG_SQUASHFS is not set
++# CONFIG_VXFS_FS is not set
++CONFIG_MINIX_FS=m
++# CONFIG_OMFS_FS is not set
++# CONFIG_HPFS_FS is not set
++# CONFIG_QNX4FS_FS is not set
++# CONFIG_ROMFS_FS is not set
++# CONFIG_SYSV_FS is not set
++# CONFIG_UFS_FS is not set
++CONFIG_NETWORK_FILESYSTEMS=y
++CONFIG_NFS_FS=y
++CONFIG_NFS_V3=y
++# CONFIG_NFS_V3_ACL is not set
++# CONFIG_NFS_V4 is not set
++CONFIG_ROOT_NFS=y
++CONFIG_NFSD=m
++CONFIG_NFSD_V3=y
++# CONFIG_NFSD_V3_ACL is not set
++# CONFIG_NFSD_V4 is not set
++CONFIG_LOCKD=y
++CONFIG_LOCKD_V4=y
++CONFIG_EXPORTFS=m
++CONFIG_NFS_COMMON=y
++CONFIG_SUNRPC=y
++# CONFIG_RPCSEC_GSS_KRB5 is not set
++# CONFIG_RPCSEC_GSS_SPKM3 is not set
++CONFIG_SMB_FS=m
++# CONFIG_SMB_NLS_DEFAULT is not set
++# CONFIG_CIFS is not set
++# CONFIG_NCP_FS is not set
++# CONFIG_CODA_FS is not set
++# CONFIG_AFS_FS is not set
++
++#
++# Partition Types
++#
++CONFIG_PARTITION_ADVANCED=y
++# CONFIG_ACORN_PARTITION is not set
++# CONFIG_OSF_PARTITION is not set
++# CONFIG_AMIGA_PARTITION is not set
++# CONFIG_ATARI_PARTITION is not set
++# CONFIG_MAC_PARTITION is not set
++CONFIG_MSDOS_PARTITION=y
++# CONFIG_BSD_DISKLABEL is not set
++# CONFIG_MINIX_SUBPARTITION is not set
++# CONFIG_SOLARIS_X86_PARTITION is not set
++# CONFIG_UNIXWARE_DISKLABEL is not set
++# CONFIG_LDM_PARTITION is not set
++# CONFIG_SGI_PARTITION is not set
++# CONFIG_ULTRIX_PARTITION is not set
++# CONFIG_SUN_PARTITION is not set
++# CONFIG_KARMA_PARTITION is not set
++# CONFIG_EFI_PARTITION is not set
++# CONFIG_SYSV68_PARTITION is not set
++CONFIG_NLS=y
++CONFIG_NLS_DEFAULT="iso8859-1"
++CONFIG_NLS_CODEPAGE_437=y
++# CONFIG_NLS_CODEPAGE_737 is not set
++# CONFIG_NLS_CODEPAGE_775 is not set
++# CONFIG_NLS_CODEPAGE_850 is not set
++# CONFIG_NLS_CODEPAGE_852 is not set
++# CONFIG_NLS_CODEPAGE_855 is not set
++# CONFIG_NLS_CODEPAGE_857 is not set
++# CONFIG_NLS_CODEPAGE_860 is not set
++# CONFIG_NLS_CODEPAGE_861 is not set
++# CONFIG_NLS_CODEPAGE_862 is not set
++# CONFIG_NLS_CODEPAGE_863 is not set
++# CONFIG_NLS_CODEPAGE_864 is not set
++# CONFIG_NLS_CODEPAGE_865 is not set
++# CONFIG_NLS_CODEPAGE_866 is not set
++# CONFIG_NLS_CODEPAGE_869 is not set
++# CONFIG_NLS_CODEPAGE_936 is not set
++# CONFIG_NLS_CODEPAGE_950 is not set
++# CONFIG_NLS_CODEPAGE_932 is not set
++# CONFIG_NLS_CODEPAGE_949 is not set
++# CONFIG_NLS_CODEPAGE_874 is not set
++# CONFIG_NLS_ISO8859_8 is not set
++# CONFIG_NLS_CODEPAGE_1250 is not set
++# CONFIG_NLS_CODEPAGE_1251 is not set
++CONFIG_NLS_ASCII=m
++CONFIG_NLS_ISO8859_1=y
++# CONFIG_NLS_ISO8859_2 is not set
++# CONFIG_NLS_ISO8859_3 is not set
++# CONFIG_NLS_ISO8859_4 is not set
++# CONFIG_NLS_ISO8859_5 is not set
++# CONFIG_NLS_ISO8859_6 is not set
++# CONFIG_NLS_ISO8859_7 is not set
++# CONFIG_NLS_ISO8859_9 is not set
++# CONFIG_NLS_ISO8859_13 is not set
++# CONFIG_NLS_ISO8859_14 is not set
++# CONFIG_NLS_ISO8859_15 is not set
++# CONFIG_NLS_KOI8_R is not set
++# CONFIG_NLS_KOI8_U is not set
++CONFIG_NLS_UTF8=m
++# CONFIG_DLM is not set
++
++#
++# Kernel hacking
++#
++# CONFIG_PRINTK_TIME is not set
++CONFIG_ENABLE_WARN_DEPRECATED=y
++CONFIG_ENABLE_MUST_CHECK=y
++CONFIG_FRAME_WARN=1024
++# CONFIG_MAGIC_SYSRQ is not set
++# CONFIG_STRIP_ASM_SYMS is not set
++# CONFIG_UNUSED_SYMBOLS is not set
++CONFIG_DEBUG_FS=y
++# CONFIG_HEADERS_CHECK is not set
++CONFIG_DEBUG_KERNEL=y
++# CONFIG_DEBUG_SHIRQ is not set
++CONFIG_DETECT_SOFTLOCKUP=y
++# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
++CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
++CONFIG_DETECT_HUNG_TASK=y
++# CONFIG_BOOTPARAM_HUNG_TASK_PANIC is not set
++CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=0
++CONFIG_SCHED_DEBUG=y
++# CONFIG_SCHEDSTATS is not set
++CONFIG_TIMER_STATS=y
++# CONFIG_DEBUG_OBJECTS is not set
++# CONFIG_SLUB_DEBUG_ON is not set
++# CONFIG_SLUB_STATS is not set
++# CONFIG_DEBUG_KMEMLEAK is not set
++CONFIG_DEBUG_PREEMPT=y
++CONFIG_DEBUG_RT_MUTEXES=y
++CONFIG_DEBUG_PI_LIST=y
++# CONFIG_RT_MUTEX_TESTER is not set
++# CONFIG_DEBUG_SPINLOCK is not set
++CONFIG_DEBUG_MUTEXES=y
++# CONFIG_DEBUG_LOCK_ALLOC is not set
++# CONFIG_PROVE_LOCKING is not set
++# CONFIG_LOCK_STAT is not set
++# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
++# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
++# CONFIG_DEBUG_KOBJECT is not set
++CONFIG_DEBUG_BUGVERBOSE=y
++# CONFIG_DEBUG_INFO is not set
++# CONFIG_DEBUG_VM is not set
++# CONFIG_DEBUG_WRITECOUNT is not set
++# CONFIG_DEBUG_MEMORY_INIT is not set
++# CONFIG_DEBUG_LIST is not set
++# CONFIG_DEBUG_SG is not set
++# CONFIG_DEBUG_NOTIFIERS is not set
++# CONFIG_DEBUG_CREDENTIALS is not set
++CONFIG_FRAME_POINTER=y
++# CONFIG_BOOT_PRINTK_DELAY is not set
++# CONFIG_RCU_TORTURE_TEST is not set
++# CONFIG_RCU_CPU_STALL_DETECTOR is not set
++# CONFIG_BACKTRACE_SELF_TEST is not set
++# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
++# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
++# CONFIG_FAULT_INJECTION is not set
++# CONFIG_LATENCYTOP is not set
++# CONFIG_SYSCTL_SYSCALL_CHECK is not set
++# CONFIG_PAGE_POISONING is not set
++CONFIG_HAVE_FUNCTION_TRACER=y
++CONFIG_TRACING_SUPPORT=y
++CONFIG_FTRACE=y
++# CONFIG_FUNCTION_TRACER is not set
++# CONFIG_IRQSOFF_TRACER is not set
++# CONFIG_PREEMPT_TRACER is not set
++# CONFIG_SCHED_TRACER is not set
++# CONFIG_ENABLE_DEFAULT_TRACERS is not set
++# CONFIG_BOOT_TRACER is not set
++CONFIG_BRANCH_PROFILE_NONE=y
++# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
++# CONFIG_PROFILE_ALL_BRANCHES is not set
++# CONFIG_STACK_TRACER is not set
++# CONFIG_KMEMTRACE is not set
++# CONFIG_WORKQUEUE_TRACER is not set
++# CONFIG_BLK_DEV_IO_TRACE is not set
++# CONFIG_DYNAMIC_DEBUG is not set
++# CONFIG_SAMPLES is not set
++CONFIG_HAVE_ARCH_KGDB=y
++# CONFIG_KGDB is not set
++# CONFIG_ARM_UNWIND is not set
++CONFIG_DEBUG_USER=y
++CONFIG_DEBUG_ERRORS=y
++# CONFIG_DEBUG_STACK_USAGE is not set
++# CONFIG_DEBUG_LL is not set
++
++#
++# Security options
++#
++# CONFIG_KEYS is not set
++# CONFIG_SECURITY is not set
++# CONFIG_SECURITYFS is not set
++# CONFIG_SECURITY_FILE_CAPABILITIES is not set
++CONFIG_CRYPTO=y
++
++#
++# Crypto core or helper
++#
++# CONFIG_CRYPTO_MANAGER is not set
++# CONFIG_CRYPTO_MANAGER2 is not set
++# CONFIG_CRYPTO_GF128MUL is not set
++# CONFIG_CRYPTO_NULL is not set
++# CONFIG_CRYPTO_CRYPTD is not set
++# CONFIG_CRYPTO_AUTHENC is not set
++# CONFIG_CRYPTO_TEST is not set
++
++#
++# Authenticated Encryption with Associated Data
++#
++# CONFIG_CRYPTO_CCM is not set
++# CONFIG_CRYPTO_GCM is not set
++# CONFIG_CRYPTO_SEQIV is not set
++
++#
++# Block modes
++#
++# CONFIG_CRYPTO_CBC is not set
++# CONFIG_CRYPTO_CTR is not set
++# CONFIG_CRYPTO_CTS is not set
++# CONFIG_CRYPTO_ECB is not set
++# CONFIG_CRYPTO_LRW is not set
++# CONFIG_CRYPTO_PCBC is not set
++# CONFIG_CRYPTO_XTS is not set
++
++#
++# Hash modes
++#
++# CONFIG_CRYPTO_HMAC is not set
++# CONFIG_CRYPTO_XCBC is not set
++# CONFIG_CRYPTO_VMAC is not set
++
++#
++# Digest
++#
++# CONFIG_CRYPTO_CRC32C is not set
++# CONFIG_CRYPTO_GHASH is not set
++# CONFIG_CRYPTO_MD4 is not set
++# CONFIG_CRYPTO_MD5 is not set
++# CONFIG_CRYPTO_MICHAEL_MIC is not set
++# CONFIG_CRYPTO_RMD128 is not set
++# CONFIG_CRYPTO_RMD160 is not set
++# CONFIG_CRYPTO_RMD256 is not set
++# CONFIG_CRYPTO_RMD320 is not set
++# CONFIG_CRYPTO_SHA1 is not set
++# CONFIG_CRYPTO_SHA256 is not set
++# CONFIG_CRYPTO_SHA512 is not set
++# CONFIG_CRYPTO_TGR192 is not set
++# CONFIG_CRYPTO_WP512 is not set
++
++#
++# Ciphers
++#
++# CONFIG_CRYPTO_AES is not set
++# CONFIG_CRYPTO_ANUBIS is not set
++# CONFIG_CRYPTO_ARC4 is not set
++# CONFIG_CRYPTO_BLOWFISH is not set
++# CONFIG_CRYPTO_CAMELLIA is not set
++# CONFIG_CRYPTO_CAST5 is not set
++# CONFIG_CRYPTO_CAST6 is not set
++# CONFIG_CRYPTO_DES is not set
++# CONFIG_CRYPTO_FCRYPT is not set
++# CONFIG_CRYPTO_KHAZAD is not set
++# CONFIG_CRYPTO_SALSA20 is not set
++# CONFIG_CRYPTO_SEED is not set
++# CONFIG_CRYPTO_SERPENT is not set
++# CONFIG_CRYPTO_TEA is not set
++# CONFIG_CRYPTO_TWOFISH is not set
++
++#
++# Compression
++#
++# CONFIG_CRYPTO_DEFLATE is not set
++# CONFIG_CRYPTO_ZLIB is not set
++# CONFIG_CRYPTO_LZO is not set
++
++#
++# Random Number Generation
++#
++# CONFIG_CRYPTO_ANSI_CPRNG is not set
++# CONFIG_CRYPTO_HW is not set
++# CONFIG_BINARY_PRINTF is not set
++
++#
++# Library routines
++#
++CONFIG_BITREVERSE=y
++CONFIG_GENERIC_FIND_LAST_BIT=y
++CONFIG_CRC_CCITT=y
++# CONFIG_CRC16 is not set
++CONFIG_CRC_T10DIF=m
++# CONFIG_CRC_ITU_T is not set
++CONFIG_CRC32=y
++# CONFIG_CRC7 is not set
++# CONFIG_LIBCRC32C is not set
++CONFIG_ZLIB_INFLATE=y
++CONFIG_ZLIB_DEFLATE=y
++CONFIG_DECOMPRESS_GZIP=y
++CONFIG_GENERIC_ALLOCATOR=y
++CONFIG_HAS_IOMEM=y
++CONFIG_HAS_IOPORT=y
++CONFIG_HAS_DMA=y
++CONFIG_NLATTR=y
+--- /dev/null
++++ b/include/media/davinci/dm355_ipipe.h
+@@ -0,0 +1,979 @@
++/*
++ * Copyright (C) 2005-2008 Texas Instruments Inc
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
++ *
++ * Feature description
++ * ===================
++ *
++ * VPFE hardware setup
++ *
++ * case 1: Capture to SDRAM with out IPIPE
++ * ****************************************
++ *
++ *            parallel
++ *                port
++ *
++ * Image sensor/       ________
++ * Yuv decoder    ---->| CCDC |--> SDRAM
++ *                     |______|
++ *
++ * case 2: Capture to SDRAM with IPIPE Preview modules in Continuous
++ *          (On the Fly mode)
++ *
++ * Image sensor/       ________    ____________________
++ * Yuv decoder    ---->| CCDC |--> | Previewer modules |--> SDRAM
++ *                     |______|    |___________________|
++ *
++ * case 3: Capture to SDRAM with IPIPE Preview modules  & Resizer
++ *         in continuous (On the Fly mode)
++ *
++ * Image sensor/       ________    _____________   ___________
++ * Yuv decoder    ---->| CCDC |--> | Previewer  |->| Resizer  |-> SDRAM
++ *                     |______|    |____________|  |__________|
++ *
++ * case 4: Capture to SDRAM with IPIPE Resizer
++ *         in continuous (On the Fly mode)
++ *
++ * Image sensor/       ________    ___________
++ * Yuv decoder    ---->| CCDC |--> | Resizer  |-> SDRAM
++ *                     |______|    |__________|
++ *
++ * case 5: Read from SDRAM and do preview and/or Resize
++ *         in Single shot mode
++ *
++ *                   _____________   ___________
++ *    SDRAM   ----> | Previewer  |->| Resizer  |-> SDRAM
++ *                  |____________|  |__________|
++ *
++ *
++ * Previewer allows fine tuning of the input image using different
++ * tuning modules in IPIPE. Some examples :- Noise filter, Defect
++ * pixel correction etc. It essentially operate on Bayer Raw data
++ * or YUV raw data. To do image tuning, application call,
++ * PREV_QUERY_CAP, and then call PREV_SET_PARAM to set parameter
++ * for a module.
++ *
++ *
++ * Resizer allows upscaling or downscaling a image to a desired
++ * resolution. There are 2 resizer modules. both operating on the
++ * same input image, but can have different output resolution.
++ * Resizer 0 has a maximum line size of 1344 pixels. So
++ * input and output size is limited to this size.
++ * Resizer 1 has a maximum line size of 640 pixels
++ */
++
++#ifndef DM355_IPIPE_H
++#define DM355_IPIPE_H
++
++struct ipipe_float_u16q16 {
++	unsigned short integer;
++	unsigned short decimal;
++};
++
++struct ipipe_float_s16q16 {
++	short integer;
++	unsigned short decimal;
++};
++
++
++/**********************************************************************
++**      Previewer API Structures
++**********************************************************************/
++
++/* Previewer module IDs used in PREV_SET/GET_PARAM IOCTL. Some
++ * modules can be also be updated during IPIPE operation. They are
++ * marked as control ID
++ */
++/* Prefilter. */
++#define PREV_PRE_FILTER		1
++/* Defect Pixel Correction */
++#define PREV_DFC		2
++/* Noise Filter */
++#define PREV_NF			3
++/* White Balance. Also a control ID */
++#define PREV_WB			4
++/* RGB to RBG Blend */
++#define PREV_RGB2RGB		5
++/* Gamma Correction */
++#define PREV_GAMMA		6
++/* RGB to YCbCr module */
++#define PREV_RGB2YUV		7
++/* Luminance Adjustment module. Also a control ID */
++#define PREV_LUM_ADJ		8
++/* YUV 422 conversion module */
++#define PREV_YUV422_CONV	9
++/* Edge Enhancement */
++#define PREV_YEE		10
++/* False Color Suppression */
++#define PREV_FCS		11
++/* Last module ID */
++#define PREV_MAX_MODULES	11
++
++
++struct ipipe_win {
++	/* vertical start line */
++	unsigned int vst;
++	/* horizontal start pixel */
++	unsigned int hst;
++	/* width */
++	unsigned int width;
++	/* height */
++	unsigned int height;
++};
++
++enum ipipe_pf_type {
++	PREV_PF_AVG4PIX = 0,
++	PREV_PF_AVG2MEDPIX = 1
++};
++
++/* Struct for configuring PREV_PRE_FILTER module */
++struct prev_prefilter {
++	/* 0 - disable, 1 - enable */
++	unsigned char en;
++	/* 0 - constant gain, 1 - adaptive gain control */
++	unsigned char en_adapt_prefilter;
++	/* 0 - Only pre-filter, 1 - Dot Reduction applied after pre-filter */
++	unsigned char en_adapt_dotred;
++	/* 0 - average of 4 pixels, 1 - average of 2 median pixels */
++	enum ipipe_pf_type aver_meth_gs1;
++	/* 0 - average of 4 pixels, 1 - average of 2 median pixels */
++	enum ipipe_pf_type aver_meth_gs2;
++	/* constant gain val if en_adapt_gc = 0,
++	 * slope in gain function if en_adapt_gc = 1
++	 */
++	unsigned int pre_gain;
++	/* down shift value in adaptive filter algorithm */
++	unsigned int pre_shf;
++	/* ThrG in adaptive filter algorithm */
++	unsigned int pre_thr_g;
++	/* ThrB in Dot Reduction */
++	unsigned int pre_thr_b;
++	/* Thr1 in the adaptive pre-filter algorithm */
++	unsigned int pre_thr_1;
++};
++
++/* Copy method selection for vertical correction
++ * Used when ipipe_dfc_corr_meth is PREV_DPC_CTORB_AFTER_HINT
++ */
++enum ipipe_dfc_copy_meth {
++	/* Copy from top */
++	IPIPE_DFC_COPY_FROM_TOP = 0,
++	/* Copy from bottom */
++	IPIPE_DFC_COPY_FROM_BOTTOM
++};
++
++enum ipipe_dfc_corr_meth {
++	/* horizontal interpolation */
++	IPIPE_DFC_H_INTP = 0,
++	/* Copy from left */
++	IPIPE_DFC_CL,
++	/* Copy from right */
++	IPIPE_DFC_CR,
++	/* 4 directional interpolation */
++	IPIPE_DFC_4_DIR_INTP,
++	/* Vertical interpolation after horizontal interpolation */
++	IPIPE_DFC_V_INTP_AFTER_H_INTP,
++	/* Vertical interpolation after copy from left */
++	IPIPE_DFC_V_INTP_AFTER_CL,
++	/* Vertical interpolation after copy from right */
++	IPIPE_DFC_V_INTP_AFTER_CR,
++	/* copy from top or bottom after horizontal interpolation */
++	IPIPE_DFC_CTORB_AFTER_HINT
++};
++
++struct ipipe_dfc_entry {
++	/* Horizontal position */
++	unsigned short horz_pos;
++	/* vertical position */
++	unsigned short vert_pos;
++	/* correction method */
++	enum ipipe_dfc_corr_meth method;
++};
++
++/* Struct for configuring DPC module */
++struct prev_dfc {
++	/* 0 - disable, 1 - enable */
++	unsigned char en;
++	/* Used when ipipe_dfc_corr_meth is PREV_DPC_CTORB_AFTER_HINT */
++	enum ipipe_dfc_copy_meth vert_copy_method;
++	/* number of entries in the correction table */
++	unsigned short dfc_size;
++	/* DFC entries table */
++	struct ipipe_dfc_entry *table;
++};
++
++
++/* Threshold values table size */
++#define IPIPE_NF_THR_TABLE_SIZE 32
++/* Intensity values table size */
++#define IPIPE_NF_STR_TABLE_SIZE 32
++
++/* NF, sampling method for green pixels */
++enum ipipe_nf_sampl_meth {
++	/* Same as R or B */
++	IPIPE_NF_BOX = 0,
++	/* Diamond mode */
++	IPIPE_NF_DIAMOND = 1
++};
++
++/* Struct for configuring NF module */
++struct prev_nf {
++	/* 0 - disable, 1 - enable */
++	unsigned char en;
++	/* Sampling method for green pixels */
++	enum ipipe_nf_sampl_meth gr_sample_meth;
++	/* Down shift value in LUT reference address */
++	unsigned char shft_val;
++	/* Spread value in NF algorithm */
++	unsigned char spread_val;
++	/* Threshold values table */
++	unsigned short thr[IPIPE_NF_THR_TABLE_SIZE];
++	/* intensity values table */
++	unsigned char str[IPIPE_NF_STR_TABLE_SIZE];
++};
++
++
++/* Struct for configuring WB module */
++struct prev_wb {
++	/* Digital gain (U10Q8). For brightness */
++	struct ipipe_float_u16q16 dgn;
++	/* Gain (U10Q7) for Red */
++	struct ipipe_float_u16q16 gain_r;
++	/* Gain (U10Q7) for Gr */
++	struct ipipe_float_u16q16 gain_gr;
++	/* Gain (U10Q7) for Gb */
++	struct ipipe_float_u16q16 gain_gb;
++	/* Gain (U10Q7) for Blue */
++	struct ipipe_float_u16q16 gain_b;
++};
++
++
++/* Struct for configuring RGB2RGB blending module */
++struct prev_rgb2rgb {
++	/* Matrix coefficient for RR S12Q8 */
++	struct ipipe_float_s16q16 coef_rr;
++	/* Matrix coefficient for GR S12Q8 */
++	struct ipipe_float_s16q16 coef_gr;
++	/* Matrix coefficient for BR S12Q8 */
++	struct ipipe_float_s16q16 coef_br;
++	/* Matrix coefficient for RG S12Q8 */
++	struct ipipe_float_s16q16 coef_rg;
++	/* Matrix coefficient for GG S12Q8 */
++	struct ipipe_float_s16q16 coef_gg;
++	/* Matrix coefficient for BG S12Q8 */
++	struct ipipe_float_s16q16 coef_bg;
++	/* Matrix coefficient for RB S12Q8 */
++	struct ipipe_float_s16q16 coef_rb;
++	/* Matrix coefficient for GB S12Q8 */
++	struct ipipe_float_s16q16 coef_gb;
++	/* Matrix coefficient for BB S12Q8 */
++	struct ipipe_float_s16q16 coef_bb;
++	/* Output offset for R S14Q0 */
++	int out_ofst_r;
++	/* Output offset for G S14Q0 */
++	int out_ofst_g;
++	/* Output offset for B S14Q0 */
++	int out_ofst_b;
++};
++
++enum ipipe_gamma_tbl_size {
++	IPIPE_GAMMA_TBL_SZ_128	= 0,
++	IPIPE_GAMMA_TBL_SZ_256	= 1,
++	IPIPE_GAMMA_TBL_SZ_512	= 3
++};
++
++enum ipipe_gamma_tbl_sel {
++	IPIPE_GAMMA_TBL_RAM = 0,
++	IPIPE_GAMMA_TBL_ROM = 1
++};
++
++struct ipipe_gamma_entry {
++	/* 10 bit slope */
++	unsigned short slope;
++	/* 10 bit offset */
++	unsigned short offset;
++};
++
++/* Struct for configuring Gamma correction module */
++struct prev_gamma {
++	/* 0 - Enable Gamma correction for Red
++	 * 1 - bypass Gamma correction. Data is divided by 16
++	 */
++	unsigned char bypass_r;
++	/* 0 - Enable Gamma correction for Blue
++	 * 1 - bypass Gamma correction. Data is divided by 16
++	 */
++	unsigned char bypass_b;
++	/* 0 - Enable Gamma correction for Green
++	 * 1 - bypass Gamma correction. Data is divided by 16
++	 */
++	unsigned char bypass_g;
++	/* PREV_GAMMA_TBL_RAM or PREV_GAMMA_TBL_ROM */
++	enum ipipe_gamma_tbl_sel tbl_sel;
++	/* Table size for RAM gamma table. */
++	enum ipipe_gamma_tbl_size tbl_size;
++	/* R table */
++	struct ipipe_gamma_entry *table_r;
++	/* Blue table */
++	struct ipipe_gamma_entry *table_b;
++	/* Green table */
++	struct ipipe_gamma_entry *table_g;
++	/* rgb all table */
++	struct ipipe_gamma_entry *table_rgb_all;
++};
++
++
++/* Struct for configuring rgb2ycbcr module */
++struct prev_rgb2yuv {
++	/* Matrix coefficient for RY S10Q8 */
++	struct ipipe_float_s16q16 coef_ry;
++	/* Matrix coefficient for GY S10Q8 */
++	struct ipipe_float_s16q16 coef_gy;
++	/* Matrix coefficient for BY S10Q8 */
++	struct ipipe_float_s16q16 coef_by;
++	/* Matrix coefficient for RCb S10Q8 */
++	struct ipipe_float_s16q16 coef_rcb;
++	/* Matrix coefficient for GCb S10Q8 */
++	struct ipipe_float_s16q16 coef_gcb;
++	/* Matrix coefficient for BCb S10Q8 */
++	struct ipipe_float_s16q16 coef_bcb;
++	/* Matrix coefficient for RCr S10Q8 */
++	struct ipipe_float_s16q16 coef_rcr;
++	/* Matrix coefficient for GCr S10Q8 */
++	struct ipipe_float_s16q16 coef_gcr;
++	/* Matrix coefficient for BCr S10Q8 */
++	struct ipipe_float_s16q16 coef_bcr;
++	/* Output offset for R S9Q0 */
++	int out_ofst_y;
++	/* Output offset for Cb S9Q0 */
++	int out_ofst_cb;
++	/* Output offset for Cr S9Q0 */
++	int out_ofst_cr;
++};
++
++/* Struct for configuring Luminance Adjustment module */
++struct prev_lum_adj {
++	/* Brightness adjustments */
++	unsigned char brightness;
++	/* contrast adjustments */
++	unsigned char contast;
++};
++
++/* Chrominance position. Applicable only for YCbCr input
++ * Applied after edge enhancement
++ */
++enum ipipe_yuv422_chr_pos {
++	/* Cositing, same position with luminance */
++	IPIPE_YUV422_CHR_POS_COSITE = 0,
++	/* Centering, In the middle of luminance */
++	IPIPE_YUV422_CHR_POS_CENTRE
++};
++
++/* Struct for configuring rgb2ycbcr module */
++struct prev_yuv422_conv {
++	/* Minimum Luminance value */
++	unsigned char lum_min;
++	/* Max Luminance value */
++	unsigned char lum_max;
++	/* Minimum Chrominance value */
++	unsigned char chrom_min;
++	/* Max Chrominance value */
++	unsigned char chrom_max;
++	/* 1 - enable LPF for chrminance, 0 - disable */
++	unsigned char en_chrom_lpf;
++	/* chroma position */
++	enum ipipe_yuv422_chr_pos chrom_pos;
++};
++
++/* Used to shift input data based on the image sensor
++ * interface requirement
++ */
++enum ipipeif_data_shift {
++	IPIPEIF_BITS15_2	= 0,
++	IPIPEIF_BITS14_1	= 1,
++	IPIPEIF_BITS13_0	= 2,
++	IPIPEIF_BITS12_0	= 3,
++	IPIPEIF_BITS11_0	= 4,
++	IPIPEIF_BITS10_0	= 5,
++	IPIPEIF_BITS9_0		= 6
++};
++
++/* Set ALAW & PACK8 status based on this */
++enum ipipe_pix_formats {
++	IPIPE_BAYER_8BIT_PACK,
++	IPIPE_BAYER_8BIT_PACK_ALAW,
++	/* 16 bit */
++	IPIPE_BAYER,
++	IPIPE_UYVY,
++	IPIPE_RGB565,
++	IPIPE_RGB888,
++	IPIPE_YUV420P
++};
++
++enum ipipeif_clkdiv {
++	IPIPEIF_DIVIDE_HALF		= 0,
++	IPIPEIF_DIVIDE_THIRD		= 1,
++	IPIPEIF_DIVIDE_FOURTH		= 2,
++	IPIPEIF_DIVIDE_FIFTH		= 3,
++	IPIPEIF_DIVIDE_SIXTH		= 4,
++	IPIPEIF_DIVIDE_EIGHTH		= 5,
++	IPIPEIF_DIVIDE_SIXTEENTH	= 6,
++	IPIPEIF_DIVIDE_THIRTY		= 7
++};
++
++enum ipipeif_decimation {
++	IPIPEIF_DECIMATION_OFF	= 0,
++	IPIPEIF_DECIMATION_ON	= 1
++};
++
++enum ipipe_dpaths_bypass_t {
++	IPIPE_BYPASS_OFF = 0,
++	IPIPE_BYPASS_ON  = 1
++};
++
++enum ipipe_colpat_t {
++	IPIPE_RED = 0,
++	IPIPE_GREEN_RED  = 1,
++	IPIPE_GREEN_BLUE = 2,
++	IPIPE_BLUE = 3
++};
++
++/* Structure for configuring Single Shot mode in the previewer
++ * channel
++ */
++
++struct prev_ss_input_spec {
++	/* width of the image in SDRAM.*/
++	unsigned int image_width;
++	/* height of the image in SDRAM */
++	unsigned int image_height;
++	/*
++	 * input image line length. Set this if you want to use a different
++	 * line length than that calculated based on image width. This should
++	 * be a multiple of 32. Driver adjust this to the next 32 byte boundary.
++	 */
++	unsigned int line_length;
++	/* vertical start position of the image
++	 * data to IPIPE
++	 */
++	unsigned int vst;
++	/* horizontal start position of the image
++	 * data to IPIPE
++	 */
++	unsigned int hst;
++	/* Global frame HD rate */
++	unsigned int ppln;
++	/* Global frame VD rate */
++	unsigned int lpfr;
++	/* clock divide to bring down the pixel clock*/
++	enum ipipeif_clkdiv clk_div;
++	/* Shift data as per image sensor capture format
++	 * only applicable for RAW Bayer inputs
++	 */
++	enum ipipeif_data_shift data_shift;
++	/* Enable decimation 1 - enable, 0 - disable
++	 * This is used for bringing down the line size
++	 * to that supported by IPIPE. DM355 IPIPE
++	 * can process only 1344 pixels per line.
++	 */
++	enum ipipeif_decimation dec_en;
++	/* used when en_dec = 1. Resize ratio for decimation
++	 * when frame size is greater than what hw can handle.
++	 * 16 to 112. IPIPE input width is calculated as follows.
++	 * width = image_width * 16/ipipeif_rsz. For example
++	 * if image_width is 1920 and user want to scale it down
++	 * to 1280, use ipipeif_rsz = 24. 1920*16/24 = 1280
++	 */
++	unsigned char rsz;
++	/* Enable/Disable avg filter at IPIPEIF.  1 - enable, 0 - disable */
++	unsigned char avg_filter_en;
++	/* Gain. 1 - 1023. divided by 512. So can be from 1/512 to 1/1023 */
++	unsigned short gain;
++	/* Input pixels formats */
++	enum ipipe_pix_formats pix_fmt;
++	/* Color pattern for odd line, odd pixel */
++	enum ipipe_colpat_t colp_olop;
++	/* Color pattern for odd line, even pixel */
++	enum ipipe_colpat_t colp_olep;
++	/* Color pattern for even line, odd pixel */
++	enum ipipe_colpat_t colp_elop;
++	/* Color pattern for even line, even pixel */
++	enum ipipe_colpat_t colp_elep;
++};
++
++struct prev_ss_output_spec {
++	/* output pixel format */
++	enum ipipe_pix_formats pix_fmt;
++};
++
++struct prev_single_shot_config {
++	/* Bypass image processing. RAW -> RAW */
++	enum ipipe_dpaths_bypass_t bypass;
++	/* Input specification for the image data */
++	struct prev_ss_input_spec input;
++	/* Output specification for the image data */
++	struct prev_ss_output_spec output;
++};
++
++struct prev_cont_input_spec {
++	/* 1 - enable, 0 - disable df subtraction */
++	unsigned char en_df_sub;
++	/* Enable decimation 1 - enable, 0 - disable
++	 * This is used for bringing down the line size
++	 * to that supported by IPIPE. DM355 IPIPE
++	 * can process only 1344 pixels per line.
++	 */
++	enum ipipeif_decimation dec_en;
++	/* used when en_dec = 1. Resize ratio for decimation
++	 * when frame size is greater than what hw can handle.
++	 * 16 to 112. IPIPE input width is calculated as follows.
++	 * width = image_width * 16/ipipeif_rsz. For example
++	 * if image_width is 1920 and user want to scale it down
++	 * to 1280, use ipipeif_rsz = 24. 1920*16/24 = 1280
++	 */
++	unsigned char rsz;
++	/* Enable/Disable avg filter at IPIPEIF. 1 - enable, 0 - disable */
++	unsigned char avg_filter_en;
++	/* Gain applied at IPIPEIF. 1 - 1023. divided by 512.So can be from
++	 * 1/512 to 1/1023.
++	 */
++	unsigned short gain;
++	/* Color pattern for odd line, odd pixel */
++	enum ipipe_colpat_t colp_olop;
++	/* Color pattern for odd line, even pixel */
++	enum ipipe_colpat_t colp_olep;
++	/* Color pattern for even line, odd pixel */
++	enum ipipe_colpat_t colp_elop;
++	/* Color pattern for even line, even pixel */
++	enum ipipe_colpat_t colp_elep;
++};
++
++/* Structure for configuring Continuous mode in the previewer
++ * channel . In continuous mode, only following parameters are
++ * available for configuration from user. Rest are configured
++ * through S_CROP and S_FMT IOCTLs in CCDC driver. In this mode
++ * data to IPIPEIF comes from CCDC
++ */
++struct prev_continuous_config {
++	/* Bypass image processing. RAW -> RAW */
++	enum ipipe_dpaths_bypass_t bypass;
++	/* Input specification for the image data */
++	struct prev_cont_input_spec input;
++};
++
++
++/*******************************************************************
++**  Resizer API structures
++*******************************************************************/
++
++
++/* Struct for configuring YUV Edge Enhancement module */
++struct prev_yee {
++	/* 1 - enable enhancement, 0 - disable */
++	unsigned char en;
++	/* 1 - enable Median NR, 0 - diable */
++	unsigned char en_emf;
++	/* HPF Shift length */
++	unsigned char hpf_shft;
++	/* HPF Coefficient 00, S10Q0 */
++	short hpf_coef_00;
++	/* HPF Coefficient 01, S10Q0 */
++	short hpf_coef_01;
++	/* HPF Coefficient 02, S10Q0 */
++	short hpf_coef_02;
++	/* HPF Coefficient 10, S10Q0 */
++	short hpf_coef_10;
++	/* HPF Coefficient 11, S10Q0 */
++	short hpf_coef_11;
++	/* HPF Coefficient 12, S10Q0 */
++	short hpf_coef_12;
++	/* HPF Coefficient 20, S10Q0 */
++	short hpf_coef_20;
++	/* HPF Coefficient 21, S10Q0 */
++	short hpf_coef_21;
++	/* HPF Coefficient 22, S10Q0 */
++	short hpf_coef_22;
++	/* Ptr to EE table. Must have 1024 entries */
++	short *table;
++};
++
++enum ipipe_fcs_type {
++	/* Y */
++	IPIPE_FCS_Y = 0,
++	/* Horizontal HPF */
++	IPIPE_FCS_HPF_HORZ,
++	/* Vertical HPF */
++	IPIPE_FCS_HPF_VERT,
++	/* 2D HPF */
++	IPIPE_FCS_2D_HPF,
++	/* 2D HPF from Y Edge Enhancement module */
++	IPIPE_FCS_2D_HPF_YEE
++};
++
++/* Struct for configuring FCS module */
++struct prev_fcs {
++	/* 1 - enable FCS, 0 - disable */
++	unsigned char en;
++	/* Selection of HOF for color suppression */
++	enum ipipe_fcs_type type;
++	/* Y Shift value for HPF */
++	unsigned char hpf_shft_y;
++	/* C Shift value for Gain function */
++	unsigned char gain_shft_c;
++	/* Threshold of the suppression Gain. Used in gain function */
++	unsigned short thr;
++	/* Intensity of the color suppression. Used in gain function */
++	unsigned short sgn;
++	/* Lower limit of the chroma gain. Used in gain function */
++	unsigned short lth;
++};
++
++/* Interpolation types used for horizontal rescale */
++enum rsz_h_intp_t {
++	RSZ_H_INTP_CUBIC = 0,
++	RSZ_H_INTP_LINEAR
++};
++
++/* Horizontal LPF intensity selection */
++enum rsz_h_lpf_lse_t {
++	RSZ_H_LPF_LSE_INTERN = 0,
++	RSZ_H_LPF_LSE_USER_VAL
++};
++
++/* Structure for configuring resizer in single shot mode.
++ * This structure is used when operation mode of the
++ * resizer is single shot. The related IOCTL is
++ * RSZ_S_CONFIG & RSZ_G_CONFIG. When chained, data to
++ * resizer comes from previewer. When not chained, only
++ * UYVY data input is allowed for resizer operation.
++ * To operate on RAW Bayer data from CCDC, chain resizer
++ * with previewer by setting chain field in the
++ * rsz_channel_config structure.
++ */
++
++struct rsz_ss_input_spec {
++	/* width of the image in SDRAM.*/
++	unsigned int image_width;
++	/* height of the image in SDRAM */
++	unsigned int image_height;
++	/*
++	 * input image line length. Set this if you want to use a different
++	 * line length than that calculated based on image width. This should
++	 * a multiple of 32. Driver adjust this to the next 32 byte boundary
++	 */
++	unsigned int line_length;
++	/* vertical start position of the image data to IPIPE */
++	unsigned int vst;
++	/* horizontal start position of the image data to IPIPE */
++	unsigned int hst;
++	/* Global frame HD rate */
++	unsigned int ppln;
++	/* Global frame VD rate */
++	unsigned int lpfr;
++	/* clock divide to bring down the pixel clock*/
++	enum ipipeif_clkdiv clk_div;
++	/* Enable decimation 1 - enable, 0 - disable
++	 * This is used for bringing down the line size
++	 * to that supported by IPIPE. DM355 IPIPE
++	 * can process only 1344 pixels per line.
++	 */
++	enum ipipeif_decimation dec_en;
++	/* used when en_dec = 1. Resize ratio for decimation
++	 * when frame size is greater than what hw can handle.
++	 * 16 to 112. IPIPE input width is calculated as follows.
++	 * width = image_width * 16/ipipeif_rsz. For example
++	 * if image_width is 1920 and user want to scale it down
++	 * to 1280, use ipipeif_rsz = 24. 1920*16/24 = 1280
++	 */
++	unsigned char rsz;
++	/* Enable/Disable avg filter at IPIPEIF. 1 - enable, 0 - disable */
++	unsigned char avg_filter_en;
++	/* Input pixels formats */
++	enum ipipe_pix_formats pix_fmt;
++};
++
++struct rsz_ss_output_spec {
++	/* enable the resizer output */
++	unsigned char enable;
++	/* output pixel format. Has to be UYVY */
++	enum ipipe_pix_formats pix_fmt;
++	/* width in pixels. must be multiple of 16. */
++	unsigned int width;
++	/* height in lines */
++	unsigned int height;
++	/* line start offset. */
++	unsigned int vst;
++	/* pixel start offset.*/
++	unsigned int hst;
++	/* horizontal rescale interpolation types */
++	enum rsz_h_intp_t h_intp_type;
++	/* horizontal hpf intesity value selection choices */
++	enum rsz_h_lpf_lse_t h_lpf_lse_sel;
++	/* User provided intensity value. Used when h_lpf_lse_sel
++	 * is RSZ_H_LPF_LSE_USER_VAL
++	 */
++	unsigned char lpf_user_val;
++};
++
++struct rsz_single_shot_config {
++	/* input spec of the image data (UYVY). non-chained
++	 * mode. Only valid when not chained. For chained
++	 * operation, previewer settings are used
++	 */
++	struct rsz_ss_input_spec input;
++	/* output spec of the image data coming out of resizer - 0(UYVY). */
++	struct rsz_ss_output_spec output1;
++	/* output spec of the image data coming out of resizer - 1(UYVY). */
++	struct rsz_ss_output_spec output2;
++	/* Image is flipped vertically, 0 - disable, 1 - enable */
++	unsigned char en_flip_vert;
++	/* Image is flipped horizontally, 0 - disable, 1 - enable */
++	unsigned char en_flip_horz;
++	/* 0 , chroma sample at odd pixel, 1 - even pixel */
++	unsigned char chroma_sample_even;
++	/* Enable Vertical anti aliasing filter 0 - disable, 1 - enable */
++	unsigned char en_vaaf;
++};
++
++struct rsz_cont_input_spec {
++	/* Enable decimation 1 - enable, 0 - disable
++	 * This is used for bringing down the line size
++	 * to that supported by IPIPE. DM355 IPIPE
++	 * can process only 1344 pixels per line.
++	 */
++	enum ipipeif_decimation dec_en;
++	/* used when en_dec = 1. Resize ratio for decimation
++	 * when frame size is greater than what hw can handle.
++	 * 16 to 112. IPIPE input width is calculated as follow.
++	 * width = image_width * 16/ipipeif_rsz. For example
++	 * if image_width is 1920 and user want to scale it down
++	 * to 1280, use ipipeif_rsz = 24. 1920*16/24 = 1280
++	 */
++	unsigned char rsz;
++	/* Enable/Disable avg filter at IPIPEIF.
++	 * 1 - enable, 0 - disable
++	 */
++	unsigned char avg_filter_en;
++	/* 1 - 1023. divided by 512. So can be from 1/512 to 1/1023 */
++	unsigned short gain;
++};
++
++struct rsz_continuous_config {
++	/* input spec of the image data (UYVY). non-chained
++	 * mode. Only valid when not chained. For chained
++	 * operation, previewer settings are used
++	 */
++	struct rsz_cont_input_spec input;
++	/* enable or disable resizer 0 output. 1 - enable,
++	 *   0 - disable
++	 */
++	unsigned char en_output1;
++	/* output spec of the image data coming out of resizer - 1(UYVY). */
++	struct rsz_ss_output_spec output2;
++	/* Image is flipped vertically, 0 - disable, 1 - enable */
++	unsigned char en_flip_vert;
++	/* Image is flipped horizontally, 0 - disable, 1 - enable */
++	unsigned char en_flip_horz;
++	/* 0 , chroma sample at odd pixel, 1 - even pixel */
++	unsigned char chroma_sample_even;
++	/* Enable Vertical anti aliasing filter 0 - disable, 1 - enable */
++	unsigned char en_vaaf;
++};
++
++#ifdef __KERNEL__
++#include <media/davinci/imp_common.h>
++enum ipipeif_clock {
++	PIXCEL_CLK	= 0,
++	SDRAM_CLK	= 1
++};
++
++enum ipipeif_ialaw {
++	ALAW_OFF	= 0,
++	ALAW_ON		= 1
++};
++
++enum ipipeif_pack_mode {
++	SIXTEEN_BIT	= 0,
++	EIGHT_BIT	= 1
++};
++
++enum ipipeif_avg_filter {
++	AVG_OFF		= 0,
++	AVG_ON		= 1
++};
++
++/* data paths */
++enum ipipe_data_paths {
++	/* Bayer RAW input to YCbCr output */
++	IPIPE_RAW2YUV = 0,
++	/* Bayer Raw to Bayer output */
++	IPIPE_RAW2RAW,
++	/* Bayer Raw to Boxcar output */
++	IPIPE_RAW2BOX,
++	/* YUV Raw to YUV Raw output */
++	IPIPE_YUV2YUV
++};
++
++enum ipipeif_input_source {
++	CCDC		= 0,
++	SDRAM_RAW	= 1,
++	CCDC_DARKFM	= 2,
++	SDRAM_YUV	= 3
++};
++
++enum ipipe_oper_mode {
++	CONTINUOUS  = 0,
++	ONE_SHOT    = 1
++};
++
++/*ipipeif structures*/
++struct ipipeif {
++	/*IPPEIF config register*/
++	enum ipipeif_data_shift data_shift;
++	enum ipipeif_clock clock_select;
++	enum ipipeif_ialaw ialaw;
++	enum ipipeif_pack_mode pack_mode;
++	enum ipipeif_avg_filter avg_filter;
++	enum ipipeif_clkdiv clk_div;
++	enum ipipeif_input_source source;
++	enum ipipeif_decimation decimation;
++	enum ipipe_oper_mode mode;
++
++	unsigned int glob_hor_size;
++	unsigned int glob_ver_size;
++	unsigned int hnum;
++	unsigned int vnum;
++	unsigned int adofs;
++	unsigned char rsz;
++	unsigned int gain;
++};
++
++enum enable_disable_t {
++	DISABLE =  0,
++	ENABLE =   1
++};
++
++/* Resizer Rescale Parameters*/
++struct ipipe_rsz_rescale_param {
++	enum ipipe_oper_mode rsz_mode;
++	unsigned int rsz_i_vst;
++	unsigned int rsz_i_vsz;
++	unsigned int rsz_i_hst;
++	unsigned int rsz_o_vsz;
++	unsigned int rsz_o_hsz;
++	unsigned int rsz_o_hst;
++	unsigned int rsz_v_phs;
++	unsigned int rsz_v_dif;
++	unsigned int rsz_h_phs;
++	unsigned int rsz_h_dif;
++	enum rsz_h_intp_t rsz_h_typ;
++	enum rsz_h_lpf_lse_t rsz_h_lse_sel;
++	unsigned char rsz_h_lpf;
++};
++
++enum ipipe_rsz_rgb_t {
++	OUTPUT_32BIT = 0,
++	OUTPUT_16BIT
++};
++
++enum ipipe_rsz_rgb_msk_t {
++	NOMASK = 0,
++	MASKLAST2
++};
++
++/* Resizer RGB Conversion Parameters */
++struct ipipe_rsz_resize2rgb {
++	enum enable_disable_t rsz_rgb_en;
++	enum ipipe_rsz_rgb_t rsz_rgb_typ;
++	enum ipipe_rsz_rgb_msk_t rsz_rgb_msk0;
++	enum ipipe_rsz_rgb_msk_t rsz_rgb_msk1;
++	unsigned int rsz_rgb_alpha_val;
++};
++
++/* Resizer External Memory Parameters */
++struct ipipe_ext_mem_param {
++	unsigned int rsz_sdr_bad_h;
++	unsigned int rsz_sdr_bad_l;
++	unsigned int rsz_sdr_sad_h;
++	unsigned int rsz_sdr_sad_l;
++	unsigned int rsz_sdr_oft;
++	unsigned int rsz_sdr_ptr_s;
++	unsigned int rsz_sdr_ptr_e;
++};
++
++struct ipipe_params {
++	struct ipipeif ipipeif_param;
++	enum ipipe_oper_mode ipipe_mode;
++	/*input/output datapath register*/
++	enum ipipe_data_paths ipipe_dpaths_fmt;
++	enum ipipe_dpaths_bypass_t ipipe_dpaths_bypass;
++
++	/*color pattern register*/
++	enum ipipe_colpat_t ipipe_colpat_elep;
++	enum ipipe_colpat_t ipipe_colpat_elop;
++	enum ipipe_colpat_t ipipe_colpat_olep;
++	enum ipipe_colpat_t ipipe_colpat_olop;
++
++	/*horizontal/vertical start, horizontal/vertical size*/
++	unsigned int ipipe_vst;
++	unsigned int ipipe_vsz;
++	unsigned int ipipe_hst;
++	unsigned int ipipe_hsz;
++
++	enum enable_disable_t rsz_seq_seq;
++	enum enable_disable_t rsz_seq_tmm;
++	enum enable_disable_t rsz_seq_hrv;
++	enum enable_disable_t rsz_seq_vrv;
++	enum enable_disable_t rsz_seq_crv;
++	enum enable_disable_t rsz_aal;
++
++	struct ipipe_rsz_rescale_param rsz_rsc_param[2];
++	struct ipipe_rsz_resize2rgb rsz2rgb[2];
++	struct ipipe_ext_mem_param ext_mem_param[2];
++	enum enable_disable_t rsz_en[2];
++};
++
++void ipipe_enable_reg_write(void);
++int ipipe_hw_setup(struct ipipe_params *config);
++int ipipe_default_raw2raw(struct ipipe_params *parameter);
++int ipipe_default_bypass_resizer(struct ipipe_params *parameter);
++int ipipe_default_bypass_ycbcr(struct ipipe_params *parameter);
++int ipipe_set_dfc_regs(struct prev_dfc *dfc);
++int ipipe_set_d2f_nf_regs(struct prev_nf *noise_filter);
++int ipipe_set_pf_regs(struct prev_prefilter *pre_filter);
++int ipipe_set_wb_regs(struct prev_wb *wb);
++int ipipe_set_rgb2ycbcr_regs(struct prev_rgb2yuv *yuv);
++int ipipe_set_lum_adj_regs(struct prev_lum_adj *lum_adj);
++int ipipe_set_yuv422_conv_regs(struct prev_yuv422_conv *conv);
++int ipipe_set_rgb2rgb_regs(struct prev_rgb2rgb *rgb);
++int ipipe_set_gamma_regs(struct prev_gamma *gamma);
++int ipipe_set_ee_regs(struct prev_yee *ee);
++int ipipe_set_fcs_regs(struct prev_fcs *fcs);
++int ipipe_set_rsz_regs(struct ipipe_params *param_resize);
++int ipipe_set_aal_regs(struct ipipe_params *param_resize);
++int ipipe_set_output_size(struct ipipe_params *params);
++int ipipe_set_output_offsets(int resizer, struct ipipe_params *params);
++int ipipe_set_rsz_structs(struct ipipe_params *params);
++int ipipe_set_resizer_address(struct ipipe_params *params,
++						int resize_no,
++						unsigned int address);
++int ipipe_set_ipipeif_address(struct ipipe_params *params,
++						unsigned int address);
++void ipipe_hw_dump_config(void);
++int rsz_enable(int rsz_id, int enable);
++
++#endif
++#endif
+--- a/drivers/media/video/davinci/ccdc_hw_device.h
++++ b/drivers/media/video/davinci/ccdc_hw_device.h
+@@ -57,7 +57,7 @@ struct ccdc_hw_ops {
+ 	 */
+ 	int (*get_params) (void *params);
+ 	/* Pointer to function to configure ccdc */
+-	int (*configure) (void);
++	int (*configure) (int mode);
+ 
+ 	/* Pointer to function to set buffer type */
+ 	int (*set_buftype) (enum ccdc_buftype buf_type);
+--- /dev/null
++++ b/include/video/davinci_vpbe.h
+@@ -0,0 +1,551 @@
++/*
++ * Copyright (C) 2006 Texas Instruments Inc
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option)any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
++ */
++#ifndef _DAVINCI_VPBE_H_
++#define _DAVINCI_VPBE_H_
++
++enum venc_soc_type {
++	DM644x = 0,
++	DM35x,
++	DM36x,
++};
++
++struct davinci_venc_platform_data {
++	enum venc_soc_type soc;
++};
++
++/* VPBE register base addresses */
++#define DM644X_VENC_REG_BASE		0x01C72400
++#define DM644X_OSD_REG_BASE		0x01C72600
++#define DM644X_VPBE_REG_BASE		0x01C72780
++
++#define DM355_VPSSCLK_REG_BASE		0x01C70000
++#define DM355_OSD_REG_BASE		0x01C70200
++#define DM355_VENC_REG_BASE		0x01C70400
++
++#define DM365_VENC_REG_BASE		0x01C71E00
++#define DM365_OSD_REG_BASE		0x01C71C00
++#define DM365_ISP5_REG_BASE		0x01C70000
++
++#define OSD_REG_SIZE			0x00000100
++
++/* SYS register addresses */
++#define SYS_VPSS_CLKCTL			0x01C40044
++
++#define DM3XX_VDAC_CONFIG		0x01C4002C
++#define DM355_USB_PHY_CTRL		0x01c40034
++
++/* VPBE Global Registers */
++#define VPBE_PID				0x0
++#define VPBE_PCR				0x4
++
++/* VPSS CLock Registers */
++#define VPSSCLK_PID				0x00
++#define VPSSCLK_CLKCTRL				0x04
++
++/* VPSS Buffer Logic Registers */
++#define VPSSBL_PID				0x00
++#define VPSSBL_PCR				0x04
++#define VPSSBL_BCR				0x08
++#define VPSSBL_INTSTAT				0x0C
++#define VPSSBL_INTSEL				0x10
++#define VPSSBL_EVTSEL				0x14
++#define VPSSBL_MEMCTRL				0x18
++#define VPSSBL_CCDCMUX				0x1C
++
++/* DM365 ISP5 system configuration */
++#define ISP5_PID				0x0
++#define ISP5_PCCR				0x4
++#define ISP5_BCR				0x8
++#define ISP5_INTSTAT				0xC
++#define ISP5_INTSEL1				0x10
++#define ISP5_INTSEL2				0x14
++#define ISP5_INTSEL3				0x18
++#define ISP5_EVTSEL				0x1c
++#define ISP5_CCDCMUX				0x20
++
++/* VPBE Video Encoder / Digital LCD Subsystem Registers (VENC) */
++#define VENC_VMOD				0x00
++#define VENC_VIDCTL				0x04
++#define VENC_VDPRO				0x08
++#define VENC_SYNCCTL				0x0C
++#define VENC_HSPLS				0x10
++#define VENC_VSPLS				0x14
++#define VENC_HINT				0x18
++#define VENC_HSTART				0x1C
++#define VENC_HVALID				0x20
++#define VENC_VINT				0x24
++#define VENC_VSTART				0x28
++#define VENC_VVALID				0x2C
++#define VENC_HSDLY				0x30
++#define VENC_VSDLY				0x34
++#define VENC_YCCCTL				0x38
++#define VENC_RGBCTL				0x3C
++#define VENC_RGBCLP				0x40
++#define VENC_LINECTL				0x44
++#define VENC_CULLLINE				0x48
++#define VENC_LCDOUT				0x4C
++#define VENC_BRTS				0x50
++#define VENC_BRTW				0x54
++#define VENC_ACCTL				0x58
++#define VENC_PWMP				0x5C
++#define VENC_PWMW				0x60
++#define VENC_DCLKCTL				0x64
++#define VENC_DCLKPTN0				0x68
++#define VENC_DCLKPTN1				0x6C
++#define VENC_DCLKPTN2				0x70
++#define VENC_DCLKPTN3				0x74
++#define VENC_DCLKPTN0A				0x78
++#define VENC_DCLKPTN1A				0x7C
++#define VENC_DCLKPTN2A				0x80
++#define VENC_DCLKPTN3A				0x84
++#define VENC_DCLKHS				0x88
++#define VENC_DCLKHSA				0x8C
++#define VENC_DCLKHR				0x90
++#define VENC_DCLKVS				0x94
++#define VENC_DCLKVR				0x98
++#define VENC_CAPCTL				0x9C
++#define VENC_CAPDO				0xA0
++#define VENC_CAPDE				0xA4
++#define VENC_ATR0				0xA8
++#define VENC_ATR1				0xAC
++#define VENC_ATR2				0xB0
++#define VENC_VSTAT				0xB8
++#define VENC_RAMADR				0xBC
++#define VENC_RAMPORT				0xC0
++#define VENC_DACTST				0xC4
++#define VENC_YCOLVL				0xC8
++#define VENC_SCPROG				0xCC
++#define VENC_CVBS				0xDC
++#define VENC_CMPNT				0xE0
++#define VENC_ETMG0				0xE4
++#define VENC_ETMG1				0xE8
++#define VENC_ETMG2				0xEC
++#define VENC_ETMG3				0xF0
++#define VENC_DACSEL				0xF4
++#define VENC_ARGBX0				0x100
++#define VENC_ARGBX1				0x104
++#define VENC_ARGBX2				0x108
++#define VENC_ARGBX3				0x10C
++#define VENC_ARGBX4				0x110
++#define VENC_DRGBX0				0x114
++#define VENC_DRGBX1				0x118
++#define VENC_DRGBX2				0x11C
++#define VENC_DRGBX3				0x120
++#define VENC_DRGBX4				0x124
++#define VENC_VSTARTA				0x128
++#define VENC_OSDCLK0				0x12C
++#define VENC_OSDCLK1				0x130
++#define VENC_HVLDCL0				0x134
++#define VENC_HVLDCL1				0x138
++#define VENC_OSDHADV				0x13C
++#define VENC_CLKCTL				0x140
++#define VENC_GAMCTL				0x144
++#define VENC_XHINTVL				0x174
++
++/* VPBE On-Screen Display Subsystem Registers (OSD) */
++#define OSD_MODE				0x00
++#define OSD_VIDWINMD				0x04
++#define OSD_OSDWIN0MD				0x08
++#define OSD_OSDWIN1MD				0x0C
++#define OSD_OSDATRMD				0x0C
++#define OSD_RECTCUR				0x10
++#define OSD_VIDWIN0OFST				0x18
++#define OSD_VIDWIN1OFST				0x1C
++#define OSD_OSDWIN0OFST				0x20
++#define OSD_OSDWIN1OFST				0x24
++#define OSD_VIDWINADH				0x28
++#define OSD_VIDWIN0ADL				0x2C
++#define OSD_VIDWIN0ADR				0x2C
++#define OSD_VIDWIN1ADL				0x30
++#define OSD_VIDWIN1ADR				0x30
++#define OSD_OSDWINADH				0x34
++#define OSD_OSDWIN0ADL				0x38
++#define OSD_OSDWIN0ADR				0x38
++#define OSD_OSDWIN1ADL				0x3C
++#define OSD_OSDWIN1ADR				0x3C
++#define OSD_BASEPX				0x40
++#define OSD_BASEPY				0x44
++#define OSD_VIDWIN0XP				0x48
++#define OSD_VIDWIN0YP				0x4C
++#define OSD_VIDWIN0XL				0x50
++#define OSD_VIDWIN0YL				0x54
++#define OSD_VIDWIN1XP				0x58
++#define OSD_VIDWIN1YP				0x5C
++#define OSD_VIDWIN1XL				0x60
++#define OSD_VIDWIN1YL				0x64
++#define OSD_OSDWIN0XP				0x68
++#define OSD_OSDWIN0YP				0x6C
++#define OSD_OSDWIN0XL				0x70
++#define OSD_OSDWIN0YL				0x74
++#define OSD_OSDWIN1XP				0x78
++#define OSD_OSDWIN1YP				0x7C
++#define OSD_OSDWIN1XL				0x80
++#define OSD_OSDWIN1YL				0x84
++#define OSD_CURXP				0x88
++#define OSD_CURYP				0x8C
++#define OSD_CURXL				0x90
++#define OSD_CURYL				0x94
++#define OSD_W0BMP01				0xA0
++#define OSD_W0BMP23				0xA4
++#define OSD_W0BMP45				0xA8
++#define OSD_W0BMP67				0xAC
++#define OSD_W0BMP89				0xB0
++#define OSD_W0BMPAB				0xB4
++#define OSD_W0BMPCD				0xB8
++#define OSD_W0BMPEF				0xBC
++#define OSD_W1BMP01				0xC0
++#define OSD_W1BMP23				0xC4
++#define OSD_W1BMP45				0xC8
++#define OSD_W1BMP67				0xCC
++#define OSD_W1BMP89				0xD0
++#define OSD_W1BMPAB				0xD4
++#define OSD_W1BMPCD				0xD8
++#define OSD_W1BMPEF				0xDC
++#define OSD_VBNDRY				0xE0
++#define OSD_EXTMODE				0xE4
++#define OSD_MISCCTL				0xE8
++#define OSD_CLUTRAMYCB				0xEC
++#define OSD_CLUTRAMCR				0xF0
++#define OSD_TRANSPVAL				0xF4
++#define OSD_TRANSPVALL				0xF4
++#define OSD_TRANSPVALU				0xF8
++#define OSD_TRANSPBMPIDX			0xFC
++#define OSD_PPVWIN0ADR				0xFC
++
++/* bit definitions */
++#define VPBE_PCR_VENC_DIV			(1 << 1)
++#define VPBE_PCR_CLK_OFF			(1 << 0)
++
++#define VPSSBL_INTSTAT_HSSIINT			(1 << 14)
++#define VPSSBL_INTSTAT_CFALDINT			(1 << 13)
++#define VPSSBL_INTSTAT_IPIPE_INT5		(1 << 12)
++#define VPSSBL_INTSTAT_IPIPE_INT4		(1 << 11)
++#define VPSSBL_INTSTAT_IPIPE_INT3		(1 << 10)
++#define VPSSBL_INTSTAT_IPIPE_INT2		(1 << 9)
++#define VPSSBL_INTSTAT_IPIPE_INT1		(1 << 8)
++#define VPSSBL_INTSTAT_IPIPE_INT0		(1 << 7)
++#define VPSSBL_INTSTAT_IPIPEIFINT		(1 << 6)
++#define VPSSBL_INTSTAT_OSDINT			(1 << 5)
++#define VPSSBL_INTSTAT_VENCINT			(1 << 4)
++#define VPSSBL_INTSTAT_H3AINT			(1 << 3)
++#define VPSSBL_INTSTAT_CCDC_VDINT2		(1 << 2)
++#define VPSSBL_INTSTAT_CCDC_VDINT1		(1 << 1)
++#define VPSSBL_INTSTAT_CCDC_VDINT0		(1 << 0)
++
++/* DM365 ISP5 bit definitions */
++#define ISP5_INTSTAT_VENCINT			(1 << 21)
++#define ISP5_INTSTAT_OSDINT			(1 << 20)
++
++#define VENC_VMOD_VDMD_SHIFT			12
++#define VENC_VMOD_VDMD_YCBCR16			0
++#define VENC_VMOD_VDMD_YCBCR8			1
++#define VENC_VMOD_VDMD_RGB666			2
++#define VENC_VMOD_VDMD_RGB8			3
++#define VENC_VMOD_VDMD_EPSON			4
++#define VENC_VMOD_VDMD_CASIO			5
++#define VENC_VMOD_VDMD_UDISPQVGA		6
++#define VENC_VMOD_VDMD_STNLCD			7
++#define VENC_VMOD_VIE_SHIFT			1
++#define VENC_VMOD_VDMD				(7 << 12)
++#define VENC_VMOD_ITLCL				(1 << 11)
++#define VENC_VMOD_ITLC				(1 << 10)
++#define VENC_VMOD_NSIT				(1 << 9)
++#define VENC_VMOD_HDMD				(1 << 8)
++#define VENC_VMOD_TVTYP_SHIFT			6
++#define VENC_VMOD_TVTYP				(3 << 6)
++#define VENC_VMOD_SLAVE				(1 << 5)
++#define VENC_VMOD_VMD				(1 << 4)
++#define VENC_VMOD_BLNK				(1 << 3)
++#define VENC_VMOD_VIE				(1 << 1)
++#define VENC_VMOD_VENC				(1 << 0)
++
++/* VMOD TVTYP options for HDMD=0 */
++#define SDTV_NTSC				0
++#define SDTV_PAL				1
++/* VMOD TVTYP options for HDMD=1 */
++#define HDTV_525P				0
++#define HDTV_625P				1
++#define HDTV_1080I				2
++#define HDTV_720P				3
++
++#define VENC_VIDCTL_VCLKP			(1 << 14)
++#define VENC_VIDCTL_VCLKE_SHIFT			13
++#define VENC_VIDCTL_VCLKE			(1 << 13)
++#define VENC_VIDCTL_VCLKZ_SHIFT			12
++#define VENC_VIDCTL_VCLKZ			(1 << 12)
++#define VENC_VIDCTL_SYDIR_SHIFT			8
++#define VENC_VIDCTL_SYDIR			(1 << 8)
++#define VENC_VIDCTL_DOMD_SHIFT			4
++#define VENC_VIDCTL_DOMD			(3 << 4)
++#define VENC_VIDCTL_YCDIR_SHIFT			0
++#define VENC_VIDCTL_YCDIR			(1 << 0)
++
++#define VENC_VDPRO_ATYCC_SHIFT			5
++#define VENC_VDPRO_ATYCC			(1 << 5)
++#define VENC_VDPRO_ATCOM_SHIFT			4
++#define VENC_VDPRO_ATCOM			(1 << 4)
++#define VENC_VDPRO_DAFRQ			(1 << 3)
++#define VENC_VDPRO_DAUPS			(1 << 2)
++#define VENC_VDPRO_CUPS				(1 << 1)
++#define VENC_VDPRO_YUPS				(1 << 0)
++
++#define VENC_SYNCCTL_VPL_SHIFT    		3
++#define VENC_SYNCCTL_VPL  			(1 << 3)
++#define VENC_SYNCCTL_HPL_SHIFT 	  		2
++#define VENC_SYNCCTL_HPL  			(1 << 2)
++#define VENC_SYNCCTL_SYEV_SHIFT   		1
++#define VENC_SYNCCTL_SYEV  			(1 << 1)
++#define VENC_SYNCCTL_SYEH_SHIFT   		0
++#define VENC_SYNCCTL_SYEH  			(1 << 0)
++#define VENC_SYNCCTL_OVD_SHIFT   		14
++#define VENC_SYNCCTL_OVD  			(1 << 14)
++
++#define VENC_DCLKCTL_DCKEC_SHIFT		11
++#define VENC_DCLKCTL_DCKEC			(1 << 11)
++#define VENC_DCLKCTL_DCKPW_SHIFT		0
++#define VENC_DCLKCTL_DCKPW			(0x3f << 0)
++
++#define VENC_VSTAT_FIDST			(1 << 4)
++
++#define VENC_CMPNT_MRGB_SHIFT			14
++#define VENC_CMPNT_MRGB				(1 << 14)
++
++#define OSD_MODE_CS				(1 << 15)
++#define OSD_MODE_OVRSZ				(1 << 14)
++#define OSD_MODE_OHRSZ				(1 << 13)
++#define OSD_MODE_EF				(1 << 12)
++#define OSD_MODE_VVRSZ				(1 << 11)
++#define OSD_MODE_VHRSZ				(1 << 10)
++#define OSD_MODE_FSINV				(1 << 9)
++#define OSD_MODE_BCLUT				(1 << 8)
++#define OSD_MODE_CABG_SHIFT			0
++#define OSD_MODE_CABG				(0xff << 0)
++
++#define OSD_VIDWINMD_VFINV			(1 << 15)
++#define OSD_VIDWINMD_V1EFC			(1 << 14)
++#define OSD_VIDWINMD_VHZ1_SHIFT			12
++#define OSD_VIDWINMD_VHZ1			(3 << 12)
++#define OSD_VIDWINMD_VVZ1_SHIFT			10
++#define OSD_VIDWINMD_VVZ1			(3 << 10)
++#define OSD_VIDWINMD_VFF1			(1 << 9)
++#define OSD_VIDWINMD_ACT1			(1 << 8)
++#define OSD_VIDWINMD_V0EFC			(1 << 6)
++#define OSD_VIDWINMD_VHZ0_SHIFT			4
++#define OSD_VIDWINMD_VHZ0			(3 << 4)
++#define OSD_VIDWINMD_VVZ0_SHIFT			2
++#define OSD_VIDWINMD_VVZ0			(3 << 2)
++#define OSD_VIDWINMD_VFF0			(1 << 1)
++#define OSD_VIDWINMD_ACT0			(1 << 0)
++
++#define OSD_OSDWIN0MD_ATN0E			(1 << 14)
++#define OSD_OSDWIN0MD_RGB0E			(1 << 13)
++#define OSD_OSDWIN0MD_BMP0MD_SHIFT		13
++#define OSD_OSDWIN0MD_BMP0MD			(3 << 13)
++#define OSD_OSDWIN0MD_CLUTS0			(1 << 12)
++#define OSD_OSDWIN0MD_OHZ0_SHIFT		10
++#define OSD_OSDWIN0MD_OHZ0			(3 << 10)
++#define OSD_OSDWIN0MD_OVZ0_SHIFT		8
++#define OSD_OSDWIN0MD_OVZ0			(3 << 8)
++#define OSD_OSDWIN0MD_BMW0_SHIFT		6
++#define OSD_OSDWIN0MD_BMW0			(3 << 6)
++#define OSD_OSDWIN0MD_BLND0_SHIFT		3
++#define OSD_OSDWIN0MD_BLND0			(7 << 3)
++#define OSD_OSDWIN0MD_TE0			(1 << 2)
++#define OSD_OSDWIN0MD_OFF0			(1 << 1)
++#define OSD_OSDWIN0MD_OACT0			(1 << 0)
++
++#define OSD_OSDWIN1MD_OASW			(1 << 15)
++#define OSD_OSDWIN1MD_ATN1E			(1 << 14)
++#define OSD_OSDWIN1MD_RGB1E			(1 << 13)
++#define OSD_OSDWIN1MD_BMP1MD_SHIFT		13
++#define OSD_OSDWIN1MD_BMP1MD			(3 << 13)
++#define OSD_OSDWIN1MD_CLUTS1			(1 << 12)
++#define OSD_OSDWIN1MD_OHZ1_SHIFT		10
++#define OSD_OSDWIN1MD_OHZ1			(3 << 10)
++#define OSD_OSDWIN1MD_OVZ1_SHIFT		8
++#define OSD_OSDWIN1MD_OVZ1			(3 << 8)
++#define OSD_OSDWIN1MD_BMW1_SHIFT		6
++#define OSD_OSDWIN1MD_BMW1			(3 << 6)
++#define OSD_OSDWIN1MD_BLND1_SHIFT		3
++#define OSD_OSDWIN1MD_BLND1			(7 << 3)
++#define OSD_OSDWIN1MD_TE1			(1 << 2)
++#define OSD_OSDWIN1MD_OFF1			(1 << 1)
++#define OSD_OSDWIN1MD_OACT1			(1 << 0)
++
++#define OSD_OSDATRMD_OASW			(1 << 15)
++#define OSD_OSDATRMD_OHZA_SHIFT			10
++#define OSD_OSDATRMD_OHZA			(3 << 10)
++#define OSD_OSDATRMD_OVZA_SHIFT			8
++#define OSD_OSDATRMD_OVZA			(3 << 8)
++#define OSD_OSDATRMD_BLNKINT_SHIFT		6
++#define OSD_OSDATRMD_BLNKINT			(3 << 6)
++#define OSD_OSDATRMD_OFFA			(1 << 1)
++#define OSD_OSDATRMD_BLNK			(1 << 0)
++
++#define OSD_RECTCUR_RCAD_SHIFT			8
++#define OSD_RECTCUR_RCAD			(0xff << 8)
++#define OSD_RECTCUR_CLUTSR			(1 << 7)
++#define OSD_RECTCUR_RCHW_SHIFT			4
++#define OSD_RECTCUR_RCHW			(7 << 4)
++#define OSD_RECTCUR_RCVW_SHIFT			1
++#define OSD_RECTCUR_RCVW			(7 << 1)
++#define OSD_RECTCUR_RCACT			(1 << 0)
++
++#define OSD_VIDWIN0OFST_V0LO			(0x1ff << 0)
++
++#define OSD_VIDWIN1OFST_V1LO			(0x1ff << 0)
++
++#define OSD_OSDWIN0OFST_O0LO			(0x1ff << 0)
++
++#define OSD_OSDWIN1OFST_O1LO			(0x1ff << 0)
++
++#define OSD_WINOFST_AH_SHIFT			9
++
++#define OSD_VIDWIN0OFST_V0AH			(0xf << 9)
++#define OSD_VIDWIN1OFST_V1AH			(0xf << 9)
++#define OSD_OSDWIN0OFST_O0AH			(0xf << 9)
++#define OSD_OSDWIN1OFST_O1AH			(0xf << 9)
++
++#define OSD_VIDWINADH_V1AH_SHIFT		8
++#define OSD_VIDWINADH_V1AH			(0x7f << 8)
++#define OSD_VIDWINADH_V0AH_SHIFT		0
++#define OSD_VIDWINADH_V0AH			(0x7f << 0)
++
++#define OSD_VIDWIN0ADL_V0AL			(0xffff << 0)
++
++#define OSD_VIDWIN1ADL_V1AL			(0xffff << 0)
++
++#define OSD_OSDWINADH_O1AH_SHIFT		8
++#define OSD_OSDWINADH_O1AH			(0x7f << 8)
++#define OSD_OSDWINADH_O0AH_SHIFT		0
++#define OSD_OSDWINADH_O0AH			(0x7f << 0)
++
++#define OSD_OSDWIN0ADL_O0AL			(0xffff << 0)
++
++#define OSD_OSDWIN1ADL_O1AL			(0xffff << 0)
++
++#define OSD_BASEPX_BPX				(0x3ff << 0)
++
++#define OSD_BASEPY_BPY				(0x1ff << 0)
++
++#define OSD_VIDWIN0XP_V0X			(0x7ff << 0)
++
++#define OSD_VIDWIN0YP_V0Y			(0x7ff << 0)
++
++#define OSD_VIDWIN0XL_V0W			(0x7ff << 0)
++
++#define OSD_VIDWIN0YL_V0H			(0x7ff << 0)
++
++#define OSD_VIDWIN1XP_V1X			(0x7ff << 0)
++
++#define OSD_VIDWIN1YP_V1Y			(0x7ff << 0)
++
++#define OSD_VIDWIN1XL_V1W			(0x7ff << 0)
++
++#define OSD_VIDWIN1YL_V1H			(0x7ff << 0)
++
++#define OSD_OSDWIN0XP_W0X			(0x7ff << 0)
++
++#define OSD_OSDWIN0YP_W0Y			(0x7ff << 0)
++
++#define OSD_OSDWIN0XL_W0W			(0x7ff << 0)
++
++#define OSD_OSDWIN0YL_W0H			(0x7ff << 0)
++
++#define OSD_OSDWIN1XP_W1X			(0x7ff << 0)
++
++#define OSD_OSDWIN1YP_W1Y			(0x7ff << 0)
++
++#define OSD_OSDWIN1XL_W1W			(0x7ff << 0)
++
++#define OSD_OSDWIN1YL_W1H			(0x7ff << 0)
++
++#define OSD_CURXP_RCSX				(0x7ff << 0)
++
++#define OSD_CURYP_RCSY				(0x7ff << 0)
++
++#define OSD_CURXL_RCSW				(0x7ff << 0)
++
++#define OSD_CURYL_RCSH				(0x7ff << 0)
++
++#define OSD_EXTMODE_EXPMDSEL			(1 << 15)
++#define OSD_EXTMODE_SCRNHEXP_SHIFT		13
++#define OSD_EXTMODE_SCRNHEXP			(3 << 13)
++#define OSD_EXTMODE_SCRNVEXP			(1 << 12)
++#define OSD_EXTMODE_OSD1BLDCHR			(1 << 11)
++#define OSD_EXTMODE_OSD0BLDCHR			(1 << 10)
++#define OSD_EXTMODE_ATNOSD1EN			(1 << 9)
++#define OSD_EXTMODE_ATNOSD0EN			(1 << 8)
++#define OSD_EXTMODE_OSDHRSZ15			(1 << 7)
++#define OSD_EXTMODE_VIDHRSZ15			(1 << 6)
++#define OSD_EXTMODE_ZMFILV1HEN			(1 << 5)
++#define OSD_EXTMODE_ZMFILV1VEN			(1 << 4)
++#define OSD_EXTMODE_ZMFILV0HEN			(1 << 3)
++#define OSD_EXTMODE_ZMFILV0VEN			(1 << 2)
++#define OSD_EXTMODE_EXPFILHEN			(1 << 1)
++#define OSD_EXTMODE_EXPFILVEN			(1 << 0)
++
++#define OSD_MISCCTL_BLDSEL			(1 << 15)
++#define OSD_MISCCTL_S420D			(1 << 14)
++#define OSD_MISCCTL_BMAPT			(1 << 13)
++#define OSD_MISCCTL_DM365M			(1 << 12)
++#define OSD_MISCCTL_RGBEN			(1 << 7)
++#define OSD_MISCCTL_RGBWIN			(1 << 6)
++#define OSD_MISCCTL_DMANG			(1 << 6)
++#define OSD_MISCCTL_TMON			(1 << 5)
++#define OSD_MISCCTL_RSEL			(1 << 4)
++#define OSD_MISCCTL_CPBSY			(1 << 3)
++#define OSD_MISCCTL_PPSW			(1 << 2)
++#define OSD_MISCCTL_PPRV			(1 << 1)
++
++#define OSD_CLUTRAMYCB_Y_SHIFT			8
++#define OSD_CLUTRAMYCB_Y			(0xff << 8)
++#define OSD_CLUTRAMYCB_CB_SHIFT			0
++#define OSD_CLUTRAMYCB_CB			(0xff << 0)
++
++#define OSD_CLUTRAMCR_CR_SHIFT			8
++#define OSD_CLUTRAMCR_CR			(0xff << 8)
++#define OSD_CLUTRAMCR_CADDR_SHIFT		0
++#define OSD_CLUTRAMCR_CADDR			(0xff << 0)
++
++#define OSD_TRANSPVAL_RGBTRANS			(0xffff << 0)
++
++#define OSD_TRANSPVALL_RGBL			(0xffff << 0)
++
++#define OSD_TRANSPVALU_Y_SHIFT			8
++#define OSD_TRANSPVALU_Y 			(0xff << 8)
++#define OSD_TRANSPVALU_RGBU_SHIFT		0
++#define OSD_TRANSPVALU_RGBU			(0xff << 0)
++
++#define OSD_TRANSPBMPIDX_BMP1_SHIFT		8
++#define OSD_TRANSPBMPIDX_BMP1			(0xff << 8)
++#define OSD_TRANSPBMPIDX_BMP0_SHIFT		0
++#define OSD_TRANSPBMPIDX_BMP0			0xff
++
++/**
++ * davinci_disp_is_second_field
++ *
++ * Returns: non-zero if true, zero otherwise
++ *
++ * Description:
++ * Check the Video Status Register (VSTAT) field FIDST to see if it's set
++ * if true then it is second field
++ */
++int davinci_disp_is_second_field(void);
++
++#endif				/* _DAVINCI_VPBE_H_ */
+--- a/drivers/media/video/davinci/vpif_capture.c
++++ b/drivers/media/video/davinci/vpif_capture.c
+@@ -36,6 +36,7 @@
+ #include <linux/version.h>
+ #include <media/v4l2-device.h>
+ #include <media/v4l2-ioctl.h>
++#include <media/davinci/videohd.h>
+ 
+ #include "vpif_capture.h"
+ #include "vpif.h"
+@@ -91,55 +92,22 @@ static const struct vpif_channel_config_
+ 		"PAL_BDGHIK", 720, 576, 25, 0, 1, 280, 1440, 1, 23, 311, 313,
+ 		336, 624, 625, 0, 1, 0, V4L2_STD_625_50,
+ 	},
++	/* Digital TV video standards  */
++	{
++		"1080I-30", 1920, 1080, 30, 0, 0, 272, 1920, 1, 21, 561, 564,
++		584, 1124, 1125, 0, 0, 1, V4L2_STD_1080I_60,
++	},
++	{
++		"720P-60", 1280, 720, 60, 1, 0, 362, 1280, 1, 26, 746, 0,
++		0, 0, 750, 0, 0, 1, V4L2_STD_720P_60,
++	},
++	{
++		"1080P-60", 1920, 1080, 60, 1, 0, 272, 1920, 1, 42, 1122, 0,
++		0, 0, 1125, 0, 0, 1, V4L2_STD_1080P_60,
++	},
+ };
+ 
+ /**
+- * vpif_uservirt_to_phys : translate user/virtual address to phy address
+- * @virtp: user/virtual address
+- *
+- * This inline function is used to convert user space virtual address to
+- * physical address.
+- */
+-static inline u32 vpif_uservirt_to_phys(u32 virtp)
+-{
+-	unsigned long physp = 0;
+-	struct mm_struct *mm = current->mm;
+-	struct vm_area_struct *vma;
+-
+-	vma = find_vma(mm, virtp);
+-
+-	/* For kernel direct-mapped memory, take the easy way */
+-	if (virtp >= PAGE_OFFSET)
+-		physp = virt_to_phys((void *)virtp);
+-	else if (vma && (vma->vm_flags & VM_IO) && (vma->vm_pgoff))
+-		/**
+-		 * this will catch, kernel-allocated, mmaped-to-usermode
+-		 * addresses
+-		 */
+-		physp = (vma->vm_pgoff << PAGE_SHIFT) + (virtp - vma->vm_start);
+-	else {
+-		/* otherwise, use get_user_pages() for general userland pages */
+-		int res, nr_pages = 1;
+-			struct page *pages;
+-
+-		down_read(&current->mm->mmap_sem);
+-
+-		res = get_user_pages(current, current->mm,
+-				     virtp, nr_pages, 1, 0, &pages, NULL);
+-		up_read(&current->mm->mmap_sem);
+-
+-		if (res == nr_pages)
+-			physp = __pa(page_address(&pages[0]) +
+-				     (virtp & ~PAGE_MASK));
+-		else {
+-			vpif_err("get_user_pages failed\n");
+-			return 0;
+-		}
+-	}
+-	return physp;
+-}
+-
+-/**
+  * buffer_prepare :  callback function for buffer prepare
+  * @q : buffer queue ptr
+  * @vb: ptr to video buffer
+@@ -158,7 +126,7 @@ static int vpif_buffer_prepare(struct vi
+ 	struct channel_obj *ch = fh->channel;
+ 	struct common_obj *common;
+ 	unsigned long addr;
+-
++	int ret;
+ 
+ 	vpif_dbg(2, debug, "vpif_buffer_prepare\n");
+ 
+@@ -170,30 +138,21 @@ static int vpif_buffer_prepare(struct vi
+ 		vb->height = common->height;
+ 		vb->size = vb->width * vb->height;
+ 		vb->field = field;
+-	}
+-	vb->state = VIDEOBUF_PREPARED;
+-	/**
+-	 * if user pointer memory mechanism is used, get the physical
+-	 * address of the buffer
+-	 */
+-	if (V4L2_MEMORY_USERPTR == common->memory) {
+-		if (0 == vb->baddr) {
+-			vpif_dbg(1, debug, "buffer address is 0\n");
+-			return -EINVAL;
+ 
+-		}
+-		vb->boff = vpif_uservirt_to_phys(vb->baddr);
+-		if (!IS_ALIGNED(vb->boff, 8))
++		ret = videobuf_iolock(q, vb, NULL);
++		if (ret < 0)
+ 			goto exit;
+-	}
+ 
+-	addr = vb->boff;
+-	if (q->streaming) {
+-		if (!IS_ALIGNED((addr + common->ytop_off), 8) ||
+-		    !IS_ALIGNED((addr + common->ybtm_off), 8) ||
+-		    !IS_ALIGNED((addr + common->ctop_off), 8) ||
+-		    !IS_ALIGNED((addr + common->cbtm_off), 8))
++		addr = videobuf_to_dma_contig(vb);
++
++		if (q->streaming) {
++			if (!IS_ALIGNED((addr + common->ytop_off), 8) ||
++			    !IS_ALIGNED((addr + common->ybtm_off), 8) ||
++			    !IS_ALIGNED((addr + common->ctop_off), 8) ||
++			    !IS_ALIGNED((addr + common->cbtm_off), 8))
+ 			goto exit;
++		}
++		vb->state = VIDEOBUF_PREPARED;
+ 	}
+ 	return 0;
+ exit:
+@@ -275,7 +234,8 @@ static void vpif_buffer_release(struct v
+ 
+ 	common = &ch->common[VPIF_VIDEO_INDEX];
+ 
+-	videobuf_dma_contig_free(q, vb);
++	if (common->memory == V4L2_MEMORY_MMAP)
++		videobuf_dma_contig_free(q, vb);
+ 	vb->state = VIDEOBUF_NEEDS_INIT;
+ }
+ 
+@@ -323,10 +283,7 @@ static void vpif_schedule_next_buffer(st
+ 	/* Remove that buffer from the buffer queue */
+ 	list_del(&common->next_frm->queue);
+ 	common->next_frm->state = VIDEOBUF_ACTIVE;
+-	if (V4L2_MEMORY_USERPTR == common->memory)
+-		addr = common->next_frm->boff;
+-	else
+-		addr = videobuf_to_dma_contig(common->next_frm);
++	addr = videobuf_to_dma_contig(common->next_frm);
+ 
+ 	/* Set top and bottom field addresses in VPIF registers */
+ 	common->set_addr(addr + common->ytop_off,
+@@ -561,7 +518,7 @@ static void vpif_config_format(struct ch
+ 	if (ch->vpifparams.iface.if_type == VPIF_IF_RAW_BAYER)
+ 		common->fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_SBGGR8;
+ 	else
+-		common->fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_YUV422P;
++		common->fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_NV16;
+ 	common->fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+ }
+ 
+@@ -600,7 +557,7 @@ static int vpif_check_format(struct chan
+ 	/**
+ 	 * first check for the pixel format. If if_type is Raw bayer,
+ 	 * only V4L2_PIX_FMT_SBGGR8 format is supported. Otherwise only
+-	 * V4L2_PIX_FMT_YUV422P is supported
++	 * V4L2_PIX_FMT_NV16 is supported
+ 	 */
+ 	if (vpif_params->iface.if_type == VPIF_IF_RAW_BAYER) {
+ 		if (pixfmt->pixelformat != V4L2_PIX_FMT_SBGGR8) {
+@@ -611,12 +568,12 @@ static int vpif_check_format(struct chan
+ 			pixfmt->pixelformat = V4L2_PIX_FMT_SBGGR8;
+ 		}
+ 	} else {
+-		if (pixfmt->pixelformat != V4L2_PIX_FMT_YUV422P) {
++		if (pixfmt->pixelformat != V4L2_PIX_FMT_NV16) {
+ 			if (!update) {
+ 				vpif_dbg(2, debug, "invalid pixel format\n");
+ 				goto exit;
+ 			}
+-			pixfmt->pixelformat = V4L2_PIX_FMT_YUV422P;
++			pixfmt->pixelformat = V4L2_PIX_FMT_NV16;
+ 		}
+ 	}
+ 
+@@ -924,7 +881,7 @@ static int vpif_reqbufs(struct file *fil
+ 
+ 	/* Initialize videobuf queue as per the buffer type */
+ 	videobuf_queue_dma_contig_init(&common->buffer_queue,
+-					    &video_qops, NULL,
++					    &video_qops, vpif_dev,
+ 					    &common->irqlock,
+ 					    reqbuf->type,
+ 					    common->fmt.fmt.pix.field,
+@@ -1048,10 +1005,7 @@ static int vpif_qbuf(struct file *file,
+ 
+ 	buf1->state = VIDEOBUF_ACTIVE;
+ 
+-	if (V4L2_MEMORY_USERPTR == common->memory)
+-		addr = buf1->boff;
+-	else
+-		addr = videobuf_to_dma_contig(buf1);
++	addr = videobuf_to_dma_contig(buf1);
+ 
+ 	common->next_frm = buf1;
+ 	common->set_addr(addr + common->ytop_off,
+@@ -1181,10 +1135,7 @@ static int vpif_streamon(struct file *fi
+ 	ch->field_id = 0;
+ 	common->started = 1;
+ 
+-	if (V4L2_MEMORY_USERPTR == common->memory)
+-		addr = common->cur_frm->boff;
+-	else
+-		addr = videobuf_to_dma_contig(common->cur_frm);
++	addr = videobuf_to_dma_contig(common->cur_frm);
+ 
+ 	/* Calculate the offset for Y and C data in the buffer */
+ 	vpif_calculate_offsets(ch);
+@@ -1465,6 +1416,19 @@ static int vpif_s_std(struct file *file,
+ 	/* Configure the default format information */
+ 	vpif_config_format(ch);
+ 
++	/**
++	 * if we are using one channel mode, then we need to
++	 * set filter value in ths7353 for TVP7002 input path
++	 */
++	if (!ch->vpifparams.std_info.ycmux_mode) {
++		ret = v4l2_device_call_until_err(&vpif_obj.v4l2_dev, 1, video,
++						 s_std_output, *std_id);
++		if (ret < 0) {
++			vpif_err("Failed to set filter for THS7353\n");
++			goto s_std_exit;
++		}
++	}
++
+ 	/* set standard in the sub device */
+ 	ret = v4l2_subdev_call(vpif_obj.sd[ch->curr_sd_index], core,
+ 				s_std, *std_id);
+@@ -1630,7 +1594,7 @@ static int vpif_enum_fmt_vid_cap(struct
+ 	} else {
+ 		fmt->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+ 		strcpy(fmt->description, "YCbCr4:2:2 YC Planar");
+-		fmt->pixelformat = V4L2_PIX_FMT_YUV422P;
++		fmt->pixelformat = V4L2_PIX_FMT_NV16;
+ 	}
+ 	return 0;
+ }
+--- a/arch/arm/configs/davinci_all_defconfig
++++ b/arch/arm/configs/davinci_all_defconfig
+@@ -1,14 +1,13 @@
+ #
+ # Automatically generated make config: don't edit
+-# Linux kernel version: 2.6.31-rc3-davinci1
+-# Fri Jul 17 08:26:52 2009
++# Linux kernel version: 2.6.32-rc2-davinci1
++# Mon Sep 28 15:56:11 2009
+ #
+ CONFIG_ARM=y
+ CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+ CONFIG_GENERIC_GPIO=y
+ CONFIG_GENERIC_TIME=y
+ CONFIG_GENERIC_CLOCKEVENTS=y
+-CONFIG_MMU=y
+ CONFIG_GENERIC_HARDIRQS=y
+ CONFIG_STACKTRACE_SUPPORT=y
+ CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+@@ -46,11 +45,12 @@ CONFIG_POSIX_MQUEUE_SYSCTL=y
+ #
+ # RCU Subsystem
+ #
+-CONFIG_CLASSIC_RCU=y
+-# CONFIG_TREE_RCU is not set
+-# CONFIG_PREEMPT_RCU is not set
++CONFIG_TREE_RCU=y
++# CONFIG_TREE_PREEMPT_RCU is not set
++# CONFIG_RCU_TRACE is not set
++CONFIG_RCU_FANOUT=32
++# CONFIG_RCU_FANOUT_EXACT is not set
+ # CONFIG_TREE_RCU_TRACE is not set
+-# CONFIG_PREEMPT_RCU_TRACE is not set
+ CONFIG_IKCONFIG=y
+ CONFIG_IKCONFIG_PROC=y
+ CONFIG_LOG_BUF_SHIFT=14
+@@ -91,17 +91,15 @@ CONFIG_SHMEM=y
+ CONFIG_AIO=y
+ 
+ #
+-# Performance Counters
++# Kernel Performance Events And Counters
+ #
+ CONFIG_VM_EVENT_COUNTERS=y
+ CONFIG_SLUB_DEBUG=y
+-# CONFIG_STRIP_ASM_SYMS is not set
+ CONFIG_COMPAT_BRK=y
+ # CONFIG_SLAB is not set
+ CONFIG_SLUB=y
+ # CONFIG_SLOB is not set
+ # CONFIG_PROFILING is not set
+-# CONFIG_MARKERS is not set
+ CONFIG_HAVE_OPROFILE=y
+ # CONFIG_KPROBES is not set
+ CONFIG_HAVE_KPROBES=y
+@@ -145,6 +143,7 @@ CONFIG_DEFAULT_IOSCHED="anticipatory"
+ #
+ # System Type
+ #
++CONFIG_MMU=y
+ # CONFIG_ARCH_AAEC2000 is not set
+ # CONFIG_ARCH_INTEGRATOR is not set
+ # CONFIG_ARCH_REALVIEW is not set
+@@ -159,6 +158,7 @@ CONFIG_DEFAULT_IOSCHED="anticipatory"
+ # CONFIG_ARCH_STMP3XXX is not set
+ # CONFIG_ARCH_NETX is not set
+ # CONFIG_ARCH_H720X is not set
++# CONFIG_ARCH_NOMADIK is not set
+ # CONFIG_ARCH_IOP13XX is not set
+ # CONFIG_ARCH_IOP32X is not set
+ # CONFIG_ARCH_IOP33X is not set
+@@ -181,11 +181,13 @@ CONFIG_DEFAULT_IOSCHED="anticipatory"
+ # CONFIG_ARCH_SA1100 is not set
+ # CONFIG_ARCH_S3C2410 is not set
+ # CONFIG_ARCH_S3C64XX is not set
++# CONFIG_ARCH_S5PC1XX is not set
+ # CONFIG_ARCH_SHARK is not set
+ # CONFIG_ARCH_LH7A40X is not set
+ # CONFIG_ARCH_U300 is not set
+ CONFIG_ARCH_DAVINCI=y
+ # CONFIG_ARCH_OMAP is not set
++# CONFIG_ARCH_BCMRING is not set
+ CONFIG_AINTC=y
+ CONFIG_ARCH_DAVINCI_DMx=y
+ 
+@@ -239,6 +241,7 @@ CONFIG_ARM_THUMB=y
+ # CONFIG_CPU_DCACHE_DISABLE is not set
+ # CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+ # CONFIG_CPU_CACHE_ROUND_ROBIN is not set
++CONFIG_ARM_L1_CACHE_SHIFT=5
+ CONFIG_COMMON_CLKDEV=y
+ 
+ #
+@@ -259,6 +262,8 @@ CONFIG_VMSPLIT_3G=y
+ # CONFIG_VMSPLIT_2G is not set
+ # CONFIG_VMSPLIT_1G is not set
+ CONFIG_PAGE_OFFSET=0xC0000000
++# CONFIG_PREEMPT_NONE is not set
++# CONFIG_PREEMPT_VOLUNTARY is not set
+ CONFIG_PREEMPT=y
+ CONFIG_HZ=100
+ CONFIG_AEABI=y
+@@ -280,6 +285,7 @@ CONFIG_BOUNCE=y
+ CONFIG_VIRT_TO_BUS=y
+ CONFIG_HAVE_MLOCK=y
+ CONFIG_HAVE_MLOCKED_PAGE_BIT=y
++# CONFIG_KSM is not set
+ CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+ CONFIG_LEDS=y
+ # CONFIG_LEDS_CPU is not set
+@@ -412,6 +418,7 @@ CONFIG_NETFILTER_ADVANCED=y
+ # CONFIG_IP6_NF_IPTABLES is not set
+ # CONFIG_IP_DCCP is not set
+ # CONFIG_IP_SCTP is not set
++# CONFIG_RDS is not set
+ # CONFIG_TIPC is not set
+ # CONFIG_ATM is not set
+ # CONFIG_BRIDGE is not set
+@@ -452,6 +459,7 @@ CONFIG_NETFILTER_ADVANCED=y
+ # Generic Driver Options
+ #
+ CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
++# CONFIG_DEVTMPFS is not set
+ CONFIG_STANDALONE=y
+ CONFIG_PREVENT_FIRMWARE_BUILD=y
+ # CONFIG_FW_LOADER is not set
+@@ -461,9 +469,9 @@ CONFIG_PREVENT_FIRMWARE_BUILD=y
+ # CONFIG_CONNECTOR is not set
+ CONFIG_MTD=m
+ # CONFIG_MTD_DEBUG is not set
++# CONFIG_MTD_TESTS is not set
+ # CONFIG_MTD_CONCAT is not set
+ CONFIG_MTD_PARTITIONS=y
+-# CONFIG_MTD_TESTS is not set
+ # CONFIG_MTD_REDBOOT_PARTS is not set
+ # CONFIG_MTD_AFS_PARTS is not set
+ # CONFIG_MTD_AR7_PARTS is not set
+@@ -499,7 +507,7 @@ CONFIG_MTD_CFI_I1=y
+ CONFIG_MTD_CFI_I2=y
+ # CONFIG_MTD_CFI_I4 is not set
+ # CONFIG_MTD_CFI_I8 is not set
+-# CONFIG_MTD_CFI_INTELEXT is not set
++CONFIG_MTD_CFI_INTELEXT=m
+ CONFIG_MTD_CFI_AMDSTD=m
+ # CONFIG_MTD_CFI_STAA is not set
+ CONFIG_MTD_CFI_UTIL=m
+@@ -696,10 +704,7 @@ CONFIG_DM9000_DEBUGLEVEL=4
+ # CONFIG_KS8842 is not set
+ # CONFIG_NETDEV_1000 is not set
+ # CONFIG_NETDEV_10000 is not set
+-
+-#
+-# Wireless LAN
+-#
++CONFIG_WLAN=y
+ # CONFIG_WLAN_PRE80211 is not set
+ # CONFIG_WLAN_80211 is not set
+ 
+@@ -734,6 +739,7 @@ CONFIG_NETPOLL=y
+ CONFIG_NETPOLL_TRAP=y
+ CONFIG_NET_POLL_CONTROLLER=y
+ # CONFIG_ISDN is not set
++# CONFIG_PHONE is not set
+ 
+ #
+ # Input device support
+@@ -745,10 +751,7 @@ CONFIG_INPUT=y
+ #
+ # Userland interfaces
+ #
+-CONFIG_INPUT_MOUSEDEV=m
+-CONFIG_INPUT_MOUSEDEV_PSAUX=y
+-CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+-CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
++# CONFIG_INPUT_MOUSEDEV is not set
+ # CONFIG_INPUT_JOYDEV is not set
+ CONFIG_INPUT_EVDEV=m
+ CONFIG_INPUT_EVBUG=m
+@@ -757,12 +760,16 @@ CONFIG_INPUT_EVBUG=m
+ # Input Device Drivers
+ #
+ CONFIG_INPUT_KEYBOARD=y
++# CONFIG_KEYBOARD_ADP5588 is not set
+ CONFIG_KEYBOARD_ATKBD=m
++# CONFIG_QT2160 is not set
+ # CONFIG_KEYBOARD_LKKBD is not set
+ CONFIG_KEYBOARD_GPIO=y
+ # CONFIG_KEYBOARD_MATRIX is not set
+ # CONFIG_KEYBOARD_LM8323 is not set
++# CONFIG_KEYBOARD_MAX7359 is not set
+ # CONFIG_KEYBOARD_NEWTON is not set
++# CONFIG_KEYBOARD_OPENCORES is not set
+ # CONFIG_KEYBOARD_STOWAWAY is not set
+ # CONFIG_KEYBOARD_SUNKBD is not set
+ CONFIG_KEYBOARD_XTKBD=m
+@@ -777,6 +784,7 @@ CONFIG_INPUT_TOUCHSCREEN=y
+ # CONFIG_TOUCHSCREEN_GUNZE is not set
+ # CONFIG_TOUCHSCREEN_ELO is not set
+ # CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
++# CONFIG_TOUCHSCREEN_MCS5000 is not set
+ # CONFIG_TOUCHSCREEN_MTOUCH is not set
+ # CONFIG_TOUCHSCREEN_INEXIO is not set
+ # CONFIG_TOUCHSCREEN_MK712 is not set
+@@ -787,7 +795,16 @@ CONFIG_INPUT_TOUCHSCREEN=y
+ # CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+ # CONFIG_TOUCHSCREEN_TSC2007 is not set
+ # CONFIG_TOUCHSCREEN_W90X900 is not set
+-# CONFIG_INPUT_MISC is not set
++CONFIG_INPUT_MISC=y
++# CONFIG_INPUT_ATI_REMOTE is not set
++# CONFIG_INPUT_ATI_REMOTE2 is not set
++# CONFIG_INPUT_KEYSPAN_REMOTE is not set
++# CONFIG_INPUT_POWERMATE is not set
++# CONFIG_INPUT_YEALINK is not set
++# CONFIG_INPUT_CM109 is not set
++# CONFIG_INPUT_UINPUT is not set
++# CONFIG_INPUT_GPIO_ROTARY_ENCODER is not set
++# CONFIG_INPUT_DM355EVM is not set
+ 
+ #
+ # Hardware I/O ports
+@@ -828,13 +845,13 @@ CONFIG_UNIX98_PTYS=y
+ CONFIG_LEGACY_PTYS=y
+ CONFIG_LEGACY_PTY_COUNT=256
+ # CONFIG_IPMI_HANDLER is not set
+-CONFIG_HW_RANDOM=m
+-# CONFIG_HW_RANDOM_TIMERIOMEM is not set
++# CONFIG_HW_RANDOM is not set
+ # CONFIG_R3964 is not set
+ # CONFIG_RAW_DRIVER is not set
+ # CONFIG_TCG_TPM is not set
+ CONFIG_I2C=y
+ CONFIG_I2C_BOARDINFO=y
++CONFIG_I2C_COMPAT=y
+ CONFIG_I2C_CHARDEV=y
+ CONFIG_I2C_HELPER_AUTO=y
+ 
+@@ -868,13 +885,17 @@ CONFIG_I2C_DAVINCI=y
+ # Miscellaneous I2C Chip support
+ #
+ # CONFIG_DS1682 is not set
+-# CONFIG_SENSORS_PCA9539 is not set
+ # CONFIG_SENSORS_TSL2550 is not set
+ # CONFIG_I2C_DEBUG_CORE is not set
+ # CONFIG_I2C_DEBUG_ALGO is not set
+ # CONFIG_I2C_DEBUG_BUS is not set
+ # CONFIG_I2C_DEBUG_CHIP is not set
+ # CONFIG_SPI is not set
++
++#
++# PPS support
++#
++# CONFIG_PPS is not set
+ CONFIG_ARCH_REQUIRE_GPIOLIB=y
+ CONFIG_GPIOLIB=y
+ # CONFIG_DEBUG_GPIO is not set
+@@ -889,7 +910,7 @@ CONFIG_GPIOLIB=y
+ #
+ # CONFIG_GPIO_MAX732X is not set
+ # CONFIG_GPIO_PCA953X is not set
+-CONFIG_GPIO_PCF857X=m
++CONFIG_GPIO_PCF857X=y
+ 
+ #
+ # PCI GPIO expanders:
+@@ -898,10 +919,19 @@ CONFIG_GPIO_PCF857X=m
+ #
+ # SPI GPIO expanders:
+ #
++
++#
++# AC97 GPIO expanders:
++#
+ # CONFIG_W1 is not set
+ # CONFIG_POWER_SUPPLY is not set
+ CONFIG_HWMON=y
+ # CONFIG_HWMON_VID is not set
++# CONFIG_HWMON_DEBUG_CHIP is not set
++
++#
++# Native drivers
++#
+ # CONFIG_SENSORS_AD7414 is not set
+ # CONFIG_SENSORS_AD7418 is not set
+ # CONFIG_SENSORS_ADM1021 is not set
+@@ -950,6 +980,7 @@ CONFIG_HWMON=y
+ # CONFIG_SENSORS_ADS7828 is not set
+ # CONFIG_SENSORS_THMC50 is not set
+ # CONFIG_SENSORS_TMP401 is not set
++# CONFIG_SENSORS_TMP421 is not set
+ # CONFIG_SENSORS_VT1211 is not set
+ # CONFIG_SENSORS_W83781D is not set
+ # CONFIG_SENSORS_W83791D is not set
+@@ -959,9 +990,7 @@ CONFIG_HWMON=y
+ # CONFIG_SENSORS_W83L786NG is not set
+ # CONFIG_SENSORS_W83627HF is not set
+ # CONFIG_SENSORS_W83627EHF is not set
+-# CONFIG_HWMON_DEBUG_CHIP is not set
+ # CONFIG_THERMAL is not set
+-# CONFIG_THERMAL_HWMON is not set
+ CONFIG_WATCHDOG=y
+ # CONFIG_WATCHDOG_NOWAYOUT is not set
+ 
+@@ -988,7 +1017,7 @@ CONFIG_SSB_POSSIBLE=y
+ # CONFIG_MFD_CORE is not set
+ # CONFIG_MFD_SM501 is not set
+ # CONFIG_MFD_ASIC3 is not set
+-# CONFIG_MFD_DM355EVM_MSP is not set
++CONFIG_MFD_DM355EVM_MSP=y
+ # CONFIG_HTC_EGPIO is not set
+ # CONFIG_HTC_PASIC3 is not set
+ # CONFIG_TPS65010 is not set
+@@ -999,9 +1028,11 @@ CONFIG_SSB_POSSIBLE=y
+ # CONFIG_MFD_TC6393XB is not set
+ # CONFIG_PMIC_DA903X is not set
+ # CONFIG_MFD_WM8400 is not set
++# CONFIG_MFD_WM831X is not set
+ # CONFIG_MFD_WM8350_I2C is not set
+ # CONFIG_MFD_PCF50633 is not set
+ # CONFIG_AB3100_CORE is not set
++# CONFIG_REGULATOR is not set
+ # CONFIG_MEDIA_SUPPORT is not set
+ 
+ #
+@@ -1013,9 +1044,9 @@ CONFIG_FB=y
+ CONFIG_FIRMWARE_EDID=y
+ # CONFIG_FB_DDC is not set
+ # CONFIG_FB_BOOT_VESA_SUPPORT is not set
+-# CONFIG_FB_CFB_FILLRECT is not set
+-# CONFIG_FB_CFB_COPYAREA is not set
+-# CONFIG_FB_CFB_IMAGEBLIT is not set
++CONFIG_FB_CFB_FILLRECT=y
++CONFIG_FB_CFB_COPYAREA=y
++CONFIG_FB_CFB_IMAGEBLIT=y
+ # CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+ # CONFIG_FB_SYS_FILLRECT is not set
+ # CONFIG_FB_SYS_COPYAREA is not set
+@@ -1032,6 +1063,7 @@ CONFIG_FIRMWARE_EDID=y
+ # Frame buffer hardware drivers
+ #
+ # CONFIG_FB_S1D13XXX is not set
++CONFIG_FB_DAVINCI=y
+ # CONFIG_FB_VIRTUAL is not set
+ # CONFIG_FB_METRONOME is not set
+ # CONFIG_FB_MB862XX is not set
+@@ -1101,7 +1133,6 @@ CONFIG_SND_SOC_TLV320AIC3X=m
+ # CONFIG_SOUND_PRIME is not set
+ CONFIG_HID_SUPPORT=y
+ CONFIG_HID=m
+-# CONFIG_HID_DEBUG is not set
+ # CONFIG_HIDRAW is not set
+ 
+ #
+@@ -1130,6 +1161,7 @@ CONFIG_HID_CYPRESS=m
+ CONFIG_HID_EZKEY=m
+ # CONFIG_HID_KYE is not set
+ CONFIG_HID_GYRATION=m
++# CONFIG_HID_TWINHAN is not set
+ # CONFIG_HID_KENSINGTON is not set
+ CONFIG_HID_LOGITECH=m
+ # CONFIG_LOGITECH_FF is not set
+@@ -1176,6 +1208,7 @@ CONFIG_USB_MON=m
+ # CONFIG_USB_OXU210HP_HCD is not set
+ # CONFIG_USB_ISP116X_HCD is not set
+ # CONFIG_USB_ISP1760_HCD is not set
++# CONFIG_USB_ISP1362_HCD is not set
+ # CONFIG_USB_SL811_HCD is not set
+ # CONFIG_USB_R8A66597_HCD is not set
+ # CONFIG_USB_HWA_HCD is not set
+@@ -1269,6 +1302,7 @@ CONFIG_USB_GADGET_SELECTED=y
+ # CONFIG_USB_GADGET_LH7A40X is not set
+ # CONFIG_USB_GADGET_OMAP is not set
+ # CONFIG_USB_GADGET_PXA25X is not set
++# CONFIG_USB_GADGET_R8A66597 is not set
+ # CONFIG_USB_GADGET_PXA27X is not set
+ # CONFIG_USB_GADGET_S3C_HSOTG is not set
+ # CONFIG_USB_GADGET_IMX is not set
+@@ -1286,6 +1320,7 @@ CONFIG_USB_ZERO=m
+ # CONFIG_USB_AUDIO is not set
+ CONFIG_USB_ETH=m
+ CONFIG_USB_ETH_RNDIS=y
++# CONFIG_USB_ETH_EEM is not set
+ CONFIG_USB_GADGETFS=m
+ CONFIG_USB_FILE_STORAGE=m
+ # CONFIG_USB_FILE_STORAGE_TEST is not set
+@@ -1316,8 +1351,10 @@ CONFIG_MMC_BLOCK=m
+ # MMC/SD/SDIO Host Controller Drivers
+ #
+ # CONFIG_MMC_SDHCI is not set
++# CONFIG_MMC_AT91 is not set
++# CONFIG_MMC_ATMELMCI is not set
++CONFIG_MMC_DAVINCI=m
+ # CONFIG_MEMSTICK is not set
+-# CONFIG_ACCESSIBILITY is not set
+ CONFIG_NEW_LEDS=y
+ CONFIG_LEDS_CLASS=m
+ 
+@@ -1345,6 +1382,7 @@ CONFIG_LEDS_TRIGGER_HEARTBEAT=m
+ #
+ # iptables trigger is under Netfilter config (LED target)
+ #
++# CONFIG_ACCESSIBILITY is not set
+ CONFIG_RTC_LIB=y
+ CONFIG_RTC_CLASS=m
+ 
+@@ -1370,6 +1408,7 @@ CONFIG_RTC_INTF_DEV=y
+ # CONFIG_RTC_DRV_PCF8563 is not set
+ # CONFIG_RTC_DRV_PCF8583 is not set
+ # CONFIG_RTC_DRV_M41T80 is not set
++# CONFIG_RTC_DRV_DM355EVM is not set
+ # CONFIG_RTC_DRV_S35390A is not set
+ # CONFIG_RTC_DRV_FM3130 is not set
+ # CONFIG_RTC_DRV_RX8581 is not set
+@@ -1399,8 +1438,11 @@ CONFIG_RTC_INTF_DEV=y
+ #
+ # CONFIG_DMADEVICES is not set
+ # CONFIG_AUXDISPLAY is not set
+-# CONFIG_REGULATOR is not set
+ # CONFIG_UIO is not set
++
++#
++# TI VLYNQ
++#
+ # CONFIG_STAGING is not set
+ 
+ #
+@@ -1429,6 +1471,7 @@ CONFIG_XFS_FS=m
+ # CONFIG_GFS2_FS is not set
+ # CONFIG_OCFS2_FS is not set
+ # CONFIG_BTRFS_FS is not set
++# CONFIG_NILFS2_FS is not set
+ CONFIG_FILE_LOCKING=y
+ CONFIG_FSNOTIFY=y
+ CONFIG_DNOTIFY=y
+@@ -1500,7 +1543,6 @@ CONFIG_MINIX_FS=m
+ # CONFIG_ROMFS_FS is not set
+ # CONFIG_SYSV_FS is not set
+ # CONFIG_UFS_FS is not set
+-# CONFIG_NILFS2_FS is not set
+ CONFIG_NETWORK_FILESYSTEMS=y
+ CONFIG_NFS_FS=y
+ CONFIG_NFS_V3=y
+@@ -1596,6 +1638,7 @@ CONFIG_ENABLE_WARN_DEPRECATED=y
+ CONFIG_ENABLE_MUST_CHECK=y
+ CONFIG_FRAME_WARN=1024
+ # CONFIG_MAGIC_SYSRQ is not set
++# CONFIG_STRIP_ASM_SYMS is not set
+ # CONFIG_UNUSED_SYMBOLS is not set
+ CONFIG_DEBUG_FS=y
+ # CONFIG_HEADERS_CHECK is not set
+@@ -1634,11 +1677,14 @@ CONFIG_DEBUG_BUGVERBOSE=y
+ # CONFIG_DEBUG_LIST is not set
+ # CONFIG_DEBUG_SG is not set
+ # CONFIG_DEBUG_NOTIFIERS is not set
++# CONFIG_DEBUG_CREDENTIALS is not set
++CONFIG_FRAME_POINTER=y
+ # CONFIG_BOOT_PRINTK_DELAY is not set
+ # CONFIG_RCU_TORTURE_TEST is not set
+ # CONFIG_RCU_CPU_STALL_DETECTOR is not set
+ # CONFIG_BACKTRACE_SELF_TEST is not set
+ # CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
++# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+ # CONFIG_FAULT_INJECTION is not set
+ # CONFIG_LATENCYTOP is not set
+ # CONFIG_SYSCTL_SYSCALL_CHECK is not set
+@@ -1663,7 +1709,7 @@ CONFIG_BRANCH_PROFILE_NONE=y
+ # CONFIG_SAMPLES is not set
+ CONFIG_HAVE_ARCH_KGDB=y
+ # CONFIG_KGDB is not set
+-CONFIG_ARM_UNWIND=y
++# CONFIG_ARM_UNWIND is not set
+ CONFIG_DEBUG_USER=y
+ CONFIG_DEBUG_ERRORS=y
+ # CONFIG_DEBUG_STACK_USAGE is not set
+@@ -1681,7 +1727,6 @@ CONFIG_CRYPTO=y
+ #
+ # Crypto core or helper
+ #
+-# CONFIG_CRYPTO_FIPS is not set
+ # CONFIG_CRYPTO_MANAGER is not set
+ # CONFIG_CRYPTO_MANAGER2 is not set
+ # CONFIG_CRYPTO_GF128MUL is not set
+@@ -1713,11 +1758,13 @@ CONFIG_CRYPTO=y
+ #
+ # CONFIG_CRYPTO_HMAC is not set
+ # CONFIG_CRYPTO_XCBC is not set
++# CONFIG_CRYPTO_VMAC is not set
+ 
+ #
+ # Digest
+ #
+ # CONFIG_CRYPTO_CRC32C is not set
++# CONFIG_CRYPTO_GHASH is not set
+ # CONFIG_CRYPTO_MD4 is not set
+ # CONFIG_CRYPTO_MD5 is not set
+ # CONFIG_CRYPTO_MICHAEL_MIC is not set
+--- /dev/null
++++ b/include/media/davinci/dm365_af.h
+@@ -0,0 +1,245 @@
++/* *
++ * Copyright (C) 2009 Texas Instruments Inc
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
++ */
++#ifndef AF_DM365_DRIVER_H
++#define AF_DM365_DRIVER_H
++
++#include <linux/ioctl.h>
++#ifdef __KERNEL__
++#include <linux/wait.h>
++#include <linux/mutex.h>
++#include <asm/io.h>
++#endif				/* End of __KERNEL_ */
++
++#ifdef __KERNEL__
++/* Device Constants */
++#define AF_MAJOR_NUMBER			0
++#define AF_NR_DEVS			1
++#define AF_TIMEOUT			((300 * HZ) / 1000)
++#endif				/* End of #ifdef __KERNEL__ */
++
++/* Range Constants */
++
++#define AF_PAXEL_HORIZONTAL_COUNT_MIN	1
++#define AF_PAXEL_HORIZONTAL_COUNT_MAX	36
++
++#define AF_PAXEL_VERTICAL_COUNT_MIN	1
++#define AF_PAXEL_VERTICAL_COUNT_MAX	128
++
++#define AF_PAXEL_HF_VF_COUNT_MAX	12
++#define AF_PAXEL_HF_VF_COUNT_MIN	1
++
++#define AF_WIDTH_MIN			8
++#define AF_WIDTH_MAX			512
++
++#define AF_LINE_INCR_MIN		2
++#define AF_LINE_INCR_MAX		32
++
++#define AF_COLUMN_INCR_MIN		2
++#define AF_COLUMN_INCR_MAX		32
++
++#define AF_HEIGHT_MIN			2
++#define AF_HEIGHT_MAX			512
++
++#define AF_HZSTART_MIN			2
++#define AF_HZSTART_MAX			4094
++
++#define AF_VTSTART_MIN			0
++#define AF_VTSTART_MAX			4095
++
++#define AF_MEDTH_MAX			255
++
++#define AF_IIRSH_MAX			4094
++
++/* Statistics data size per paxel */
++#define AF_PAXEL_SIZE_HF_ONLY		48
++#define AF_PAXEL_SIZE_HF_VF		64
++
++#define AF_NUMBER_OF_HFV_COEF		11
++#define AF_NUMBER_OF_VFV_COEF		5
++#define AF_HFV_COEF_MASK		0xFFF
++#define AF_VFV_COEF_MASK		0xFF
++#define AF_HFV_THR_MAX			0xFFFF
++#define AF_VFV_THR_MAX			0xFFFF
++
++/* list of ioctls */
++#pragma pack(1)
++#define  AF_IOC_MAXNR			5
++#define  AF_MAGIC_NO			'a'
++#define  AF_S_PARAM	_IOWR(AF_MAGIC_NO, 1, struct af_configuration *)
++#define  AF_G_PARAM	_IOWR(AF_MAGIC_NO, 2, struct af_configuration *)
++#define  AF_ENABLE	_IO(AF_MAGIC_NO, 3)
++#define  AF_DISABLE	_IO(AF_MAGIC_NO, 4)
++#pragma  pack()
++
++/* enum used for status of specific feature */
++enum af_enable_flag {
++	H3A_AF_DISABLE,
++	H3A_AF_ENABLE
++};
++
++enum af_config_flag {
++	H3A_AF_CONFIG_NOT_DONE,
++	H3A_AF_CONFIG
++};
++
++struct af_reg_dump {
++	unsigned int addr;
++	unsigned int val;
++};
++
++/* enum used for keep track of whether hardware is used */
++enum af_in_use_flag {
++	AF_NOT_IN_USE,
++	AF_IN_USE
++};
++
++enum af_mode {
++	ACCUMULATOR_SUMMED,
++	ACCUMULATOR_PEAK
++};
++
++/* Focus value selection */
++enum af_focus_val_sel {
++	/* 4 color Horizontal focus value only */
++	AF_HFV_ONLY,
++	/* 1 color Horizontal focus value & 1 color Vertical focus vlaue */
++	AF_HFV_AND_VFV
++};
++
++
++/* Red, Green, and blue pixel location in the AF windows */
++enum rgbpos {
++	/* GR and GB as Bayer pattern */
++	GR_GB_BAYER,
++	/* RG and GB as Bayer pattern */
++	RG_GB_BAYER,
++	/* GR and BG as Bayer pattern */
++	GR_BG_BAYER,
++	/* RG and BG as Bayer pattern */
++	RG_BG_BAYER,
++	/* GG and RB as custom pattern */
++	GG_RB_CUSTOM,
++	/* RB and GG as custom pattern */
++	RB_GG_CUSTOM
++};
++
++/* Contains the information regarding the Horizontal Median Filter */
++struct af_hmf {
++	/* Status of Horizontal Median Filter */
++	enum af_enable_flag enable;
++	/* Threshhold Value for Horizontal Median Filter */
++	unsigned int threshold;
++};
++
++/* Contains the information regarding the IIR Filters */
++struct af_iir {
++	/* IIR Start Register Value */
++	unsigned int hz_start_pos;
++	/* IIR Filter Coefficient for Set 0 */
++	int coeff_set0[AF_NUMBER_OF_HFV_COEF];
++	/* IIR Filter Coefficient for Set 1 */
++	int coeff_set1[AF_NUMBER_OF_HFV_COEF];
++};
++
++/* Contains the information regarding the VFV FIR filters */
++struct af_fir {
++	/* FIR 1 coefficents */
++	int coeff_1[AF_NUMBER_OF_VFV_COEF];
++	/* FIR 2 coefficents */
++	int coeff_2[AF_NUMBER_OF_VFV_COEF];
++	/* Horizontal FV threshold for FIR 1 */
++	unsigned int hfv_thr1;
++	/* Horizontal FV threshold for FIR 2 */
++	unsigned int hfv_thr2;
++	/* Vertical FV threshold for FIR 1 */
++	unsigned int vfv_thr1;
++	/* Vertical FV threshold for FIR 2 */
++	unsigned int vfv_thr2;
++};
++/* Contains the information regarding the Paxels Structure in AF Engine */
++struct af_paxel {
++	/* Width of the Paxel */
++	unsigned int width;
++	/* Height of the Paxel */
++	unsigned int height;
++	/* Horizontal Start Position */
++	unsigned int hz_start;
++	/* Vertical Start Position */
++	unsigned int vt_start;
++	/* Horizontal Count */
++	unsigned int hz_cnt;
++	/* Vertical Count */
++	unsigned int vt_cnt;
++	/* Line Increment */
++	unsigned int line_incr;
++	/* Column Increment. Only for VFV */
++	unsigned int column_incr;
++};
++
++
++/* Contains the parameters required for hardware set up of AF Engine */
++struct af_configuration {
++	/* ALAW status */
++	enum af_enable_flag alaw_enable;
++	/* Focus value selection */
++	enum af_focus_val_sel fv_sel;
++	/* HMF configurations */
++	struct af_hmf hmf_config;
++	/* RGB Positions. Only applicable with AF_HFV_ONLY selection */
++	enum rgbpos rgb_pos;
++	/* IIR filter configurations */
++	struct af_iir iir_config;
++	/* FIR filter configuration */
++	struct af_fir fir_config;
++	/* Paxel parameters */
++	struct af_paxel paxel_config;
++	/* Accumulator mode */
++	enum af_mode mode;
++};
++
++#ifdef __KERNEL__
++/* Structure for device of AF Engine */
++struct af_device {
++	/* Driver usage counter */
++	enum af_in_use_flag in_use;
++	/* Device configuration structure */
++	struct af_configuration *config;
++	/* Contains the latest statistics */
++	void *buff_old;
++	/* Buffer in which HW will fill the statistics or HW is already
++	 * filling statistics
++	 */
++	void *buff_curr;
++	/* Buffer which will be passed to */
++	void *buff_app;
++	/* user space on read call Size of image buffer */
++	unsigned int buff_size;
++	/* Flag indicates */
++	int buffer_filled;
++	/* statistics are available Paxel size in bytes */
++	int size_paxel;
++	/* Wait queue for driver */
++	wait_queue_head_t af_wait_queue;
++	/* mutex for driver */
++	struct mutex read_blocked;
++	/* Flag indicates Engine is configured */
++	enum af_config_flag af_config;
++};
++
++#endif				/* __KERNEL__ */
++#endif				/* AF_DM365_DRIVER_H */
+--- a/drivers/input/keyboard/Kconfig
++++ b/drivers/input/keyboard/Kconfig
+@@ -423,4 +423,14 @@ config KEYBOARD_W90P910
+ 	  To compile this driver as a module, choose M here: the
+ 	  module will be called w90p910_keypad.
+ 
++config KEYBOARD_DAVINCI
++	tristate "TI DaVinci Key Scan"
++	depends on ARCH_DAVINCI_DM365
++	help
++	  Say Y to enable keypad module support for the TI DaVinci
++	  platforms (DM365).
++
++	  To compile this driver as a module, choose M here: the
++	  module will be called davinci_keyscan.
++
+ endif
+--- a/arch/arm/mach-davinci/da830.c
++++ b/arch/arm/mach-davinci/da830.c
+@@ -411,7 +411,7 @@ static struct davinci_clk da830_clks[] =
+ 	CLK(NULL,		"pwm2",		&pwm2_clk),
+ 	CLK("eqep.0",		NULL,		&eqep0_clk),
+ 	CLK("eqep.1",		NULL,		&eqep1_clk),
+-	CLK("da830_lcdc",	NULL,		&lcdc_clk),
++	CLK("da8xx_lcdc.0",	NULL,		&lcdc_clk),
+ 	CLK("davinci-mcasp.0",	NULL,		&mcasp0_clk),
+ 	CLK("davinci-mcasp.1",	NULL,		&mcasp1_clk),
+ 	CLK("davinci-mcasp.2",	NULL,		&mcasp2_clk),
+@@ -1143,7 +1143,21 @@ static struct davinci_id da830_ids[] = {
+ 		.part_no	= 0xb7df,
+ 		.manufacturer	= 0x017,	/* 0x02f >> 1 */
+ 		.cpu_id		= DAVINCI_CPU_ID_DA830,
+-		.name		= "da830/omap l137",
++		.name		= "da830/omap-l137 rev1.0",
++	},
++	{
++		.variant	= 0x8,
++		.part_no	= 0xb7df,
++		.manufacturer	= 0x017,
++		.cpu_id		= DAVINCI_CPU_ID_DA830,
++		.name		= "da830/omap-l137 rev1.1",
++	},
++	{
++		.variant	= 0x9,
++		.part_no	= 0xb7df,
++		.manufacturer	= 0x017,
++		.cpu_id		= DAVINCI_CPU_ID_DA830,
++		.name		= "da830/omap-l137 rev2.0",
+ 	},
+ };
+ 
+@@ -1178,13 +1192,11 @@ static struct davinci_timer_info da830_t
+ static struct davinci_soc_info davinci_soc_info_da830 = {
+ 	.io_desc		= da830_io_desc,
+ 	.io_desc_num		= ARRAY_SIZE(da830_io_desc),
+-	.jtag_id_base		= IO_ADDRESS(DA8XX_JTAG_ID_REG),
+ 	.ids			= da830_ids,
+ 	.ids_num		= ARRAY_SIZE(da830_ids),
+ 	.cpu_clks		= da830_clks,
+ 	.psc_bases		= da830_psc_bases,
+ 	.psc_bases_num		= ARRAY_SIZE(da830_psc_bases),
+-	.pinmux_base		= IO_ADDRESS(DA8XX_BOOT_CFG_BASE + 0x120),
+ 	.pinmux_pins		= da830_pins,
+ 	.pinmux_pins_num	= ARRAY_SIZE(da830_pins),
+ 	.intc_base		= (void __iomem *)DA8XX_CP_INTC_VIRT,
+@@ -1201,5 +1213,13 @@ static struct davinci_soc_info davinci_s
+ 
+ void __init da830_init(void)
+ {
++	da8xx_syscfg_base = ioremap(DA8XX_SYSCFG_BASE, SZ_4K);
++	if (WARN(!da8xx_syscfg_base, "Unable to map syscfg module"))
++		return;
++
++	davinci_soc_info_da830.jtag_id_base =
++					DA8XX_SYSCFG_VIRT(DA8XX_JTAG_ID_REG);
++	davinci_soc_info_da830.pinmux_base = DA8XX_SYSCFG_VIRT(0x120);
++
+ 	davinci_common_init(&davinci_soc_info_da830);
+ }
+--- a/arch/arm/mach-davinci/dm365.c
++++ b/arch/arm/mach-davinci/dm365.c
+@@ -19,6 +19,7 @@
+ #include <linux/platform_device.h>
+ #include <linux/dma-mapping.h>
+ #include <linux/gpio.h>
++#include <linux/spi/spi.h>
+ 
+ #include <asm/mach/map.h>
+ 
+@@ -32,6 +33,11 @@
+ #include <mach/time.h>
+ #include <mach/serial.h>
+ #include <mach/common.h>
++#include <mach/asp.h>
++#include <mach/keyscan.h>
++#include <mach/spi.h>
++#include <video/davinci_osd.h>
++#include <video/davinci_vpbe.h>
+ 
+ #include "clock.h"
+ #include "mux.h"
+@@ -230,6 +236,7 @@ static struct clk vpss_dac_clk = {
+ 	.name		= "vpss_dac",
+ 	.parent		= &pll1_sysclk3,
+ 	.lpsc		= DM365_LPSC_DAC_CLK,
++	.flags		= ALWAYS_ENABLED,
+ };
+ 
+ static struct clk vpss_master_clk = {
+@@ -369,7 +376,7 @@ static struct clk timer3_clk = {
+ 
+ static struct clk usb_clk = {
+ 	.name		= "usb",
+-	.parent		= &pll2_sysclk1,
++	.parent		= &pll1_aux_clk,
+ 	.lpsc		= DAVINCI_LPSC_USB,
+ };
+ 
+@@ -456,7 +463,7 @@ static struct davinci_clk dm365_clks[] =
+ 	CLK(NULL, "usb", &usb_clk),
+ 	CLK("davinci_emac.1", NULL, &emac_clk),
+ 	CLK("voice_codec", NULL, &voicecodec_clk),
+-	CLK("soc-audio.0", NULL, &asp0_clk),
++	CLK("davinci-asp.0", NULL, &asp0_clk),
+ 	CLK(NULL, "rto", &rto_clk),
+ 	CLK(NULL, "mjcp", &mjcp_clk),
+ 	CLK(NULL, NULL, NULL),
+@@ -531,7 +538,7 @@ MUX_CFG(DM365,  EMAC_CRS,	3,   2,     1,
+ MUX_CFG(DM365,  EMAC_MDIO,	3,   1,     1,    1,     false)
+ MUX_CFG(DM365,  EMAC_MDCLK,	3,   0,     1,    1,     false)
+ 
+-MUX_CFG(DM365,	KEYPAD,		2,   0,     0x3f, 0x3f,  false)
++MUX_CFG(DM365,	KEYSCAN,	2,   0,     0x3f, 0x3f,  false)
+ 
+ MUX_CFG(DM365,	PWM0,		1,   0,     3,    2,     false)
+ MUX_CFG(DM365,	PWM0_G23,	3,   26,    3,    3,     false)
+@@ -603,9 +610,163 @@ INT_CFG(DM365,  INT_IMX1_ENABLE,     24,
+ INT_CFG(DM365,  INT_IMX1_DISABLE,    24,    1,    0,     false)
+ INT_CFG(DM365,  INT_NSF_ENABLE,      25,    1,    1,     false)
+ INT_CFG(DM365,  INT_NSF_DISABLE,     25,    1,    0,     false)
++
++EVT_CFG(DM365,	EVT2_ASP_TX,         0,     1,    0,     false)
++EVT_CFG(DM365,	EVT3_ASP_RX,         1,     1,    0,     false)
+ #endif
+ };
+ 
++static u64 dm365_spi0_dma_mask = DMA_BIT_MASK(32);
++
++static struct davinci_spi_platform_data dm365_spi0_pdata = {
++	.version 	= SPI_VERSION_1,
++	.num_chipselect = 2,
++	.clk_internal	= 1,
++	.cs_hold	= 1,
++	.intr_level	= 0,
++	.poll_mode	= 1,	/* 0 -> interrupt mode 1-> polling mode */
++	.use_dma	= 1,	/* when 1, value in poll_mode is ignored */
++	.c2tdelay	= 0,
++	.t2cdelay	= 0,
++};
++
++static struct resource dm365_spi0_resources[] = {
++	{
++		.start = 0x01c66000,
++		.end   = 0x01c667ff,
++		.flags = IORESOURCE_MEM,
++	},
++	{
++		.start = IRQ_DM365_SPIINT0_0,
++		.flags = IORESOURCE_IRQ,
++	},
++	{
++		.start = 17,
++		.flags = IORESOURCE_DMA | IORESOURCE_DMA_RX_CHAN,
++	},
++	{
++		.start = 16,
++		.flags = IORESOURCE_DMA | IORESOURCE_DMA_TX_CHAN,
++	},
++	{
++		.start = EVENTQ_3,
++		.flags = IORESOURCE_DMA | IORESOURCE_DMA_EVENT_Q,
++	},
++};
++
++static struct platform_device dm365_spi0_device = {
++	.name = "spi_davinci",
++	.id = 0,
++	.dev = {
++		.dma_mask = &dm365_spi0_dma_mask,
++		.coherent_dma_mask = DMA_BIT_MASK(32),
++		.platform_data = &dm365_spi0_pdata,
++	},
++	.num_resources = ARRAY_SIZE(dm365_spi0_resources),
++	.resource = dm365_spi0_resources,
++};
++
++void __init dm365_init_spi0(unsigned chipselect_mask,
++		struct spi_board_info *info, unsigned len)
++{
++	davinci_cfg_reg(DM365_SPI0_SCLK);
++	davinci_cfg_reg(DM365_SPI0_SDI);
++	davinci_cfg_reg(DM365_SPI0_SDO);
++
++	/* not all slaves will be wired up */
++	if (chipselect_mask & BIT(0))
++		davinci_cfg_reg(DM365_SPI0_SDENA0);
++	if (chipselect_mask & BIT(1))
++		davinci_cfg_reg(DM365_SPI0_SDENA1);
++
++	spi_register_board_info(info, len);
++
++	platform_device_register(&dm365_spi0_device);
++}
++
++
++/* IPIPEIF device configuration */
++static u64 dm365_ipipeif_dma_mask = DMA_BIT_MASK(32);
++static struct resource dm365_ipipeif_resources[] = {
++	{
++		.start          = 0x01C71200,
++		.end            = 0x01C71200 + 0x60,
++		.flags          = IORESOURCE_MEM,
++	},
++};
++
++static struct platform_device dm365_ipipeif_dev = {
++	.name		= "dm3xx_ipipeif",
++	.id		= -1,
++	.num_resources	= ARRAY_SIZE(dm365_ipipeif_resources),
++	.resource	= dm365_ipipeif_resources,
++	.dev = {
++		.dma_mask		= &dm365_ipipeif_dma_mask,
++		.coherent_dma_mask	= DMA_BIT_MASK(32),
++		/* For IPIPEIF device type. 1 - DM365 */
++		.platform_data		= (void *)1,
++	},
++};
++
++static u64 dm365_osd_dma_mask = DMA_BIT_MASK(32);
++
++static struct davinci_osd_platform_data dm365_osd_pdata = {
++	.type = DM365,
++};
++
++static struct resource dm365_osd_resources[] = {
++	{
++		.start          = IRQ_VENCINT,
++		.end            = IRQ_VENCINT,
++		.flags          = IORESOURCE_IRQ,
++	},
++	{
++		.start          = DM365_OSD_REG_BASE,
++		.end            = DM365_OSD_REG_BASE + OSD_REG_SIZE,
++		.flags          = IORESOURCE_MEM,
++	},
++};
++
++static struct platform_device dm365_osd_dev = {
++	.name		= "davinci_osd",
++	.id		= -1,
++	.num_resources	= ARRAY_SIZE(dm365_osd_resources),
++	.resource	= dm365_osd_resources,
++	.dev = {
++		.dma_mask		= &dm365_osd_dma_mask,
++		.coherent_dma_mask	= DMA_BIT_MASK(32),
++		.platform_data		= &dm365_osd_pdata,
++	},
++};
++
++static u64 dm365_venc_dma_mask = DMA_BIT_MASK(32);
++
++
++static struct davinci_venc_platform_data dm365_venc_pdata = {
++	.soc = DM36x,
++};
++
++
++static struct resource dm365_venc_resources[] = {
++	{
++		.start          = DM365_VENC_REG_BASE,
++		.end            = DM365_VENC_REG_BASE + 0x180,
++		.flags          = IORESOURCE_MEM,
++	},
++};
++
++static struct platform_device dm365_venc_dev = {
++	.name		= "davinci_venc",
++	.id		= -1,
++	.num_resources	= ARRAY_SIZE(dm365_venc_resources),
++	.resource	= dm365_venc_resources,
++	.dev = {
++		.dma_mask		= &dm365_venc_dma_mask,
++		.coherent_dma_mask	= DMA_BIT_MASK(32),
++		.platform_data		= &dm365_venc_pdata,
++	},
++};
++
+ static struct emac_platform_data dm365_emac_pdata = {
+ 	.ctrl_reg_offset	= DM365_EMAC_CNTRL_OFFSET,
+ 	.ctrl_mod_reg_offset	= DM365_EMAC_CNTRL_MOD_OFFSET,
+@@ -696,6 +857,7 @@ static u8 dm365_default_priorities[DAVIN
+ 	[IRQ_I2C]			= 3,
+ 	[IRQ_UARTINT0]			= 3,
+ 	[IRQ_UARTINT1]			= 3,
++	[IRQ_DM365_RTCINT]		= 3,
+ 	[IRQ_DM365_SPIINT0_0]		= 3,
+ 	[IRQ_DM365_SPIINT3_0]		= 3,
+ 	[IRQ_DM365_GPIO0]		= 3,
+@@ -806,6 +968,50 @@ static struct platform_device dm365_edma
+ 	.resource		= edma_resources,
+ };
+ 
++static struct resource dm365_asp_resources[] = {
++	{
++		.start	= DAVINCI_DM365_ASP0_BASE,
++		.end	= DAVINCI_DM365_ASP0_BASE + SZ_8K - 1,
++		.flags	= IORESOURCE_MEM,
++	},
++	{
++		.start	= DAVINCI_DMA_ASP0_TX,
++		.end	= DAVINCI_DMA_ASP0_TX,
++		.flags	= IORESOURCE_DMA,
++	},
++	{
++		.start	= DAVINCI_DMA_ASP0_RX,
++		.end	= DAVINCI_DMA_ASP0_RX,
++		.flags	= IORESOURCE_DMA,
++	},
++};
++
++static struct platform_device dm365_asp_device = {
++	.name		= "davinci-asp",
++	.id		= 0,
++	.num_resources	= ARRAY_SIZE(dm365_asp_resources),
++	.resource	= dm365_asp_resources,
++};
++
++static struct resource dm365_rtc_resources[] = {
++	{
++		.start = DM365_RTC_BASE,
++		.end = DM365_RTC_BASE + SZ_1K - 1,
++		.flags = IORESOURCE_MEM,
++	},
++	{
++		.start = IRQ_DM365_RTCINT,
++		.flags = IORESOURCE_IRQ,
++	},
++};
++
++static struct platform_device dm365_rtc_device = {
++	.name = "rtc_davinci",
++	.id = 0,
++	.num_resources = ARRAY_SIZE(dm365_rtc_resources),
++	.resource = dm365_rtc_resources,
++};
++
+ static struct map_desc dm365_io_desc[] = {
+ 	{
+ 		.virtual	= IO_VIRT,
+@@ -822,6 +1028,28 @@ static struct map_desc dm365_io_desc[] =
+ 	},
+ };
+ 
++static struct resource dm365_ks_resources[] = {
++	{
++		/* registers */
++		.start = DM365_KEYSCAN_BASE,
++		.end = DM365_KEYSCAN_BASE + SZ_1K - 1,
++		.flags = IORESOURCE_MEM,
++	},
++	{
++		/* interrupt */
++		.start = IRQ_DM365_KEYINT,
++		.end = IRQ_DM365_KEYINT,
++		.flags = IORESOURCE_IRQ,
++	},
++};
++
++static struct platform_device dm365_ks_device = {
++	.name		= "davinci_keyscan",
++	.id		= 0,
++	.num_resources	= ARRAY_SIZE(dm365_ks_resources),
++	.resource	= dm365_ks_resources,
++};
++
+ /* Contents of JTAG ID register used to identify exact cpu type */
+ static struct davinci_id dm365_ids[] = {
+ 	{
+@@ -907,11 +1135,118 @@ static struct davinci_soc_info davinci_s
+ 	.sram_len		= SZ_32K,
+ };
+ 
++void __init dm365_init_asp(struct snd_platform_data *pdata)
++{
++	davinci_cfg_reg(DM365_MCBSP0_BDX);
++	davinci_cfg_reg(DM365_MCBSP0_X);
++	davinci_cfg_reg(DM365_MCBSP0_BFSX);
++	davinci_cfg_reg(DM365_MCBSP0_BDR);
++	davinci_cfg_reg(DM365_MCBSP0_R);
++	davinci_cfg_reg(DM365_MCBSP0_BFSR);
++	davinci_cfg_reg(DM365_EVT2_ASP_TX);
++	davinci_cfg_reg(DM365_EVT3_ASP_RX);
++	dm365_asp_device.dev.platform_data = pdata;
++	platform_device_register(&dm365_asp_device);
++}
++
++void __init dm365_init_ks(struct davinci_ks_platform_data *pdata)
++{
++	dm365_ks_device.dev.platform_data = pdata;
++	platform_device_register(&dm365_ks_device);
++}
++
++void __init dm365_init_rtc(void)
++{
++	davinci_cfg_reg(DM365_INT_PRTCSS);
++	platform_device_register(&dm365_rtc_device);
++}
++
+ void __init dm365_init(void)
+ {
+ 	davinci_common_init(&davinci_soc_info_dm365);
+ }
+ 
++static struct resource dm365_vpss_resources[] = {
++	{
++		/* VPSS ISP5 Base address */
++		.name           = "vpss",
++		.start          = 0x01c70000,
++		.end            = 0x01c70000 + 0xff,
++		.flags          = IORESOURCE_MEM,
++	},
++	{
++		/* VPSS CLK Base address */
++		.name           = "vpss",
++		.start          = 0x01c70200,
++		.end            = 0x01c70200 + 0xff,
++		.flags          = IORESOURCE_MEM,
++	},
++};
++
++static struct platform_device dm365_vpss_device = {
++       .name                   = "vpss",
++       .id                     = -1,
++       .dev.platform_data      = "dm365_vpss",
++       .num_resources          = ARRAY_SIZE(dm365_vpss_resources),
++       .resource               = dm365_vpss_resources,
++};
++
++static struct resource vpfe_resources[] = {
++	{
++		.start          = IRQ_VDINT0,
++		.end            = IRQ_VDINT0,
++		.flags          = IORESOURCE_IRQ,
++	},
++	{
++		.start          = IRQ_VDINT1,
++		.end            = IRQ_VDINT1,
++		.flags          = IORESOURCE_IRQ,
++	},
++};
++
++static u64 vpfe_capture_dma_mask = DMA_BIT_MASK(32);
++static struct platform_device vpfe_capture_dev = {
++	.name           = CAPTURE_DRV_NAME,
++	.id             = -1,
++	.num_resources  = ARRAY_SIZE(vpfe_resources),
++	.resource       = vpfe_resources,
++	.dev = {
++		.dma_mask               = &vpfe_capture_dma_mask,
++		.coherent_dma_mask      = DMA_BIT_MASK(32),
++	},
++};
++
++static struct resource isif_resource[] = {
++	/* ISIF Base address */
++	{
++		.start          = 0x01c71000,
++		.end            = 0x01c71000 + 0x1ff,
++		.flags          = IORESOURCE_MEM,
++	},
++	/* ISIF Linearization table 0 */
++	{
++		.start          = 0x1C7C000,
++		.end            = 0x1C7C000 + 0x2ff,
++		.flags          = IORESOURCE_MEM,
++	},
++	/* ISIF Linearization table 1 */
++	{
++		.start          = 0x1C7C400,
++		.end            = 0x1C7C400 + 0x2ff,
++		.flags          = IORESOURCE_MEM,
++	},
++};
++static struct platform_device dm365_isif_dev = {
++	.name           = "dm365_isif",
++	.id             = -1,
++	.num_resources  = ARRAY_SIZE(isif_resource),
++	.resource       = isif_resource,
++	.dev = {
++		.dma_mask               = &vpfe_capture_dma_mask,
++		.coherent_dma_mask      = DMA_BIT_MASK(32),
++	},
++};
++
+ static int __init dm365_init_devices(void)
+ {
+ 	if (!cpu_is_davinci_dm365())
+@@ -921,6 +1256,26 @@ static int __init dm365_init_devices(voi
+ 	platform_device_register(&dm365_edma_device);
+ 	platform_device_register(&dm365_emac_device);
+ 
++	/*
++	* setup Mux configuration for vpfe input and register
++	* vpfe capture platform device
++	*/
++	platform_device_register(&dm365_vpss_device);
++	platform_device_register(&dm365_ipipeif_dev);
++	platform_device_register(&dm365_isif_dev);
++	platform_device_register(&vpfe_capture_dev);
++
++	/* Register OSD device */
++	platform_device_register(&dm365_osd_dev);
++
++	/* Register VENC device */
++	platform_device_register(&dm365_venc_dev);
++
+ 	return 0;
+ }
+ postcore_initcall(dm365_init_devices);
++
++void dm365_set_vpfe_config(struct vpfe_config *cfg)
++{
++       vpfe_capture_dev.dev.platform_data = cfg;
++}
+--- /dev/null
++++ b/arch/arm/configs/davinci_dm644x_defconfig
+@@ -0,0 +1,1711 @@
++#
++# Automatically generated make config: don't edit
++# Linux kernel version: 2.6.32-rc2-davinci1
++# Wed Oct  7 16:24:45 2009
++#
++CONFIG_ARM=y
++CONFIG_SYS_SUPPORTS_APM_EMULATION=y
++CONFIG_GENERIC_GPIO=y
++CONFIG_GENERIC_TIME=y
++CONFIG_GENERIC_CLOCKEVENTS=y
++CONFIG_GENERIC_HARDIRQS=y
++CONFIG_STACKTRACE_SUPPORT=y
++CONFIG_HAVE_LATENCYTOP_SUPPORT=y
++CONFIG_LOCKDEP_SUPPORT=y
++CONFIG_TRACE_IRQFLAGS_SUPPORT=y
++CONFIG_HARDIRQS_SW_RESEND=y
++CONFIG_GENERIC_IRQ_PROBE=y
++CONFIG_RWSEM_GENERIC_SPINLOCK=y
++CONFIG_GENERIC_HWEIGHT=y
++CONFIG_GENERIC_CALIBRATE_DELAY=y
++CONFIG_ZONE_DMA=y
++CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
++CONFIG_VECTORS_BASE=0xffff0000
++CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
++CONFIG_CONSTRUCTORS=y
++
++#
++# General setup
++#
++CONFIG_EXPERIMENTAL=y
++CONFIG_BROKEN_ON_SMP=y
++CONFIG_LOCK_KERNEL=y
++CONFIG_INIT_ENV_ARG_LIMIT=32
++CONFIG_LOCALVERSION=""
++CONFIG_LOCALVERSION_AUTO=y
++# CONFIG_SWAP is not set
++CONFIG_SYSVIPC=y
++CONFIG_SYSVIPC_SYSCTL=y
++CONFIG_POSIX_MQUEUE=y
++CONFIG_POSIX_MQUEUE_SYSCTL=y
++# CONFIG_BSD_PROCESS_ACCT is not set
++# CONFIG_TASKSTATS is not set
++# CONFIG_AUDIT is not set
++
++#
++# RCU Subsystem
++#
++CONFIG_TREE_RCU=y
++# CONFIG_TREE_PREEMPT_RCU is not set
++# CONFIG_RCU_TRACE is not set
++CONFIG_RCU_FANOUT=32
++# CONFIG_RCU_FANOUT_EXACT is not set
++# CONFIG_TREE_RCU_TRACE is not set
++CONFIG_IKCONFIG=y
++CONFIG_IKCONFIG_PROC=y
++CONFIG_LOG_BUF_SHIFT=14
++CONFIG_GROUP_SCHED=y
++CONFIG_FAIR_GROUP_SCHED=y
++# CONFIG_RT_GROUP_SCHED is not set
++CONFIG_USER_SCHED=y
++# CONFIG_CGROUP_SCHED is not set
++# CONFIG_CGROUPS is not set
++# CONFIG_SYSFS_DEPRECATED_V2 is not set
++# CONFIG_RELAY is not set
++# CONFIG_NAMESPACES is not set
++CONFIG_BLK_DEV_INITRD=y
++CONFIG_INITRAMFS_SOURCE=""
++CONFIG_RD_GZIP=y
++# CONFIG_RD_BZIP2 is not set
++# CONFIG_RD_LZMA is not set
++CONFIG_CC_OPTIMIZE_FOR_SIZE=y
++CONFIG_SYSCTL=y
++CONFIG_ANON_INODES=y
++CONFIG_EMBEDDED=y
++CONFIG_UID16=y
++CONFIG_SYSCTL_SYSCALL=y
++CONFIG_KALLSYMS=y
++# CONFIG_KALLSYMS_ALL is not set
++# CONFIG_KALLSYMS_EXTRA_PASS is not set
++CONFIG_HOTPLUG=y
++CONFIG_PRINTK=y
++CONFIG_BUG=y
++CONFIG_ELF_CORE=y
++CONFIG_BASE_FULL=y
++CONFIG_FUTEX=y
++CONFIG_EPOLL=y
++CONFIG_SIGNALFD=y
++CONFIG_TIMERFD=y
++CONFIG_EVENTFD=y
++CONFIG_SHMEM=y
++CONFIG_AIO=y
++
++#
++# Kernel Performance Events And Counters
++#
++CONFIG_VM_EVENT_COUNTERS=y
++CONFIG_SLUB_DEBUG=y
++CONFIG_COMPAT_BRK=y
++# CONFIG_SLAB is not set
++CONFIG_SLUB=y
++# CONFIG_SLOB is not set
++# CONFIG_PROFILING is not set
++CONFIG_HAVE_OPROFILE=y
++# CONFIG_KPROBES is not set
++CONFIG_HAVE_KPROBES=y
++CONFIG_HAVE_KRETPROBES=y
++CONFIG_HAVE_CLK=y
++
++#
++# GCOV-based kernel profiling
++#
++# CONFIG_GCOV_KERNEL is not set
++# CONFIG_SLOW_WORK is not set
++CONFIG_HAVE_GENERIC_DMA_COHERENT=y
++CONFIG_SLABINFO=y
++CONFIG_RT_MUTEXES=y
++CONFIG_BASE_SMALL=0
++CONFIG_MODULES=y
++# CONFIG_MODULE_FORCE_LOAD is not set
++CONFIG_MODULE_UNLOAD=y
++CONFIG_MODULE_FORCE_UNLOAD=y
++CONFIG_MODVERSIONS=y
++# CONFIG_MODULE_SRCVERSION_ALL is not set
++CONFIG_BLOCK=y
++CONFIG_LBDAF=y
++# CONFIG_BLK_DEV_BSG is not set
++# CONFIG_BLK_DEV_INTEGRITY is not set
++
++#
++# IO Schedulers
++#
++CONFIG_IOSCHED_NOOP=y
++CONFIG_IOSCHED_AS=y
++# CONFIG_IOSCHED_DEADLINE is not set
++# CONFIG_IOSCHED_CFQ is not set
++CONFIG_DEFAULT_AS=y
++# CONFIG_DEFAULT_DEADLINE is not set
++# CONFIG_DEFAULT_CFQ is not set
++# CONFIG_DEFAULT_NOOP is not set
++CONFIG_DEFAULT_IOSCHED="anticipatory"
++# CONFIG_FREEZER is not set
++
++#
++# System Type
++#
++CONFIG_MMU=y
++# CONFIG_ARCH_AAEC2000 is not set
++# CONFIG_ARCH_INTEGRATOR is not set
++# CONFIG_ARCH_REALVIEW is not set
++# CONFIG_ARCH_VERSATILE is not set
++# CONFIG_ARCH_AT91 is not set
++# CONFIG_ARCH_CLPS711X is not set
++# CONFIG_ARCH_GEMINI is not set
++# CONFIG_ARCH_EBSA110 is not set
++# CONFIG_ARCH_EP93XX is not set
++# CONFIG_ARCH_FOOTBRIDGE is not set
++# CONFIG_ARCH_MXC is not set
++# CONFIG_ARCH_STMP3XXX is not set
++# CONFIG_ARCH_NETX is not set
++# CONFIG_ARCH_H720X is not set
++# CONFIG_ARCH_NOMADIK is not set
++# CONFIG_ARCH_IOP13XX is not set
++# CONFIG_ARCH_IOP32X is not set
++# CONFIG_ARCH_IOP33X is not set
++# CONFIG_ARCH_IXP23XX is not set
++# CONFIG_ARCH_IXP2000 is not set
++# CONFIG_ARCH_IXP4XX is not set
++# CONFIG_ARCH_L7200 is not set
++# CONFIG_ARCH_KIRKWOOD is not set
++# CONFIG_ARCH_LOKI is not set
++# CONFIG_ARCH_MV78XX0 is not set
++# CONFIG_ARCH_ORION5X is not set
++# CONFIG_ARCH_MMP is not set
++# CONFIG_ARCH_KS8695 is not set
++# CONFIG_ARCH_NS9XXX is not set
++# CONFIG_ARCH_W90X900 is not set
++# CONFIG_ARCH_PNX4008 is not set
++# CONFIG_ARCH_PXA is not set
++# CONFIG_ARCH_MSM is not set
++# CONFIG_ARCH_RPC is not set
++# CONFIG_ARCH_SA1100 is not set
++# CONFIG_ARCH_S3C2410 is not set
++# CONFIG_ARCH_S3C64XX is not set
++# CONFIG_ARCH_S5PC1XX is not set
++# CONFIG_ARCH_SHARK is not set
++# CONFIG_ARCH_LH7A40X is not set
++# CONFIG_ARCH_U300 is not set
++CONFIG_ARCH_DAVINCI=y
++# CONFIG_ARCH_OMAP is not set
++# CONFIG_ARCH_BCMRING is not set
++CONFIG_AINTC=y
++CONFIG_ARCH_DAVINCI_DMx=y
++
++#
++# TI DaVinci Implementations
++#
++
++#
++# DaVinci Core Type
++#
++CONFIG_ARCH_DAVINCI_DM644x=y
++# CONFIG_ARCH_DAVINCI_DM355 is not set
++# CONFIG_ARCH_DAVINCI_DM646x is not set
++# CONFIG_ARCH_DAVINCI_DA830 is not set
++# CONFIG_ARCH_DAVINCI_DA850 is not set
++# CONFIG_ARCH_DAVINCI_DM365 is not set
++
++#
++# DaVinci Board Type
++#
++CONFIG_MACH_DAVINCI_EVM=y
++# CONFIG_MACH_SFFSDR is not set
++CONFIG_DAVINCI_MUX=y
++# CONFIG_DAVINCI_MUX_DEBUG is not set
++# CONFIG_DAVINCI_MUX_WARNINGS is not set
++CONFIG_DAVINCI_RESET_CLOCKS=y
++CONFIG_OSC_CLK_FREQ=27000000
++
++#
++# Processor Type
++#
++CONFIG_CPU_32=y
++CONFIG_CPU_ARM926T=y
++CONFIG_CPU_32v5=y
++CONFIG_CPU_ABRT_EV5TJ=y
++CONFIG_CPU_PABRT_NOIFAR=y
++CONFIG_CPU_CACHE_VIVT=y
++CONFIG_CPU_COPY_V4WB=y
++CONFIG_CPU_TLB_V4WBI=y
++CONFIG_CPU_CP15=y
++CONFIG_CPU_CP15_MMU=y
++
++#
++# Processor Features
++#
++CONFIG_ARM_THUMB=y
++# CONFIG_CPU_ICACHE_DISABLE is not set
++# CONFIG_CPU_DCACHE_DISABLE is not set
++# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
++# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
++CONFIG_ARM_L1_CACHE_SHIFT=5
++CONFIG_COMMON_CLKDEV=y
++CONFIG_FORCE_MAX_ZONEORDER=13
++
++#
++# Bus support
++#
++# CONFIG_PCI_SYSCALL is not set
++# CONFIG_ARCH_SUPPORTS_MSI is not set
++# CONFIG_PCCARD is not set
++
++#
++# Kernel Features
++#
++CONFIG_TICK_ONESHOT=y
++CONFIG_NO_HZ=y
++CONFIG_HIGH_RES_TIMERS=y
++CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
++CONFIG_VMSPLIT_3G=y
++# CONFIG_VMSPLIT_2G is not set
++# CONFIG_VMSPLIT_1G is not set
++CONFIG_PAGE_OFFSET=0xC0000000
++# CONFIG_PREEMPT_NONE is not set
++# CONFIG_PREEMPT_VOLUNTARY is not set
++CONFIG_PREEMPT=y
++CONFIG_HZ=100
++CONFIG_AEABI=y
++# CONFIG_OABI_COMPAT is not set
++# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
++# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
++# CONFIG_HIGHMEM is not set
++CONFIG_SELECT_MEMORY_MODEL=y
++CONFIG_FLATMEM_MANUAL=y
++# CONFIG_DISCONTIGMEM_MANUAL is not set
++# CONFIG_SPARSEMEM_MANUAL is not set
++CONFIG_FLATMEM=y
++CONFIG_FLAT_NODE_MEM_MAP=y
++CONFIG_PAGEFLAGS_EXTENDED=y
++CONFIG_SPLIT_PTLOCK_CPUS=4096
++# CONFIG_PHYS_ADDR_T_64BIT is not set
++CONFIG_ZONE_DMA_FLAG=1
++CONFIG_BOUNCE=y
++CONFIG_VIRT_TO_BUS=y
++CONFIG_HAVE_MLOCK=y
++CONFIG_HAVE_MLOCKED_PAGE_BIT=y
++# CONFIG_KSM is not set
++CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
++CONFIG_LEDS=y
++# CONFIG_LEDS_CPU is not set
++CONFIG_ALIGNMENT_TRAP=y
++# CONFIG_UACCESS_WITH_MEMCPY is not set
++
++#
++# Boot options
++#
++CONFIG_ZBOOT_ROM_TEXT=0x0
++CONFIG_ZBOOT_ROM_BSS=0x0
++CONFIG_CMDLINE=""
++# CONFIG_XIP_KERNEL is not set
++# CONFIG_KEXEC is not set
++
++#
++# CPU Power Management
++#
++# CONFIG_CPU_IDLE is not set
++
++#
++# Floating point emulation
++#
++
++#
++# At least one emulation must be selected
++#
++# CONFIG_VFP is not set
++
++#
++# Userspace binary formats
++#
++CONFIG_BINFMT_ELF=y
++# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
++CONFIG_HAVE_AOUT=y
++# CONFIG_BINFMT_AOUT is not set
++# CONFIG_BINFMT_MISC is not set
++
++#
++# Power management options
++#
++# CONFIG_PM is not set
++CONFIG_ARCH_SUSPEND_POSSIBLE=y
++CONFIG_NET=y
++
++#
++# Networking options
++#
++CONFIG_PACKET=y
++# CONFIG_PACKET_MMAP is not set
++CONFIG_UNIX=y
++CONFIG_XFRM=y
++# CONFIG_XFRM_USER is not set
++# CONFIG_XFRM_SUB_POLICY is not set
++# CONFIG_XFRM_MIGRATE is not set
++# CONFIG_XFRM_STATISTICS is not set
++# CONFIG_NET_KEY is not set
++CONFIG_INET=y
++# CONFIG_IP_MULTICAST is not set
++# CONFIG_IP_ADVANCED_ROUTER is not set
++CONFIG_IP_FIB_HASH=y
++CONFIG_IP_PNP=y
++CONFIG_IP_PNP_DHCP=y
++# CONFIG_IP_PNP_BOOTP is not set
++# CONFIG_IP_PNP_RARP is not set
++# CONFIG_NET_IPIP is not set
++# CONFIG_NET_IPGRE is not set
++# CONFIG_ARPD is not set
++# CONFIG_SYN_COOKIES is not set
++# CONFIG_INET_AH is not set
++# CONFIG_INET_ESP is not set
++# CONFIG_INET_IPCOMP is not set
++# CONFIG_INET_XFRM_TUNNEL is not set
++CONFIG_INET_TUNNEL=m
++CONFIG_INET_XFRM_MODE_TRANSPORT=y
++CONFIG_INET_XFRM_MODE_TUNNEL=y
++CONFIG_INET_XFRM_MODE_BEET=y
++# CONFIG_INET_LRO is not set
++CONFIG_INET_DIAG=y
++CONFIG_INET_TCP_DIAG=y
++# CONFIG_TCP_CONG_ADVANCED is not set
++CONFIG_TCP_CONG_CUBIC=y
++CONFIG_DEFAULT_TCP_CONG="cubic"
++# CONFIG_TCP_MD5SIG is not set
++CONFIG_IPV6=m
++# CONFIG_IPV6_PRIVACY is not set
++# CONFIG_IPV6_ROUTER_PREF is not set
++# CONFIG_IPV6_OPTIMISTIC_DAD is not set
++# CONFIG_INET6_AH is not set
++# CONFIG_INET6_ESP is not set
++# CONFIG_INET6_IPCOMP is not set
++# CONFIG_IPV6_MIP6 is not set
++# CONFIG_INET6_XFRM_TUNNEL is not set
++# CONFIG_INET6_TUNNEL is not set
++CONFIG_INET6_XFRM_MODE_TRANSPORT=m
++CONFIG_INET6_XFRM_MODE_TUNNEL=m
++CONFIG_INET6_XFRM_MODE_BEET=m
++# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
++CONFIG_IPV6_SIT=m
++CONFIG_IPV6_NDISC_NODETYPE=y
++# CONFIG_IPV6_TUNNEL is not set
++# CONFIG_IPV6_MULTIPLE_TABLES is not set
++# CONFIG_IPV6_MROUTE is not set
++# CONFIG_NETWORK_SECMARK is not set
++CONFIG_NETFILTER=y
++# CONFIG_NETFILTER_DEBUG is not set
++CONFIG_NETFILTER_ADVANCED=y
++
++#
++# Core Netfilter Configuration
++#
++# CONFIG_NETFILTER_NETLINK_QUEUE is not set
++# CONFIG_NETFILTER_NETLINK_LOG is not set
++# CONFIG_NF_CONNTRACK is not set
++# CONFIG_NETFILTER_XTABLES is not set
++# CONFIG_IP_VS is not set
++
++#
++# IP: Netfilter Configuration
++#
++# CONFIG_NF_DEFRAG_IPV4 is not set
++# CONFIG_IP_NF_QUEUE is not set
++# CONFIG_IP_NF_IPTABLES is not set
++# CONFIG_IP_NF_ARPTABLES is not set
++
++#
++# IPv6: Netfilter Configuration
++#
++# CONFIG_IP6_NF_QUEUE is not set
++# CONFIG_IP6_NF_IPTABLES is not set
++# CONFIG_IP_DCCP is not set
++# CONFIG_IP_SCTP is not set
++# CONFIG_RDS is not set
++# CONFIG_TIPC is not set
++# CONFIG_ATM is not set
++# CONFIG_BRIDGE is not set
++# CONFIG_NET_DSA is not set
++# CONFIG_VLAN_8021Q is not set
++# CONFIG_DECNET is not set
++# CONFIG_LLC2 is not set
++# CONFIG_IPX is not set
++# CONFIG_ATALK is not set
++# CONFIG_X25 is not set
++# CONFIG_LAPB is not set
++# CONFIG_ECONET is not set
++# CONFIG_WAN_ROUTER is not set
++# CONFIG_PHONET is not set
++# CONFIG_IEEE802154 is not set
++# CONFIG_NET_SCHED is not set
++# CONFIG_DCB is not set
++
++#
++# Network testing
++#
++# CONFIG_NET_PKTGEN is not set
++# CONFIG_HAMRADIO is not set
++# CONFIG_CAN is not set
++# CONFIG_IRDA is not set
++# CONFIG_BT is not set
++# CONFIG_AF_RXRPC is not set
++# CONFIG_WIRELESS is not set
++# CONFIG_WIMAX is not set
++# CONFIG_RFKILL is not set
++# CONFIG_NET_9P is not set
++
++#
++# Device Drivers
++#
++
++#
++# Generic Driver Options
++#
++CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
++# CONFIG_DEVTMPFS is not set
++CONFIG_STANDALONE=y
++CONFIG_PREVENT_FIRMWARE_BUILD=y
++# CONFIG_FW_LOADER is not set
++# CONFIG_DEBUG_DRIVER is not set
++# CONFIG_DEBUG_DEVRES is not set
++# CONFIG_SYS_HYPERVISOR is not set
++# CONFIG_CONNECTOR is not set
++# CONFIG_MTD is not set
++# CONFIG_PARPORT is not set
++CONFIG_BLK_DEV=y
++# CONFIG_BLK_DEV_COW_COMMON is not set
++CONFIG_BLK_DEV_LOOP=m
++# CONFIG_BLK_DEV_CRYPTOLOOP is not set
++# CONFIG_BLK_DEV_NBD is not set
++# CONFIG_BLK_DEV_UB is not set
++CONFIG_BLK_DEV_RAM=y
++CONFIG_BLK_DEV_RAM_COUNT=1
++CONFIG_BLK_DEV_RAM_SIZE=32768
++# CONFIG_BLK_DEV_XIP is not set
++# CONFIG_CDROM_PKTCDVD is not set
++# CONFIG_ATA_OVER_ETH is not set
++# CONFIG_MG_DISK is not set
++CONFIG_MISC_DEVICES=y
++# CONFIG_ICS932S401 is not set
++# CONFIG_ENCLOSURE_SERVICES is not set
++# CONFIG_ISL29003 is not set
++# CONFIG_C2PORT is not set
++
++#
++# EEPROM support
++#
++CONFIG_EEPROM_AT24=y
++# CONFIG_EEPROM_LEGACY is not set
++# CONFIG_EEPROM_MAX6875 is not set
++# CONFIG_EEPROM_93CX6 is not set
++CONFIG_HAVE_IDE=y
++CONFIG_IDE=y
++
++#
++# Please see Documentation/ide/ide.txt for help/info on IDE drives
++#
++CONFIG_IDE_XFER_MODE=y
++CONFIG_IDE_TIMINGS=y
++# CONFIG_BLK_DEV_IDE_SATA is not set
++CONFIG_IDE_GD=y
++CONFIG_IDE_GD_ATA=y
++# CONFIG_IDE_GD_ATAPI is not set
++# CONFIG_BLK_DEV_IDECD is not set
++# CONFIG_BLK_DEV_IDETAPE is not set
++# CONFIG_IDE_TASK_IOCTL is not set
++CONFIG_IDE_PROC_FS=y
++
++#
++# IDE chipset support/bugfixes
++#
++# CONFIG_BLK_DEV_PLATFORM is not set
++CONFIG_BLK_DEV_IDEDMA_SFF=y
++CONFIG_BLK_DEV_PALMCHIP_BK3710=y
++CONFIG_BLK_DEV_IDEDMA=y
++
++#
++# SCSI device support
++#
++# CONFIG_RAID_ATTRS is not set
++CONFIG_SCSI=y
++CONFIG_SCSI_DMA=y
++# CONFIG_SCSI_TGT is not set
++# CONFIG_SCSI_NETLINK is not set
++CONFIG_SCSI_PROC_FS=y
++
++#
++# SCSI support type (disk, tape, CD-ROM)
++#
++CONFIG_BLK_DEV_SD=y
++# CONFIG_CHR_DEV_ST is not set
++# CONFIG_CHR_DEV_OSST is not set
++# CONFIG_BLK_DEV_SR is not set
++# CONFIG_CHR_DEV_SG is not set
++# CONFIG_CHR_DEV_SCH is not set
++# CONFIG_SCSI_MULTI_LUN is not set
++# CONFIG_SCSI_CONSTANTS is not set
++# CONFIG_SCSI_LOGGING is not set
++# CONFIG_SCSI_SCAN_ASYNC is not set
++CONFIG_SCSI_WAIT_SCAN=m
++
++#
++# SCSI Transports
++#
++# CONFIG_SCSI_SPI_ATTRS is not set
++# CONFIG_SCSI_FC_ATTRS is not set
++# CONFIG_SCSI_ISCSI_ATTRS is not set
++# CONFIG_SCSI_SAS_LIBSAS is not set
++# CONFIG_SCSI_SRP_ATTRS is not set
++CONFIG_SCSI_LOWLEVEL=y
++# CONFIG_ISCSI_TCP is not set
++# CONFIG_LIBFC is not set
++# CONFIG_LIBFCOE is not set
++# CONFIG_SCSI_DEBUG is not set
++# CONFIG_SCSI_DH is not set
++# CONFIG_SCSI_OSD_INITIATOR is not set
++# CONFIG_ATA is not set
++# CONFIG_MD is not set
++CONFIG_NETDEVICES=y
++# CONFIG_DUMMY is not set
++# CONFIG_BONDING is not set
++# CONFIG_MACVLAN is not set
++# CONFIG_EQUALIZER is not set
++CONFIG_TUN=m
++# CONFIG_VETH is not set
++CONFIG_PHYLIB=y
++
++#
++# MII PHY device drivers
++#
++# CONFIG_MARVELL_PHY is not set
++# CONFIG_DAVICOM_PHY is not set
++# CONFIG_QSEMI_PHY is not set
++CONFIG_LXT_PHY=y
++# CONFIG_CICADA_PHY is not set
++# CONFIG_VITESSE_PHY is not set
++# CONFIG_SMSC_PHY is not set
++# CONFIG_BROADCOM_PHY is not set
++# CONFIG_ICPLUS_PHY is not set
++# CONFIG_REALTEK_PHY is not set
++# CONFIG_NATIONAL_PHY is not set
++# CONFIG_STE10XP is not set
++CONFIG_LSI_ET1011C_PHY=y
++# CONFIG_FIXED_PHY is not set
++# CONFIG_MDIO_BITBANG is not set
++CONFIG_NET_ETHERNET=y
++# CONFIG_MII is not set
++# CONFIG_AX88796 is not set
++# CONFIG_SMC91X is not set
++CONFIG_TI_DAVINCI_EMAC=y
++# CONFIG_DM9000 is not set
++# CONFIG_ETHOC is not set
++# CONFIG_SMC911X is not set
++# CONFIG_SMSC911X is not set
++# CONFIG_DNET is not set
++# CONFIG_IBM_NEW_EMAC_ZMII is not set
++# CONFIG_IBM_NEW_EMAC_RGMII is not set
++# CONFIG_IBM_NEW_EMAC_TAH is not set
++# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
++# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
++# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
++# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
++# CONFIG_B44 is not set
++# CONFIG_KS8842 is not set
++# CONFIG_NETDEV_1000 is not set
++# CONFIG_NETDEV_10000 is not set
++CONFIG_WLAN=y
++# CONFIG_WLAN_PRE80211 is not set
++# CONFIG_WLAN_80211 is not set
++
++#
++# Enable WiMAX (Networking options) to see the WiMAX drivers
++#
++
++#
++# USB Network Adapters
++#
++# CONFIG_USB_CATC is not set
++# CONFIG_USB_KAWETH is not set
++# CONFIG_USB_PEGASUS is not set
++# CONFIG_USB_RTL8150 is not set
++# CONFIG_USB_USBNET is not set
++# CONFIG_WAN is not set
++CONFIG_PPP=m
++# CONFIG_PPP_MULTILINK is not set
++# CONFIG_PPP_FILTER is not set
++CONFIG_PPP_ASYNC=m
++CONFIG_PPP_SYNC_TTY=m
++CONFIG_PPP_DEFLATE=m
++# CONFIG_PPP_BSDCOMP is not set
++# CONFIG_PPP_MPPE is not set
++# CONFIG_PPPOE is not set
++# CONFIG_PPPOL2TP is not set
++# CONFIG_SLIP is not set
++CONFIG_SLHC=m
++CONFIG_NETCONSOLE=y
++# CONFIG_NETCONSOLE_DYNAMIC is not set
++CONFIG_NETPOLL=y
++CONFIG_NETPOLL_TRAP=y
++CONFIG_NET_POLL_CONTROLLER=y
++# CONFIG_ISDN is not set
++# CONFIG_PHONE is not set
++
++#
++# Input device support
++#
++CONFIG_INPUT=y
++# CONFIG_INPUT_FF_MEMLESS is not set
++# CONFIG_INPUT_POLLDEV is not set
++
++#
++# Userland interfaces
++#
++# CONFIG_INPUT_MOUSEDEV is not set
++# CONFIG_INPUT_JOYDEV is not set
++CONFIG_INPUT_EVDEV=m
++CONFIG_INPUT_EVBUG=m
++
++#
++# Input Device Drivers
++#
++# CONFIG_INPUT_KEYBOARD is not set
++# CONFIG_INPUT_MOUSE is not set
++# CONFIG_INPUT_JOYSTICK is not set
++# CONFIG_INPUT_TABLET is not set
++# CONFIG_INPUT_TOUCHSCREEN is not set
++# CONFIG_INPUT_MISC is not set
++
++#
++# Hardware I/O ports
++#
++CONFIG_SERIO=y
++CONFIG_SERIO_SERPORT=y
++CONFIG_SERIO_LIBPS2=y
++# CONFIG_SERIO_RAW is not set
++# CONFIG_GAMEPORT is not set
++
++#
++# Character devices
++#
++CONFIG_VT=y
++CONFIG_CONSOLE_TRANSLATIONS=y
++# CONFIG_VT_CONSOLE is not set
++CONFIG_HW_CONSOLE=y
++# CONFIG_VT_HW_CONSOLE_BINDING is not set
++CONFIG_DEVKMEM=y
++# CONFIG_SERIAL_NONSTANDARD is not set
++
++#
++# Serial drivers
++#
++CONFIG_SERIAL_8250=y
++CONFIG_SERIAL_8250_CONSOLE=y
++CONFIG_SERIAL_8250_NR_UARTS=3
++CONFIG_SERIAL_8250_RUNTIME_UARTS=3
++# CONFIG_SERIAL_8250_EXTENDED is not set
++
++#
++# Non-8250 serial port support
++#
++CONFIG_SERIAL_CORE=y
++CONFIG_SERIAL_CORE_CONSOLE=y
++CONFIG_UNIX98_PTYS=y
++# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
++CONFIG_LEGACY_PTYS=y
++CONFIG_LEGACY_PTY_COUNT=256
++# CONFIG_IPMI_HANDLER is not set
++# CONFIG_HW_RANDOM is not set
++# CONFIG_R3964 is not set
++# CONFIG_RAW_DRIVER is not set
++# CONFIG_TCG_TPM is not set
++CONFIG_I2C=y
++CONFIG_I2C_BOARDINFO=y
++CONFIG_I2C_COMPAT=y
++CONFIG_I2C_CHARDEV=y
++CONFIG_I2C_HELPER_AUTO=y
++
++#
++# I2C Hardware Bus support
++#
++
++#
++# I2C system bus drivers (mostly embedded / system-on-chip)
++#
++CONFIG_I2C_DAVINCI=y
++# CONFIG_I2C_DESIGNWARE is not set
++# CONFIG_I2C_GPIO is not set
++# CONFIG_I2C_OCORES is not set
++# CONFIG_I2C_SIMTEC is not set
++
++#
++# External I2C/SMBus adapter drivers
++#
++# CONFIG_I2C_PARPORT_LIGHT is not set
++# CONFIG_I2C_TAOS_EVM is not set
++# CONFIG_I2C_TINY_USB is not set
++
++#
++# Other I2C/SMBus bus drivers
++#
++# CONFIG_I2C_PCA_PLATFORM is not set
++# CONFIG_I2C_STUB is not set
++
++#
++# Miscellaneous I2C Chip support
++#
++# CONFIG_DS1682 is not set
++# CONFIG_SENSORS_TSL2550 is not set
++# CONFIG_I2C_DEBUG_CORE is not set
++# CONFIG_I2C_DEBUG_ALGO is not set
++# CONFIG_I2C_DEBUG_BUS is not set
++# CONFIG_I2C_DEBUG_CHIP is not set
++# CONFIG_SPI is not set
++
++#
++# PPS support
++#
++# CONFIG_PPS is not set
++CONFIG_ARCH_REQUIRE_GPIOLIB=y
++CONFIG_GPIOLIB=y
++# CONFIG_DEBUG_GPIO is not set
++# CONFIG_GPIO_SYSFS is not set
++
++#
++# Memory mapped GPIO expanders:
++#
++
++#
++# I2C GPIO expanders:
++#
++# CONFIG_GPIO_MAX732X is not set
++# CONFIG_GPIO_PCA953X is not set
++CONFIG_GPIO_PCF857X=y
++
++#
++# PCI GPIO expanders:
++#
++
++#
++# SPI GPIO expanders:
++#
++
++#
++# AC97 GPIO expanders:
++#
++# CONFIG_W1 is not set
++# CONFIG_POWER_SUPPLY is not set
++CONFIG_HWMON=y
++# CONFIG_HWMON_VID is not set
++# CONFIG_HWMON_DEBUG_CHIP is not set
++
++#
++# Native drivers
++#
++# CONFIG_SENSORS_AD7414 is not set
++# CONFIG_SENSORS_AD7418 is not set
++# CONFIG_SENSORS_ADM1021 is not set
++# CONFIG_SENSORS_ADM1025 is not set
++# CONFIG_SENSORS_ADM1026 is not set
++# CONFIG_SENSORS_ADM1029 is not set
++# CONFIG_SENSORS_ADM1031 is not set
++# CONFIG_SENSORS_ADM9240 is not set
++# CONFIG_SENSORS_ADT7462 is not set
++# CONFIG_SENSORS_ADT7470 is not set
++# CONFIG_SENSORS_ADT7473 is not set
++# CONFIG_SENSORS_ADT7475 is not set
++# CONFIG_SENSORS_ATXP1 is not set
++# CONFIG_SENSORS_DS1621 is not set
++# CONFIG_SENSORS_F71805F is not set
++# CONFIG_SENSORS_F71882FG is not set
++# CONFIG_SENSORS_F75375S is not set
++# CONFIG_SENSORS_G760A is not set
++# CONFIG_SENSORS_GL518SM is not set
++# CONFIG_SENSORS_GL520SM is not set
++# CONFIG_SENSORS_IT87 is not set
++# CONFIG_SENSORS_LM63 is not set
++# CONFIG_SENSORS_LM75 is not set
++# CONFIG_SENSORS_LM77 is not set
++# CONFIG_SENSORS_LM78 is not set
++# CONFIG_SENSORS_LM80 is not set
++# CONFIG_SENSORS_LM83 is not set
++# CONFIG_SENSORS_LM85 is not set
++# CONFIG_SENSORS_LM87 is not set
++# CONFIG_SENSORS_LM90 is not set
++# CONFIG_SENSORS_LM92 is not set
++# CONFIG_SENSORS_LM93 is not set
++# CONFIG_SENSORS_LTC4215 is not set
++# CONFIG_SENSORS_LTC4245 is not set
++# CONFIG_SENSORS_LM95241 is not set
++# CONFIG_SENSORS_MAX1619 is not set
++# CONFIG_SENSORS_MAX6650 is not set
++# CONFIG_SENSORS_PC87360 is not set
++# CONFIG_SENSORS_PC87427 is not set
++# CONFIG_SENSORS_PCF8591 is not set
++# CONFIG_SENSORS_SHT15 is not set
++# CONFIG_SENSORS_DME1737 is not set
++# CONFIG_SENSORS_SMSC47M1 is not set
++# CONFIG_SENSORS_SMSC47M192 is not set
++# CONFIG_SENSORS_SMSC47B397 is not set
++# CONFIG_SENSORS_ADS7828 is not set
++# CONFIG_SENSORS_THMC50 is not set
++# CONFIG_SENSORS_TMP401 is not set
++# CONFIG_SENSORS_TMP421 is not set
++# CONFIG_SENSORS_VT1211 is not set
++# CONFIG_SENSORS_W83781D is not set
++# CONFIG_SENSORS_W83791D is not set
++# CONFIG_SENSORS_W83792D is not set
++# CONFIG_SENSORS_W83793 is not set
++# CONFIG_SENSORS_W83L785TS is not set
++# CONFIG_SENSORS_W83L786NG is not set
++# CONFIG_SENSORS_W83627HF is not set
++# CONFIG_SENSORS_W83627EHF is not set
++# CONFIG_THERMAL is not set
++CONFIG_WATCHDOG=y
++# CONFIG_WATCHDOG_NOWAYOUT is not set
++
++#
++# Watchdog Device Drivers
++#
++# CONFIG_SOFT_WATCHDOG is not set
++CONFIG_DAVINCI_WATCHDOG=y
++
++#
++# USB-based Watchdog Cards
++#
++# CONFIG_USBPCWATCHDOG is not set
++CONFIG_SSB_POSSIBLE=y
++
++#
++# Sonics Silicon Backplane
++#
++# CONFIG_SSB is not set
++
++#
++# Multifunction device drivers
++#
++# CONFIG_MFD_CORE is not set
++# CONFIG_MFD_SM501 is not set
++# CONFIG_MFD_ASIC3 is not set
++# CONFIG_HTC_EGPIO is not set
++# CONFIG_HTC_PASIC3 is not set
++# CONFIG_TPS65010 is not set
++# CONFIG_TWL4030_CORE is not set
++# CONFIG_MFD_TMIO is not set
++# CONFIG_MFD_T7L66XB is not set
++# CONFIG_MFD_TC6387XB is not set
++# CONFIG_MFD_TC6393XB is not set
++# CONFIG_PMIC_DA903X is not set
++# CONFIG_MFD_WM8400 is not set
++# CONFIG_MFD_WM831X is not set
++# CONFIG_MFD_WM8350_I2C is not set
++# CONFIG_MFD_PCF50633 is not set
++# CONFIG_AB3100_CORE is not set
++# CONFIG_REGULATOR is not set
++CONFIG_MEDIA_SUPPORT=y
++
++#
++# Multimedia core support
++#
++CONFIG_VIDEO_DEV=y
++CONFIG_VIDEO_V4L2_COMMON=y
++# CONFIG_VIDEO_ALLOW_V4L1 is not set
++# CONFIG_VIDEO_V4L1_COMPAT is not set
++# CONFIG_DVB_CORE is not set
++CONFIG_VIDEO_MEDIA=y
++
++#
++# Multimedia drivers
++#
++# CONFIG_MEDIA_ATTACH is not set
++CONFIG_MEDIA_TUNER=y
++# CONFIG_MEDIA_TUNER_CUSTOMISE is not set
++CONFIG_MEDIA_TUNER_SIMPLE=y
++CONFIG_MEDIA_TUNER_TDA8290=y
++CONFIG_MEDIA_TUNER_TDA9887=y
++CONFIG_MEDIA_TUNER_TEA5761=y
++CONFIG_MEDIA_TUNER_TEA5767=y
++CONFIG_MEDIA_TUNER_MT20XX=y
++CONFIG_MEDIA_TUNER_XC2028=y
++CONFIG_MEDIA_TUNER_XC5000=y
++CONFIG_MEDIA_TUNER_MC44S803=y
++CONFIG_VIDEO_V4L2=y
++CONFIG_VIDEOBUF_GEN=y
++CONFIG_VIDEOBUF_VMALLOC=y
++CONFIG_VIDEOBUF_DMA_CONTIG=y
++CONFIG_VIDEO_CAPTURE_DRIVERS=y
++# CONFIG_VIDEO_ADV_DEBUG is not set
++# CONFIG_VIDEO_FIXED_MINOR_RANGES is not set
++# CONFIG_VIDEO_HELPER_CHIPS_AUTO is not set
++
++#
++# Encoders/decoders and other helper chips
++#
++
++#
++# Audio decoders
++#
++# CONFIG_VIDEO_TVAUDIO is not set
++# CONFIG_VIDEO_TDA7432 is not set
++# CONFIG_VIDEO_TDA9840 is not set
++# CONFIG_VIDEO_TDA9875 is not set
++# CONFIG_VIDEO_TEA6415C is not set
++# CONFIG_VIDEO_TEA6420 is not set
++# CONFIG_VIDEO_MSP3400 is not set
++# CONFIG_VIDEO_CS5345 is not set
++# CONFIG_VIDEO_CS53L32A is not set
++# CONFIG_VIDEO_M52790 is not set
++# CONFIG_VIDEO_TLV320AIC23B is not set
++# CONFIG_VIDEO_WM8775 is not set
++# CONFIG_VIDEO_WM8739 is not set
++# CONFIG_VIDEO_VP27SMPX is not set
++
++#
++# RDS decoders
++#
++# CONFIG_VIDEO_SAA6588 is not set
++
++#
++# Video decoders
++#
++# CONFIG_VIDEO_ADV7180 is not set
++# CONFIG_VIDEO_BT819 is not set
++# CONFIG_VIDEO_BT856 is not set
++# CONFIG_VIDEO_BT866 is not set
++# CONFIG_VIDEO_KS0127 is not set
++# CONFIG_VIDEO_OV7670 is not set
++# CONFIG_VIDEO_MT9V011 is not set
++# CONFIG_VIDEO_TCM825X is not set
++# CONFIG_VIDEO_SAA7110 is not set
++# CONFIG_VIDEO_SAA711X is not set
++# CONFIG_VIDEO_SAA717X is not set
++CONFIG_VIDEO_TVP514X=y
++# CONFIG_VIDEO_TVP5150 is not set
++# CONFIG_VIDEO_TVP7002 is not set
++# CONFIG_VIDEO_VPX3220 is not set
++
++#
++# Video and audio decoders
++#
++# CONFIG_VIDEO_CX25840 is not set
++
++#
++# MPEG video encoders
++#
++# CONFIG_VIDEO_CX2341X is not set
++
++#
++# Video encoders
++#
++# CONFIG_VIDEO_SAA7127 is not set
++# CONFIG_VIDEO_SAA7185 is not set
++# CONFIG_VIDEO_ADV7170 is not set
++# CONFIG_VIDEO_ADV7175 is not set
++# CONFIG_VIDEO_THS7303 is not set
++# CONFIG_VIDEO_THS7353 is not set
++# CONFIG_VIDEO_ADV7343 is not set
++# CONFIG_VIDEO_THS8200 is not set
++
++#
++# Video improvement chips
++#
++# CONFIG_VIDEO_UPD64031A is not set
++# CONFIG_VIDEO_UPD64083 is not set
++CONFIG_VIDEO_DAVINCI_DISPLAY=y
++CONFIG_DAVINCI_ENC_MNGR=y
++CONFIG_ENC_MNGR_MAX_CHANNELS=1
++CONFIG_DAVINCI_OSD=y
++CONFIG_DAVINCI_VPBE_ENCODER=y
++CONFIG_DAVINCI_LOGICPD_ENCODER=y
++# CONFIG_DAVINCI_AVNET_ENCODER is not set
++# CONFIG_VIDEO_VIVI is not set
++CONFIG_VIDEO_VPSS_SYSTEM=y
++CONFIG_VIDEO_VPFE_CAPTURE=y
++CONFIG_VIDEO_DM6446_CCDC=y
++# CONFIG_VIDEO_SAA5246A is not set
++# CONFIG_VIDEO_SAA5249 is not set
++# CONFIG_SOC_CAMERA is not set
++# CONFIG_SOC_CAMERA_MT9T031 is not set
++# CONFIG_V4L_USB_DRIVERS is not set
++# CONFIG_RADIO_ADAPTERS is not set
++# CONFIG_DAB is not set
++
++#
++# Graphics support
++#
++# CONFIG_VGASTATE is not set
++CONFIG_VIDEO_OUTPUT_CONTROL=y
++CONFIG_FB=y
++# CONFIG_FIRMWARE_EDID is not set
++# CONFIG_FB_DDC is not set
++# CONFIG_FB_BOOT_VESA_SUPPORT is not set
++CONFIG_FB_CFB_FILLRECT=y
++CONFIG_FB_CFB_COPYAREA=y
++CONFIG_FB_CFB_IMAGEBLIT=y
++# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
++# CONFIG_FB_SYS_FILLRECT is not set
++# CONFIG_FB_SYS_COPYAREA is not set
++# CONFIG_FB_SYS_IMAGEBLIT is not set
++# CONFIG_FB_FOREIGN_ENDIAN is not set
++# CONFIG_FB_SYS_FOPS is not set
++# CONFIG_FB_SVGALIB is not set
++# CONFIG_FB_MACMODES is not set
++# CONFIG_FB_BACKLIGHT is not set
++# CONFIG_FB_MODE_HELPERS is not set
++# CONFIG_FB_TILEBLITTING is not set
++
++#
++# Frame buffer hardware drivers
++#
++# CONFIG_FB_S1D13XXX is not set
++CONFIG_FB_DAVINCI=y
++# CONFIG_FB_VIRTUAL is not set
++# CONFIG_FB_METRONOME is not set
++# CONFIG_FB_MB862XX is not set
++# CONFIG_FB_BROADSHEET is not set
++# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
++
++#
++# Display device support
++#
++# CONFIG_DISPLAY_SUPPORT is not set
++
++#
++# Console display driver support
++#
++# CONFIG_VGA_CONSOLE is not set
++CONFIG_DUMMY_CONSOLE=y
++# CONFIG_FRAMEBUFFER_CONSOLE is not set
++CONFIG_LOGO=y
++CONFIG_LOGO_LINUX_MONO=y
++CONFIG_LOGO_LINUX_VGA16=y
++CONFIG_LOGO_LINUX_CLUT224=y
++CONFIG_SOUND=y
++# CONFIG_SOUND_OSS_CORE is not set
++CONFIG_SND=y
++CONFIG_SND_TIMER=y
++CONFIG_SND_PCM=y
++CONFIG_SND_JACK=y
++# CONFIG_SND_SEQUENCER is not set
++# CONFIG_SND_MIXER_OSS is not set
++# CONFIG_SND_PCM_OSS is not set
++# CONFIG_SND_HRTIMER is not set
++# CONFIG_SND_DYNAMIC_MINORS is not set
++CONFIG_SND_SUPPORT_OLD_API=y
++CONFIG_SND_VERBOSE_PROCFS=y
++# CONFIG_SND_VERBOSE_PRINTK is not set
++# CONFIG_SND_DEBUG is not set
++# CONFIG_SND_RAWMIDI_SEQ is not set
++# CONFIG_SND_OPL3_LIB_SEQ is not set
++# CONFIG_SND_OPL4_LIB_SEQ is not set
++# CONFIG_SND_SBAWE_SEQ is not set
++# CONFIG_SND_EMU10K1_SEQ is not set
++CONFIG_SND_DRIVERS=y
++# CONFIG_SND_DUMMY is not set
++# CONFIG_SND_MTPAV is not set
++# CONFIG_SND_SERIAL_U16550 is not set
++# CONFIG_SND_MPU401 is not set
++CONFIG_SND_ARM=y
++CONFIG_SND_USB=y
++# CONFIG_SND_USB_AUDIO is not set
++# CONFIG_SND_USB_CAIAQ is not set
++CONFIG_SND_SOC=y
++CONFIG_SND_DAVINCI_SOC=y
++CONFIG_SND_DAVINCI_SOC_I2S=y
++CONFIG_SND_DAVINCI_SOC_EVM=y
++CONFIG_SND_SOC_I2C_AND_SPI=y
++# CONFIG_SND_SOC_ALL_CODECS is not set
++CONFIG_SND_SOC_TLV320AIC3X=y
++# CONFIG_SOUND_PRIME is not set
++CONFIG_HID_SUPPORT=y
++CONFIG_HID=y
++# CONFIG_HIDRAW is not set
++
++#
++# USB Input Devices
++#
++CONFIG_USB_HID=y
++# CONFIG_HID_PID is not set
++# CONFIG_USB_HIDDEV is not set
++
++#
++# Special HID drivers
++#
++CONFIG_HID_A4TECH=m
++CONFIG_HID_APPLE=m
++CONFIG_HID_BELKIN=m
++CONFIG_HID_CHERRY=m
++CONFIG_HID_CHICONY=m
++CONFIG_HID_CYPRESS=m
++# CONFIG_HID_DRAGONRISE is not set
++CONFIG_HID_EZKEY=m
++# CONFIG_HID_KYE is not set
++CONFIG_HID_GYRATION=m
++# CONFIG_HID_TWINHAN is not set
++# CONFIG_HID_KENSINGTON is not set
++CONFIG_HID_LOGITECH=y
++# CONFIG_LOGITECH_FF is not set
++# CONFIG_LOGIRUMBLEPAD2_FF is not set
++CONFIG_HID_MICROSOFT=y
++CONFIG_HID_MONTEREY=m
++# CONFIG_HID_NTRIG is not set
++CONFIG_HID_PANTHERLORD=m
++# CONFIG_PANTHERLORD_FF is not set
++CONFIG_HID_PETALYNX=m
++CONFIG_HID_SAMSUNG=m
++CONFIG_HID_SONY=m
++CONFIG_HID_SUNPLUS=m
++# CONFIG_HID_GREENASIA is not set
++# CONFIG_HID_SMARTJOYPLUS is not set
++# CONFIG_HID_TOPSEED is not set
++# CONFIG_HID_THRUSTMASTER is not set
++# CONFIG_HID_ZEROPLUS is not set
++CONFIG_USB_SUPPORT=y
++CONFIG_USB_ARCH_HAS_HCD=y
++# CONFIG_USB_ARCH_HAS_OHCI is not set
++# CONFIG_USB_ARCH_HAS_EHCI is not set
++CONFIG_USB=y
++# CONFIG_USB_DEBUG is not set
++# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
++
++#
++# Miscellaneous USB options
++#
++CONFIG_USB_DEVICEFS=y
++CONFIG_USB_DEVICE_CLASS=y
++# CONFIG_USB_DYNAMIC_MINORS is not set
++# CONFIG_USB_OTG is not set
++# CONFIG_USB_OTG_WHITELIST is not set
++# CONFIG_USB_OTG_BLACKLIST_HUB is not set
++# CONFIG_USB_MON is not set
++# CONFIG_USB_WUSB is not set
++# CONFIG_USB_WUSB_CBAF is not set
++
++#
++# USB Host Controller Drivers
++#
++# CONFIG_USB_C67X00_HCD is not set
++# CONFIG_USB_OXU210HP_HCD is not set
++# CONFIG_USB_ISP116X_HCD is not set
++# CONFIG_USB_ISP1760_HCD is not set
++# CONFIG_USB_ISP1362_HCD is not set
++# CONFIG_USB_SL811_HCD is not set
++# CONFIG_USB_R8A66597_HCD is not set
++# CONFIG_USB_HWA_HCD is not set
++CONFIG_USB_MUSB_HDRC=y
++CONFIG_USB_MUSB_SOC=y
++
++#
++# DaVinci 35x, 36x, 644x USB support
++#
++CONFIG_USB_MUSB_HOST=y
++# CONFIG_USB_MUSB_PERIPHERAL is not set
++# CONFIG_USB_MUSB_OTG is not set
++# CONFIG_MUSB_SCHEDULE_INTR_EP is not set
++CONFIG_USB_MUSB_HDRC_HCD=y
++# CONFIG_MUSB_PIO_ONLY is not set
++# CONFIG_USB_INVENTRA_DMA is not set
++CONFIG_USB_TI_CPPI_DMA=y
++# CONFIG_USB_MUSB_DEBUG is not set
++
++#
++# USB Device Class drivers
++#
++# CONFIG_USB_ACM is not set
++# CONFIG_USB_PRINTER is not set
++# CONFIG_USB_WDM is not set
++# CONFIG_USB_TMC is not set
++
++#
++# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
++#
++
++#
++# also be needed; see USB_STORAGE Help for more info
++#
++CONFIG_USB_STORAGE=y
++# CONFIG_USB_STORAGE_DEBUG is not set
++# CONFIG_USB_STORAGE_DATAFAB is not set
++# CONFIG_USB_STORAGE_FREECOM is not set
++# CONFIG_USB_STORAGE_ISD200 is not set
++# CONFIG_USB_STORAGE_USBAT is not set
++# CONFIG_USB_STORAGE_SDDR09 is not set
++# CONFIG_USB_STORAGE_SDDR55 is not set
++# CONFIG_USB_STORAGE_JUMPSHOT is not set
++# CONFIG_USB_STORAGE_ALAUDA is not set
++# CONFIG_USB_STORAGE_ONETOUCH is not set
++# CONFIG_USB_STORAGE_KARMA is not set
++# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
++# CONFIG_USB_LIBUSUAL is not set
++
++#
++# USB Imaging devices
++#
++# CONFIG_USB_MDC800 is not set
++# CONFIG_USB_MICROTEK is not set
++
++#
++# USB port drivers
++#
++# CONFIG_USB_SERIAL is not set
++
++#
++# USB Miscellaneous drivers
++#
++# CONFIG_USB_EMI62 is not set
++# CONFIG_USB_EMI26 is not set
++# CONFIG_USB_ADUTUX is not set
++# CONFIG_USB_SEVSEG is not set
++# CONFIG_USB_RIO500 is not set
++# CONFIG_USB_LEGOTOWER is not set
++# CONFIG_USB_LCD is not set
++# CONFIG_USB_BERRY_CHARGE is not set
++# CONFIG_USB_LED is not set
++# CONFIG_USB_CYPRESS_CY7C63 is not set
++# CONFIG_USB_CYTHERM is not set
++# CONFIG_USB_IDMOUSE is not set
++# CONFIG_USB_FTDI_ELAN is not set
++# CONFIG_USB_APPLEDISPLAY is not set
++# CONFIG_USB_SISUSBVGA is not set
++# CONFIG_USB_LD is not set
++# CONFIG_USB_TRANCEVIBRATOR is not set
++# CONFIG_USB_IOWARRIOR is not set
++CONFIG_USB_TEST=y
++# CONFIG_USB_ISIGHTFW is not set
++# CONFIG_USB_VST is not set
++# CONFIG_USB_GADGET is not set
++
++#
++# OTG and related infrastructure
++#
++CONFIG_USB_OTG_UTILS=y
++# CONFIG_USB_GPIO_VBUS is not set
++CONFIG_NOP_USB_XCEIV=y
++CONFIG_MMC=y
++# CONFIG_MMC_DEBUG is not set
++# CONFIG_MMC_UNSAFE_RESUME is not set
++
++#
++# MMC/SD/SDIO Card Drivers
++#
++CONFIG_MMC_BLOCK=y
++# CONFIG_MMC_BLOCK_BOUNCE is not set
++# CONFIG_SDIO_UART is not set
++# CONFIG_MMC_TEST is not set
++
++#
++# MMC/SD/SDIO Host Controller Drivers
++#
++# CONFIG_MMC_SDHCI is not set
++# CONFIG_MMC_AT91 is not set
++# CONFIG_MMC_ATMELMCI is not set
++CONFIG_MMC_DAVINCI=y
++# CONFIG_MEMSTICK is not set
++CONFIG_NEW_LEDS=y
++CONFIG_LEDS_CLASS=m
++
++#
++# LED drivers
++#
++# CONFIG_LEDS_PCA9532 is not set
++CONFIG_LEDS_GPIO=m
++CONFIG_LEDS_GPIO_PLATFORM=y
++# CONFIG_LEDS_LP3944 is not set
++# CONFIG_LEDS_PCA955X is not set
++# CONFIG_LEDS_BD2802 is not set
++
++#
++# LED Triggers
++#
++CONFIG_LEDS_TRIGGERS=y
++CONFIG_LEDS_TRIGGER_TIMER=m
++# CONFIG_LEDS_TRIGGER_IDE_DISK is not set
++CONFIG_LEDS_TRIGGER_HEARTBEAT=m
++# CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
++# CONFIG_LEDS_TRIGGER_GPIO is not set
++# CONFIG_LEDS_TRIGGER_DEFAULT_ON is not set
++
++#
++# iptables trigger is under Netfilter config (LED target)
++#
++# CONFIG_ACCESSIBILITY is not set
++CONFIG_RTC_LIB=y
++# CONFIG_RTC_CLASS is not set
++# CONFIG_DMADEVICES is not set
++# CONFIG_AUXDISPLAY is not set
++# CONFIG_UIO is not set
++
++#
++# TI VLYNQ
++#
++# CONFIG_STAGING is not set
++
++#
++# File systems
++#
++CONFIG_EXT2_FS=y
++# CONFIG_EXT2_FS_XATTR is not set
++# CONFIG_EXT2_FS_XIP is not set
++CONFIG_EXT3_FS=y
++# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
++CONFIG_EXT3_FS_XATTR=y
++# CONFIG_EXT3_FS_POSIX_ACL is not set
++# CONFIG_EXT3_FS_SECURITY is not set
++# CONFIG_EXT4_FS is not set
++CONFIG_JBD=y
++# CONFIG_JBD_DEBUG is not set
++CONFIG_FS_MBCACHE=y
++# CONFIG_REISERFS_FS is not set
++# CONFIG_JFS_FS is not set
++# CONFIG_FS_POSIX_ACL is not set
++CONFIG_XFS_FS=m
++# CONFIG_XFS_QUOTA is not set
++# CONFIG_XFS_POSIX_ACL is not set
++# CONFIG_XFS_RT is not set
++# CONFIG_XFS_DEBUG is not set
++# CONFIG_GFS2_FS is not set
++# CONFIG_OCFS2_FS is not set
++# CONFIG_BTRFS_FS is not set
++# CONFIG_NILFS2_FS is not set
++CONFIG_FILE_LOCKING=y
++CONFIG_FSNOTIFY=y
++CONFIG_DNOTIFY=y
++CONFIG_INOTIFY=y
++CONFIG_INOTIFY_USER=y
++# CONFIG_QUOTA is not set
++# CONFIG_AUTOFS_FS is not set
++CONFIG_AUTOFS4_FS=m
++# CONFIG_FUSE_FS is not set
++
++#
++# Caches
++#
++# CONFIG_FSCACHE is not set
++
++#
++# CD-ROM/DVD Filesystems
++#
++# CONFIG_ISO9660_FS is not set
++# CONFIG_UDF_FS is not set
++
++#
++# DOS/FAT/NT Filesystems
++#
++CONFIG_FAT_FS=y
++CONFIG_MSDOS_FS=y
++CONFIG_VFAT_FS=y
++CONFIG_FAT_DEFAULT_CODEPAGE=437
++CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
++# CONFIG_NTFS_FS is not set
++
++#
++# Pseudo filesystems
++#
++CONFIG_PROC_FS=y
++CONFIG_PROC_SYSCTL=y
++CONFIG_PROC_PAGE_MONITOR=y
++CONFIG_SYSFS=y
++CONFIG_TMPFS=y
++# CONFIG_TMPFS_POSIX_ACL is not set
++# CONFIG_HUGETLB_PAGE is not set
++# CONFIG_CONFIGFS_FS is not set
++CONFIG_MISC_FILESYSTEMS=y
++# CONFIG_ADFS_FS is not set
++# CONFIG_AFFS_FS is not set
++# CONFIG_HFS_FS is not set
++# CONFIG_HFSPLUS_FS is not set
++# CONFIG_BEFS_FS is not set
++# CONFIG_BFS_FS is not set
++# CONFIG_EFS_FS is not set
++CONFIG_CRAMFS=y
++# CONFIG_SQUASHFS is not set
++# CONFIG_VXFS_FS is not set
++CONFIG_MINIX_FS=m
++# CONFIG_OMFS_FS is not set
++# CONFIG_HPFS_FS is not set
++# CONFIG_QNX4FS_FS is not set
++# CONFIG_ROMFS_FS is not set
++# CONFIG_SYSV_FS is not set
++# CONFIG_UFS_FS is not set
++CONFIG_NETWORK_FILESYSTEMS=y
++CONFIG_NFS_FS=y
++CONFIG_NFS_V3=y
++# CONFIG_NFS_V3_ACL is not set
++# CONFIG_NFS_V4 is not set
++CONFIG_ROOT_NFS=y
++CONFIG_NFSD=m
++CONFIG_NFSD_V3=y
++# CONFIG_NFSD_V3_ACL is not set
++# CONFIG_NFSD_V4 is not set
++CONFIG_LOCKD=y
++CONFIG_LOCKD_V4=y
++CONFIG_EXPORTFS=m
++CONFIG_NFS_COMMON=y
++CONFIG_SUNRPC=y
++# CONFIG_RPCSEC_GSS_KRB5 is not set
++# CONFIG_RPCSEC_GSS_SPKM3 is not set
++CONFIG_SMB_FS=m
++# CONFIG_SMB_NLS_DEFAULT is not set
++# CONFIG_CIFS is not set
++# CONFIG_NCP_FS is not set
++# CONFIG_CODA_FS is not set
++# CONFIG_AFS_FS is not set
++
++#
++# Partition Types
++#
++CONFIG_PARTITION_ADVANCED=y
++# CONFIG_ACORN_PARTITION is not set
++# CONFIG_OSF_PARTITION is not set
++# CONFIG_AMIGA_PARTITION is not set
++# CONFIG_ATARI_PARTITION is not set
++# CONFIG_MAC_PARTITION is not set
++CONFIG_MSDOS_PARTITION=y
++# CONFIG_BSD_DISKLABEL is not set
++# CONFIG_MINIX_SUBPARTITION is not set
++# CONFIG_SOLARIS_X86_PARTITION is not set
++# CONFIG_UNIXWARE_DISKLABEL is not set
++# CONFIG_LDM_PARTITION is not set
++# CONFIG_SGI_PARTITION is not set
++# CONFIG_ULTRIX_PARTITION is not set
++# CONFIG_SUN_PARTITION is not set
++# CONFIG_KARMA_PARTITION is not set
++# CONFIG_EFI_PARTITION is not set
++# CONFIG_SYSV68_PARTITION is not set
++CONFIG_NLS=y
++CONFIG_NLS_DEFAULT="iso8859-1"
++CONFIG_NLS_CODEPAGE_437=y
++# CONFIG_NLS_CODEPAGE_737 is not set
++# CONFIG_NLS_CODEPAGE_775 is not set
++# CONFIG_NLS_CODEPAGE_850 is not set
++# CONFIG_NLS_CODEPAGE_852 is not set
++# CONFIG_NLS_CODEPAGE_855 is not set
++# CONFIG_NLS_CODEPAGE_857 is not set
++# CONFIG_NLS_CODEPAGE_860 is not set
++# CONFIG_NLS_CODEPAGE_861 is not set
++# CONFIG_NLS_CODEPAGE_862 is not set
++# CONFIG_NLS_CODEPAGE_863 is not set
++# CONFIG_NLS_CODEPAGE_864 is not set
++# CONFIG_NLS_CODEPAGE_865 is not set
++# CONFIG_NLS_CODEPAGE_866 is not set
++# CONFIG_NLS_CODEPAGE_869 is not set
++# CONFIG_NLS_CODEPAGE_936 is not set
++# CONFIG_NLS_CODEPAGE_950 is not set
++# CONFIG_NLS_CODEPAGE_932 is not set
++# CONFIG_NLS_CODEPAGE_949 is not set
++# CONFIG_NLS_CODEPAGE_874 is not set
++# CONFIG_NLS_ISO8859_8 is not set
++# CONFIG_NLS_CODEPAGE_1250 is not set
++# CONFIG_NLS_CODEPAGE_1251 is not set
++CONFIG_NLS_ASCII=m
++CONFIG_NLS_ISO8859_1=y
++# CONFIG_NLS_ISO8859_2 is not set
++# CONFIG_NLS_ISO8859_3 is not set
++# CONFIG_NLS_ISO8859_4 is not set
++# CONFIG_NLS_ISO8859_5 is not set
++# CONFIG_NLS_ISO8859_6 is not set
++# CONFIG_NLS_ISO8859_7 is not set
++# CONFIG_NLS_ISO8859_9 is not set
++# CONFIG_NLS_ISO8859_13 is not set
++# CONFIG_NLS_ISO8859_14 is not set
++# CONFIG_NLS_ISO8859_15 is not set
++# CONFIG_NLS_KOI8_R is not set
++# CONFIG_NLS_KOI8_U is not set
++CONFIG_NLS_UTF8=m
++# CONFIG_DLM is not set
++
++#
++# Kernel hacking
++#
++# CONFIG_PRINTK_TIME is not set
++CONFIG_ENABLE_WARN_DEPRECATED=y
++CONFIG_ENABLE_MUST_CHECK=y
++CONFIG_FRAME_WARN=1024
++# CONFIG_MAGIC_SYSRQ is not set
++# CONFIG_STRIP_ASM_SYMS is not set
++# CONFIG_UNUSED_SYMBOLS is not set
++CONFIG_DEBUG_FS=y
++# CONFIG_HEADERS_CHECK is not set
++CONFIG_DEBUG_KERNEL=y
++# CONFIG_DEBUG_SHIRQ is not set
++CONFIG_DETECT_SOFTLOCKUP=y
++# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
++CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
++CONFIG_DETECT_HUNG_TASK=y
++# CONFIG_BOOTPARAM_HUNG_TASK_PANIC is not set
++CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=0
++CONFIG_SCHED_DEBUG=y
++# CONFIG_SCHEDSTATS is not set
++CONFIG_TIMER_STATS=y
++# CONFIG_DEBUG_OBJECTS is not set
++# CONFIG_SLUB_DEBUG_ON is not set
++# CONFIG_SLUB_STATS is not set
++# CONFIG_DEBUG_KMEMLEAK is not set
++CONFIG_DEBUG_PREEMPT=y
++CONFIG_DEBUG_RT_MUTEXES=y
++CONFIG_DEBUG_PI_LIST=y
++# CONFIG_RT_MUTEX_TESTER is not set
++# CONFIG_DEBUG_SPINLOCK is not set
++CONFIG_DEBUG_MUTEXES=y
++# CONFIG_DEBUG_LOCK_ALLOC is not set
++# CONFIG_PROVE_LOCKING is not set
++# CONFIG_LOCK_STAT is not set
++# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
++# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
++# CONFIG_DEBUG_KOBJECT is not set
++CONFIG_DEBUG_BUGVERBOSE=y
++# CONFIG_DEBUG_INFO is not set
++# CONFIG_DEBUG_VM is not set
++# CONFIG_DEBUG_WRITECOUNT is not set
++# CONFIG_DEBUG_MEMORY_INIT is not set
++# CONFIG_DEBUG_LIST is not set
++# CONFIG_DEBUG_SG is not set
++# CONFIG_DEBUG_NOTIFIERS is not set
++# CONFIG_DEBUG_CREDENTIALS is not set
++CONFIG_FRAME_POINTER=y
++# CONFIG_BOOT_PRINTK_DELAY is not set
++# CONFIG_RCU_TORTURE_TEST is not set
++# CONFIG_RCU_CPU_STALL_DETECTOR is not set
++# CONFIG_BACKTRACE_SELF_TEST is not set
++# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
++# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
++# CONFIG_FAULT_INJECTION is not set
++# CONFIG_LATENCYTOP is not set
++# CONFIG_SYSCTL_SYSCALL_CHECK is not set
++# CONFIG_PAGE_POISONING is not set
++CONFIG_HAVE_FUNCTION_TRACER=y
++CONFIG_TRACING_SUPPORT=y
++CONFIG_FTRACE=y
++# CONFIG_FUNCTION_TRACER is not set
++# CONFIG_IRQSOFF_TRACER is not set
++# CONFIG_PREEMPT_TRACER is not set
++# CONFIG_SCHED_TRACER is not set
++# CONFIG_ENABLE_DEFAULT_TRACERS is not set
++# CONFIG_BOOT_TRACER is not set
++CONFIG_BRANCH_PROFILE_NONE=y
++# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
++# CONFIG_PROFILE_ALL_BRANCHES is not set
++# CONFIG_STACK_TRACER is not set
++# CONFIG_KMEMTRACE is not set
++# CONFIG_WORKQUEUE_TRACER is not set
++# CONFIG_BLK_DEV_IO_TRACE is not set
++# CONFIG_DYNAMIC_DEBUG is not set
++# CONFIG_SAMPLES is not set
++CONFIG_HAVE_ARCH_KGDB=y
++# CONFIG_KGDB is not set
++# CONFIG_ARM_UNWIND is not set
++CONFIG_DEBUG_USER=y
++CONFIG_DEBUG_ERRORS=y
++# CONFIG_DEBUG_STACK_USAGE is not set
++# CONFIG_DEBUG_LL is not set
++
++#
++# Security options
++#
++# CONFIG_KEYS is not set
++# CONFIG_SECURITY is not set
++# CONFIG_SECURITYFS is not set
++# CONFIG_SECURITY_FILE_CAPABILITIES is not set
++CONFIG_CRYPTO=y
++
++#
++# Crypto core or helper
++#
++# CONFIG_CRYPTO_MANAGER is not set
++# CONFIG_CRYPTO_MANAGER2 is not set
++# CONFIG_CRYPTO_GF128MUL is not set
++# CONFIG_CRYPTO_NULL is not set
++# CONFIG_CRYPTO_CRYPTD is not set
++# CONFIG_CRYPTO_AUTHENC is not set
++# CONFIG_CRYPTO_TEST is not set
++
++#
++# Authenticated Encryption with Associated Data
++#
++# CONFIG_CRYPTO_CCM is not set
++# CONFIG_CRYPTO_GCM is not set
++# CONFIG_CRYPTO_SEQIV is not set
++
++#
++# Block modes
++#
++# CONFIG_CRYPTO_CBC is not set
++# CONFIG_CRYPTO_CTR is not set
++# CONFIG_CRYPTO_CTS is not set
++# CONFIG_CRYPTO_ECB is not set
++# CONFIG_CRYPTO_LRW is not set
++# CONFIG_CRYPTO_PCBC is not set
++# CONFIG_CRYPTO_XTS is not set
++
++#
++# Hash modes
++#
++# CONFIG_CRYPTO_HMAC is not set
++# CONFIG_CRYPTO_XCBC is not set
++# CONFIG_CRYPTO_VMAC is not set
++
++#
++# Digest
++#
++# CONFIG_CRYPTO_CRC32C is not set
++# CONFIG_CRYPTO_GHASH is not set
++# CONFIG_CRYPTO_MD4 is not set
++# CONFIG_CRYPTO_MD5 is not set
++# CONFIG_CRYPTO_MICHAEL_MIC is not set
++# CONFIG_CRYPTO_RMD128 is not set
++# CONFIG_CRYPTO_RMD160 is not set
++# CONFIG_CRYPTO_RMD256 is not set
++# CONFIG_CRYPTO_RMD320 is not set
++# CONFIG_CRYPTO_SHA1 is not set
++# CONFIG_CRYPTO_SHA256 is not set
++# CONFIG_CRYPTO_SHA512 is not set
++# CONFIG_CRYPTO_TGR192 is not set
++# CONFIG_CRYPTO_WP512 is not set
++
++#
++# Ciphers
++#
++# CONFIG_CRYPTO_AES is not set
++# CONFIG_CRYPTO_ANUBIS is not set
++# CONFIG_CRYPTO_ARC4 is not set
++# CONFIG_CRYPTO_BLOWFISH is not set
++# CONFIG_CRYPTO_CAMELLIA is not set
++# CONFIG_CRYPTO_CAST5 is not set
++# CONFIG_CRYPTO_CAST6 is not set
++# CONFIG_CRYPTO_DES is not set
++# CONFIG_CRYPTO_FCRYPT is not set
++# CONFIG_CRYPTO_KHAZAD is not set
++# CONFIG_CRYPTO_SALSA20 is not set
++# CONFIG_CRYPTO_SEED is not set
++# CONFIG_CRYPTO_SERPENT is not set
++# CONFIG_CRYPTO_TEA is not set
++# CONFIG_CRYPTO_TWOFISH is not set
++
++#
++# Compression
++#
++# CONFIG_CRYPTO_DEFLATE is not set
++# CONFIG_CRYPTO_ZLIB is not set
++# CONFIG_CRYPTO_LZO is not set
++
++#
++# Random Number Generation
++#
++# CONFIG_CRYPTO_ANSI_CPRNG is not set
++# CONFIG_CRYPTO_HW is not set
++# CONFIG_BINARY_PRINTF is not set
++
++#
++# Library routines
++#
++CONFIG_BITREVERSE=y
++CONFIG_GENERIC_FIND_LAST_BIT=y
++CONFIG_CRC_CCITT=m
++# CONFIG_CRC16 is not set
++CONFIG_CRC_T10DIF=m
++# CONFIG_CRC_ITU_T is not set
++CONFIG_CRC32=y
++# CONFIG_CRC7 is not set
++# CONFIG_LIBCRC32C is not set
++CONFIG_ZLIB_INFLATE=y
++CONFIG_ZLIB_DEFLATE=m
++CONFIG_DECOMPRESS_GZIP=y
++CONFIG_GENERIC_ALLOCATOR=y
++CONFIG_HAS_IOMEM=y
++CONFIG_HAS_IOPORT=y
++CONFIG_HAS_DMA=y
++CONFIG_NLATTR=y
+--- a/arch/arm/mach-davinci/board-dm355-evm.c
++++ b/arch/arm/mach-davinci/board-dm355-evm.c
+@@ -24,6 +24,7 @@
+ #include <media/tvp514x.h>
+ #include <linux/spi/spi.h>
+ #include <linux/spi/eeprom.h>
++#include <linux/i2c/dm355evm_msp.h>
+ 
+ #include <asm/setup.h>
+ #include <asm/mach-types.h>
+@@ -48,20 +49,26 @@
+  * swap chips, maybe with a different block size, partitioning may
+  * need to be changed.
+  */
+-#define NAND_BLOCK_SIZE		SZ_128K
++/*define NAND_BLOCK_SIZE		SZ_128K*/
++
++/* For Samsung 4K NAND (K9KAG08U0M) with 256K sectors */
++/*#define NAND_BLOCK_SIZE		SZ_256K*/
++
++/* For Micron 4K NAND with 512K sectors */
++#define NAND_BLOCK_SIZE		SZ_512K
+ 
+ static struct mtd_partition davinci_nand_partitions[] = {
+ 	{
+ 		/* UBL (a few copies) plus U-Boot */
+ 		.name		= "bootloader",
+ 		.offset		= 0,
+-		.size		= 15 * NAND_BLOCK_SIZE,
++		.size		= 30 * NAND_BLOCK_SIZE,
+ 		.mask_flags	= MTD_WRITEABLE, /* force read-only */
+ 	}, {
+ 		/* U-Boot environment */
+ 		.name		= "params",
+ 		.offset		= MTDPART_OFS_APPEND,
+-		.size		= 1 * NAND_BLOCK_SIZE,
++		.size		= 2 * NAND_BLOCK_SIZE,
+ 		.mask_flags	= 0,
+ 	}, {
+ 		.name		= "kernel",
+@@ -86,8 +93,9 @@ static struct davinci_nand_pdata davinci
+ 	.mask_chipsel		= BIT(14),
+ 	.parts			= davinci_nand_partitions,
+ 	.nr_parts		= ARRAY_SIZE(davinci_nand_partitions),
+-	.ecc_mode		= NAND_ECC_HW_SYNDROME,
++	.ecc_mode		= NAND_ECC_HW,
+ 	.options		= NAND_USE_FLASH_BBT,
++	.ecc_bits		= 4,
+ };
+ 
+ static struct resource davinci_nand_resources[] = {
+@@ -137,14 +145,58 @@ static void dm355evm_mmcsd_gpios(unsigne
+ 	dm355evm_mmc_gpios = gpio;
+ }
+ 
++#define PCA9543A_I2C_ADDR       (0x73)
++
++static struct i2c_client *pca9543a;
++
++static int pca9543a_probe(struct i2c_client *client,
++		const struct i2c_device_id *id)
++{
++	pca9543a = client;
++	return 0;
++}
++
++static int pca9543a_remove(struct i2c_client *client)
++{
++	pca9543a = NULL;
++	return 0;
++}
++
++static const struct i2c_device_id pca9543a_ids[] = {
++	{ "PCA9543A", 0, },
++	{ /* end of list */ },
++};
++
++/* This is for i2c driver for the MT9T031 header i2c switch */
++static struct i2c_driver pca9543a_driver = {
++	.driver.name	= "PCA9543A",
++	.id_table	= pca9543a_ids,
++	.probe		= pca9543a_probe,
++	.remove		= pca9543a_remove,
++};
++
+ static struct i2c_board_info dm355evm_i2c_info[] = {
+ 	{	I2C_BOARD_INFO("dm355evm_msp", 0x25),
+ 		.platform_data = dm355evm_mmcsd_gpios,
+ 	},
++	{
++		I2C_BOARD_INFO("PCA9543A", 0x73),
++	},
+ 	/* { plus irq  }, */
+ 	{ I2C_BOARD_INFO("tlv320aic33", 0x1b), },
+ };
+ 
++/* have_sensor() - Check if we have support for sensor interface */
++static inline int have_sensor(void)
++{
++#if defined(CONFIG_SOC_CAMERA_MT9T031) || \
++    defined(CONFIG_SOC_CAMERA_MT9T031_MODULE)
++	return 1;
++#else
++	return 0;
++#endif
++}
++
+ static void __init evm_init_i2c(void)
+ {
+ 	davinci_init_i2c(&i2c_pdata);
+@@ -152,7 +204,8 @@ static void __init evm_init_i2c(void)
+ 	gpio_request(5, "dm355evm_msp");
+ 	gpio_direction_input(5);
+ 	dm355evm_i2c_info[0].irq = gpio_to_irq(5);
+-
++	if (have_sensor())
++		i2c_add_driver(&pca9543a_driver);
+ 	i2c_register_board_info(1, dm355evm_i2c_info,
+ 			ARRAY_SIZE(dm355evm_i2c_info));
+ }
+@@ -181,6 +234,72 @@ static struct platform_device dm355evm_d
+ 	.num_resources	= ARRAY_SIZE(dm355evm_dm9000_rsrc),
+ };
+ 
++/**
++ * dm355evm_enable_pca9543a() - Enable/Disable I2C switch PCA9543A for sensor
++ * @en: enable/disbale flag
++ */
++static int dm355evm_enable_pca9543a(int en)
++{
++	static char val = 1;
++	int status;
++	struct i2c_msg msg = {
++			.flags = 0,
++			.len = 1,
++			.buf = &val,
++		};
++
++	if (!en)
++		val = 0;
++
++	if (!pca9543a)
++		return -ENXIO;
++
++	msg.addr = pca9543a->addr;
++	/* turn i2c switch, pca9543a, on/off */
++	status = i2c_transfer(pca9543a->adapter, &msg, 1);
++	return status;
++}
++
++/**
++ * dm355evm_setup_video_input() - setup video data path and i2c
++ * @id: sub device id
++ */
++static int dm355evm_setup_video_input(enum vpfe_subdev_id id)
++{
++	int ret;
++
++	switch (id) {
++	case VPFE_SUBDEV_MT9T031:
++	{
++		ret = dm355evm_msp_write(MSP_VIDEO_IMAGER,
++					 DM355EVM_MSP_VIDEO_IN);
++		if (ret >= 0)
++			ret = dm355evm_enable_pca9543a(1);
++		else
++			/* switch off i2c switch since we failed */
++			ret = dm355evm_enable_pca9543a(0);
++		break;
++	}
++	case VPFE_SUBDEV_TVP5146:
++	{
++		ret = dm355evm_msp_write(0, DM355EVM_MSP_VIDEO_IN);
++		break;
++	}
++	default:
++		return -EINVAL;
++	}
++	return (ret >= 0 ? 0 : ret);
++}
++
++/* Input available at the mt9t031 */
++static struct v4l2_input mt9t031_inputs[] = {
++	{
++		.index = 0,
++		.name = "Camera",
++		.type = V4L2_INPUT_TYPE_CAMERA,
++	}
++};
++
+ static struct tvp514x_platform_data tvp5146_pdata = {
+ 	.clk_polarity = 0,
+ 	.hs_polarity = 1,
+@@ -204,7 +323,7 @@ static struct v4l2_input tvp5146_inputs[
+ 	},
+ };
+ 
+-/*
++/**
+  * this is the route info for connecting each input to decoder
+  * ouput that goes to vpfe. There is a one to one correspondence
+  * with tvp5146_inputs
+@@ -222,8 +341,8 @@ static struct vpfe_route tvp5146_routes[
+ 
+ static struct vpfe_subdev_info vpfe_sub_devs[] = {
+ 	{
+-		.name = "tvp5146",
+-		.grp_id = 0,
++		.module_name = TVP514X_MODULE_NAME,
++		.grp_id = VPFE_SUBDEV_TVP5146,
+ 		.num_inputs = ARRAY_SIZE(tvp5146_inputs),
+ 		.inputs = tvp5146_inputs,
+ 		.routes = tvp5146_routes,
+@@ -237,6 +356,23 @@ static struct vpfe_subdev_info vpfe_sub_
+ 			I2C_BOARD_INFO("tvp5146", 0x5d),
+ 			.platform_data = &tvp5146_pdata,
+ 		},
++	},
++	{
++		.module_name = "mt9t031",
++		.is_camera = 1,
++		.grp_id = VPFE_SUBDEV_MT9T031,
++		.num_inputs = ARRAY_SIZE(mt9t031_inputs),
++		.inputs = mt9t031_inputs,
++		.ccdc_if_params = {
++			.if_type = VPFE_RAW_BAYER,
++			.hdpol = VPFE_PINPOL_POSITIVE,
++			.vdpol = VPFE_PINPOL_POSITIVE,
++		},
++		.board_info = {
++			I2C_BOARD_INFO("mt9t031", 0x5d),
++			/* this is for PCLK rising edge */
++			.platform_data = (void *)1,
++		},
+ 	}
+ };
+ 
+@@ -245,6 +381,9 @@ static struct vpfe_config vpfe_cfg = {
+ 	.sub_devs = vpfe_sub_devs,
+ 	.card_name = "DM355 EVM",
+ 	.ccdc = "DM355 CCDC",
++	.num_clocks = 2,
++	.clocks = {"vpss_master", "vpss_slave"},
++	.setup_input = dm355evm_setup_video_input,
+ };
+ 
+ static struct platform_device *davinci_evm_devices[] __initdata = {
+@@ -310,7 +449,7 @@ static struct spi_board_info dm355_evm_s
+ 	{
+ 		.modalias	= "at25",
+ 		.platform_data	= &at25640a,
+-		.max_speed_hz	= 10 * 1000 * 1000,	/* at 3v3 */
++		.max_speed_hz	= 30 * 1000 * 1000,	/* at 3v3 */
+ 		.bus_num	= 0,
+ 		.chip_select	= 0,
+ 		.mode		= SPI_MODE_0,
+--- /dev/null
++++ b/drivers/char/dm365_ipipe.c
+@@ -0,0 +1,4011 @@
++/*
++ * Copyright (C) 2008-2009 Texas Instruments Inc
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
++ */
++//#include <linux/config.h>
++#include <linux/module.h>
++#include <linux/init.h>
++#include <linux/string.h>
++#include <linux/kernel.h>
++#include <linux/slab.h>
++#include <linux/fs.h>
++#include <linux/errno.h>
++#include <linux/types.h>
++#include <linux/cdev.h>
++#include <linux/dma-mapping.h>
++#include <linux/interrupt.h>
++#include <linux/uaccess.h>
++#include <linux/mutex.h>
++#include <linux/device.h>
++#include <linux/videodev2.h>
++#include <media/davinci/dm365_ipipe.h>
++#include <media/davinci/imp_hw_if.h>
++
++#include <mach/irqs.h>
++
++#include "dm365_ipipe_hw.h"
++#include "dm365_def_para.h"
++
++/* IPIPE module operation state */
++struct ipipe_oper_state {
++	/* Operation state in continuous mode */
++	unsigned int state;
++	/* Semaphore to protect the common hardware configuration */
++	struct mutex lock;
++	/* previewer config state */
++	unsigned int prev_config_state;
++	/* Shared configuration of the hardware */
++	struct ipipe_params *shared_config_param;
++	/* shared resource in use */
++	unsigned int resource_in_use;
++	/* resizer config state */
++	unsigned int rsz_config_state;
++	/* resizer chained with previewer */
++	unsigned int rsz_chained;
++	/* CCDC API related variables */
++	/* Buffer type, interleaved or field seperated for interlaced
++	 *  scan
++	 */
++	unsigned int buffer_type;
++	/* frame format, 0 - interlaced, 1 - progressive */
++	unsigned int frame_format;
++	/* input pixel format */
++	enum imp_pix_formats in_pixel_format;
++	/* input pixel format */
++	enum imp_pix_formats out_pixel_format;
++};
++
++/* Operation mode of image processor (imp) */
++static u32 oper_mode = IMP_MODE_SINGLE_SHOT;
++module_param(oper_mode, uint, S_IRUGO);
++/* enable/disable serializer */
++static u32 en_serializer;
++module_param(en_serializer, uint, S_IRUGO);
++
++#define CONFIG_IPIPE_PARAM_VALIDATION
++/* ipipe module operation state & configuration */
++static struct ipipe_oper_state oper_state;
++
++/* LUT Defect pixel correction data */
++static struct prev_lutdpc lutdpc;
++static int set_lutdpc_params(struct device *dev, void *param, int len);
++static int get_lutdpc_params(struct device *dev, void *param, int len);
++
++/* LUT Defect pixel correction data */
++static struct prev_otfdpc otfdpc;
++static int set_otfdpc_params(struct device *dev, void *param, int len);
++static int get_otfdpc_params(struct device *dev, void *param, int len);
++
++/* Noise filter */
++static struct prev_nf nf1;
++static struct prev_nf nf2;
++static int set_nf1_params(struct device *dev, void *param, int len);
++static int get_nf1_params(struct device *dev, void *param, int len);
++static int set_nf2_params(struct device *dev, void *param, int len);
++static int get_nf2_params(struct device *dev, void *param, int len);
++
++/* Green Imbalance Correction */
++static struct prev_gic gic;
++static int set_gic_params(struct device *dev, void *param, int len);
++static int get_gic_params(struct device *dev, void *param, int len);
++
++/* White Balance */
++static struct prev_wb wb;
++static int set_wb_params(struct device *dev, void *param, int len);
++static int get_wb_params(struct device *dev, void *param, int len);
++
++/* CFA */
++static struct prev_cfa cfa;
++static int set_cfa_params(struct device *dev, void *param, int len);
++static int get_cfa_params(struct device *dev, void *param, int len);
++
++/* RGB2RGB conversion */
++static struct prev_rgb2rgb rgb2rgb_1;
++static struct prev_rgb2rgb rgb2rgb_2;
++static int set_rgb2rgb_1_params(struct device *dev, void *param, int len);
++static int get_rgb2rgb_1_params(struct device *dev, void *param, int len);
++static int set_rgb2rgb_2_params(struct device *dev, void *param, int len);
++static int get_rgb2rgb_2_params(struct device *dev, void *param, int len);
++
++/* Gamma correction */
++static struct prev_gamma gamma;
++static int set_gamma_params(struct device *dev, void *param, int len);
++static int get_gamma_params(struct device *dev, void *param, int len);
++
++/* 3D LUT */
++static struct prev_3d_lut lut_3d;
++static int set_3d_lut_params(struct device *dev, void *param, int len);
++static int get_3d_lut_params(struct device *dev, void *param, int len);
++
++/* Lumina Adjustment */
++static struct prev_lum_adj lum_adj;
++static int set_lum_adj_params(struct device *dev, void *param, int len);
++static int get_lum_adj_params(struct device *dev, void *param, int len);
++
++/* RGB2YUV conversion */
++static struct prev_rgb2yuv rgb2yuv;
++static int set_rgb2yuv_params(struct device *dev, void *param, int len);
++static int get_rgb2yuv_params(struct device *dev, void *param, int len);
++
++/* YUV 422 conversion */
++static struct prev_yuv422_conv yuv422_conv;
++static int set_yuv422_conv_params(struct device *dev, void *param, int len);
++static int get_yuv422_conv_params(struct device *dev, void *param, int len);
++
++/* GBCE */
++static struct prev_gbce gbce;
++static int set_gbce_params(struct device *dev, void *param, int len);
++static int get_gbce_params(struct device *dev, void *param, int len);
++
++/* Edge Enhancement */
++static struct prev_yee yee;
++static int set_yee_params(struct device *dev, void *param, int len);
++static int get_yee_params(struct device *dev, void *param, int len);
++
++/* Chromatic Artifact Reduction, CAR */
++static struct prev_car car;
++static int set_car_params(struct device *dev, void *param, int len);
++static int get_car_params(struct device *dev, void *param, int len);
++
++/* Chromatic Artifact Reduction, CAR */
++static struct prev_cgs cgs;
++static int set_cgs_params(struct device *dev, void *param, int len);
++static int get_cgs_params(struct device *dev, void *param, int len);
++
++/* Tables for various tuning modules */
++struct ipipe_lutdpc_entry ipipe_lutdpc_table[MAX_SIZE_DPC];
++struct ipipe_3d_lut_entry ipipe_3d_lut_table[MAX_SIZE_3D_LUT];
++unsigned short ipipe_gbce_table[MAX_SIZE_GBCE_LUT];
++struct ipipe_gamma_entry ipipe_gamma_table_r[MAX_SIZE_GAMMA];
++struct ipipe_gamma_entry ipipe_gamma_table_b[MAX_SIZE_GAMMA];
++struct ipipe_gamma_entry ipipe_gamma_table_g[MAX_SIZE_GAMMA];
++short ipipe_yee_table[MAX_SIZE_YEE_LUT];
++
++static struct prev_module_if prev_modules[PREV_MAX_MODULES] = {
++	{
++		.version = "5.1",
++		.module_id = PREV_LUTDPC,
++		.module_name = "LUT Defect Correction",
++		.control = 0,
++		.path = IMP_RAW2RAW | IMP_RAW2YUV,
++		.set = set_lutdpc_params,
++		.get = get_lutdpc_params
++	},
++	{
++		.version = "5.1",
++		.module_id = PREV_OTFDPC,
++		.module_name = "OTF Defect Pixel Correction",
++		.control = 0,
++		.path = IMP_RAW2RAW | IMP_RAW2YUV,
++		.set = set_otfdpc_params,
++		.get = get_otfdpc_params
++	},
++	{
++		.version = "5.1",
++		.module_id = PREV_NF1,
++		.module_name = "2-D Noise filter - 1",
++		.control = 0,
++		.path = IMP_RAW2RAW | IMP_RAW2YUV,
++		.set = set_nf1_params,
++		.get = get_nf1_params
++	},
++	{
++		.version = "5.1",
++		.module_id = PREV_NF2,
++		.module_name = "2-D Noise filter - 2",
++		.control = 0,
++		.path = IMP_RAW2RAW | IMP_RAW2YUV,
++		.set = set_nf2_params,
++		.get = get_nf2_params
++	},
++	{
++		.version = "5.1",
++		.module_id = PREV_GIC,
++		.module_name = "Green Imbalance Correction",
++		.control = 0,
++		.path = IMP_RAW2RAW | IMP_RAW2YUV,
++		.set = set_gic_params,
++		.get = get_gic_params
++	},
++	{
++		.version = "5.1",
++		.module_id = PREV_WB,
++		.module_name = "White balance",
++		.control = 1,
++		.path = IMP_RAW2RAW | IMP_RAW2YUV,
++		.set = set_wb_params,
++		.get = get_wb_params
++	},
++	{
++		.version = "5.1",
++		.module_id = PREV_CFA,
++		.module_name = "CFA Interpolation",
++		.control = 0,
++		.path = IMP_RAW2YUV,
++		.set = set_cfa_params,
++		.get = get_cfa_params
++	},
++	{
++		.version = "5.1",
++		.module_id = PREV_RGB2RGB_1,
++		.module_name = "RGB-RGB Conversion - 1",
++		.control = 0,
++		.path = IMP_RAW2YUV,
++		.set = set_rgb2rgb_1_params,
++		.get = get_rgb2rgb_1_params
++	},
++	{
++		.version = "5.1",
++		.module_id = PREV_GAMMA,
++		.module_name = "Gamma Correction",
++		.control = 0,
++		.path = IMP_RAW2YUV,
++		.set = set_gamma_params,
++		.get = get_gamma_params
++	},
++	{
++		.version = "5.1",
++		.module_id = PREV_RGB2RGB_2,
++		.module_name = "RGB-RGB Conversion - 2",
++		.control = 0,
++		.path = IMP_RAW2YUV,
++		.set = set_rgb2rgb_2_params,
++		.get = get_rgb2rgb_2_params
++	},
++	{
++		.version = "5.1",
++		.module_id = PREV_3D_LUT,
++		.module_name = "3D LUT",
++		.control = 0,
++		.path = IMP_RAW2YUV,
++		.set = set_3d_lut_params,
++		.get = get_3d_lut_params
++	},
++	{
++		.version = "5.1",
++		.module_id = PREV_RGB2YUV,
++		.module_name = "RGB-YCbCr conversion",
++		.control = 0,
++		.path = IMP_RAW2YUV,
++		.set = set_rgb2yuv_params,
++		.get = get_rgb2yuv_params
++	},
++	{
++		.version = "5.1",
++		.module_id = PREV_GBCE,
++		.module_name = "Global Brightness,Contrast Control",
++		.control = 0,
++		.path = IMP_RAW2YUV,
++		.set = set_gbce_params,
++		.get = get_gbce_params
++	},
++	{
++		.version = "5.1",
++		.module_id = PREV_YUV422_CONV,
++		.module_name = "YUV 422 conversion",
++		.control = 0,
++		.path = IMP_RAW2YUV,
++		.set = set_yuv422_conv_params,
++		.get = get_yuv422_conv_params
++	},
++	{
++		.version = "5.1",
++		.module_id = PREV_LUM_ADJ,
++		.module_name = "Luminance Adjustment",
++		.control = 1,
++		.path = IMP_RAW2YUV,
++		.set = set_lum_adj_params,
++		.get = get_lum_adj_params
++	},
++	{
++		.version = "5.1",
++		.module_id = PREV_YEE,
++		.module_name = "Edge Enhancer",
++		.control = 1,
++		.path = IMP_RAW2YUV | IMP_YUV2YUV,
++		.set = set_yee_params,
++		.get = get_yee_params
++	},
++	{
++		.version = "5.1",
++		.module_id = PREV_CAR,
++		.module_name = "Chromatic Artifact Reduction",
++		.control = 1,
++		.path = IMP_RAW2YUV | IMP_YUV2YUV,
++		.set = set_car_params,
++		.get = get_car_params
++	},
++	{
++		.version = "5.1",
++		.module_id = PREV_CGS,
++		.module_name = "Chromatic Gain Suppression",
++		.control = 1,
++		.path = IMP_RAW2YUV | IMP_YUV2YUV,
++		.set = set_cgs_params,
++		.get = get_cgs_params
++	}
++};
++
++/* function prototypes */
++static struct prev_module_if *prev_enum_preview_cap(struct device *dev,
++						    int index);
++static unsigned int prev_get_oper_mode(void);
++static unsigned int ipipe_get_oper_state(void);
++static void ipipe_set_oper_state(unsigned int state);
++static unsigned int ipipe_rsz_chain_state(void);
++static void *ipipe_alloc_config_block(struct device *dev, int shared);
++static void ipipe_dealloc_config_block(struct device *dev, void *config_block);
++static void ipipe_set_user_config_defaults(struct device *dev,
++					   enum imp_log_chan_t chan_type,
++					   unsigned int oper_mode,
++					   void *config);
++static int ipipe_set_preview_config(struct device *dev,
++				    unsigned int oper_mode,
++				    void *user_config, void *config);
++static int ipipe_set_resize_config(struct device *dev, unsigned int oper_mode,
++				   int resizer_chained,
++				   void *user_config, void *config);
++static int ipipe_reconfig_resizer(struct device *dev,
++				struct rsz_reconfig *reconfig,
++				void *config);
++
++static void ipipe_enable(unsigned char en, void *config);
++static void ipipe_get_irq(struct irq_numbers *irq);
++static unsigned int ipipe_get_rsz_config_state(void);
++static int ipipe_do_hw_setup(struct device *dev, void *config);
++static unsigned int ipipe_get_prev_config_state(void);
++static void ipipe_lock_chain(void);
++static void ipipe_unlock_chain(void);
++static void ipipe_dealloc_user_config_block(struct device *dev,
++					    void *config_block);
++static void *ipipe_alloc_user_config_block(struct device *dev,
++					   enum imp_log_chan_t chan_type,
++					   unsigned int oper_mode, int *len);
++static int ipipe_update_outbuf1_address(void *config, unsigned int address);
++static int ipipe_update_outbuf2_address(void *config, unsigned int address);
++static int ipipe_set_ipipe_if_address(void *config, unsigned int address);
++
++/* IPIPE hardware limits */
++#define IPIPE_MAX_OUTPUT_WIDTH_A	2176
++#define IPIPE_MAX_OUTPUT_WIDTH_B	640
++
++/* Based on max resolution supported. QXGA */
++#define IPIPE_MAX_OUTPUT_HEIGHT_A	1536
++/* Based on max resolution supported. VGA */
++#define IPIPE_MAX_OUTPUT_HEIGHT_B	480
++
++/* Raw YUV formats */
++static u32 ipipe_raw_yuv_pix_formats[] =
++                {V4L2_PIX_FMT_UYVY, V4L2_PIX_FMT_NV12};
++
++
++static int ipipe_enum_pix(u32 *pix, int i)
++{
++	if (i >= ARRAY_SIZE(ipipe_raw_yuv_pix_formats))
++		return -EINVAL;
++
++	*pix = ipipe_raw_yuv_pix_formats[i];
++	return 0;
++}
++
++static int ipipe_get_max_output_width(int rsz)
++{
++	if (rsz == RSZ_A)
++		return IPIPE_MAX_OUTPUT_WIDTH_A;
++	return IPIPE_MAX_OUTPUT_WIDTH_B;
++}
++
++static int ipipe_get_max_output_height(int rsz)
++{
++	if (rsz == RSZ_A)
++		return IPIPE_MAX_OUTPUT_HEIGHT_A;
++	return IPIPE_MAX_OUTPUT_HEIGHT_B;
++}
++
++static int ipipe_serialize(void)
++{
++	return en_serializer;
++}
++
++static void ipipe_dump_hw_config(void);
++
++/* APIs for CCDC driver */
++static int ipipe_set_input_win(struct imp_window *);
++static int ipipe_get_input_win(struct imp_window *);
++static int ipipe_set_in_pixel_format(enum imp_pix_formats);
++static int ipipe_set_out_pixel_format(enum imp_pix_formats);
++static int ipipe_set_buftype(unsigned char);
++static int ipipe_set_frame_format(unsigned char);
++static int ipipe_set_output_win(struct imp_window *win);
++static int ipipe_get_output_state(unsigned char out_sel);
++static int ipipe_get_line_length(unsigned char out_sel);
++static int ipipe_get_image_height(unsigned char out_sel);
++static int ipipe_set_hw_if_param(struct vpfe_hw_if_param *if_param);
++
++struct imp_hw_interface dm365_ipipe_interface = {
++	.name = "DM365 IPIPE",
++	.owner = THIS_MODULE,
++	.prev_enum_modules = prev_enum_preview_cap,
++	.get_preview_oper_mode = prev_get_oper_mode,
++	.get_resize_oper_mode = prev_get_oper_mode,
++	.get_hw_state = ipipe_get_oper_state,
++	.set_hw_state = ipipe_set_oper_state,
++	.resizer_chain = ipipe_rsz_chain_state,
++	.lock_chain = ipipe_lock_chain,
++	.unlock_chain = ipipe_unlock_chain,
++	.serialize = ipipe_serialize,
++	.alloc_config_block = ipipe_alloc_config_block,
++	.dealloc_config_block = ipipe_dealloc_config_block,
++	.alloc_user_config_block = ipipe_alloc_user_config_block,
++	.dealloc_config_block = ipipe_dealloc_user_config_block,
++	.set_user_config_defaults = ipipe_set_user_config_defaults,
++	.set_preview_config = ipipe_set_preview_config,
++	.set_resizer_config = ipipe_set_resize_config,
++	.reconfig_resizer = ipipe_reconfig_resizer,
++	.update_inbuf_address = ipipe_set_ipipe_if_address,
++	.update_outbuf1_address = ipipe_update_outbuf1_address,
++	.update_outbuf2_address = ipipe_update_outbuf2_address,
++	.enable = ipipe_enable,
++	.enable_resize = rsz_src_enable,
++	.hw_setup = ipipe_do_hw_setup,
++	.get_preview_irq = ipipe_get_irq,
++	.get_rsz_irq = ipipe_get_irq,
++	.get_resizer_config_state = ipipe_get_rsz_config_state,
++	.get_previewer_config_state = ipipe_get_prev_config_state,
++	/* Below used by CCDC driver to set input and output params */
++	.set_input_win = ipipe_set_input_win,
++	.get_input_win = ipipe_get_input_win,
++	.set_hw_if_param = ipipe_set_hw_if_param,
++	.set_in_pixel_format = ipipe_set_in_pixel_format,
++	.set_out_pixel_format = ipipe_set_out_pixel_format,
++	.set_buftype = ipipe_set_buftype,
++	.set_frame_format = ipipe_set_frame_format,
++	.set_output_win = ipipe_set_output_win,
++	.get_output_state = ipipe_get_output_state,
++	.get_line_length = ipipe_get_line_length,
++	.get_image_height = ipipe_get_image_height,
++	.get_image_height = ipipe_get_image_height,
++	.get_max_output_width = ipipe_get_max_output_width,
++	.get_max_output_height = ipipe_get_max_output_height,
++	.enum_pix = ipipe_enum_pix,
++	/* debug function */
++	.dump_hw_config = ipipe_dump_hw_config,
++};
++
++static int ipipe_set_ipipe_if_address(void *config, unsigned int address)
++{
++	struct ipipeif *if_params;
++	if (ISNULL(config))
++		return -1;
++	if_params = &((struct ipipe_params *)config)->ipipeif_param;
++	return ipipeif_set_address(if_params, address);
++}
++
++static void ipipe_lock_chain(void)
++{
++	mutex_lock(&oper_state.lock);
++	oper_state.resource_in_use = 1;
++	mutex_unlock(&oper_state.lock);
++}
++
++static void ipipe_unlock_chain(void)
++{
++	mutex_lock(&oper_state.lock);
++	oper_state.resource_in_use = 0;
++	oper_state.prev_config_state = STATE_NOT_CONFIGURED;
++	oper_state.rsz_config_state = STATE_NOT_CONFIGURED;
++	oper_state.rsz_chained = 0;
++	mutex_unlock(&oper_state.lock);
++}
++static int ipipe_process_pix_fmts(enum ipipe_pix_formats in_pix_fmt,
++				  enum ipipe_pix_formats out_pix_fmt,
++				  struct ipipe_params *param)
++{
++	enum ipipe_pix_formats temp_pix_fmt;
++
++	switch (in_pix_fmt) {
++	case IPIPE_BAYER_8BIT_PACK:
++		{
++			temp_pix_fmt = IPIPE_BAYER;
++			param->ipipeif_param.var.if_5_1.pack_mode
++			    = IPIPEIF_5_1_PACK_8_BIT;
++			break;
++		}
++	case IPIPE_BAYER_8BIT_PACK_ALAW:
++		{
++			param->ipipeif_param.var.if_5_1.pack_mode
++			    = IPIPEIF_5_1_PACK_8_BIT_A_LAW;
++			temp_pix_fmt = IPIPE_BAYER;
++			break;
++		}
++	case IPIPE_BAYER_8BIT_PACK_DPCM:
++		{
++			param->ipipeif_param.var.if_5_1.pack_mode
++			    = IPIPEIF_5_1_PACK_8_BIT;
++			param->ipipeif_param.var.if_5_1.dpcm.en = 1;
++			temp_pix_fmt = IPIPE_BAYER;
++			break;
++		}
++	case IPIPE_BAYER:
++		{
++			param->ipipeif_param.var.if_5_1.pack_mode
++			    = IPIPEIF_5_1_PACK_16_BIT;
++			temp_pix_fmt = IPIPE_BAYER;
++			break;
++		}
++	case IPIPE_BAYER_12BIT_PACK:
++		{
++			param->ipipeif_param.var.if_5_1.pack_mode
++			    = IPIPEIF_5_1_PACK_12_BIT;
++			temp_pix_fmt = IPIPE_BAYER;
++			break;
++		}
++	default:
++		{
++			temp_pix_fmt = IPIPE_UYVY;
++		}
++	}
++
++	if (temp_pix_fmt == IPIPE_BAYER)
++		if (out_pix_fmt == IPIPE_BAYER)
++			param->ipipe_dpaths_fmt = IPIPE_RAW2RAW;
++		else if ((out_pix_fmt == IPIPE_UYVY) ||
++			 (out_pix_fmt == IPIPE_YUV420SP))
++			param->ipipe_dpaths_fmt = IPIPE_RAW2YUV;
++		else {
++			printk(KERN_ERR "process pix format, unknown output"
++				 "format %d", out_pix_fmt);
++			return -1;
++		}
++	else if (temp_pix_fmt == IPIPE_UYVY) {
++		if (out_pix_fmt == IPIPE_UYVY)
++			param->ipipe_dpaths_fmt = IPIPE_YUV2YUV;
++		else if (out_pix_fmt == IPIPE_YUV420SP)
++			param->ipipe_dpaths_fmt = IPIPE_YUV2YUV;
++		else {
++			printk(KERN_ERR "process pix format, unknown output"
++				"format %d", out_pix_fmt);
++			return -1;
++		}
++	}
++	return 0;
++}
++
++/*
++ * calculate_resize_ratios()
++ *   calculates resize ratio for resizer A or B. This is called after setting
++ * the input size or output size
++ */ 
++static void calculate_resize_ratios(struct ipipe_params *param, int index)
++{
++	param->rsz_rsc_param[index].h_dif =
++	    ((param->ipipe_hsz + 1) * 256) /
++	    (param->rsz_rsc_param[index].o_hsz + 1);
++	param->rsz_rsc_param[index].v_dif =
++	    ((param->ipipe_vsz + 1) * 256) /
++	    (param->rsz_rsc_param[index].o_vsz + 1);
++}
++
++static int ipipe_do_hw_setup(struct device *dev, void *config)
++{
++	struct ipipe_params *param = (struct ipipe_params *)config;
++	int ret = 0;
++
++	dev_dbg(dev, "ipipe_do_hw_setup\n");
++	ret = mutex_lock_interruptible(&oper_state.lock);
++	if (ret)
++		return ret;
++	if ((ISNULL(config)) && (oper_mode == IMP_MODE_CONTINUOUS)) {
++		/* continuous mode */
++		param = oper_state.shared_config_param;
++		if (param->rsz_en[RSZ_A])
++			calculate_resize_ratios(param, RSZ_A);
++		if (param->rsz_en[RSZ_B])
++			calculate_resize_ratios(param, RSZ_B);
++		ret = ipipe_hw_setup(param);
++	}
++	mutex_unlock(&oper_state.lock);
++	return ret;
++}
++static void ipipe_get_irq(struct irq_numbers *irq)
++{
++	irq->sdram = IRQ_PRVUINT;
++	irq->update = -1;
++}
++
++static unsigned int ipipe_rsz_chain_state(void)
++{
++	return oper_state.rsz_chained;
++}
++
++static int ipipe_update_outbuf1_address(void *config, unsigned int address)
++{
++	if ((ISNULL(config)) && (oper_mode == IMP_MODE_CONTINUOUS))
++		return rsz_set_output_address(oper_state.shared_config_param,
++					       0,
++					       address);
++	return rsz_set_output_address((struct ipipe_params *)config,
++				       0,
++				       address);
++}
++
++static int ipipe_update_outbuf2_address(void *config, unsigned int address)
++{
++	if ((ISNULL(config)) && (oper_mode == IMP_MODE_CONTINUOUS))
++		return rsz_set_output_address(oper_state.shared_config_param,
++					       1,
++					       address);
++	return rsz_set_output_address((struct ipipe_params *)config,
++				       1,
++				       address);
++}
++
++static void ipipe_enable(unsigned char en, void *config)
++{
++	unsigned char val = 0;
++	struct ipipe_params *param = (struct ipipe_params *)config;
++
++	if (en)
++		val = 1;
++	if (oper_mode == IMP_MODE_CONTINUOUS)
++		param = oper_state.shared_config_param;
++	if (param->rsz_common.source == IPIPE_DATA)
++		regw_ip(val, IPIPE_SRC_EN);
++	else
++		regw_ip(0, IPIPE_SRC_EN);
++	if (param->rsz_en[RSZ_A])
++		rsz_enable(RSZ_A, en);
++	if (param->rsz_en[RSZ_B])
++		rsz_enable(RSZ_B, en);
++	if (oper_mode == IMP_MODE_SINGLE_SHOT)
++		ipipeif_set_enable(val, oper_mode);
++}
++
++static int validate_lutdpc_params(struct device *dev)
++{
++#ifdef CONFIG_IPIPE_PARAM_VALIDATION
++	int i;
++	if (lutdpc.en > 1 ||
++	    lutdpc.repl_white > 1 ||
++	    lutdpc.dpc_size > LUT_DPC_MAX_SIZE)
++		return -1;
++	if (lutdpc.en && (ISNULL(lutdpc.table)))
++		return -1;
++	for (i = 0; i < lutdpc.dpc_size; i++) {
++		if (lutdpc.table[i].horz_pos > LUT_DPC_H_POS_MASK ||
++		    lutdpc.table[i].vert_pos > LUT_DPC_V_POS_MASK)
++			return -1;
++	}
++#endif
++	return 0;
++}
++
++static int set_lutdpc_params(struct device *dev, void *param, int len)
++{
++	struct prev_lutdpc dpc_param;
++	struct ipipe_lutdpc_entry *temp;
++
++	if (ISNULL(param)) {
++		/* Copy defaults for dfc */
++		temp = lutdpc.table;
++		memcpy((void *)&lutdpc,
++		       (void *)&dm365_lutdpc_defaults,
++		       sizeof(struct prev_lutdpc));
++		lutdpc.table = temp;
++	} else {
++		if (len != sizeof(struct prev_lutdpc)) {
++			dev_err(dev,
++				"set_lutdpc_params: param struct length"
++				" mismatch\n");
++			return -EINVAL;
++		}
++		if (copy_from_user(&dpc_param,
++				   (struct prev_lutdpc *)param,
++				   sizeof(struct prev_lutdpc))) {
++			dev_err(dev,
++				"set_lutdpc_params: Error in copy to kernel\n");
++			return -EFAULT;
++		}
++
++		if (ISNULL(dpc_param.table)) {
++			dev_err(dev, "Invalid user dpc table ptr\n");
++			return -EINVAL;
++		}
++		lutdpc.en = dpc_param.en;
++		lutdpc.repl_white = dpc_param.repl_white;
++		lutdpc.dpc_size = dpc_param.dpc_size;
++		if (copy_from_user
++			(lutdpc.table,
++			(struct ipipe_dpc_entry *)dpc_param.table,
++			(lutdpc.dpc_size *
++			sizeof(struct ipipe_lutdpc_entry)))) {
++			dev_err(dev,
++				"set_lutdpc_params: Error in copying "
++				"dfc table to kernel\n");
++			return -EFAULT;
++		}
++
++		if (validate_lutdpc_params(dev) < 0)
++			return -EINVAL;
++	}
++	return ipipe_set_lutdpc_regs(&lutdpc);
++}
++
++static int get_lutdpc_params(struct device *dev, void *param, int len)
++{
++	struct prev_lutdpc user_lutdpc;
++	struct prev_lutdpc *lut_param = (struct prev_lutdpc *)param;
++	if (ISNULL(lut_param)) {
++		dev_err(dev, "get_lutdpc_params: invalid user ptr");
++		return -EINVAL;
++	}
++	if (len != sizeof(struct prev_lutdpc)) {
++		dev_err(dev,
++			"get_lutdpc_params: param struct length mismatch\n");
++		return -EINVAL;
++	}
++	if (copy_from_user(&user_lutdpc,
++			   lut_param,
++			   sizeof(struct prev_lutdpc))) {
++		dev_err(dev, "get_lutdpc_params: Error in copy to" " kernel\n");
++		return -EFAULT;
++	}
++
++	user_lutdpc.en = lutdpc.en;
++	user_lutdpc.repl_white = lutdpc.repl_white;
++	user_lutdpc.dpc_size = lutdpc.dpc_size;
++	if (ISNULL(user_lutdpc.table)) {
++		dev_err(dev, "get_lutdpc_params:" " Invalid table ptr");
++		return -EINVAL;
++	}
++	if (copy_to_user(user_lutdpc.table,
++			 lutdpc.table,
++			 (lutdpc.dpc_size *
++			  sizeof(struct ipipe_lutdpc_entry)))) {
++		dev_err(dev,
++			"get_lutdpc_params:Table Error in" " copy to user\n");
++		return -EFAULT;
++	}
++
++	if (copy_to_user(lut_param,
++			 &user_lutdpc,
++			 sizeof(struct prev_lutdpc))) {
++		dev_err(dev, "get_lutdpc_params: Error in copy" " to user\n");
++		return -EFAULT;
++	}
++	return 0;
++}
++
++static int validate_otfdpc_params(struct device *dev)
++{
++#ifdef CONFIG_IPIPE_PARAM_VALIDATION
++	struct prev_otfdpc *dpc_param = (struct prev_otfdpc *)&otfdpc;
++	struct prev_otfdpc_2_0 *dpc_2_0;
++	struct prev_otfdpc_3_0 *dpc_3_0;
++
++	if (dpc_param->en > 1)
++		return -1;
++	if (dpc_param->alg == IPIPE_OTFDPC_2_0) {
++		dpc_2_0 = &dpc_param->alg_cfg.dpc_2_0;
++		if (dpc_2_0->det_thr.r > OTFDPC_DPC2_THR_MASK ||
++		    dpc_2_0->det_thr.gr > OTFDPC_DPC2_THR_MASK ||
++		    dpc_2_0->det_thr.gb > OTFDPC_DPC2_THR_MASK ||
++		    dpc_2_0->det_thr.b > OTFDPC_DPC2_THR_MASK ||
++		    dpc_2_0->corr_thr.r > OTFDPC_DPC2_THR_MASK ||
++		    dpc_2_0->corr_thr.gr > OTFDPC_DPC2_THR_MASK ||
++		    dpc_2_0->corr_thr.gb > OTFDPC_DPC2_THR_MASK ||
++		    dpc_2_0->corr_thr.b > OTFDPC_DPC2_THR_MASK)
++			return -1;
++	} else {
++		dpc_3_0 = &dpc_param->alg_cfg.dpc_3_0;
++		if (dpc_3_0->act_adj_shf > OTF_DPC3_0_SHF_MASK ||
++		    dpc_3_0->det_thr > OTF_DPC3_0_DET_MASK ||
++		    dpc_3_0->det_slp > OTF_DPC3_0_SLP_MASK ||
++		    dpc_3_0->det_thr_min > OTF_DPC3_0_DET_MASK ||
++		    dpc_3_0->det_thr_max > OTF_DPC3_0_DET_MASK ||
++		    dpc_3_0->corr_thr > OTF_DPC3_0_CORR_MASK ||
++		    dpc_3_0->corr_slp > OTF_DPC3_0_SLP_MASK ||
++		    dpc_3_0->corr_thr_min > OTF_DPC3_0_CORR_MASK ||
++		    dpc_3_0->corr_thr_max > OTF_DPC3_0_CORR_MASK)
++			return -1;
++	}
++#endif
++	return 0;
++}
++
++static int set_otfdpc_params(struct device *dev, void *param, int len)
++{
++	struct prev_otfdpc *dpc_param = (struct prev_otfdpc *)param;
++
++	if (ISNULL(param)) {
++		/* Copy defaults for dpc2.0 defaults */
++		memcpy((void *)&otfdpc,
++		       (void *)&dm365_otfdpc_defaults,
++		       sizeof(struct ipipe_otfdpc_2_0));
++	} else {
++		if (len != sizeof(struct prev_otfdpc)) {
++			dev_err(dev,
++				"set_otfdpc_params: param struct length"
++				" mismatch\n");
++			return -EINVAL;
++		}
++		if (copy_from_user(&otfdpc,
++				   dpc_param,
++				   sizeof(struct prev_otfdpc))) {
++			dev_err(dev,
++				"set_otfdpc_params: Error in copy to kernel\n");
++			return -EFAULT;
++		}
++
++		if (validate_otfdpc_params(dev) < 0)
++			return -EINVAL;
++	}
++	return ipipe_set_otfdpc_regs(&otfdpc);
++}
++
++static int get_otfdpc_params(struct device *dev, void *param, int len)
++{
++	struct prev_otfdpc *dpc_param = (struct prev_otfdpc *)param;
++
++	if (ISNULL(dpc_param)) {
++		dev_err(dev, "get_otfdpc_params: invalid user ptr");
++		return -EINVAL;
++	}
++	if (len != sizeof(struct prev_otfdpc)) {
++		dev_err(dev,
++			"get_otfdpc_params: param struct length mismatch\n");
++		return -EINVAL;
++	}
++	if (copy_to_user(dpc_param,
++			 &otfdpc,
++			 sizeof(struct prev_otfdpc))) {
++		dev_err(dev,
++			"get_otfdpc_params: Error in copy dpc table to user\n");
++		return -EFAULT;
++	}
++	return 0;
++}
++
++static int validate_nf_params(struct device *dev, unsigned int id)
++{
++#ifdef CONFIG_IPIPE_PARAM_VALIDATION
++	int i;
++	struct prev_nf *nf_param = &nf1;
++
++	if (id)
++		nf_param = &nf2;
++	if (nf_param->en > 1 ||
++	    nf_param->shft_val > D2F_SHFT_VAL_MASK ||
++	    nf_param->spread_val > D2F_SPR_VAL_MASK ||
++	    nf_param->apply_lsc_gain > 1 ||
++	    nf_param->edge_det_min_thr > D2F_EDGE_DET_THR_MASK ||
++	    nf_param->edge_det_max_thr > D2F_EDGE_DET_THR_MASK)
++		return -1;
++
++	for (i = 0; i < IPIPE_NF_THR_TABLE_SIZE; i++)
++		if (nf_param->thr[i] > D2F_THR_VAL_MASK)
++			return -1;
++	for (i = 0; i < IPIPE_NF_STR_TABLE_SIZE; i++)
++		if (nf_param->str[i] > D2F_STR_VAL_MASK)
++			return -1;
++#endif
++	return 0;
++}
++
++static int set_nf_params(struct device *dev, unsigned int id,
++			 void *param, int len)
++{
++	struct prev_nf *nf_param = (struct prev_nf *)param;
++	struct prev_nf *nf = &nf1;
++
++	if (id)
++		nf = &nf2;
++
++	if (ISNULL(nf_param)) {
++		/* Copy defaults for nf */
++		memcpy((void *)nf,
++		       (void *)&dm365_nf_defaults,
++		       sizeof(struct prev_nf));
++		memset((void *)nf->thr, 0, IPIPE_NF_THR_TABLE_SIZE);
++		memset((void *)nf->str, 0, IPIPE_NF_THR_TABLE_SIZE);
++	} else {
++		if (len != sizeof(struct prev_nf)) {
++			dev_err(dev,
++				"set_nf_params: param struct length"
++				" mismatch\n");
++			return -EINVAL;
++		}
++		if (copy_from_user(nf, nf_param, sizeof(struct prev_nf))) {
++			dev_err(dev,
++				"set_nf_params: Error in copy to kernel\n");
++			return -EFAULT;
++		}
++		if (validate_nf_params(dev, id) < 0)
++			return -EINVAL;
++	}
++	/* Now set the values in the hw */
++	return ipipe_set_d2f_regs(id, nf);
++}
++
++static int set_nf1_params(struct device *dev, void *param, int len)
++{
++	return set_nf_params(dev, 0, param, len);
++}
++
++static int set_nf2_params(struct device *dev, void *param, int len)
++{
++	return set_nf_params(dev, 1, param, len);
++}
++
++static int get_nf_params(struct device *dev, unsigned int id, void *param,
++			 int len)
++{
++	struct prev_nf *nf_param = (struct prev_nf *)param;
++	struct prev_nf *nf = &nf1;
++
++	if (ISNULL(nf_param)) {
++		dev_err(dev, "get_nf_params: invalid user ptr");
++		return -EINVAL;
++	}
++	if (len != sizeof(struct prev_nf)) {
++		dev_err(dev,
++			"get_nf_params: param struct length mismatch\n");
++		return -EINVAL;
++	}
++	if (id)
++		nf = &nf2;
++	if (copy_to_user((struct prev_nf *)nf_param, nf,
++			 sizeof(struct prev_nf))) {
++		dev_err(dev, "get_nf_params: Error in copy from kernel\n");
++		return -EFAULT;
++	}
++	return 0;
++}
++
++static int get_nf1_params(struct device *dev, void *param, int len)
++{
++	return get_nf_params(dev, 0, param, len);
++}
++
++static int get_nf2_params(struct device *dev, void *param, int len)
++{
++	return get_nf_params(dev, 1, param, len);
++}
++
++static int validate_gic_params(struct device *dev)
++{
++#ifdef CONFIG_IPIPE_PARAM_VALIDATION
++	if (gic.en > 1 ||
++	    gic.gain > GIC_GAIN_MASK ||
++	    gic.thr > GIC_THR_MASK ||
++	    gic.slope > GIC_SLOPE_MASK ||
++	    gic.apply_lsc_gain > 1 ||
++	    gic.nf2_thr_gain.integer > GIC_NFGAN_INT_MASK ||
++	    gic.nf2_thr_gain.decimal > GIC_NFGAN_DECI_MASK)
++		return -1;
++#endif
++	return 0;
++}
++
++static int set_gic_params(struct device *dev, void *param, int len)
++{
++	struct prev_gic *gic_param = (struct prev_gic *)param;
++
++	if (ISNULL(gic_param)) {
++		/* Copy defaults for nf */
++		memcpy((void *)&gic,
++		       (void *)&dm365_gic_defaults,
++		       sizeof(struct prev_gic));
++	} else {
++		if (len != sizeof(struct prev_gic)) {
++			dev_err(dev,
++				"set_gic_params: param struct length"
++				" mismatch\n");
++			return -EINVAL;
++		}
++		if (copy_from_user(&gic, gic_param, sizeof(struct prev_gic))) {
++			dev_err(dev,
++				"set_gic_params: Error in copy to kernel\n");
++			return -EFAULT;
++		}
++		if (validate_gic_params(dev) < 0)
++			return -EINVAL;
++	}
++	/* Now set the values in the hw */
++	return ipipe_set_gic_regs(&gic);
++}
++
++static int get_gic_params(struct device *dev, void *param, int len)
++{
++	struct prev_gic *gic_param = (struct prev_gic *)param;
++
++	if (ISNULL(gic_param)) {
++		dev_err(dev, "get_gic_params: invalid user ptr");
++		return -EINVAL;
++	}
++
++	if (len != sizeof(struct prev_gic)) {
++		dev_err(dev,
++			"get_gic_params: param struct length mismatch\n");
++		return -EINVAL;
++	}
++
++	if (copy_to_user((struct prev_gic *)gic_param,
++			 &gic,
++			 sizeof(struct prev_gic))) {
++		dev_err(dev, "get_gic_params: Error in copy from kernel\n");
++		return -EFAULT;
++	}
++	return 0;
++}
++
++static int validate_wb_params(struct device *dev)
++{
++#ifdef CONFIG_IPIPE_PARAM_VALIDATION
++	if (wb.ofst_r > WB_OFFSET_MASK ||
++	    wb.ofst_gr > WB_OFFSET_MASK ||
++	    wb.ofst_gb > WB_OFFSET_MASK ||
++	    wb.ofst_b > WB_OFFSET_MASK ||
++	    wb.gain_r.integer > WB_GAIN_INT_MASK ||
++	    wb.gain_r.decimal > WB_GAIN_DECI_MASK ||
++	    wb.gain_gr.integer > WB_GAIN_INT_MASK ||
++	    wb.gain_gr.decimal > WB_GAIN_DECI_MASK ||
++	    wb.gain_gb.integer > WB_GAIN_INT_MASK ||
++	    wb.gain_gb.decimal > WB_GAIN_DECI_MASK ||
++	    wb.gain_b.integer > WB_GAIN_INT_MASK ||
++	    wb.gain_b.decimal > WB_GAIN_DECI_MASK)
++		return -1;
++#endif
++	return 0;
++}
++static int set_wb_params(struct device *dev, void *param, int len)
++{
++	struct prev_wb *wb_param = (struct prev_wb *)param;
++
++	dev_dbg(dev, "set_wb_params");
++	if (ISNULL(wb_param)) {
++		/* Copy defaults for wb */
++		memcpy((void *)&wb,
++		       (void *)&dm365_wb_defaults,
++		       sizeof(struct prev_wb));
++	} else {
++		if (len != sizeof(struct prev_wb)) {
++			dev_err(dev,
++				"set_wb_params: param struct length"
++				" mismatch\n");
++			return -EINVAL;
++		}
++		if (copy_from_user(&wb, wb_param, sizeof(struct prev_wb))) {
++			dev_err(dev,
++				"set_wb_params: Error in copy to kernel\n");
++			return -EFAULT;
++		}
++		if (validate_wb_params(dev) < 0)
++			return -EINVAL;
++	}
++
++	/* Now set the values in the hw */
++	return ipipe_set_wb_regs(&wb);
++}
++static int get_wb_params(struct device *dev, void *param, int len)
++{
++	struct prev_wb *wb_param = (struct prev_wb *)param;
++
++	if (ISNULL(wb_param)) {
++		dev_err(dev, "get_wb_params: invalid user ptr");
++		return -EINVAL;
++	}
++	if (len != sizeof(struct prev_wb)) {
++		dev_err(dev,
++			"get_wb_params: param struct length mismatch\n");
++		return -EINVAL;
++	}
++	if (copy_to_user((struct prev_wb *)wb_param,
++			 &wb,
++			 sizeof(struct prev_wb))) {
++		dev_err(dev, "get_wb_params: Error in copy from kernel\n");
++		return -EFAULT;
++	}
++	return 0;
++}
++
++static int validate_cfa_params(struct device *dev)
++{
++#ifdef CONFIG_IPIPE_PARAM_VALIDATION
++	if (cfa.hpf_thr_2dir > CFA_HPF_THR_2DIR_MASK ||
++	    cfa.hpf_slp_2dir > CFA_HPF_SLOPE_2DIR_MASK ||
++	    cfa.hp_mix_thr_2dir > CFA_HPF_MIX_THR_2DIR_MASK ||
++	    cfa.hp_mix_slope_2dir > CFA_HPF_MIX_SLP_2DIR_MASK ||
++	    cfa.dir_thr_2dir > CFA_DIR_THR_2DIR_MASK ||
++	    cfa.dir_slope_2dir > CFA_DIR_SLP_2DIR_MASK ||
++	    cfa.nd_wt_2dir > CFA_ND_WT_2DIR_MASK ||
++	    cfa.hue_fract_daa > CFA_DAA_HUE_FRA_MASK ||
++	    cfa.edge_thr_daa > CFA_DAA_EDG_THR_MASK ||
++	    cfa.thr_min_daa > CFA_DAA_THR_MIN_MASK ||
++	    cfa.thr_slope_daa > CFA_DAA_THR_SLP_MASK ||
++	    cfa.slope_min_daa > CFA_DAA_SLP_MIN_MASK ||
++	    cfa.slope_slope_daa > CFA_DAA_SLP_SLP_MASK ||
++	    cfa.lp_wt_daa > CFA_DAA_LP_WT_MASK)
++		return -1;
++#endif
++	return 0;
++}
++static int set_cfa_params(struct device *dev, void *param, int len)
++{
++	struct prev_cfa *cfa_param = (struct prev_cfa *)param;
++
++	dev_dbg(dev, "set_cfa_params");
++	if (ISNULL(cfa_param)) {
++		/* Copy defaults for wb */
++		memcpy((void *)&cfa,
++		       (void *)&dm365_cfa_defaults,
++		       sizeof(struct prev_cfa));
++	} else {
++		if (len != sizeof(struct prev_cfa)) {
++			dev_err(dev,
++				"set_cfa_params: param struct length"
++				" mismatch\n");
++			return -EINVAL;
++		}
++		if (copy_from_user(&cfa, cfa_param, sizeof(struct prev_cfa))) {
++			dev_err(dev,
++				"set_cfa_params: Error in copy to kernel\n");
++			return -EFAULT;
++		}
++		if (validate_cfa_params(dev) < 0)
++			return -EINVAL;
++	}
++
++	/* Now set the values in the hw */
++	return ipipe_set_cfa_regs(&cfa);
++}
++static int get_cfa_params(struct device *dev, void *param, int len)
++{
++	struct prev_cfa *cfa_param = (struct prev_cfa *)param;
++	dev_dbg(dev, "get_cfa_params\n");
++	if (ISNULL(cfa_param)) {
++		dev_err(dev, "get_cfa_params: invalid user ptr");
++		return -EINVAL;
++	}
++	if (len != sizeof(struct prev_cfa)) {
++		dev_err(dev,
++			"get_cfa_params: param struct length mismatch\n");
++		return -EINVAL;
++	}
++	if (copy_to_user((struct prev_cfa *)cfa_param,
++			 &cfa,
++			 sizeof(struct prev_cfa))) {
++		dev_err(dev, "get_cfa_params: Error in copy from kernel\n");
++		return -EFAULT;
++	}
++	return 0;
++}
++
++static int validate_rgb2rgb_params(struct device *dev, unsigned int id)
++{
++#ifdef CONFIG_IPIPE_PARAM_VALIDATION
++	struct prev_rgb2rgb *rgb2rgb = &rgb2rgb_1;
++	u32 offset_upper = RGB2RGB_1_OFST_MASK,
++	    gain_int_upper = RGB2RGB_1_GAIN_INT_MASK;
++
++	if (id) {
++		rgb2rgb = &rgb2rgb_2;
++		offset_upper = RGB2RGB_2_OFST_MASK;
++		gain_int_upper = RGB2RGB_2_GAIN_INT_MASK;
++	}
++	if (rgb2rgb->coef_rr.decimal > RGB2RGB_GAIN_DECI_MASK ||
++	    rgb2rgb->coef_rr.integer > gain_int_upper)
++		return -1;
++
++	if (rgb2rgb->coef_gr.decimal > RGB2RGB_GAIN_DECI_MASK ||
++	    rgb2rgb->coef_gr.integer > gain_int_upper)
++		return -1;
++
++	if (rgb2rgb->coef_br.decimal > RGB2RGB_GAIN_DECI_MASK ||
++	    rgb2rgb->coef_br.integer > gain_int_upper)
++		return -1;
++
++	if (rgb2rgb->coef_rg.decimal > RGB2RGB_GAIN_DECI_MASK ||
++	    rgb2rgb->coef_rg.integer > gain_int_upper)
++		return -1;
++
++	if (rgb2rgb->coef_gg.decimal > RGB2RGB_GAIN_DECI_MASK ||
++	    rgb2rgb->coef_gg.integer > gain_int_upper)
++		return -1;
++
++	if (rgb2rgb->coef_bg.decimal > RGB2RGB_GAIN_DECI_MASK ||
++	    rgb2rgb->coef_bg.integer > gain_int_upper)
++		return -1;
++
++	if (rgb2rgb->coef_rb.decimal > RGB2RGB_GAIN_DECI_MASK ||
++	    rgb2rgb->coef_rb.integer > gain_int_upper)
++		return -1;
++
++	if (rgb2rgb->coef_gb.decimal > RGB2RGB_GAIN_DECI_MASK ||
++	    rgb2rgb->coef_gb.integer > gain_int_upper)
++		return -1;
++
++	if (rgb2rgb->coef_bb.decimal > RGB2RGB_GAIN_DECI_MASK ||
++	    rgb2rgb->coef_bb.integer > gain_int_upper)
++		return -1;
++
++	if (rgb2rgb->out_ofst_r > offset_upper ||
++	    rgb2rgb->out_ofst_g > offset_upper ||
++	    rgb2rgb->out_ofst_b > offset_upper)
++		return -1;
++#endif
++	return 0;
++}
++
++static int set_rgb2rgb_params(struct device *dev, unsigned int id,
++			      void *param, int len)
++{
++	struct prev_rgb2rgb *rgb2rgb = &rgb2rgb_1;
++	struct prev_rgb2rgb *rgb2rgb_param = (struct prev_rgb2rgb *)param;
++
++	if (id)
++		rgb2rgb = &rgb2rgb_2;
++	if (ISNULL(rgb2rgb_param)) {
++		/* Copy defaults for rgb2rgb conversion */
++		memcpy((void *)rgb2rgb,
++		       (void *)&dm365_rgb2rgb_defaults,
++		       sizeof(struct prev_rgb2rgb));
++	} else {
++
++		if (len != sizeof(struct prev_rgb2rgb)) {
++			dev_err(dev,
++				"set_rgb2rgb_params: param struct length"
++				" mismatch\n");
++			return -EINVAL;
++		}
++
++		if (copy_from_user(rgb2rgb,
++				   rgb2rgb_param,
++				   sizeof(struct prev_rgb2rgb))) {
++			dev_err(dev,
++				"set_rgb2rgb_params: Error in "
++				"copy to kernel\n");
++			return -EFAULT;
++		}
++		if (validate_rgb2rgb_params(dev, id) < 0)
++			return -EINVAL;
++	}
++	return ipipe_set_rgb2rgb_regs(id, rgb2rgb);
++}
++
++static int set_rgb2rgb_1_params(struct device *dev, void *param, int len)
++{
++	return set_rgb2rgb_params(dev, 0, param, len);
++}
++
++static int set_rgb2rgb_2_params(struct device *dev, void *param, int len)
++{
++	return set_rgb2rgb_params(dev, 1, param, len);
++}
++
++static int get_rgb2rgb_params(struct device *dev, unsigned int id,
++			      void *param, int len)
++{
++	struct prev_rgb2rgb *rgb2rgb_param = (struct prev_rgb2rgb *)param;
++	struct prev_rgb2rgb *rgb2rgb = &rgb2rgb_1;
++
++	if (ISNULL(rgb2rgb_param)) {
++		dev_err(dev, "get_rgb2rgb_params: invalid user ptr");
++		return -EINVAL;
++	}
++
++	if (len != sizeof(struct prev_rgb2rgb)) {
++		dev_err(dev,
++			"get_rgb2rgb_params: param struct length mismatch\n");
++		return -EINVAL;
++	}
++
++	if (id)
++		rgb2rgb = &rgb2rgb_2;
++	if (copy_to_user((struct prev_rgb2rgb *)rgb2rgb_param,
++			 rgb2rgb,
++			 sizeof(struct prev_rgb2rgb))) {
++		dev_err(dev, "get_rgb2rgb_params: Error in copy to user\n");
++		return -EFAULT;
++	}
++	return 0;
++}
++
++static int get_rgb2rgb_1_params(struct device *dev, void *param, int len)
++{
++	return get_rgb2rgb_params(dev, 0, param, len);
++}
++
++static int get_rgb2rgb_2_params(struct device *dev, void *param, int len)
++{
++	return get_rgb2rgb_params(dev, 1, param, len);
++}
++
++static int validate_gamma_entry(struct ipipe_gamma_entry *table, int size)
++{
++#ifdef CONFIG_IPIPE_PARAM_VALIDATION
++	int i;
++
++	if (ISNULL(table))
++		return -1;
++	else {
++		for (i = 0; i < size; i++) {
++			if (table[i].slope > GAMMA_MASK ||
++			    table[i].offset > GAMMA_MASK)
++				return -1;
++		}
++	}
++#endif
++	return 0;
++}
++
++static int validate_gamma_params(struct device *dev)
++{
++#ifdef CONFIG_IPIPE_PARAM_VALIDATION
++	int table_size = 0;
++	int err = 0;
++	if (gamma.bypass_r > 1 ||
++	    gamma.bypass_b > 1 ||
++	    gamma.bypass_g > 1)
++		return -1;
++
++	if (gamma.tbl_sel == IPIPE_GAMMA_TBL_RAM) {
++		if (gamma.tbl_size == IPIPE_GAMMA_TBL_SZ_64)
++			table_size = 64;
++		if (gamma.tbl_size == IPIPE_GAMMA_TBL_SZ_128)
++			table_size = 128;
++		else if (gamma.tbl_size == IPIPE_GAMMA_TBL_SZ_256)
++			table_size = 256;
++		else if (gamma.tbl_size == IPIPE_GAMMA_TBL_SZ_512)
++			table_size = 512;
++		if (!gamma.bypass_r) {
++			err = validate_gamma_entry(gamma.table_r, table_size);
++			if (err) {
++				dev_err(dev, "GAMMA R - table entry invalid\n");
++				return err;
++			}
++		}
++		if (!gamma.bypass_b) {
++			err = validate_gamma_entry(gamma.table_b, table_size);
++			if (err) {
++				dev_err(dev, "GAMMA B - table entry invalid\n");
++				return err;
++			}
++		}
++		if (!gamma.bypass_g) {
++			err = validate_gamma_entry(gamma.table_g, table_size);
++			if (err) {
++				dev_err(dev, "GAMMA G - table entry invalid\n");
++				return err;
++			}
++		}
++	}
++#endif
++	return 0;
++}
++static int set_gamma_params(struct device *dev, void *param, int len)
++{
++	int table_size = 0;
++	struct prev_gamma user_gamma;
++	struct prev_gamma *gamma_param = (struct prev_gamma *)param;
++
++	if (ISNULL(gamma_param)) {
++		/* Copy defaults for gamma */
++		gamma.bypass_r = dm365_gamma_defaults.bypass_r;
++		gamma.bypass_g = dm365_gamma_defaults.bypass_g;
++		gamma.bypass_b = dm365_gamma_defaults.bypass_b;
++		gamma.tbl_sel = dm365_gamma_defaults.tbl_sel;
++		gamma.tbl_size = dm365_gamma_defaults.tbl_size;
++		/* By default, we bypass the gamma correction.
++		 * So no values by default for tables
++		 */
++	} else {
++		if (len != sizeof(struct prev_gamma)) {
++			dev_err(dev,
++				"set_gamma_params: param struct length"
++				" mismatch\n");
++			return -EINVAL;
++		}
++		if (copy_from_user(&user_gamma, gamma_param,
++				   sizeof(struct prev_gamma))) {
++			dev_err(dev,
++				"set_gamma_params: Error in copy to kernel\n");
++			return -EFAULT;
++		}
++		gamma.bypass_r = user_gamma.bypass_r;
++		gamma.bypass_b = user_gamma.bypass_b;
++		gamma.bypass_g = user_gamma.bypass_g;
++		gamma.tbl_sel = user_gamma.tbl_sel;
++		gamma.tbl_size = user_gamma.tbl_size;
++
++		if (user_gamma.tbl_sel == IPIPE_GAMMA_TBL_RAM) {
++			if (user_gamma.tbl_size == IPIPE_GAMMA_TBL_SZ_64)
++				table_size = 64;
++			else if (user_gamma.tbl_size == IPIPE_GAMMA_TBL_SZ_128)
++				table_size = 128;
++			else if (user_gamma.tbl_size == IPIPE_GAMMA_TBL_SZ_256)
++				table_size = 256;
++			else if (user_gamma.tbl_size == IPIPE_GAMMA_TBL_SZ_512)
++				table_size = 512;
++			else {
++				dev_err(dev,
++					"set_gamma_params: Invalid"
++					" table_size\n");
++				return -EINVAL;
++			}
++
++			if (!user_gamma.bypass_r) {
++				if (ISNULL(user_gamma.table_r)) {
++					dev_err(dev,
++						"set_gamma_params: Invalid"
++						" table ptr for R\n");
++					return -EINVAL;
++				}
++				if (copy_from_user(gamma.table_r,
++						   user_gamma.table_r,
++						   (table_size *
++						   sizeof(struct \
++						   ipipe_gamma_entry)))) {
++					dev_err(dev,
++						"set_gamma_params: R-Error"
++						" in copy to kernel\n");
++					return -EFAULT;
++				}
++			}
++
++			if (!user_gamma.bypass_b) {
++				if (ISNULL(user_gamma.table_b)) {
++					dev_err(dev,
++						"set_gamma_params: Invalid"
++						" table ptr for B\n");
++					return -EINVAL;
++				}
++				if (copy_from_user(gamma.table_b,
++						   user_gamma.table_b,
++						   (table_size *
++						   sizeof(struct \
++						   ipipe_gamma_entry)))) {
++					dev_err(dev,
++						"set_gamma_params: B-Error"
++						" in copy to kernel\n");
++					return -EFAULT;
++				}
++			}
++
++			if (!user_gamma.bypass_g) {
++				if (ISNULL(user_gamma.table_g)) {
++					dev_err(dev,
++						"set_gamma_params: Invalid"
++						" table ptr for G\n");
++					return -EINVAL;
++				}
++				if (copy_from_user(gamma.table_g,
++						   user_gamma.table_g,
++						   (table_size *
++						   sizeof(struct \
++						   ipipe_gamma_entry)))) {
++					dev_err(dev,
++						"set_gamma_params: G-Error "
++						"in copy to kernel\n");
++					return -EFAULT;
++				}
++			}
++		}
++
++		if (validate_gamma_params(dev) < 0)
++			return -EINVAL;
++	}
++	return ipipe_set_gamma_regs(&gamma);
++}
++static int get_gamma_params(struct device *dev, void *param, int len)
++{
++	int table_size = 0;
++	struct prev_gamma user_gamma;
++	struct prev_gamma *gamma_param = (struct prev_gamma *)param;
++
++	if (ISNULL(gamma_param)) {
++		dev_err(dev, "get_gamma_params: invalid user ptr");
++		return -EINVAL;
++	}
++	if (len != sizeof(struct prev_gamma)) {
++		dev_err(dev,
++			"get_gamma_params: param struct length mismatch\n");
++		return -EINVAL;
++	}
++	if (copy_from_user(&user_gamma,
++			   gamma_param,
++			   sizeof(struct prev_gamma))) {
++		dev_err(dev, "get_gamma_params: Error in copy to kernel\n");
++		return -EFAULT;
++	}
++
++	user_gamma.bypass_r = gamma.bypass_r;
++	user_gamma.bypass_g = gamma.bypass_g;
++	user_gamma.bypass_b = gamma.bypass_b;
++	user_gamma.tbl_sel = gamma.tbl_sel;
++	user_gamma.tbl_size = gamma.tbl_size;
++	if (gamma.tbl_sel == IPIPE_GAMMA_TBL_RAM) {
++		if (gamma.tbl_size == IPIPE_GAMMA_TBL_SZ_128)
++			table_size = 128;
++		else if (gamma.tbl_size == IPIPE_GAMMA_TBL_SZ_256)
++			table_size = 256;
++		else if (gamma.tbl_size == IPIPE_GAMMA_TBL_SZ_512)
++			table_size = 512;
++
++		if ((!gamma.bypass_r) && ((ISNULL(user_gamma.table_r)))) {
++			dev_err(dev,
++				"get_gamma_params: table ptr empty for R\n");
++			return -EINVAL;
++		} else {
++			if (copy_to_user(user_gamma.table_r,
++					 gamma.table_r,
++					 (table_size *
++					 sizeof(struct ipipe_gamma_entry)))) {
++				dev_err(dev,
++					"set_gamma_params: R-Table Error in"
++					" copy to user\n");
++				return -EFAULT;
++			}
++		}
++
++		if ((!gamma.bypass_b) && ((ISNULL(user_gamma.table_b)))) {
++			dev_err(dev,
++				"get_gamma_params: table ptr empty for B\n");
++			return -EINVAL;
++		} else {
++			if (copy_to_user(user_gamma.table_b,
++					 gamma.table_b,
++					 (table_size *
++					  sizeof(struct ipipe_gamma_entry)))) {
++				dev_err(dev,
++					"set_gamma_params: B-Table Error in"
++					" copy to user\n");
++				return -EFAULT;
++			}
++		}
++
++		if ((!gamma.bypass_g) && ((ISNULL(user_gamma.table_g)))) {
++			dev_err(dev,
++				"get_gamma_params: table ptr empty for G\n");
++			return -EINVAL;
++		} else {
++			if (copy_from_user(gamma.table_g,
++					   user_gamma.table_g,
++					   (table_size *
++					   sizeof(struct ipipe_gamma_entry)))) {
++				dev_err(dev,
++					"set_gamma_params: G-Table"
++					"copy error\n");
++				return -EFAULT;
++			}
++		}
++
++	}
++	if (copy_to_user(gamma_param, &user_gamma, sizeof(struct prev_gamma))) {
++		dev_err(dev, "get_dfc_params: Error in copy from kernel\n");
++		return -EFAULT;
++	}
++	return 0;
++}
++
++static int validate_3d_lut_params(struct device *dev)
++{
++#ifdef CONFIG_IPIPE_PARAM_VALIDATION
++	int i;
++	if (lut_3d.en > 1)
++		return -1;
++	if (lut_3d.en) {
++		for (i = 0; i < MAX_SIZE_3D_LUT; i++) {
++			if (lut_3d.table[i].r > D3_LUT_ENTRY_MASK ||
++			    lut_3d.table[i].g > D3_LUT_ENTRY_MASK ||
++			    lut_3d.table[i].b > D3_LUT_ENTRY_MASK)
++				return -1;
++		}
++	}
++#endif
++	return 0;
++}
++static int set_3d_lut_params(struct device *dev, void *param, int len)
++{
++	struct prev_3d_lut user_3d_lut;
++	struct prev_3d_lut *lut_param = (struct prev_3d_lut *)param;
++
++	if (ISNULL(lut_param)) {
++		/* Copy defaults for gamma */
++		lut_3d.en = dm365_3d_lut_defaults.en;
++		/* By default, 3D lut is disabled
++		 */
++	} else {
++		if (len != sizeof(struct prev_3d_lut)) {
++			dev_err(dev,
++				"set_3d_lut_params: param struct"
++				" length mismatch\n");
++			return -EINVAL;
++		}
++		if (copy_from_user(&user_3d_lut,
++				   lut_param,
++				   sizeof(struct prev_3d_lut))) {
++			dev_err(dev,
++				"set_3d_lut_params: Error in copy to"
++				" kernel\n");
++			return -EFAULT;
++		}
++		lut_3d.en = user_3d_lut.en;
++		if (ISNULL(user_3d_lut.table)) {
++			dev_err(dev, "set_3d_lut_params:" " Invalid table ptr");
++			return -EINVAL;
++		}
++		if (copy_from_user(lut_3d.table,
++				   user_3d_lut.table,
++				   (MAX_SIZE_3D_LUT *
++				   sizeof(struct ipipe_3d_lut_entry)))) {
++			dev_err(dev,
++				"set_3d_lut_params:Error"
++				" in copy to kernel\n");
++			return -EFAULT;
++		}
++
++		if (validate_3d_lut_params(dev) < 0)
++			return -EINVAL;
++	}
++	return ipipe_set_3d_lut_regs(&lut_3d);
++}
++static int get_3d_lut_params(struct device *dev, void *param, int len)
++{
++	struct prev_3d_lut user_3d_lut;
++	struct prev_3d_lut *lut_param = (struct prev_3d_lut *)param;
++
++	if (ISNULL(lut_param)) {
++		dev_err(dev, "get_3d_lut_params: invalid user ptr");
++		return -EINVAL;
++	}
++	if (len != sizeof(struct prev_3d_lut)) {
++		dev_err(dev,
++			"get_3d_lut_params: param struct length mismatch\n");
++		return -EINVAL;
++	}
++	if (copy_from_user(&user_3d_lut,
++			   lut_param,
++			   sizeof(struct prev_3d_lut))) {
++		dev_err(dev, "get_3d_lut_params: Error in copy to" " kernel\n");
++		return -EFAULT;
++	}
++
++	user_3d_lut.en = lut_3d.en;
++	if (ISNULL(user_3d_lut.table)) {
++		dev_err(dev, "get_3d_lut_params:" " Invalid table ptr");
++		return -EINVAL;
++	}
++	if (copy_to_user(user_3d_lut.table, lut_3d.table,
++			 (MAX_SIZE_3D_LUT *
++			  sizeof(struct ipipe_3d_lut_entry)))) {
++		dev_err(dev,
++			"get_3d_lut_params:Table Error in" " copy to user\n");
++		return -EFAULT;
++	}
++
++	if (copy_to_user(lut_param, &user_3d_lut, sizeof(struct prev_3d_lut))) {
++		dev_err(dev, "get_3d_lut_params: Error in copy" " to user\n");
++		return -EFAULT;
++	}
++	return 0;
++}
++
++static int validate_lum_adj_params(struct device *dev)
++{
++	/* nothing to validate */
++	return 0;
++}
++
++static int set_lum_adj_params(struct device *dev, void *param, int len)
++{
++	struct prev_lum_adj *lum_adj_param = (struct prev_lum_adj *)param;
++
++	if (ISNULL(lum_adj_param)) {
++		/* Copy defaults for Luminance adjustments */
++		memcpy((void *)&lum_adj,
++		       (void *)&dm365_lum_adj_defaults,
++		       sizeof(struct prev_lum_adj));
++	} else {
++		if (len != sizeof(struct prev_lum_adj)) {
++			dev_err(dev,
++				"set_lum_adj_params: param struct length"
++				" mismatch\n");
++			return -EINVAL;
++		}
++		if (copy_from_user(&lum_adj,
++				   lum_adj_param,
++				   sizeof(struct prev_lum_adj))) {
++			dev_err(dev,
++				"set_lum_adj_params: Error in copy"
++				" from user\n");
++			return -EFAULT;
++		}
++		if (validate_lum_adj_params(dev) < 0)
++			return -EINVAL;
++	}
++	return ipipe_set_lum_adj_regs(&lum_adj);
++}
++
++static int get_lum_adj_params(struct device *dev, void *param, int len)
++{
++	struct prev_lum_adj *lum_adj_param = (struct prev_lum_adj *)param;
++	if (ISNULL(lum_adj_param)) {
++		dev_err(dev, "get_lum_adj_params: invalid user ptr");
++		return -EINVAL;
++	}
++
++	if (len != sizeof(struct prev_lum_adj)) {
++		dev_err(dev,
++			"get_lum_adj_params: param struct length mismatch\n");
++		return -EINVAL;
++	}
++
++	if (copy_to_user(lum_adj_param,
++			 &lum_adj,
++			 sizeof(struct prev_lum_adj))) {
++		dev_err(dev, "get_lum_adj_params: Error in copy to" " user\n");
++		return -EFAULT;
++	}
++	return 0;
++}
++
++static int validate_rgb2yuv_params(struct device *dev)
++{
++#ifdef CONFIG_IPIPE_PARAM_VALIDATION
++	if (rgb2yuv.coef_ry.decimal > RGB2YCBCR_COEF_DECI_MASK ||
++	    rgb2yuv.coef_ry.integer > RGB2YCBCR_COEF_INT_MASK)
++		return -1;
++
++	if (rgb2yuv.coef_gy.decimal > RGB2YCBCR_COEF_DECI_MASK ||
++	    rgb2yuv.coef_gy.integer > RGB2YCBCR_COEF_INT_MASK)
++		return -1;
++
++	if (rgb2yuv.coef_by.decimal > RGB2YCBCR_COEF_DECI_MASK ||
++	    rgb2yuv.coef_by.integer > RGB2YCBCR_COEF_INT_MASK)
++		return -1;
++
++	if (rgb2yuv.coef_rcb.decimal > RGB2YCBCR_COEF_DECI_MASK ||
++	    rgb2yuv.coef_rcb.integer > RGB2YCBCR_COEF_INT_MASK)
++		return -1;
++
++	if (rgb2yuv.coef_gcb.decimal > RGB2YCBCR_COEF_DECI_MASK ||
++	    rgb2yuv.coef_gcb.integer > RGB2YCBCR_COEF_INT_MASK)
++		return -1;
++
++	if (rgb2yuv.coef_bcb.decimal > RGB2YCBCR_COEF_DECI_MASK ||
++	    rgb2yuv.coef_bcb.integer > RGB2YCBCR_COEF_INT_MASK)
++		return -1;
++
++	if (rgb2yuv.coef_rcr.decimal > RGB2YCBCR_COEF_DECI_MASK ||
++	    rgb2yuv.coef_rcr.integer > RGB2YCBCR_COEF_INT_MASK)
++		return -1;
++
++	if (rgb2yuv.coef_gcr.decimal > RGB2YCBCR_COEF_DECI_MASK ||
++	    rgb2yuv.coef_gcr.integer > RGB2YCBCR_COEF_INT_MASK)
++		return -1;
++
++	if (rgb2yuv.coef_bcr.decimal > RGB2YCBCR_COEF_DECI_MASK ||
++	    rgb2yuv.coef_bcr.integer > RGB2YCBCR_COEF_INT_MASK)
++		return -1;
++
++	if (rgb2yuv.out_ofst_y > RGB2YCBCR_OFST_MASK ||
++	    rgb2yuv.out_ofst_cb > RGB2YCBCR_OFST_MASK ||
++	    rgb2yuv.out_ofst_cr > RGB2YCBCR_OFST_MASK)
++		return -1;
++#endif
++	return 0;
++}
++static int set_rgb2yuv_params(struct device *dev, void *param, int len)
++{
++	struct prev_rgb2yuv *rgb2yuv_param = (struct prev_rgb2yuv *)param;
++
++	if (ISNULL(rgb2yuv_param)) {
++		/* Copy defaults for rgb2yuv conversion  */
++		memcpy((void *)&rgb2yuv,
++		       (void *)&dm365_rgb2yuv_defaults,
++		       sizeof(struct prev_rgb2yuv));
++	} else {
++		if (len != sizeof(struct prev_rgb2yuv)) {
++			dev_err(dev,
++				"set_rgb2yuv_params: param struct"
++				" length mismatch\n");
++			return -EINVAL;
++		}
++		if (copy_from_user(&rgb2yuv,
++				   rgb2yuv_param,
++				   sizeof(struct prev_rgb2yuv))) {
++			dev_err(dev,
++				"set_rgb2yuv_params: Error in copy from"
++				" user\n");
++			return -EFAULT;
++		}
++		if (validate_rgb2yuv_params(dev) < 0)
++			return -EINVAL;
++	}
++	return ipipe_set_rgb2ycbcr_regs(&rgb2yuv);
++}
++static int get_rgb2yuv_params(struct device *dev, void *param, int len)
++{
++	struct prev_rgb2yuv *rgb2yuv_param = (struct prev_rgb2yuv *)param;
++	if (ISNULL(rgb2yuv_param)) {
++		dev_err(dev, "get_rgb2yuv_params: invalid user ptr");
++		return -EINVAL;
++	}
++	if (len != sizeof(struct prev_rgb2yuv)) {
++		dev_err(dev,
++			"get_rgb2yuv_params: param struct length mismatch\n");
++		return -EINVAL;
++	}
++	if (copy_to_user((struct prev_rgb2yuv *)rgb2yuv_param,
++			 &rgb2yuv,
++			 sizeof(struct prev_rgb2yuv))) {
++		dev_err(dev, "get_rgb2yuv_params: Error in copy from"
++			" kernel\n");
++		return -EFAULT;
++	}
++	return 0;
++}
++
++static int validate_gbce_params(struct device *dev)
++{
++#ifdef CONFIG_IPIPE_PARAM_VALIDATION
++	int i;
++	u32 max = GBCE_Y_VAL_MASK;
++	if (gbce.type == IPIPE_GBCE_GAIN_TBL)
++		max = GBCE_GAIN_VAL_MASK;
++	if (gbce.en > 1)
++		return -1;
++	if (gbce.en) {
++		for (i = 0; i < MAX_SIZE_GBCE_LUT; i++)
++			if (gbce.table[i] > max)
++				return -1;
++	}
++#endif
++	return 0;
++}
++static int set_gbce_params(struct device *dev, void *param, int len)
++{
++	struct prev_gbce user_gbce;
++	struct prev_gbce *gbce_param = (struct prev_gbce *)param;
++
++	if (ISNULL(gbce_param))
++		/* Copy defaults for gamma */
++		gbce.en = dm365_gbce_defaults.en;
++		/* By default, GBCE is disabled
++		 */
++	else {
++		if (len != sizeof(struct prev_gbce)) {
++			dev_err(dev,
++				"set_gbce_params: param struct"
++				" length mismatch\n");
++			return -EINVAL;
++		}
++		if (copy_from_user(&user_gbce,
++				   gbce_param,
++				   sizeof(struct prev_gbce))) {
++			dev_err(dev,
++				"set_gbce_params: Error in copy to"
++				" kernel\n");
++			return -EFAULT;
++		}
++		gbce.en = user_gbce.en;
++		gbce.type = user_gbce.type;
++		if (ISNULL(user_gbce.table)) {
++			dev_err(dev, "set_gbce_params:" " Invalid table ptr");
++			return -EINVAL;
++		}
++
++		if (copy_from_user(gbce.table,
++				   user_gbce.table,
++				   (MAX_SIZE_GBCE_LUT *
++				   sizeof(unsigned short)))) {
++			dev_err(dev,
++				"set_gbce_params:Error" " in copy to kernel\n");
++			return -EFAULT;
++		}
++		if (validate_gbce_params(dev) < 0)
++			return -EINVAL;
++	}
++	return ipipe_set_gbce_regs(&gbce);
++}
++static int get_gbce_params(struct device *dev, void *param, int len)
++{
++	struct prev_gbce user_gbce;
++	struct prev_gbce *gbce_param = (struct prev_gbce *)param;
++
++	if (ISNULL(gbce_param)) {
++		dev_err(dev, "get_gbce_params: invalid user ptr");
++		return -EINVAL;
++	}
++	if (len != sizeof(struct prev_gbce)) {
++		dev_err(dev,
++			"get_gbce_params: param struct length mismatch\n");
++		return -EINVAL;
++	}
++	if (copy_from_user(&user_gbce, gbce_param, sizeof(struct prev_gbce))) {
++		dev_err(dev, "get_gbce_params: Error in copy to" " kernel\n");
++		return -EFAULT;
++	}
++
++	user_gbce.en = gbce.en;
++	user_gbce.type = gbce.type;
++	if (ISNULL(user_gbce.table)) {
++		dev_err(dev, "get_gbce_params:" " Invalid table ptr");
++		return -EINVAL;
++	}
++	if (copy_to_user(user_gbce.table,
++			 gbce.table,
++			 (MAX_SIZE_GBCE_LUT *
++			 sizeof(unsigned short)))) {
++		dev_err(dev,
++			"get_gbce_params:Table Error in" " copy to user\n");
++		return -EFAULT;
++	}
++
++	if (copy_to_user(gbce_param, &user_gbce, sizeof(struct prev_gbce))) {
++		dev_err(dev, "get_gbce_params: Error in copy" " to user\n");
++		return -EFAULT;
++	}
++	return 0;
++}
++
++static int validate_yuv422_conv_params(struct device *dev)
++{
++#ifdef CONFIG_IPIPE_PARAM_VALIDATION
++	if (yuv422_conv.en_chrom_lpf > 1)
++		return -1;
++#endif
++	return 0;
++}
++
++static int set_yuv422_conv_params(struct device *dev, void *param, int len)
++{
++	struct prev_yuv422_conv *yuv422_conv_param =
++	    (struct prev_yuv422_conv *)param;
++	if (ISNULL(yuv422_conv_param)) {
++		/* Copy defaults for yuv 422 conversion */
++		memcpy((void *)&yuv422_conv,
++		       (void *)&dm365_yuv422_conv_defaults,
++		       sizeof(struct prev_yuv422_conv));
++	} else {
++		if (len != sizeof(struct prev_yuv422_conv)) {
++			dev_err(dev,
++				"set_yuv422_conv_params: param struct"
++				" length mismatch\n");
++			return -EINVAL;
++		}
++		if (copy_from_user(&yuv422_conv,
++				   yuv422_conv_param,
++				   sizeof(struct prev_yuv422_conv))) {
++			dev_err(dev,
++				"set_yuv422_conv_params: Error in copy"
++				" from user\n");
++			return -EFAULT;
++		}
++		if (validate_yuv422_conv_params(dev) < 0)
++			return -EINVAL;
++	}
++	return ipipe_set_yuv422_conv_regs(&yuv422_conv);
++}
++static int get_yuv422_conv_params(struct device *dev, void *param, int len)
++{
++	struct prev_yuv422_conv *yuv422_conv_param =
++	    (struct prev_yuv422_conv *)param;
++
++	if (ISNULL(yuv422_conv_param)) {
++		dev_err(dev, "get_yuv422_conv_params: invalid user ptr");
++		return -EINVAL;
++	}
++	if (len != sizeof(struct prev_yuv422_conv)) {
++		dev_err(dev,
++			"get_yuv422_conv_params: param struct"
++			" length mismatch\n");
++		return -EINVAL;
++	}
++	if (copy_to_user(yuv422_conv_param,
++			 &yuv422_conv,
++			 sizeof(struct prev_yuv422_conv))) {
++		dev_err(dev,
++			"get_yuv422_conv_params: Error in copy from kernel\n");
++		return -EFAULT;
++	}
++	return 0;
++}
++
++static int validate_yee_params(struct device *dev)
++{
++#ifdef CONFIG_IPIPE_PARAM_VALIDATION
++	int i;
++	if (yee.en > 1 ||
++	    yee.en_halo_red > 1 ||
++	    yee.hpf_shft > YEE_HPF_SHIFT_MASK)
++		return -1;
++
++	if (yee.hpf_coef_00 > YEE_COEF_MASK ||
++	    yee.hpf_coef_01 > YEE_COEF_MASK ||
++	    yee.hpf_coef_02 > YEE_COEF_MASK ||
++	    yee.hpf_coef_10 > YEE_COEF_MASK ||
++	    yee.hpf_coef_11 > YEE_COEF_MASK ||
++	    yee.hpf_coef_12 > YEE_COEF_MASK ||
++	    yee.hpf_coef_20 > YEE_COEF_MASK ||
++	    yee.hpf_coef_21 > YEE_COEF_MASK ||
++	    yee.hpf_coef_22 > YEE_COEF_MASK)
++		return -1;
++
++	if (yee.yee_thr > YEE_THR_MASK ||
++	    yee.es_gain > YEE_ES_GAIN_MASK ||
++	    yee.es_thr1 > YEE_ES_THR1_MASK ||
++	    yee.es_thr2 > YEE_THR_MASK ||
++	    yee.es_gain_grad > YEE_THR_MASK ||
++	    yee.es_ofst_grad > YEE_THR_MASK)
++		return -1;
++
++	for (i = 0; i < MAX_SIZE_YEE_LUT ; i++)
++		if (yee.table[i] > YEE_ENTRY_MASK)
++			return -1;
++#endif
++	return 0;
++}
++static int set_yee_params(struct device *dev, void *param, int len)
++{
++	short *temp_table;
++	struct prev_yee user_yee;
++	struct prev_yee *yee_param = (struct prev_yee *)param;
++
++	if (ISNULL(yee_param)) {
++		temp_table = yee.table;
++		/* Copy defaults for ns */
++		memcpy((void *)&yee,
++		       (void *)&dm365_yee_defaults,
++		       sizeof(struct prev_yee));
++		yee.table = temp_table;
++	} else {
++		if (len != sizeof(struct prev_yee)) {
++			dev_err(dev,
++				"set_yee_params: param struct"
++				" length mismatch\n");
++			return -EINVAL;
++		}
++		if (copy_from_user(&user_yee,
++				   yee_param,
++				   sizeof(struct prev_yee))) {
++			dev_err(dev,
++				"set_yee_params: Error in copy from user\n");
++			return -EFAULT;
++		}
++		if (ISNULL(user_yee.table)) {
++			dev_err(dev, "get_yee_params: yee table ptr null\n");
++			return -EINVAL;
++		}
++		if (copy_from_user(yee.table,
++				   user_yee.table,
++				   (MAX_SIZE_YEE_LUT * sizeof(short)))) {
++			dev_err(dev,
++				"set_yee_params: Error in copy from user\n");
++			return -EFAULT;
++		}
++		temp_table = yee.table;
++		memcpy(&yee, &user_yee, sizeof(struct prev_yee));
++		yee.table = temp_table;
++		if (validate_yee_params(dev) < 0)
++			return -EINVAL;
++	}
++	return ipipe_set_ee_regs(&yee);
++}
++static int get_yee_params(struct device *dev, void *param, int len)
++{
++	short *temp_table;
++	struct prev_yee *yee_param = (struct prev_yee *)param;
++	struct prev_yee user_yee;
++
++	if (ISNULL(yee_param)) {
++		dev_err(dev, "get_yee_params: invalid user ptr");
++		return -EINVAL;
++	}
++	if (len != sizeof(struct prev_yee)) {
++		dev_err(dev,
++			"get_yee_params: param struct"
++			" length mismatch\n");
++		return -EINVAL;
++	}
++	if (copy_from_user(&user_yee, yee_param, sizeof(struct prev_yee))) {
++		dev_err(dev, "get_yee_params: Error in copy to kernel\n");
++		return -EFAULT;
++	}
++	if (ISNULL(user_yee.table)) {
++		dev_err(dev, "get_yee_params: yee table ptr null\n");
++		return -EINVAL;
++	}
++	if (copy_to_user(user_yee.table, yee.table,
++			 (MAX_SIZE_YEE_LUT * sizeof(short)))) {
++		dev_err(dev, "get_yee_params: Error in copy from kernel\n");
++		return -EFAULT;
++	}
++	temp_table = user_yee.table;
++	memcpy(&user_yee, &yee, sizeof(struct prev_yee));
++	user_yee.table = temp_table;
++
++	if (copy_to_user(yee_param, &user_yee, sizeof(struct prev_yee))) {
++		dev_err(dev, "get_yee_params: Error in copy from kernel\n");
++		return -EFAULT;
++	}
++	return 0;
++}
++
++static int validate_car_params(struct device *dev)
++{
++#ifdef CONFIG_IPIPE_PARAM_VALIDATION
++	if (car.en > 1 ||
++	    car.hpf_shft > CAR_HPF_SHIFT_MASK ||
++	    car.gain1.shft > CAR_GAIN1_SHFT_MASK ||
++	    car.gain1.gain_min > CAR_GAIN_MIN_MASK ||
++	    car.gain2.shft > CAR_GAIN2_SHFT_MASK ||
++	    car.gain2.gain_min > CAR_GAIN_MIN_MASK)
++		return -1;
++#endif
++	return 0;
++}
++
++static int set_car_params(struct device *dev, void *param, int len)
++{
++	struct prev_car *car_param = (struct prev_car *)param;
++
++	if (ISNULL(car_param)) {
++		/* Copy defaults for ns */
++		memcpy((void *)&car,
++		       (void *)&dm365_car_defaults,
++		       sizeof(struct prev_car));
++	} else {
++		if (len != sizeof(struct prev_car)) {
++			dev_err(dev,
++				"set_car_params: param struct"
++				" length mismatch\n");
++			return -EINVAL;
++		}
++		if (copy_from_user(&car, car_param, sizeof(struct prev_car))) {
++			dev_err(dev,
++				"set_car_params: Error in copy from user\n");
++			return -EFAULT;
++		}
++		if (validate_car_params(dev) < 0)
++			return -EINVAL;
++	}
++	return ipipe_set_car_regs(&car);
++}
++static int get_car_params(struct device *dev, void *param, int len)
++{
++	struct prev_car *car_param = (struct prev_car *)param;
++
++	if (ISNULL(car_param)) {
++		dev_err(dev, "get_car_params: invalid user ptr");
++		return -EINVAL;
++	}
++	if (len != sizeof(struct prev_car)) {
++		dev_err(dev,
++			"get_car_params: param struct"
++			" length mismatch\n");
++		return -EINVAL;
++	}
++	if (copy_to_user(car_param, &car, sizeof(struct prev_car))) {
++		dev_err(dev, "get_car_params: Error in copy from kernel\n");
++		return -EFAULT;
++	}
++	return 0;
++}
++
++static int validate_cgs_params(struct device *dev)
++{
++#ifdef CONFIG_IPIPE_PARAM_VALIDATION
++	if (cgs.en > 1 ||
++	    cgs.h_shft > CAR_SHIFT_MASK)
++		return -1;
++#endif
++	return 0;
++}
++
++static int set_cgs_params(struct device *dev, void *param, int len)
++{
++	struct prev_cgs *cgs_param = (struct prev_cgs *)param;
++
++	if (ISNULL(cgs_param)) {
++		/* Copy defaults for ns */
++		memcpy((void *)&cgs,
++		       (void *)&dm365_cgs_defaults,
++		       sizeof(struct prev_cgs));
++	} else {
++		if (len != sizeof(struct prev_cgs)) {
++			dev_err(dev,
++				"set_cgs_params: param struct"
++				" length mismatch\n");
++			return -EINVAL;
++		}
++		if (copy_from_user(&cgs, cgs_param, sizeof(struct prev_cgs))) {
++			dev_err(dev,
++				"set_cgs_params: Error in copy from user\n");
++			return -EFAULT;
++		}
++		if (validate_cgs_params(dev) < 0)
++			return -EINVAL;
++	}
++	return ipipe_set_cgs_regs(&cgs);
++}
++static int get_cgs_params(struct device *dev, void *param, int len)
++{
++	struct prev_cgs *cgs_param = (struct prev_cgs *)param;
++
++	if (ISNULL(cgs_param)) {
++		dev_err(dev, "get_cgs_params: invalid user ptr");
++		return -EINVAL;
++	}
++	if (len != sizeof(struct prev_cgs)) {
++		dev_err(dev,
++			"get_cgs_params: param struct"
++			" length mismatch\n");
++		return -EINVAL;
++	}
++	if (copy_to_user(cgs_param, &cgs, sizeof(struct prev_cgs))) {
++		dev_err(dev, "get_cgs_params: Error in copy from kernel\n");
++		return -EFAULT;
++	}
++	return 0;
++}
++
++static struct prev_module_if *prev_enum_preview_cap(struct device *dev,
++						    int index)
++{
++	dev_dbg(dev, "prev_enum_preview_cap: index = %d\n", index);
++	if ((index + 1) > PREV_MAX_MODULES)
++		return NULL;
++
++	return &prev_modules[index];
++}
++
++static unsigned int prev_get_oper_mode(void)
++{
++	return oper_mode;
++}
++
++static unsigned int ipipe_get_oper_state(void)
++{
++	return oper_state.state;
++}
++
++static void ipipe_set_oper_state(unsigned int state)
++{
++	mutex_lock(&oper_state.lock);
++	oper_state.state = state;
++	mutex_unlock(&oper_state.lock);
++}
++
++static unsigned int ipipe_get_prev_config_state(void)
++{
++	return oper_state.prev_config_state;
++}
++
++static unsigned int ipipe_get_rsz_config_state(void)
++{
++	return oper_state.rsz_config_state;
++}
++
++/* function: calculate_normal_f_div_param
++ * Algorithm to calculate the frame division parameters for resizer.
++ * in normal mode. Please refer the application note in DM360 functional
++ * spec for details of the algorithm
++ */
++static int calculate_normal_f_div_param(struct device *dev,
++					int input_width,
++					int output_width,
++					struct ipipe_rsz_rescale_param *param)
++{
++	/* rsz = R, input_width = H, output width = h in the equation */
++	unsigned int rsz, temp, temp1, o, h1, h2;
++	if (output_width > input_width) {
++		dev_err(dev, "frame div mode is used for scale down only\n");
++		return -1;
++	}
++
++	rsz = (input_width << 8) / output_width;
++	temp = rsz << 1;
++	temp1 = ((input_width << 8) / temp) + 1;
++	o = 14;
++	if (!(temp1 % 2)) {
++		h1 = temp1;
++	} else {
++		temp1 = (input_width << 7);
++		temp1 -= (rsz >> 1);
++		temp1 /= (rsz << 1);
++		temp1 <<= 1;
++		temp1 += 2;
++		o += ((CEIL(rsz, 1024)) << 1);
++		h1 = temp1;
++	}
++	h2 = output_width - h1;
++	/* phi */
++	temp = (h1 * rsz) - (((input_width >> 1) - o) << 8);
++	/* skip */
++	temp1 = ((temp - 1024) >> 9) << 1;
++	param->f_div.num_passes = IPIPE_MAX_PASSES;
++	param->f_div.pass[0].o_hsz = h1 - 1;
++	param->f_div.pass[0].i_hps = 0;
++	param->f_div.pass[0].h_phs = 0;
++	param->f_div.pass[0].src_hps = 0;
++	param->f_div.pass[0].src_hsz = (input_width >> 2) + o;
++	param->f_div.pass[1].o_hsz = h2 - 1;
++	param->f_div.pass[1].i_hps = temp1;
++	param->f_div.pass[1].h_phs = (temp - (temp1 << 8));
++	param->f_div.pass[1].src_hps = (input_width >> 2) - o;
++	param->f_div.pass[1].src_hsz = (input_width >> 2) + o;
++	return 0;
++}
++
++/* function: calculate_down_scale_f_div_param
++ * Algorithm to calculate the frame division parameters for resizer in
++ * downscale mode. Please refer the application note in DM360 functional
++ * spec for details of the algorithm
++ */
++static int calculate_down_scale_f_div_param(struct device *dev,
++					    int input_width,
++					    int output_width,
++					    struct ipipe_rsz_rescale_param
++					    *param)
++{
++	/* rsz = R, input_width = H, output width = h in the equation */
++	unsigned int upper_h1, upper_h2, rsz, temp, temp1, o, h1, h2, two_power,
++	    n;
++
++	upper_h1 = input_width >> 1;
++	n = param->h_dscale_ave_sz;
++	/* 2 ^ (scale+1) */
++	two_power = (1 << (n + 1));
++	upper_h1 = (upper_h1 >> (n + 1)) << (n + 1);
++	upper_h2 = input_width - upper_h1;
++	if (upper_h2 % two_power) {
++		dev_err(dev, "frame halves to be a multiple of 2 power n+1 \n");
++		return -1;
++	}
++	two_power = (1 << n);
++	rsz = (input_width << 8) / output_width;
++	temp = rsz * two_power;
++	temp1 = ((upper_h1 << 8) / temp) + 1;
++	if (!(temp1 % 2))
++		h1 = temp1;
++	else {
++		temp1 = (upper_h1 << 8);
++		temp1 >>= (n + 1);
++		temp1 -= (rsz >> 1);
++		temp1 /= (rsz << 1);
++		temp1 <<= 1;
++		temp1 += 2;
++		h1 = temp1;
++	}
++	o = 10 + (two_power << 2);
++	if (((input_width << 7) / rsz) % 2)
++		o += (((CEIL(rsz, 1024)) << 1) << n);
++	h2 = output_width - h1;
++	/* phi */
++	temp = (h1 * rsz) - (((upper_h1 - (o - 10)) / two_power) << 8);
++	/* skip */
++	temp1 = ((temp - 1024) >> 9) << 1;
++	param->f_div.num_passes = IPIPE_MAX_PASSES;
++	param->f_div.pass[0].o_hsz = h1 - 1;
++	param->f_div.pass[0].i_hps = 0;
++	param->f_div.pass[0].h_phs = 0;
++	param->f_div.pass[0].src_hps = 0;
++	param->f_div.pass[0].src_hsz = upper_h1 + o;
++	param->f_div.pass[1].o_hsz = h2 - 1;
++	param->f_div.pass[1].i_hps = 10 + (temp1 * two_power);
++	param->f_div.pass[1].h_phs = (temp - (temp1 << 8));
++	param->f_div.pass[1].src_hps = (upper_h1 - o);
++	param->f_div.pass[1].src_hsz = (upper_h2 + o);
++	return 0;
++}
++
++/* update the parameter in param for a given input and output width */
++static int update_preview_f_div_params(struct device *dev,
++				       int input_width,
++				       int output_width,
++				       struct ipipe_rsz_rescale_param *param)
++{
++	unsigned int temp;
++
++	temp = input_width >> 1;
++	if (temp < 8) {
++		dev_err(dev, "input width must me atleast 16 pixels\n");
++		return -1;
++	}
++	param->f_div.en = 1;
++	param->f_div.num_passes = IPIPE_MAX_PASSES;
++	param->f_div.pass[0].o_hsz = temp;
++	param->f_div.pass[0].i_hps = 0;
++	param->f_div.pass[0].h_phs = 0;
++	param->f_div.pass[0].src_hps = 0;
++	param->f_div.pass[0].src_hsz = temp + 10;
++	param->f_div.pass[1].o_hsz = temp;
++	param->f_div.pass[1].i_hps = 0;
++	param->f_div.pass[1].h_phs = 0;
++	param->f_div.pass[1].src_hps = temp - 8;
++	param->f_div.pass[1].src_hsz = temp + 10;
++	return 0;
++}
++
++/* Use shared to allocate exclusive blocks as required
++ * by resize applications in single shot mode
++ */
++static void *ipipe_alloc_config_block(struct device *dev, int shared)
++{
++
++	struct ipipe_params *config_block;
++	if (shared) {
++		/* return common data block */
++		mutex_lock(&oper_state.lock);
++		if (oper_state.resource_in_use) {
++			dev_err(dev, "Shared resource in use\n");
++			mutex_unlock(&oper_state.lock);
++			return NULL;
++		}
++		mutex_unlock(&oper_state.lock);
++		return oper_state.shared_config_param;
++	} else {
++		config_block = kmalloc(sizeof(struct ipipe_params), GFP_KERNEL);
++		if (ISNULL(config_block)) {
++			dev_err(dev,
++				"imp_alloc_config_block: failed"
++				" to allocate memory\n");
++		}
++	}
++	return config_block;
++}
++
++/* Used to free only non-shared config block allocated through
++ * imp_alloc_config_block
++ */
++static void ipipe_dealloc_config_block(struct device *dev, void *config_block)
++{
++	if (config_block) {
++		if (config_block != oper_state.shared_config_param)
++			kfree(config_block);
++		else
++			dev_err(dev, "Trying to free shared config block\n");
++	}
++}
++
++static void ipipe_dealloc_user_config_block(struct device *dev,
++					    void *config_block)
++{
++	kfree(config_block);
++}
++
++static void *ipipe_alloc_user_config_block(struct device *dev,
++					   enum imp_log_chan_t chan_type,
++					   unsigned int oper_mode, int *len)
++{
++	void *config = NULL;
++	if (oper_mode == IMP_MODE_SINGLE_SHOT) {
++		if (chan_type == IMP_PREVIEWER) {
++			config =
++			    kmalloc(sizeof(struct prev_single_shot_config),
++				    GFP_KERNEL);
++			*len = sizeof(struct prev_single_shot_config);
++		} else if (chan_type == IMP_RESIZER) {
++			config =
++			    kmalloc(sizeof(struct rsz_single_shot_config),
++				    GFP_KERNEL);
++			*len = sizeof(struct rsz_single_shot_config);
++		}
++
++	} else {
++		if (chan_type == IMP_PREVIEWER) {
++			config =
++			    kmalloc(sizeof(struct prev_continuous_config),
++				    GFP_KERNEL);
++			*len = sizeof(struct prev_continuous_config);
++		} else if (chan_type == IMP_RESIZER) {
++			config =
++			    kmalloc(sizeof(struct rsz_continuous_config),
++				    GFP_KERNEL);
++			*len = sizeof(struct rsz_continuous_config);
++		}
++	}
++	return config;
++}
++
++static void ipipe_set_user_config_defaults(struct device *dev,
++					   enum imp_log_chan_t chan_type,
++					   unsigned int oper_mode, void *config)
++{
++	dev_dbg(dev, "ipipe_set_user_config_defaults\n");
++	if (oper_mode == IMP_MODE_SINGLE_SHOT) {
++		if (chan_type == IMP_PREVIEWER) {
++			dev_dbg(dev, "SS-Preview\n");
++			/* preview channel in single shot mode */
++			memcpy(config,
++			       (void *)&dm365_prev_ss_config_defs,
++			       sizeof(struct prev_single_shot_config));
++		} else {
++			dev_dbg(dev, "SS-Resize\n");
++			/* resizer channel in single shot mode */
++			memcpy(config,
++			       (void *)&dm365_rsz_ss_config_defs,
++			       sizeof(struct rsz_single_shot_config));
++		}
++	} else if (oper_mode == IMP_MODE_CONTINUOUS) {
++		/* Continuous mode */
++		if (chan_type == IMP_PREVIEWER) {
++			dev_dbg(dev, "Cont Preview\n");
++			/* previewer defaults */
++			memcpy(config,
++			       (void *)&dm365_prev_cont_config_defs,
++			       sizeof(struct prev_continuous_config));
++		} else {
++			dev_dbg(dev, "Cont resize\n");
++			/* resizer defaults */
++			memcpy(config,
++			       (void *)&dm365_rsz_cont_config_defs,
++			       sizeof(struct rsz_continuous_config));
++		}
++	} else
++		dev_err(dev, "Incorrect mode used\n");
++}
++
++/* function :calculate_sdram_offsets()
++ *	This function calculates the offsets from start of buffer for the C
++ *	plane when output format is YUV420SP. It also calculates the offsets
++ *	from the start of the buffer when the image is flipped vertically
++ *	or horizontally for ycbcr/y/c planes
++ */
++static int calculate_sdram_offsets(struct ipipe_params *param, int index)
++{
++	int image_height, image_width, offset = 0, yuv_420 = 0,
++	    bytesperline = 2;
++
++	if (!param->rsz_en[index])
++		return -1;
++
++	image_height = param->rsz_rsc_param[index].o_vsz + 1;
++	image_width = param->rsz_rsc_param[index].o_hsz + 1;
++	param->ext_mem_param[index].c_offset = 0;
++	param->ext_mem_param[index].flip_ofst_y = 0;
++	param->ext_mem_param[index].flip_ofst_c = 0;
++	if ((param->ipipe_dpaths_fmt != IPIPE_RAW2RAW) &&
++	    (param->ipipe_dpaths_fmt != IPIPE_RAW2BOX)) {
++		if ((param->rsz_rsc_param[index].cen) &&
++		    (param->rsz_rsc_param[index].yen)) {
++			/* YUV 420 */
++			yuv_420 = 1;
++			bytesperline = 1;
++		}
++	}
++	if (param->rsz_rsc_param[index].h_flip)
++		/* width * bytesperline - 1 */
++		offset = (image_width * bytesperline) - 1;
++	if (param->rsz_rsc_param[index].v_flip)
++		offset += ((image_height - 1) *
++			   param->ext_mem_param[index].
++			   rsz_sdr_oft_y);
++	param->ext_mem_param[index].flip_ofst_y = offset;
++	if (yuv_420) {
++		offset = 0;
++		/* half height for c-plane */
++		if (param->rsz_rsc_param[index].h_flip)
++			/* width * bytesperline - 1 */
++			offset = image_width - 1;
++			if (param->rsz_rsc_param[index].v_flip)
++				offset +=
++				    (((image_height >> 1) - 1) *
++				     param->ext_mem_param[index].
++				     rsz_sdr_oft_c);
++			param->ext_mem_param[index].flip_ofst_c =
++				    offset;
++			param->ext_mem_param[index].c_offset =
++			    param->ext_mem_param[index].
++			    rsz_sdr_oft_y * image_height;
++	}
++	return 0;
++}
++
++static void enable_422_420_conversion(struct ipipe_params *param,
++				      int index, enum enable_disable_t en)
++{
++	/* Enable 422 to 420 conversion */
++	param->rsz_rsc_param[index].cen = en;
++	param->rsz_rsc_param[index].yen = en;
++}
++
++static int configure_resizer_out_params(struct ipipe_params *param,
++					int index,
++					void *output_spec,
++					unsigned char partial, unsigned flag)
++{
++	if (partial) {
++		struct rsz_part_output_spec *partial_output =
++		    (struct rsz_part_output_spec *)output_spec;
++		if (partial_output->enable) {
++			param->rsz_en[index] = ENABLE;
++			param->rsz_rsc_param[index].h_flip =
++			    partial_output->h_flip;
++			param->rsz_rsc_param[index].v_flip =
++			    partial_output->v_flip;
++			param->rsz_rsc_param[index].v_typ_y =
++			    partial_output->v_typ_y;
++			param->rsz_rsc_param[index].v_typ_c =
++			    partial_output->v_typ_c;
++			param->rsz_rsc_param[index].v_lpf_int_y =
++			    partial_output->v_lpf_int_y;
++			param->rsz_rsc_param[index].v_lpf_int_c =
++			    partial_output->v_lpf_int_c;
++			param->rsz_rsc_param[index].h_typ_y =
++			    partial_output->h_typ_y;
++			param->rsz_rsc_param[index].h_typ_c =
++			    partial_output->h_typ_c;
++			param->rsz_rsc_param[index].h_lpf_int_y =
++			    partial_output->h_lpf_int_y;
++			param->rsz_rsc_param[index].h_lpf_int_c =
++			    partial_output->h_lpf_int_c;
++			param->rsz_rsc_param[index].dscale_en =
++			    partial_output->en_down_scale;
++			param->rsz_rsc_param[index].h_dscale_ave_sz =
++			    partial_output->h_dscale_ave_sz;
++			param->rsz_rsc_param[index].v_dscale_ave_sz =
++			    partial_output->v_dscale_ave_sz;
++			param->ext_mem_param[index].user_y_ofst =
++			    (partial_output->user_y_ofst + 31) & ~0x1F;
++			param->ext_mem_param[index].user_c_ofst =
++			    (partial_output->user_c_ofst + 31) & ~0x1F;
++
++		} else
++			param->rsz_en[index] = DISABLE;
++
++	} else {
++		struct rsz_output_spec *output =
++		    (struct rsz_output_spec *)output_spec;
++		if (output->enable) {
++			param->rsz_en[index] = ENABLE;
++			param->rsz_rsc_param[index].o_vsz = output->height - 1;
++			param->rsz_rsc_param[index].o_hsz = output->width - 1;
++			param->ext_mem_param[index].rsz_sdr_ptr_s_y =
++			    output->vst_y;
++			param->ext_mem_param[index].rsz_sdr_ptr_e_y =
++			    output->height;
++			param->ext_mem_param[index].rsz_sdr_ptr_s_c =
++			    output->vst_c;
++			param->ext_mem_param[index].rsz_sdr_ptr_e_c =
++			    output->height;
++
++			if (flag) {
++				/* update common parameters */
++				param->rsz_rsc_param[index].h_flip =
++				    output->h_flip;
++				param->rsz_rsc_param[index].v_flip =
++				    output->v_flip;
++				param->rsz_rsc_param[index].v_typ_y =
++				    output->v_typ_y;
++				param->rsz_rsc_param[index].v_typ_c =
++				    output->v_typ_c;
++				param->rsz_rsc_param[index].v_lpf_int_y =
++				    output->v_lpf_int_y;
++				param->rsz_rsc_param[index].v_lpf_int_c =
++				    output->v_lpf_int_c;
++				param->rsz_rsc_param[index].h_typ_y =
++				    output->h_typ_y;
++				param->rsz_rsc_param[index].h_typ_c =
++				    output->h_typ_c;
++				param->rsz_rsc_param[index].h_lpf_int_y =
++				    output->h_lpf_int_y;
++				param->rsz_rsc_param[index].h_lpf_int_c =
++				    output->h_lpf_int_c;
++				param->rsz_rsc_param[index].dscale_en =
++				    output->en_down_scale;
++				param->rsz_rsc_param[index].h_dscale_ave_sz =
++				    output->h_dscale_ave_sz;
++				param->rsz_rsc_param[index].v_dscale_ave_sz =
++				    output->h_dscale_ave_sz;
++				param->ext_mem_param[index].user_y_ofst =
++				    (output->user_y_ofst + 31) & ~0x1F;
++				param->ext_mem_param[index].user_c_ofst =
++				    (output->user_c_ofst + 31) & ~0x1F;
++			}
++		} else
++			param->rsz_en[index] = DISABLE;
++	}
++	return 0;
++}
++
++/* function :calculate_line_length()
++ *	This function calculates the line length of various image
++ *	planes at the input and output
++ */
++static int calculate_line_length(enum ipipe_pix_formats pix,
++				 int width,
++				 int height, int *line_len, int *line_len_c)
++{
++
++	*line_len = 0;
++	*line_len_c = 0;
++
++	if ((pix == IPIPE_UYVY) || (pix == IPIPE_BAYER))
++		*line_len = width << 1;
++	else if (pix == IPIPE_420SP_Y || pix == IPIPE_420SP_C) {
++		*line_len = width;
++		*line_len_c = width;
++	}
++	else {
++		/* YUV 420 */
++		/* round width to upper 32 byte boundary */
++		*line_len = width;
++		*line_len_c = width;
++	}
++	/* adjust the line len to be a multiple of 32 */
++	*line_len += 31;
++	*line_len &= ~0x1f;
++	*line_len_c += 31;
++	*line_len_c &= ~0x1f;
++	return 0;
++}
++
++static inline int rsz_validate_input_image_format(struct device *dev,
++						  enum ipipe_pix_formats pix,
++						  int width,
++						  int height, int *line_len)
++{
++	int temp;
++	if (pix != IPIPE_UYVY && pix != IPIPE_420SP_Y && pix != IPIPE_420SP_C) {
++		dev_err(dev,
++			"rsz_validate_out_pix_formats"
++			"pix format not supported, %d\n", pix);
++		return -EINVAL;
++	}
++
++	if (width == 0 || height == 0) {
++		dev_err(dev, "validate_line_length: invalid width or height\n");
++		return -EINVAL;
++	}
++
++	if (pix == IPIPE_420SP_C)
++		return calculate_line_length(pix,
++					      width,
++					      height,
++					      &temp,
++					      line_len);
++	else
++		return calculate_line_length(pix,
++					      width,
++					      height,
++					      line_len,
++					      &temp);
++}
++
++static inline int rsz_validate_output_image_format(struct device *dev,
++						   enum ipipe_pix_formats pix,
++						   int width,
++						   int height,
++						   int *in_line_len,
++						   int *in_line_len_c)
++{
++	if (pix != IPIPE_UYVY
++	    && pix != IPIPE_420SP_Y
++	    && pix != IPIPE_420SP_C
++	    && pix != IPIPE_YUV420SP && pix != IPIPE_BAYER) {
++		dev_err(dev,
++			"rsz_validate_out_pix_formats"
++			"pix format not supported, %d\n", pix);
++		return -EINVAL;
++	}
++
++	if (width == 0 || height == 0) {
++		dev_err(dev, "validate_line_length: invalid width or height\n");
++		return -EINVAL;
++	}
++
++	return calculate_line_length(pix,
++				      width,
++				      height, in_line_len, in_line_len_c);
++}
++
++static int configure_common_rsz_params(struct device *dev,
++				       struct ipipe_params *param,
++				       struct rsz_single_shot_config *ss_config)
++{
++	param->rsz_common.yuv_y_min = ss_config->yuv_y_min;
++	param->rsz_common.yuv_y_max = ss_config->yuv_y_max;
++	param->rsz_common.yuv_c_min = ss_config->yuv_c_min;
++	param->rsz_common.yuv_c_max = ss_config->yuv_c_max;
++	param->rsz_common.out_chr_pos = ss_config->out_chr_pos;
++	param->rsz_common.rsz_seq_crv = ss_config->chroma_sample_even;
++	return 0;
++}
++
++static int configure_common_rsz_in_params(struct device *dev,
++					  struct ipipe_params *param,
++					  int flag, int rsz_chained,
++					  void *input_spec)
++{
++	enum ipipe_pix_formats pix;
++	if (!flag) {
++		struct prev_ss_input_spec *in_specs =
++		    (struct prev_ss_input_spec *)input_spec;
++		param->rsz_common.vsz = in_specs->image_height - 1;
++		param->rsz_common.hsz = in_specs->image_width - 1;
++		pix = in_specs->pix_fmt;
++	} else {
++		struct rsz_ss_input_spec *in_specs =
++		    (struct rsz_ss_input_spec *)input_spec;
++		if (!rsz_chained) {
++			param->rsz_common.vps = in_specs->vst;
++			param->rsz_common.hps = in_specs->hst;
++		}
++		param->rsz_common.vsz = in_specs->image_height - 1;
++		param->rsz_common.hsz = in_specs->image_width - 1;
++		pix = in_specs->pix_fmt;
++	}
++	switch (pix) {
++	case IPIPE_BAYER_8BIT_PACK:
++	case IPIPE_BAYER_8BIT_PACK_ALAW:
++	case IPIPE_BAYER_8BIT_PACK_DPCM:
++	case IPIPE_BAYER_12BIT_PACK:
++	case IPIPE_BAYER:
++		{
++			param->rsz_common.src_img_fmt = RSZ_IMG_422;
++			param->rsz_common.source = IPIPE_DATA;
++			break;
++		}
++	case IPIPE_UYVY:
++		{
++			param->rsz_common.src_img_fmt = RSZ_IMG_422;
++			if (rsz_chained)
++				param->rsz_common.source = IPIPE_DATA;
++			else
++				param->rsz_common.source = IPIPEIF_DATA;
++			param->rsz_common.raw_flip = 0;
++			break;
++		}
++	case IPIPE_420SP_Y:
++		{
++			param->rsz_common.src_img_fmt = RSZ_IMG_420;
++			/* Select y */
++			param->rsz_common.y_c = 0;
++			param->rsz_common.source = IPIPEIF_DATA;
++			param->rsz_common.raw_flip = 0;
++			break;
++		}
++	case IPIPE_420SP_C:
++		{
++			param->rsz_common.src_img_fmt = RSZ_IMG_420;
++			/* Select y */
++			param->rsz_common.y_c = 1;
++			param->rsz_common.source = IPIPEIF_DATA;
++			param->rsz_common.raw_flip = 0;
++			break;
++		}
++	default:
++		return -1;
++	}
++	return 0;
++}
++
++static int validate_ipipeif_decimation(struct device *dev,
++				       enum ipipeif_decimation dec_en,
++				       unsigned char rsz,
++				       unsigned char frame_div_mode_en,
++				       int width)
++{
++	if (dec_en && frame_div_mode_en) {
++		dev_err(dev,
++			"Both dec_en & frame_div_mode_en"
++			"can not enabled simultaneously\n");
++		return -EINVAL;
++	}
++	if (frame_div_mode_en) {
++		dev_err(dev, "frame_div_mode mode not supported");
++		return -EINVAL;
++	}
++	if (dec_en) {
++		if (width <= IPIPE_MAX_INPUT_WIDTH) {
++			dev_err(dev,
++				"image width to be more than"
++				" %d for decimation\n", IPIPE_MAX_INPUT_WIDTH);
++			return -EINVAL;
++		}
++		if ((rsz < IPIPEIF_RSZ_MIN) || (rsz > IPIPEIF_RSZ_MAX)) {
++			dev_err(dev, "rsz range is %d to %d\n",
++				IPIPEIF_RSZ_MIN, IPIPEIF_RSZ_MAX);
++			return -EINVAL;
++		}
++	}
++	return 0;
++}
++
++static int configure_resizer_in_ss_mode(struct device *dev,
++					void *user_config,
++					int resizer_chained,
++					struct ipipe_params *param)
++{
++	/* resizer in standalone mode. In this mode if serializer
++	 * is enabled, we need to set config params in the hw.
++	 */
++	struct rsz_single_shot_config *ss_config =
++	    (struct rsz_single_shot_config *)user_config;
++	int ret = 0, line_len, line_len_c;
++
++	ret = rsz_validate_input_image_format(dev,
++					      ss_config->input.pix_fmt,
++					      ss_config->input.image_width,
++					      ss_config->input.image_height,
++					      &line_len);
++
++	if (ret)
++		return -EINVAL;
++
++	/* shared block */
++	if ((!ss_config->output1.enable) && (!ss_config->output2.enable)) {
++		dev_err(dev, "One of the resizer output must be enabled\n");
++		return -EINVAL;
++	}
++	ret = mutex_lock_interruptible(&oper_state.lock);
++	if (ret)
++		return ret;
++	if (!ss_config->input.line_length)
++		param->ipipeif_param.adofs = line_len;
++	else {
++		param->ipipeif_param.adofs = ss_config->input.line_length;
++		param->ipipeif_param.adofs =
++				(param->ipipeif_param.adofs + 31) & ~0x1f;
++	}
++	if (ss_config->output1.enable) {
++		param->rsz_en[RSZ_A] = ENABLE;
++		param->rsz_rsc_param[RSZ_A].mode = ONE_SHOT;
++		ret = rsz_validate_output_image_format(dev,
++						       ss_config->output1.
++						       pix_fmt,
++						       ss_config->output1.width,
++						       ss_config->output1.
++						       height,
++						       &line_len,
++						       &line_len_c);
++		if (ret) {
++			mutex_unlock(&oper_state.lock);
++			return ret;
++		}
++		param->ext_mem_param[RSZ_A].rsz_sdr_oft_y = line_len;
++		param->ext_mem_param[RSZ_A].rsz_sdr_oft_c = line_len_c;
++		ret = configure_resizer_out_params(param,
++						   RSZ_A,
++						   &ss_config->output1,
++						   0,
++						   1);
++
++		if (ss_config->output1.pix_fmt == IMP_BAYER)
++			param->rsz_common.raw_flip = 1;
++		else
++			param->rsz_common.raw_flip = 0;
++
++		if (ss_config->output1.pix_fmt == IPIPE_YUV420SP)
++			enable_422_420_conversion(param, RSZ_A, ENABLE);
++		else
++			enable_422_420_conversion(param, RSZ_A,
++							  DISABLE);
++		if (ret) {
++			mutex_unlock(&oper_state.lock);
++			dev_err(dev, "error configuring resizer output1\n");
++			return ret;
++		}
++	}
++
++	if (ss_config->output2.enable) {
++		param->rsz_en[RSZ_A] = ENABLE;
++		param->rsz_rsc_param[RSZ_B].mode = ONE_SHOT;
++		ret = rsz_validate_output_image_format(dev,
++						       ss_config->output2.
++						       pix_fmt,
++						       ss_config->output2.width,
++						       ss_config->output2.
++						       height,
++						       &line_len,
++						       &line_len_c);
++		if (ret) {
++			mutex_unlock(&oper_state.lock);
++			return ret;
++		}
++		param->ext_mem_param[RSZ_B].rsz_sdr_oft_y = line_len;
++		param->ext_mem_param[RSZ_B].rsz_sdr_oft_c = line_len_c;
++		ret = configure_resizer_out_params(param,
++						   RSZ_B,
++						   &ss_config->output2,
++						   0,
++						   1);
++		if (ret) {
++			dev_err(dev,
++				"error configuring resizer output2 params\n");
++			mutex_unlock(&oper_state.lock);
++			return ret;
++		}
++		if (ss_config->output2.pix_fmt == IPIPE_YUV420SP)
++			enable_422_420_conversion(param, RSZ_B, ENABLE);
++		else
++			enable_422_420_conversion(param,
++						  RSZ_B,
++						  DISABLE);
++	}
++	configure_common_rsz_params(dev, param, ss_config);
++	if (resizer_chained) {
++		oper_state.rsz_chained = 1;
++		oper_state.rsz_config_state = STATE_CONFIGURED;
++	} else {
++		oper_state.rsz_chained = 0;
++		ret = validate_ipipeif_decimation(dev,
++						  ss_config->input.dec_en,
++						  ss_config->input.rsz,
++						  ss_config->input.
++						  frame_div_mode_en,
++						  ss_config->input.image_width);
++		if (ret) {
++			mutex_unlock(&oper_state.lock);
++			return ret;
++		}
++
++		if (ipipe_process_pix_fmts(ss_config->input.pix_fmt,
++				   ss_config->output1.pix_fmt,
++				   param) < 0) {
++			dev_err(dev, "error in input or output pix format\n");
++			mutex_unlock(&oper_state.lock);
++			return -EINVAL;
++		}
++
++		param->ipipeif_param.source = SDRAM_YUV;
++		param->ipipeif_param.glob_hor_size = ss_config->input.ppln;
++		param->ipipeif_param.glob_ver_size = ss_config->input.lpfr;
++		param->ipipeif_param.hnum = ss_config->input.image_width;
++		param->ipipeif_param.vnum = ss_config->input.image_height;
++		param->ipipeif_param.var.if_5_1.clk_div =
++		    ss_config->input.clk_div;
++		if (ss_config->input.dec_en) {
++			param->ipipeif_param.decimation = IPIPEIF_DECIMATION_ON;
++			param->ipipeif_param.rsz = ss_config->input.rsz;
++			param->ipipeif_param.avg_filter =
++			    (enum ipipeif_avg_filter)ss_config->input.
++			    avg_filter_en;
++			param->ipipe_hsz =
++			    (((ss_config->input.image_width *
++			       IPIPEIF_RSZ_CONST) / ss_config->input.rsz) - 1);
++		}
++		if (ss_config->input.pix_fmt == IPIPE_420SP_Y
++			|| ss_config->input.pix_fmt == IPIPE_420SP_C)
++		{
++			param->ipipeif_param.var.if_5_1.pack_mode
++				= IPIPEIF_5_1_PACK_8_BIT;
++			param->ipipeif_param.var.if_5_1.source1 = CCDC;
++			param->ipipeif_param.var.if_5_1.isif_port.if_type
++				= VPFE_YCBCR_SYNC_16;
++			param->ipipeif_param.var.if_5_1.data_shift
++				= IPIPEIF_5_1_BITS11_0;
++
++			param->ipipeif_param.source = SDRAM_RAW;
++
++
++		}
++		if (ss_config->input.pix_fmt == IPIPE_420SP_C)
++			param->ipipeif_param.var.if_5_1.isif_port.if_type
++				= VPFE_RAW_BAYER;
++		param->ipipe_hsz = ss_config->input.image_width - 1;
++		param->ipipe_vsz = ss_config->input.image_height - 1;
++		param->ipipe_vps = ss_config->input.vst;
++		param->ipipe_hps = ss_config->input.hst;
++		param->ipipe_dpaths_fmt = IPIPE_YUV2YUV;
++		configure_common_rsz_in_params(dev, param, 1, resizer_chained,
++					       &ss_config->input);
++		if (param->rsz_en[RSZ_A]) {
++
++			calculate_resize_ratios(param, RSZ_A);
++			calculate_sdram_offsets(param, RSZ_A);
++
++			/* Overriding resize ratio calculation */
++			if (ss_config->input.pix_fmt == IPIPE_420SP_C)
++			{
++				param->rsz_rsc_param[RSZ_A].v_dif =
++				    (((param->ipipe_vsz + 1) * 2) * 256) /
++				    (param->rsz_rsc_param[RSZ_A].o_vsz + 1);
++			}
++		}
++
++		if (param->rsz_en[RSZ_B]) {
++			calculate_resize_ratios(param, RSZ_B);
++			calculate_sdram_offsets(param, RSZ_B);
++
++			/* Overriding resize ratio calculation */
++			if (ss_config->input.pix_fmt == IPIPE_420SP_C)
++			{
++				param->rsz_rsc_param[RSZ_B].v_dif =
++				    (((param->ipipe_vsz + 1) * 2) * 256) /
++				    (param->rsz_rsc_param[RSZ_B].o_vsz + 1);
++			}
++		}
++	}
++	mutex_unlock(&oper_state.lock);
++	return 0;
++}
++
++static int configure_resizer_in_cont_mode(struct device *dev,
++					  void *user_config,
++					  int resizer_chained,
++					  struct ipipe_params *param)
++{
++	/* Continuous mode. This is a shared config block */
++	struct rsz_continuous_config *cont_config =
++	    (struct rsz_continuous_config *)user_config;
++	int line_len, line_len_c, ret;
++
++	if (resizer_chained) {
++		ret = mutex_lock_interruptible(&oper_state.lock);
++		if (ret)
++			return ret;
++		if (!cont_config->output1.enable) {
++			dev_err(dev, "enable resizer - 0\n");
++			mutex_unlock(&oper_state.lock);
++			return -EINVAL;
++		}
++		param->rsz_en[RSZ_A] = ENABLE;
++		param->rsz_rsc_param[RSZ_A].mode = CONTINUOUS;
++		ret = configure_resizer_out_params(param,
++						   RSZ_A,
++						   &cont_config->output1,
++						   1,
++						   0);
++		if (ret) {
++			dev_err(dev, "error configuring resizer output1\n");
++			mutex_unlock(&oper_state.lock);
++			return -EINVAL;
++		}
++		param->rsz_en[RSZ_B] = DISABLE;
++
++		if (cont_config->output2.enable) {
++			param->rsz_rsc_param[RSZ_B].mode = CONTINUOUS;
++			ret = rsz_validate_output_image_format(dev,
++						       cont_config->output2.
++						       pix_fmt,
++						       cont_config->output2.
++						       width,
++						       cont_config->output2.
++						       height,
++						       &line_len,
++						       &line_len_c);
++			if (ret) {
++				mutex_unlock(&oper_state.lock);
++				return ret;
++			}
++			param->ext_mem_param[RSZ_B].rsz_sdr_oft_y = line_len;
++			param->ext_mem_param[RSZ_B].rsz_sdr_oft_c = line_len_c;
++			ret = configure_resizer_out_params(param,
++						   RSZ_B,
++						   &cont_config->output2,
++						   0,
++						   1);
++			if (cont_config->output2.pix_fmt == IPIPE_YUV420SP)
++				enable_422_420_conversion(param,
++						RSZ_B, ENABLE);
++			else
++				enable_422_420_conversion(param,
++						RSZ_B, DISABLE);
++
++			if (ret) {
++				dev_err(dev, "error configuring resizer"
++					" output2\n");
++				mutex_unlock(&oper_state.lock);
++				return -EINVAL;
++			}
++		}
++		oper_state.rsz_chained = 1;
++		oper_state.rsz_config_state = STATE_CONFIGURED;
++		mutex_unlock(&oper_state.lock);
++	} else {
++		dev_err(dev, "Resizer cannot be configured in standalone"
++			"for continuous mode\n");
++		return -EINVAL;
++	}
++	return 0;
++}
++static int ipipe_set_resize_config(struct device *dev,
++				   unsigned int oper_mode,
++				   int resizer_chained,
++				   void *user_config, void *config)
++{
++	int ret = 0;
++	struct ipipe_params *param = (struct ipipe_params *)config;
++
++	dev_dbg(dev, "ipipe_set_resize_config, resizer_chained = %d\n",
++		resizer_chained);
++	if ((ISNULL(user_config)) || (ISNULL(config))) {
++		dev_err(dev, "Invalid user_config or config ptr\n");
++		return -EINVAL;
++	}
++
++	memcpy((void *)config,
++	       (void *)&dm365_ipipe_defs,
++	       sizeof(struct ipipe_params));
++
++	if (oper_mode == IMP_MODE_SINGLE_SHOT) {
++		ret = configure_resizer_in_ss_mode(dev,
++						   user_config,
++						   resizer_chained,
++						   param);
++		if (!ret && (!en_serializer && !resizer_chained))
++			ret = ipipe_hw_setup(config);
++	} else
++		ret = configure_resizer_in_cont_mode(dev,
++						     user_config,
++						     resizer_chained,
++						     param);
++	return ret;
++}
++
++static void configure_resize_passthru(struct ipipe_params *param, int bypass)
++{
++	param->rsz_rsc_param[RSZ_A].cen = DISABLE;
++	param->rsz_rsc_param[RSZ_A].yen = DISABLE;
++	param->rsz_rsc_param[RSZ_A].v_phs_y = 0;
++	param->rsz_rsc_param[RSZ_A].v_phs_c = 0;
++	param->rsz_rsc_param[RSZ_A].v_dif = 256;
++	param->rsz_rsc_param[RSZ_A].v_lpf_int_y = 0;
++	param->rsz_rsc_param[RSZ_A].v_lpf_int_c = 0;
++	param->rsz_rsc_param[RSZ_A].h_phs = 0;
++	param->rsz_rsc_param[RSZ_A].h_dif = 256;
++	param->rsz_rsc_param[RSZ_A].h_lpf_int_y = 0;
++	param->rsz_rsc_param[RSZ_A].h_lpf_int_c = 0;
++	param->rsz_rsc_param[RSZ_A].dscale_en = DISABLE;
++	param->rsz2rgb[RSZ_A].rgb_en = DISABLE;
++	param->rsz_en[RSZ_A] = ENABLE;
++	param->rsz_en[RSZ_B] = DISABLE;
++	if (bypass) {
++		param->rsz_rsc_param[RSZ_A].i_vps = 0;
++		param->rsz_rsc_param[RSZ_A].i_hps = 0;
++		/* Raw Bypass */
++		param->rsz_common.passthrough = IPIPE_BYPASS_ON;
++	}
++}
++
++static inline int prev_validate_output_image_format(struct device *dev,
++						    enum ipipe_pix_formats pix,
++						    int *line_len,
++						    int in_width, int in_height)
++{
++	if (pix != IPIPE_UYVY && pix != IPIPE_BAYER) {
++		dev_err(dev,
++			"prev_validate_output_image_format"
++			"pix format not supported, %d\n", pix);
++		return -EINVAL;
++	}
++
++	if ((in_width == 0) || (in_height == 0)) {
++		dev_err(dev,
++			"prev_validate_output_image_format:"
++			" invalid width or height\n");
++		return -EINVAL;
++	}
++
++	*line_len = in_width * 2;
++
++	/* Adjust line length to be a multiple of 32 */
++	*line_len += 31;
++	*line_len &= ~0x1f;
++	return 0;
++}
++
++static inline int validate_preview_input_spec(struct device *dev,
++					      enum ipipe_pix_formats pix,
++					      int width,
++					      int height, int *line_len)
++{
++	if (pix != IPIPE_UYVY
++	    && pix != IPIPE_BAYER
++	    && pix != IPIPE_BAYER_8BIT_PACK
++	    && pix != IPIPE_BAYER_8BIT_PACK_ALAW
++	    && pix != IPIPE_BAYER_8BIT_PACK_DPCM
++	    && pix != IPIPE_BAYER_12BIT_PACK) {
++		dev_err(dev,
++			"validate_preview_input_spec:"
++			"pix format not supported, %d\n", pix);
++		return -EINVAL;
++	}
++	if (width == 0 || height == 0) {
++		dev_err(dev,
++			"rsz_validate_out_image_formats: "
++			"invalid width or height\n");
++		return -EINVAL;
++	}
++
++	if (pix == IPIPE_UYVY || pix == IPIPE_BAYER)
++		*line_len = width * 2;
++	else if (pix == IPIPE_BAYER_8BIT_PACK ||
++		 pix == IPIPE_BAYER_8BIT_PACK_ALAW ||
++		 pix == IPIPE_BAYER_8BIT_PACK_DPCM)
++		*line_len = width;
++	else
++		/* 12 bit */
++		*line_len = width + (width >> 1);
++	/* Adjust line length to be a multiple of 32 */
++	*line_len += 31;
++	*line_len &= ~0x1f;
++	return 0;
++}
++
++static int configure_previewer_in_cont_mode(struct device *dev,
++					    void *user_config,
++					    struct ipipe_params *param)
++{
++	int ret;
++	struct prev_continuous_config *cont_config =
++	    (struct prev_continuous_config *)user_config;
++
++	if (cont_config->input.en_df_sub) {
++		dev_err(dev, "DF subtraction is not supported\n");
++		return -EINVAL;
++	}
++	if (cont_config->input.dec_en) {
++		if ((cont_config->input.rsz < IPIPEIF_RSZ_MIN)
++		    || (cont_config->input.rsz > IPIPEIF_RSZ_MAX)) {
++			dev_err(dev, "rsz range is %d to %d\n",
++				IPIPEIF_RSZ_MIN, IPIPEIF_RSZ_MAX);
++			return -EINVAL;
++		}
++	}
++	ret = mutex_lock_interruptible(&oper_state.lock);
++	if (ret)
++		return ret;
++	param->rsz_common.passthrough = cont_config->bypass;
++	param->ipipeif_param.source = CCDC;
++	param->ipipeif_param.clock_select = PIXCEL_CLK;
++	param->ipipeif_param.mode = CONTINUOUS;
++	if (cont_config->input.dec_en) {
++		param->ipipeif_param.decimation = IPIPEIF_DECIMATION_ON;
++		param->ipipeif_param.rsz = cont_config->input.rsz;
++		param->ipipeif_param.avg_filter =
++		    (enum ipipeif_avg_filter)cont_config->input.avg_filter_en;
++	}
++	/* IPIPE mode */
++	param->ipipe_mode = CONTINUOUS;
++	param->ipipe_colpat_olop = cont_config->input.colp_olop;
++	param->ipipe_colpat_olep = cont_config->input.colp_olep;
++	param->ipipe_colpat_elop = cont_config->input.colp_elop;
++	param->ipipe_colpat_elep = cont_config->input.colp_elep;
++	param->ipipeif_param.gain = cont_config->input.gain;
++	param->ipipeif_param.var.if_5_1.clip = cont_config->input.clip;
++	param->ipipeif_param.var.if_5_1.dpc = cont_config->input.dpc;
++	param->ipipeif_param.var.if_5_1.align_sync =
++	    cont_config->input.align_sync;
++	param->ipipeif_param.var.if_5_1.rsz_start =
++	    cont_config->input.rsz_start;
++	if (!oper_state.rsz_chained) {
++		param->rsz_rsc_param[0].mode = CONTINUOUS;
++		/* setup bypass resizer */
++		configure_resize_passthru(param, 0);
++	}
++	if (cont_config->bypass)
++		configure_resize_passthru(param, 1);
++	oper_state.prev_config_state = STATE_CONFIGURED;
++	mutex_unlock(&oper_state.lock);
++	return 0;
++}
++
++static int configure_previewer_in_ss_mode(struct device *dev,
++					  void *user_config,
++					  struct ipipe_params *param)
++{
++	int ret = 0;
++	int line_len;
++	struct prev_single_shot_config *ss_config =
++	    (struct prev_single_shot_config *)user_config;
++
++	ret = validate_preview_input_spec(dev,
++					  ss_config->input.pix_fmt,
++					  ss_config->input.image_width,
++					  ss_config->input.image_height,
++					  &line_len);
++	if (ret)
++		return -EINVAL;
++
++	ret = mutex_lock_interruptible(&oper_state.lock);
++	if (ret)
++		return ret;
++
++	if (!ss_config->input.line_length)
++		param->ipipeif_param.adofs = line_len;
++	else {
++		param->ipipeif_param.adofs = ss_config->input.line_length;
++		param->ipipeif_param.adofs =
++				(param->ipipeif_param.adofs + 31) & ~0x1f;
++	}
++	if (ss_config->input.dec_en && ss_config->input.frame_div_mode_en) {
++		dev_err(dev,
++			"Both dec_en & frame_div_mode_en"
++			"can not enabled simultaneously\n");
++		mutex_unlock(&oper_state.lock);
++		return -EINVAL;
++	}
++
++	ret = validate_ipipeif_decimation(dev,
++					  ss_config->input.dec_en,
++					  ss_config->input.rsz,
++					  ss_config->input.frame_div_mode_en,
++					  ss_config->input.image_width);
++	if (ret) {
++		mutex_unlock(&oper_state.lock);
++		return -EINVAL;
++	}
++
++	if (!oper_state.rsz_chained) {
++		ret = prev_validate_output_image_format(dev,
++							ss_config->output.
++							pix_fmt, &line_len,
++							ss_config->input.
++							image_width,
++							ss_config->input.
++							image_height);
++		if (ret) {
++			mutex_unlock(&oper_state.lock);
++			return -EINVAL;
++		}
++		param->ext_mem_param[RSZ_A].rsz_sdr_oft_y = line_len;
++		if (ss_config->input.frame_div_mode_en)
++			ret = update_preview_f_div_params(dev,
++							  ss_config->input.
++							  image_width,
++							  ss_config->input.
++							  image_width,
++							  &param->
++							  rsz_rsc_param[RSZ_A]);
++		if (ret) {
++			mutex_unlock(&oper_state.lock);
++			return -EINVAL;
++		}
++	} else {
++		if (ss_config->input.frame_div_mode_en &&
++		    param->rsz_en[RSZ_A]) {
++			if (!param->rsz_rsc_param[RSZ_A].dscale_en)
++				ret = calculate_normal_f_div_param(
++							dev,
++							ss_config->input.
++							  image_width,
++							param->rsz_rsc_param
++							  [RSZ_A].
++							  o_vsz + 1,
++							&param->rsz_rsc_param
++							  [RSZ_A]);
++			else
++				ret = calculate_down_scale_f_div_param(
++							dev,
++							ss_config->
++							input.image_width,
++							param->rsz_rsc_param
++							  [RSZ_A].o_vsz + 1,
++							&param->rsz_rsc_param
++							  [RSZ_A]);
++			if (ret) {
++				mutex_unlock(&oper_state.lock);
++				return -EINVAL;
++			}
++		}
++		if (ss_config->input.frame_div_mode_en &&
++		    param->rsz_en[RSZ_B]) {
++			if (!param->rsz_rsc_param[RSZ_B].dscale_en)
++				ret = calculate_normal_f_div_param(
++							dev,
++							ss_config->input.
++							   image_width,
++							param->rsz_rsc_param
++							   [RSZ_B].o_vsz + 1,
++							&param->rsz_rsc_param
++							   [RSZ_B]);
++			else
++				ret = calculate_down_scale_f_div_param(
++							dev,
++							ss_config->input.
++							   image_width,
++							param->rsz_rsc_param
++							   [RSZ_B].o_vsz + 1,
++							&param->rsz_rsc_param
++							   [RSZ_B]);
++			if (ret) {
++				mutex_unlock(&oper_state.lock);
++				return -EINVAL;
++			}
++		}
++	}
++	if (ipipe_process_pix_fmts(ss_config->input.pix_fmt,
++				   ss_config->output.pix_fmt,
++				   param) < 0) {
++		dev_err(dev, "error in input or output pix format\n");
++		mutex_unlock(&oper_state.lock);
++		return -EINVAL;
++	}
++	param->ipipeif_param.hnum = ss_config->input.image_width;
++	param->ipipeif_param.vnum = ss_config->input.image_height;
++	param->ipipeif_param.glob_hor_size = ss_config->input.ppln;
++	param->ipipeif_param.glob_ver_size = ss_config->input.lpfr;
++	param->ipipeif_param.var.if_5_1.clk_div = ss_config->input.clk_div;
++	param->ipipeif_param.var.if_5_1.pix_order = ss_config->input.pix_order;
++	param->ipipeif_param.var.if_5_1.align_sync =
++	    ss_config->input.align_sync;
++	param->ipipeif_param.var.if_5_1.rsz_start = ss_config->input.rsz_start;
++	if (param->ipipeif_param.var.if_5_1.dpcm.en) {
++		param->ipipeif_param.var.if_5_1.dpcm.pred =
++		    ss_config->input.pred;
++		param->ipipeif_param.var.if_5_1.dpcm.type = DPCM_8BIT_12BIT;
++	}
++	param->ipipeif_param.var.if_5_1.data_shift =
++	    ss_config->input.data_shift;
++
++	param->ipipe_hsz = ss_config->input.image_width - 1;
++	if (ss_config->input.dec_en) {
++		if ((ss_config->input.rsz < IPIPEIF_RSZ_MIN) ||
++		    (ss_config->input.rsz > IPIPEIF_RSZ_MAX)) {
++			dev_err(dev, "rsz range is %d to %d\n",
++				IPIPEIF_RSZ_MIN, IPIPEIF_RSZ_MAX);
++			mutex_unlock(&oper_state.lock);
++			return -EINVAL;
++		}
++		param->ipipeif_param.decimation = IPIPEIF_DECIMATION_ON;
++		param->ipipeif_param.rsz = ss_config->input.rsz;
++		param->ipipeif_param.avg_filter =
++		    (enum ipipeif_avg_filter)ss_config->input.avg_filter_en;
++		param->ipipe_hsz =
++		    (((ss_config->input.image_width * IPIPEIF_RSZ_CONST) /
++		      ss_config->input.rsz) - 1);
++	}
++	param->ipipeif_param.gain = ss_config->input.gain;
++	param->ipipeif_param.var.if_5_1.clip = ss_config->input.clip;
++	param->ipipeif_param.var.if_5_1.dpc = ss_config->input.dpc;
++	param->ipipe_colpat_olop = ss_config->input.colp_olop;
++	param->ipipe_colpat_olep = ss_config->input.colp_olep;
++	param->ipipe_colpat_elop = ss_config->input.colp_elop;
++	param->ipipe_colpat_elep = ss_config->input.colp_elep;
++	param->ipipe_vps = ss_config->input.vst;
++	param->ipipe_hps = ss_config->input.hst;
++	param->ipipe_vsz = ss_config->input.image_height - 1;
++	if (ss_config->input.pix_fmt == IPIPE_UYVY)
++		param->ipipeif_param.source = SDRAM_YUV;
++	else
++		param->ipipeif_param.source = SDRAM_RAW;
++
++	configure_common_rsz_in_params(dev, param, 1, oper_state.rsz_chained,
++					       &ss_config->input);
++
++	param->rsz_common.passthrough = ss_config->bypass;
++	/* update the resize parameters */
++	if (ss_config->bypass == IPIPE_BYPASS_ON ||
++	    param->ipipe_dpaths_fmt == IPIPE_RAW2RAW)
++		/* Bypass resizer */
++		configure_resize_passthru(param, 1);
++	else {
++		if (oper_state.rsz_chained) {
++			if (param->rsz_en[RSZ_A]) {
++				calculate_resize_ratios(param, RSZ_A);
++				calculate_sdram_offsets(param, RSZ_A);
++			}
++			if (param->rsz_en[RSZ_B]) {
++				calculate_resize_ratios(param, RSZ_B);
++				calculate_sdram_offsets(param, RSZ_B);
++			}
++		} else {
++			struct rsz_output_spec *output_specs =
++				kmalloc(sizeof(struct rsz_output_spec),
++					GFP_KERNEL);
++			if (ISNULL(output_specs)) {
++				dev_err(dev, "Memory Alloc failure\n");
++				mutex_unlock(&oper_state.lock);
++				return -EINVAL;
++			}
++				/* Using resizer as pass through */
++			configure_resize_passthru(param, 0);
++			memset((void *)output_specs, 0,
++				sizeof(struct rsz_output_spec));
++			output_specs->enable = 1;
++			output_specs->pix_fmt = IPIPE_UYVY;
++			output_specs->width = ss_config->input.image_width;
++			output_specs->height = ss_config->input.image_height;
++			output_specs->vst_y = ss_config->input.vst;
++			configure_resizer_out_params(param, RSZ_A,
++				output_specs, 0, 0);
++			calculate_sdram_offsets(param, RSZ_A);
++			kfree(output_specs);
++		}
++	}
++	mutex_unlock(&oper_state.lock);
++	return 0;
++}
++
++static int ipipe_reconfig_resizer(struct device *dev,
++				struct rsz_reconfig *reconfig,
++				void *config)
++{
++	struct ipipe_params *param = (struct ipipe_params *)config;
++	if (ISNULL(reconfig)) {
++		dev_err(dev, "Null User ptr received for reconfig");
++		return -EINVAL;
++	}
++
++	if ((reconfig->pix_format != IMP_420SP_Y) &&
++		(reconfig->pix_format != IMP_420SP_C)) {
++		dev_err(dev, "reconfig - pixel format incorrect");
++		return -EINVAL;
++	}
++	if (param->rsz_common.src_img_fmt != RSZ_IMG_420) {
++		dev_err(dev, "reconfig - source format originally"
++				"configured is not YUV420SP\n");
++		return -EINVAL;
++	}
++	if ((param->rsz_common.y_c) && (reconfig->pix_format == IMP_420SP_C)) {
++		dev_err(dev, "reconfig - channel is already configured"
++				"for YUV420SP - C data\n");
++		return -EINVAL;
++	}
++	if ((!param->rsz_common.y_c) && (reconfig->pix_format == IMP_420SP_Y)) {
++		dev_err(dev, "reconfig - channel is already configured"
++				"for YUV420SP - Y data\n");
++		return -EINVAL;
++	}
++	if (reconfig->pix_format == IMP_420SP_Y)
++		param->rsz_common.y_c = 0;
++	else
++		param->rsz_common.y_c = 1;
++	if (!en_serializer)
++		rsz_set_in_pix_format(param->rsz_common.y_c);
++	return 0;
++}
++
++#ifdef CONFIG_IMP_DEBUG
++static void ipipe_dump_hw_config(void)
++{
++	printk(KERN_NOTICE "IPIPE Configuration context\n");
++	printk(KERN_NOTICE
++	       "**************************************************\n");
++	if (oper_mode == IMP_MODE_SINGLE_SHOT)
++		printk(KERN_NOTICE "Operation mode = SINGLE SHOT\n");
++	else
++		printk(KERN_NOTICE "Operation mode = CONTINUOUS\n");
++	if (oper_state.rsz_chained)
++		printk(KERN_NOTICE "Resizer chained\n");
++	else
++		printk(KERN_NOTICE "Resizer not chained\n");
++	if (en_serializer)
++		printk(KERN_NOTICE "Serializer is enabled\n");
++	else
++		printk(KERN_NOTICE "Serializer is disabled\n");
++	if (oper_mode != IMP_MODE_SINGLE_SHOT) {
++		if (oper_state.prev_config_state)
++			printk(KERN_NOTICE "Previewer is configured\n");
++		else
++			printk(KERN_NOTICE "Previewer is not configured\n");
++	}
++	if (oper_state.rsz_chained || (oper_mode != IMP_MODE_SINGLE_SHOT)) {
++		if (oper_state.rsz_config_state)
++			printk(KERN_NOTICE "Resizer is configured\n");
++		else
++			printk(KERN_NOTICE "Resizer is not configured\n");
++	}
++	ipipe_hw_dump_config();
++}
++#else
++static void ipipe_dump_hw_config(void)
++{
++}
++#endif
++
++static int ipipe_set_preview_config(struct device *dev,
++				    unsigned int oper_mode,
++				    void *user_config, void *config)
++{
++	int ret = 0;
++	struct ipipe_params *param = (struct ipipe_params *)config;
++	dev_err(dev, "ipipe_set_preview_config\n");
++
++	if ((ISNULL(user_config)) || (ISNULL(config))) {
++		dev_err(dev, "Invalid user_config or config ptr\n");
++		return -EINVAL;
++	}
++
++	if (!oper_state.rsz_chained) {
++		/* For chained resizer, defaults are set by resizer */
++		memcpy((void *)config,
++		       (void *)&dm365_ipipe_defs,
++		       sizeof(struct ipipe_params));
++	}
++
++	/* shared block */
++	if (oper_mode == IMP_MODE_SINGLE_SHOT) {
++		/* previewer in standalone mode. In this mode if serializer
++		 * is enabled, we need to set config params for hw.
++		 */
++		ret = configure_previewer_in_ss_mode(dev, user_config, param);
++
++		if ((!ret) && !en_serializer)
++			ret = ipipe_hw_setup(config);
++	} else
++		ret = configure_previewer_in_cont_mode(dev, user_config, param);
++	/* continuous mode */
++	return ret;
++}
++struct imp_hw_interface *imp_get_hw_if(void)
++{
++	return &dm365_ipipe_interface;
++}
++EXPORT_SYMBOL(imp_get_hw_if);
++
++/* APIs for CCDC driver */
++static int ipipe_set_input_win(struct imp_window *win)
++{
++	int ret;
++	struct ipipe_params *param = oper_state.shared_config_param;
++
++	ret = mutex_lock_interruptible(&oper_state.lock);
++	if (ret)
++		return ret;
++	if (param->ipipeif_param.decimation) {
++		param->ipipe_hsz =
++		    ((win->width * IPIPEIF_RSZ_CONST) /
++		     param->ipipeif_param.rsz) - 1;
++	} else
++		param->ipipe_hsz = win->width - 1;
++	if (!oper_state.frame_format) {
++		param->ipipe_vsz = (win->height >> 1) - 1;
++		param->ipipe_vps = (win->vst >> 1);
++	} else {
++		param->ipipe_vsz = win->height - 1;
++		param->ipipe_vps = win->vst;
++	}
++	param->ipipe_hps = win->hst;
++	param->rsz_common.vsz = param->ipipe_vsz;
++	param->rsz_common.hsz = param->ipipe_hsz;
++	mutex_unlock(&oper_state.lock);
++	return 0;
++}
++static int ipipe_get_input_win(struct imp_window *win)
++{
++	int ret;
++	struct ipipe_params *param = oper_state.shared_config_param;
++
++	ret = mutex_lock_interruptible(&oper_state.lock);
++	if (ret)
++		return ret;
++	if (param->ipipeif_param.decimation)
++		win->width =
++		    (((param->ipipe_hsz + 1) * param->ipipeif_param.rsz) >> 4);
++	else
++		win->width = param->ipipe_hsz + 1;
++	if (!oper_state.frame_format) {
++		win->height = (param->ipipe_vsz + 1) << 1;
++		win->vst = (param->ipipe_vps << 1);
++	} else {
++		win->height = param->ipipe_vsz + 1;
++		win->vst = param->ipipe_vps;
++	}
++	win->hst = param->ipipe_hps;
++	mutex_unlock(&oper_state.lock);
++	return 0;
++}
++
++static int ipipe_set_in_pixel_format(enum imp_pix_formats pix_fmt)
++{
++	int ret;
++	struct ipipe_params *param = oper_state.shared_config_param;
++
++	ret = mutex_lock_interruptible(&oper_state.lock);
++	if (ret)
++		return ret;
++	oper_state.in_pixel_format = pix_fmt;
++	param->rsz_common.src_img_fmt = RSZ_IMG_422;
++	mutex_unlock(&oper_state.lock);
++	return 0;
++}
++
++static int ipipe_set_out_pixel_format(enum imp_pix_formats pix_fmt)
++{
++	struct ipipe_params *param = oper_state.shared_config_param;
++	int err;
++
++	/* if image is RAW, preserve raw image format while flipping.
++	 * otherwise preserve, preserve ycbcr format while flipping
++	 */
++	if (pix_fmt == IMP_BAYER)
++		param->rsz_common.raw_flip = 1;
++	else
++		param->rsz_common.raw_flip = 0;
++
++	err = mutex_lock_interruptible(&oper_state.lock);
++	if (err)
++		return err;
++	oper_state.out_pixel_format = pix_fmt;
++	err = ipipe_process_pix_fmts(oper_state.in_pixel_format,
++				     oper_state.out_pixel_format,
++				     param);
++
++	mutex_unlock(&oper_state.lock);
++	return err;
++}
++
++static int ipipe_set_buftype(unsigned char buf_type)
++{
++	int ret;
++
++	ret = mutex_lock_interruptible(&oper_state.lock);
++	if (ret)
++		return ret;
++	oper_state.buffer_type = buf_type;
++	mutex_unlock(&oper_state.lock);
++	return 0;
++}
++
++static int ipipe_set_frame_format(unsigned char frm_fmt)
++{
++	int ret;
++
++	ret = mutex_lock_interruptible(&oper_state.lock);
++	if (ret)
++		return ret;
++	oper_state.frame_format = frm_fmt;
++	mutex_unlock(&oper_state.lock);
++	return 0;
++}
++
++static int ipipe_set_output_win(struct imp_window *win)
++{
++	struct ipipe_params *param = oper_state.shared_config_param;
++	struct rsz_output_spec output_specs;
++	int ret = -1, line_len, line_len_c;
++	if (!param->rsz_en[0]) {
++		printk(KERN_ERR "resizer output1 not enabled\n");
++		return ret;
++	}
++	output_specs.enable = 1;
++	output_specs.width = win->width;
++	/* Always set output height same as in height
++	   for de-interlacing
++	 */
++	output_specs.height = win->height;
++	output_specs.vst_y = win->vst;
++	if (oper_state.out_pixel_format == IPIPE_YUV420SP)
++		output_specs.vst_c = win->vst;
++	ret = mutex_lock_interruptible(&oper_state.lock);
++	if (ret)
++		return ret;
++	ret = configure_resizer_out_params(param, RSZ_A, &output_specs, 0, 0);
++	if (ret) {
++		printk(KERN_ERR "error in configuring output1\n");
++		mutex_unlock(&oper_state.lock);
++		return ret;
++	}
++	ret |= calculate_line_length(oper_state.out_pixel_format,
++				     param->rsz_rsc_param[0].o_hsz + 1,
++				     param->rsz_rsc_param[0].o_vsz + 1,
++				     &line_len,
++				     &line_len_c);
++	if (ret) {
++		printk(KERN_ERR "error in calculating line length\n");
++		mutex_unlock(&oper_state.lock);
++		return ret;
++	}
++	param->ext_mem_param[0].rsz_sdr_oft_y = line_len;
++	param->ext_mem_param[0].rsz_sdr_oft_c = line_len_c;
++	calculate_resize_ratios(param, RSZ_A);
++	if (param->rsz_en[RSZ_B])
++		calculate_resize_ratios(param, RSZ_B);
++	if (oper_state.out_pixel_format == IPIPE_YUV420SP)
++		enable_422_420_conversion(param, RSZ_A, ENABLE);
++	else
++		enable_422_420_conversion(param, RSZ_A, DISABLE);
++
++	ret = calculate_sdram_offsets(param, RSZ_A);
++	if (param->rsz_en[RSZ_B])
++		ret = calculate_sdram_offsets(param, RSZ_B);
++
++	if (ret)
++		printk(KERN_ERR "error in calculating sdram offsets\n");
++	mutex_unlock(&oper_state.lock);
++	return ret;
++}
++static int ipipe_get_output_state(unsigned char out_sel)
++{
++	struct ipipe_params *param = oper_state.shared_config_param;
++	if ((out_sel != RSZ_A) && (out_sel != RSZ_B))
++		return 0;
++	return param->rsz_en[out_sel];
++}
++
++/* This should be called only after setting the output
++ * window params. This also assumes the corresponding
++ * output is configured prior to calling this.
++ */
++static int ipipe_get_line_length(unsigned char out_sel)
++{
++	struct ipipe_params *param = oper_state.shared_config_param;
++	if ((out_sel != RSZ_A) && (out_sel != RSZ_B))
++		return -1;
++	/* assume output is always UYVY. Change this if we
++	 * support RGB
++	 */
++	if (!param->rsz_en[out_sel])
++		return -1;
++
++	return param->ext_mem_param[out_sel].rsz_sdr_oft_y;
++}
++
++static int ipipe_get_image_height(unsigned char out_sel)
++{
++	struct ipipe_params *param = oper_state.shared_config_param;
++	if ((out_sel != RSZ_A) && (out_sel != RSZ_B))
++		return -1;
++	if (!param->rsz_en[out_sel])
++		return -1;
++
++	return param->rsz_rsc_param[out_sel].o_vsz + 1;
++}
++
++/* Assume valid param ptr */
++int ipipe_set_hw_if_param(struct vpfe_hw_if_param *if_param)
++{
++	int ret;
++	struct ipipe_params *param = oper_state.shared_config_param;
++
++	ret = mutex_lock_interruptible(&oper_state.lock);
++	if (ret)
++		return ret;
++	param->ipipeif_param.var.if_5_1.isif_port = *if_param;
++	mutex_unlock(&oper_state.lock);
++	return 0;
++}
++
++static int dm365_ipipe_init(void)
++{
++	oper_state.shared_config_param =
++	    kmalloc(sizeof(struct ipipe_params), GFP_KERNEL);
++	if (ISNULL(oper_state.shared_config_param)) {
++		printk(KERN_ERR
++		       "dm365_ipipe_init: failed to allocate memory\n");
++		return -ENOMEM;
++	}
++	memcpy(&dm365_ipipe_defs.ipipeif_param.var.if_5_1,
++		&ipipeif_5_1_defaults,
++		sizeof(struct ipipeif_5_1));
++	lutdpc.table = ipipe_lutdpc_table;
++	lut_3d.table = ipipe_3d_lut_table;
++	gbce.table = ipipe_gbce_table;
++	gamma.table_r = ipipe_gamma_table_r;
++	gamma.table_b = ipipe_gamma_table_b;
++	gamma.table_g = ipipe_gamma_table_g;
++	yee.table = ipipe_yee_table;
++	mutex_init(&oper_state.lock);
++	oper_state.state = CHANNEL_FREE;
++	oper_state.prev_config_state = STATE_NOT_CONFIGURED;
++	oper_state.rsz_config_state = STATE_NOT_CONFIGURED;
++	oper_state.frame_format = 1;
++	oper_state.in_pixel_format = IMP_BAYER;
++	oper_state.out_pixel_format = IMP_UYVY;
++	if (oper_mode == IMP_MODE_SINGLE_SHOT)
++		printk(KERN_NOTICE
++		       "DM365 IPIPE initialized in Single Shot mode\n");
++	else
++		printk(KERN_NOTICE
++		       "DM365 IPIPE initialized in Continuous mode\n");
++	return 0;
++}
++
++static void dm365_ipipe_cleanup(void)
++{
++	kfree(oper_state.shared_config_param);
++	printk(KERN_NOTICE "DM365 IPIPE hardware module exited\n");
++}
++
++subsys_initcall(dm365_ipipe_init);
++module_exit(dm365_ipipe_cleanup);
++MODULE_LICENSE("GPL");
+--- /dev/null
++++ b/drivers/char/imp_previewer.c
+@@ -0,0 +1,781 @@
++/*
++ * Copyright (C) 2008 Texas Instruments Inc
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option)any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
++ */
++
++//#include <linux/config.h>
++#include <linux/kernel.h>
++#include <linux/module.h>
++#include <linux/init.h>
++#include <linux/kernel.h>
++#include <linux/slab.h>
++#include <linux/fs.h>
++#include <linux/errno.h>
++#include <linux/types.h>
++#include <linux/cdev.h>
++#include <linux/dma-mapping.h>
++#include <linux/interrupt.h>
++#include <linux/uaccess.h>
++#include <linux/platform_device.h>
++
++#include <media/davinci/imp_hw_if.h>
++#include <media/davinci/imp_previewer.h>
++
++#include <mach/cputype.h>
++
++#define DRIVERNAME  "DaVinciPreviewer"
++
++struct device *prev_dev;
++
++/* prev_device structure */
++static struct prev_device prevdevice;
++
++/* instance of the imp interface */
++static struct imp_hw_interface *imp_hw_if;
++
++/* Functions */
++int previewer_open(struct inode *inode, struct file *filp)
++{
++	struct prev_device *device = &prevdevice;
++	struct prev_fh *fh;
++	int i;
++
++	if (filp->f_flags & O_NONBLOCK) {
++		dev_err
++		    (prev_dev,
++		     "previewer_open: device cannot be "
++			"opened in non-blocked mode\n");
++		return -EBUSY;
++	}
++	/* allocate memory for a the file handle */
++
++	fh = kmalloc(sizeof(struct prev_fh), GFP_KERNEL);
++	if (fh == NULL)
++		return -ENOMEM;
++
++	mutex_lock(&device->lock);
++	if (!device->users) {
++		device->chan->mode = IMP_MODE_INVALID;
++		device->chan->primary_user = 0;
++		device->chan->chained = 0;
++		/* Preview channel has maximum priority
++		   since it is used with a capture application
++		   and needs to achieve required fps throughput
++		 */
++		device->chan->config = NULL;
++		device->chan->user_config_size = 0;
++		device->chan->user_config = NULL;
++		device->chan->config_state = STATE_NOT_CONFIGURED;
++		device->chan->in_numbufs = 0;
++		device->chan->out_numbuf1s = 0;
++		device->chan->out_numbuf2s = 0;
++		for (i = 0; i < MAX_BUFFERS; i++) {
++			device->chan->in_bufs[i] = NULL;
++			device->chan->out_buf1s[i] = NULL;
++			device->chan->out_buf2s[i] = NULL;
++		}
++		device->chan->priority = MAX_PRIORITY;
++		init_completion(&(device->chan->channel_sem));
++		device->chan->channel_sem.done = 0;
++		mutex_init(&(device->chan->lock));
++	}
++	device->users++;
++	mutex_unlock(&device->lock);
++	/* store the pointer of prev_params in private_data member of file
++	   and params member of prev_device */
++	filp->private_data = fh;
++	fh->chan = device->chan;
++	fh->primary_user = 0;
++
++	return 0;
++}
++
++int previewer_release(struct inode *inode, struct file *filp)
++{
++	/* get the configuratin from private_date member of file */
++	struct prev_fh *fh;
++	struct imp_logical_channel *chan;
++	struct prev_device *device = &prevdevice;
++	unsigned int state;
++	unsigned int mode;
++
++	mutex_lock(&device->lock);
++	fh = (struct prev_fh *)filp->private_data;
++	chan = fh->chan;
++
++	/* if hw is busy in continuous mode, and this is primary
++	   user, we can not close the device
++	 */
++	state = imp_hw_if->get_hw_state();
++	mode = imp_hw_if->get_preview_oper_mode();
++
++	if ((device->users != 1) && (fh->primary_user)) {
++		dev_err(prev_dev,
++			"Close other instances before"
++			" this primary user instance\n");
++		mutex_unlock(&device->lock);
++		return -EBUSY;
++	}
++
++	device->users--;
++	if (fh->primary_user) {
++		/* call free_buffers to free memory allocated to buffers */
++		imp_common_free_buffers(prev_dev, chan);
++		chan->primary_user = 0;
++		if (chan->config_state == STATE_CONFIGURED)
++			kfree(chan->user_config);
++	}
++
++	kfree(filp->private_data);
++	/* Assign null to private_data member of file and params
++	   member of device */
++	filp->private_data = NULL;
++	mutex_unlock(&device->lock);
++	return 0;
++}
++
++int previewer_mmap(struct file *filp, struct vm_area_struct *vma)
++{
++	/* get the address of global object of prev_device structure */
++	struct prev_device *device = &prevdevice;
++	return (imp_common_mmap(filp, vma, device->chan));
++}
++
++int previewer_doioctl(struct inode *inode, struct file *file,
++		      unsigned int cmd, unsigned long arg)
++{
++	int ret = 0;
++	struct prev_fh *fh = (struct prev_fh *)file->private_data;
++	struct imp_logical_channel *chan = fh->chan;
++	unsigned int mode, user_mode;
++
++	if (ISNULL(chan)) {
++		dev_err(prev_dev, "channel ptr is null\n");
++		return -EFAULT;
++	}
++
++	if (ISNULL((void *)arg)) {
++		dev_err(prev_dev, "arg ptr is null\n");
++		return -EFAULT;
++	}
++
++
++	mode = imp_hw_if->get_preview_oper_mode();
++
++	switch (cmd) {
++	case PREV_QUERYBUF:
++	case PREV_REQBUF:
++	case PREV_S_PARAM:
++	case PREV_PREVIEW:
++	case PREV_S_CONFIG:
++		{
++			if (!fh->primary_user)
++				return -EACCES;
++		}
++		break;
++	}
++
++	switch (cmd) {
++	case PREV_QUERYBUF:
++	case PREV_REQBUF:
++	case PREV_PREVIEW:
++		{
++			if (chan->mode == PREV_MODE_CONTINUOUS)
++				return -EACCES;
++		}
++		break;
++	}
++
++	/* switch according value of cmd */
++	switch (cmd) {
++
++	case PREV_S_OPER_MODE:
++		{
++			user_mode = *((unsigned long *)arg);
++			if (chan->mode != IMP_MODE_INVALID) {
++				dev_err(prev_dev,
++					"Mode set for this channel already\n");
++				ret = -EINVAL;
++				goto ERROR;
++			}
++
++			/* primary user trying to set mode */
++			if (user_mode >= IMP_MODE_INVALID) {
++				dev_err(prev_dev, "Invalid mode\n");
++				ret = -EINVAL;
++				goto ERROR;
++			}
++
++			if (user_mode != mode) {
++				dev_err(prev_dev,
++					"Operation mode doesn't match"
++					" with current hw mode\n");
++				ret = -EINVAL;
++				goto ERROR;
++			}
++
++			if (mutex_lock_interruptible(&chan->lock)) {
++				ret = -EINTR;
++				goto ERROR;
++			}
++
++			chan->mode = mode;
++			chan->primary_user = 1;
++			fh->primary_user = 1;
++			mutex_unlock(&chan->lock);
++			dev_dbg(prev_dev,
++				"PREV_S_OPER_MODE: Operation mode set to %d\n",
++				user_mode);
++		}
++		break;
++		/* if case is to query for buffer address */
++	case PREV_G_OPER_MODE:
++		{
++			*(unsigned long *)arg = chan->mode;
++			dev_dbg(prev_dev,
++				"PREV_G_OPER_MODE: mode = %d\n", chan->mode);
++		}
++		break;
++
++	case PREV_ENUM_CAP:
++		{
++			struct prev_cap *cap = (struct prev_cap *)arg;
++			struct prev_module_if *module_if;
++			dev_dbg(prev_dev, "PREV_ENUM_CAP:\n");
++
++			module_if =
++			    imp_hw_if->prev_enum_modules(prev_dev, cap->index);
++
++			if (ISNULL(module_if)) {
++				dev_dbg(prev_dev,
++					"PREV_ENUM_CAP - Last module \n");
++				ret = -EINVAL;
++				goto ERROR;
++			} else {
++				strcpy(cap->version, module_if->version);
++				cap->module_id = module_if->module_id;
++				cap->control = module_if->control;
++				cap->path = module_if->path;
++				strcpy(cap->module_name,
++				       module_if->module_name);
++			}
++		}
++		break;
++
++		/* if case is to set configuration parameters */
++	case PREV_S_PARAM:
++		{
++			struct prev_module_param *module_param =
++			    (struct prev_module_param *)arg;
++			struct prev_module_if *module_if;
++
++			dev_dbg(prev_dev, "PREV_S_PARAM:\n");
++
++			if (chan->config_state != STATE_CONFIGURED) {
++				dev_err(prev_dev, "Channel not configured\n");
++				ret = -EINVAL;
++				goto ERROR;
++			}
++
++			module_if =
++			    imp_get_module_interface(prev_dev,
++						     module_param->module_id);
++			if (ISNULL(module_if)) {
++				dev_err(prev_dev, "Invalid module id\n");
++				ret = -EINVAL;
++				goto ERROR;
++			} else {
++				if (strcmp
++				    (module_if->version,
++				     module_param->version)) {
++					dev_err(prev_dev,
++						"Invalid module version\n");
++					ret = -EINVAL;
++					goto ERROR;
++				}
++				/* we have a valid */
++				ret = module_if->set(prev_dev,
++						     module_param->
++						     param, module_param->len);
++				if (ret < 0) {
++					dev_err(prev_dev,
++						"error in PREV_S_PARAM\n");
++					goto ERROR;
++				}
++			}
++		}
++		break;
++		/* if case is to get configuration parameters */
++	case PREV_G_PARAM:
++		{
++			struct prev_module_param *module_param =
++			    (struct prev_module_param *)arg;
++			struct prev_module_if *module_if;
++
++			dev_dbg(prev_dev, "PREV_G_PARAM:\n");
++
++			if (ISNULL(module_param)) {
++				ret = -EINVAL;
++				goto ERROR;
++			}
++			module_if =
++			    imp_get_module_interface(prev_dev,
++						     module_param->module_id);
++			if (ISNULL(module_if)) {
++				dev_err(prev_dev, "Invalid module id\n");
++				ret = -EINVAL;
++				goto ERROR;
++			} else {
++				if (strcmp
++				    (module_if->version,
++				     module_param->version)) {
++					dev_err(prev_dev,
++						"Invalid module version\n");
++					ret = -EINVAL;
++					goto ERROR;
++				}
++
++				ret = module_if->get(prev_dev,
++						     module_param->param,
++						     module_param->len);
++				if (ret < 0) {
++					dev_err(prev_dev,
++						"error in PREV_G_PARAM\n");
++					goto ERROR;
++				}
++			}
++		}
++		break;
++
++	case PREV_S_CONFIG:
++		{
++			dev_dbg(prev_dev, "PREV_S_CONFIG:\n");
++			if (mutex_lock_interruptible(&(chan->lock))) {
++				ret = -EINTR;
++				goto ERROR;
++			}
++
++			ret =
++			    imp_set_preview_config(prev_dev, chan,
++						   (struct prev_channel_config
++						    *)arg);
++			mutex_unlock(&(chan->lock));
++		}
++		break;
++
++	case PREV_G_CONFIG:
++		{
++			struct prev_channel_config *user_config =
++			    (struct prev_channel_config *)arg;
++
++			dev_dbg(prev_dev, "PREV_G_CONFIG:\n");
++			if (ISNULL(user_config->config)) {
++				ret = -EINVAL;
++				dev_err(prev_dev, "error in PREV_GET_CONFIG\n");
++				goto ERROR;
++			}
++
++			ret =
++			    imp_get_preview_config(prev_dev, chan, user_config);
++		}
++		break;
++	case PREV_S_CONTROL:
++		{
++			struct prev_module_if *module_if;
++			struct prev_control *control_param =
++			    (struct prev_control *)arg;
++
++			dev_dbg(prev_dev, "PREV_S_CONTROL:\n");
++			if (ISNULL(control_param)) {
++				ret = -EINVAL;
++				goto ERROR;
++			}
++
++			if (chan->mode != IMP_MODE_CONTINUOUS) {
++				dev_err(prev_dev,
++					"Control operation allowed"
++					" only in continuous mode\n");
++				ret = -EINVAL;
++				goto ERROR;
++			}
++			module_if =
++			    imp_get_module_interface(prev_dev,
++						     control_param->module_id);
++			if (ISNULL(module_if)) {
++				dev_err(prev_dev, "Invalid module id\n");
++				ret = -EINVAL;
++				goto ERROR;
++			} else {
++				if (strcmp
++				    (module_if->version,
++				     control_param->version)) {
++					dev_err(prev_dev,
++						"Invalid module version\n");
++					ret = -EINVAL;
++					goto ERROR;
++				}
++			}
++
++			if (mutex_lock_interruptible(&chan->lock)) {
++				ret = -EINTR;
++				goto ERROR;
++			}
++
++			ret = module_if->set(prev_dev,
++					     control_param->param,
++					     control_param->len);
++			if (ret < 0) {
++				dev_err(prev_dev,
++					"error in handling PREV_SET_CONTROL\n");
++			}
++			mutex_unlock(&(chan->lock));
++		}
++		break;
++	case PREV_G_CONTROL:
++		{
++			struct prev_module_if *module_if;
++			struct prev_control *control_param =
++			    (struct prev_control *)arg;
++
++			dev_dbg(prev_dev, "PREV_G_CONTROL:\n");
++			if (ISNULL(control_param)) {
++				ret = -EINVAL;
++				goto ERROR;
++			}
++			module_if =
++			    imp_get_module_interface(prev_dev,
++						     control_param->module_id);
++			if (ISNULL(module_if)) {
++				dev_err(prev_dev, "Invalid module id\n");
++				ret = -EINVAL;
++				goto ERROR;
++			} else {
++				if (strcmp
++				    (module_if->version,
++				     control_param->version)) {
++					dev_err(prev_dev,
++						"Invalid module version\n");
++					ret = -EINVAL;
++					goto ERROR;
++				}
++			}
++			ret = module_if->get(prev_dev,
++					     control_param->param,
++					     control_param->len);
++			if (ret < 0) {
++				dev_err(prev_dev,
++					"error in handling PREV_GET_CONTROL\n");
++			}
++		}
++		break;
++
++	case PREV_QUERYBUF:
++		{
++			dev_dbg(prev_dev, "PREV_QUERYBUF:\n");
++			if (mutex_lock_interruptible(&chan->lock)) {
++				ret = -EINTR;
++				goto ERROR;
++			}
++
++			/* call query buffer which will return buffer address */
++			ret = imp_common_query_buffer(prev_dev,
++						      chan,
++						      (struct imp_buffer *)arg);
++			mutex_unlock(&(chan->lock));
++		}
++		break;
++
++		/* if case is to request buffers */
++	case PREV_REQBUF:
++		{
++			dev_dbg(prev_dev, "PREV_REQBUF:\n");
++			if (mutex_lock_interruptible(&chan->lock)) {
++				ret = -EINTR;
++				goto ERROR;
++			}
++
++			/* call request buffer to allocate buffers */
++			ret = imp_common_request_buffer(prev_dev,
++							chan,
++							(struct imp_reqbufs *)
++							arg);
++			mutex_unlock(&(chan->lock));
++		}
++		break;
++
++		/* if the case is to do previewing */
++	case PREV_PREVIEW:
++		{
++			dev_dbg(prev_dev, "PREV_PREVIEW:\n");
++			if (mutex_lock_interruptible(&chan->lock)) {
++				ret = -EINTR;
++				goto ERROR;
++			}
++			ret =
++			    imp_common_start_preview(prev_dev, chan,
++						     (struct imp_convert *)arg);
++			mutex_unlock(&(chan->lock));
++		}
++		break;
++#ifdef CONFIG_IMP_DEBUG
++	case PREV_DUMP_HW_CONFIG:
++		{
++			dev_dbg(prev_dev, "PREV_DUMP_HW_CONFIG:\n");
++			if (mutex_lock_interruptible(&chan->lock)) {
++				ret = -EINTR;
++				goto ERROR;
++			}
++			if (imp_hw_if->dump_hw_config)
++				imp_hw_if->dump_hw_config();
++			mutex_unlock(&(chan->lock));
++		}
++		break;
++#endif
++	default:
++		dev_err(prev_dev, "previewer_ioctl: Invalid Command Value\n");
++		ret = -EINVAL;
++	}
++
++ERROR:
++	return ret;
++}
++
++static int previewer_ioctl(struct inode *inode, struct file *file,
++			   unsigned int cmd, unsigned long arg)
++{
++	int ret;
++	char sbuf[128];
++	void *mbuf = NULL;
++	void *parg = NULL;
++
++	dev_dbg(prev_dev, "Start of previewer ioctl\n");
++
++	/*  Copy arguments into temp kernel buffer  */
++	switch (_IOC_DIR(cmd)) {
++	case _IOC_NONE:
++		parg = NULL;
++		break;
++	case _IOC_READ:
++	case _IOC_WRITE:
++	case (_IOC_WRITE | _IOC_READ):
++		if (_IOC_SIZE(cmd) <= sizeof(sbuf)) {
++			parg = sbuf;
++		} else {
++			/* too big to allocate from stack */
++			mbuf = kmalloc(_IOC_SIZE(cmd), GFP_KERNEL);
++			if (ISNULL(mbuf))
++				return -ENOMEM;
++			parg = mbuf;
++		}
++
++		ret = -EFAULT;
++		if (_IOC_DIR(cmd) & _IOC_WRITE)
++			if (copy_from_user(parg, (void __user *)arg,
++					   _IOC_SIZE(cmd)))
++				goto out;
++		break;
++	}
++
++	/* call driver */
++	ret = previewer_doioctl(inode, file, cmd, (unsigned long)parg);
++	if (ret == -ENOIOCTLCMD)
++		ret = -EINVAL;
++
++	/*  Copy results into user buffer  */
++	switch (_IOC_DIR(cmd)) {
++	case _IOC_READ:
++	case (_IOC_WRITE | _IOC_READ):
++		if (copy_to_user((void __user *)arg, parg, _IOC_SIZE(cmd)))
++			ret = -EFAULT;
++		break;
++	}
++out:
++	kfree(mbuf);
++
++	dev_dbg(prev_dev, "End of previewer ioctl\n");
++	return ret;
++}
++
++static void previewer_platform_release(struct device *device)
++{
++	/* This is called when the reference count goes to zero */
++}
++
++static int previewer_probe(struct device *device)
++{
++	prev_dev = device;
++	return 0;
++}
++
++static int previewer_remove(struct device *device)
++{
++	return 0;
++}
++
++/* global variable of type file_operations containing function
++pointers of file operations */
++static struct file_operations prev_fops = {
++	.owner = THIS_MODULE,
++	.open = previewer_open,
++	.release = previewer_release,
++	.mmap = previewer_mmap,
++	.ioctl = previewer_ioctl,
++};
++
++/* global variable of type cdev to register driver to the kernel */
++static struct cdev cdev;
++
++/* global variable which keeps major and minor number of the driver in it */
++static dev_t dev;
++
++static struct class *prev_class;
++
++static struct platform_device previewer_device = {
++	.name = "davinci_previewer",
++	.id = 2,
++	.dev = {
++		.release = previewer_platform_release,
++	}
++};
++
++static struct device_driver previewer_driver = {
++	.name = "davinci_previewer",
++	.bus = &platform_bus_type,
++	.probe = previewer_probe,
++	.remove = previewer_remove
++};
++
++int __init previewer_init(void)
++{
++	int result;
++	struct imp_logical_channel *chan_config = NULL;
++
++	/* Register the driver in the kernel */
++	/* dynamically get the major number for the driver using
++	   alloc_chrdev_region function */
++	result = alloc_chrdev_region(&dev, 0, 1, DRIVERNAME);
++
++	/* if it fails return error */
++	if (result < 0) {
++		printk(KERN_ERR "DaVinciPreviewer: Module intialization \
++		failed. could not register character device\n");
++		return -ENODEV;
++	}
++
++	/* initialize cdev with file operations */
++	cdev_init(&cdev, &prev_fops);
++	cdev.owner = THIS_MODULE;
++	cdev.ops = &prev_fops;
++
++	/* add cdev to the kernel */
++	result = cdev_add(&cdev, dev, 1);
++
++	if (result) {
++		unregister_chrdev_region(dev, 1);
++		printk(KERN_ERR
++		       "DaVinciPreviewer: Error adding "
++			"DavinciPreviewer .. error no:%d\n",
++		       result);
++		return -EINVAL;
++	}
++
++	/* register character driver to the kernel */
++	register_chrdev(MAJOR(dev), DRIVERNAME, &prev_fops);
++
++	/* register driver as a platform driver */
++	if (driver_register(&previewer_driver) != 0) {
++		unregister_chrdev_region(dev, 1);
++		cdev_del(&cdev);
++		return -EINVAL;
++	}
++
++	/* Register the drive as a platform device */
++	if (platform_device_register(&previewer_device) != 0) {
++		driver_unregister(&previewer_driver);
++		unregister_chrdev_region(dev, 1);
++		unregister_chrdev(MAJOR(dev), DRIVERNAME);
++		cdev_del(&cdev);
++		return -EINVAL;
++	}
++
++	prev_class = class_create(THIS_MODULE, "davinci_previewer");
++	if (!prev_class) {
++		printk(KERN_NOTICE
++		       "previewer_init: error in creating device class\n");
++		driver_unregister(&previewer_driver);
++		platform_device_unregister(&previewer_device);
++		unregister_chrdev_region(dev, 1);
++		unregister_chrdev(MAJOR(dev), DRIVERNAME);
++		cdev_del(&cdev);
++		return -EIO;
++	}
++
++	device_create(prev_class, NULL, dev, NULL, "davinci_previewer");
++
++	prevdevice.users = 0;
++	chan_config = kmalloc(sizeof(struct imp_logical_channel), GFP_KERNEL);
++	if (ISNULL(chan_config)) {
++		unregister_chrdev_region(dev, 1);
++		device_destroy(prev_class, dev);
++		class_destroy(prev_class);
++		driver_unregister(&previewer_driver);
++		platform_device_unregister(&previewer_device);
++		cdev_del(&cdev);
++		unregister_chrdev(MAJOR(dev), DRIVERNAME);
++		return -ENOMEM;
++	}
++	prevdevice.chan = chan_config;
++	prevdevice.chan->priority = MAX_PRIORITY;
++	prevdevice.chan->type = IMP_PREVIEWER;
++	if (!cpu_is_davinci_dm644x())
++		imp_init_serializer();
++	/* initialize mutex to 0 */
++	mutex_init(&(prevdevice.lock));
++	mutex_init(&(prevdevice.chan->lock));
++	imp_hw_if = imp_get_hw_if();
++	printk(KERN_NOTICE "davinci_previewer initialized\n");
++	return 0;
++}
++
++void __exit previewer_cleanup(void)
++{
++	/* remove major number allocated to this driver */
++	unregister_chrdev_region(dev, 1);
++
++	/* remove simple class device */
++	device_destroy(prev_class, dev);
++
++	/* destroy simple class */
++	class_destroy(prev_class);
++
++	/* Remove platform driver */
++	driver_unregister(&previewer_driver);
++
++	/* remove platform device */
++	platform_device_unregister(&previewer_device);
++
++	cdev_del(&cdev);
++
++	/* unregistering the driver from the kernel */
++	unregister_chrdev(MAJOR(dev), DRIVERNAME);
++
++	kfree(prevdevice.chan);
++}
++
++module_init(previewer_init)
++module_exit(previewer_cleanup)
++
++MODULE_LICENSE("GPL");
+--- /dev/null
++++ b/include/video/davincifb_ioctl.h
+@@ -0,0 +1,175 @@
++/*
++ * Copyright (C) 2009 Texas Instruments Inc
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option)any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
++ */
++
++#ifndef DAVINCIFB_IOCTL_H
++#define DAVINCIFB_IOCTL_H
++
++/*
++ * Enumerations
++ */
++
++/*  Enum for Boolean variables  */
++typedef enum {
++	SET_0 = 0,
++	SET_1 = 1
++} CB_CR_ORDER, ATTRIBUTE;
++
++/*  Enable/Disable enum */
++typedef enum {
++	VPBE_DISABLE = 0,
++	VPBE_ENABLE = 1
++} ATTENUATION, EXPANSION, BLINKING;
++
++/*
++ * Structures and Union Definitions
++ */
++
++typedef struct zoom_params {
++	u_int32_t window_id;
++	u_int32_t zoom_h;
++	u_int32_t zoom_v;
++} zoom_params_t;
++
++/* Structure for transparency and the blending factor for the bitmap window */
++typedef struct vpbe_bitmap_blend_params {
++	unsigned int colorkey;	/* color key to be blended */
++	unsigned int enable_colorkeying;	/* enable color keying */
++	unsigned int bf;	/* valid range from 0 to 7 only. */
++} vpbe_bitmap_blend_params_t;
++
++/*  Structure for window expansion  */
++typedef struct vpbe_win_expansion {
++	EXPANSION horizontal;
++	EXPANSION vertical;	/* 1: Enable 0:disable */
++} vpbe_win_expansion_t;
++
++/*  Structure for OSD window blinking options */
++typedef struct vpbe_blink_option {
++	BLINKING blinking;	/* 1: Enable blinking 0: Disable */
++	unsigned int interval;	/* Valid only if blinking is 1 */
++} vpbe_blink_option_t;
++
++/*  Structure for background color  */
++typedef struct vpbe_backg_color {
++	unsigned char clut_select;	/* 2: RAM CLUT 1:ROM1 CLUT 0:ROM0 CLUT */
++	unsigned char color_offset;	/* index of color */
++} vpbe_backg_color_t;
++
++/*  Structure for Video window configurable parameters  */
++typedef struct vpbe_video_config_params {
++	CB_CR_ORDER cb_cr_order;	/* Cb/Cr order in input data for a pixel. */
++	/*    0: cb cr  1:  cr cb */
++	vpbe_win_expansion_t exp_info;	/* HZ/VT Expansion enable disable */
++} vpbe_video_config_params_t;
++
++/*
++ * Union of structures giving the CLUT index for the 1, 2, 4 bit bitmap values
++ */
++typedef union vpbe_clut_idx {
++	struct _for_4bit_bitmap {
++		unsigned char bitmap_val_0;
++		unsigned char bitmap_val_1;
++		unsigned char bitmap_val_2;
++		unsigned char bitmap_val_3;
++		unsigned char bitmap_val_4;
++		unsigned char bitmap_val_5;
++		unsigned char bitmap_val_6;
++		unsigned char bitmap_val_7;
++		unsigned char bitmap_val_8;
++		unsigned char bitmap_val_9;
++		unsigned char bitmap_val_10;
++		unsigned char bitmap_val_11;
++		unsigned char bitmap_val_12;
++		unsigned char bitmap_val_13;
++		unsigned char bitmap_val_14;
++		unsigned char bitmap_val_15;
++	} for_4bit_bitmap;
++	struct _for_2bit_bitmap {
++		unsigned char bitmap_val_0;
++		unsigned char dummy0[4];
++		unsigned char bitmap_val_1;
++		unsigned char dummy1[4];
++		unsigned char bitmap_val_2;
++		unsigned char dummy2[4];
++		unsigned char bitmap_val_3;
++	} for_2bit_bitmap;
++	struct _for_1bit_bitmap {
++		unsigned char bitmap_val_0;
++		unsigned char dummy0[14];
++		unsigned char bitmap_val_1;
++	} for_1bit_bitmap;
++} vpbe_clut_idx_t;
++
++/* Structure for bitmap window configurable parameters */
++typedef struct vpbe_bitmap_config_params {
++	/* Only for bitmap width = 1,2,4 bits */
++	vpbe_clut_idx_t clut_idx;
++	/* Attenuation value for YUV o/p for bitmap window */
++	unsigned char attenuation_enable;
++	/* 0: ROM DM270, 1:ROM DM320, 2:RAM CLUT */
++	unsigned char clut_select;
++} vpbe_bitmap_config_params_t;
++
++/* Structure to hold window position */
++typedef struct vpbe_window_position {
++	unsigned int xpos;	/* X position of the window */
++	unsigned int ypos;	/* Y position of the window */
++} vpbe_window_position_t;
++
++#define	RAM_CLUT_SIZE	256*3
++
++/* custom ioctl definitions */
++#define FBIO_WAITFORVSYNC	_IOW('F', 0x20, u_int32_t)
++#define FBIO_SETATTRIBUTE	_IOW('F', 0x21, struct fb_fillrect)
++#define FBIO_SETPOSX		_IOW('F', 0x22, u_int32_t)
++#define FBIO_SETPOSY		_IOW('F', 0x23, u_int32_t)
++#define FBIO_SETZOOM		_IOW('F', 0x24, struct zoom_params)
++#define FBIO_ENABLE_DISABLE_WIN		\
++	_IOW('F', 0x30, unsigned char)
++#define FBIO_SET_BITMAP_BLEND_FACTOR	\
++	_IOW('F', 0x31, vpbe_bitmap_blend_params_t)
++#define FBIO_SET_BITMAP_WIN_RAM_CLUT	\
++	_IOW('F', 0x32, unsigned char[RAM_CLUT_SIZE])
++#define FBIO_ENABLE_DISABLE_ATTRIBUTE_WIN \
++	_IOW('F', 0x33, unsigned int)
++#define FBIO_GET_BLINK_INTERVAL		\
++	_IOR('F', 0x34, vpbe_blink_option_t)
++#define FBIO_SET_BLINK_INTERVAL		\
++	_IOW('F', 0x35, vpbe_blink_option_t)
++#define FBIO_GET_VIDEO_CONFIG_PARAMS	\
++	_IOR('F', 0x36, vpbe_video_config_params_t)
++#define FBIO_SET_VIDEO_CONFIG_PARAMS	\
++	_IOW('F', 0x37, vpbe_video_config_params_t)
++#define FBIO_GET_BITMAP_CONFIG_PARAMS	\
++	_IOR('F', 0x38, vpbe_bitmap_config_params_t)
++#define FBIO_SET_BITMAP_CONFIG_PARAMS	\
++	_IOW('F', 0x39, vpbe_bitmap_config_params_t)
++#define FBIO_SET_BACKG_COLOR		\
++	_IOW('F', 0x47, vpbe_backg_color_t)
++#define FBIO_SETPOS			\
++	_IOW('F', 0x49, u_int32_t)
++#define FBIO_SET_CURSOR			\
++	_IOW('F', 0x50, struct fb_cursor)
++
++/*  Window ID definitions */
++#define OSD0 0
++#define VID0 1
++#define OSD1 2
++#define VID1 3
++
++#endif				/* ifndef DAVINCIFB_IOCTL_H */
+--- a/drivers/spi/Kconfig
++++ b/drivers/spi/Kconfig
+@@ -77,6 +77,13 @@ config SPI_AU1550
+ 	  This driver can also be built as a module.  If so, the module
+ 	  will be called au1550_spi.
+ 
++config SPI_DAVINCI
++	tristate "SPI controller driver for DaVinci/DA8xx SoC's"
++	depends on SPI_MASTER && ARCH_DAVINCI
++	select SPI_BITBANG
++	help
++	  SPI master controller for DaVinci and DA8xx SPI modules.
++
+ config SPI_BITBANG
+ 	tristate "Utilities for Bitbanging SPI masters"
+ 	help
+--- a/drivers/media/video/videobuf-dma-sg.c
++++ b/drivers/media/video/videobuf-dma-sg.c
+@@ -588,7 +588,7 @@ static int __videobuf_mmap_mapper(struct
+ 			retval = -EBUSY;
+ 			goto done;
+ 		}
+-		size += q->bufs[last]->bsize;
++		size += PAGE_ALIGN(q->bufs[last]->bsize);
+ 		if (size == (vma->vm_end - vma->vm_start))
+ 			break;
+ 	}
+@@ -610,7 +610,7 @@ static int __videobuf_mmap_mapper(struct
+ 			continue;
+ 		q->bufs[i]->map   = map;
+ 		q->bufs[i]->baddr = vma->vm_start + size;
+-		size += q->bufs[i]->bsize;
++		size += PAGE_ALIGN(q->bufs[i]->bsize);
+ 	}
+ 
+ 	map->count    = 1;
+--- a/drivers/rtc/Makefile
++++ b/drivers/rtc/Makefile
+@@ -26,6 +26,7 @@ obj-$(CONFIG_RTC_DRV_BFIN)	+= rtc-bfin.o
+ obj-$(CONFIG_RTC_DRV_BQ4802)	+= rtc-bq4802.o
+ obj-$(CONFIG_RTC_DRV_CMOS)	+= rtc-cmos.o
+ obj-$(CONFIG_RTC_DRV_COH901331)	+= rtc-coh901331.o
++obj-$(CONFIG_RTC_DRV_DAVINCI)	+= rtc-davinci.o
+ obj-$(CONFIG_RTC_DRV_DM355EVM)	+= rtc-dm355evm.o
+ obj-$(CONFIG_RTC_DRV_DS1216)	+= rtc-ds1216.o
+ obj-$(CONFIG_RTC_DRV_DS1286)	+= rtc-ds1286.o
+--- /dev/null
++++ b/include/media/davinci/dm355_aew.h
+@@ -0,0 +1,153 @@
++/*
++ * Copyright (C) 2009 Texas Instruments Inc
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
++ */
++
++#ifndef DM355_AEW_DRIVER_H
++#define DM355_AEW_DRIVER_H
++
++#include <linux/ioctl.h>
++
++#ifdef __KERNEL__
++#include <linux/kernel.h>
++#include <linux/wait.h>
++#include <linux/semaphore.h>
++#include <linux/mutex.h>
++#include <asm/io.h>
++#include <asm/fcntl.h>
++#endif
++
++/* Driver Range Constants*/
++#define AEW_WINDOW_VERTICAL_COUNT_MIN		1
++#define AEW_WINDOW_VERTICAL_COUNT_MAX		128
++#define AEW_WINDOW_HORIZONTAL_COUNT_MIN		2
++#define AEW_WINDOW_HORIZONTAL_COUNT_MAX		36
++#define AEW_WINDOW_SIZE				18
++#define AEW_WIDTH_MIN				8
++#define AEW_WIDTH_MAX				256
++#define AEW_AVELMT_MAX				1023
++#define AEW_HZ_LINEINCR_MIN			2
++#define AEW_HZ_LINEINCR_MAX			32
++#define AEW_VT_LINEINCR_MIN			2
++#define AEW_VT_LINEINCR_MAX			32
++#define AEW_HEIGHT_MIN				2
++#define AEW_HEIGHT_MAX				256
++#define AEW_HZSTART_MIN				0
++#define AEW_HZSTART_MAX				4095
++#define AEW_VTSTART_MIN				0
++#define AEW_VTSTART_MAX				4095
++#define AEW_BLKWINHEIGHT_MIN			2
++#define AEW_BLKWINHEIGHT_MAX			256
++#define AEW_BLKWINVTSTART_MIN			0
++#define AEW_BLKWINVTSTART_MAX			4095
++
++#ifdef __KERNEL__
++
++/* Device Constants*/
++#define AEW_NR_DEVS		1
++#define DEVICE_NAME		"dm355_aew"
++#define AEW_MAJOR_NUMBER	0
++#define AEW_IOC_MAXNR		4
++#define AEW_TIMEOUT		(300 * HZ / 1000)
++#endif
++
++/* List of ioctls */
++#pragma pack(1)
++#define AEW_MAGIC_NO    'e'
++#define AEW_S_PARAM	_IOWR(AEW_MAGIC_NO , 1 , struct aew_configuration *)
++#define AEW_G_PARAM	_IOWR(AEW_MAGIC_NO , 2 , struct aew_configuration *)
++#define AEW_ENABLE	_IO(AEW_MAGIC_NO , 3)
++#define AEW_DISABLE	_IO(AEW_MAGIC_NO , 4)
++#pragma pack()
++
++/*Enum for device usage*/
++typedef enum {
++	AEW_NOT_IN_USE = 0,	/* Device is not in use */
++	AEW_IN_USE = 1		/* Device in use */
++} aew_In_use;
++
++/*Enum for Enable/Disable specific feature*/
++typedef enum {
++	H3A_AEW_ENABLE = 1,
++	H3A_AEW_DISABLE = 0
++} aew_alaw_enable;
++
++typedef enum {
++	H3A_AEW_CONFIG_NOT_DONE,
++	H3A_AEW_CONFIG
++} aew_config_flag;
++
++/* Contains the information regarding Window Structure in AEW Engine */
++struct aew_window {
++	unsigned int width;		/* Width of the window */
++	unsigned int height;		/* Height of the window */
++	unsigned int hz_start;		/* Horizontal Start of the window */
++	unsigned int vt_start;		/* Vertical Start of the window */
++	unsigned int hz_cnt;		/* Horizontal Count */
++	unsigned int vt_cnt;		/* Vertical Count */
++	unsigned int hz_line_incr;	/* Horizontal Line Increment */
++	unsigned int vt_line_incr;	/* Vertical Line Increment */
++};
++
++/* Contains the information regarding the AEW Black Window Structure*/
++struct aew_black_window {
++	unsigned int height;	/* Height of the Black Window */
++	unsigned int vt_start;	/* Vertical Start of the black Window */
++};
++
++typedef enum _aew_input_src {
++	AEW_CCDC = 0,
++	AEW_SDRAM = 1
++} aew_input_src_t;
++
++/* Contains configuration required for setup of AEW engine*/
++struct aew_configuration {
++	aew_alaw_enable alaw_enable;		/* A-law status */
++	int saturation_limit;			/* Saturation Limit */
++	struct aew_window window_config;	/* Window for AEW Engine */
++	struct aew_black_window blackwindow_config;	/* Black Window */
++};
++
++#ifdef __KERNEL__
++/* Contains information about device structure of AEW*/
++struct aew_device {
++	aew_In_use in_use;			/* Driver usage flag */
++	struct aew_configuration *config;	/* Device configuration */
++	void *buff_old;			/* Contains latest statistics */
++	void *buff_curr;		/* Buffer in which HW will */
++
++	/*
++	 * Fill the statistics
++	 * or HW is already filling
++	 * statistics
++	 */
++
++	void *buff_app;		/* Buffer which will be passed */
++
++	int buffer_filled;	/* Flag indicates statistics */
++
++	unsigned int size_window;
++	wait_queue_head_t aew_wait_queue;
++	struct mutex read_blocked;
++
++	/* Flag indicates Engine is configured */
++	aew_config_flag aew_config;
++};
++
++int aew_hardware_setup(void);
++int aew_validate_parameters(void);
++#endif
++#endif
+--- a/arch/arm/mach-davinci/include/mach/asp.h
++++ b/arch/arm/mach-davinci/include/mach/asp.h
+@@ -11,6 +11,9 @@
+ #define DAVINCI_ASP0_BASE	0x01E02000
+ #define DAVINCI_ASP1_BASE	0x01E04000
+ 
++/* Bases of dm365 register banks */
++#define DAVINCI_DM365_ASP0_BASE	0x01D02000
++
+ /* Bases of dm646x register banks */
+ #define	DAVINCI_DM646X_MCASP0_REG_BASE		0x01D01000
+ #define DAVINCI_DM646X_MCASP1_REG_BASE		0x01D01800
+--- a/arch/arm/mach-davinci/Kconfig
++++ b/arch/arm/mach-davinci/Kconfig
+@@ -27,11 +27,13 @@ config ARCH_DAVINCI_DM646x
+         bool "DaVinci 646x based system"
+ 	select AINTC
+ 	select ARCH_DAVINCI_DMx
++	select DAVINCI_MUX if PCI
+ 
+ config ARCH_DAVINCI_DA830
+         bool "DA830/OMAP-L137 based system"
+ 	select CP_INTC
+ 	select ARCH_DAVINCI_DA8XX
++	select CPU_DCACHE_WRITETHROUGH # needed on silicon revs 1.0, 1.1
+ 
+ config ARCH_DAVINCI_DA850
+ 	bool "DA850/OMAP-L138 based system"
+@@ -101,6 +103,32 @@ config MACH_DAVINCI_DA830_EVM
+ 	help
+ 	  Say Y here to select the TI DA830/OMAP-L137 Evaluation Module.
+ 
++config DA830_UI
++	bool "DA830/OMAP-L137 UI (User Interface) board support"
++	depends on MACH_DAVINCI_DA830_EVM
++	help
++	  Say Y here if you have the DA830/OMAP-L137 UI
++	  (User Interface) board installed and you want to
++	  enable the peripherals located on User Interface
++	  board.
++
++choice
++	prompt "Select DA830/OMAP-L137 UI board peripheral"
++	depends on DA830_UI
++
++config DA830_UI_LCD
++	bool "LCD"
++	help
++	  Say Y here to use the LCD as a framebuffer or simple character
++	  display.
++
++config DA830_UI_NAND
++	bool "NAND flash"
++	help
++	  Say Y here to use the NAND flash.  Do not forget to setup
++	  the switch correctly.
++endchoice
++
+ config MACH_DAVINCI_DA850_EVM
+ 	bool "TI DA850/OMAP-L138 Reference Platform"
+ 	default ARCH_DAVINCI_DA850
+@@ -145,6 +173,14 @@ config DAVINCI_RESET_CLOCKS
+ 	  probably do not want this option enabled until your
+ 	  device drivers work properly.
+ 
++config OSC_CLK_FREQ
++	int "Input oscillator clock frequency"
++	default 27000000
++	depends on ARCH_DAVINCI
++	help
++	  Specify external clock input frequency for system oscillator. Make
++	  sure this matches as per your board specification.
++
+ endmenu
+ 
+ endif
+--- /dev/null
++++ b/arch/arm/mach-davinci/include/mach/keyscan.h
+@@ -0,0 +1,42 @@
++/*
++ * Copyright (C) 2009 Texas Instruments, Inc
++ *
++ * Author: Miguel Aguilar <miguel.aguilar@ridgerun.com>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
++ */
++
++#ifndef DAVINCI_KEYSCAN_H
++#define DAVINCI_KEYSCAN_H
++
++#include <linux/io.h>
++
++enum davinci_matrix_types {
++	DAVINCI_KEYSCAN_MATRIX_4X4,
++	DAVINCI_KEYSCAN_MATRIX_5X3,
++};
++
++struct davinci_ks_platform_data {
++	int		(*device_enable)(struct device *dev);
++	unsigned short	*keymap;
++	u32		keymapsize;
++	u8		rep:1;
++	u8		strobe;
++	u8		interval;
++	u8		matrix_type;
++};
++
++#endif
++
+--- /dev/null
++++ b/arch/arm/mach-davinci/cdce949.c
+@@ -0,0 +1,389 @@
++/*
++ * TI DaVinci DM646x board specific setup
++ *
++ * Author: Nageswari Srinivasan
++ * This file adds support for CDCE949, on board PLL on DM6467 EVM
++ * CDCE949 can output 5 different clock frequecies depending upon
++ * the configuration. In DM6467 EVM, CDCE949 output is used by
++ * VPIF display, Audio (McASP0, McASP1) and TSIF
++ */
++#include <linux/kernel.h>
++#include <linux/init.h>
++#include <linux/clk.h>
++#include <linux/platform_device.h>
++#include <linux/i2c.h>
++#include <asm/mach/map.h>
++#include <mach/dm646x.h>
++#include <mach/cputype.h>
++#include <mach/clock.h>
++#include "clock.h"
++#include "mux.h"
++
++struct i2c_client *cdce_client;
++
++/* Structure to hold the register values for different frequencies */
++
++struct cdce_cfg_val {
++	unsigned char reg_val[5];
++};
++
++static const struct cdce_cfg_val freq_13500 = {
++	.reg_val	= {8, 0x00, 0x04, 0x02, 0x08},
++};
++
++static const struct cdce_cfg_val freq_16875 = {
++	.reg_val	= {8, 0x9f, 0xB0, 0x02, 0x89},
++};
++
++
++static const struct cdce_cfg_val freq_27000 = {
++	.reg_val	= {4, 0x00, 0x40, 0x02, 0x08},
++};
++
++
++static const struct cdce_cfg_val freq_54000 = {
++	.reg_val	= {4, 0xFF, 0x80, 0x02, 0x07},
++};
++
++static const struct cdce_cfg_val freq_81000 = {
++	.reg_val	= {2, 0xBF, 0xA0, 0x03, 0x0A},
++};
++static const struct cdce_cfg_val freq_74250 = {
++	.reg_val	= {2, 0xBF, 0xA0, 0x03, 0x0A},
++};
++
++static const struct cdce_cfg_val freq_148000 = {
++	.reg_val	= {2, 0xBF, 0xA0, 0x03, 0x0A},
++};
++
++
++struct cdce_freq_table {
++	struct cdce_cfg_val	*cfg_data;
++	unsigned long frequency;
++};
++
++#define TABLE(freq)	\
++{			\
++	.cfg_data	= (struct cdce_cfg_val *) &freq_##freq,	\
++	.frequency	= freq,	\
++}
++
++static struct cdce_freq_table freq_table[] =  {
++TABLE(13500),
++TABLE(16875),
++TABLE(27000),
++TABLE(54000),
++TABLE(81000),
++TABLE(74250),
++TABLE(148000),
++};
++
++
++/*
++ * Device specific clocks
++ */
++#define CDCE949_REF_CLK		27000000
++
++
++/*	depending on the name of the clock,
++ *	call the corresponding set of registers
++ *	of CDCE 949 for setting the required clock frequency
++ */
++
++
++static int cdce_set_rate(struct clk *clk, unsigned long rate)
++{
++	int array_size, i;
++	int err = 0;
++	struct cdce_cfg_val *freq_val = NULL;
++	struct i2c_client *client;
++
++	client = cdce_client;
++
++/* Find the index value for the frequency divider and
++ *  multiplier from the Table */
++
++	array_size	= ARRAY_SIZE(freq_table);
++	rate = rate/1000;
++
++	for (i = 0; i < array_size; i++) {
++		if (freq_table[i].frequency == rate) {
++			freq_val = freq_table[i].cfg_data;
++			break;
++		}
++	}
++/* Check whether the cline adapter is installed */
++
++	if (IS_ERR(cdce_client))
++		return -ENODEV;
++
++	if (freq_val == NULL)
++		return -EINVAL;
++
++	if (!(strcmp(clk->name, "cdce_vpif"))) {
++		if (rate == 148000) {
++			err |= i2c_smbus_write_byte_data(client,
++						0x13 | 0x80, 0x00);
++/* Set PLL1_0 Multiplier */
++			err |= i2c_smbus_write_byte_data(client,
++						0x18 | 0x80, 0xaf);
++			err |= i2c_smbus_write_byte_data(client,
++						0x19 | 0x80, 0x50);
++			err |= i2c_smbus_write_byte_data(client,
++						0x1a | 0x80, 0x02);
++			err |= i2c_smbus_write_byte_data(client,
++						0x1b | 0x80, 0xc9);
++/* Set PLL1_11 Multiplier */
++			err |= i2c_smbus_write_byte_data(client,
++					0x1c | 0x80, 0x00);
++			err |= i2c_smbus_write_byte_data(client,
++					0x1d | 0x80, 0x40);
++			err |= i2c_smbus_write_byte_data(client,
++					 0x1e | 0x80, 0x02);
++			err |= i2c_smbus_write_byte_data(client,
++					0x1f | 0x80, 0xc9);
++/* Output state selection */
++			err |= i2c_smbus_write_byte_data(client,
++					0x15 | 0x80, 0x00);
++			err |= i2c_smbus_write_byte_data(client,
++					0x14 | 0x80, 0xef);
++/* Switch MUX to PLL1 output */
++			err |= i2c_smbus_write_byte_data(client,
++					0x14 | 0x80, 0x6f);
++			err |= i2c_smbus_write_byte_data(client,
++					0x16 | 0x80, 0x06);
++/* Set P2DIV Divider, P3DIV and Input crystal */
++			err |= i2c_smbus_write_byte_data(client,
++					0x17 | 0x80, 0x06);
++
++			err |= i2c_smbus_write_byte_data(client,
++					0x01 | 0x80, 0x00);
++			err |= i2c_smbus_write_byte_data(client,
++					0x05 | 0x80, (9 << 3));
++			err |= i2c_smbus_write_byte_data(client,
++					0x02 | 0x80, 0x80);
++/* Enable and Disable PLL */
++			err |= i2c_smbus_write_byte_data(client,
++					0x02 | 0x80, 0xbc);
++			err |= i2c_smbus_write_byte_data(client,
++					0x03 | 0x80, 0x01);
++	} else if (rate == 74250) {
++		err |= i2c_smbus_write_byte_data(client,
++				0x13 | 0x80, 0x00);
++		err |= i2c_smbus_write_byte_data(client,
++				0x18 | 0x80, 0xaf);
++		err |= i2c_smbus_write_byte_data(client,
++					0x19 | 0x80, 0x50);
++		err |= i2c_smbus_write_byte_data(client,
++					0x1a | 0x80, 0x02);
++		err |= i2c_smbus_write_byte_data(client,
++					0x1b | 0x80, 0xc9);
++
++		err |= i2c_smbus_write_byte_data(client,
++					0x1c | 0x80, 0x00);
++		err |= i2c_smbus_write_byte_data(client,
++					0x1d | 0x80, 0x40);
++		err |= i2c_smbus_write_byte_data(client,
++					0x1e | 0x80, 0x02);
++		err |= i2c_smbus_write_byte_data(client,
++					0x1f | 0x80, 0xc9);
++
++/* Output state selection */
++
++		err |= i2c_smbus_write_byte_data(client,
++					0x15 | 0x80, 0x00);
++		err |= i2c_smbus_write_byte_data(client,
++					0x14 | 0x80, 0xef);
++		err |= i2c_smbus_write_byte_data(client,
++					0x14 | 0x80, 0x6f);
++		err |= i2c_smbus_write_byte_data(client,
++					0x16 | 0x80, 0x06);
++		err |= i2c_smbus_write_byte_data(client,
++					0x17 | 0x80, 0x06);
++
++		err |= i2c_smbus_write_byte_data(client,
++					0x01 | 0x80, 0x00);
++		err |= i2c_smbus_write_byte_data(client,
++					0x05 | 0x80, ( 9 << 3 ));
++		err |= i2c_smbus_write_byte_data(client,
++					0x02 | 0x80, 0x80);
++		err |= i2c_smbus_write_byte_data(client,
++					0x02 | 0x80, 0xbc);
++		err |= i2c_smbus_write_byte_data(client,
++					0x03 | 0x80, 0x02);
++
++	} else if (rate == 27000) {
++		err |= i2c_smbus_write_byte_data(client,
++					0x13 | 0x80, 0x00);
++		err |= i2c_smbus_write_byte_data(client,
++					0x18 | 0x80, 0x00);
++		err |= i2c_smbus_write_byte_data(client,
++					0x19 | 0x80, 0x40);
++		err |= i2c_smbus_write_byte_data(client,
++					0x1a | 0x80, 0x02);
++		err |= i2c_smbus_write_byte_data(client,
++					0x1b | 0x80, 0x08);
++
++		err |= i2c_smbus_write_byte_data(client,
++					0x1c | 0x80, 0x00);
++		err |= i2c_smbus_write_byte_data(client,
++					0x1d | 0x80, 0x40);
++		err |= i2c_smbus_write_byte_data(client,
++					0x1e | 0x80, 0x02);
++		err |= i2c_smbus_write_byte_data(client,
++					0x1f | 0x80, 0x08);
++
++		err |= i2c_smbus_write_byte_data(client,
++					0x15 | 0x80, 0x02);
++		err |= i2c_smbus_write_byte_data(client,
++					0x14 | 0x80, 0xed);
++		err |= i2c_smbus_write_byte_data(client,
++					0x16 | 0x80, 0x01);
++		err |= i2c_smbus_write_byte_data(client,
++					0x17 | 0x80, 0x01);
++
++		err |= i2c_smbus_write_byte_data(client,
++					0x01 | 0x80, 0x00);
++		err |= i2c_smbus_write_byte_data(client,
++					0x05 | 0x80, 0x50);
++		err |= i2c_smbus_write_byte_data(client,
++					0x02 | 0x80, 0xb4);
++		err |= i2c_smbus_write_byte_data(client,
++					0x03 | 0x80, 0x01);
++	}
++
++
++	if (err)
++		return -EINVAL;
++	else
++		clk->rate = (freq_table[i].frequency * 1000);
++
++	}
++
++
++	else if (strcmp(clk->name, "cdce_audio"))	{
++
++/*	TO DO - Need to add corresponding functions for
++ *	McASP1 clock settings on EVM
++ */
++	}
++/*	TO DO - Need to add corresponding functions for
++ *	McASP1 clock settings on EVM
++ */
++	else if (strcmp(clk->name, "cdce_mcasp1")) {
++		return 0;
++	}
++/*	Clock setting for TSIF.
++ *	Currently TSIF0 and TSIF1 will be using the same frequency for
++ *	TSIF_OUT if they select the same clock source as external
++ */
++
++	else if (strcmp(clk->name, "cdce_crgo_vc1")) {
++
++	}
++/* Update the clock rate to take new clock value */
++
++	clk->rate = freq_table[i].frequency * 1000;
++	return 0;
++}
++
++static int cdce949_probe(struct i2c_client *client,
++			const struct i2c_device_id *id)
++{
++	cdce_client = client;
++	return 0;
++
++}
++
++static int cdce949_remove(struct i2c_client *client)
++{
++	client = NULL;
++	return 0;
++}
++static const struct i2c_device_id cdce949_id[] = {
++	{"cdce949", 0},
++	{},
++};
++
++
++
++
++static struct i2c_driver cdce949_driver = {
++	.driver = {
++		.owner	= THIS_MODULE,
++		.name	= "cdce949",
++	},
++	.probe		= cdce949_probe,
++	.id_table	= cdce949_id,
++	.remove		= cdce949_remove,
++};
++
++
++
++
++
++static struct clk ref_clk = {
++	.name = "cdce_ref_clk",
++	.rate = CDCE949_REF_CLK,
++};
++
++
++static struct clk cdce_vpif_clk = {
++	.name = "cdce_vpif",
++	.parent = &ref_clk,
++	.rate = CDCE949_REF_CLK,
++	.set_rate = cdce_set_rate,
++};
++
++static struct clk cdce_audio_clk = {
++	.name = "cdce_audio",
++	.parent = &ref_clk,
++	.rate = CDCE949_REF_CLK,
++	.set_rate = cdce_set_rate,
++};
++
++static struct clk cdce_mcasp1_clk = {
++	.name = "cdce_mcasp1",
++	.parent = &ref_clk,
++	.rate = CDCE949_REF_CLK,
++	.set_rate = cdce_set_rate,
++};
++
++static struct clk cdce_crg0_vc1_clk = {
++	.name = "cdce_crg0_vc1",
++	.parent = &ref_clk,
++	.rate = CDCE949_REF_CLK,
++	.set_rate = cdce_set_rate,
++};
++
++struct davinci_clk cdce_clks[] = {
++	CLK(NULL, "cdce_ref_clk", &ref_clk),
++	CLK(NULL, "cdce_vpif", &cdce_vpif_clk),
++	CLK(NULL, "cdce_audio", &cdce_audio_clk),
++	CLK(NULL, "cdce_mcasp1", &cdce_mcasp1_clk),
++	CLK(NULL, "cdce_crg0_vc1", &cdce_crg0_vc1_clk),
++	CLK(NULL, NULL, NULL),
++};
++
++static int __init cdce949_init(void)
++{
++	struct davinci_clk *c;
++	struct clk *clk;
++
++	for (c = cdce_clks; c->lk.clk; c++) {
++		clk = c->lk.clk;
++		clkdev_add(&c->lk);
++		clk_register(clk);
++	}
++
++	return i2c_add_driver(&cdce949_driver);
++}
++
++static void __exit cdce949_exit(void)
++{
++	i2c_del_driver(&cdce949_driver);
++}
++
++
++module_init(cdce949_init);
++module_exit(cdce949_exit);
+--- /dev/null
++++ b/include/media/davinci/dm355_af.h
+@@ -0,0 +1,179 @@
++/*
++ * Copyright (C) 2009 Texas Instruments Inc
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
++ */
++
++#ifndef AF_DM355_DRIVER_H
++#define AF_DM355_DRIVER_H
++
++/* Kernel Header files */
++#include <linux/ioctl.h>
++
++#ifdef __KERNEL__
++#include <linux/kernel.h>
++#include <linux/wait.h>
++#include <linux/mutex.h>
++#include <asm/io.h>
++#endif
++
++#ifdef __KERNEL__
++/* Device Constants */
++#define AF_MAJOR_NUMBER			0
++#define DEVICE_NAME			"dm355_af"
++#define AF_NR_DEVS			1
++#define AF_TIMEOUT			(300 * HZ) / 1000
++#endif
++
++/* Range Constants */
++#define AF_PAXEL_HORIZONTAL_COUNT_MIN	1
++#define AF_PAXEL_HORIZONTAL_COUNT_MAX	36
++#define AF_PAXEL_VERTICAL_COUNT_MIN	1
++#define AF_PAXEL_VERTICAL_COUNT_MAX	128
++#define AF_PAXEL_SIZE			48
++#define AF_WIDTH_MIN			8
++#define AF_WIDTH_MAX			256
++#define AF_LINE_INCR_MIN		2
++#define AF_LINE_INCR_MAX		32
++#define AF_HEIGHT_MIN			2
++#define AF_HEIGHT_MAX			256
++#define AF_HZSTART_MIN			2
++#define AF_HZSTART_MAX			4094
++#define AF_VTSTART_MIN			0
++#define AF_VTSTART_MAX			4095
++#define AF_MEDTH_MAX			255
++#define AF_IIRSH_MAX			4094
++#define AF_COEF_MIN			0xFFFFF800
++#define AF_COEF_MAX			0x000007FF
++#define AF_NUMBER_OF_COEF		11
++
++/* list of ioctls */
++#pragma	pack(1)
++#define	AF_IOC_MAXNR	5
++#define	AF_MAGIC_NO	'a'
++#define	AF_S_PARAM	_IOWR(AF_MAGIC_NO, 1, struct af_configuration *)
++#define	AF_G_PARAM	_IOWR(AF_MAGIC_NO, 2, struct af_configuration *)
++#define	AF_ENABLE	_IO(AF_MAGIC_NO,3)
++#define	AF_DISABLE	_IO(AF_MAGIC_NO,4)
++#pragma	pack()
++
++/* enum used for status of specific feature */
++typedef enum {
++	H3A_AF_DISABLE = 0,
++	H3A_AF_ENABLE = 1
++} af_alaw_enable, af_hmf_enable;
++
++typedef enum {
++	H3A_AF_CONFIG_NOT_DONE,
++	H3A_AF_CONFIG
++} af_config_flag;
++
++struct af_reg_dump {
++	unsigned int addr;
++	unsigned int val;
++};
++
++/* enum used for keep track of whether hardware is used */
++typedef enum {
++	AF_NOT_IN_USE = 0,
++	AF_IN_USE = 1
++} af_In_use;
++
++typedef enum {
++	ACCUMULATOR_SUMMED = 0,
++	ACCUMULATOR_PEAK = 1
++} af_mode;
++
++/* Red, Green, and blue pixel location in the AF windows */
++typedef enum {
++	GR_GB_BAYER = 0,	/* GR and GB as Bayer pattern */
++	RG_GB_BAYER = 1,	/* RG and GB as Bayer pattern */
++	GR_BG_BAYER = 2,	/* GR and BG as Bayer pattern */
++	RG_BG_BAYER = 3,	/* RG and BG as Bayer pattern */
++	GG_RB_CUSTOM = 4,	/* GG and RB as custom pattern */
++	RB_GG_CUSTOM = 5	/* RB and GG as custom pattern */
++} rgbpos;
++
++/* Contains the information regarding the Horizontal Median Filter */
++struct af_hmf {
++	af_hmf_enable enable;
++
++	/* Threshhold Value for orizontal Median Filter  */
++	unsigned int threshold;
++};
++
++/* Contains the information regarding the IIR Filters */
++struct af_iir {
++	unsigned int hz_start_pos;
++
++	/* IIR Filter Coefficient for Set 0 */
++	int coeff_set0[AF_NUMBER_OF_COEF];
++
++	/* IIR Filter Coefficient for Set 1 */
++	int coeff_set1[AF_NUMBER_OF_COEF];
++};
++
++/* Contains the information regarding the Paxels Structure in AF Engine */
++struct af_paxel {
++	unsigned int width;	/* Width of the Paxel */
++	unsigned int height;	/* Height of the Paxel */
++	unsigned int hz_start;	/* Horizontal Start Position */
++	unsigned int vt_start;	/* Vertical Start Position */
++	unsigned int hz_cnt;	/* Horizontal Count */
++	unsigned int vt_cnt;	/* vertical Count */
++	unsigned int line_incr;	/* Line Increment */
++};
++
++/* Contains the parameters required for hardware set up of AF Engine */
++struct af_configuration {
++	af_alaw_enable alaw_enable;	/*ALAW status */
++	struct af_hmf hmf_config;	/*HMF configurations */
++	rgbpos rgb_pos;			/*RGB Positions */
++	struct af_iir iir_config;	/*IIR filter configurations */
++	struct af_paxel paxel_config;	/*Paxel parameters */
++	af_mode mode;			/*Accumulator mode */
++};
++
++#ifdef __KERNEL__
++/* Structure for device of AF Engine */
++struct af_device {
++	af_In_use in_use;
++
++	/*Device configuration structure */
++	struct af_configuration *config;
++	void *buff_old;		/*Contains the latest statistics */
++	void *buff_curr;	/*Buffer in which HW will */
++
++	/*
++	 * Fill the statistics
++	 * or HW is already filling statistics
++	 */
++
++	void *buff_app;
++
++	/* User space on read call */
++	unsigned int buff_size;	/* Size of image buffer */
++	int buffer_filled;	/* Flag indicates */
++
++	/*statistics are available */
++	int size_paxel;				/*Paxel size in bytes */
++	wait_queue_head_t af_wait_queue;	/*Wait queue for driver */
++	/* mutex for driver */
++	struct mutex read_blocked;
++	/* Flag indicates Engine is configured */
++	af_config_flag af_config;
++};
++#endif				/* __KERNEL__ */
++#endif				/* AF_DM355_DRIVER_H */
+--- a/arch/arm/mach-davinci/da850.c
++++ b/arch/arm/mach-davinci/da850.c
+@@ -30,12 +30,17 @@
+ #include "clock.h"
+ #include "mux.h"
+ 
++/* SoC specific clock flags */
++#define DA850_CLK_ASYNC3	BIT(16)
++
+ #define DA850_PLL1_BASE		0x01e1a000
+ #define DA850_TIMER64P2_BASE	0x01f0c000
+ #define DA850_TIMER64P3_BASE	0x01f0d000
+ 
+ #define DA850_REF_FREQ		24000000
+ 
++#define CFGCHIP3_ASYNC3_CLKSRC	BIT(4)
++
+ static struct pll_data pll0_data = {
+ 	.num		= 1,
+ 	.phys_base	= DA8XX_PLL0_BASE,
+@@ -232,6 +237,7 @@ static struct clk uart1_clk = {
+ 	.name		= "uart1",
+ 	.parent		= &pll0_sysclk2,
+ 	.lpsc		= DA8XX_LPSC1_UART1,
++	.flags		= DA850_CLK_ASYNC3,
+ 	.psc_ctlr	= 1,
+ };
+ 
+@@ -239,6 +245,7 @@ static struct clk uart2_clk = {
+ 	.name		= "uart2",
+ 	.parent		= &pll0_sysclk2,
+ 	.lpsc		= DA8XX_LPSC1_UART2,
++	.flags		= DA850_CLK_ASYNC3,
+ 	.psc_ctlr	= 1,
+ };
+ 
+@@ -506,8 +513,8 @@ static const struct mux_config da850_pin
+ 	MUX_CFG(DA850, EMA_WAIT_1,	6,	24,	15,	1,	false)
+ 	MUX_CFG(DA850, NEMA_CS_2,	7,	0,	15,	1,	false)
+ 	/* GPIO function */
++	MUX_CFG(DA850, GPIO2_8,		5,	28,	15,	8,	false)
+ 	MUX_CFG(DA850, GPIO2_15,	5,	0,	15,	8,	false)
+-	MUX_CFG(DA850, GPIO8_10,	18,	28,	15,	8,	false)
+ 	MUX_CFG(DA850, GPIO4_0,		10,	28,	15,	8,	false)
+ 	MUX_CFG(DA850, GPIO4_1,		10,	24,	15,	8,	false)
+ #endif
+@@ -555,12 +562,11 @@ const short da850_mcasp_pins[] __initdat
+ };
+ 
+ const short da850_lcdcntl_pins[] __initdata = {
+-	DA850_LCD_D_1, DA850_LCD_D_2, DA850_LCD_D_3, DA850_LCD_D_4,
+-	DA850_LCD_D_5, DA850_LCD_D_6, DA850_LCD_D_7, DA850_LCD_D_8,
+-	DA850_LCD_D_9, DA850_LCD_D_10, DA850_LCD_D_11, DA850_LCD_D_12,
+-	DA850_LCD_D_13, DA850_LCD_D_14, DA850_LCD_D_15, DA850_LCD_PCLK,
+-	DA850_LCD_HSYNC, DA850_LCD_VSYNC, DA850_NLCD_AC_ENB_CS, DA850_GPIO2_15,
+-	DA850_GPIO8_10,
++	DA850_LCD_D_0, DA850_LCD_D_1, DA850_LCD_D_2, DA850_LCD_D_3,
++	DA850_LCD_D_4, DA850_LCD_D_5, DA850_LCD_D_6, DA850_LCD_D_7,
++	DA850_LCD_D_8, DA850_LCD_D_9, DA850_LCD_D_10, DA850_LCD_D_11,
++	DA850_LCD_D_12, DA850_LCD_D_13, DA850_LCD_D_14, DA850_LCD_D_15,
++	DA850_LCD_PCLK, DA850_LCD_HSYNC, DA850_LCD_VSYNC, DA850_NLCD_AC_ENB_CS,
+ 	-1
+ };
+ 
+@@ -790,16 +796,38 @@ static struct davinci_timer_info da850_t
+ 	.clocksource_id	= T0_TOP,
+ };
+ 
++static void da850_set_async3_src(int pllnum)
++{
++	struct clk *clk, *newparent = pllnum ? &pll1_sysclk2 : &pll0_sysclk2;
++	struct davinci_clk *c;
++	unsigned int v;
++	int ret;
++
++	for (c = da850_clks; c->lk.clk; c++) {
++		clk = c->lk.clk;
++		if (clk->flags & DA850_CLK_ASYNC3) {
++			ret = clk_set_parent(clk, newparent);
++			WARN(ret, "DA850: unable to re-parent clock %s",
++								clk->name);
++		}
++       }
++
++	v = __raw_readl(DA8XX_SYSCFG_VIRT(DA8XX_CFGCHIP3_REG));
++	if (pllnum)
++		v |= CFGCHIP3_ASYNC3_CLKSRC;
++	else
++		v &= ~CFGCHIP3_ASYNC3_CLKSRC;
++	__raw_writel(v, DA8XX_SYSCFG_VIRT(DA8XX_CFGCHIP3_REG));
++}
++
+ static struct davinci_soc_info davinci_soc_info_da850 = {
+ 	.io_desc		= da850_io_desc,
+ 	.io_desc_num		= ARRAY_SIZE(da850_io_desc),
+-	.jtag_id_base		= IO_ADDRESS(DA8XX_JTAG_ID_REG),
+ 	.ids			= da850_ids,
+ 	.ids_num		= ARRAY_SIZE(da850_ids),
+ 	.cpu_clks		= da850_clks,
+ 	.psc_bases		= da850_psc_bases,
+ 	.psc_bases_num		= ARRAY_SIZE(da850_psc_bases),
+-	.pinmux_base		= IO_ADDRESS(DA8XX_BOOT_CFG_BASE + 0x120),
+ 	.pinmux_pins		= da850_pins,
+ 	.pinmux_pins_num	= ARRAY_SIZE(da850_pins),
+ 	.intc_base		= (void __iomem *)DA8XX_CP_INTC_VIRT,
+@@ -816,5 +844,22 @@ static struct davinci_soc_info davinci_s
+ 
+ void __init da850_init(void)
+ {
++	da8xx_syscfg_base = ioremap(DA8XX_SYSCFG_BASE, SZ_4K);
++	if (WARN(!da8xx_syscfg_base, "Unable to map syscfg module"))
++		return;
++
++	davinci_soc_info_da850.jtag_id_base =
++					DA8XX_SYSCFG_VIRT(DA8XX_JTAG_ID_REG);
++	davinci_soc_info_da850.pinmux_base = DA8XX_SYSCFG_VIRT(0x120);
++
+ 	davinci_common_init(&davinci_soc_info_da850);
++
++	/*
++	 * Move the clock source of Async3 domain to PLL1 SYSCLK2.
++	 * This helps keeping the peripherals on this domain insulated
++	 * from CPU frequency changes caused by DVFS. The firmware sets
++	 * both PLL0 and PLL1 to the same frequency so, there should not
++	 * be any noticible change even in non-DVFS use cases.
++	 */
++	da850_set_async3_src(1);
+ }
+--- a/arch/arm/mach-davinci/dm644x.c
++++ b/arch/arm/mach-davinci/dm644x.c
+@@ -28,6 +28,8 @@
+ #include <mach/serial.h>
+ #include <mach/common.h>
+ #include <mach/asp.h>
++#include <video/davinci_osd.h>
++#include <video/davinci_vpbe.h>
+ 
+ #include "clock.h"
+ #include "mux.h"
+@@ -476,15 +478,6 @@ static u8 dm644x_default_priorities[DAVI
+ 
+ /*----------------------------------------------------------------------*/
+ 
+-static const s8 dma_chan_dm644x_no_event[] = {
+-	 0,  1, 12, 13, 14,
+-	15, 25, 30, 31, 45,
+-	46, 47, 55, 56, 57,
+-	58, 59, 60, 61, 62,
+-	63,
+-	-1
+-};
+-
+ static const s8
+ queue_tc_mapping[][2] = {
+ 	/* {event queue no, TC no} */
+@@ -508,7 +501,6 @@ static struct edma_soc_info dm644x_edma_
+ 		.n_slot			= 128,
+ 		.n_tc			= 2,
+ 		.n_cc			= 1,
+-		.noevent		= dma_chan_dm644x_no_event,
+ 		.queue_tc_mapping	= queue_tc_mapping,
+ 		.queue_priority_mapping	= queue_priority_mapping,
+ 	},
+@@ -609,6 +601,11 @@ static struct resource vpfe_resources[]
+ 		.end            = IRQ_VDINT1,
+ 		.flags          = IORESOURCE_IRQ,
+ 	},
++};
++
++static u64 vpfe_capture_dma_mask = DMA_BIT_MASK(32);
++static struct resource dm644x_ccdc_resource[] = {
++	/* CCDC Base address */
+ 	{
+ 		.start          = 0x01c70400,
+ 		.end            = 0x01c70400 + 0xff,
+@@ -616,7 +613,17 @@ static struct resource vpfe_resources[]
+ 	},
+ };
+ 
+-static u64 vpfe_capture_dma_mask = DMA_BIT_MASK(32);
++static struct platform_device dm644x_ccdc_dev = {
++	.name           = "dm644x_ccdc",
++	.id             = -1,
++	.num_resources  = ARRAY_SIZE(dm644x_ccdc_resource),
++	.resource       = dm644x_ccdc_resource,
++	.dev = {
++		.dma_mask               = &vpfe_capture_dma_mask,
++		.coherent_dma_mask      = DMA_BIT_MASK(32),
++	},
++};
++
+ static struct platform_device vpfe_capture_dev = {
+ 	.name		= CAPTURE_DRV_NAME,
+ 	.id		= -1,
+@@ -634,6 +641,64 @@ void dm644x_set_vpfe_config(struct vpfe_
+ }
+ 
+ /*----------------------------------------------------------------------*/
++static u64 dm644x_osd_dma_mask = DMA_BIT_MASK(32);
++
++static struct davinci_osd_platform_data dm644x_osd_pdata = {
++	.type = DM6446,
++};
++
++static struct resource dm644x_osd_resources[] = {
++	{
++		.start          = IRQ_VENCINT,
++		.end            = IRQ_VENCINT,
++		.flags          = IORESOURCE_IRQ,
++	},
++	{
++		.start          = DM644X_OSD_REG_BASE,
++		.end            = DM644X_OSD_REG_BASE + 0x200,
++		.flags          = IORESOURCE_MEM,
++	},
++};
++
++static struct platform_device dm644x_osd_dev = {
++	.name		= "davinci_osd",
++	.id		= -1,
++	.num_resources	= ARRAY_SIZE(dm644x_osd_resources),
++	.resource	= dm644x_osd_resources,
++	.dev = {
++		.dma_mask		= &dm644x_osd_dma_mask,
++		.coherent_dma_mask	= DMA_BIT_MASK(32),
++		.platform_data		= &dm644x_osd_pdata,
++	},
++};
++
++static u64 dm644x_venc_dma_mask = DMA_BIT_MASK(32);
++
++
++static struct davinci_venc_platform_data dm644x_venc_pdata = {
++	.soc = DM644x,
++};
++
++
++static struct resource dm644x_venc_resources[] = {
++	{
++		.start          = DM644X_VENC_REG_BASE,
++		.end            = DM644X_VENC_REG_BASE + 0x180,
++		.flags          = IORESOURCE_MEM,
++	},
++};
++
++static struct platform_device dm644x_venc_dev = {
++	.name		= "davinci_venc",
++	.id		= -1,
++	.num_resources	= ARRAY_SIZE(dm644x_venc_resources),
++	.resource	= dm644x_venc_resources,
++	.dev = {
++		.dma_mask		= &dm644x_venc_dma_mask,
++		.coherent_dma_mask	= DMA_BIT_MASK(32),
++		.platform_data		= &dm644x_venc_pdata,
++	},
++};
+ 
+ static struct map_desc dm644x_io_desc[] = {
+ 	{
+@@ -769,8 +834,15 @@ static int __init dm644x_init_devices(vo
+ 	platform_device_register(&dm644x_edma_device);
+ 	platform_device_register(&dm644x_emac_device);
+ 	platform_device_register(&dm644x_vpss_device);
++	platform_device_register(&dm644x_ccdc_dev);
+ 	platform_device_register(&vpfe_capture_dev);
+ 
++	/* Register OSD device */
++	platform_device_register(&dm644x_osd_dev);
++
++	/* Register VENC device */
++	platform_device_register(&dm644x_venc_dev);
++
+ 	return 0;
+ }
+ postcore_initcall(dm644x_init_devices);
+--- a/arch/arm/mach-davinci/board-da850-evm.c
++++ b/arch/arm/mach-davinci/board-da850-evm.c
+@@ -32,12 +32,13 @@
+ #include <mach/cp_intc.h>
+ #include <mach/da8xx.h>
+ #include <mach/nand.h>
++#include <mach/mux.h>
+ 
+ #define DA850_EVM_PHY_MASK		0x1
+ #define DA850_EVM_MDIO_FREQUENCY	2200000 /* PHY bus frequency */
+ 
++#define DA850_LCD_PWR_PIN		GPIO_TO_PIN(2, 8)
+ #define DA850_LCD_BL_PIN		GPIO_TO_PIN(2, 15)
+-#define DA850_LCD_PWR_PIN		GPIO_TO_PIN(8, 10)
+ 
+ #define DA850_MMCSD_CD_PIN		GPIO_TO_PIN(4, 0)
+ #define DA850_MMCSD_WP_PIN		GPIO_TO_PIN(4, 1)
+@@ -264,6 +265,11 @@ static void __init da850_evm_init_nor(vo
+ #define HAS_MMC 0
+ #endif
+ 
++static const short da850_evm_lcdc_pins[] = {
++	DA850_GPIO2_8, DA850_GPIO2_15,
++	-1
++};
++
+ static __init void da850_evm_init(void)
+ {
+ 	struct davinci_soc_info *soc_info = &davinci_soc_info;
+@@ -365,22 +371,32 @@ static __init void da850_evm_init(void)
+ 		pr_warning("da850_evm_init: mcasp mux setup failed: %d\n",
+ 				ret);
+ 
+-	da8xx_init_mcasp(0, &da850_evm_snd_data);
++	da8xx_register_mcasp(0, &da850_evm_snd_data);
+ 
+ 	ret = da8xx_pinmux_setup(da850_lcdcntl_pins);
+ 	if (ret)
+ 		pr_warning("da850_evm_init: lcdcntl mux setup failed: %d\n",
+ 				ret);
+ 
++	/* Handle board specific muxing for LCD here */
++	ret = da8xx_pinmux_setup(da850_evm_lcdc_pins);
++	if (ret)
++		pr_warning("da850_evm_init: evm specific lcd mux setup "
++				"failed: %d\n",	ret);
++
+ 	ret = da850_lcd_hw_init();
+ 	if (ret)
+ 		pr_warning("da850_evm_init: lcd initialization failed: %d\n",
+ 				ret);
+ 
+-	ret = da8xx_register_lcdc();
++	ret = da8xx_register_lcdc(&sharp_lk043t1dg01_pdata);
+ 	if (ret)
+ 		pr_warning("da850_evm_init: lcdc registration failed: %d\n",
+ 				ret);
++
++	ret = da8xx_register_rtc();
++	if (ret)
++		pr_warning("da850_evm_init: rtc setup failed: %d\n", ret);
+ }
+ 
+ #ifdef CONFIG_SERIAL_8250_CONSOLE
+--- /dev/null
++++ b/include/media/davinci/logicpd_encoder.h
+@@ -0,0 +1,55 @@
++/*
++ * Copyright (C) 2007 Texas Instruments Inc
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
++ */
++
++#ifndef LOGICPD_ENCODER_H
++#define LOGICPD_ENCODER_H
++
++#ifdef __KERNEL__
++/* Kernel Header files */
++#include <linux/i2c.h>
++#include <linux/device.h>
++#endif
++
++#ifdef __KERNEL__
++/* encoder standard related strctures */
++#define LOGICPD_ENCODER_MAX_NO_OUTPUTS		    (1)
++#define LOGICPD_ENCODER_GRAPHICS_NUM_STD		(4)
++
++struct logicpd_encoder_params {
++	int outindex;
++	char *mode;
++};
++
++struct logicpd_encoder_config {
++	int no_of_outputs;
++	struct {
++		char *output_name;
++		int no_of_standard;
++		struct vid_enc_mode_info
++		 standards[LOGICPD_ENCODER_GRAPHICS_NUM_STD];
++	} output[LOGICPD_ENCODER_MAX_NO_OUTPUTS];
++};
++
++struct logicpd_encoder_channel {
++	struct encoder_device *enc_device;
++	struct logicpd_encoder_params params;
++};
++
++#endif				/* End of #ifdef __KERNEL__ */
++
++#endif				/* End of #ifndef LOGICPD_ENCODER_H */
+--- /dev/null
++++ b/include/media/davinci/dm365_aew.h
+@@ -0,0 +1,199 @@
++/* *
++ * Copyright (C) 2009 Texas Instruments Inc
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
++ */
++#ifndef DM365_AEW_DRIVER_H
++#define DM365_AEW_DRIVER_H
++
++#include <linux/ioctl.h>
++#ifdef __KERNEL__
++#include <linux/wait.h>
++#include <linux/mutex.h>
++#include <asm/io.h>
++#endif				/* end of #ifdef __KERNEL__ */
++
++/* Driver Range Constants */
++#define AEW_WINDOW_VERTICAL_COUNT_MIN		1
++#define AEW_WINDOW_VERTICAL_COUNT_MAX		128
++#define AEW_WINDOW_HORIZONTAL_COUNT_MIN		2
++#define AEW_WINDOW_HORIZONTAL_COUNT_MAX		36
++
++#define AEW_WIDTH_MIN				8
++#define AEW_WIDTH_MAX				256
++
++#define AEW_AVELMT_MAX				1023
++
++#define AEW_HZ_LINEINCR_MIN			2
++#define AEW_HZ_LINEINCR_MAX			32
++
++#define AEW_VT_LINEINCR_MIN			2
++#define AEW_VT_LINEINCR_MAX			32
++
++#define AEW_HEIGHT_MIN				2
++#define AEW_HEIGHT_MAX				256
++
++#define AEW_HZSTART_MIN				0
++#define AEW_HZSTART_MAX				4095
++
++#define AEW_VTSTART_MIN				0
++#define AEW_VTSTART_MAX				4095
++
++#define AEW_BLKWINHEIGHT_MIN			2
++#define AEW_BLKWINHEIGHT_MAX			256
++
++#define AEW_BLKWINVTSTART_MIN			0
++#define AEW_BLKWINVTSTART_MAX			4095
++
++#define AEW_SUMSHIFT_MAX			15
++
++/* Statistics data size per window */
++#define AEW_WINDOW_SIZE				32
++#define AEW_WINDOW_SIZE_SUM_ONLY		16
++
++#ifdef __KERNEL__
++
++/* Device Constants */
++#define AEW_NR_DEVS				1
++#define AEW_DEVICE_NAME				"dm365_aew"
++#define AEW_MAJOR_NUMBER			0
++#define AEW_IOC_MAXNR				4
++#define AEW_TIMEOUT				((300 * HZ) / 1000)
++#endif
++
++
++/* List of ioctls */
++#pragma pack(1)
++#define AEW_MAGIC_NO	'e'
++#define AEW_S_PARAM	_IOWR(AEW_MAGIC_NO, 1, struct aew_configuration *)
++#define AEW_G_PARAM	_IOWR(AEW_MAGIC_NO, 2, struct aew_configuration *)
++#define AEW_ENABLE	_IO(AEW_MAGIC_NO, 3)
++#define AEW_DISABLE	_IO(AEW_MAGIC_NO, 4)
++#pragma  pack()
++
++/* Enum for device usage */
++enum aew_in_use_flag {
++	/* Device is not in use */
++	AEW_NOT_IN_USE,
++	/* Device in use */
++	AEW_IN_USE
++};
++
++/* Enum for Enable/Disable specific feature */
++enum aew_enable_flag {
++	H3A_AEW_DISABLE,
++	H3A_AEW_ENABLE
++};
++
++enum aew_config_flag {
++	H3A_AEW_CONFIG_NOT_DONE,
++	H3A_AEW_CONFIG
++};
++
++
++/* Contains the information regarding Window Structure in AEW Engine */
++struct aew_window {
++	/* Width of the window */
++	unsigned int width;
++	/* Height of the window */
++	unsigned int height;
++	/* Horizontal Start of the window */
++	unsigned int hz_start;
++	/* Vertical Start of the window */
++	unsigned int vt_start;
++	/* Horizontal Count */
++	unsigned int hz_cnt;
++	/* Vertical Count */
++	unsigned int vt_cnt;
++	/* Horizontal Line Increment */
++	unsigned int hz_line_incr;
++	/* Vertical Line Increment */
++	unsigned int vt_line_incr;
++};
++
++/* Contains the information regarding the AEW Black Window Structure */
++struct aew_black_window {
++	/* Height of the Black Window */
++	unsigned int height;
++	/* Vertical Start of the black Window */
++	unsigned int vt_start;
++};
++
++/* Contains the information regarding the Horizontal Median Filter */
++struct aew_hmf {
++	/* Status of Horizontal Median Filter */
++	enum aew_enable_flag enable;
++	/* Threshhold Value for Horizontal Median Filter. Make sure
++	 * to keep this same as AF threshold since we have a common
++	 * threshold for both
++	 */
++	unsigned int threshold;
++};
++
++/* AE/AWB output format */
++enum aew_output_format {
++	AEW_OUT_SUM_OF_SQUARES,
++	AEW_OUT_MIN_MAX,
++	AEW_OUT_SUM_ONLY
++};
++
++/* Contains configuration required for setup of AEW engine */
++struct aew_configuration {
++	/* A-law status */
++	enum aew_enable_flag alaw_enable;
++	/* AE/AWB output format */
++	enum aew_output_format out_format;
++	/* AW/AWB right shift value for sum of pixels */
++	char sum_shift;
++	/* Saturation Limit */
++	int saturation_limit;
++	/* HMF configurations */
++	struct aew_hmf hmf_config;
++	/* Window for AEW Engine */
++	struct aew_window window_config;
++	/* Black Window */
++	struct aew_black_window blackwindow_config;
++};
++#ifdef __KERNEL__
++/* Contains information about device structure of AEW*/
++struct aew_device {
++	/* Driver usage flag */
++	enum aew_in_use_flag in_use;
++	/* Device configuration */
++	struct aew_configuration *config;
++	/* Contains latest statistics */
++	void *buff_old;
++	/* Buffer in which HW will fill the statistics or HW is already
++	 * filling
++	 */
++	void *buff_curr;
++	/* statistics Buffer which will be passed */
++	void *buff_app;
++	/* to user on read call. Flag indicates statistics are available */
++	int buffer_filled;
++	/* Window size in bytes */
++	unsigned int size_window;
++	/* Wait queue for the driver */
++	wait_queue_head_t aew_wait_queue;
++	/* Mutex for driver */
++	struct mutex read_blocked;
++	/* Flag indicates Engine is configured */
++	enum aew_config_flag aew_config;
++};
++
++int aew_hardware_setup(void);
++int aew_validate_parameters(void);
++#endif				/* End of #ifdef __KERNEL__ */
++#endif				/*End of DM365_AEW_H */
+--- /dev/null
++++ b/drivers/char/dm3xx_ipipe.c
+@@ -0,0 +1,430 @@
++/*
++ * Copyright (C) 2008-2009 Texas Instruments Inc
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
++ *
++ * ipipe module to hold common functionality across DM355 and DM365 */
++#include <linux/kernel.h>
++#include <linux/platform_device.h>
++#include <linux/uaccess.h>
++#include <linux/io.h>
++#include <media/davinci/dm3xx_ipipe.h>
++
++static void *__iomem ipipeif_base_addr;
++
++#define DM355	0
++#define DM365	1
++static int device_type;
++
++static inline u32 regr_if(u32 offset)
++{
++	 return __raw_readl(ipipeif_base_addr + offset);
++}
++
++static inline void regw_if(u32 val, u32 offset)
++{
++	__raw_writel(val, ipipeif_base_addr + offset);
++}
++
++void ipipeif_set_enable(char en, unsigned int mode)
++{
++	regw_if(1, IPIPEIF_ENABLE);
++}
++
++u32 ipipeif_get_enable(void)
++{
++	return regr_if(IPIPEIF_ENABLE);
++}
++
++int ipipeif_set_address(struct ipipeif *params, unsigned int address)
++{
++	unsigned int utemp, utemp1;
++	if (params->source != 0) {
++		utemp = ((params->adofs >> 5) & IPIPEIF_ADOFS_LSB_MASK);
++		regw_if(utemp, IPIPEIF_ADOFS);
++
++		/* lower sixteen bit */
++		utemp = ((address >> IPIPEIF_ADDRL_SHIFT) & IPIPEIF_ADDRL_MASK);
++		regw_if(utemp, IPIPEIF_ADDRL);
++
++		/* upper next seven bit */
++		utemp1 =
++		    ((address >> IPIPEIF_ADDRU_SHIFT) & IPIPEIF_ADDRU_MASK);
++		regw_if(utemp1, IPIPEIF_ADDRU);
++	} else
++		return -1;
++	return 0;
++}
++
++static void ipipeif_config_dpc(struct ipipeif_dpc *dpc)
++{
++	u32 utemp = 0;
++	if (dpc->en) {
++		utemp = ((dpc->en & 1) << IPIPEIF_DPC2_EN_SHIFT);
++		utemp |= (dpc->thr & IPIPEIF_DPC2_THR_MASK);
++	}
++	regw_if(utemp, IPIPEIF_DPC2);
++}
++
++/* This function sets up IPIPEIF and is called from
++ * ipipe_hw_setup()
++ */
++int ipipeif_hw_setup(struct ipipeif *params)
++{
++	unsigned int utemp = 0, utemp1 = 0x7;
++	enum vpfe_hw_if_type isif_port_if;
++
++	if (NULL == params)
++		return -1;
++	/* Enable clock to IPIPEIF and IPIPE */
++	if (device_type == DM365)
++		vpss_enable_clock(VPSS_IPIPEIF_CLOCK, 1);
++	/* Combine all the fields to make CFG1 register of IPIPEIF */
++	utemp = params->mode << ONESHOT_SHIFT;
++	utemp |= params->source << INPSRC_SHIFT;
++	utemp |= params->clock_select << CLKSEL_SHIFT;
++	utemp |= params->avg_filter << AVGFILT_SHIFT;
++	utemp |= params->decimation << DECIM_SHIFT;
++
++	if (device_type == DM355) {
++		utemp |= params->var.if_base.ialaw << IALAW_SHIFT;
++		utemp |= params->var.if_base.pack_mode << PACK8IN_SHIFT;
++		utemp |= params->var.if_base.clk_div << CLKDIV_SHIFT;
++		utemp |= params->var.if_base.data_shift << DATASFT_SHIFT;
++	} else {
++		/* DM365 IPIPE 5.1 */
++		utemp |= params->var.if_5_1.pack_mode << PACK8IN_SHIFT;
++		utemp |= params->var.if_5_1.source1 << INPSRC1_SHIFT;
++		if (params->source != SDRAM_YUV)
++			utemp |= params->var.if_5_1.data_shift << DATASFT_SHIFT;
++		else
++			utemp &= (~(utemp1 << DATASFT_SHIFT));
++	}
++	regw_if(utemp, IPIPEIF_GFG1);
++
++	switch (params->source) {
++	case CCDC:
++		{
++			regw_if(params->gain, IPIPEIF_GAIN);
++			break;
++		}
++	case SDRAM_RAW:
++	case CCDC_DARKFM:
++		{
++			regw_if(params->gain, IPIPEIF_GAIN);
++			/* fall through */
++		}
++	case SDRAM_YUV:
++		{
++			utemp |= params->var.if_5_1.data_shift << DATASFT_SHIFT;
++			regw_if(params->glob_hor_size, IPIPEIF_PPLN);
++			regw_if(params->glob_ver_size, IPIPEIF_LPFR);
++			regw_if(params->hnum, IPIPEIF_HNUM);
++			regw_if(params->vnum, IPIPEIF_VNUM);
++			if (device_type == DM355) {
++//TODO
++#if 0
++				utemp = regr_vpss(DM355_VPSSBL_PCR);
++				/* IPIPEIF read master */
++				RESETBIT(utemp, 4);
++				RESETBIT(utemp, 5);
++				regw_vpss(utemp, DM355_VPSSBL_PCR);
++#endif
++			}
++			break;
++		}
++	default:
++		/* Do nothing */
++		;
++	}
++
++	/*check if decimation is enable or not */
++	if (params->decimation)
++		regw_if(params->rsz, IPIPEIF_RSZ);
++	if (device_type == DM365) {
++		/* Setup sync alignment and initial rsz position */
++		utemp = params->var.if_5_1.align_sync & 1;
++		utemp <<= IPIPEIF_INIRSZ_ALNSYNC_SHIFT;
++		utemp |= (params->var.if_5_1.rsz_start & IPIPEIF_INIRSZ_MASK);
++		regw_if(utemp, IPIPEIF_INIRSZ);
++
++		/* Enable DPCM decompression */
++		switch (params->source) {
++		case SDRAM_RAW:
++			{
++				utemp = 0;
++				if (params->var.if_5_1.dpcm.en) {
++					utemp = params->var.if_5_1.dpcm.en & 1;
++					utemp |= (params->var.if_5_1.dpcm.type
++						  & 1)
++					    << IPIPEIF_DPCM_BITS_SHIFT;
++					utemp |=
++					    (params->var.if_5_1.dpcm.pred & 1)
++					    << IPIPEIF_DPCM_PRED_SHIFT;
++				}
++				regw_if(utemp, IPIPEIF_DPCM);
++
++				/* set DPC */
++				ipipeif_config_dpc(&params->var.if_5_1.dpc);
++
++				regw_if(params->var.if_5_1.clip, IPIPEIF_OCLIP);
++				/* fall through for SDRAM YUV mode */
++				isif_port_if =
++				    params->var.if_5_1.isif_port.if_type;
++				/* configure CFG2 */
++				switch (isif_port_if) {
++					case VPFE_YCBCR_SYNC_16:
++						utemp |=
++						    (0 <<
++						     IPIPEIF_CFG2_YUV8_SHIFT);
++						utemp |=
++						    (1 <<
++						     IPIPEIF_CFG2_YUV16_SHIFT);
++						regw_if(utemp, IPIPEIF_CFG2);
++						break;
++					default:
++						utemp |=
++						    (0 <<
++						     IPIPEIF_CFG2_YUV8_SHIFT);
++						utemp |=
++						    (0 <<
++						     IPIPEIF_CFG2_YUV16_SHIFT);
++						regw_if(utemp, IPIPEIF_CFG2);
++						break;
++
++					}
++			}
++		case SDRAM_YUV:
++			{
++				/* Set clock divider */
++				if (params->clock_select == SDRAM_CLK) {
++					utemp |=
++					    ((params->var.if_5_1.clk_div.m - 1)
++					     << IPIPEIF_CLKDIV_M_SHIFT);
++					utemp |=
++					    (params->var.if_5_1.clk_div.n - 1);
++					regw_if(utemp, IPIPEIF_CLKDIV);
++				}
++				break;
++			}
++		case CCDC:
++		case CCDC_DARKFM:
++			{
++				/* set DPC */
++				ipipeif_config_dpc(&params->var.if_5_1.dpc);
++
++				/* Set DF gain & threshold control */
++				utemp = 0;
++				if (params->var.if_5_1.df_gain_en) {
++					utemp = (params->var.if_5_1.df_gain_thr
++						 & IPIPEIF_DF_GAIN_THR_MASK);
++					regw_if(utemp, IPIPEIF_DFSGTH);
++					utemp = ((params->var.if_5_1.df_gain_en
++						  & 1)
++						 << IPIPEIF_DF_GAIN_EN_SHIFT);
++					utemp |= (params->var.if_5_1.df_gain
++						  & IPIPEIF_DF_GAIN_MASK);
++				}
++				regw_if(utemp, IPIPEIF_DFSGVL);
++
++				isif_port_if =
++				    params->var.if_5_1.isif_port.if_type;
++				/* configure CFG2 */
++				utemp =
++				    params->var.if_5_1.isif_port.hdpol
++				    << IPIPEIF_CFG2_HDPOL_SHIFT;
++				utemp |=
++				    params->var.if_5_1.isif_port.vdpol
++				    << IPIPEIF_CFG2_VDPOL_SHIFT;
++				switch (isif_port_if) {
++				case VPFE_YCBCR_SYNC_16:
++				case VPFE_BT1120:
++					{
++						utemp |=
++						    (0 <<
++						     IPIPEIF_CFG2_YUV8_SHIFT);
++						utemp |=
++						    (1 <<
++						     IPIPEIF_CFG2_YUV16_SHIFT);
++						break;
++					}
++				case VPFE_BT656:
++				case VPFE_YCBCR_SYNC_8:
++				case VPFE_BT656_10BIT:
++					{
++						utemp |=
++						    (1 <<
++						     IPIPEIF_CFG2_YUV8_SHIFT);
++						utemp |=
++						    (1 <<
++						     IPIPEIF_CFG2_YUV16_SHIFT);
++						utemp |=
++						    ((params->var.if_5_1.
++						      pix_order)
++						     <<
++						     IPIPEIF_CFG2_YUV8P_SHIFT);
++						break;
++					}
++				default:
++					{
++						/* Bayer */
++						regw_if(params->var.if_5_1.clip,
++							IPIPEIF_OCLIP);
++						utemp |=
++						    (0 <<
++						     IPIPEIF_CFG2_YUV16_SHIFT);
++					}
++				}
++				regw_if(utemp, IPIPEIF_CFG2);
++				break;
++			}
++		default:
++			/* do nothing */
++			;
++		}
++	}
++	return 0;
++}
++
++#ifdef CONFIG_IMP_DEBUG
++void ipipeif_dump_register(void)
++{
++	u32 utemp;
++	printk(KERN_NOTICE "IPIPEIF Registers\n");
++	printk(KERN_NOTICE
++	       "**************************************************\n");
++	utemp = regr_if(IPIPEIF_ENABLE);
++	printk(KERN_NOTICE "IPIPEIF ENABLE = 0x%x\n", utemp);
++	utemp = regr_if(IPIPEIF_GFG1);
++	printk(KERN_NOTICE "IPIPEIF CFG = 0x%x\n", utemp);
++	utemp = regr_if(IPIPEIF_PPLN);
++	printk(KERN_NOTICE "IPIPEIF PPLN = 0x%x\n", utemp);
++	utemp = regr_if(IPIPEIF_LPFR);
++	printk(KERN_NOTICE "IPIPEIF LPFR = 0x%x\n", utemp);
++	utemp = regr_if(IPIPEIF_HNUM);
++	printk(KERN_NOTICE "IPIPEIF HNUM = 0x%x\n", utemp);
++	utemp = regr_if(IPIPEIF_VNUM);
++	printk(KERN_NOTICE "IPIPEIF VNUM = 0x%x\n", utemp);
++	utemp = regr_if(IPIPEIF_ADDRU);
++	printk(KERN_NOTICE "IPIPEIF ADDRU = 0x%x\n", utemp);
++	utemp = regr_if(IPIPEIF_ADDRL);
++	printk(KERN_NOTICE "IPIPEIF ADDRL = 0x%x\n", utemp);
++	utemp = regr_if(IPIPEIF_ADOFS);
++	printk(KERN_NOTICE "IPIPEIF ADOFS = 0x%x\n", utemp);
++	utemp = regr_if(IPIPEIF_RSZ);
++	printk(KERN_NOTICE "IPIPEIF RSZ = 0x%x\n", utemp);
++	utemp = regr_if(IPIPEIF_GAIN);
++	printk(KERN_NOTICE "IPIPEIF GAIN = 0x%x\n", utemp);
++	utemp = regr_if(IPIPEIF_DPCM);
++	printk(KERN_NOTICE "IPIPEIF DPCM = 0x%x\n", utemp);
++	utemp = regr_if(IPIPEIF_CFG2);
++	printk(KERN_NOTICE "IPIPEIF CFG2 = 0x%x\n", utemp);
++	utemp = regr_if(IPIPEIF_INIRSZ);
++	printk(KERN_NOTICE "IPIPEIF INIRSZ = 0x%x\n", utemp);
++	utemp = regr_if(IPIPEIF_OCLIP);
++	printk(KERN_NOTICE "IPIPEIF OCLIP = %x\n", utemp);
++	utemp = regr_if(IPIPEIF_DTUDF);
++	printk(KERN_NOTICE "IPIPEIF DTUDF = %x\n", utemp);
++	utemp = regr_if(IPIPEIF_CLKDIV);
++	printk(KERN_NOTICE "IPIPEIF CLKDIV = %x\n", utemp);
++	utemp = regr_if(IPIPEIF_DPC1);
++	printk(KERN_NOTICE "IPIPEIF DPC1 = %x\n", utemp);
++	utemp = regr_if(IPIPEIF_DPC2);
++	printk(KERN_NOTICE "IPIPEIF DPC2  = %x\n", utemp);
++	utemp = regr_if(IPIPEIF_DFSGVL);
++	printk(KERN_NOTICE "IPIPEIF DFSGVL  = %x\n", utemp);
++	utemp = regr_if(IPIPEIF_DFSGTH);
++	printk(KERN_NOTICE "IPIPEIF DFSGTH  = %x\n", utemp);
++	utemp = regr_if(IPIPEIF_RSZ3A);
++	printk(KERN_NOTICE "IPIPEIF RSZ3A  = %x\n", utemp);
++	utemp = regr_if(IPIPEIF_INIRSZ3A);
++	printk(KERN_NOTICE "IPIPEIF INIRSZ3A  = %x\n", utemp);
++	printk(KERN_NOTICE "IPIPE Registers\n");
++	printk(KERN_NOTICE
++	       "**************************************************\n");
++}
++#else
++void ipipeif_dump_register(void) {};
++#endif
++
++static int __init dm3xx_ipipeif_probe(struct platform_device *pdev)
++{
++        static resource_size_t  res_len;
++        struct resource *res;
++        int status = 0;
++
++        if (NULL == pdev->dev.platform_data)
++		printk("DM355 IPIPEIF probed\n");		
++	else {
++		printk("DM365 IPIPEIF probed\n");		
++		device_type = DM365;
++	}
++
++        res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
++        if (!res)
++                return -ENOENT;
++
++        res_len = res->end - res->start + 1;
++
++        res = request_mem_region(res->start, res_len, res->name);
++        if (!res)
++                return -EBUSY;
++
++        ipipeif_base_addr = ioremap_nocache(res->start, res_len);
++        if (!ipipeif_base_addr) {
++                status = -EBUSY;
++                goto fail;
++        }
++        return 0;
++
++fail:
++        release_mem_region(res->start, res_len);
++        return status;
++}
++
++static int dm3xx_ipipeif_remove(struct platform_device *pdev)
++{
++        struct resource *res;
++
++        iounmap(ipipeif_base_addr);
++        res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
++        if (res)
++                release_mem_region(res->start, res->end - res->start + 1);
++        return 0;
++}
++
++static struct platform_driver dm3xx_ipipeif_driver = {
++        .driver = {
++                .name   = "dm3xx_ipipeif",
++                .owner = THIS_MODULE,
++        },
++        .remove = __devexit_p(dm3xx_ipipeif_remove),
++        .probe = dm3xx_ipipeif_probe,
++};
++
++static int dm3xx_ipipeif_init(void)
++{
++	return platform_driver_register(&dm3xx_ipipeif_driver);
++}
++
++static void dm3xx_ipipeif_exit(void)
++{
++	platform_driver_unregister(&dm3xx_ipipeif_driver);
++}
++
++module_init(dm3xx_ipipeif_init);
++module_exit(dm3xx_ipipeif_exit);
++
++MODULE_LICENSE("GPL");
+--- /dev/null
++++ b/drivers/video/davincifb.c
+@@ -0,0 +1,2467 @@
++/*
++ * Copyright (C) 2007 MontaVista Software Inc.
++ * Copyright (C) 2006 Texas Instruments Inc
++ *
++ * Andy Lowe (alowe@mvista.com), MontaVista Software
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option)any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
++ */
++
++#include <linux/module.h>
++#include <linux/kernel.h>
++#include <linux/errno.h>
++#include <linux/string.h>
++#include <linux/mm.h>
++#include <linux/tty.h>
++#include <linux/slab.h>
++#include <linux/delay.h>
++#include <linux/fb.h>
++#include <linux/init.h>
++#include <linux/dma-mapping.h>
++#include <asm/uaccess.h>
++#include <linux/moduleparam.h>	/* for module_param() */
++#include <linux/platform_device.h>
++#include <asm/system.h>
++#include <video/davinci_vpbe.h>
++#include <video/davinci_osd.h>
++#include <media/davinci/vid_encoder_types.h>
++#include <media/davinci/davinci_enc.h>
++#include <video/davincifb_ioctl.h>
++#include <video/davincifb.h>
++#include <mach/cputype.h>
++
++/* return non-zero if the info structure corresponds to OSD0 or OSD1 */
++static int is_osd_win(const struct fb_info *info)
++{
++	const struct vpbe_dm_win_info *win = info->par;
++
++	if (win->layer == WIN_OSD0 || win->layer == WIN_OSD1)
++		return 1;
++	else
++		return 0;
++}
++
++/* return non-zero if the info structure corresponds to VID0 or VID1 */
++#define is_vid_win(info) (!is_osd_win(info))
++
++/*
++ * Convert a framebuffer info pointer to a davinci_osd_layer enumeration.
++ * It is up to the caller to verify that the info structure corresponds to
++ * either OSD0 or OSD1.
++ */
++static enum davinci_osd_layer fb_info_to_osd_enum(const struct fb_info *info)
++{
++	const struct vpbe_dm_win_info *win = info->par;
++
++	if (win->layer == WIN_OSD1)
++		return OSDWIN_OSD1;
++	else
++		return OSDWIN_OSD0;
++}
++
++/* macros for testing fb_var_screeninfo attributes */
++#define is_attribute_mode(var) (((var)->bits_per_pixel == 4) && \
++	((var)->nonstd != 0))
++#define is_yuv(var) ((((var)->bits_per_pixel == 16) || \
++  ((var)->bits_per_pixel == 8)) \
++  && ((var)->nonstd != 0))
++#define is_window_interlaced(var) (((var)->vmode & FB_VMODE_INTERLACED) \
++	== FB_VMODE_INTERLACED)
++
++/* macros for testing fb_videomode attributes */
++#define is_display_interlaced(mode) (((mode)->vmode & FB_VMODE_INTERLACED) \
++	== FB_VMODE_INTERLACED)
++
++static unsigned int fb_cbcr_ofst;
++
++/*
++ * Convert an fb_var_screeninfo struct to a Davinci display layer configuration.
++ * lconfig->xpos, lconfig->ypos, and lconfig->line_length are not modified
++ * because no information about them is contained in var.
++ * The value of the yc_pixfmt argument is returned in lconfig->pixfmt if a
++ * the var specifies a YC pixel format.  The value of yc_pixfmt must be either
++ * PIXFMT_YCbCrI or PIXFMT_YCrCbI.
++ */
++static void convert_fb_var_to_osd(const struct fb_var_screeninfo *var,
++				  struct davinci_layer_config *lconfig,
++				  enum davinci_pix_format yc_pixfmt)
++{
++	lconfig->xsize = var->xres;
++	lconfig->ysize = var->yres;
++	lconfig->interlaced = is_window_interlaced(var);
++
++	switch (var->bits_per_pixel) {
++	case 1:
++		lconfig->pixfmt = PIXFMT_1BPP;
++		break;
++	case 2:
++		lconfig->pixfmt = PIXFMT_2BPP;
++		break;
++	case 4:
++		if (is_attribute_mode(var))
++			lconfig->pixfmt = PIXFMT_OSD_ATTR;
++		else
++			lconfig->pixfmt = PIXFMT_4BPP;
++		break;
++	case 8:
++		if (is_yuv(var))
++			lconfig->pixfmt = PIXFMT_NV12;
++		else
++			lconfig->pixfmt = PIXFMT_8BPP;
++		break;
++	case 16:
++	default:
++		if (is_yuv(var))
++			lconfig->pixfmt = yc_pixfmt;
++		else
++			lconfig->pixfmt = PIXFMT_RGB565;
++		break;
++	case 24:
++	case 32:
++		lconfig->pixfmt = PIXFMT_RGB888;
++		break;
++	}
++}
++
++/*
++ * Convert an fb_info struct to a Davinci display layer configuration.
++ */
++static void convert_fb_info_to_osd(const struct fb_info *info,
++				   struct davinci_layer_config *lconfig)
++{
++	const struct vpbe_dm_win_info *win = info->par;
++
++	lconfig->line_length = info->fix.line_length;
++	lconfig->xpos = win->xpos;
++	lconfig->ypos = win->ypos;
++	convert_fb_var_to_osd(&info->var, lconfig, win->dm->yc_pixfmt);
++}
++
++/*
++ * Convert a Davinci display layer configuration to var info.
++ * The following members of var are not modified:
++ *	var->xres_virtual
++ *	var->yres_virtual
++ *	var->xoffset
++ *	var->yoffset
++ *	var->pixclock
++ *	var->left_margin
++ *	var->right_margin
++ *	var->upper_margin
++ *	var->lower_margin
++ *	var->hsync_len
++ *	var->vsync_len
++ *	var->sync
++ * Only bit 0 of var->vmode (FB_VMODE_INTERLACED) is modified.  All other bits
++ * of var->vmode are retained.
++ */
++static void convert_osd_to_fb_var(const struct davinci_layer_config *lconfig,
++				  struct fb_var_screeninfo *var)
++{
++	var->xres = lconfig->xsize;
++	var->yres = lconfig->ysize;
++	if (lconfig->interlaced)
++		var->vmode |= FB_VMODE_INTERLACED;
++	else
++		var->vmode &= ~FB_VMODE_INTERLACED;
++
++	var->red.offset = var->green.offset = var->blue.offset = 0;
++	var->red.msb_right = var->green.msb_right = var->blue.msb_right = 0;
++	var->transp.offset = var->transp.length = var->transp.msb_right = 0;
++	var->nonstd = 0;
++
++	switch (lconfig->pixfmt) {
++	case PIXFMT_1BPP:
++		var->bits_per_pixel = 1;
++		var->red.length = var->green.length = var->blue.length =
++		    var->bits_per_pixel;
++		break;
++	case PIXFMT_2BPP:
++		var->bits_per_pixel = 2;
++		var->red.length = var->green.length = var->blue.length =
++		    var->bits_per_pixel;
++		break;
++	case PIXFMT_4BPP:
++		var->bits_per_pixel = 4;
++		var->red.length = var->green.length = var->blue.length =
++		    var->bits_per_pixel;
++		break;
++	case PIXFMT_8BPP:
++		var->bits_per_pixel = 8;
++		var->red.length = var->green.length = var->blue.length =
++		    var->bits_per_pixel;
++		break;
++	case PIXFMT_RGB565:
++		var->bits_per_pixel = 16;
++		var->red.offset = 11;
++		var->red.length = 5;
++		var->green.offset = 5;
++		var->green.length = 6;
++		var->blue.offset = 0;
++		var->blue.length = 5;
++		break;
++	case PIXFMT_YCbCrI:
++	case PIXFMT_YCrCbI:
++		var->bits_per_pixel = 16;
++		var->red.length = var->green.length = var->blue.length = 0;
++		var->nonstd = 1;
++		break;
++	case PIXFMT_NV12:
++		if (cpu_is_davinci_dm365()) {
++			var->bits_per_pixel = 8;
++			var->red.length = var->green.length = var->blue.length =
++			    0;
++			var->nonstd = 1;
++		}
++	case PIXFMT_RGB888:
++		if (cpu_is_davinci_dm644x()) {
++			var->bits_per_pixel = 24;
++			var->red.offset = 0;
++			var->red.length = 8;
++			var->green.offset = 8;
++			var->green.length = 8;
++			var->blue.offset = 16;
++			var->blue.length = 8;
++		} else {
++			var->bits_per_pixel = 32;
++			var->red.offset = 16;
++			var->red.length = 8;
++			var->green.offset = 8;
++			var->green.length = 8;
++			var->blue.offset = 0;
++			var->blue.length = 8;
++			var->transp.offset = 24;
++			var->transp.length = 3;
++		}
++		break;
++	case PIXFMT_OSD_ATTR:
++		var->bits_per_pixel = 4;
++		var->red.length = var->green.length = var->blue.length = 0;
++		var->nonstd = 1;
++		break;
++	}
++
++	var->grayscale = 0;
++	var->activate = FB_ACTIVATE_NOW;
++	var->height = 0;
++	var->width = 0;
++	var->accel_flags = 0;
++	var->rotate = 0;
++}
++
++/*
++ * Get the video mode from the encoder manager.
++ */
++static int get_video_mode(struct fb_videomode *mode)
++{
++	struct vid_enc_mode_info mode_info;
++	int ret;
++
++	memset(&mode_info, 0, sizeof(mode_info));
++	memset(mode, 0, sizeof(*mode));
++
++	ret = davinci_enc_get_mode(0, &mode_info);
++
++	mode->name = mode_info.name;
++	if (mode_info.fps.denominator) {
++		unsigned fps_1000;	/* frames per 1000 seconds */
++		unsigned lps;	/* lines per second */
++		unsigned pps;	/* pixels per second */
++		unsigned vtotal;	/* total lines per frame */
++		unsigned htotal;	/* total pixels per line */
++		unsigned interlace = (mode_info.interlaced) ? 2 : 1;
++
++		fps_1000 =
++		    (1000 * mode_info.fps.numerator +
++		     mode_info.fps.denominator / 2) / mode_info.fps.denominator;
++		mode->refresh = (interlace * fps_1000 + 1000 / 2) / 1000;
++
++		vtotal =
++		    mode_info.yres + mode_info.lower_margin +
++		    mode_info.vsync_len + mode_info.upper_margin;
++		lps = (fps_1000 * vtotal + 1000 / 2) / 1000;
++
++		htotal =
++		    mode_info.xres + mode_info.right_margin +
++		    mode_info.hsync_len + mode_info.left_margin;
++		pps = lps * htotal;
++
++		if (pps)
++			mode->pixclock =
++			    ((1000000000UL + pps / 2) / pps) * 1000;
++	}
++	mode->xres = mode_info.xres;
++	mode->yres = mode_info.yres;
++	mode->left_margin = mode_info.left_margin;
++	mode->right_margin = mode_info.right_margin;
++	mode->upper_margin = mode_info.upper_margin;
++	mode->lower_margin = mode_info.lower_margin;
++	mode->hsync_len = mode_info.hsync_len;
++	mode->vsync_len = mode_info.vsync_len;
++	if (mode_info.flags & (1 << 0))
++		mode->sync |= FB_SYNC_HOR_HIGH_ACT;
++	if (mode_info.flags & (1 << 1))
++		mode->sync |= FB_SYNC_VERT_HIGH_ACT;
++	if (mode_info.std)
++		mode->sync |= FB_SYNC_BROADCAST;
++	if (mode_info.interlaced)
++		mode->vmode |= FB_VMODE_INTERLACED;
++
++	return ret;
++}
++
++/*
++ * Set a video mode with the encoder manager.
++ */
++static int set_video_mode(struct fb_videomode *mode)
++{
++	struct vid_enc_mode_info mode_info;
++	int ret;
++
++	davinci_enc_get_mode(0, &mode_info);
++
++	mode_info.name = (unsigned char *)mode->name;
++	mode_info.fps.numerator = 0;
++	mode_info.fps.denominator = 0;
++	if (mode->pixclock && mode->xres && mode->yres) {
++		unsigned fps_1000;	/* frames per 1000 seconds */
++		unsigned lps;	/* lines per second */
++		unsigned pps;	/* pixels per second */
++		unsigned vtotal;	/* total lines per frame */
++		unsigned htotal;	/* total pixels per line */
++
++		pps =
++		    ((1000000000UL +
++		      mode->pixclock / 2) / mode->pixclock) * 1000;
++
++		htotal =
++		    mode->xres + mode->right_margin + mode->hsync_len +
++		    mode->left_margin;
++		lps = (pps + htotal / 2) / htotal;
++
++		vtotal =
++		    mode->yres + mode->lower_margin + mode->vsync_len +
++		    mode->upper_margin;
++		fps_1000 = (lps * 1000 + vtotal / 2) / vtotal;
++
++		mode_info.fps.numerator = fps_1000;
++		mode_info.fps.denominator = 1000;
++
++		/*
++		 * 1000 == 2*2*2*5*5*5, so factor out any common multiples of 2
++		 * or 5
++		 */
++		while ((((mode_info.fps.numerator / 2) * 2) ==
++			mode_info.fps.numerator)
++		       && (((mode_info.fps.denominator / 2) * 2) ==
++			   mode_info.fps.denominator)) {
++			mode_info.fps.numerator = mode_info.fps.numerator / 2;
++			mode_info.fps.denominator =
++			    mode_info.fps.denominator / 2;
++		}
++		while ((((mode_info.fps.numerator / 5) * 5) ==
++			mode_info.fps.numerator)
++		       && (((mode_info.fps.denominator / 5) * 5) ==
++			   mode_info.fps.denominator)) {
++			mode_info.fps.numerator = mode_info.fps.numerator / 5;
++			mode_info.fps.denominator =
++			    mode_info.fps.denominator / 5;
++		}
++	}
++	mode_info.xres = mode->xres;
++	mode_info.yres = mode->yres;
++	mode_info.left_margin = mode->left_margin;
++	mode_info.right_margin = mode->right_margin;
++	mode_info.upper_margin = mode->upper_margin;
++	mode_info.lower_margin = mode->lower_margin;
++	mode_info.hsync_len = mode->hsync_len;
++	mode_info.vsync_len = mode->vsync_len;
++	if (mode->sync & FB_SYNC_HOR_HIGH_ACT)
++		mode_info.flags |= (1 << 0);
++	else
++		mode_info.flags &= ~(1 << 0);
++	if (mode->sync & FB_SYNC_VERT_HIGH_ACT)
++		mode_info.flags |= (1 << 1);
++	else
++		mode_info.flags &= ~(1 << 1);
++	if (mode->sync & FB_SYNC_BROADCAST)
++		mode_info.std = 1;
++	else
++		mode_info.std = 0;
++	if (mode->vmode & FB_VMODE_INTERLACED)
++		mode_info.interlaced = 1;
++	else
++		mode_info.interlaced = 0;
++
++	ret = davinci_enc_set_mode(0, &mode_info);
++
++	return ret;
++}
++
++/*
++ * Construct an fb_var_screeninfo structure from an fb_videomode structure
++ * describing the display and a davinci_layer_config structure describing a window.
++ * The following members of var not modified:
++ *	var->xoffset
++ *	var->yoffset
++ *	var->xres_virtual
++ *	var->yres_virtual
++ * The following members of var are loaded with values derived from mode:
++ *	var->pixclock
++ *	var->left_margin
++ *	var->hsync_len
++ *	var->vsync_len
++ *	var->right_margin
++ *	var->upper_margin
++ *	var->lower_margin
++ *	var->sync
++ *	var->vmode (all bits except bit 0: FB_VMODE_INTERLACED)
++ * The following members of var are loaded with values derived from lconfig:
++ *	var->xres
++ *	var->yres
++ *	var->bits_per_pixel
++ *	var->red
++ *	var->green
++ *	var->blue
++ *	var->transp
++ *	var->nonstd
++ *	var->grayscale
++ *	var->activate
++ *	var->height
++ *	var->width
++ *	var->accel_flags
++ *	var->rotate
++ *	var->vmode (only bit 0: FB_VMODE_INTERLACED)
++ *
++ * If the display resolution (xres and yres) specified in mode matches the
++ * window resolution specified in lconfig, then the display timing info returned
++ * in var is valid and var->pixclock will be the value derived from mode.
++ * If the display resolution does not match the window resolution, then
++ * var->pixclock will be set to 0 to indicate that the display timing info
++ * returned in var is not valid.
++ *
++ * mode and lconfig are not modified.
++ */
++static void construct_fb_var(struct fb_var_screeninfo *var,
++			     struct fb_videomode *mode,
++			     struct davinci_layer_config *lconfig)
++{
++	fb_videomode_to_var(var, mode);
++	convert_osd_to_fb_var(lconfig, var);
++	if (lconfig->xsize != mode->xres || lconfig->ysize != mode->yres)
++		var->pixclock = 0;
++}
++
++/*
++ * Update the values in an fb_fix_screeninfo structure based on the values in an
++ * fb_var_screeninfo structure.
++ * The following members of fix are updated:
++ *	fix->visual
++ *	fix->xpanstep
++ *	fix->ypanstep
++ *	fix->ywrapstep
++ *	fix->line_length
++ * All other members of fix are unmodified.
++ */
++static void update_fix_info(const struct fb_var_screeninfo *var,
++			    struct fb_fix_screeninfo *fix)
++{
++	fix->visual =
++	    (var->bits_per_pixel >
++	     8) ? FB_VISUAL_TRUECOLOR : FB_VISUAL_PSEUDOCOLOR;
++	/*
++	 * xpanstep must correspond to a multiple of the 32-byte cache line size
++	 */
++	switch (var->bits_per_pixel) {
++	case 1:
++	case 2:
++	case 4:
++	case 8:
++	case 12:
++	case 16:
++	case 32:
++		fix->xpanstep = (8 * 32) / var->bits_per_pixel;
++		break;
++	case 24:
++		fix->xpanstep = 32;	/* 32 pixels = 3 cache lines */
++		break;
++	default:
++		fix->xpanstep = 0;
++		break;
++	}
++	fix->ypanstep = 1;
++	fix->ywrapstep = 0;
++	fix->line_length = (var->xres_virtual * var->bits_per_pixel + 7) / 8;
++	/* line_length must be a multiple of the 32-byte cache line size */
++	fix->line_length = ((fix->line_length + 31) / 32) * 32;
++}
++
++/*
++ * Determine if the window configuration specified by var will fit in a
++ * framebuffer of size fb_size.
++ * Returns 1 if the window will fit in the framebuffer, or 0 otherwise.
++ */
++static int window_will_fit_framebuffer(const struct fb_var_screeninfo *var,
++				       unsigned fb_size)
++{
++	unsigned line_length;
++
++	line_length = (var->bits_per_pixel * var->xres_virtual + 7) / 8;
++	/* line length must be a multiple of the cache line size (32) */
++	line_length = ((line_length + 31) / 32) * 32;
++
++	if (var->yres_virtual * line_length <= fb_size)
++		return 1;
++	else
++		return 0;
++}
++
++/*
++ * FBIO_WAITFORVSYNC handler
++ */
++static int davincifb_wait_for_vsync(struct fb_info *info)
++{
++	struct vpbe_dm_win_info *win = info->par;
++	wait_queue_t wq;
++	unsigned long cnt;
++	int ret;
++
++	init_waitqueue_entry(&wq, current);
++
++	cnt = win->dm->vsync_cnt;
++	ret = wait_event_interruptible_timeout(win->dm->vsync_wait,
++					       cnt != win->dm->vsync_cnt,
++					       win->dm->timeout);
++	if (ret < 0)
++		return ret;
++	if (ret == 0)
++		return -ETIMEDOUT;
++
++	return 0;
++}
++
++static void davincifb_vsync_callback(unsigned event, void *arg)
++{
++	struct vpbe_dm_info *dm = (struct vpbe_dm_info *)arg;
++	unsigned long addr = 0;
++	static unsigned last_event;
++
++	event &= ~DAVINCI_DISP_END_OF_FRAME;
++	if (event == last_event) {
++		/* progressive */
++		xchg(&addr, dm->win[WIN_OSD0].sdram_address);
++		if (addr) {
++			davinci_disp_start_layer(dm->win[WIN_OSD0].layer,
++						 dm->win[WIN_OSD0].
++						 sdram_address,
++						 fb_cbcr_ofst);
++			dm->win[WIN_OSD0].sdram_address = 0;
++		}
++		addr = 0;
++		xchg(&addr, dm->win[WIN_OSD1].sdram_address);
++		if (addr) {
++			davinci_disp_start_layer(dm->win[WIN_OSD1].layer,
++						 dm->win[WIN_OSD1].
++						 sdram_address,
++						 fb_cbcr_ofst);
++			dm->win[WIN_OSD1].sdram_address = 0;
++		}
++		addr = 0;
++		xchg(&addr, dm->win[WIN_VID0].sdram_address);
++		if (addr) {
++			davinci_disp_start_layer(dm->win[WIN_VID0].layer,
++						 dm->win[WIN_VID0].
++						 sdram_address,
++						 fb_cbcr_ofst);
++			dm->win[WIN_VID0].sdram_address = 0;
++		}
++		addr = 0;
++		xchg(&addr, dm->win[WIN_VID1].sdram_address);
++		if (addr) {
++			davinci_disp_start_layer(dm->win[WIN_VID1].layer,
++						 dm->win[WIN_VID1].
++						 sdram_address,
++						 fb_cbcr_ofst);
++			dm->win[WIN_VID1].sdram_address = 0;
++		}
++		++dm->vsync_cnt;
++		wake_up_interruptible(&dm->vsync_wait);
++	} else {
++		/* interlaced */
++		if (event & DAVINCI_DISP_SECOND_FIELD) {
++			xchg(&addr, dm->win[WIN_OSD0].sdram_address);
++			if (addr) {
++				davinci_disp_start_layer(dm->win[WIN_OSD0].
++							 layer,
++							 dm->win[WIN_OSD0].
++							 sdram_address,
++							 fb_cbcr_ofst);
++				dm->win[WIN_OSD0].sdram_address = 0;
++			}
++			addr = 0;
++			xchg(&addr, dm->win[WIN_OSD1].sdram_address);
++			if (addr) {
++				davinci_disp_start_layer(dm->win[WIN_OSD1].
++							 layer,
++							 dm->win[WIN_OSD1].
++							 sdram_address,
++							 fb_cbcr_ofst);
++				dm->win[WIN_OSD1].sdram_address = 0;
++			}
++			addr = 0;
++			xchg(&addr, dm->win[WIN_VID0].sdram_address);
++			if (addr) {
++				davinci_disp_start_layer(dm->win[WIN_VID0].
++							 layer,
++							 dm->win[WIN_VID0].
++							 sdram_address,
++							 fb_cbcr_ofst);
++				dm->win[WIN_VID0].sdram_address = 0;
++			}
++			addr = 0;
++			xchg(&addr, dm->win[WIN_VID1].sdram_address);
++			if (addr) {
++				davinci_disp_start_layer(dm->win[WIN_VID1].
++							 layer,
++							 dm->win[WIN_VID1].
++							 sdram_address,
++							 fb_cbcr_ofst);
++				dm->win[WIN_VID1].sdram_address = 0;
++			}
++		} else {
++			++dm->vsync_cnt;
++			wake_up_interruptible(&dm->vsync_wait);
++		}
++	}
++	last_event = event;
++}
++
++/*
++ * FBIO_SETATTRIBUTE handler
++ *
++ * This ioctl is deprecated.  The user can write the attribute values directly
++ * to the OSD1 framebuffer.
++ *
++ * Set a uniform attribute value over a rectangular area on the attribute
++ * window. The attribute value (0 to 15) is passed through the fb_fillrect's
++ * color parameter.  r->dx and r->width must both be even.  If not, they are
++ * rounded down.
++ */
++static int vpbe_set_attr_blend(struct fb_info *info, struct fb_fillrect *r)
++{
++	struct vpbe_dm_win_info *win = info->par;
++	struct fb_var_screeninfo *var = &info->var;
++	char __iomem *start;
++	u8 blend;
++	u32 width_bytes;
++
++	if (win->layer != WIN_OSD1)
++		return -EINVAL;
++
++	if (!is_attribute_mode(var))
++		return -EINVAL;
++
++	if (r->dx + r->width > var->xres_virtual)
++		return -EINVAL;
++	if (r->dy + r->height > var->yres_virtual)
++		return -EINVAL;
++	if (r->color > 15)
++		return -EINVAL;
++
++	width_bytes = (r->width * var->bits_per_pixel) / 8;
++	start =
++	    info->screen_base + r->dy * info->fix.line_length +
++	    (r->dx * var->bits_per_pixel) / 8;
++
++	blend = (((u8) r->color & 0xf) << 4) | ((u8) r->color);
++	while (r->height--) {
++		memset(start, blend, width_bytes);
++		start += info->fix.line_length;
++	}
++
++	return 0;
++}
++
++/*
++ * FBIO_SETPOSX handler
++ */
++static int vpbe_setposx(struct fb_info *info, unsigned xpos)
++{
++	struct vpbe_dm_win_info *win = info->par;
++	struct fb_var_screeninfo *var = &info->var;
++	struct fb_var_screeninfo v;
++	unsigned old_xpos = win->xpos;
++	int retval;
++
++	if (!win->own_window)
++		return -ENODEV;
++
++	memcpy(&v, var, sizeof(v));
++	win->xpos = xpos;
++	retval = info->fbops->fb_check_var(&v, info);
++	if (retval) {
++		win->xpos = old_xpos;
++		return retval;
++	}
++
++	/* update the window position */
++	memcpy(var, &v, sizeof(v));
++	retval = info->fbops->fb_set_par(info);
++
++	return retval;
++}
++
++/*
++ * FBIO_SETPOSY handler
++ */
++static int vpbe_setposy(struct fb_info *info, unsigned ypos)
++{
++	struct vpbe_dm_win_info *win = info->par;
++	struct fb_var_screeninfo *var = &info->var;
++	struct fb_var_screeninfo v;
++	unsigned old_ypos = win->ypos;
++	int retval;
++
++	if (!win->own_window)
++		return -ENODEV;
++
++	memcpy(&v, var, sizeof(v));
++	win->ypos = ypos;
++	retval = info->fbops->fb_check_var(&v, info);
++	if (retval) {
++		win->ypos = old_ypos;
++		return retval;
++	}
++
++	/* update the window position */
++	memcpy(var, &v, sizeof(v));
++	retval = info->fbops->fb_set_par(info);
++
++	return retval;
++}
++
++/*
++ * FBIO_SETZOOM handler
++ */
++static int vpbe_set_zoom(struct fb_info *info, struct zoom_params *zoom)
++{
++	struct vpbe_dm_win_info *win = info->par;
++	enum davinci_zoom_factor h_zoom, v_zoom;
++
++	if (!win->own_window)
++		return -ENODEV;
++
++	switch (zoom->zoom_h) {
++	case 0:
++		h_zoom = ZOOM_X1;
++		break;
++	case 1:
++		h_zoom = ZOOM_X2;
++		break;
++	case 2:
++		h_zoom = ZOOM_X4;
++		break;
++	default:
++		return -EINVAL;
++	}
++
++	switch (zoom->zoom_v) {
++	case 0:
++		v_zoom = ZOOM_X1;
++		break;
++	case 1:
++		v_zoom = ZOOM_X2;
++		break;
++	case 2:
++		v_zoom = ZOOM_X4;
++		break;
++	default:
++		return -EINVAL;
++	}
++
++	davinci_disp_set_zoom(win->layer, h_zoom, v_zoom);
++
++	return 0;
++}
++
++/*
++ * FBIO_ENABLE_DISABLE_WIN handler
++ *
++ * This ioctl is deprecated.  Use the standard FBIOBLANK ioctl instead.
++ */
++static int vpbe_enable_disable_win(struct fb_info *info, int enable)
++{
++	struct vpbe_dm_win_info *win = info->par;
++	int retval = 0;
++
++	if (!win->own_window)
++		return -ENODEV;
++
++	if (enable) {
++		win->display_window = 1;
++		retval = info->fbops->fb_check_var(&info->var, info);
++		if (retval)
++			return retval;
++		retval = info->fbops->fb_set_par(info);
++	} else {
++		win->display_window = 0;
++		davinci_disp_disable_layer(win->layer);
++	}
++
++	return retval;
++}
++
++/*
++ * FBIO_SET_BITMAP_BLEND_FACTOR handler
++ */
++static int vpbe_bitmap_set_blend_factor(struct fb_info *info, struct vpbe_bitmap_blend_params
++					*blend_para)
++{
++	enum davinci_osd_layer osdwin = fb_info_to_osd_enum(info);
++
++	if (!is_osd_win(info))
++		return -EINVAL;
++
++	if (blend_para->bf > OSD_8_VID_0)
++		return -EINVAL;
++
++	davinci_disp_set_blending_factor(osdwin, blend_para->bf);
++	if (blend_para->enable_colorkeying)
++		davinci_disp_enable_color_key(osdwin, blend_para->colorkey);
++	else
++		davinci_disp_disable_color_key(osdwin);
++
++	return 0;
++}
++
++/*
++ * FBIO_SET_BITMAP_WIN_RAM_CLUT handler
++ *
++ * This ioctl is deprecated.  Use the standard framebuffer ioctl FBIOPUTCMAP
++ * instead.  Note that FBIOPUTCMAP colors are expressed in RGB space instead of
++ * YCbCr space.
++ */
++static int vpbe_bitmap_set_ram_clut(struct fb_info *info,
++				    unsigned char ram_clut[256][3])
++{
++	int i;
++
++	if (!is_osd_win(info))
++		return -EINVAL;
++
++	for (i = 0; i < 256; i++) {
++		davinci_disp_set_clut_ycbcr(i, ram_clut[i][0], ram_clut[i][1],
++					    ram_clut[i][2]);
++	}
++	return 0;
++}
++
++/*
++ * FBIO_ENABLE_DISABLE_ATTRIBUTE_WIN handler
++ *
++ * This ioctl is deprecated.  Attribute mode can be enabled via the standard
++ * framebuffer ioctl FBIOPUT_VSCREENINFO by setting var->bits_per_pixel to 4
++ * and var->nonstd to a non-zero value.  Attribute mode can be disabled by using
++ * FBIOPUT_VSCREENINFO to set a standard pixel format.
++ *
++ * The enabled/disabled status of OSD1 is unchanged by this ioctl.  To avoid
++ * display glitches, you should disable OSD1 prior to calling this ioctl.
++ *
++ * When enabling attribute mode, var->bits_per_pixel is set to 4.  var->xres,
++ * var->yres, var->xres_virtual, var->yres_virtual, win->xpos, and win->ypos are
++ * all copied from OSD0.  var->xoffset and var->yoffset are set to 0.
++ * fix->line_length is updated to be consistent with 4 bits per pixel.  No
++ * changes are made to the OSD1 configuration if OSD1 is already in attribute
++ * mode.
++ *
++ * When disabling attribute mode, the window geometry is unchanged.
++ * var->bits_per_pixel remains set to 4.  No changes are made to the OSD1
++ * configuration if OSD1 is not in attribute mode.
++ */
++static int vpbe_enable_disable_attribute_window(struct fb_info *info, u32 flag)
++{
++	struct vpbe_dm_win_info *win = info->par;
++	struct fb_var_screeninfo *var = &info->var;
++	struct fb_var_screeninfo v;
++	struct davinci_layer_config lconfig;
++	int retval;
++
++	if (win->layer != WIN_OSD1)
++		return -EINVAL;
++
++	/* return with no error if there is nothing to do */
++	if ((is_attribute_mode(var) && flag)
++	    || (!is_attribute_mode(var) && !flag))
++		return 0;
++
++	/* start with the current OSD1 var */
++	memcpy(&v, var, sizeof(v));
++
++	if (flag) {		/* enable attribute mode */
++		const struct vpbe_dm_win_info *osd0 = &win->dm->win[WIN_OSD0];
++		const struct fb_var_screeninfo *osd0_var = &osd0->info->var;
++		unsigned old_xpos = win->xpos;
++		unsigned old_ypos = win->ypos;
++		/* get the OSD0 window configuration */
++		convert_fb_var_to_osd(osd0_var, &lconfig, win->dm->yc_pixfmt);
++		/* change the pixfmt to attribute mode */
++		lconfig.pixfmt = PIXFMT_OSD_ATTR;
++		/* update the var for OSD1 */
++		convert_osd_to_fb_var(&lconfig, &v);
++		/* copy xres_virtual and yres_virtual from OSD0 */
++		v.xres_virtual = osd0_var->xres_virtual;
++		v.yres_virtual = osd0_var->yres_virtual;
++		/* zero xoffset and yoffset */
++		v.xoffset = 0;
++		v.yoffset = 0;
++		/* copy xpos and ypos from OSD0 */
++		win->xpos = osd0->xpos;
++		win->ypos = osd0->ypos;
++
++		retval = info->fbops->fb_check_var(&v, info);
++		if (retval) {
++			win->xpos = old_xpos;
++			win->ypos = old_ypos;
++			return retval;
++		}
++
++		/*
++		 * Enable attribute mode by replacing info->var and calling
++		 * the fb_set_par method to activate it.
++		 */
++		memcpy(var, &v, sizeof(v));
++		retval = info->fbops->fb_set_par(info);
++	} else {		/* disable attribute mode */
++		/* get the current OSD1 window configuration */
++		convert_fb_var_to_osd(var, &lconfig, win->dm->yc_pixfmt);
++		/* change the pixfmt to 4-bits-per-pixel bitmap */
++		lconfig.pixfmt = PIXFMT_4BPP;
++		/* update the var for OSD1 */
++		convert_osd_to_fb_var(&lconfig, &v);
++
++		retval = info->fbops->fb_check_var(&v, info);
++		if (retval)
++			return retval;
++
++		/*
++		 * Disable attribute mode by replacing info->var and calling
++		 * the fb_set_par method to activate it.
++		 */
++		memcpy(var, &v, sizeof(v));
++		retval = info->fbops->fb_set_par(info);
++	}
++
++	return retval;
++}
++
++/*
++ * FBIO_GET_BLINK_INTERVAL handler
++ */
++static int vpbe_get_blinking(struct fb_info *info,
++			     struct vpbe_blink_option *blink_option)
++{
++	struct vpbe_dm_win_info *win = info->par;
++	enum davinci_blink_interval blink;
++	int enabled;
++
++	if (win->layer != WIN_OSD1)
++		return -EINVAL;
++
++	davinci_disp_get_blink_attribute(&enabled, &blink);
++	blink_option->blinking = enabled;
++	blink_option->interval = blink;
++
++	return 0;
++}
++
++/*
++ * FBIO_SET_BLINK_INTERVAL handler
++ */
++static int vpbe_set_blinking(struct fb_info *info,
++			     struct vpbe_blink_option *blink_option)
++{
++	struct vpbe_dm_win_info *win = info->par;
++
++	if (win->layer != WIN_OSD1)
++		return -EINVAL;
++
++	if (blink_option->interval > BLINK_X4)
++		return -EINVAL;
++
++	davinci_disp_set_blink_attribute(blink_option->blinking,
++					 blink_option->interval);
++
++	return 0;
++}
++
++/*
++ * FBIO_GET_VIDEO_CONFIG_PARAMS handler
++ *
++ * Despite the name, this ioctl can be used on both video windows and OSD
++ * (bitmap) windows.
++ */
++static int vpbe_get_vid_params(struct fb_info *info,
++			       struct vpbe_video_config_params *vid_conf_params)
++{
++	struct vpbe_dm_win_info *win = info->par;
++	enum davinci_h_exp_ratio h_exp;
++	enum davinci_v_exp_ratio v_exp;
++
++	if (!win->own_window)
++		return -ENODEV;
++
++	if (is_vid_win(info))
++		davinci_disp_get_vid_expansion(&h_exp, &v_exp);
++	else
++		davinci_disp_get_osd_expansion(&h_exp, &v_exp);
++
++	vid_conf_params->cb_cr_order =
++	    (win->dm->yc_pixfmt == PIXFMT_YCbCrI) ? 0 : 1;
++	vid_conf_params->exp_info.horizontal = h_exp;
++	vid_conf_params->exp_info.vertical = v_exp;
++
++	return 0;
++}
++
++/*
++ * FBIO_SET_VIDEO_CONFIG_PARAMS handler
++ *
++ * Despite the name, this ioctl can be used on both video windows and OSD
++ * (bitmap) windows.
++ *
++ * NOTE: If the cb_cr_order is changed, it won't take effect until an
++ * FBIOPUT_VSCREENINFO ioctl is executed on a window with a YC pixel format.
++ */
++static int vpbe_set_vid_params(struct fb_info *info,
++			       struct vpbe_video_config_params *vid_conf_params)
++{
++	struct vpbe_dm_win_info *win = info->par;
++	enum davinci_h_exp_ratio h_exp;
++	enum davinci_v_exp_ratio v_exp;
++
++	if (!win->own_window)
++		return -ENODEV;
++
++	if (vid_conf_params->exp_info.horizontal > H_EXP_3_OVER_2)
++		return -EINVAL;
++
++	if (vid_conf_params->exp_info.vertical > V_EXP_6_OVER_5)
++		return -EINVAL;
++
++	win->dm->yc_pixfmt =
++	    vid_conf_params->cb_cr_order ? PIXFMT_YCrCbI : PIXFMT_YCbCrI;
++
++	h_exp = vid_conf_params->exp_info.horizontal;
++	v_exp = vid_conf_params->exp_info.vertical;
++	if (is_vid_win(info))
++		davinci_disp_set_vid_expansion(h_exp, v_exp);
++	else
++		davinci_disp_set_osd_expansion(h_exp, v_exp);
++
++	return 0;
++}
++
++/*
++ * FBIO_GET_BITMAP_CONFIG_PARAMS handler
++ */
++static int vpbe_bitmap_get_params(struct fb_info *info, struct vpbe_bitmap_config_params
++				  *bitmap_conf_params)
++{
++	enum davinci_osd_layer osdwin = fb_info_to_osd_enum(info);
++	enum davinci_clut clut;
++
++	if (!is_osd_win(info))
++		return -EINVAL;
++
++	clut = davinci_disp_get_osd_clut(osdwin);
++	if (clut == ROM_CLUT)
++		bitmap_conf_params->clut_select = davinci_disp_get_rom_clut();
++	else
++		bitmap_conf_params->clut_select = 2;
++
++	bitmap_conf_params->attenuation_enable =
++	    davinci_disp_get_rec601_attenuation(osdwin);
++
++	memset(&bitmap_conf_params->clut_idx, 0,
++	       sizeof(bitmap_conf_params->clut_idx));
++
++	switch (info->var.bits_per_pixel) {
++	case 1:
++		bitmap_conf_params->clut_idx.for_1bit_bitmap.bitmap_val_0 =
++		    davinci_disp_get_palette_map(osdwin, 0);
++		bitmap_conf_params->clut_idx.for_1bit_bitmap.bitmap_val_1 =
++		    davinci_disp_get_palette_map(osdwin, 1);
++		break;
++	case 2:
++		bitmap_conf_params->clut_idx.for_2bit_bitmap.bitmap_val_0 =
++		    davinci_disp_get_palette_map(osdwin, 0);
++		bitmap_conf_params->clut_idx.for_2bit_bitmap.bitmap_val_1 =
++		    davinci_disp_get_palette_map(osdwin, 1);
++		bitmap_conf_params->clut_idx.for_2bit_bitmap.bitmap_val_2 =
++		    davinci_disp_get_palette_map(osdwin, 2);
++		bitmap_conf_params->clut_idx.for_2bit_bitmap.bitmap_val_3 =
++		    davinci_disp_get_palette_map(osdwin, 3);
++		break;
++	case 4:
++		bitmap_conf_params->clut_idx.for_4bit_bitmap.bitmap_val_0 =
++		    davinci_disp_get_palette_map(osdwin, 0);
++		bitmap_conf_params->clut_idx.for_4bit_bitmap.bitmap_val_1 =
++		    davinci_disp_get_palette_map(osdwin, 1);
++		bitmap_conf_params->clut_idx.for_4bit_bitmap.bitmap_val_2 =
++		    davinci_disp_get_palette_map(osdwin, 2);
++		bitmap_conf_params->clut_idx.for_4bit_bitmap.bitmap_val_3 =
++		    davinci_disp_get_palette_map(osdwin, 3);
++		bitmap_conf_params->clut_idx.for_4bit_bitmap.bitmap_val_4 =
++		    davinci_disp_get_palette_map(osdwin, 4);
++		bitmap_conf_params->clut_idx.for_4bit_bitmap.bitmap_val_5 =
++		    davinci_disp_get_palette_map(osdwin, 5);
++		bitmap_conf_params->clut_idx.for_4bit_bitmap.bitmap_val_6 =
++		    davinci_disp_get_palette_map(osdwin, 6);
++		bitmap_conf_params->clut_idx.for_4bit_bitmap.bitmap_val_7 =
++		    davinci_disp_get_palette_map(osdwin, 7);
++		bitmap_conf_params->clut_idx.for_4bit_bitmap.bitmap_val_8 =
++		    davinci_disp_get_palette_map(osdwin, 8);
++		bitmap_conf_params->clut_idx.for_4bit_bitmap.bitmap_val_9 =
++		    davinci_disp_get_palette_map(osdwin, 9);
++		bitmap_conf_params->clut_idx.for_4bit_bitmap.bitmap_val_10 =
++		    davinci_disp_get_palette_map(osdwin, 10);
++		bitmap_conf_params->clut_idx.for_4bit_bitmap.bitmap_val_11 =
++		    davinci_disp_get_palette_map(osdwin, 11);
++		bitmap_conf_params->clut_idx.for_4bit_bitmap.bitmap_val_12 =
++		    davinci_disp_get_palette_map(osdwin, 12);
++		bitmap_conf_params->clut_idx.for_4bit_bitmap.bitmap_val_13 =
++		    davinci_disp_get_palette_map(osdwin, 13);
++		bitmap_conf_params->clut_idx.for_4bit_bitmap.bitmap_val_14 =
++		    davinci_disp_get_palette_map(osdwin, 14);
++		bitmap_conf_params->clut_idx.for_4bit_bitmap.bitmap_val_15 =
++		    davinci_disp_get_palette_map(osdwin, 15);
++		break;
++	default:
++		break;
++	}
++
++	return 0;
++}
++
++/*
++ * FBIO_SET_BITMAP_CONFIG_PARAMS handler
++ *
++ * The palette map is ignored unless the color depth is set to 1, 2, or 4 bits
++ * per pixel.  A default palette map is supplied for these color depths where
++ * the clut index is equal to the pixel value.  It is not necessary to change
++ * the default palette map when using the RAM clut, because the RAM clut values
++ * can be changed.  It is only necessary to modify the default palette map when
++ * using a ROM clut.
++ */
++static int vpbe_bitmap_set_params(struct fb_info *info, struct vpbe_bitmap_config_params
++				  *bitmap_conf_params)
++{
++	enum davinci_osd_layer osdwin = fb_info_to_osd_enum(info);
++	enum davinci_clut clut = ROM_CLUT;
++
++	if (!is_osd_win(info))
++		return -EINVAL;
++
++	if (bitmap_conf_params->clut_select == 0)
++		davinci_disp_set_rom_clut(ROM_CLUT0);
++	else if (bitmap_conf_params->clut_select == 1)
++		davinci_disp_set_rom_clut(ROM_CLUT1);
++	else if (bitmap_conf_params->clut_select == 2)
++		clut = RAM_CLUT;
++	else
++		return -EINVAL;
++
++	davinci_disp_set_osd_clut(osdwin, clut);
++	davinci_disp_set_rec601_attenuation(osdwin,
++					    bitmap_conf_params->
++					    attenuation_enable);
++
++	switch (info->var.bits_per_pixel) {
++	case 1:
++		davinci_disp_set_palette_map(osdwin, 0,
++					     bitmap_conf_params->clut_idx.
++					     for_1bit_bitmap.bitmap_val_0);
++		davinci_disp_set_palette_map(osdwin, 1,
++					     bitmap_conf_params->clut_idx.
++					     for_1bit_bitmap.bitmap_val_1);
++		break;
++	case 2:
++		davinci_disp_set_palette_map(osdwin, 0,
++					     bitmap_conf_params->clut_idx.
++					     for_2bit_bitmap.bitmap_val_0);
++		davinci_disp_set_palette_map(osdwin, 1,
++					     bitmap_conf_params->clut_idx.
++					     for_2bit_bitmap.bitmap_val_1);
++		davinci_disp_set_palette_map(osdwin, 2,
++					     bitmap_conf_params->clut_idx.
++					     for_2bit_bitmap.bitmap_val_2);
++		davinci_disp_set_palette_map(osdwin, 3,
++					     bitmap_conf_params->clut_idx.
++					     for_2bit_bitmap.bitmap_val_3);
++		break;
++	case 4:
++		davinci_disp_set_palette_map(osdwin, 0,
++					     bitmap_conf_params->clut_idx.
++					     for_4bit_bitmap.bitmap_val_0);
++		davinci_disp_set_palette_map(osdwin, 1,
++					     bitmap_conf_params->clut_idx.
++					     for_4bit_bitmap.bitmap_val_1);
++		davinci_disp_set_palette_map(osdwin, 2,
++					     bitmap_conf_params->clut_idx.
++					     for_4bit_bitmap.bitmap_val_2);
++		davinci_disp_set_palette_map(osdwin, 3,
++					     bitmap_conf_params->clut_idx.
++					     for_4bit_bitmap.bitmap_val_3);
++		davinci_disp_set_palette_map(osdwin, 4,
++					     bitmap_conf_params->clut_idx.
++					     for_4bit_bitmap.bitmap_val_4);
++		davinci_disp_set_palette_map(osdwin, 5,
++					     bitmap_conf_params->clut_idx.
++					     for_4bit_bitmap.bitmap_val_5);
++		davinci_disp_set_palette_map(osdwin, 6,
++					     bitmap_conf_params->clut_idx.
++					     for_4bit_bitmap.bitmap_val_6);
++		davinci_disp_set_palette_map(osdwin, 7,
++					     bitmap_conf_params->clut_idx.
++					     for_4bit_bitmap.bitmap_val_7);
++		davinci_disp_set_palette_map(osdwin, 8,
++					     bitmap_conf_params->clut_idx.
++					     for_4bit_bitmap.bitmap_val_8);
++		davinci_disp_set_palette_map(osdwin, 9,
++					     bitmap_conf_params->clut_idx.
++					     for_4bit_bitmap.bitmap_val_9);
++		davinci_disp_set_palette_map(osdwin, 10,
++					     bitmap_conf_params->clut_idx.
++					     for_4bit_bitmap.bitmap_val_10);
++		davinci_disp_set_palette_map(osdwin, 11,
++					     bitmap_conf_params->clut_idx.
++					     for_4bit_bitmap.bitmap_val_11);
++		davinci_disp_set_palette_map(osdwin, 12,
++					     bitmap_conf_params->clut_idx.
++					     for_4bit_bitmap.bitmap_val_12);
++		davinci_disp_set_palette_map(osdwin, 13,
++					     bitmap_conf_params->clut_idx.
++					     for_4bit_bitmap.bitmap_val_13);
++		davinci_disp_set_palette_map(osdwin, 14,
++					     bitmap_conf_params->clut_idx.
++					     for_4bit_bitmap.bitmap_val_14);
++		davinci_disp_set_palette_map(osdwin, 15,
++					     bitmap_conf_params->clut_idx.
++					     for_4bit_bitmap.bitmap_val_15);
++		break;
++	default:
++		break;
++	}
++
++	return 0;
++}
++
++/*
++ * FBIO_SET_BACKG_COLOR handler
++ */
++static int vpbe_set_backg_color(struct fb_info *info,
++				struct vpbe_backg_color *backg_color)
++{
++	enum davinci_clut clut = ROM_CLUT;
++
++	if (backg_color->clut_select == 0)
++		davinci_disp_set_rom_clut(ROM_CLUT0);
++	else if (backg_color->clut_select == 1)
++		davinci_disp_set_rom_clut(ROM_CLUT1);
++	else if (backg_color->clut_select == 2)
++		clut = RAM_CLUT;
++	else
++		return -EINVAL;
++
++	davinci_disp_set_background(clut, backg_color->color_offset);
++
++	return 0;
++}
++
++/*
++ * FBIO_SETPOS handler
++ */
++static int vpbe_setpos(struct fb_info *info,
++		       struct vpbe_window_position *win_pos)
++{
++	struct vpbe_dm_win_info *win = info->par;
++	struct fb_var_screeninfo *var = &info->var;
++	struct fb_var_screeninfo v;
++	unsigned old_xpos = win->xpos;
++	unsigned old_ypos = win->ypos;
++	int retval;
++
++	if (!win->own_window)
++		return -ENODEV;
++
++	memcpy(&v, var, sizeof(v));
++	win->xpos = win_pos->xpos;
++	win->ypos = win_pos->ypos;
++	retval = info->fbops->fb_check_var(&v, info);
++	if (retval) {
++		win->xpos = old_xpos;
++		win->ypos = old_ypos;
++		return retval;
++	}
++
++	/* update the window position */
++	memcpy(var, &v, sizeof(v));
++	retval = info->fbops->fb_set_par(info);
++
++	return retval;
++}
++
++/*
++ * FBIO_SET_CURSOR handler
++ */
++static int vpbe_set_cursor_params(struct fb_info *info,
++				  struct fb_cursor *fbcursor)
++{
++	struct davinci_cursor_config cursor;
++
++	if (!fbcursor->enable) {
++		davinci_disp_cursor_disable();
++		return 0;
++	}
++
++	cursor.xsize = fbcursor->image.width;
++	cursor.ysize = fbcursor->image.height;
++	cursor.xpos = fbcursor->image.dx;
++	cursor.ypos = fbcursor->image.dy;
++	cursor.interlaced = is_window_interlaced(&info->var);
++	cursor.h_width =
++	    (fbcursor->image.depth > 7) ? 7 : fbcursor->image.depth;
++	cursor.v_width = cursor.h_width;
++	cursor.clut = ROM_CLUT;
++	cursor.clut_index = fbcursor->image.fg_color;
++
++	davinci_disp_set_cursor_config(&cursor);
++
++	davinci_disp_cursor_enable();
++
++	return 0;
++}
++
++/*
++ * fb_ioctl method
++ */
++static int
++davincifb_ioctl(struct fb_info *info, unsigned int cmd,	unsigned long arg)
++{
++	struct vpbe_dm_win_info *win = info->par;
++	void __user *argp = (void __user *)arg;
++	struct fb_fillrect rect;
++	struct zoom_params zoom;
++	int retval = 0;
++	struct vpbe_bitmap_blend_params blend_para;
++	struct vpbe_blink_option blink_option;
++	struct vpbe_video_config_params vid_conf_params;
++	struct vpbe_bitmap_config_params bitmap_conf_params;
++	struct vpbe_backg_color backg_color;
++	struct vpbe_window_position win_pos;
++	struct fb_cursor cursor;
++
++	switch (cmd) {
++	case FBIO_WAITFORVSYNC:
++		/* This ioctl accepts an integer argument to specify a
++		 * display.  We only support one display, so we will
++		 * simply ignore the argument.
++		 */
++		return davincifb_wait_for_vsync(info);
++
++	case FBIO_SETATTRIBUTE:
++		if (copy_from_user(&rect, argp, sizeof(rect)))
++			return -EFAULT;
++		return vpbe_set_attr_blend(info, &rect);
++
++	case FBIO_SETPOSX:
++		return vpbe_setposx(info, arg);
++
++	case FBIO_SETPOSY:
++		return vpbe_setposy(info, arg);
++
++	case FBIO_SETZOOM:
++		if (copy_from_user(&zoom, argp, sizeof(zoom)))
++			return -EFAULT;
++		return vpbe_set_zoom(info, &zoom);
++
++	case FBIO_ENABLE_DISABLE_WIN:
++		return vpbe_enable_disable_win(info, arg);
++
++	case FBIO_SET_BITMAP_BLEND_FACTOR:
++		if (copy_from_user(&blend_para, argp, sizeof(blend_para)))
++			return -EFAULT;
++		return vpbe_bitmap_set_blend_factor(info, &blend_para);
++
++	case FBIO_SET_BITMAP_WIN_RAM_CLUT:
++		if (copy_from_user(win->dm->ram_clut[0], argp, RAM_CLUT_SIZE))
++			return -EFAULT;
++		return vpbe_bitmap_set_ram_clut(info, win->dm->ram_clut);
++
++	case FBIO_ENABLE_DISABLE_ATTRIBUTE_WIN:
++		return vpbe_enable_disable_attribute_window(info, arg);
++
++	case FBIO_GET_BLINK_INTERVAL:
++		if ((retval = vpbe_get_blinking(info, &blink_option)) < 0)
++			return retval;
++		if (copy_to_user(argp, &blink_option, sizeof(blink_option)))
++			return -EFAULT;
++		return 0;
++
++	case FBIO_SET_BLINK_INTERVAL:
++		if (copy_from_user(&blink_option, argp, sizeof(blink_option)))
++			return -EFAULT;
++		return vpbe_set_blinking(info, &blink_option);
++
++	case FBIO_GET_VIDEO_CONFIG_PARAMS:
++		if ((retval = vpbe_get_vid_params(info, &vid_conf_params)) < 0)
++			return retval;
++		if (copy_to_user
++		    (argp, &vid_conf_params, sizeof(vid_conf_params)))
++			return -EFAULT;
++		return 0;
++
++	case FBIO_SET_VIDEO_CONFIG_PARAMS:
++		if (copy_from_user
++		    (&vid_conf_params, argp, sizeof(vid_conf_params)))
++			return -EFAULT;
++		return vpbe_set_vid_params(info, &vid_conf_params);
++
++	case FBIO_GET_BITMAP_CONFIG_PARAMS:
++		if ((retval =
++		     vpbe_bitmap_get_params(info, &bitmap_conf_params)) < 0)
++			return retval;
++		if (copy_to_user
++		    (argp, &bitmap_conf_params, sizeof(bitmap_conf_params)))
++			return -EFAULT;
++		return 0;
++
++	case FBIO_SET_BITMAP_CONFIG_PARAMS:
++		if (copy_from_user
++		    (&bitmap_conf_params, argp, sizeof(bitmap_conf_params)))
++			return -EFAULT;
++		return vpbe_bitmap_set_params(info, &bitmap_conf_params);
++
++	case FBIO_SET_BACKG_COLOR:
++		if (copy_from_user(&backg_color, argp, sizeof(backg_color)))
++			return -EFAULT;
++		return vpbe_set_backg_color(info, &backg_color);
++
++	case FBIO_SETPOS:
++		if (copy_from_user(&win_pos, argp, sizeof(win_pos)))
++			return -EFAULT;
++		return vpbe_setpos(info, &win_pos);
++
++	case FBIO_SET_CURSOR:
++		if (copy_from_user(&cursor, argp, sizeof(cursor)))
++			return -EFAULT;
++		return vpbe_set_cursor_params(info, &cursor);
++
++	default:
++		return -EINVAL;
++	}
++}
++
++
++/*
++ * fb_check_var method
++ */
++static int
++davincifb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
++{
++	struct vpbe_dm_win_info *win = info->par;
++	struct fb_videomode *mode = &win->dm->mode;
++	struct davinci_layer_config lconfig;
++	struct fb_fix_screeninfo fix;
++		
++	/*
++	 * Get an updated copy of the video mode from the encoder manager, just
++	 * in case the display has been switched.
++	 */
++	get_video_mode(mode);
++
++	/*
++	 * xres, yres, xres_virtual, or yres_virtual equal to zero is treated as
++	 * a special case.  It indicates that the window should be disabled.  If
++	 * the window is a video window, it will also be released.
++	 */
++	if (var->xres == 0 || var->yres == 0 || var->xres_virtual == 0
++	    || var->yres_virtual == 0) {
++		var->xres = 0;
++		var->yres = 0;
++		var->xres_virtual = 0;
++		var->yres_virtual = 0;
++		return 0;
++	}
++
++	switch (var->bits_per_pixel) {
++	case 1:
++	case 2:
++	case 4:
++	case 8:
++	case 16:
++		break;
++	case 24:
++		if (cpu_is_davinci_dm355())
++			return -EINVAL;
++		break;
++	case 32:
++		if (cpu_is_davinci_dm644x())
++			return -EINVAL;
++		break;
++	default:
++		return -EINVAL;
++	}
++
++	if (var->xres_virtual < var->xres || var->yres_virtual < var->yres)
++		return -EINVAL;
++	if (var->xoffset > var->xres_virtual - var->xres)
++		return -EINVAL;
++	if (var->yoffset > var->yres_virtual - var->yres)
++		return -EINVAL;
++	if (mode->xres < var->xres || mode->yres < var->yres)
++		return -EINVAL;
++	if (win->xpos > mode->xres - var->xres)
++		return -EINVAL;
++	if (win->ypos > mode->yres - var->yres)
++		return -EINVAL;
++	convert_fb_var_to_osd(var, &lconfig, win->dm->yc_pixfmt);
++
++	update_fix_info(var, &fix);
++	lconfig.line_length = fix.line_length;
++	lconfig.xpos = win->xpos;
++	lconfig.ypos = win->ypos;
++	/* xoffset must be a multiple of xpanstep */
++	if (var->xoffset & ~(fix.xpanstep - 1))
++		return -EINVAL;
++
++	/* check if we have enough video memory to support this mode */
++	if (!window_will_fit_framebuffer(var, info->fix.smem_len))
++		return -EINVAL;
++
++	/* see if the OSD manager approves of this configuration */
++	if (davinci_disp_try_layer_config(win->layer, &lconfig))
++		return -EINVAL;
++	/*
++	 * Reject this var if the OSD manager would have to modify the window
++	 * geometry to make it work.
++	 */
++	if (lconfig.xsize != var->xres || lconfig.ysize != var->yres)
++		return -EINVAL;
++	if (lconfig.xpos != win->xpos || lconfig.ypos != win->ypos)
++		return -EINVAL;
++	
++	/*
++	 * At this point we have accepted the var, so now we convert our layer
++	 * configuration struct back to the var in order to make all of the
++	 * pixel format and geometry values consistent.  The var timing values
++	 * will be unmodified, as we have no way to verify them.
++	 */
++	convert_osd_to_fb_var(&lconfig, var);
++
++	return 0;
++}
++
++/*
++ * fb_set_par method
++ */
++static int davincifb_set_par(struct fb_info *info)
++{
++	struct vpbe_dm_win_info *win = info->par;
++	struct fb_var_screeninfo *var = &info->var;
++	struct davinci_layer_config lconfig;
++	struct fb_videomode mode;
++	unsigned start;
++
++	/* update the fix info to be consistent with the var */
++	update_fix_info(var, &info->fix);
++	convert_fb_info_to_osd(info, &lconfig);
++
++	/* See if we need to pass the timing values to the encoder manager. */
++	memcpy(&mode, &win->dm->mode, sizeof(mode));
++	fb_var_to_videomode(&mode, var);
++	mode.name = win->dm->mode.name;
++	if (mode.xres == win->dm->mode.xres && mode.yres == win->dm->mode.yres
++	    && mode.pixclock != 0) {
++		/*
++		 * If the timing parameters from the var are different than the
++		 * timing parameters from the encoder, try to update the
++		 * timing parameters with the encoder manager.
++		 */
++		if (!fb_mode_is_equal(&mode, &win->dm->mode))
++			set_video_mode(&mode);
++	}
++	/* update our copy of the encoder video mode */
++	get_video_mode(&win->dm->mode);
++
++	/* turn off ping-pong buffer and field inversion to fix
++	   the image shaking problem in 1080I mode. The problem i.d. by the
++	   DM6446 Advisory 1.3.8 is not seen in 1080I mode, but the ping-pong
++	   buffer workaround created a shaking problem. */
++/* Sandeep */
++#if 0
++	if (win->layer == WIN_VID0 &&
++	    strcmp(mode.name, VID_ENC_STD_1080I_30) == 0 &&
++	    (cpu_is_davinci_dm644x_pg1x() || cpu_is_davinci_dm357()))
++		davinci_disp_set_field_inversion(0);
++#endif
++	/*
++	 * Update the var with the encoder timing info.  The window geometry
++	 * will be preserved.
++	 */
++	construct_fb_var(var, &win->dm->mode, &lconfig);
++
++	/* need to update interlaced since the mode may have changed */
++	lconfig.interlaced = var->vmode = win->dm->mode.vmode;
++	/*
++	 * xres, yres, xres_virtual, or yres_virtual equal to zero is treated as
++	 * a special case.  It indicates that the window should be disabled.  If
++	 * the window is a video window, it will also be released.
++	 * Note that we disable the window, but we do not set the
++	 * win->disable_window flag.  This allows the window to be re-enabled
++	 * simply by using the FBIOPUT_VSCREENINFO ioctl to set a valid
++	 * configuration.
++	 */
++	if (lconfig.xsize == 0 || lconfig.ysize == 0) {
++		if (win->own_window) {
++			davinci_disp_disable_layer(win->layer);
++			if (is_vid_win(info)) {
++				win->own_window = 0;
++				davinci_disp_release_layer(win->layer);
++			}
++		}
++		return 0;
++	}
++
++	/*
++	 * If we don't currently own this window, we must claim it from the OSD
++	 * manager.
++	 */
++	if (!win->own_window) {
++		if (davinci_disp_request_layer(win->layer))
++			return -ENODEV;
++		win->own_window = 1;
++	}
++
++	/* DM365 YUV420 Planar */
++	if (cpu_is_davinci_dm365() &&
++			info->var.bits_per_pixel == 8 &&
++			(win->layer == WIN_VID0 || win->layer == WIN_VID1)
++			) {
++		start =
++			info->fix.smem_start +
++			(var->xoffset * 12) / 8 +
++			var->yoffset * 3 / 2 * info->fix.line_length;
++	} else {
++		start =
++		info->fix.smem_start + (var->xoffset * var->bits_per_pixel) / 8
++		+ var->yoffset * info->fix.line_length;
++	}
++	davinci_disp_set_layer_config(win->layer, &lconfig);
++	davinci_disp_start_layer(win->layer, start, fb_cbcr_ofst);
++	if (win->display_window)
++		davinci_disp_enable_layer(win->layer, 0);
++
++	return 0;
++}
++
++/*
++ * This macro converts a 16-bit color passed to fb_setcolreg to the width
++ * supported by the pixel format.
++ */
++#define CNVT_TOHW(val,width) ((((val)<<(width))+0x7FFF-(val))>>16)
++
++/*
++ * fb_setcolreg method
++ */
++static int davincifb_setcolreg(unsigned regno, unsigned red, unsigned green,
++			       unsigned blue, unsigned transp,
++			       struct fb_info *info)
++{
++	unsigned r, g, b, t;
++
++	if (regno >= 256)	/* no. of hw registers */
++		return -EINVAL;
++
++	/*
++	 * An RGB color palette isn't applicable to a window with a YUV pixel
++	 * format or to a window in attribute mode.
++	 */
++	if (is_yuv(&info->var) || is_attribute_mode(&info->var))
++		return -EINVAL;
++
++	switch (info->fix.visual) {
++	case FB_VISUAL_TRUECOLOR:
++		r = CNVT_TOHW(red, info->var.red.length);
++		g = CNVT_TOHW(green, info->var.green.length);
++		b = CNVT_TOHW(blue, info->var.blue.length);
++		t = CNVT_TOHW(transp, info->var.transp.length);
++		break;
++	case FB_VISUAL_PSEUDOCOLOR:
++	default:
++		r = CNVT_TOHW(red, 8);
++		g = CNVT_TOHW(green, 8);
++		b = CNVT_TOHW(blue, 8);
++		t = 0;
++		break;
++	}
++
++	/* Truecolor has hardware independent palette */
++	if (info->fix.visual == FB_VISUAL_TRUECOLOR) {
++		u32 v;
++
++		if (regno >= 16)
++			return -EINVAL;
++
++		v = (r << info->var.red.offset) |
++		    (g << info->var.green.offset) |
++		    (b << info->var.blue.offset) |
++		    (t << info->var.transp.offset);
++
++		switch (info->var.bits_per_pixel) {
++		case 16:
++			((u16 *) (info->pseudo_palette))[regno] = v;
++			break;
++		case 24:
++		case 32:
++			((u32 *) (info->pseudo_palette))[regno] = v;
++			break;
++		}
++		return 0;
++	}
++
++	if (!is_osd_win(info))
++		return -EINVAL;
++
++	davinci_disp_set_clut_rgb(regno, r, g, b);
++
++	return 0;
++}
++
++/*
++ * fb_pan_display method
++ *
++ * Pan the display using the `xoffset' and `yoffset' fields of the `var'
++ * structure.  We don't support wrapping and ignore the FB_VMODE_YWRAP flag.
++ */
++static int
++davincifb_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)
++{
++	struct vpbe_dm_win_info *win = info->par;
++	unsigned start;
++
++	if (!win->own_window)
++		return -ENODEV;
++
++	if (var->xoffset > info->var.xres_virtual - info->var.xres)
++		return -EINVAL;
++	if (var->yoffset > info->var.yres_virtual - info->var.yres)
++		return -EINVAL;
++
++	/* xoffset must be a multiple of xpanstep */
++	if (var->xoffset & ~(info->fix.xpanstep - 1))
++		return -EINVAL;
++
++	/* For DM365 video windows:
++   * using bits_per_pixel to calculate start/offset address
++   * needs to be changed for YUV420 planar format since
++   * it is 8. But consider CbCr the real (avg) bits per pixel
++   * is 12. line_length is calcuate using 8, so offset needs
++   * to time 1.5 to take C plane into account.
++   */
++	if (cpu_is_davinci_dm365() &&
++			info->var.bits_per_pixel == 8 &&
++			(win->layer == WIN_VID0 || win->layer == WIN_VID1)
++			) {
++		start =
++	    info->fix.smem_start +
++	    (var->xoffset * 12) / 8 +
++	    var->yoffset * 3 / 2 * info->fix.line_length;
++	} else {
++		start =
++	    info->fix.smem_start +
++	    (var->xoffset * info->var.bits_per_pixel) / 8 +
++	    var->yoffset * info->fix.line_length;
++	}
++	if (davinci_disp_is_second_field()) {
++		davinci_disp_start_layer(win->layer, start, fb_cbcr_ofst);
++	} else
++		win->sdram_address = start;
++
++	return 0;
++}
++
++/*
++ * fb_blank method
++ *
++ * Blank the screen if blank_mode != 0, else unblank.
++ */
++int davincifb_blank(int blank_mode, struct fb_info *info)
++{
++	struct vpbe_dm_win_info *win = info->par;
++	int retval = 0;
++
++	if (!win->own_window)
++		return -ENODEV;
++
++	if (!blank_mode) {
++		win->display_window = 1;
++		retval = info->fbops->fb_check_var(&info->var, info);
++		if (retval)
++			return retval;
++		retval = info->fbops->fb_set_par(info);
++	} else {
++		win->display_window = 0;
++		davinci_disp_disable_layer(win->layer);
++	}
++
++	return retval;
++}
++
++/*
++ *  Frame buffer operations
++ */
++static struct fb_ops davincifb_ops = {
++	.owner = THIS_MODULE,
++	.fb_check_var = davincifb_check_var,
++	.fb_set_par = davincifb_set_par,
++	.fb_setcolreg = davincifb_setcolreg,
++	.fb_blank = davincifb_blank,
++	.fb_pan_display = davincifb_pan_display,
++	.fb_fillrect = cfb_fillrect,
++	.fb_copyarea = cfb_copyarea,
++	.fb_imageblit = cfb_imageblit,
++	.fb_rotate = NULL,
++	.fb_sync = NULL,
++	.fb_ioctl = davincifb_ioctl,
++};
++
++static void davincifb_release_window(struct device *dev,
++				     struct vpbe_dm_win_info *win)
++{
++	struct fb_info *info = win->info;
++
++	if (info) {
++		unregister_framebuffer(info);
++		win->info = NULL;
++	}
++
++	if (win->own_window) {
++		davinci_disp_release_layer(win->layer);
++		win->own_window = 0;
++	}
++	win->display_window = 0;
++
++	if (info) {
++		dma_free_coherent(dev, info->fix.smem_len, info->screen_base,
++				  info->fix.smem_start);
++		fb_dealloc_cmap(&info->cmap);
++		kfree(info);
++	}
++}
++
++static int davincifb_init_window(struct device *dev,
++				 struct vpbe_dm_win_info *win,
++				 struct davinci_layer_config *lconfig,
++				 unsigned fb_size, const char *name)
++{
++	struct fb_info *info;
++	int err;
++
++	if (!fb_size)
++		return 0;
++
++	info = kzalloc(sizeof(*info), GFP_KERNEL);
++	if (!info) {
++		dev_err(dev, "%s: Can't allocate memory for fb_info struct.\n",
++			name);
++		return -ENOMEM;
++	}
++	win->info = info;
++
++	/* initialize fb_info */
++	info->par = win;
++	info->flags =
++	    FBINFO_DEFAULT | FBINFO_HWACCEL_COPYAREA | FBINFO_HWACCEL_FILLRECT |
++	    FBINFO_HWACCEL_IMAGEBLIT | FBINFO_HWACCEL_XPAN |
++	    FBINFO_HWACCEL_YPAN;
++	info->fbops = &davincifb_ops;
++	info->screen_size = fb_size;
++	info->pseudo_palette = win->pseudo_palette;
++	if (fb_alloc_cmap(&info->cmap, 256, 0) < 0) {
++		dev_err(dev, "%s: Can't allocate color map.\n", name);
++		err = -ENODEV;
++		goto cmap_out;
++	}
++
++	/* initialize fb_fix_screeninfo */
++	strlcpy(info->fix.id, name, sizeof(info->fix.id));
++	info->fix.smem_len = fb_size;
++	info->fix.type = FB_TYPE_PACKED_PIXELS;
++
++	/* allocate the framebuffer */
++	info->screen_base =
++	    dma_alloc_coherent(dev, info->fix.smem_len,
++			       (dma_addr_t *) & info->fix.smem_start,
++			       GFP_KERNEL | GFP_DMA);
++	if (!info->screen_base) {
++		dev_err(dev, "%s: dma_alloc_coherent failed when allocating "
++			"framebuffer.\n", name);
++		err = -ENOMEM;
++		goto fb_alloc_out;
++	}
++
++	/*
++	 * Fill the framebuffer with zeros unless it is an OSD1 window in
++	 * attribute mode, in which case we fill it with 0x77 to make the OSD0
++	 * pixels opaque.
++	 */
++	memset(info->screen_base,
++	       (lconfig->pixfmt == PIXFMT_OSD_ATTR) ? 0x77 : 0,
++	       info->fix.smem_len);
++
++	/* initialize fb_var_screeninfo */
++	construct_fb_var(&info->var, &win->dm->mode, lconfig);
++	win->xpos = lconfig->xpos;
++	win->ypos = lconfig->ypos;
++	info->var.xres_virtual = info->var.xres;
++	info->var.yres_virtual = info->var.yres;
++
++	/* update the fix info to be consistent with the var */
++	update_fix_info(&info->var, &info->fix);
++
++	/*
++	 * Request ownership of the window from the OSD manager unless this is
++	 * a video window and the window size is 0.
++	 */
++	if (is_osd_win(info) || (info->var.xres != 0 && info->var.yres != 0)) {
++		if (!davinci_disp_request_layer(win->layer))
++			win->own_window = 1;
++	}
++	/* bail out if this is an OSD window and we don't own it */
++	if (is_osd_win(info) && !win->own_window) {
++		dev_err(dev, "%s: Failed to obtain ownership of OSD "
++			"window.\n", name);
++		err = -ENODEV;
++		goto own_out;
++	}
++
++	win->display_window = 1;
++
++	if (win->own_window) {
++		/* check if our initial window configuration is valid */
++		if (info->fbops->fb_check_var(&info->var, info)) {
++			dev_warn(dev, "%s: Initial window configuration is "
++				 "invalid.\n", name);
++		} else
++			info->fbops->fb_set_par(info);
++	}
++
++	/* register the framebuffer */
++	if (register_framebuffer(info)) {
++		dev_err(dev, "%s: Failed to register framebuffer.\n", name);
++		err = -ENODEV;
++		goto register_out;
++	}
++
++	dev_info(dev, "%s: %dx%dx%d@%d,%d with framebuffer size %dKB\n",
++		 info->fix.id, info->var.xres, info->var.yres,
++		 info->var.bits_per_pixel, win->xpos, win->ypos,
++		 info->fix.smem_len >> 10);
++
++	return 0;
++
++      register_out:
++	if (win->own_window)
++		davinci_disp_release_layer(win->layer);
++	win->own_window = 0;
++      own_out:
++	dma_free_coherent(dev, info->fix.smem_len, info->screen_base,
++			  info->fix.smem_start);
++      fb_alloc_out:
++	fb_dealloc_cmap(&info->cmap);
++      cmap_out:
++	kfree(info);
++
++	return err;
++}
++
++static int davincifb_remove(struct device *dev)
++{
++//	struct device *dev = &pdev->dev;
++	struct vpbe_dm_info *dm = dev_get_drvdata(dev);
++
++	dev_set_drvdata(dev, NULL);
++
++	davinci_disp_unregister_callback(&dm->vsync_callback);
++
++	davincifb_release_window(dev, &dm->win[WIN_VID1]);
++	davincifb_release_window(dev, &dm->win[WIN_OSD1]);
++	davincifb_release_window(dev, &dm->win[WIN_VID0]);
++	davincifb_release_window(dev, &dm->win[WIN_OSD0]);
++
++	kfree(dm);
++
++	return 0;
++}
++
++/*
++ * Return the maximum number of bytes per screen for a display layer at a
++ * resolution specified by an fb_videomode struct.
++ */
++static unsigned davincifb_max_screen_size(enum davinci_disp_layer layer,
++					  const struct fb_videomode *mode)
++{
++	unsigned max_bpp = 32;
++	unsigned line_length;
++	unsigned size;
++
++	switch (layer) {
++	case WIN_OSD0:
++	case WIN_OSD1:
++		if (cpu_is_davinci_dm355())
++			max_bpp = 32;
++		else
++			max_bpp = 16;
++		break;
++	case WIN_VID0:
++	case WIN_VID1:
++		if (cpu_is_davinci_dm355())
++			max_bpp = 16;
++		else
++			max_bpp = 24;
++		break;
++	}
++
++	line_length = (mode->xres * max_bpp + 7) / 8;
++	line_length = ((line_length + 31) / 32) * 32;
++	size = mode->yres * line_length;
++
++	return size;
++}
++
++static void parse_win_params(struct vpbe_dm_win_info *win,
++			     struct davinci_layer_config *lconfig,
++			     unsigned *fb_size, char *opt)
++{
++	char *s, *p, c = 0;
++	unsigned bits_per_pixel;
++
++	if (!opt)
++		return;
++
++	/* xsize */
++	p = strpbrk(opt, "x,@");
++	if (p)
++		c = *p;
++	if ((s = strsep(&opt, "x,@")) == NULL)
++		return;
++	if (*s)
++		lconfig->xsize = simple_strtoul(s, NULL, 0);
++	if (!p || !opt)
++		return;
++
++	/* ysize */
++	if (c == 'x') {
++		p = strpbrk(opt, "x,@");
++		if (p)
++			c = *p;
++		if ((s = strsep(&opt, "x,@")) == NULL)
++			return;
++		if (*s)
++			lconfig->ysize = simple_strtoul(s, NULL, 0);
++		if (!p || !opt)
++			return;
++	}
++
++	/* bits per pixel */
++	if (c == 'x') {
++		p = strpbrk(opt, ",@");
++		if (p)
++			c = *p;
++		if ((s = strsep(&opt, ",@")) == NULL)
++			return;
++		if (*s) {
++			bits_per_pixel = simple_strtoul(s, NULL, 0);
++			switch (bits_per_pixel) {
++			case 1:
++				if (win->layer == WIN_OSD0
++				    || win->layer == WIN_OSD1)
++					lconfig->pixfmt = PIXFMT_1BPP;
++				break;
++			case 2:
++				if (win->layer == WIN_OSD0
++				    || win->layer == WIN_OSD1)
++					lconfig->pixfmt = PIXFMT_2BPP;
++				break;
++			case 4:
++				if (win->layer == WIN_OSD0
++				    || win->layer == WIN_OSD1)
++					lconfig->pixfmt = PIXFMT_4BPP;
++				break;
++			case 8:
++				if (win->layer == WIN_OSD0
++				    || win->layer == WIN_OSD1)
++					lconfig->pixfmt = PIXFMT_8BPP;
++				if (cpu_is_davinci_dm365())
++					if (win->layer == WIN_VID0 ||
++					    win->layer == WIN_VID1)
++						lconfig->pixfmt = PIXFMT_NV12;
++				break;
++			case 16:
++				if (win->layer == WIN_OSD0
++				    || win->layer == WIN_OSD1)
++					lconfig->pixfmt = PIXFMT_RGB565;
++				else
++					lconfig->pixfmt = win->dm->yc_pixfmt;
++				break;
++			case 24:
++				if (cpu_is_davinci_dm644x()
++				    && (win->layer == WIN_VID0
++					|| win->layer == WIN_VID1))
++					lconfig->pixfmt = PIXFMT_RGB888;
++				break;
++			case 32:
++				if (cpu_is_davinci_dm355()
++				    && (win->layer == WIN_OSD0
++					|| win->layer == WIN_OSD1))
++					lconfig->pixfmt = PIXFMT_RGB888;
++				break;
++			default:
++				break;
++			}
++		}
++		if (!p || !opt)
++			return;
++	}
++
++	/* framebuffer size */
++	if (c == ',') {
++		p = strpbrk(opt, "@");
++		if (p)
++			c = *p;
++		if ((s = strsep(&opt, "@")) == NULL)
++			return;
++		if (*s) {
++			*fb_size = simple_strtoul(s, &s, 0);
++			if (*s == 'K')
++				*fb_size <<= 10;
++			if (*s == 'M')
++				*fb_size <<= 20;
++		}
++		if (!p || !opt)
++			return;
++	}
++
++	/* xpos */
++	if (c == '@') {
++		p = strpbrk(opt, ",");
++		if (p)
++			c = *p;
++		if ((s = strsep(&opt, ",")) == NULL)
++			return;
++		if (*s)
++			lconfig->xpos = simple_strtoul(s, NULL, 0);
++		if (!p || !opt)
++			return;
++	}
++
++	/* ypos */
++	if (c == ',') {
++		s = opt;
++		if (*s)
++			lconfig->ypos = simple_strtoul(s, NULL, 0);
++	}
++
++	return;
++}
++
++/*
++ * Pass boot-time options by adding the following string to the boot params:
++ *	video=davincifb:options
++ * Valid options:
++ *	osd0=[MxNxP,S@X,Y]
++ *      osd1=[MxNxP,S@X,Y]
++ *	vid0=[off|MxNxP,S@X,Y]
++ *	vid1=[off|MxNxP,S@X,Y]
++ *		MxN are the horizontal and vertical window size
++ *		P is the color depth (bits per pixel)
++ *		S is the framebuffer size with a size suffix such as 'K' or 'M'
++ *		X,Y are the window position
++ *
++ * Only video windows can be turned off.  Turning off a video window means that
++ * no framebuffer device will be registered for it,
++ *
++ * To cause a window to be supported by the framebuffer driver but not displayed
++ * initially, pass a value of 0 for the window size.
++ *
++ * For example:
++ *      video=davincifb:osd0=720x480x16@0,0:osd1=720x480:vid0=off:vid1=off
++ *
++ * This routine returns 1 if the window is to be turned off, or 0 otherwise.
++ */
++static int davincifb_get_default_win_config(struct device *dev,
++					    struct vpbe_dm_win_info *win,
++					    struct davinci_layer_config
++					    *lconfig, unsigned *fb_size,
++					    const char *options)
++{
++	const char *win_names[] = { "osd0=", "vid0=", "osd1=", "vid1=" };
++	const char *this_opt, *next_opt;
++	int this_len, opt_len;
++	static char opt_buf[128];
++
++	/* supply default values for lconfig and fb_size */
++	switch (win->layer) {
++	case WIN_OSD0:
++		lconfig->pixfmt = PIXFMT_RGB565;
++		lconfig->xsize = win->dm->mode.xres;
++		lconfig->ysize = win->dm->mode.yres;
++		break;
++	case WIN_OSD1:
++		lconfig->pixfmt = PIXFMT_OSD_ATTR;
++		lconfig->xsize = win->dm->mode.xres;
++		lconfig->ysize = win->dm->mode.yres;
++		break;
++	case WIN_VID0:
++	case WIN_VID1:
++		lconfig->pixfmt = win->dm->yc_pixfmt;
++		lconfig->xsize = 0;
++		lconfig->ysize = 0;
++		break;
++	}
++	lconfig->xpos = 0;
++	lconfig->ypos = 0;
++
++	lconfig->interlaced = is_display_interlaced(&win->dm->mode);
++	*fb_size = davincifb_max_screen_size(win->layer, &win->dm->mode);
++
++	next_opt = options;
++	while ((this_opt = next_opt)) {
++		this_len = strcspn(this_opt, ":");
++		next_opt = strpbrk(this_opt, ":");
++		if (next_opt)
++			++next_opt;
++
++		opt_len = strlen(win_names[win->layer]);
++		if (this_len >= opt_len) {
++			if (strncmp(this_opt, win_names[win->layer], opt_len))
++				continue;
++			this_len -= opt_len;
++			this_opt += opt_len;
++			if ((this_len >= strlen("off"))
++			    && !strncmp(this_opt, "off", strlen("off")))
++				return 1;
++			else {
++				strlcpy(opt_buf, this_opt,
++					min_t(int, sizeof(opt_buf),
++					      this_len + 1));
++				parse_win_params(win, lconfig, fb_size,
++						 opt_buf);
++				return 0;
++			}
++		}
++	}
++
++	return 0;
++}
++
++/*
++ *     Module parameter definitions
++ */
++static char *options = "";
++
++module_param(options, charp, S_IRUGO);
++
++static int davincifb_probe(struct device *dev)
++{
++//	struct device *dev = &pdev->dev;
++	struct vpbe_dm_info *dm;
++	struct davinci_layer_config lconfig;
++	unsigned fb_size;
++	int err;
++
++	dm = kzalloc(sizeof(*dm), GFP_KERNEL);
++	if (!dm) {
++		dev_err(dev, "Can't allocate memory for driver state.\n");
++		return -ENOMEM;
++	}
++	dev_set_drvdata(dev, dm);
++
++	/* get the video mode from the encoder manager */
++	get_video_mode(&dm->mode);
++
++	/* set the default Cb/Cr order */
++	dm->yc_pixfmt = PIXFMT_YCbCrI;
++
++	/* initialize OSD0 */
++	dm->win[WIN_OSD0].layer = WIN_OSD0;
++	dm->win[WIN_OSD0].dm = dm;
++	dm->win[WIN_OSD0].sdram_address = 0;
++	davincifb_get_default_win_config(dev, &dm->win[WIN_OSD0], &lconfig,
++					 &fb_size, options);
++	err =
++	    davincifb_init_window(dev, &dm->win[WIN_OSD0], &lconfig, fb_size,
++				  OSD0_FBNAME);
++	if (err)
++		goto osd0_out;
++
++	/* initialize VID0 */
++	dm->win[WIN_VID0].layer = WIN_VID0;
++	dm->win[WIN_VID0].dm = dm;
++	dm->win[WIN_VID0].sdram_address = 0;
++	if (!davincifb_get_default_win_config
++	    (dev, &dm->win[WIN_VID0], &lconfig, &fb_size, options)) {
++		err =
++		    davincifb_init_window(dev, &dm->win[WIN_VID0], &lconfig,
++					  fb_size, VID0_FBNAME);
++		if (err)
++			goto vid0_out;
++	}
++
++	/* initialize OSD1 */
++	dm->win[WIN_OSD1].layer = WIN_OSD1;
++	dm->win[WIN_OSD1].dm = dm;
++	dm->win[WIN_OSD1].sdram_address = 0;
++	davincifb_get_default_win_config(dev, &dm->win[WIN_OSD1], &lconfig,
++					 &fb_size, options);
++	err =
++	    davincifb_init_window(dev, &dm->win[WIN_OSD1], &lconfig, fb_size,
++				  OSD1_FBNAME);
++	if (err)
++		goto osd1_out;
++
++	/* initialize VID1 */
++	dm->win[WIN_VID1].layer = WIN_VID1;
++	dm->win[WIN_VID1].dm = dm;
++	dm->win[WIN_VID1].sdram_address = 0;
++	if (!davincifb_get_default_win_config
++	    (dev, &dm->win[WIN_VID1], &lconfig, &fb_size, options)) {
++		err =
++		    davincifb_init_window(dev, &dm->win[WIN_VID1], &lconfig,
++					  fb_size, VID1_FBNAME);
++		if (err)
++			goto vid1_out;
++	}
++
++	/* initialize the vsync wait queue */
++	init_waitqueue_head(&dm->vsync_wait);
++	dm->timeout = HZ / 5;
++
++	/* register the end-of-frame callback */
++	dm->vsync_callback.mask = DAVINCI_DISP_FIRST_FIELD |
++	    DAVINCI_DISP_SECOND_FIELD | DAVINCI_DISP_END_OF_FRAME;
++
++	dm->vsync_callback.handler = davincifb_vsync_callback;
++	dm->vsync_callback.arg = dm;
++	davinci_disp_register_callback(&dm->vsync_callback);
++
++	return 0;
++
++      vid1_out:
++	davincifb_release_window(dev, &dm->win[WIN_OSD1]);
++      osd1_out:
++	davincifb_release_window(dev, &dm->win[WIN_VID0]);
++      vid0_out:
++	davincifb_release_window(dev, &dm->win[WIN_OSD0]);
++      osd0_out:
++	kfree(dm);
++
++	return err;
++}
++
++static void davincifb_release_dev(struct device *dev)
++{
++}
++
++static u64 davincifb_dmamask = ~(u32) 0;
++
++/* FIXME: move to board setup file */
++static struct platform_device davincifb_device = {
++	.name = "davincifb",
++	.id = 0,
++	.dev = {
++		.release = davincifb_release_dev,
++		.dma_mask = &davincifb_dmamask,
++		.coherent_dma_mask = 0xffffffff,
++		},
++	.num_resources = 0,
++};
++
++static struct device_driver davincifb_driver = {
++	.name = "davincifb",
++	.bus = &platform_bus_type,
++	.probe = davincifb_probe,
++	.remove = davincifb_remove,
++	.suspend = NULL,
++	.resume = NULL,
++};
++#if 0
++static struct platform_driver davincifb_driver = {
++	.probe = davincifb_probe,
++	.remove = davincifb_remove,
++	.driver = {
++			.name = "davincifb",
++			.owner = THIS_MODULE,
++		},
++};
++#endif
++static int __init davincifb_init(void)
++{
++	struct device *dev = &davincifb_device.dev;
++#ifndef MODULE
++	{
++		char *names[] = { "davincifb", "dm64xxfb", "dm355fb" };
++		int i, num_names = 3;
++
++		for (i = 0; i < num_names; i++) {
++			if (fb_get_options(names[i], &options)) {
++				dev_err(dev, " Disabled on command-line.\n");
++				return -ENODEV;
++			}
++			if (options)
++				break;
++		}
++	}
++#endif
++
++	/* Register the device with LDM */
++	if (platform_device_register(&davincifb_device)) {
++		pr_debug("failed to register davincifb device\n");
++		return -ENODEV;
++	}
++
++	/* Register the driver with LDM */
++	if (driver_register(&davincifb_driver)) {
++		dev_err(dev, "failed to register davincifb driver\n");
++		platform_device_unregister(&davincifb_device);
++		return -ENODEV;
++	}
++
++	return 0;
++}
++
++static void __exit davincifb_cleanup(void)
++{
++	driver_unregister(&davincifb_driver);
++	platform_device_unregister(&davincifb_device);
++}
++
++module_init(davincifb_init);
++module_exit(davincifb_cleanup);
++
++MODULE_DESCRIPTION("Framebuffer driver for TI DaVinci");
++MODULE_AUTHOR("MontaVista Software");
++MODULE_LICENSE("GPL");
+--- /dev/null
++++ b/drivers/char/imp_common.c
+@@ -0,0 +1,1539 @@
++/*
++ * Copyright (C) 2008 Texas Instruments Inc
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
++ */
++
++#include <linux/module.h>
++#include <linux/init.h>
++#include <linux/kernel.h>
++#include <linux/slab.h>
++#include <linux/fs.h>
++#include <linux/errno.h>
++#include <linux/types.h>
++#include <linux/cdev.h>
++#include <linux/dma-mapping.h>
++#include <linux/interrupt.h>
++#include <linux/uaccess.h>
++#include <linux/device.h>
++
++#include <media/davinci/vpss.h>
++#include <media/davinci/imp_hw_if.h>
++
++#include <mach/cputype.h>
++
++static int serializer_initialized;
++struct imp_serializer imp_serializer_info;
++static struct imp_hw_interface *imp_hw_if;
++
++int imp_common_mmap(struct file *filp,
++		    struct vm_area_struct *vma,
++		    struct imp_logical_channel *channel)
++{
++	int i, flag = 0, shift;
++	/* get the page offset */
++	unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
++	shift = PAGE_SHIFT;
++	for (i = 0; i < channel->in_numbufs; i++) {
++		if (channel->in_bufs[i]->offset == offset) {
++			flag = 1;
++			break;
++		}
++	}
++
++	/* page offset passed in mmap should one from output buffers */
++	if (flag == 0) {
++		for (i = 0; i < channel->out_numbuf1s; i++) {
++			if (channel->out_buf1s[i]->offset == offset) {
++				flag = 1;
++				break;
++			}
++		}
++	}
++
++	if (flag == 0) {
++		for (i = 0; i < channel->out_numbuf2s; i++) {
++			if (channel->out_buf2s[i]->offset == offset) {
++				flag = 1;
++				break;
++			}
++		}
++	}
++	if (flag) {
++		/* map buffers address space from kernel space to user space */
++		if (remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff,
++				    vma->vm_end - vma->vm_start,
++				    vma->vm_page_prot))
++			return -EAGAIN;
++	} else {
++		/* No matching buffer */
++		return -EINVAL;
++	}
++	return 0;
++}
++EXPORT_SYMBOL(imp_common_mmap);
++
++/* inline function to free reserver pages  */
++static inline void imp_common_free_pages(unsigned long addr,
++					 unsigned long bufsize)
++{
++	unsigned long size, ad = addr;
++	size = PAGE_SIZE << (get_order(bufsize));
++	if (!addr)
++		return;
++	while (size > 0) {
++		ClearPageReserved(virt_to_page(addr));
++		addr += PAGE_SIZE;
++		size -= PAGE_SIZE;
++	}
++	free_pages(ad, get_order(bufsize));
++}
++
++/* This function is used to free memory allocated to buffers */
++int imp_common_free_buffers(struct device *dev,
++			    struct imp_logical_channel *channel)
++{
++	int i;
++	unsigned long adr;
++	if (!channel) {
++		dev_err(dev, "\nfree_buffers:error in argument");
++		return -EINVAL;
++	}
++	/* free memory allocated to in buffers */
++	for (i = 0; i < channel->in_numbufs; i++) {
++		if (channel->in_bufs[i]) {
++			adr = channel->in_bufs[i]->offset;
++			if (adr)
++				imp_common_free_pages((unsigned long)
++						      phys_to_virt(adr),
++						      channel->in_bufs[i]->
++						      size);
++
++			kfree(channel->in_bufs[i]);
++
++			channel->in_bufs[i] = NULL;
++		}
++	}
++	channel->in_numbufs = 0;
++	/* free memory allocated to out buffers */
++	for (i = 0; i < channel->out_numbuf1s; i++) {
++		if (channel->out_buf1s[i]) {
++			adr = channel->out_buf1s[i]->offset;
++			if (adr)
++				imp_common_free_pages((unsigned long)
++						      phys_to_virt(adr),
++						      channel->out_buf1s[i]->
++						      size);
++
++			kfree(channel->out_buf1s[i]);
++
++			channel->out_buf1s[i] = NULL;
++		}
++	}
++
++	channel->out_numbuf1s = 0;
++
++	/* free memory allocated to out buffers */
++	for (i = 0; i < channel->out_numbuf2s; i++) {
++		if (channel->out_buf2s[i]) {
++			adr = channel->out_buf2s[i]->offset;
++			if (adr)
++				imp_common_free_pages((unsigned long)
++						      phys_to_virt(adr),
++						      channel->out_buf2s[i]->
++						      size);
++
++			kfree(channel->out_buf2s[i]);
++
++			channel->out_buf2s[i] = NULL;
++		}
++	}
++
++	channel->out_numbuf2s = 0;
++	return 0;
++}
++EXPORT_SYMBOL(imp_common_free_buffers);
++
++/*
++ * This function will query the buffer's physical address
++ * whose index is passed in ipipe_buffer.
++ * It will store that address in ipipe_buffer.
++ */
++int imp_common_query_buffer(struct device *dev,
++			    struct imp_logical_channel *channel,
++			    struct imp_buffer *buffer)
++{
++
++	if (!buffer || !channel) {
++		dev_err(dev, "query_buffer: error in argument\n");
++		return -EINVAL;
++	}
++
++	if (buffer->index < 0) {
++		dev_err(dev, "query_buffer: invalid index %d\n", buffer->index);
++		return -EINVAL;
++	}
++
++	if ((buffer->buf_type != IMP_BUF_IN)
++	    && (buffer->buf_type != IMP_BUF_OUT1)
++	    && (buffer->buf_type != IMP_BUF_OUT2)) {
++		dev_err(dev, "request_buffer: invalid buffer type\n");
++		return -EINVAL;
++	}
++	/* if buf_type is input buffer then get offset of input buffer */
++	if (buffer->buf_type == IMP_BUF_IN) {
++		/* error checking for wrong index number */
++		if (buffer->index >= channel->in_numbufs) {
++			dev_err(dev, "query_buffer: invalid index");
++			return -EINVAL;
++		}
++
++		/* get the offset and size of the buffer and store
++		   it in buffer */
++		buffer->offset = channel->in_bufs[buffer->index]->offset;
++		buffer->size = channel->in_bufs[buffer->index]->size;
++	}
++	/* if buf_type is output buffer then get offset of output buffer */
++	else if (buffer->buf_type == IMP_BUF_OUT1) {
++		/* error checking for wrong index number */
++		if (buffer->index >= channel->out_numbuf1s) {
++			dev_err(dev, "query_buffer: invalid index\n");
++			return -EINVAL;
++		}
++		/* get the offset and size of the buffer and store
++		   it in buffer */
++		buffer->offset = channel->out_buf1s[buffer->index]->offset;
++		buffer->size = channel->out_buf1s[buffer->index]->size;
++	}
++	/* if buf_type is output buffer then get offset of output buffer */
++	else if (buffer->buf_type == IMP_BUF_OUT2) {
++		/* error checking for wrong index number */
++		if (buffer->index >= channel->out_numbuf2s) {
++			dev_err(dev, "query_buffer: invalid index\n");
++			return -EINVAL;
++		}
++		/* get the offset and size of the buffer and store
++		   it in buffer */
++		buffer->offset = channel->out_buf2s[buffer->index]->offset;
++		buffer->size = channel->out_buf2s[buffer->index]->size;
++	} else {
++		dev_err(dev, "query_buffer: invalid buffer type\n");
++		return -EINVAL;
++	}
++
++	return 0;
++}
++EXPORT_SYMBOL(imp_common_query_buffer);
++
++int imp_common_request_buffer(struct device *dev,
++			      struct imp_logical_channel *channel,
++			      struct imp_reqbufs *reqbufs)
++{
++	struct imp_buffer *buffer = NULL;
++	int count = 0;
++	unsigned long adr;
++	u32 size;
++
++	if (!reqbufs || !channel) {
++		dev_err(dev, "request_buffer: error in argument\n");
++		return -EINVAL;
++	}
++
++	/* if number of buffers requested is more then support return error */
++	if (reqbufs->count > MAX_BUFFERS) {
++		dev_err(dev, "request_buffer: invalid buffer count\n");
++		return -EINVAL;
++	}
++
++	if ((reqbufs->buf_type != IMP_BUF_IN)
++	    && (reqbufs->buf_type != IMP_BUF_OUT1)
++	    && (reqbufs->buf_type != IMP_BUF_OUT2)) {
++		dev_err(dev, "request_buffer: invalid buffer type %d\n",
++			reqbufs->buf_type);
++		return -EINVAL;
++	}
++	if (reqbufs->count < 0) {
++		dev_err(dev, "request_buffer: invalid buffer count %d\n",
++			reqbufs->count);
++		return -EINVAL;
++	}
++	/* if buf_type is input then allocate buffers for input */
++	if (reqbufs->buf_type == IMP_BUF_IN) {
++		/*if buffer count is zero, free all the buffers */
++		if (reqbufs->count == 0) {
++			/* free all the buffers */
++			for (count = 0; count < channel->in_numbufs; count++) {
++				/* free memory allocate for the image */
++				if (channel->in_bufs[count]) {
++					adr =
++					    (unsigned long)channel->
++					    in_bufs[count]->offset;
++					if (adr)
++						imp_common_free_pages((unsigned
++							long)
++							phys_to_virt
++							(adr),
++							channel->
++							in_bufs
++							[count]->
++							size);
++
++					/* free the memory allocated
++					   to ipipe_buffer */
++					kfree(channel->in_bufs[count]);
++
++					channel->in_bufs[count] = NULL;
++				}
++			}
++			channel->in_numbufs = 0;
++			return 0;
++		}
++
++		/* free the extra buffers */
++		if (channel->in_numbufs > reqbufs->count &&
++		    reqbufs->size == channel->in_bufs[0]->size) {
++			for (count = reqbufs->count;
++			     count < channel->in_numbufs; count++) {
++				/* free memory allocate for the image */
++				if (channel->in_bufs[count]) {
++					adr = channel->in_bufs[count]->offset;
++					if (adr)
++						imp_common_free_pages((unsigned
++								long)
++								phys_to_virt
++								(adr),
++								channel->
++								in_bufs
++								[count]->
++								size);
++
++					/* free the memory allocated
++					   to ipipe_buffer */
++					kfree(channel->in_bufs[count]);
++
++					channel->in_bufs[count] = NULL;
++				}
++			}
++			channel->in_numbufs = reqbufs->count;
++			return 0;
++		}
++		/* if size requested is different from already allocated,
++		   free memory of all already allocated buffers */
++		if (channel->in_numbufs) {
++			if (reqbufs->size != channel->in_bufs[0]->size) {
++				for (count = 0;
++				     count < channel->in_numbufs; count++) {
++					if (channel->in_bufs[count]) {
++						adr =
++						    channel->
++						    in_bufs[count]->offset;
++						if (adr)
++							imp_common_free_pages(
++							(unsigned long)
++							phys_to_virt(adr),
++							channel->in_bufs
++							[count]->size);
++
++						kfree(channel->in_bufs[count]);
++
++						channel->in_bufs[count] = NULL;
++					}
++				}
++				channel->in_numbufs = 0;
++			}
++		}
++
++		/* allocate the buffer */
++		for (count = channel->in_numbufs; count < reqbufs->count;
++		     count++) {
++			/* Allocate memory for struct ipipe_buffer */
++			buffer = kmalloc(sizeof(struct imp_buffer), GFP_KERNEL);
++
++			/* if memory allocation fails then return error */
++			if (!buffer) {
++				/* free all the buffers */
++				while (--count >= channel->in_numbufs) {
++					adr = channel->in_bufs[count]->offset;
++					if (adr)
++						imp_common_free_pages((unsigned
++								long)
++								phys_to_virt
++								(adr),
++								channel->
++								in_bufs
++								[count]->
++								size);
++					kfree(channel->in_bufs[count]);
++					channel->in_bufs[count] = NULL;
++				}
++				dev_err(dev,
++					"1.request_buffer:not enough memory\n");
++				return -ENOMEM;
++			}
++
++			/* assign buffer's address in configuration */
++			channel->in_bufs[count] = buffer;
++
++			/* set buffers index and buf_type,size parameters */
++			buffer->index = count;
++			buffer->buf_type = IMP_BUF_IN;
++			buffer->size = reqbufs->size;
++			/* allocate memory for buffer of size passed
++			   in reqbufs */
++			buffer->offset =
++			    (unsigned long)__get_free_pages(GFP_KERNEL |
++							    GFP_DMA,
++							    get_order
++							    (reqbufs->size));
++
++			/* if memory allocation fails, return error */
++			if (!(buffer->offset)) {
++				/* free all the buffer's space */
++				kfree(buffer);
++				channel->in_bufs[count] = NULL;
++				while (--count >= channel->in_numbufs) {
++					adr = channel->in_bufs[count]->offset;
++					if (adr)
++						imp_common_free_pages((unsigned
++								long)
++								phys_to_virt
++								(adr),
++								channel->
++								in_bufs
++								[count]->
++								size);
++					kfree(channel->in_bufs[count]);
++					channel->in_bufs[count] = NULL;
++				}
++				dev_err(dev,
++					"2.request_buffer:not enough memory\n");
++
++				return -ENOMEM;
++			}
++
++			adr = (unsigned long)buffer->offset;
++			size = PAGE_SIZE << (get_order(reqbufs->size));
++			while (size > 0) {
++				/* make sure the frame buffers
++				   are never swapped out of memory */
++				SetPageReserved(virt_to_page(adr));
++				adr += PAGE_SIZE;
++				size -= PAGE_SIZE;
++			}
++			/* convert vertual address to physical */
++			buffer->offset = (unsigned long)
++			    virt_to_phys((void *)(buffer->offset));
++		}
++		channel->in_numbufs = reqbufs->count;
++	}
++	/* if buf_type is output then allocate buffers for output */
++	else if (reqbufs->buf_type == IMP_BUF_OUT1) {
++		if (reqbufs->count == 0) {
++			/* free all the buffers */
++			for (count = 0; count < channel->out_numbuf1s;
++				count++) {
++				/* free memory allocate for the image */
++				if (channel->out_buf1s[count]) {
++					adr = channel->out_buf1s[count]->offset;
++					if (adr)
++						imp_common_free_pages((unsigned
++								long)
++								phys_to_virt
++								(adr),
++								channel->
++								out_buf1s
++								[count]->
++								size);
++
++					/* free the memory allocated to
++					   ipipe_buffer */
++					kfree(channel->out_buf1s[count]);
++
++					channel->out_buf1s[count] = NULL;
++				}
++			}
++			channel->out_numbuf1s = 0;
++
++			return 0;
++		}
++		/* free the buffers */
++		if (channel->out_numbuf1s > reqbufs->count &&
++		    reqbufs->size == channel->out_buf1s[0]->size) {
++			for (count = reqbufs->count;
++			     count < channel->out_numbuf1s; count++) {
++				/* free memory allocate for the image */
++				if (channel->out_buf1s[count]) {
++					adr = channel->out_buf1s[count]->offset;
++					if (adr)
++						imp_common_free_pages((unsigned
++								long)
++								phys_to_virt
++								(adr),
++								channel->
++								out_buf1s
++								[count]->
++								size);
++
++					/* free the memory allocated to
++					   ipipe_buffer */
++					kfree(channel->out_buf1s[count]);
++
++					channel->out_buf1s[count] = NULL;
++				}
++			}
++			channel->out_numbuf1s = reqbufs->count;
++
++			return 0;
++		}
++		/* if size requested is different from already allocated,
++		   free memory of all already allocated buffers */
++		if (channel->out_numbuf1s) {
++			if (reqbufs->size != channel->out_buf1s[0]->size) {
++				for (count = 0;
++				     count < channel->out_numbuf1s; count++) {
++					if (channel->out_buf1s[count]) {
++						adr =
++						    channel->
++						    out_buf1s[count]->offset;
++
++						if (adr)
++							imp_common_free_pages(
++								(unsigned long)
++								phys_to_virt
++								(adr),
++								channel->
++								out_buf1s
++								[count]->
++								size);
++
++						kfree(channel->
++						      out_buf1s[count]);
++
++						channel->out_buf1s[count] =
++						    NULL;
++					}
++				}
++				channel->out_numbuf1s = 0;
++			}
++		}
++
++		/* allocate the buffer */
++		for (count = channel->out_numbuf1s;
++		     count < reqbufs->count; count++) {
++			/* Allocate memory for struct ipipe_buffer */
++			buffer = kmalloc(sizeof(struct imp_buffer), GFP_KERNEL);
++
++			/* if memory allocation fails then return error */
++			if (!buffer) {
++				/* free all the buffers */
++				while (--count >= channel->out_numbuf1s) {
++					adr = channel->out_buf1s[count]->offset;
++					if (adr)
++						imp_common_free_pages((unsigned
++								long)
++								phys_to_virt
++								(adr),
++								channel->
++								out_buf1s
++								[count]->
++								size);
++					kfree(channel->out_buf1s[count]);
++					channel->out_buf1s[count] = NULL;
++				}
++
++				dev_err(dev,
++					"3.request_buffer:not enough memory\n");
++
++				return -ENOMEM;
++			}
++
++			/* assign buffer's address out configuration */
++			channel->out_buf1s[count] = buffer;
++
++			/* set buffers outdex and buf_type,size parameters */
++			buffer->index = count;
++			buffer->buf_type = IMP_BUF_OUT1;
++			buffer->size = reqbufs->size;
++			/* allocate memory for buffer of size passed
++			   in reqbufs */
++			buffer->offset =
++			    (unsigned long)__get_free_pages(GFP_KERNEL |
++							    GFP_DMA,
++							    get_order
++							    (reqbufs->size));
++
++			/* if memory allocation fails, return error */
++			if (!(buffer->offset)) {
++				/* free all the buffer's space */
++				kfree(buffer);
++				channel->out_buf1s[count] = NULL;
++				while (--count >= channel->out_numbuf1s) {
++					adr = channel->out_buf1s[count]->offset;
++					if (adr)
++						imp_common_free_pages((unsigned
++								long)
++								phys_to_virt
++								(adr),
++								channel->
++								out_buf1s
++								[count]->
++								size);
++					kfree(channel->out_buf1s[count]);
++					channel->out_buf1s[count] = NULL;
++				}
++				dev_err(dev,
++					"4.request_buffer:not enough memory\n");
++
++				return -ENOMEM;
++			}
++
++			adr = (unsigned long)buffer->offset;
++			size = PAGE_SIZE << (get_order(reqbufs->size));
++			while (size > 0) {
++				/* make sure the frame buffers
++				   are never swapped out of memory */
++				SetPageReserved(virt_to_page(adr));
++				adr += PAGE_SIZE;
++				size -= PAGE_SIZE;
++			}
++			/* convert vertual address to physical */
++			buffer->offset = (unsigned long)
++			    virt_to_phys((void *)(buffer->offset));
++		}
++		channel->out_numbuf1s = reqbufs->count;
++
++	} else if (reqbufs->buf_type == IMP_BUF_OUT2) {
++		if (reqbufs->count == 0) {
++			/* free all the buffers */
++			for (count = 0; count < channel->out_numbuf2s;
++				 count++) {
++				/* free memory allocate for the image */
++				if (channel->out_buf2s[count]) {
++					adr = channel->out_buf2s[count]->offset;
++					if (adr)
++						imp_common_free_pages((unsigned
++								long)
++								phys_to_virt
++								(adr),
++								channel->
++								out_buf2s
++								[count]->
++								size);
++
++					/* free the memory allocated to
++					   ipipe_buffer */
++					kfree(channel->out_buf2s[count]);
++
++					channel->out_buf2s[count] = NULL;
++				}
++			}
++			channel->out_numbuf2s = 0;
++
++			return 0;
++		}
++		/* free the buffers */
++		if (channel->out_numbuf2s > reqbufs->count &&
++		    reqbufs->size == channel->out_buf2s[0]->size) {
++			for (count = reqbufs->count;
++			     count < channel->out_numbuf2s; count++) {
++				/* free memory allocate for the image */
++				if (channel->out_buf2s[count]) {
++					adr = channel->out_buf2s[count]->offset;
++					if (adr)
++						imp_common_free_pages((unsigned
++								long)
++								phys_to_virt
++								(adr),
++								channel->
++								out_buf2s
++								[count]->
++								size);
++
++					/* free the memory allocated to
++					   ipipe_buffer */
++					kfree(channel->out_buf2s[count]);
++
++					channel->out_buf2s[count] = NULL;
++				}
++			}
++			channel->out_numbuf2s = reqbufs->count;
++
++			return 0;
++		}
++		/* if size requested is different from already allocated,
++		   free memory of all already allocated buffers */
++		if (channel->out_numbuf2s) {
++			if (reqbufs->size != channel->out_buf2s[0]->size) {
++				for (count = 0;
++				     count < channel->out_numbuf2s; count++) {
++					if (channel->out_buf2s[count]) {
++						adr =
++						    channel->
++						    out_buf2s[count]->offset;
++
++						if (adr)
++							imp_common_free_pages(
++								(unsigned long)
++								phys_to_virt
++								(adr),
++								channel->
++								out_buf2s
++								[count]->
++								size);
++
++						kfree(channel->
++						      out_buf2s[count]);
++
++						channel->out_buf2s[count] =
++						    NULL;
++					}
++				}
++				channel->out_numbuf2s = 0;
++			}
++		}
++
++		/* allocate the buffer */
++		for (count = channel->out_numbuf2s;
++		     count < reqbufs->count; count++) {
++			/* Allocate memory for struct ipipe_buffer */
++			buffer = kmalloc(sizeof(struct imp_buffer), GFP_KERNEL);
++
++			/* if memory allocation fails then return error */
++			if (!buffer) {
++				/* free all the buffers */
++				while (--count >= channel->out_numbuf2s) {
++					adr = channel->out_buf2s[count]->offset;
++					if (adr)
++						imp_common_free_pages((unsigned
++							long)
++							phys_to_virt
++							(adr),
++							channel->
++							out_buf2s
++							[count]->
++							size);
++					kfree(channel->out_buf2s[count]);
++					channel->out_buf2s[count] = NULL;
++				}
++
++				dev_err(dev,
++					"5.request_buffer:not enough memory\n");
++
++				return -ENOMEM;
++			}
++
++			/* assign buffer's address out configuration */
++			channel->out_buf2s[count] = buffer;
++
++			/* set buffers outdex and buf_type,size parameters */
++			buffer->index = count;
++			buffer->buf_type = IMP_BUF_OUT2;
++			buffer->size = reqbufs->size;
++			/* allocate memory for buffer of size passed
++			   in reqbufs */
++			buffer->offset =
++			    (unsigned long)__get_free_pages(GFP_KERNEL |
++							    GFP_DMA,
++							    get_order
++							    (reqbufs->size));
++
++			/* if memory allocation fails, return error */
++			if (!(buffer->offset)) {
++				/* free all the buffer's space */
++				kfree(buffer);
++				channel->out_buf2s[count] = NULL;
++				while (--count >= channel->out_numbuf2s) {
++					adr = channel->out_buf2s[count]->offset;
++					if (adr)
++						imp_common_free_pages((unsigned
++								long)
++								phys_to_virt
++								(adr),
++								channel->
++								out_buf2s
++								[count]->
++								size);
++					kfree(channel->out_buf2s[count]);
++					channel->out_buf2s[count] = NULL;
++				}
++				dev_err(dev,
++					"6.request_buffer:not enough memory\n");
++
++				return -ENOMEM;
++			}
++
++			adr = (unsigned long)buffer->offset;
++			size = PAGE_SIZE << (get_order(reqbufs->size));
++			while (size > 0) {
++				/* make sure the frame buffers
++				   are never swapped out of memory */
++				SetPageReserved(virt_to_page(adr));
++				adr += PAGE_SIZE;
++				size -= PAGE_SIZE;
++			}
++			/* convert vertual address to physical */
++			buffer->offset = (unsigned long)
++			    virt_to_phys((void *)(buffer->offset));
++		}
++		channel->out_numbuf2s = reqbufs->count;
++
++	} else {
++		dev_err(dev, "request_buffer: invalid buffer type\n");
++
++		return -EINVAL;
++	}
++
++	return 0;
++}
++EXPORT_SYMBOL(imp_common_request_buffer);
++
++static irqreturn_t imp_common_isr(int irq, void *device_id)
++{
++	u32 val = vpss_dma_complete_interrupt();
++
++	if (val == 0 || val == 2)
++		complete(&(imp_serializer_info.sem_isr));
++	return IRQ_HANDLED;
++}
++
++int imp_set_preview_config(struct device *dev,
++			   struct imp_logical_channel *channel,
++			   struct prev_channel_config *chan_config)
++{
++	int ret = 0, len = 0;
++
++	if (channel->mode == IMP_MODE_INVALID) {
++		dev_err(dev, "Channel mode is not set. \n");
++		return -EINVAL;
++	}
++
++	if (channel->mode != chan_config->oper_mode) {
++		dev_err(dev,
++			"mode mis-match, chan mode = %d, config mode = %d\n",
++			channel->mode, chan_config->oper_mode);
++		return -EINVAL;
++	}
++
++	if (channel->config_state == STATE_NOT_CONFIGURED) {
++		/* for preview, always use the shared structure */
++		channel->config = imp_hw_if->alloc_config_block(dev, 1);
++		/* allocate buffer for holding user configuration */
++		channel->user_config = imp_hw_if->alloc_user_config_block(dev,
++								IMP_PREVIEWER,
++								channel->
++								mode,
++								&len);
++		if (ISNULL(channel->user_config)) {
++			dev_err(dev,
++				"memory allocate failed for user config\n");
++			return -EFAULT;
++		}
++		channel->user_config_size = len;
++	}
++
++	if (ISNULL(chan_config->config)) {
++		/* put defaults for user configuration */
++		imp_hw_if->set_user_config_defaults(dev,
++						    IMP_PREVIEWER,
++						    chan_config->oper_mode,
++						    channel->user_config);
++		dev_dbg(dev, "imp_set_preview_config.. default \n");
++	} else {
++		dev_dbg(dev, "imp_set_preview_config.. user config\n");
++		if (copy_from_user(channel->user_config,
++				   chan_config->config,
++				   channel->user_config_size)) {
++			dev_err(dev, "Copy from user to kernel failed\n");
++			return -EFAULT;
++		}
++	}
++
++	/* Update the user configuration in the hw config block */
++	ret = imp_hw_if->set_preview_config(dev,
++					    chan_config->oper_mode,
++					    channel->user_config,
++					    channel->config);
++
++	if (ret < 0)
++		dev_err(dev, "set preview config failed\n");
++
++	channel->config_state = STATE_CONFIGURED;
++	return ret;
++}
++EXPORT_SYMBOL(imp_set_preview_config);
++
++int imp_set_resizer_config(struct device *dev,
++			   struct imp_logical_channel *channel,
++			   struct rsz_channel_config *chan_config)
++{
++	int ret = 0, len;
++
++	dev_dbg(dev, "imp_set_resizer_config. len = %d\n", chan_config->len);
++	if (channel->mode == IMP_MODE_INVALID) {
++		dev_err(dev, "Channel mode is not set. \n");
++		return -EINVAL;
++	}
++
++	if (channel->mode != chan_config->oper_mode) {
++		dev_err(dev,
++			"mode mis-match, chan mode = %d, config mode = %d\n",
++			channel->mode, chan_config->oper_mode);
++		return -EINVAL;
++	}
++
++	if ((chan_config->oper_mode == IMP_MODE_CONTINUOUS) &&
++	    (!chan_config->chain)) {
++		dev_err(dev,
++			"In continuous mode, resizer can be only chained. \n");
++		return -EINVAL;
++	}
++
++	if (channel->config_state == STATE_NOT_CONFIGURED) {
++		if (chan_config->oper_mode == IMP_MODE_CONTINUOUS) {
++			/* allocate shared hw config block */
++			dev_dbg(dev, "imp_set_resizer_config-cont. \n");
++			channel->config = imp_hw_if->alloc_config_block(dev, 1);
++		} else {
++			if (chan_config->chain) {
++				dev_dbg(dev,
++					"imp_set_resizer_config-ss, chain. \n");
++				channel->config =
++				    imp_hw_if->alloc_config_block(dev, 1);
++			} else {
++				dev_dbg(dev,
++					"imp_set_resizer_config-ss,"
++					" no-chain.\n");
++				channel->config =
++				    imp_hw_if->alloc_config_block(dev, 0);
++			}
++		}
++		if (ISNULL(channel->config)) {
++			dev_err(dev, "memory allocation failed\n");
++			return -EFAULT;
++		}
++		/* allocate buffer for holding user configuration */
++		channel->user_config = imp_hw_if->alloc_user_config_block(dev,
++								IMP_RESIZER,
++								chan_config->
++								oper_mode,
++								&len);
++		if (ISNULL(channel->user_config)) {
++			dev_err(dev, "memory allocation failed\n");
++			if (!chan_config->chain)
++				kfree(channel->config);
++			return -EFAULT;
++		}
++		channel->user_config_size = len;
++		dev_dbg(dev, "imp_set_resizer_config, len = %d. \n", len);
++	}
++
++	if (ISNULL(chan_config->config)) {
++		/* put defaults for user configuration */
++		imp_hw_if->set_user_config_defaults(dev,
++						    IMP_RESIZER,
++						    chan_config->oper_mode,
++						    channel->user_config);
++		dev_dbg(dev, "imp_set_resizer_config, default\n");
++	} else {
++		if (copy_from_user(channel->user_config,
++				   chan_config->config,
++				   channel->user_config_size)) {
++			dev_err(dev, "Copy from user to kernel failed\n");
++			return -EFAULT;
++		}
++		dev_dbg(dev, "imp_set_resizer_config, user setting\n");
++	}
++
++	/* Update the user configuration in the hw config block or
++	   if chained, copy it to the shared block and allow previewer
++	   to configure it */
++	ret = imp_hw_if->set_resizer_config(dev,
++					    chan_config->oper_mode,
++					    chan_config->chain,
++					    channel->user_config,
++					    channel->config);
++
++	if (ret < 0)
++		dev_err(dev, "set resizer config failed\n");
++
++	channel->chained = chan_config->chain;
++	channel->config_state = STATE_CONFIGURED;
++
++	return ret;
++}
++EXPORT_SYMBOL(imp_set_resizer_config);
++
++int imp_get_preview_config(struct device *dev,
++			   struct imp_logical_channel *channel,
++			   struct prev_channel_config *chan_config)
++{
++	if (channel->mode == IMP_MODE_INVALID) {
++		dev_err(dev, "Channel mode is not set. \n");
++		return -EINVAL;
++	}
++
++	if (channel->mode != chan_config->oper_mode) {
++		dev_err(dev,
++			"mode mis-match, chan mode = %d, config mode = %d\n",
++			channel->mode, chan_config->oper_mode);
++		return -EINVAL;
++	}
++
++	if (channel->config_state != STATE_CONFIGURED) {
++		dev_err(dev, "channel not configured\n");
++		return -EINVAL;
++	}
++
++	if (ISNULL(chan_config->config)) {
++		dev_err(dev, "NULL ptr\n");
++		return -EINVAL;
++	}
++
++	if (copy_to_user((void *)chan_config->config,
++			 (void *)channel->user_config,
++			 channel->user_config_size)) {
++		dev_err(dev, "Error in copy to user\n");
++		return -EFAULT;
++	}
++	return 0;
++}
++EXPORT_SYMBOL(imp_get_preview_config);
++
++int imp_get_resize_config(struct device *dev,
++			  struct imp_logical_channel *channel,
++			  struct rsz_channel_config *chan_config)
++{
++	dev_dbg(dev, "imp_get_resize_config:\n");
++	if (channel->mode == IMP_MODE_INVALID) {
++		dev_err(dev, "Channel mode is not set. \n");
++		return -EINVAL;
++	}
++
++	if (channel->mode != chan_config->oper_mode) {
++		dev_err(dev,
++			"mode mis-match, chan mode = %d, config mode = %d\n",
++			channel->mode, chan_config->oper_mode);
++		return -EINVAL;
++	}
++
++	if (channel->config_state != STATE_CONFIGURED) {
++		dev_err(dev, "channel not configured\n");
++		return -EINVAL;
++	}
++
++	if (ISNULL(chan_config->config)) {
++		dev_err(dev, "NULL ptr\n");
++		return -EINVAL;
++	}
++
++	if (copy_to_user((void *)chan_config->config,
++			 (void *)channel->user_config,
++			 channel->user_config_size)) {
++		dev_err(dev, "Error in copy to user\n");
++		return -EFAULT;
++	}
++	return 0;
++}
++EXPORT_SYMBOL(imp_get_resize_config);
++
++struct prev_module_if *imp_get_module_interface(struct device *dev,
++						unsigned short module_id)
++{
++	struct prev_module_if *module_if;
++	unsigned int index = 0;
++	while (1) {
++		module_if = imp_hw_if->prev_enum_modules(dev, index);
++		if (ISNULL(module_if))
++			break;
++		if (module_if->module_id == module_id)
++			break;
++		index++;
++	}
++	return module_if;
++}
++EXPORT_SYMBOL(imp_get_module_interface);
++
++int imp_init_serializer(void)
++{
++	if (!serializer_initialized) {
++		memset((void *)&imp_serializer_info, (char)0,
++		       sizeof(struct imp_serializer));
++		init_completion(&imp_serializer_info.sem_isr);
++		imp_serializer_info.sem_isr.done = 0;
++		imp_serializer_info.array_count = 0;
++		mutex_init(&imp_serializer_info.array_sem);
++		printk(KERN_NOTICE "imp serializer initialized\n");
++		serializer_initialized = 1;
++		imp_hw_if = imp_get_hw_if();
++	}
++	return 0;
++}
++EXPORT_SYMBOL(imp_init_serializer);
++
++/*
++=====================add_to_array===========================
++ Function to add the current channel configuration into	array
++according to priority.
++*/
++static int add_to_array(struct device *dev, struct imp_logical_channel *chan)
++{
++	int array_index, device_index, ret;
++
++	/* locking the configuartion aaray */
++	ret = mutex_lock_interruptible(&imp_serializer_info.array_sem);
++	if (ret < 0)
++		return ret;
++
++	/* Add configuration to the     queue according to its priority */
++	if (imp_serializer_info.array_count == 0) {
++		/* If array     empty insert at top     position */
++		dev_dbg(dev, "First request for resizing \n");
++		imp_serializer_info.channel_config[imp_serializer_info.
++						   array_count]
++		    = chan;
++	} else {
++		/* Check the priority and insert according to the priority */
++		/* it will start from first     index */
++		for (array_index = 1;
++		     array_index < imp_serializer_info.array_count;
++		     array_index++) {
++			if (imp_serializer_info.channel_config[array_index]->
++			    priority < chan->priority)
++				break;
++		}
++		/* Shift all the elements one step down in array */
++		/* IF firstelement and second have same prioroty than insert */
++		/* below first */
++		for (device_index = imp_serializer_info.array_count;
++		     device_index > array_index; device_index--) {
++			imp_serializer_info.channel_config[device_index] =
++			    imp_serializer_info.
++			    channel_config[device_index - 1];
++		}
++
++		imp_serializer_info.channel_config[array_index] = chan;
++	}
++
++	/* incrementing number of requests for resizing */
++	imp_serializer_info.array_count++;
++	dev_dbg(dev, "The total request for resizing are %d",
++		imp_serializer_info.array_count);
++
++	if (imp_serializer_info.array_count != 1) {
++		mutex_unlock(&imp_serializer_info.array_sem);
++
++		/* if the request is pending that lock the request */
++		wait_for_completion_interruptible(&(chan->channel_sem));
++
++	} else {
++		mutex_unlock(&imp_serializer_info.array_sem);
++	}
++
++	return 0;
++}				/*  end of function addToarray */
++
++/*
++=====================delete_from_array===========================
++ Function	to delete the processed	array entry	form the array
++*/
++static int delete_from_array(struct device *dev,
++			     struct imp_logical_channel *chan)
++{
++	int array_index = 0, device_index, ret;
++
++	ret = mutex_lock_interruptible(&(imp_serializer_info.array_sem));
++
++	if (ret < 0)
++		return ret;
++
++	/*shift the     entried in array */
++	if (imp_serializer_info.array_count != 1) {
++		/* decrementing the     request count */
++		imp_serializer_info.array_count--;
++
++		/* Shift all the elements one step up in array */
++		for (device_index = array_index;
++		     device_index < imp_serializer_info.array_count;
++		     device_index++) {
++
++			imp_serializer_info.channel_config[device_index] =
++			    imp_serializer_info.
++			    channel_config[device_index + 1];
++		}
++		/* making last entry NULL; */
++		imp_serializer_info.channel_config[device_index + 1] = NULL;
++	}
++	/* remove the top entry */
++	else {
++		dev_dbg(dev, "\n Removing the first request");
++		imp_serializer_info.array_count--;
++		imp_serializer_info.channel_config[0] = NULL;
++	}
++
++	if (imp_serializer_info.array_count != 0) {
++		/* Get config having highest priority in array
++		   resizer_device.config
++		   and unlock config.sem of that config */
++
++		dev_dbg(dev,
++			"Releasing array lock of the	second entry\n");
++		complete(&(imp_serializer_info.channel_config[0]->channel_sem));
++		mutex_unlock(&(imp_serializer_info.array_sem));
++	} else {
++		dev_dbg(dev, "Releasing array lock	\n");
++		mutex_unlock(&(imp_serializer_info.array_sem));
++	}
++
++	return 0;
++}
++
++/**
++ * imp_uservirt_to_phys : translate user/virtual address to phy address
++ * @virtp: user/virtual address
++ *
++ * This inline function is used to convert user space virtual address to
++ * physical address.
++ */
++static inline u32 imp_uservirt_to_phys(struct device *dev, u32 virtp)
++{
++	unsigned long physp = 0;
++	struct mm_struct *mm = current->mm;
++	struct vm_area_struct *vma;
++	/* For kernel direct-mapped memory, take the easy way */
++	if (virtp >= PAGE_OFFSET) {
++		physp = virt_to_phys((void *)virtp);
++	} else if ((vma = find_vma(mm, virtp)) && (vma->vm_flags & VM_IO) &&
++		   (vma->vm_pgoff)) {
++		/**
++		 * this will catch, kernel-allocated, mmaped-to-usermode
++		 * addresses
++		 */
++		physp = (vma->vm_pgoff << PAGE_SHIFT) + (virtp - vma->vm_start);
++	} else {
++		/* otherwise, use get_user_pages() for general userland pages */
++		int res, nr_pages = 1;
++		struct page *pages;
++		down_read(&current->mm->mmap_sem);
++
++		res = get_user_pages(current, current->mm,
++				     virtp, nr_pages, 1, 0, &pages, NULL);
++		up_read(&current->mm->mmap_sem);
++
++		if (res == nr_pages)
++			physp = __pa(page_address(&pages[0]) +
++				     (virtp & ~PAGE_MASK));
++		else {
++			dev_err(dev, "get_user_pages failed\n");
++			return 0;
++		}
++	}
++	return physp;
++}
++
++static int imp_common_start(struct device *dev,
++		     struct imp_logical_channel *chan,
++		     struct imp_convert *convert)
++{
++	int ret, prev;
++	struct irq_numbers irq;
++	unsigned int offset = 0;
++	unsigned long addr;
++	int status = 0;
++
++	if ((convert->in_buff.size == 0) || (convert->in_buff.offset == 0)) {
++		dev_err(dev, "in_buff buf size or offset invalid\n");
++		return -1;
++	}
++	if (chan->in_numbufs == 0) {
++		/* user ptr IO */
++		if (convert->in_buff.index != -1) {
++			dev_err(dev,
++				"in_buff index should be set to -1"
++				" for user ptr io\n");
++			return -1;
++		}
++		if (convert->in_buff.offset % 32) {
++			dev_err(dev, "in_buff Offset to be a multiple of 32\n");
++			return -1;
++		}
++		addr = imp_uservirt_to_phys(dev, convert->in_buff.offset);
++		if (!addr) {
++			dev_err(dev, "in_buff Offset - can't get user page\n");
++			return -1;
++		}
++		if (imp_hw_if->update_inbuf_address(chan->config, addr) < 0) {
++			dev_err(dev,
++				"Error in configuring input buffer address\n");
++			return -EINVAL;
++		}
++	} else {
++		if ((convert->in_buff.index < 0) ||
++		    (convert->in_buff.index >= chan->in_numbufs)) {
++			dev_err(dev, "in_buff index is out of range\n");
++			return -1;
++		}
++		if (cpu_is_davinci_dm365()) {
++			if ((convert->in_buff.offset + convert->in_buff.size)  >
++			 (chan->in_bufs[convert->in_buff.index]->offset +
++			 chan->in_bufs[convert->in_buff.index]->size)) {
++				dev_err(dev,
++					"in_buff offset provided "
++					" is out of range, %d:%d:%d:%d:%d\n",
++					convert->in_buff.index,
++					convert->in_buff.offset,
++					convert->in_buff.size,
++					chan->in_bufs[convert->in_buff.index]->offset,
++					chan->in_bufs[convert->in_buff.index]->size);
++				return -1;
++			}
++		} else if (convert->in_buff.offset !=
++		    chan->in_bufs[convert->in_buff.index]->offset) {
++			dev_err(dev,
++				"in_buff offset provided doesn't"
++				" match, %d:%d:%d\n",
++				convert->in_buff.index,
++				convert->in_buff.offset,
++				chan->in_bufs[convert->in_buff.index]->offset);
++			return -1;
++		}
++		if (imp_hw_if->update_inbuf_address(chan->config,
++						    convert->in_buff.
++						    offset) < 0) {
++			dev_err(dev,
++				"Error in configuring input buffer address\n");
++			return -EINVAL;
++		}
++	}
++
++	if ((convert->out_buff1.size != 0)
++		&& (convert->out_buff1.offset != 0)) {
++		if (chan->out_numbuf1s == 0) {
++			/* user ptr IO */
++			if (convert->out_buff1.index != -1) {
++				dev_err(dev,
++					"out_buff1 index should be"
++					" -1 for user ptr IO\n");
++				return -1;
++			}
++			if (convert->out_buff1.offset % 32) {
++				dev_err(dev,
++					"out_buff1 Offset to be a multiple"
++					" of 32\n");
++				return -1;
++			}
++			offset = imp_uservirt_to_phys(dev, convert->out_buff1.offset);
++			if (!offset) {
++				dev_err(dev, "out_buff1 Offset - can't get user page\n");
++				return -1;
++			}
++			status = 1;
++		} else {
++			/* memory mapped IO */
++			if ((convert->out_buff1.index < 0) ||
++			    (convert->out_buff1.index >= chan->out_numbuf1s)) {
++				dev_err(dev,
++					"out_buff1, index is out of range\n");
++				return -1;
++			}
++			if (cpu_is_davinci_dm365()) {
++				if ((convert->out_buff1.offset +
++				     convert->out_buff1.size)  >
++				    (chan->out_buf1s[convert->out_buff1.index]->offset +
++				     chan->out_buf1s[convert->out_buff1.index]->size)) {
++					dev_err(dev,
++					"out_buff offset provided "
++					" is out of range, %d:%d:%d:%d:%d\n",
++					convert->out_buff1.index,
++					convert->out_buff1.offset,
++					convert->out_buff1.size,
++					chan->out_buf1s[convert->out_buff1.index]->offset,
++					chan->out_buf1s[convert->out_buff1.index]->size);
++					return -1;
++				}
++			} else if (convert->out_buff1.offset !=
++			    chan->out_buf1s[convert->out_buff1.index]->offset) {
++				dev_err(dev,
++					"out_buff1 offset provided"
++					" doesn't match\n");
++				return -1;
++			}
++			offset =
++			    convert->out_buff1.offset;
++			status = 1;
++		}
++	}
++
++	if (imp_hw_if->update_outbuf1_address(chan->config, offset) < 0) {
++		dev_err(dev, "Error in configuring out_buff1 address\n");
++		return -EINVAL;
++	}
++
++	offset = 0;
++	if ((convert->out_buff2.size != 0)
++		&& (convert->out_buff2.offset != 0)) {
++		if (chan->out_numbuf2s == 0) {
++			/* user ptr IO */
++			if (convert->out_buff2.index != -1) {
++				dev_err(dev,
++					"out_buff2 index should be -1"
++					" for user ptr IO\n");
++				return -1;
++			}
++			if (convert->out_buff2.offset % 32) {
++				dev_err(dev,
++					"out_buff2 Offset to be a"
++					" multiple of 32\n");
++				return -1;
++			}
++			status = 1;
++			offset = imp_uservirt_to_phys(dev, convert->out_buff2.offset);
++			if (!offset) {
++				dev_err(dev, "out_buff2 Offset - can't get user page\n");
++				return -1;
++			}
++		} else {
++			/* memory mapped IO */
++			if ((convert->out_buff2.index < 0) ||
++			    (convert->out_buff2.index >= chan->out_numbuf2s)) {
++				dev_err(dev,
++					"out_buff1, index is out of range\n");
++				return -1;
++			}
++			if (cpu_is_davinci_dm365()) {
++				if ((convert->out_buff2.offset + convert->out_buff2.size)  >
++				(chan->out_buf2s[convert->out_buff2.index]->offset + chan->out_buf2s[convert->out_buff2.index]->size)) {
++					dev_err(dev,
++					"out_buff offset provided "
++					" is out of range, %d:%d:%d:%d:%d\n",
++					convert->out_buff2.index,
++					convert->out_buff2.offset,
++					convert->out_buff2.size,
++					chan->out_buf2s[convert->out_buff2.index]->offset,
++					chan->out_buf2s[convert->out_buff2.index]->size);
++					return -1;
++				}
++			} else if (convert->out_buff2.offset !=
++			    chan->out_buf2s[convert->out_buff2.index]->offset) {
++				dev_err(dev,
++					"out_buff2 offset provided"
++					" doesn't match\n");
++				return -1;
++			}
++			offset =
++			    convert->out_buff2.offset;
++			status = 1;
++		}
++	}
++
++	if (!(ISNULL(imp_hw_if->update_outbuf2_address))) {
++		if (imp_hw_if->update_outbuf2_address(
++				chan->config, offset) < 0) {
++			dev_err(dev,
++				"Error in configuring out_buff2 address\n");
++			return -EINVAL;
++		}
++	}
++
++	if (!status) {
++		dev_err(dev,
++			"either out_buff1 or  out_buff2 address needed \n");
++		return -EINVAL;
++	}
++
++	ret = add_to_array(dev, chan);
++
++	if (ret < 0)
++		return ret;
++
++	if (chan->type == IMP_PREVIEWER) {
++		if (chan->chained) {
++			imp_hw_if->get_rsz_irq(&irq);
++			prev = 0;
++		} else {
++			imp_hw_if->get_preview_irq(&irq);
++			prev = 1;
++		}
++	} else {
++		/* Resizer channel */
++		imp_hw_if->get_rsz_irq(&irq);
++		prev = 0;
++	}
++
++	if (prev)
++		ret = request_irq(irq.sdram, imp_common_isr, IRQF_DISABLED,
++				  "DaVinciPreviewer", (void *)NULL);
++	else
++		ret = request_irq(irq.sdram, imp_common_isr, IRQF_DISABLED,
++				  "DaVinciResizer", (void *)NULL);
++	if (imp_hw_if->serialize())
++		imp_hw_if->hw_setup(dev, chan->config);
++
++	imp_hw_if->enable(1, chan->config);
++
++	/* Waiting for resizing to be complete */
++	wait_for_completion_interruptible(&(imp_serializer_info.sem_isr));
++
++	free_irq(irq.sdram, (void *)NULL);
++
++	ret = delete_from_array(dev, chan);
++
++	return ret;
++}
++
++int imp_common_start_resize(struct device *dev,
++			    struct imp_logical_channel *chan,
++			    struct imp_convert *convert)
++{
++	return (imp_common_start(dev, chan, convert));
++}
++EXPORT_SYMBOL(imp_common_start_resize);
++
++int imp_common_start_preview(struct device *dev,
++			     struct imp_logical_channel *chan,
++			     struct imp_convert *convert)
++{
++	return (imp_common_start(dev, chan, convert));
++}
++EXPORT_SYMBOL(imp_common_start_preview);
++
++int imp_common_reconfig_resizer(struct device *dev,
++			struct rsz_reconfig *reconfig,
++			struct imp_logical_channel *chan)
++{
++	if (chan->config_state != STATE_CONFIGURED) {
++		dev_err(dev, "Configure channel first before reconfig\n");
++		return -EINVAL;
++	}
++	if (ISNULL(imp_hw_if->reconfig_resizer)) {
++		dev_err(dev, "reconfig is not supported\n");
++		return -EINVAL;
++	}
++
++	return imp_hw_if->reconfig_resizer(dev, reconfig, chan->config);
++}
++EXPORT_SYMBOL(imp_common_reconfig_resizer);
++
++static __init int imp_common_init(void)
++{
++	return 0;
++}
++static void imp_cleanup(void)
++{
++}
++
++MODULE_LICENSE("GPL");
++
++module_init(imp_common_init);
++module_exit(imp_cleanup);
+--- a/drivers/media/video/davinci/Makefile
++++ b/drivers/media/video/davinci/Makefile
+@@ -10,8 +10,30 @@ obj-$(CONFIG_DISPLAY_DAVINCI_DM646X_EVM)
+ #DM646x EVM Capture driver
+ obj-$(CONFIG_CAPTURE_DAVINCI_DM646X_EVM) += vpif_capture.o
+ 
+-# Capture: DM6446 and DM355
++# Capture: DM6446, DM355, DM365
+ obj-$(CONFIG_VIDEO_VPSS_SYSTEM) += vpss.o
+ obj-$(CONFIG_VIDEO_VPFE_CAPTURE) += vpfe_capture.o
+ obj-$(CONFIG_VIDEO_DM6446_CCDC) += dm644x_ccdc.o
+ obj-$(CONFIG_VIDEO_DM355_CCDC) += dm355_ccdc.o
++obj-$(CONFIG_VIDEO_DM365_ISIF) += dm365_ccdc.o
++dm355_af_driver-objs		+= dm355_af.o dm355_af_hw.o
++obj-$(CONFIG_VIDEO_DM355_AF)	+= dm355_af_driver.o
++dm355_aew_driver-objs		+= dm355_aew.o dm355_aew_hw.o
++obj-$(CONFIG_VIDEO_DM355_AEW)	+= dm355_aew_driver.o
++
++dm365_a3_hw_driver-objs := dm365_a3_hw.o
++obj-$(CONFIG_VIDEO_DM365_3A_HW)	+= dm365_a3_hw_driver.o
++dm365_af_driver-objs := dm365_af.o
++obj-$(CONFIG_VIDEO_DM365_AF)	+= dm365_af_driver.o
++dm365_aew_driver-objs := dm365_aew.o
++obj-$(CONFIG_VIDEO_DM365_AEW)	+= dm365_aew_driver.o
++
++# DaVinci Encoder/Display Manager and Encoders
++obj-$(CONFIG_DAVINCI_OSD)		+= davinci_osd.o davinci_platform.o
++obj-$(CONFIG_DAVINCI_ENC_MNGR)		+= davinci_enc_mngr.o
++
++obj-$(CONFIG_DAVINCI_LOGICPD_ENCODER)	+= logicpd_encoder.o
++obj-$(CONFIG_DAVINCI_AVNET_ENCODER)	+= avnetlcd_encoder.o
++obj-$(CONFIG_DAVINCI_VPBE_ENCODER)	+= vpbe_encoder.o
++
++obj-$(CONFIG_VIDEO_DAVINCI_DISPLAY)	+= davinci_display.o
+--- a/arch/arm/Kconfig
++++ b/arch/arm/Kconfig
+@@ -908,8 +908,8 @@ source "arch/arm/common/Kconfig"
+ 
+ config FORCE_MAX_ZONEORDER
+ 	int
+-	depends on SA1111
+-	default "9"
++	default "9" if SA1111
++	default "13" if ARCH_DAVINCI
+ 
+ menu "Bus support"
+ 
+@@ -935,7 +935,7 @@ config ISA_DMA_API
+ 	bool
+ 
+ config PCI
+-	bool "PCI support" if ARCH_INTEGRATOR_AP || ARCH_VERSATILE_PB || ARCH_IXP4XX || ARCH_KS8695 || MACH_ARMCORE
++	bool "PCI support" if ARCH_INTEGRATOR_AP || ARCH_VERSATILE_PB || ARCH_IXP4XX || ARCH_KS8695 || MACH_ARMCORE || ARCH_DAVINCI_DM646x
+ 	help
+ 	  Find out whether you have a PCI motherboard. PCI is the name of a
+ 	  bus system, i.e. the way the CPU talks to the other stuff inside
+--- a/include/media/v4l2-chip-ident.h
++++ b/include/media/v4l2-chip-ident.h
+@@ -129,6 +129,9 @@ enum {
+ 	V4L2_IDENT_SAA6752HS = 6752,
+ 	V4L2_IDENT_SAA6752HS_AC3 = 6753,
+ 
++	/* module tvp7002: just ident 7002 */
++	V4L2_IDENT_TVP7002 = 7002,
++
+ 	/* module adv7170: just ident 7170 */
+ 	V4L2_IDENT_ADV7170 = 7170,
+ 
+@@ -147,9 +150,15 @@ enum {
+ 	/* module ths7303: just ident 7303 */
+ 	V4L2_IDENT_THS7303 = 7303,
+ 
++	/* module ths7353: just ident 7353 */
++	V4L2_IDENT_THS7353 = 7353,
++
+ 	/* module adv7343: just ident 7343 */
+ 	V4L2_IDENT_ADV7343 = 7343,
+ 
++	/* module ths8200: just ident 8200 */
++	V4L2_IDENT_THS8200 = 8200,
++
+ 	/* module wm8739: just ident 8739 */
+ 	V4L2_IDENT_WM8739 = 8739,
+ 
+--- a/sound/soc/davinci/Kconfig
++++ b/sound/soc/davinci/Kconfig
+@@ -13,9 +13,9 @@ config SND_DAVINCI_SOC_MCASP
+ 	tristate
+ 
+ config SND_DAVINCI_SOC_EVM
+-	tristate "SoC Audio support for DaVinci DM6446 or DM355 EVM"
++	tristate "SoC Audio support for DaVinci DM6446, DM355 or DM365 EVM"
+ 	depends on SND_DAVINCI_SOC
+-	depends on MACH_DAVINCI_EVM || MACH_DAVINCI_DM355_EVM
++	depends on MACH_DAVINCI_EVM || MACH_DAVINCI_DM355_EVM  || MACH_DAVINCI_DM365_EVM
+ 	select SND_DAVINCI_SOC_I2S
+ 	select SND_SOC_TLV320AIC3X
+ 	help
+--- /dev/null
++++ b/include/media/davinci/vpbe_encoder.h
+@@ -0,0 +1,49 @@
++/*
++ * Copyright (C) 2007 Texas Instruments Inc
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
++ */
++
++#ifndef VPBE_ENCODER_H
++#define VPBE_ENCODER_H
++
++#ifdef __KERNEL__
++/* Kernel Header files */
++#include <linux/i2c.h>
++#include <linux/device.h>
++#endif
++
++#ifdef __KERNEL__
++/* encoder standard related strctures */
++#define VPBE_ENCODER_MAX_NO_OUTPUTS		            (3)
++#define VPBE_ENCODER_MAX_NUM_STD			(13)
++#define VPBE_DM355_ENCODER_MAX_NO_OUTPUTS		    (1)
++#define VPBE_DM355_ENCODER_COMPOSITE_NUM_STD        (2)
++#define VPBE_DM355_ENCODER_MAX_NUM_STD              (2)
++
++#define VPBE_DM644X_ENCODER_MAX_NO_OUTPUTS		    (3)
++#define VPBE_DM644X_ENCODER_COMPONENT_NUM_STD		(6)
++#define VPBE_DM644X_ENCODER_SVIDEO_NUM_STD		    (2)
++#define VPBE_DM644X_ENCODER_COMPOSITE_NUM_STD       (2)
++
++#define VPBE_DM365_ENCODER_MAX_NO_OUTPUTS		(3)
++#define VPBE_DM365_ENCODER_COMPOSITE_NUM_STD		(2)
++#define VPBE_DM365_ENCODER_COMPONENT_NUM_STD		(9)
++#define VPBE_DM365_ENCODER_SVIDEO_NUM_STD		(2)
++
++
++#endif				/* End of #ifdef __KERNEL__ */
++
++#endif				/* End of #ifndef VPBE_VENC_H */
+--- a/drivers/video/modedb.c
++++ b/drivers/video/modedb.c
+@@ -756,10 +756,12 @@ void fb_videomode_to_var(struct fb_var_s
+ {
+ 	var->xres = mode->xres;
+ 	var->yres = mode->yres;
++#if 0
+ 	var->xres_virtual = mode->xres;
+ 	var->yres_virtual = mode->yres;
+ 	var->xoffset = 0;
+ 	var->yoffset = 0;
++#endif
+ 	var->pixclock = mode->pixclock;
+ 	var->left_margin = mode->left_margin;
+ 	var->right_margin = mode->right_margin;
+--- /dev/null
++++ b/drivers/char/dm355_ipipe_hw.h
+@@ -0,0 +1,341 @@
++/*
++ * Copyright (C) 2007-2008 Texas Instruments Inc
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
++ */
++#ifndef _DM355_IPIPE_HW_H
++#define _DM355_IPIPE_HW_H
++
++#ifdef __KERNEL__
++
++#include <linux/kernel.h>
++#include <linux/io.h>
++#include <mach/hardware.h>
++
++#define IPIPE_IOBASE_VADDR 		IO_ADDRESS(0x01C71000)
++#define IPIPEIF_IOBASE_VADDR		IO_ADDRESS(0x01C70100)
++
++static inline u32 regr_ip(u32 offset)
++{
++    return __raw_readl(IPIPE_IOBASE_VADDR + offset);
++}
++
++static inline u32 regw_ip(u32 val, u32 offset)
++{
++    __raw_writel(val, IPIPE_IOBASE_VADDR + offset);
++    return val;
++}
++static inline u32 regr_if(u32 offset)
++{
++    return __raw_readl(IPIPEIF_IOBASE_VADDR + offset);
++}
++
++static inline u32 regw_if(u32 val, u32 offset)
++{
++    __raw_writel(val, IPIPEIF_IOBASE_VADDR + offset);
++    return val;
++}
++/*
++static inline u32 regr_vpss(u32 offset)
++{
++    return davinci_readl(VPSS_BL_BASE + offset);
++}
++
++static inline u32 regw_vpss(u32 val, u32 offset)
++{
++    davinci_writel(val, VPSS_BL_BASE + offset);
++    return val;
++}
++*/
++
++#define SET_LOW_ADD     0x0000FFFF
++#define SET_HIGH_ADD    0xFFFF0000
++
++
++/* macro for bit set and clear */
++#define SETBIT(reg, bit)   (reg = ((reg) | ((0x00000001)<<(bit))))
++#define RESETBIT(reg, bit) (reg = ((reg) & (~(0x00000001<<(bit)))))
++/* -to set vpss reg for ipipe- */
++#define VPSS_PCR		0x0804
++#define VPSS_MEMCTL		0x0818
++#define VPSS_CLK   		0x0004
++
++
++
++#define SDR_ENABLE		2/*int number for IRQ_EN*/
++/* Internal RAM table addresses for defect correction */
++#define DEF_COR_START_ADDR	0x0000
++#define DEF_COR_END_ADDR	0x07FF
++#define DEF_COR_SIZE		1024
++#define MAX_SIZE_DFC			1024
++#define MAX_SIZE_EEC			1024
++#define MAX_SIZE_GAMMA			512
++
++/* Internal RAM table addresses for gamma correction */
++#define GAMMA_START_ADDR      0x0000
++#define GAMMA_END_ADDR        0x03FF
++
++/*Internal RAM table addresses for edge enhancement correction*/
++#define EDGE_ENHANCE_START_ADDR		0x0200
++#define EDGE_ENHANCE_END_ADDR		0x01FF
++
++/* IPIPE Register Offsets from the base address */
++
++#define IPIPE_EN 		0x0000
++#define IPIPE_MODE 		0x0004
++#define IPIPE_DPATHS 		0x0008
++#define IPIPE_COLPAT		0x000C
++#define IPIPE_VST		0x0010
++#define IPIPE_VSZ 		0x0014
++#define IPIPE_HST		0x0018
++#define IPIPE_HSZ 		0x001C
++/*gated clock enable*/
++#define GCL_ARM			0x0024
++#define GCL_CCD 		0x0028
++#define GCL_SDR			0x002C
++/* Internal Memory Access */
++#define RAM_MODE		0x0030
++#define RAM_ADR			0x0034
++#define RAM_WDT			0x0038
++#define RAM_RDT			0x003C
++/* Interrupts */
++#define IRQ_EN			0x0040
++#define IRQ_RZA			0x0044
++#define IRQ_RZB			0x0048
++/* Defect Correction */
++#define DFC_EN			0x004C
++#define DFC_SEL			0x0050
++#define DFC_ADR			0x0054
++#define DFC_SIZE		0x0058
++/* Programmable Noise Filter */
++#define D2F_EN			0x005C
++#define D2F_CFG			0x0060
++#define D2F_THR			0x0064
++#define D2F_STR			0x00E4
++/* PreFilter */
++#define PRE_EN			0x0164
++#define PRE_TYP			0x0168
++#define PRE_SHF			0x016C
++#define PRE_GAIN		0x0170
++#define PRE_THR_G		0x0174
++#define PRE_THR_B		0x0178
++#define PRE_THR_1		0x017C
++/* White Balance */
++#define WB2_DGN			0x0180
++#define WB2_WG_R		0x0184
++#define WB2_WG_GR		0x0188
++#define WB2_WG_GB		0x018C
++#define WB2_WG_B		0x0190
++
++/* RGB to RGB conversion (include GAMMA correction) */
++#define RGB_MUL_RR		0x01F4
++
++/* Defect Correction */
++#define DFC_EN                  0x004C
++#define DFC_SEL                 0x0050
++#define DFC_ADR                 0x0054
++#define DFC_SIZ                 0x0058
++/* Programmable Noise Filter */
++#define D2F_EN                  0x005C
++#define D2F_CFG                 0x0060
++#define DFC_THR                 0x0064
++#define D2F_STR                 0x00E4
++/* PreFilter */
++#define PRE_EN                  0x0164
++#define PRE_TYP                 0x0168
++#define PRE_SHF                 0x016C
++#define PRE_GAIN                0x0170
++#define PRE_THR_G               0x0174
++#define PRE_THR_B               0x0178
++#define PRE_THR_1               0x017C
++/* White Balance */
++#define WB2_DGN                 0x0180
++#define WB2_WG_R                0x0184
++#define WB2_WG_GR               0x0188
++#define WB2_WG_GB               0x018C
++#define WB2_WG_B                0x0190
++
++/* RGB to RGB conversion (include GAMMA correction) */
++#define RGB_MUL_RR              0x01F4
++#define RGB_MUL_GR              0x01F8
++#define RGB_MUL_BR              0x01FC
++#define RGB_MUL_RG		0x0200
++#define RGB_MUL_GG		0x0204
++#define RGB_MUL_BG		0x0208
++#define RGB_MUL_RB		0x020C
++
++#define RGB_MUL_GB		0x0210
++#define RGB_MUL_BB		0x0214
++#define RGB_MUL_OR		0x0218
++#define RGB_MUL_OG		0x021C
++#define RGB_MUL_OB		0x0220
++#define GMM_CFG			0x0224
++
++/* RGB to YUV(YCbCr) conversion */
++#define YUV_ADJ 		0x0228
++#define YUV_MUL_RY 		0x022C
++#define YUV_MUL_GY 		0x0230
++#define YUV_MUL_BY 		0x0234
++#define YUV_MUL_RCB 		0x0238
++#define YUV_MUL_GCB 		0x023C
++#define YUV_MUL_BCB 		0x0240
++#define YUV_MUL_RCR 		0x0244
++#define YUV_MUL_GCR 		0x0248
++#define YUV_MUL_BCR 		0x024C
++#define YUV_OFT_Y 		0x0250
++#define YUV_OFT_CB 		0x0254
++#define YUV_OFT_CR 		0x0258
++#define YUV_Y_MIN 		0x025C
++#define YUV_Y_MAX 		0x0260
++#define YUV_C_MIN 		0x0264
++#define YUV_C_MAX 		0x0268
++#define YUV_PHS 		0x026C
++
++/* Edge Enhancer */
++#define YEE_EN			0x0270
++#define YEE_EMF			0x0274
++#define YEE_SHF			0x0278
++#define YEE_MUL_00		0x027C
++#define YEE_MUL_01		0x0280
++#define YEE_MUL_02		0x0284
++#define YEE_MUL_10		0x0288
++#define YEE_MUL_11		0x028C
++#define YEE_MUL_12		0x0290
++#define YEE_MUL_20		0x0294
++#define YEE_MUL_21		0x0298
++#define YEE_MUL_22		0x029C
++
++/* False Color Suppression */
++#define FCS_EN			0x02A0
++#define FCS_TYP			0x02A4
++#define FCS_SHF_Y		0x02A8
++#define FCS_SHF_C		0x02AC
++#define FCS_THR 		0x02B0
++#define FCS_SGN			0x02B4
++#define FCS_LTH			0x02B8
++
++/* Resizer */
++#define RSZ_SEQ                 0x02BC
++#define RSZ_AAL                 0x02C0
++
++/* Resizer Rescale Parameters */
++#define RSZ_EN_0	        0x02C4
++#define RSZ_EN_1             	0x0334
++/* offset of the registers to be added with base register of either RSZ0 or
++ * RSZ1
++ */
++#define RSZ_MODE	        0x4
++#define RSZ_I_VST               0x8
++#define RSZ_I_VSZ               0xC
++#define RSZ_I_HST               0x10
++#define RSZ_O_VSZ               0x14
++#define RSZ_O_HST               0x18
++#define RSZ_O_HSZ		0x1C
++#define RSZ_V_PHS               0x20
++#define RSZ_V_PHS_O	        0x24
++#define RSZ_V_DIF               0x28
++#define RSZ_V_SIZ_O             0x2C
++#define RSZ_H_PHS               0x30
++#define RSZ_H_DIF               0x34
++#define RSZ_H_TYP               0x38
++#define RSZ_H_LSE               0x3C
++#define RSZ_H_LPF             	0x40
++
++/* Resizer RGB Conversion Parameters */
++#define RSZ_RGB_EN              0x44
++#define RSZ_RGB_TYP             0x48
++#define RSZ_RGB_BLD             0x4C
++
++/* Resizer External Memory Parameters */
++#define RSZ_SDR_BAD_H           0x50
++#define RSZ_SDR_BAD_L           0x54
++#define RSZ_SDR_SAD_H           0x58
++#define RSZ_SDR_SAD_L           0x5C
++#define RSZ_SDR_OFT             0x60
++#define RSZ_SDR_PTR_S           0x64
++#define RSZ_SDR_PTR_E           0x68
++#define RSZ_SDR_PTR_O           0x6C
++
++/* Macro for resizer */
++#define IPIPE_RESIZER_0(i)  (IPIPE_IOBASE_VADDR + RSZ_EN_0 + i)
++#define IPIPE_RESIZER_1(i)  (IPIPE_IOBASE_VADDR + RSZ_EN_1 + i)
++
++/* Masking fields */
++#define IPIPE_MODE_WRT 		(1 << 1)
++#define IPIPE_DPATHS_FMT	(3 << 0)
++#define IPIPE_DPATHS_BYPASS	(1 << 2)
++#define IPIPE_COLPAT_ELEP	(3 << 0)
++#define IPIPE_COLPAT_ELOP	(3 << 2)
++#define IPIPE_COLPAT_OLEP	(3 << 4)
++#define IPIPE_COLPAT_OLOP	(3 << 6)
++#define IPIPE_D2F_CFG_SPR	(3 << 0)
++#define IPIPE_D2F_CFG_SHF       (3 << 2)
++#define IPIPE_D2F_CFG_TYP       (1 << 4)
++#define IPIPE_PRE_TYP_SEL1	(1 << 1)
++#define IPIPE_PRE_TYP_EN0       (1 << 2)
++#define IPIPE_PRE_TYP_EN1       (1 << 3)
++#define IPIPE_GMM_CFG_BYPG      (1 << 1)
++#define IPIPE_GMM_CFG_BYPB      (1 << 2)
++#define IPIPE_GMM_CFG_TBL       (1 << 4)
++#define IPIPE_GMM_CFG_SIZ       (3 << 5)
++#define IPIPE_YUV_ADJ_CTR	(0Xff << 0)
++#define IPIPE_YUV_ADJ_BRT       (0Xff << 8)
++#define IPIPE_YUV_PHS_LPF	(1 << 1)
++#define IPIPE_RSZ_SEQ_TMM	(1 << 1)
++#define IPIPE_RSZ_SEQ_HRV       (1 << 2)
++#define IPIPE_RSZ_SEQ_VRV       (1 << 3)
++#define IPIPE_RSZ_SEQ_CRV       (1 << 3)
++#define IPIPE_RSZ_RGB_TYP_MSK0  (1 << 1)
++#define IPIPE_RSZ_RGB_TYP_MSK1  (1 << 2)
++
++/* BIT FIELDS */
++
++#define IPIPE_DPATHS_BYPASS_SHIFT	 2
++#define IPIPE_COLPAT_ELOP_SHIFT		 2
++#define IPIPE_COLPAT_OLEP_SHIFT		 4
++#define IPIPE_COLPAT_OLOP_SHIFT		 6
++#define IPIPE_D2F_CFG_SHF_SHIFT          2
++#define IPIPE_D2F_CFG_TYP_SHIFT          4
++#define IPIPE_PRE_TYP_SEL1_SHIFT         1
++#define IPIPE_PRE_TYP_EN0_SHIFT          2
++#define IPIPE_PRE_TYP_EN1_SHIFT          3
++#define IPIPE_GMM_CFG_BYPG_SHIFT         1
++#define IPIPE_GMM_CFG_BYPB_SHIFT         2
++#define IPIPE_GMM_CFG_TBL_SHIFT          4
++#define IPIPE_GMM_CFG_SIZ_SHIFT          5
++#define IPIPE_YUV_ADJ_BRT_SHIFT          8
++#define IPIPE_YUV_PHS_LPF_SHIFT          1
++#define IPIPE_RSZ_SEQ_TMM_SHIFT          1
++#define IPIPE_RSZ_SEQ_HRV_SHIFT          2
++#define IPIPE_RSZ_SEQ_VRV_SHIFT          3
++#define IPIPE_RSZ_SEQ_CRV_SHIFT          3
++#define IPIPE_RSZ_RGB_TYP_MSK0_SHIFT     1
++#define IPIPE_RSZ_RGB_TYP_MSK1_SHIFT     2
++
++/* IPIPEIF Register Offsets from the base address */
++#define IPIPEIF_ENABLE 	0x00
++#define IPIPEIF_GFG 	0x04
++#define IPIPEIF_PPLN	0x08
++#define IPIPEIF_LPFR	0x0C
++#define IPIPEIF_HNUM 	0x10
++#define IPIPEIF_VNUM    0x14
++#define IPIPEIF_ADDRU   0x18
++#define IPIPEIF_ADDRL   0x1C
++#define IPIPEIF_ADOFS   0x20
++#define IPIPEIF_RSZ   	0x24
++#define IPIPEIF_GAIN   0x28
++
++#endif /* End of #ifdef __KERNEL__ */
++#endif  /* End of #ifdef _DM355_IPIPE_HW_H */
+--- a/arch/arm/mach-davinci/board-da830-evm.c
++++ b/arch/arm/mach-davinci/board-da830-evm.c
+@@ -13,8 +13,14 @@
+ #include <linux/module.h>
+ #include <linux/init.h>
+ #include <linux/console.h>
++#include <linux/interrupt.h>
++#include <linux/gpio.h>
++#include <linux/platform_device.h>
+ #include <linux/i2c.h>
++#include <linux/i2c/pcf857x.h>
+ #include <linux/i2c/at24.h>
++#include <linux/mtd/mtd.h>
++#include <linux/mtd/partitions.h>
+ 
+ #include <asm/mach-types.h>
+ #include <asm/mach/arch.h>
+@@ -22,12 +28,18 @@
+ #include <mach/common.h>
+ #include <mach/irqs.h>
+ #include <mach/cp_intc.h>
++#include <mach/mux.h>
++#include <mach/nand.h>
+ #include <mach/da8xx.h>
+ #include <mach/asp.h>
++#include <mach/usb.h>
+ 
+ #define DA830_EVM_PHY_MASK		0x0
+ #define DA830_EVM_MDIO_FREQUENCY	2200000	/* PHY bus frequency */
+ 
++#define DA830_EMIF25_ASYNC_DATA_CE3_BASE	0x62000000
++#define DA830_EMIF25_CONTROL_BASE		0x68000000
++
+ static struct at24_platform_data da830_evm_i2c_eeprom_info = {
+ 	.byte_len	= SZ_256K / 8,
+ 	.page_size	= 64,
+@@ -36,6 +48,31 @@ static struct at24_platform_data da830_e
+ 	.context	= (void *)0x7f00,
+ };
+ 
++static int da830_evm_ui_expander_setup(struct i2c_client *client, int gpio,
++		unsigned ngpio, void *context)
++{
++	gpio_request(gpio + 6, "MUX_MODE");
++#ifdef CONFIG_DA830_UI_LCD
++	gpio_direction_output(gpio + 6, 0);
++#else /* Must be NAND or NOR */
++	gpio_direction_output(gpio + 6, 1);
++#endif
++	return 0;
++}
++
++static int da830_evm_ui_expander_teardown(struct i2c_client *client, int gpio,
++		unsigned ngpio, void *context)
++{
++	gpio_free(gpio + 6);
++	return 0;
++}
++
++static struct pcf857x_platform_data da830_evm_ui_expander_info = {
++	.gpio_base	= DAVINCI_N_GPIO,
++	.setup		= da830_evm_ui_expander_setup,
++	.teardown	= da830_evm_ui_expander_teardown,
++};
++
+ static struct i2c_board_info __initdata da830_evm_i2c_devices[] = {
+ 	{
+ 		I2C_BOARD_INFO("24c256", 0x50),
+@@ -43,7 +80,11 @@ static struct i2c_board_info __initdata
+ 	},
+ 	{
+ 		I2C_BOARD_INFO("tlv320aic3x", 0x18),
+-	}
++	},
++	{
++		I2C_BOARD_INFO("pcf8574", 0x3f),
++		.platform_data	= &da830_evm_ui_expander_info,
++	},
+ };
+ 
+ static struct davinci_i2c_platform_data da830_evm_i2c_0_pdata = {
+@@ -51,10 +92,139 @@ static struct davinci_i2c_platform_data
+ 	.bus_delay	= 0,	/* usec */
+ };
+ 
++/*
++ * USB1 VBUS is controlled by GPIO1[15], over-current is reported on GPIO2[4].
++ */
++#define ON_BD_USB_DRV	GPIO_TO_PIN(1, 15)
++#define ON_BD_USB_OVC	GPIO_TO_PIN(2, 4)
++
++static const short da830_evm_usb11_pins[] = {
++	DA830_GPIO1_15, DA830_GPIO2_4,
++	-1
++};
++
++static da8xx_ocic_handler_t da830_evm_usb_ocic_handler;
++
++static int da830_evm_usb_set_power(unsigned port, int on)
++{
++	gpio_set_value(ON_BD_USB_DRV, on);
++	return 0;
++}
++
++static int da830_evm_usb_get_power(unsigned port)
++{
++	return gpio_get_value(ON_BD_USB_DRV);
++}
++
++static int da830_evm_usb_get_oci(unsigned port)
++{
++	return !gpio_get_value(ON_BD_USB_OVC);
++}
++
++static irqreturn_t da830_evm_usb_ocic_irq(int, void *);
++
++static int da830_evm_usb_ocic_notify(da8xx_ocic_handler_t handler)
++{
++	int irq 	= gpio_to_irq(ON_BD_USB_OVC);
++	int error	= 0;
++
++	if (handler != NULL) {
++		da830_evm_usb_ocic_handler = handler;
++
++		error = request_irq(irq, da830_evm_usb_ocic_irq, IRQF_DISABLED |
++				    IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,
++				    "OHCI over-current indicator", NULL);
++		if (error)
++			printk(KERN_ERR "%s: could not request IRQ to watch "
++			       "over-current indicator changes\n", __func__);
++	} else
++		free_irq(irq, NULL);
++
++	return error;
++}
++
++static struct da8xx_ohci_root_hub da830_evm_usb11_pdata = {
++	.set_power	= da830_evm_usb_set_power,
++	.get_power	= da830_evm_usb_get_power,
++	.get_oci	= da830_evm_usb_get_oci,
++	.ocic_notify	= da830_evm_usb_ocic_notify,
++
++	/* TPS2065 switch @ 5V */
++	.potpgt		= (3 + 1) / 2,	/* 3 ms max */
++};
++
++static irqreturn_t da830_evm_usb_ocic_irq(int irq, void *dev_id)
++{
++	da830_evm_usb_ocic_handler(&da830_evm_usb11_pdata, 1);
++	return IRQ_HANDLED;
++}
++
++static __init void da830_evm_usb_init(void)
++{
++	u32 cfgchip2;
++	int ret;
++
++	/*
++	 * Set up USB clock/mode in the CFGCHIP2 register.
++	 * FYI:  CFGCHIP2 is 0x0000ef00 initially.
++	 */
++	cfgchip2 = __raw_readl(DA8XX_SYSCFG_VIRT(DA8XX_CFGCHIP2_REG));
++
++	/* USB2.0 PHY reference clock is 24 MHz */
++	cfgchip2 &= ~CFGCHIP2_REFFREQ;
++	cfgchip2 |=  CFGCHIP2_REFFREQ_24MHZ;
++
++	/*
++	 * Select internal reference clock for USB 2.0 PHY
++	 * and use it as a clock source for USB 1.1 PHY
++	 * (this is the default setting anyway).
++	 */
++	cfgchip2 &= ~CFGCHIP2_USB1PHYCLKMUX;
++	cfgchip2 |=  CFGCHIP2_USB2PHYCLKMUX;
++
++	__raw_writel(cfgchip2, DA8XX_SYSCFG_VIRT(DA8XX_CFGCHIP2_REG));
++
++	ret = da8xx_pinmux_setup(da830_evm_usb11_pins);
++	if (ret) {
++		pr_warning("%s: USB 1.1 PinMux setup failed: %d\n",
++			   __func__, ret);
++		return;
++	}
++
++	ret = gpio_request(ON_BD_USB_DRV, "ON_BD_USB_DRV");
++	if (ret) {
++		printk(KERN_ERR "%s: failed to request GPIO for USB 1.1 port "
++		       "power control: %d\n", __func__, ret);
++		return;
++	}
++	gpio_direction_output(ON_BD_USB_DRV, 0);
++
++	ret = gpio_request(ON_BD_USB_OVC, "ON_BD_USB_OVC");
++	if (ret) {
++		printk(KERN_ERR "%s: failed to request GPIO for USB 1.1 port "
++		       "over-current indicator: %d\n", __func__, ret);
++		return;
++	}
++	gpio_direction_input(ON_BD_USB_OVC);
++
++	ret = da8xx_register_usb11(&da830_evm_usb11_pdata);
++	if (ret)
++		pr_warning("%s: USB 1.1 registration failed: %d\n",
++			   __func__, ret);
++}
++
+ static struct davinci_uart_config da830_evm_uart_config __initdata = {
+ 	.enabled_uarts = 0x7,
+ };
+ 
++static const short da830_evm_mcasp1_pins[] = {
++	DA830_AHCLKX1, DA830_ACLKX1, DA830_AFSX1, DA830_AHCLKR1, DA830_AFSR1,
++	DA830_AMUTE1, DA830_AXR1_0, DA830_AXR1_1, DA830_AXR1_2, DA830_AXR1_5,
++	DA830_ACLKR1, DA830_AXR1_6, DA830_AXR1_7, DA830_AXR1_8, DA830_AXR1_10,
++	DA830_AXR1_11,
++	-1
++};
++
+ static u8 da830_iis_serializer_direction[] = {
+ 	RX_MODE,	INACTIVE_MODE,	INACTIVE_MODE,	INACTIVE_MODE,
+ 	INACTIVE_MODE,	TX_MODE,	INACTIVE_MODE,	INACTIVE_MODE,
+@@ -74,6 +244,150 @@ static struct snd_platform_data da830_ev
+ 	.rxnumevt	= 1,
+ };
+ 
++/*
++ * GPIO2[1] is used as MMC_SD_WP and GPIO2[2] as MMC_SD_INS.
++ */
++static const short da830_evm_mmc_sd_pins[] = {
++	DA830_MMCSD_DAT_0, DA830_MMCSD_DAT_1, DA830_MMCSD_DAT_2,
++	DA830_MMCSD_DAT_3, DA830_MMCSD_DAT_4, DA830_MMCSD_DAT_5,
++	DA830_MMCSD_DAT_6, DA830_MMCSD_DAT_7, DA830_MMCSD_CLK,
++	DA830_MMCSD_CMD,   DA830_GPIO2_1,     DA830_GPIO2_2,
++	-1
++};
++
++static int da830_evm_mmc_get_ro(int index)
++{
++	int val, status, gpio_num = 33;
++
++	status = gpio_request(gpio_num, "MMC WP\n");
++	if (status < 0) {
++		pr_warning("%s can not open GPIO %d\n", __func__, gpio_num);
++		return 0;
++	}
++	gpio_direction_input(gpio_num);
++	val = gpio_get_value(gpio_num);
++	gpio_free(gpio_num);
++	return val;
++}
++
++static struct davinci_mmc_config da830_evm_mmc_config = {
++	.get_ro			= da830_evm_mmc_get_ro,
++	.wires			= 4,
++	.version		= MMC_CTLR_VERSION_2,
++};
++
++#ifdef CONFIG_DA830_UI_NAND
++static struct mtd_partition da830_evm_nand_partitions[] = {
++	/* bootloader (U-Boot, etc) in first sector */
++	[0] = {
++		.name		= "bootloader",
++		.offset		= 0,
++		.size		= SZ_128K,
++		.mask_flags	= MTD_WRITEABLE,	/* force read-only */
++	},
++	/* bootloader params in the next sector */
++	[1] = {
++		.name		= "params",
++		.offset		= MTDPART_OFS_APPEND,
++		.size		= SZ_128K,
++		.mask_flags	= MTD_WRITEABLE,	/* force read-only */
++	},
++	/* kernel */
++	[2] = {
++		.name		= "kernel",
++		.offset		= MTDPART_OFS_APPEND,
++		.size		= SZ_2M,
++		.mask_flags	= 0,
++	},
++	/* file system */
++	[3] = {
++		.name		= "filesystem",
++		.offset		= MTDPART_OFS_APPEND,
++		.size		= MTDPART_SIZ_FULL,
++		.mask_flags	= 0,
++	}
++};
++
++/* flash bbt decriptors */
++static uint8_t da830_evm_nand_bbt_pattern[] = { 'B', 'b', 't', '0' };
++static uint8_t da830_evm_nand_mirror_pattern[] = { '1', 't', 'b', 'B' };
++
++static struct nand_bbt_descr da830_evm_nand_bbt_main_descr = {
++	.options	= NAND_BBT_LASTBLOCK | NAND_BBT_CREATE |
++			  NAND_BBT_WRITE | NAND_BBT_2BIT |
++			  NAND_BBT_VERSION | NAND_BBT_PERCHIP,
++	.offs		= 2,
++	.len		= 4,
++	.veroffs	= 16,
++	.maxblocks	= 4,
++	.pattern	= da830_evm_nand_bbt_pattern
++};
++
++static struct nand_bbt_descr da830_evm_nand_bbt_mirror_descr = {
++	.options	= NAND_BBT_LASTBLOCK | NAND_BBT_CREATE |
++			  NAND_BBT_WRITE | NAND_BBT_2BIT |
++			  NAND_BBT_VERSION | NAND_BBT_PERCHIP,
++	.offs		= 2,
++	.len		= 4,
++	.veroffs	= 16,
++	.maxblocks	= 4,
++	.pattern	= da830_evm_nand_mirror_pattern
++};
++
++static struct davinci_nand_pdata da830_evm_nand_pdata = {
++	.parts		= da830_evm_nand_partitions,
++	.nr_parts	= ARRAY_SIZE(da830_evm_nand_partitions),
++	.ecc_mode	= NAND_ECC_HW,
++	.ecc_bits	= 4,
++	.options	= NAND_USE_FLASH_BBT,
++	.bbt_td		= &da830_evm_nand_bbt_main_descr,
++	.bbt_md		= &da830_evm_nand_bbt_mirror_descr,
++};
++
++static struct resource da830_evm_nand_resources[] = {
++	[0] = {		/* First memory resource is NAND I/O window */
++		.start	= DA830_EMIF25_ASYNC_DATA_CE3_BASE,
++		.end	= DA830_EMIF25_ASYNC_DATA_CE3_BASE + PAGE_SIZE - 1,
++		.flags	= IORESOURCE_MEM,
++	},
++	[1] = {		/* Second memory resource is AEMIF control registers */
++		.start	= DA830_EMIF25_CONTROL_BASE,
++		.end	= DA830_EMIF25_CONTROL_BASE + SZ_32K - 1,
++		.flags	= IORESOURCE_MEM,
++	},
++};
++
++static struct platform_device da830_evm_nand_device = {
++	.name		= "davinci_nand",
++	.id		= 1,
++	.dev		= {
++		.platform_data	= &da830_evm_nand_pdata,
++	},
++	.num_resources	= ARRAY_SIZE(da830_evm_nand_resources),
++	.resource	= da830_evm_nand_resources,
++};
++#endif
++
++static struct platform_device *da830_evm_devices[] __initdata = {
++#ifdef CONFIG_DA830_UI_NAND
++	&da830_evm_nand_device,
++#endif
++};
++
++/*
++ * UI board NAND/NOR flashes only use 8-bit data bus.
++ */
++static const short da830_evm_emif25_pins[] = {
++	DA830_EMA_D_0, DA830_EMA_D_1, DA830_EMA_D_2, DA830_EMA_D_3,
++	DA830_EMA_D_4, DA830_EMA_D_5, DA830_EMA_D_6, DA830_EMA_D_7,
++	DA830_EMA_A_0, DA830_EMA_A_1, DA830_EMA_A_2, DA830_EMA_A_3,
++	DA830_EMA_A_4, DA830_EMA_A_5, DA830_EMA_A_6, DA830_EMA_A_7,
++	DA830_EMA_A_8, DA830_EMA_A_9, DA830_EMA_A_10, DA830_EMA_A_11,
++	DA830_EMA_A_12, DA830_EMA_BA_0, DA830_EMA_BA_1, DA830_NEMA_WE,
++	DA830_NEMA_CS_2, DA830_NEMA_CS_3, DA830_NEMA_OE, DA830_EMA_WAIT_0,
++	-1
++};
++
+ static __init void da830_evm_init(void)
+ {
+ 	struct davinci_soc_info *soc_info = &davinci_soc_info;
+@@ -94,6 +408,8 @@ static __init void da830_evm_init(void)
+ 		pr_warning("da830_evm_init: i2c0 registration failed: %d\n",
+ 				ret);
+ 
++	da830_evm_usb_init();
++
+ 	soc_info->emac_pdata->phy_mask = DA830_EVM_PHY_MASK;
+ 	soc_info->emac_pdata->mdio_max_freq = DA830_EVM_MDIO_FREQUENCY;
+ 	soc_info->emac_pdata->rmii_en = 1;
+@@ -117,12 +433,49 @@ static __init void da830_evm_init(void)
+ 	i2c_register_board_info(1, da830_evm_i2c_devices,
+ 			ARRAY_SIZE(da830_evm_i2c_devices));
+ 
+-	ret = da8xx_pinmux_setup(da830_mcasp1_pins);
++	ret = da8xx_pinmux_setup(da830_evm_mcasp1_pins);
+ 	if (ret)
+ 		pr_warning("da830_evm_init: mcasp1 mux setup failed: %d\n",
+ 				ret);
+ 
+-	da8xx_init_mcasp(1, &da830_evm_snd_data);
++	da8xx_register_mcasp(1, &da830_evm_snd_data);
++
++	ret = da8xx_pinmux_setup(da830_evm_mmc_sd_pins);
++	if (ret)
++		pr_warning("da830_evm_init: mmc/sd mux setup failed: %d\n",
++				ret);
++
++	ret = da8xx_register_mmcsd0(&da830_evm_mmc_config);
++	if (ret)
++		pr_warning("da830_evm_init: mmc/sd registration failed: %d\n",
++				ret);
++
++#ifdef CONFIG_DA830_UI
++#ifdef CONFIG_DA830_UI_LCD
++	ret = da8xx_pinmux_setup(da830_lcdcntl_pins);
++	if (ret)
++		pr_warning("da830_evm_init: lcdcntl mux setup failed: %d\n",
++				ret);
++
++	ret = da8xx_register_lcdc(&sharp_lcd035q3dg01_pdata);
++	if (ret)
++		pr_warning("da830_evm_init: lcd setup failed: %d\n", ret);
++#else /* Must be NAND or NOR */
++	ret = da8xx_pinmux_setup(da830_evm_emif25_pins);
++	if (ret)
++		pr_warning("da830_evm_init: emif25 mux setup failed: %d\n",
++				ret);
++
++	ret = platform_add_devices(da830_evm_devices,
++			ARRAY_SIZE(da830_evm_devices));
++	if (ret)
++		pr_warning("da830_evm_init: EVM devices not added\n");
++#endif
++#endif
++
++	ret = da8xx_register_rtc();
++	if (ret)
++		pr_warning("da830_evm_init: rtc setup failed: %d\n", ret);
+ }
+ 
+ #ifdef CONFIG_SERIAL_8250_CONSOLE
+@@ -146,7 +499,7 @@ static void __init da830_evm_map_io(void
+ 	da830_init();
+ }
+ 
+-MACHINE_START(DAVINCI_DA830_EVM, "DaVinci DA830/OMAP L137 EVM")
++MACHINE_START(DAVINCI_DA830_EVM, "DaVinci DA830/OMAP-L137 EVM")
+ 	.phys_io	= IO_PHYS,
+ 	.io_pg_offst	= (__IO_ADDRESS(IO_PHYS) >> 18) & 0xfffc,
+ 	.boot_params	= (DA8XX_DDR_BASE + 0x100),
+--- a/drivers/mmc/core/core.c
++++ b/drivers/mmc/core/core.c
+@@ -1073,6 +1073,7 @@ void mmc_rescan(struct work_struct *work
+ 	mmc_claim_host(host);
+ 
+ 	mmc_power_up(host);
++	mmc_reset_sdio(host);
+ 	mmc_go_idle(host);
+ 
+ 	mmc_send_if_cond(host, host->ocr_avail);
+--- a/arch/arm/mach-davinci/board-dm646x-evm.c
++++ b/arch/arm/mach-davinci/board-dm646x-evm.c
+@@ -33,8 +33,15 @@
+ #include <linux/i2c/at24.h>
+ #include <linux/i2c/pcf857x.h>
+ #include <linux/etherdevice.h>
++#include <linux/spi/spi.h>
++#include <linux/spi/eeprom.h>
+ 
+ #include <media/tvp514x.h>
++#include <media/tvp7002.h>
++#include <media/davinci/videohd.h>
++#include <linux/mtd/mtd.h>
++#include <linux/mtd/nand.h>
++#include <linux/mtd/partitions.h>
+ 
+ #include <asm/setup.h>
+ #include <asm/mach-types.h>
+@@ -44,12 +51,31 @@
+ 
+ #include <mach/dm646x.h>
+ #include <mach/common.h>
++#include <mach/mux.h>
+ #include <mach/psc.h>
+ #include <mach/serial.h>
+ #include <mach/i2c.h>
++#include <mach/nand.h>
+ #include <mach/mmc.h>
+ #include <mach/emac.h>
+ 
++#include <mach/clock.h>
++#include "clock.h"
++
++
++#if defined(CONFIG_PCI)
++#define HAS_PCI 1
++#else
++#define HAS_PCI 0
++#endif
++
++#if defined(CONFIG_MTD_NAND_DAVINCI) || \
++	defined(CONFIG_MTD_NAND_DAVINCI_MODULE)
++#define HAS_NAND 1
++#else
++#define HAS_NAND 0
++#endif
++
+ #if defined(CONFIG_BLK_DEV_PALMCHIP_BK3710) || \
+     defined(CONFIG_BLK_DEV_PALMCHIP_BK3710_MODULE)
+ #define HAS_ATA 1
+@@ -57,9 +83,24 @@
+ #define HAS_ATA 0
+ #endif
+ 
++#if defined(CONFIG_MTD_NAND_DAVINCI) || \
++    defined(CONFIG_MTD_NAND_DAVINCI_MODULE)
++#define HAS_NAND 1
++#else
++#define HAS_NAND 0
++#endif
++
++
++#define DAVINCI_ASYNC_EMIF_CONTROL_BASE		0x20008000
++#define DAVINCI_ASYNC_EMIF_DATA_CE0_BASE	0x42000000
++
++#define NAND_BLOCK_SIZE		SZ_128K
++
+ /* CPLD Register 0 bits to control ATA */
+ #define DM646X_EVM_ATA_RST		BIT(0)
+ #define DM646X_EVM_ATA_PWD		BIT(1)
++#define DM646X_EVM_USB_VBUS		BIT(7)
++#define DM646X_EVM_CIR_UART             BIT(5)
+ 
+ #define DM646X_EVM_PHY_MASK		(0x2)
+ #define DM646X_EVM_MDIO_FREQUENCY	(2200000) /* PHY bus frequency */
+@@ -69,13 +110,20 @@
+ #define VCH2CLK_MASK		(BIT_MASK(10) | BIT_MASK(9) | BIT_MASK(8))
+ #define VCH2CLK_SYSCLK8		(BIT(9))
+ #define VCH2CLK_AUXCLK		(BIT(9) | BIT(8))
++#define VCH2CLK_VP_CLKIN2	(BIT(9) | BIT(10))
++
+ #define VCH3CLK_MASK		(BIT_MASK(14) | BIT_MASK(13) | BIT_MASK(12))
+ #define VCH3CLK_SYSCLK8		(BIT(13))
+-#define VCH3CLK_AUXCLK		(BIT(14) | BIT(13))
++#define VCH3CLK_AUXCLK		(BIT(12) | BIT(13))
++#define VCH3CLK_VP_CLKIN2	(BIT(13) | BIT(14))
+ 
+ #define VIDCH2CLK		(BIT(10))
+ #define VIDCH3CLK		(BIT(11))
+ #define VIDCH1CLK		(BIT(4))
++
++#define VIDCH1CLKSRCCH1		(BIT(4))
++#define VIDCH1CLKSRCCH0		(~BIT(4))
++
+ #define TVP7002_INPUT		(BIT(4))
+ #define TVP5147_INPUT		(~BIT(4))
+ #define VPIF_INPUT_ONE_CHANNEL	(BIT(5))
+@@ -88,40 +136,194 @@ static void __iomem *vpif_vsclkdis_reg;
+ /* spin lock for updating above registers */
+ static spinlock_t vpif_reg_lock;
+ 
++
+ static struct davinci_uart_config uart_config __initdata = {
+ 	.enabled_uarts = (1 << 0),
+ };
+ 
++/* Note: The partitioning is driven by combination of UBL and U-Boot. For
++ * example, in the layout below, U-Boot puts environment in block 0
++ * and UBL can be in blocks 1-5 while U-Boot resides after UBL blocks.
++ */
++static struct mtd_partition davinci_nand_partitions[] = {
++	{
++		/* U-Boot environment */
++		.name		= "params",
++		.offset		= 0,
++		.size		= 1 * NAND_BLOCK_SIZE,
++		.mask_flags	= 0,
++	}, {
++		/* UBL, U-Boot */
++		.name		= "bootloader",
++		.offset		= MTDPART_OFS_APPEND,
++		.size		= 10 * NAND_BLOCK_SIZE,
++		.mask_flags	= MTD_WRITEABLE,	/* force read-only */
++	}, {
++		.name		= "kernel",
++		.offset		= MTDPART_OFS_APPEND,
++		.size		= SZ_4M,
++		.mask_flags	= 0,
++	}, {
++		.name		= "filesystem",
++		.offset		= MTDPART_OFS_APPEND,
++		.size		= MTDPART_SIZ_FULL,
++		.mask_flags	= 0,
++	}
++};
++
++static struct davinci_nand_pdata davinci_nand_data = {
++	.mask_cle 		= 0x80000,
++	.mask_ale 		= 0x40000,
++	.parts			= davinci_nand_partitions,
++	.nr_parts		= ARRAY_SIZE(davinci_nand_partitions),
++	.ecc_mode		= NAND_ECC_HW,
++	.options		= 0,
++};
++
++static struct resource davinci_nand_resources[] = {
++	{
++		.start		= DAVINCI_ASYNC_EMIF_DATA_CE0_BASE,
++		.end		= DAVINCI_ASYNC_EMIF_DATA_CE0_BASE + SZ_32M - 1,
++		.flags		= IORESOURCE_MEM,
++	}, {
++		.start		= DAVINCI_ASYNC_EMIF_CONTROL_BASE,
++		.end		= DAVINCI_ASYNC_EMIF_CONTROL_BASE + SZ_4K - 1,
++		.flags		= IORESOURCE_MEM,
++	},
++};
++
++static struct platform_device davinci_nand_device = {
++	.name			= "davinci_nand",
++	.id			= 0,
++
++	.num_resources		= ARRAY_SIZE(davinci_nand_resources),
++	.resource		= davinci_nand_resources,
++
++	.dev			= {
++		.platform_data	= &davinci_nand_data,
++	},
++};
++
++/* Setup DM6467 for PCI mode. In case of default EVM, the CPLD along with FET
++ * switches takes care of switching to PCI Boot mode when the EVM is put in
++ * the PCI slot and this funtion needs to do nothing. While in case when the
++ * CPLD code/ Hardware is reworked (not to do autoswitch), the code below
++ * handles mux configurations to switch to PCI (Host) mode  and takes care of
++ * driving RST# over PCI Bus.
++ *
++ * Note: This function relies on h/w setting of PCIEN to distinguish between
++ * modified and unmodified EVM and might not work in case s/w (e.g., bootloader)
++ * is manipulating PCIEN after booting.
++ */
++static void dm646xevm_pci_setup(void)
++{
++	void __iomem *base = IO_ADDRESS(DAVINCI_SYSTEM_MODULE_BASE);
++
++	/* Skip this if PCIEN is already set in  PINMUX0 */
++	if (!((__raw_readl(base + PINMUX0)) & (1<<2))) {
++		/* Power up the I/O cells for PCI interface */
++		__raw_writel(__raw_readl(base + DM64XX_VDD3P3V_PWDN)
++				& ~(3<<16), base + DM64XX_VDD3P3V_PWDN);
++
++		davinci_cfg_reg(DM646X_HPI32EN);
++
++		/* Drive GPIO[13] High to avoid reset when PCI is
++		 * enabled
++		 */
++		if (gpio_request(13, "RST#") != 0) {
++			pr_err("Request for GPIO13 failed.\n");
++			return;
++		}
++
++		gpio_direction_output(13, 1);
++
++		/* Ensure AUDCK1 is disabled to control GPIO[2] */
++		davinci_cfg_reg(DM646X_AUDCK1);
++
++		davinci_cfg_reg(DM646X_PCIEN);
++
++		/* Drive GPIO[2] high to take the PCI bus out of reset
++		 * (drive RST#) and select B2 of the FET mux on EVM to
++		 * deselect NAND and switch to PCI Bus
++		 */
++		if (gpio_request(2, "PCIRST#") != 0) {
++			pr_err("Request for GPIO2 failed.\n");
++			return;
++		}
++		gpio_direction_output(2, 1);
++	} else {
++		pr_info("PCI_EN is already asserted.\n");
++	}
++}
++static struct i2c_client *cpld_reg0_client;
++
+ /* CPLD Register 0 Client: used for I/O Control */
+ static int cpld_reg0_probe(struct i2c_client *client,
+ 			   const struct i2c_device_id *id)
+ {
+-	if (HAS_ATA) {
+-		u8 data;
+-		struct i2c_msg msg[2] = {
+-			{
+-				.addr = client->addr,
+-				.flags = I2C_M_RD,
+-				.len = 1,
+-				.buf = &data,
+-			},
+-			{
+-				.addr = client->addr,
+-				.flags = 0,
+-				.len = 1,
+-				.buf = &data,
+-			},
+-		};
++	u8 data;
++	struct i2c_msg msg[2] = {
++		{
++			.addr = client->addr,
++			.flags = I2C_M_RD,
++			.len = 1,
++			.buf = &data,
++		},
++		{
++			.addr = client->addr,
++			.flags = 0,
++			.len = 1,
++			.buf = &data,
++		},
++	};
++
++	cpld_reg0_client = client;
++
++	/* Clear UART CIR to enable cir operation. */
++		i2c_transfer(client->adapter, msg, 1);
++		data &= ~(DM646X_EVM_CIR_UART);
++		i2c_transfer(client->adapter, msg + 1, 1);
+ 
++	if (HAS_ATA && !HAS_PCI) {
+ 		/* Clear ATA_RSTn and ATA_PWD bits to enable ATA operation. */
+ 		i2c_transfer(client->adapter, msg, 1);
+ 		data &= ~(DM646X_EVM_ATA_RST | DM646X_EVM_ATA_PWD);
+ 		i2c_transfer(client->adapter, msg + 1, 1);
+ 	}
+ 
++	setup_usb(500, 8);
++
+ 	return 0;
+ }
+ 
++void usb_vbus_control(u8 on)
++{
++	u8 data;
++	struct i2c_msg msg[2] = {
++		{
++			.addr = cpld_reg0_client->addr,
++			.flags = I2C_M_RD,
++			.len = 1,
++			.buf = &data,
++		},
++		{
++			.addr = cpld_reg0_client->addr,
++			.flags = 0,
++			.len = 1,
++			.buf = &data,
++		},
++	};
++
++	i2c_transfer(cpld_reg0_client->adapter, msg, 1);
++	if (on)
++		data |= DM646X_EVM_USB_VBUS;
++	else
++		data &= ~DM646X_EVM_USB_VBUS;
++
++	i2c_transfer(cpld_reg0_client->adapter, msg + 1, 1);
++}
++EXPORT_SYMBOL(usb_vbus_control);
++
+ static const struct i2c_device_id cpld_reg_ids[] = {
+ 	{ "cpld_reg0", 0, },
+ 	{ },
+@@ -365,6 +567,9 @@ static struct i2c_board_info __initdata
+ 	{
+ 		I2C_BOARD_INFO("cpld_video", 0x3b),
+ 	},
++	{
++		I2C_BOARD_INFO("cdce949", 0x6C),
++	},
+ };
+ 
+ static struct davinci_i2c_platform_data i2c_pdata = {
+@@ -406,10 +611,10 @@ static int set_vpif_clock(int mux_mode,
+ 	value &= ~(VCH2CLK_MASK);
+ 	value &= ~(VCH3CLK_MASK);
+ 
+-	if (hd >= 1)
+-		value |= (VCH2CLK_SYSCLK8 | VCH3CLK_SYSCLK8);
+-	else
+-		value |= (VCH2CLK_AUXCLK | VCH3CLK_AUXCLK);
++	/* Here it is assumed that channel3 will use same
++	   clock as channel-2. If channel3 operates in SD
++	   mode, this needs to be changed */
++	value |= (VCH2CLK_VP_CLKIN2 | VCH3CLK_VP_CLKIN2);
+ 
+ 	__raw_writel(value, vpif_vidclkctl_reg);
+ 
+@@ -424,18 +629,28 @@ static int set_vpif_clock(int mux_mode,
+ }
+ 
+ static struct vpif_subdev_info dm646x_vpif_subdev[] = {
++#if defined(CONFIG_VIDEO_ADV7343) || defined(CONFIG_VIDEO_ADV7343_MODULE)
+ 	{
+ 		.name	= "adv7343",
+ 		.board_info = {
+ 			I2C_BOARD_INFO("adv7343", 0x2a),
+ 		},
+ 	},
++#endif
+ 	{
+ 		.name	= "ths7303",
+ 		.board_info = {
+ 			I2C_BOARD_INFO("ths7303", 0x2c),
+ 		},
+ 	},
++#if defined(CONFIG_VIDEO_THS8200) || defined(CONFIG_VIDEO_THS8200_MODULE)
++	{
++		.name	= "ths8200",
++		.board_info = {
++			I2C_BOARD_INFO("ths8200", 0x20),
++		},
++	},
++#endif
+ };
+ 
+ static const char *output[] = {
+@@ -500,7 +715,7 @@ static int setup_vpif_input_channel_mode
+ 	unsigned long flags;
+ 	int err = 0;
+ 	int val;
+-	u32 value;
++	u32 value, value1;
+ 
+ 	if (!vpif_vsclkdis_reg || !cpld_client)
+ 		return -ENXIO;
+@@ -511,14 +726,18 @@ static int setup_vpif_input_channel_mode
+ 
+ 	spin_lock_irqsave(&vpif_reg_lock, flags);
+ 	value = __raw_readl(vpif_vsclkdis_reg);
++	value1 = __raw_readl(vpif_vidclkctl_reg);
+ 	if (mux_mode) {
+ 		val &= VPIF_INPUT_TWO_CHANNEL;
+ 		value |= VIDCH1CLK;
++		value1 |= VIDCH1CLKSRCCH1;
+ 	} else {
+ 		val |= VPIF_INPUT_ONE_CHANNEL;
+ 		value &= ~VIDCH1CLK;
++		value1 &= VIDCH1CLKSRCCH0;
+ 	}
+ 	__raw_writel(value, vpif_vsclkdis_reg);
++	__raw_writel(value1, vpif_vidclkctl_reg);
+ 	spin_unlock_irqrestore(&vpif_reg_lock, flags);
+ 
+ 	err = i2c_smbus_write_byte(cpld_client, val);
+@@ -534,9 +753,22 @@ static struct tvp514x_platform_data tvp5
+ 	.vs_polarity = 1
+ };
+ 
++struct tvp7002_platform_data tvp7002_pdata = {
++       .clk_polarity = 1,
++       .hs_polarity = 1,
++       .vs_polarity = 1,
++       .fid_polarity = 1,
++};
++
+ #define TVP514X_STD_ALL (V4L2_STD_NTSC | V4L2_STD_PAL)
++#define TVP7002_STD_ALL        (V4L2_STD_525P_60   | V4L2_STD_625P_50 	|\
++				V4L2_STD_525_60    | V4L2_STD_625_50   |\
++				V4L2_STD_720P_50   | V4L2_STD_720P_60 	|\
++				V4L2_STD_1080I_50  | V4L2_STD_1080I_60 	|\
++				V4L2_STD_1080P_50  | V4L2_STD_1080P_60)
+ 
+ static struct vpif_subdev_info vpif_capture_sdev_info[] = {
++#ifndef CONFIG_VIDEO_TVP7002
+ 	{
+ 		.name	= TVP5147_CH0,
+ 		.board_info = {
+@@ -569,6 +801,30 @@ static struct vpif_subdev_info vpif_capt
+ 			.fid_pol = 0,
+ 		},
+ 	},
++#else
++	{
++		.name = "ths7353",
++		.board_info = {
++			I2C_BOARD_INFO("ths7353", 0x2e),
++			/* From driver point of view, we need only
++			   channel number for Luma*/
++			.platform_data = CONFIG_VIDEO_THS7353_LUMA_CHANNEL,
++		},
++	},
++	{
++		.name = "tvp7002",
++		.board_info = {
++			I2C_BOARD_INFO("tvp7002", 0x5d),
++			.platform_data = &tvp7002_pdata,
++		},
++		.vpif_if = {
++			.if_type = VPIF_IF_BT1120,
++			.hd_pol = 1,
++			.vd_pol = 1,
++			.fid_pol = 0,
++		},
++	},
++#endif
+ };
+ 
+ static const struct vpif_input dm6467_ch0_inputs[] = {
+@@ -581,6 +837,15 @@ static const struct vpif_input dm6467_ch
+ 		},
+ 		.subdev_name = TVP5147_CH0,
+ 	},
++	{
++		.input = {
++			.index = 1,
++			.name = "Component",
++			.type = V4L2_INPUT_TYPE_CAMERA,
++			.std = TVP7002_STD_ALL,
++		},
++		.subdev_name = "tvp7002",
++	},
+ };
+ 
+ static const struct vpif_input dm6467_ch1_inputs[] = {
+@@ -600,6 +865,7 @@ static struct vpif_capture_config dm646x
+ 	.setup_input_channel_mode = setup_vpif_input_channel_mode,
+ 	.subdev_info = vpif_capture_sdev_info,
+ 	.subdev_count = ARRAY_SIZE(vpif_capture_sdev_info),
++	.card_name	= "DM646x EVM",
+ 	.chan_config[0] = {
+ 		.inputs = dm6467_ch0_inputs,
+ 		.input_count = ARRAY_SIZE(dm6467_ch0_inputs),
+@@ -638,6 +904,24 @@ static void __init davinci_map_io(void)
+ 	dm646x_init();
+ }
+ 
++static struct spi_eeprom at25640a = {
++	.byte_len	= SZ_64K / 2,
++	.name		= "at25640a",
++	.page_size	= 64,
++	.flags		= EE_ADDR2,
++};
++
++static struct spi_board_info dm646x_evm_spi_info[] __initconst = {
++	{
++		.modalias	= "at25",
++		.platform_data	= &at25640a,
++		.max_speed_hz	= 10 * 1000 * 1000,	/* at 3v3 */
++		.bus_num	= 0,
++		.chip_select	= 0,
++		.mode		= SPI_MODE_0,
++	},
++};
++
+ static __init void evm_init(void)
+ {
+ 	struct davinci_soc_info *soc_info = &davinci_soc_info;
+@@ -646,12 +930,30 @@ static __init void evm_init(void)
+ 	davinci_serial_init(&uart_config);
+ 	dm646x_init_mcasp0(&dm646x_evm_snd_data[0]);
+ 	dm646x_init_mcasp1(&dm646x_evm_snd_data[1]);
++	dm646x_init_cir_device();
+ 
+-	if (HAS_ATA)
+-		dm646x_init_ide();
++	if (HAS_PCI) {
++		if (HAS_ATA)
++			pr_warning("WARNING: both PCI and IDE are "
++					"enabled, but they share some pins.\n"
++					"\tDisable PCI for IDE support.\n");
++		if (HAS_NAND)
++			pr_warning("WARNING: both PCI and NAND are "
++					"enabled, but they share AEMIF pins.\n"
++					"\tDisable PCI for NAND support.\n");
++		dm646xevm_pci_setup();
++	} else {
++
++		if (HAS_ATA)
++			dm646x_init_ide();
++		if (HAS_NAND)
++			platform_device_register(&davinci_nand_device);
++	}
+ 
+ 	soc_info->emac_pdata->phy_mask = DM646X_EVM_PHY_MASK;
+ 	soc_info->emac_pdata->mdio_max_freq = DM646X_EVM_MDIO_FREQUENCY;
++
++	dm646x_init_spi0(dm646x_evm_spi_info, ARRAY_SIZE(dm646x_evm_spi_info));
+ }
+ 
+ static __init void davinci_dm646x_evm_irq_init(void)
+@@ -669,3 +971,5 @@ MACHINE_START(DAVINCI_DM6467_EVM, "DaVin
+ 	.init_machine = evm_init,
+ MACHINE_END
+ 
++
++
+--- a/arch/arm/mach-davinci/include/mach/edma.h
++++ b/arch/arm/mach-davinci/include/mach/edma.h
+@@ -280,8 +280,8 @@ struct edma_soc_info {
+ 	unsigned	n_cc;
+ 	enum dma_event_q	default_queue;
+ 
+-	/* list of channels with no even trigger; terminated by "-1" */
+-	const s8	*noevent;
++	const s8	(*rsv_chans)[2];
++	const s16	(*rsv_slots)[2];
+ 	const s8	(*queue_tc_mapping)[2];
+ 	const s8	(*queue_priority_mapping)[2];
+ };
+--- a/drivers/media/video/videobuf-core.c
++++ b/drivers/media/video/videobuf-core.c
+@@ -360,7 +360,7 @@ int __videobuf_mmap_setup(struct videobu
+ 		q->bufs[i]->bsize  = bsize;
+ 		switch (memory) {
+ 		case V4L2_MEMORY_MMAP:
+-			q->bufs[i]->boff  = bsize * i;
++			q->bufs[i]->boff = PAGE_ALIGN(bsize) * i;
+ 			break;
+ 		case V4L2_MEMORY_USERPTR:
+ 		case V4L2_MEMORY_OVERLAY:
+@@ -430,9 +430,8 @@ int videobuf_reqbufs(struct videobuf_que
+ 		count = VIDEO_MAX_FRAME;
+ 	size = 0;
+ 	q->ops->buf_setup(q, &count, &size);
+-	size = PAGE_ALIGN(size);
+ 	dprintk(1, "reqbufs: bufs=%d, size=0x%x [%d pages total]\n",
+-		count, size, (count*size)>>PAGE_SHIFT);
++		count, size, (count*PAGE_ALIGN(size))>>PAGE_SHIFT);
+ 
+ 	retval = __videobuf_mmap_setup(q, count, size, req->memory);
+ 	if (retval < 0) {
+@@ -1099,7 +1098,7 @@ int videobuf_cgmbuf(struct videobuf_queu
+ 	mbuf->size   = 0;
+ 	for (i = 0; i < mbuf->frames; i++) {
+ 		mbuf->offsets[i]  = q->bufs[i]->boff;
+-		mbuf->size       += q->bufs[i]->bsize;
++		mbuf->size       += PAGE_ALIGN(q->bufs[i]->bsize);
+ 	}
+ 
+ 	return 0;
+--- /dev/null
++++ b/drivers/char/davinci_vdce_hw.h
+@@ -0,0 +1,260 @@
++/* *
++ * Copyright (C) 2007 Texas Instruments	Inc
++ *
++ * This	program	is free	software; you can redistribute it and/or modify
++ * it under the	terms of the GNU General Public	License	as published by
++ * the Free Software Foundation; either	version	2 of the License, or
++ * (at your option) any	later version.
++ *
++ * This	program	is distributed in the hope that	it will	be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A	PARTICULAR PURPOSE.	 See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59	Temple Place, Suite 330, Boston, MA 02111-1307	USA
++ */
++/* davinci_vdce_hw.h	file */
++#ifndef	DAVINCI_VDCE_HW_H
++#define	DAVINCI_VDCE_HW_H
++
++#ifdef __KERNEL__
++#include <mach/hardware.h>
++#include <asm/io.h>
++#endif
++
++#define	MAX_BLEND_TABLE	(4)
++
++/* Register	offset mapping*/
++#ifdef __KERNEL__
++#define	BITSET(variable,bit)		((variable)| (1<<bit))
++#define	BITRESET(variable,bit)		((variable)& (~(0x00000001<<(bit))))
++#define	BITGET(variable,bit)		(((variable)& (1<<bit))>>(bit))
++
++/* Bit position for various bits . Used in BITSET */
++#define	 SET_CCV_V_TYPE		(2)
++#define	 SET_CCV_H_TYPE		(3)
++#define	 SET_CCV_IN_MPEG1	(1)
++#define	 SET_CCV_OUT_MPEG1	(0)
++#define	 SET_CCV_ENABLE		(10)
++#define	 VDCE_RASTER_SCANNING	(0)
++/* Bits position number to be used in bitset for setting various registers */
++#define	SET_HRSZ_ENABLE		(0)
++#define	SET_VRSZ_ENABLE		(4)
++#define	SET_HRSZ_ALF_ENABLE	(8)
++#define	SET_VRSZ_ALF_ENABLE	(12)
++#define	SET_RSZ_H_TYPE		(1)
++#define	SET_RSZ_V_TYPE		(5)
++#define	SET_RSZ_H_ALF_mode	(9)
++#define	SET_LUMA_ENABLE		(1)
++#define	SET_CHROMA_ENABLE	(2)
++#define	SET_TOP_ENABLE		(7)
++#define	SET_BOT_ENABLE		(6)
++#define	SET_SRC_MODE		(14)
++#define	SET_RES_MODE		(13)
++#define	SET_BMP_MODE		(15)
++#define	SET_PRO_MODE		(12)
++/* various modes supported in hardware. The value generated by them */
++#define	MODE_PRECODEC		(2)
++#define	MODE_POSTCODEC		(3)
++#define	MODE_TRANSCODEC		(1)
++#define	MODE_EPAD		(0)
++
++#define	SET_RSZ_ENABLE		(8)
++#define	SET_RMAP_ENABLE		(9)
++#define	SET_BLEND_ENABLE	(11)
++#define	FOUR_TWO_TWO		(1)
++#define	SET_RMAP_YENABLE	(3)
++#define	SET_RMAP_CENABLE	(11)
++
++/* various shifts and masks of register */
++#define	LUMA_CHROMA_ENABLE_MASK	(0x6)
++#define	LUMA_CHROMA_ENABLE_SHIFT (0x1)
++#define	TOP_BOTTOM_ENABLE_MASK	(0xc0)
++#define	TOP_BOTTOM_ENABLE_SHIFT	(0x6)
++
++/* Mask and shift values for range mapping registers */
++#define	RANGE_MAP_Y_SHIFT	(0)
++#define	RANGE_MAP_Y_MASK	(0x7<<RANGE_MAP_Y_SHIFT)
++#define	RANGE_MAP_C_SHIFT	(8)
++#define	RANGE_MAP_C_MASK	(0x7<<RANGE_MAP_C_SHIFT)
++/* Mask and shift values for Blending registers */
++#define	BLD_LUT_Y_SHIFT		(16)
++#define	BLD_LUT_Y_MASK		(0xff<<BLD_LUT_Y_SHIFT)
++#define	BLD_LUT_CB_SHIFT	(0)
++#define	BLD_LUT_CB_MASK		(0xff<<BLD_LUT_CB_SHIFT)
++#define	BLD_LUT_CR_SHIFT	(8)
++#define	BLD_LUT_CR_MASK		(0xff<<BLD_LUT_CR_SHIFT)
++#define	BLD_LUT_FCT_SHIFT	(24)
++#define	BLD_LUT_FCT_MASK	(0xff<<BLD_LUT_FCT_SHIFT)
++/* Mask and shift values for Edgepadding registers */
++#define	EPD_C_HEXT_SHIFT	(0)
++#define	EPD_C_HEXT_MASK		(0x3f<<EPD_C_HEXT_SHIFT)
++#define	EPD_C_VEXT_SHIFT	(8)
++#define	EPD_C_VEXT_MASK		(0x3f<<EPD_C_VEXT_SHIFT	 )
++#define	EPD_Y_VEXT_SHIFT	(8)
++#define	EPD_Y_VEXT_MASK		(0x3f<<EPD_Y_VEXT_SHIFT)
++#define	EPD_Y_HEXT_SHIFT	(0)
++#define	EPD_Y_HEXT_MASK		(0x3f<<EPD_Y_HEXT_SHIFT	)
++/* Mask and shift values for Resizing registers */
++#define	RSZ_H_MAG_SHIFT		(0)
++#define	RSZ_H_MAG_MASK		(0xfff<<RSZ_H_MAG_SHIFT	)
++#define	RSZ_V_MAG_SHIFT		(0)
++#define	RSZ_V_MAG_MASK		(0xfff<<RSZ_V_MAG_SHIFT	)
++
++#define	VDCE_REQ_SZ_SHIFT		(0)
++#define	VDCE_REQ_SZ_MASK		(0x1ff<<VDCE_REQ_SZ_SHIFT	)
++#define	VDCE_PRCS_UNIT_SIZE_SHIFT	 (0)
++#define	VDCE_PRCS_UNIT_SIZE_MASK	 (0x1ff<<VDCE_PRCS_UNIT_SIZE_SHIFT )
++/* source and result image size shift and mask */
++#define	SRC_Y_HSZ_SHIFT		(0)
++#define	SRC_Y_HSZ_MASK		(0xfff<<SRC_Y_HSZ_SHIFT	)
++#define	SRC_Y_VSZ_SHIFT		(16)
++#define	SRC_Y_VSZ_MASK		(0xfff<<SRC_Y_VSZ_SHIFT	)
++#define	RES_Y_HSZ_SHIFT		(0)
++#define	RES_Y_HSZ_MASK		(0xfff<<SRC_Y_HSZ_SHIFT	)
++#define	RES_Y_VSZ_SHIFT		(16)
++#define	RES_Y_VSZ_MASK		(0xfff<<RES_Y_VSZ_SHIFT	)
++#define	SRC_C_HSZ_SHIFT		(0)
++#define	SRC_C_HSZ_MASK		(0xfff<<SRC_C_HSZ_SHIFT	)
++#define	SRC_C_VSZ_SHIFT		(16)
++#define	SRC_C_VSZ_MASK		(0xfff<<SRC_C_VSZ_SHIFT	 )
++#define	RES_C_HSZ_SHIFT		(0)
++#define	RES_C_HSZ_MASK		(0xfff<<RES_C_HSZ_SHIFT	)
++#define	RES_C_VSZ_SHIFT		(16)
++#define	RES_C_VSZ_MASK		(0xfff<<RES_C_VSZ_SHIFT)
++#define	SRC_BMP_HSZ_SHIFT	(0)
++#define	SRC_BMP_HSZ_MASK	(0xfff<<SRC_BMP_HSZ_SHIFT )
++#define	SRC_BMP_VSZ_SHIFT	(16)
++#define	SRC_BMP_VSZ_MASK	(0xfff<<SRC_BMP_VSZ_SHIFT )
++#define	SRC_BMP_STRT_HPS_SHIFT	  (0)
++#define	SRC_BMP_STRT_HPS_MASK	  (0xfff<<SRC_BMP_STRT_HPS_SHIFT)
++#define	RES_BMP_STRT_VPS_SHIFT	(16)
++#define	RES_BMP_STRT_VPS_MASK	(0xfff<<RES_BMP_STRT_VPS_SHIFT )
++
++#define	VDCE_MODE_SHIFT		(4)
++#define	VDCE_MODE_MASK		(0x3 <<VDCE_MODE_SHIFT )
++#define	RSZ_ALF_INTENSITY_SHIFT	(0)
++#define	RSZ_ALF_INTENSITY_MASK	(0xff)
++/* Base address and offset for various ge registers */
++#define	VDCE_IOBASE_VADDR	IO_ADDRESS(0x01c12800)
++/*#define	VDCE_IOBASE_VADDR	(0x01c12800)*/
++#define	VDCE_ENABLE		(0x0)
++#define	VDCE_CTRL		(0x04)
++#define	VDCE_INTEN		(0x08)
++#define	VDCE_INTEN_SET		(0x0c)
++#define	VDCE_EMULATION_CTRL	(0x1c)
++#define	VDCE_STATUS		(0x14)
++#define	VDCE_STATUS_CLR		(0x18)
++#define	VDCE_SDR_FMT		(0x20)
++#define	VDCE_REQ_SZ		(0x24)
++#define	VDCE_PRCS_UNIT_SIZE	(0x28)
++#define	VDCE_SRC_STRT_ADD_YTOP	(0x40)
++#define	VDCE_SRC_STRT_OFF_YTOP	(0x48)
++#define	VDCE_SRC_STRT_ADD_YBOT	(0x4c)
++#define	VDCE_SRC_STRT_OFF_YBOT	(0x54)
++#define	VDCE_SRC_STRT_ADD_CTOP	(0x58)
++#define	VDCE_SRC_STRT_OFF_CTOP	(0x60)
++#define	VDCE_SRC_STRT_ADD_CBOT	(0x64)
++#define	VDCE_SRC_STRT_OFF_CBOT	(0x6c)
++#define	VDCE_SRC_STRT_ADD_BMP_TOP	(0x70)
++#define	VDCE_SRC_STRT_OFF_BMP_TOP	(0x74)
++#define	VDCE_SRC_STRT_ADD_BMP_BOT	(0x78)
++#define	VDCE_SRC_STRT_OFF_BMP_BOT	(0x7c)
++#define	VDCE_RES_STRT_ADD_YTOP	(0x80)
++#define	VDCE_RES_STRT_OFF_YTOP	(0x88)
++#define	VDCE_RES_STRT_ADD_YBOT	(0x8c)
++#define	VDCE_RES_STRT_OFF_YBOT	(0x94)
++#define	VDCE_RES_STRT_ADD_CTOP	(0x98)
++#define	VDCE_RES_STRT_OFF_CTOP	(0xa0)
++#define	VDCE_RES_STRT_ADD_CBOT	(0xa4)
++#define	VDCE_RES_STRT_OFF_CBOT	(0xac)
++#define	SRC_Y_STRT_PS		(0xc0)
++#define	SRC_Y_SZ		(0xc4)
++#define	SRC_C_STRT_PS		(0xc8)
++#define	SRC_C_SZ		(0xcc)
++#define	SRC_BMP_STRT_PS		(0xd0)
++#define	SRC_BMP_SZ		(0xd4)
++#define	RES_Y_STRT_PS		(0xe0)
++#define	RES_Y_SZ		(0xe4)
++#define	RES_C_STRT_PS		(0xe8)
++#define	RES_C_SZ		(0xec)
++#define	RES_BMP_STRT_PS		(0xf0)
++#define	RSZ_MODE		(0x100)
++#define	RSZ_H_MAG		(0x104)
++#define	RSZ_V_MAG		(0x108)
++#define	RSZ_H_PHASE		(0x10c)
++#define	RSZ_V_PHASE		(0x110)
++#define	RSZ_ALF_INTENSITY	(0x114)
++#define	CCV_MODE		(0x120)
++#define	BLD_LUT_00		(0x140)
++#define	BLD_LUT_01		(0x144)
++#define	BLD_LUT_02		(0x148)
++#define	BLD_LUT_03		(0x14c)
++#define	RGMP_CTRL		(0x160)
++#define	EPD_LUMA_WIDTH		(0x184)
++#define	EPD_CHROMA_WIDTH	(0x188)
++/* Register read/write */
++#define	regw(val,reg)		__raw_writel(val,((reg)+ VDCE_IOBASE_VADDR))
++#define	regr(reg)		__raw_readl((reg)+VDCE_IOBASE_VADDR)
++
++#define vdce_isbusy()		(regr(VDCE_CTRL) & 0x01)
++
++/* register mapping structure */
++typedef struct vdce_hw_config {
++	unsigned int vdce_ctrl;
++	unsigned int vdce_emulation_ctrl;
++	unsigned int vdce_sdr_fmt;
++	unsigned int vdce_req_sz;
++	unsigned int vdce_prcs_unit_size;
++	u32 src_Y_strt_ps;
++	u32 src_Y_sz;
++	u32 src_C_strt_ps;
++	u32 src_C_sz;
++	u32 src_bmp_strt_ps;
++	u32 src_bmp_sz;
++	u32 res_Y_strt_ps;
++	u32 res_Y_sz;
++	u32 res_C_strt_ps;
++	u32 res_C_sz;
++	u32 res_bmp_strt_ps;
++	unsigned int vdce_src_strt_add_ytop;
++	unsigned int vdce_src_strt_add_ctop;
++	unsigned int vdce_src_strt_add_ybot;
++	unsigned int vdce_src_strt_add_cbot;
++	unsigned int vdce_res_strt_add_ytop;
++	unsigned int vdce_res_strt_add_ctop;
++	unsigned int vdce_res_strt_add_ybot;
++	unsigned int vdce_res_strt_add_cbot;
++	unsigned int vdce_src_add_ofst_ytop;
++	unsigned int vdce_src_add_ofst_ctop;
++	unsigned int vdce_src_add_ofst_ybot;
++	unsigned int vdce_src_add_ofst_cbot;
++	unsigned int vdce_src_strt_add_bmp_top;
++	unsigned int vdce_src_strt_add_bmp_bot;
++	unsigned int vdce_src_strt_off_bmp_top;
++	unsigned int vdce_src_strt_off_bmp_bot;
++	unsigned int vdce_res_strt_off_ytop;
++	unsigned int vdce_res_strt_off_ctop;
++	unsigned int vdce_res_strt_off_ybot;
++	unsigned int vdce_res_strt_off_cbot;
++	u32 rsz_mode;
++	u32 rsz_h_mag;
++	u32 rsz_v_mag;
++	u32 rsz_h_phase;
++	u32 rsz_v_phase;
++	u32 rsz_alf_intensity;
++	u32 ccv_mode;
++	u32 bld_lut[MAX_BLEND_TABLE];
++	u32 rgmp_ctrl;
++	u32 epd_luma_width;
++	u32 epd_chroma_width;
++} vdce_hw_config_t;
++
++int vdce_enable_int(void);
++int vdce_clear_status(void);
++int vdce_enable(vdce_hw_config_t *);
++void vdce_hw_setup(vdce_hw_config_t *);
++#endif
++#endif
+--- a/drivers/media/video/davinci/vpif_display.c
++++ b/drivers/media/video/davinci/vpif_display.c
+@@ -30,10 +30,11 @@
+ #include <linux/platform_device.h>
+ #include <linux/io.h>
+ #include <linux/version.h>
+-
++#include <linux/clk.h>
+ #include <asm/irq.h>
+ #include <asm/page.h>
+ 
++#include <media/davinci/videohd.h>
+ #include <media/adv7343.h>
+ #include <media/v4l2-device.h>
+ #include <media/v4l2-ioctl.h>
+@@ -46,7 +47,11 @@
+ MODULE_DESCRIPTION("TI DaVinci VPIF Display driver");
+ MODULE_LICENSE("GPL");
+ 
+-#define DM646X_V4L2_STD (V4L2_STD_525_60 | V4L2_STD_625_50)
++#define DM646X_V4L2_STD (V4L2_STD_525_60 | V4L2_STD_625_50 |\
++			 V4L2_STD_1080P_60 | V4L2_STD_720P_60|\
++			 V4L2_STD_720P_50 | V4L2_STD_1080I_60 |\
++			 V4L2_STD_1080I_50 | V4L2_STD_525P_60 |\
++			 V4L2_STD_625P_50)
+ 
+ #define vpif_err(fmt, arg...)	v4l2_err(&vpif_obj.v4l2_dev, fmt, ## arg)
+ #define vpif_dbg(level, debug, fmt, arg...)	\
+@@ -86,12 +91,40 @@ static struct device *vpif_dev;
+ static const struct vpif_channel_config_params ch_params[] = {
+ 	{
+ 		"NTSC", 720, 480, 30, 0, 1, 268, 1440, 1, 23, 263, 266,
+-		286, 525, 525, 0, 1, 0, V4L2_STD_525_60,
++		286, 525, 525, 0, 1, 0, V4L2_STD_525_60, 27000000
+ 	},
+ 	{
+ 		"PAL", 720, 576, 25, 0, 1, 280, 1440, 1, 23, 311, 313,
+-		336, 624, 625, 0, 1, 0, V4L2_STD_625_50,
++		336, 624, 625, 0, 1, 0, V4L2_STD_625_50, 27000000
++	},
++	{
++		"1080P60", 1920, 1080, 60, 1, 0, 272, 1920, 1, 42, 1122, 0,
++		0, 0, 1125, 0, 0, 1, V4L2_STD_1080P_60, 148000000
++	},
++	{
++		"720P-60", 1280, 720, 60, 1, 0, 362, 1280, 1, 26, 746, 0,
++		0, 0, 750, 0, 0, 1, V4L2_STD_720P_60, 74250000
++	},
++	{
++		"720P-50", 1280, 720, 50, 1, 0, 692, 1280, 1, 26, 746, 0,
++		0, 0, 750, 0, 0, 1, V4L2_STD_720P_50, 74250000
++	},
++	{
++		"1080I-30", 1920, 1080, 30, 0, 0, 272, 1920, 1, 21, 561, 564,
++		584, 1124, 1125, 0, 0, 1, V4L2_STD_1080I_60, 74250000
++	},
++	{
++		"1080I-25", 1920, 1080, 25, 0, 0, 712, 1920, 1, 21, 561, 564,
++		584, 1124, 1125, 0, 0, 1, V4L2_STD_1080I_50, 74250000
+ 	},
++	{
++		"480P-60", 720, 480, 60, 1, 0, 130, 720, 1, 43, 525,
++		0, 0, 0, 525, 0, 0, 0, V4L2_STD_525P_60, 27000000
++	},
++	{
++		"576P-50", 720, 576, 50, 1, 0, 136, 720, 1, 45, 621,
++		0, 0, 0, 625, 0, 0, 0, V4L2_STD_625P_50, 27000000
++	}
+ };
+ 
+ /*
+@@ -146,6 +179,7 @@ static int vpif_buffer_prepare(struct vi
+ 	struct vpif_fh *fh = q->priv_data;
+ 	struct common_obj *common;
+ 	unsigned long addr;
++	int ret;
+ 
+ 	common = &fh->channel->common[VPIF_VIDEO_INDEX];
+ 	if (VIDEOBUF_NEEDS_INIT == vb->state) {
+@@ -153,29 +187,21 @@ static int vpif_buffer_prepare(struct vi
+ 		vb->height	= common->height;
+ 		vb->size	= vb->width * vb->height;
+ 		vb->field	= field;
+-	}
+-	vb->state = VIDEOBUF_PREPARED;
+ 
+-	/* if user pointer memory mechanism is used, get the physical
+-	 * address of the buffer */
+-	if (V4L2_MEMORY_USERPTR == common->memory) {
+-		if (!vb->baddr) {
+-			vpif_err("buffer_address is 0\n");
+-			return -EINVAL;
+-		}
+-
+-		vb->boff = vpif_uservirt_to_phys(vb->baddr);
+-		if (!ISALIGNED(vb->boff))
++		ret = videobuf_iolock(q, vb, NULL);
++		if (ret < 0)
+ 			goto buf_align_exit;
+-	}
+ 
+-	addr = vb->boff;
+-	if (q->streaming && (V4L2_BUF_TYPE_SLICED_VBI_OUTPUT != q->type)) {
+-		if (!ISALIGNED(addr + common->ytop_off) ||
+-		    !ISALIGNED(addr + common->ybtm_off) ||
+-		    !ISALIGNED(addr + common->ctop_off) ||
+-		    !ISALIGNED(addr + common->cbtm_off))
+-			goto buf_align_exit;
++		addr = videobuf_to_dma_contig(vb);
++		if (q->streaming &&
++			(V4L2_BUF_TYPE_SLICED_VBI_OUTPUT != q->type)) {
++			if (!ISALIGNED(addr + common->ytop_off) ||
++			    !ISALIGNED(addr + common->ybtm_off) ||
++			    !ISALIGNED(addr + common->ctop_off) ||
++			    !ISALIGNED(addr + common->cbtm_off))
++				goto buf_align_exit;
++		}
++		vb->state = VIDEOBUF_PREPARED;
+ 	}
+ 	return 0;
+ 
+@@ -234,7 +260,9 @@ static void vpif_buffer_release(struct v
+ 
+ 	common = &ch->common[VPIF_VIDEO_INDEX];
+ 
+-	videobuf_dma_contig_free(q, vb);
++	if (V4L2_MEMORY_USERPTR != vb->memory)
++		videobuf_dma_contig_free(q, vb);
++
+ 	vb->state = VIDEOBUF_NEEDS_INIT;
+ 
+ 	if (V4L2_MEMORY_MMAP != common->memory)
+@@ -490,7 +518,7 @@ static void vpif_config_format(struct ch
+ 
+ 	common->fmt.fmt.pix.sizeimage =
+ 			config_params.channel_bufsize[ch->channel_id];
+-	common->fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_YUV422P;
++	common->fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_NV16;
+ 	common->fmt.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+ }
+ 
+@@ -501,7 +529,7 @@ static int vpif_check_format(struct chan
+ 	enum v4l2_field field = pixfmt->field;
+ 	u32 sizeimage, hpitch, vpitch;
+ 
+-	if (pixfmt->pixelformat != V4L2_PIX_FMT_YUV422P)
++	if (pixfmt->pixelformat != V4L2_PIX_FMT_NV16)
+ 		goto invalid_fmt_exit;
+ 
+ 	if (!(VPIF_VALID_FIELD(field)))
+@@ -705,7 +733,7 @@ static int vpif_enum_fmt_vid_out(struct
+ 	/* Fill in the information about format */
+ 	fmt->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+ 	strcpy(fmt->description, "YCbCr4:2:2 YC Planar");
+-	fmt->pixelformat = V4L2_PIX_FMT_YUV422P;
++	fmt->pixelformat = V4L2_PIX_FMT_NV16;
+ 
+ 	return 0;
+ }
+@@ -727,6 +755,7 @@ static int vpif_g_fmt_vid_out(struct fil
+ 
+ 	if (vpif_get_std_info(ch)) {
+ 		vpif_err("Error getting the standard info\n");
++		mutex_unlock(&common->lock);
+ 		return -EINVAL;
+ 	}
+ 
+@@ -828,7 +857,8 @@ static int vpif_reqbufs(struct file *fil
+ 	if (mutex_lock_interruptible(&common->lock))
+ 		return -ERESTARTSYS;
+ 
+-	if (common->fmt.type != reqbuf->type) {
++	if ((common->fmt.type != reqbuf->type) ||
++	    (NULL == vpif_dev)) {
+ 		ret = -EINVAL;
+ 		goto reqbuf_exit;
+ 	}
+@@ -849,7 +879,7 @@ static int vpif_reqbufs(struct file *fil
+ 
+ 	/* Initialize videobuf queue as per the buffer type */
+ 	videobuf_queue_dma_contig_init(&common->buffer_queue,
+-					    &video_qops, NULL,
++					    &video_qops, vpif_dev,
+ 					    &common->irqlock,
+ 					    reqbuf->type, field,
+ 					    sizeof(struct videobuf_buffer), fh);
+@@ -886,16 +916,22 @@ static int vpif_querybuf(struct file *fi
+ static int vpif_qbuf(struct file *file, void *priv, struct v4l2_buffer *buf)
+ {
+ 
+-	struct vpif_fh *fh = priv;
+-	struct channel_obj *ch = fh->channel;
+-	struct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];
+-	struct v4l2_buffer tbuf = *buf;
+-	struct videobuf_buffer *buf1;
+-	unsigned long addr = 0;
+-	unsigned long flags;
+-	int ret = 0;
++	struct vpif_fh *fh = NULL;
++	struct channel_obj *ch = NULL;
++	struct common_obj *common = NULL;
+ 
+-	if (common->fmt.type != tbuf.type)
++	if ((NULL == buf) || (NULL == priv))
++		return -EINVAL;
++
++	fh = priv;
++	ch = fh->channel;
++
++	if (NULL == ch)
++		return -EINVAL;
++
++	common = &(ch->common[VPIF_VIDEO_INDEX]);
++
++	if (common->fmt.type != buf->type)
+ 		return -EINVAL;
+ 
+ 	if (!fh->io_allowed[VPIF_VIDEO_INDEX]) {
+@@ -903,72 +939,7 @@ static int vpif_qbuf(struct file *file,
+ 		return -EACCES;
+ 	}
+ 
+-	if (!(list_empty(&common->dma_queue)) ||
+-	    (common->cur_frm != common->next_frm) ||
+-	    !(common->started) ||
+-	    (common->started && (0 == ch->field_id)))
+-		return videobuf_qbuf(&common->buffer_queue, buf);
+-
+-	/* bufferqueue is empty store buffer address in VPIF registers */
+-	mutex_lock(&common->buffer_queue.vb_lock);
+-	buf1 = common->buffer_queue.bufs[tbuf.index];
+-	if (buf1->memory != tbuf.memory) {
+-		vpif_err("invalid buffer type\n");
+-		goto qbuf_exit;
+-	}
+-
+-	if ((buf1->state == VIDEOBUF_QUEUED) ||
+-	    (buf1->state == VIDEOBUF_ACTIVE)) {
+-		vpif_err("invalid state\n");
+-		goto qbuf_exit;
+-	}
+-
+-	switch (buf1->memory) {
+-	case V4L2_MEMORY_MMAP:
+-		if (buf1->baddr == 0)
+-			goto qbuf_exit;
+-		break;
+-
+-	case V4L2_MEMORY_USERPTR:
+-		if (tbuf.length < buf1->bsize)
+-			goto qbuf_exit;
+-
+-		if ((VIDEOBUF_NEEDS_INIT != buf1->state)
+-			    && (buf1->baddr != tbuf.m.userptr))
+-			vpif_buffer_release(&common->buffer_queue, buf1);
+-			buf1->baddr = tbuf.m.userptr;
+-		break;
+-
+-	default:
+-		goto qbuf_exit;
+-	}
+-
+-	local_irq_save(flags);
+-	ret = vpif_buffer_prepare(&common->buffer_queue, buf1,
+-					common->buffer_queue.field);
+-	if (ret < 0) {
+-		local_irq_restore(flags);
+-		goto qbuf_exit;
+-	}
+-
+-	buf1->state = VIDEOBUF_ACTIVE;
+-	addr = buf1->boff;
+-	common->next_frm = buf1;
+-	if (tbuf.type != V4L2_BUF_TYPE_SLICED_VBI_OUTPUT) {
+-		common->set_addr((addr + common->ytop_off),
+-				 (addr + common->ybtm_off),
+-				 (addr + common->ctop_off),
+-				 (addr + common->cbtm_off));
+-	}
+-
+-	local_irq_restore(flags);
+-	list_add_tail(&buf1->stream, &common->buffer_queue.stream);
+-	mutex_unlock(&common->buffer_queue.vb_lock);
+-	return 0;
+-
+-qbuf_exit:
+-	mutex_unlock(&common->buffer_queue.vb_lock);
+-	return -EINVAL;
++	return videobuf_qbuf(&common->buffer_queue, buf);
+ }
+ 
+ static int vpif_s_std(struct file *file, void *priv, v4l2_std_id *std_id)
+@@ -977,6 +948,7 @@ static int vpif_s_std(struct file *file,
+ 	struct channel_obj *ch = fh->channel;
+ 	struct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];
+ 	int ret = 0;
++	struct v4l2_subdev *sd = NULL;
+ 
+ 	if (!(*std_id & DM646X_V4L2_STD))
+ 		return -EINVAL;
+@@ -994,32 +966,39 @@ static int vpif_s_std(struct file *file,
+ 	/* Get the information about the standard */
+ 	if (vpif_get_std_info(ch)) {
+ 		vpif_err("Error getting the standard info\n");
++		mutex_unlock(&common->lock);
+ 		return -EINVAL;
+ 	}
+ 
+-	if ((ch->vpifparams.std_info.width *
+-		ch->vpifparams.std_info.height * 2) >
+-		config_params.channel_bufsize[ch->channel_id]) {
+-		vpif_err("invalid std for this size\n");
+-		ret = -EINVAL;
+-		goto s_std_exit;
++	vpif_dbg(1, debug, "Setting Video Ops\n");
++	list_for_each_entry(sd, &(&(vpif_obj.v4l2_dev))->subdevs, list) {
++		vpif_dbg(1, debug, "SubDev Name %s\n", sd->name);
++		if (sd->ops->video && sd->ops->video->s_std_output)
++			ret = sd->ops->video->s_std_output(sd , *std_id);
++		if (ret && ret != -ENOIOCTLCMD)
++			break;
+ 	}
+-
+-	common->fmt.fmt.pix.bytesperline = common->fmt.fmt.pix.width;
+-	/* Configure the default format information */
+-	vpif_config_format(ch);
+-
+-	ret = v4l2_device_call_until_err(&vpif_obj.v4l2_dev, 1, video,
+-						s_std_output, *std_id);
+ 	if (ret < 0) {
+ 		vpif_err("Failed to set output standard\n");
+ 		goto s_std_exit;
+ 	}
+ 
+-	ret = v4l2_device_call_until_err(&vpif_obj.v4l2_dev, 1, core,
+-							s_std, *std_id);
+-	if (ret < 0)
++	vpif_dbg(1, debug, "Setting Core Ops\n");
++	list_for_each_entry(sd, &(&(vpif_obj.v4l2_dev))->subdevs, list) {
++		vpif_dbg(1, debug, "SubDev Name %s\n", sd->name);
++		if (sd->ops->core && sd->ops->core->s_std)
++			ret = sd->ops->core->s_std(sd , *std_id);
++		if (ret && ret != -ENOIOCTLCMD)
++			break;
++	}
++
++	if (ret < 0) {
+ 		vpif_err("Failed to set standard for sub devices\n");
++	} else {
++		common->fmt.fmt.pix.bytesperline = common->fmt.fmt.pix.width;
++		/* Configure the default format information */
++		vpif_config_format(ch);
++	}
+ 
+ s_std_exit:
+ 	mutex_unlock(&common->lock);
+@@ -1055,6 +1034,7 @@ static int vpif_streamon(struct file *fi
+ 	struct vpif_params *vpif = &ch->vpifparams;
+ 	struct vpif_display_config *vpif_config_data =
+ 					vpif_dev->platform_data;
++	int sizeimage;
+ 	unsigned long addr = 0;
+ 	int ret = 0;
+ 
+@@ -1104,6 +1084,20 @@ static int vpif_streamon(struct file *fi
+ 		goto streamon_exit;
+ 	}
+ 
++	if (common->memory == V4L2_MEMORY_MMAP)
++		sizeimage = config_params.channel_bufsize[ch->channel_id];
++	else
++		sizeimage = common->fmt.fmt.pix.sizeimage;
++
++	if ((ch->vpifparams.std_info.width *
++		ch->vpifparams.std_info.height * 2) >
++			sizeimage) {
++		vpif_err("invalid std for this size\n");
++		ret = -EINVAL;
++		goto streamon_exit;
++	}
++
++
+ 	/* Get the next frame from the buffer queue */
+ 	common->next_frm = common->cur_frm =
+ 			    list_entry(common->dma_queue.next,
+@@ -1117,7 +1111,7 @@ static int vpif_streamon(struct file *fi
+ 	ch->field_id = 0;
+ 	common->started = 1;
+ 	if (buftype == V4L2_BUF_TYPE_VIDEO_OUTPUT) {
+-		addr = common->cur_frm->boff;
++		addr = videobuf_to_dma_contig(common->cur_frm);
+ 		/* Calculate the offset for Y and C data  in the buffer */
+ 		vpif_calculate_offsets(ch);
+ 
+@@ -1140,6 +1134,9 @@ static int vpif_streamon(struct file *fi
+ 			goto streamon_exit;
+ 		}
+ 
++		/* Settting pixel clock */
++		clk_set_rate(vpif_obj.vpif_clk, vpif->std_info.clk_rate);
++
+ 		/* set the parameters and addresses */
+ 		ret = vpif_set_video_params(vpif, ch->channel_id + 2);
+ 		if (ret < 0)
+@@ -1161,7 +1158,7 @@ static int vpif_streamon(struct file *fi
+ 		}
+ 
+ 		if ((VPIF_CHANNEL3_VIDEO == ch->channel_id)
+-			|| (common->started == 2)) {
++			|| (0 == ch->vpifparams.std_info.ycmux_mode)) {
+ 			channel3_intr_assert();
+ 			channel3_intr_enable(1);
+ 			enable_channel3(1);
+@@ -1259,6 +1256,7 @@ static int vpif_s_output(struct file *fi
+ 	struct channel_obj *ch = fh->channel;
+ 	struct video_obj *vid_ch = &ch->video;
+ 	struct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];
++	struct v4l2_subdev *sd = NULL;
+ 	int ret = 0;
+ 
+ 	if (mutex_lock_interruptible(&common->lock))
+@@ -1270,8 +1268,13 @@ static int vpif_s_output(struct file *fi
+ 		goto s_output_exit;
+ 	}
+ 
+-	ret = v4l2_device_call_until_err(&vpif_obj.v4l2_dev, 1, video,
+-							s_routing, 0, i, 0);
++	list_for_each_entry(sd, &(&(vpif_obj.v4l2_dev))->subdevs, list) {
++		vpif_dbg(1, debug, "SubDev Name %s\n", sd->name);
++		if (sd->ops->video && sd->ops->video->s_routing)
++			ret = sd->ops->video->s_routing(sd , 0, i, 0);
++		if (ret && ret != -ENOIOCTLCMD)
++			break;
++	}
+ 
+ 	if (ret < 0)
+ 		vpif_err("Failed to set output standard\n");
+@@ -1449,16 +1452,19 @@ static __init int vpif_probe(struct plat
+ 
+ 	k = 0;
+ 	while ((res = platform_get_resource(pdev, IORESOURCE_IRQ, k))) {
+-		for (i = res->start; i <= res->end; i++) {
+-			if (request_irq(i, vpif_channel_isr, IRQF_DISABLED,
++		/* Since the irq is single there is no need to
++		   run a for loop */
++		if (request_irq(res->start, vpif_channel_isr, IRQF_DISABLED,
+ 					"DM646x_Display",
+ 				(void *)(&vpif_obj.dev[k]->channel_id))) {
+-				err = -EBUSY;
+-				goto vpif_int_err;
+-			}
++			err = -EBUSY;
++			res_end = k;
++			goto vpif_int_err;
+ 		}
++
+ 		k++;
+ 	}
++	res_end = k;
+ 
+ 	for (i = 0; i < VPIF_DISPLAY_MAX_DEVICES; i++) {
+ 
+@@ -1556,6 +1562,7 @@ static __init int vpif_probe(struct plat
+ 						NULL);
+ 		if (!vpif_obj.sd[i]) {
+ 			vpif_err("Error registering v4l2 subdevice\n");
++			err = -ENODEV;
+ 			goto probe_subdev_out;
+ 		}
+ 
+@@ -1563,6 +1570,12 @@ static __init int vpif_probe(struct plat
+ 			vpif_obj.sd[i]->grp_id = 1 << i;
+ 	}
+ 
++	vpif_obj.vpif_clk = clk_get(NULL, "cdce_vpif");
++	if (NULL == vpif_obj.vpif_clk) {
++		vpif_err("Error getting clock\n");
++		err = -EINVAL;
++		goto probe_subdev_out;
++	}
+ 	return 0;
+ 
+ probe_subdev_out:
+@@ -1571,17 +1584,19 @@ probe_out:
+ 	for (k = 0; k < j; k++) {
+ 		ch = vpif_obj.dev[k];
+ 		video_unregister_device(ch->video_dev);
+-		video_device_release(ch->video_dev);
++		if (ch->video_dev->minor == -1)
++			video_device_release(ch->video_dev);
+ 		ch->video_dev = NULL;
+ 	}
+ vpif_int_err:
+ 	v4l2_device_unregister(&vpif_obj.v4l2_dev);
+ 	vpif_err("VPIF IRQ request failed\n");
+-	for (q = k; k >= 0; k--) {
+-		for (m = i; m >= res->start; m--)
+-			free_irq(m, (void *)(&vpif_obj.dev[k]->channel_id));
+-		res = platform_get_resource(pdev, IORESOURCE_IRQ, k-1);
+-		m = res->end;
++	for (q = 0; q < res_end; q++) {
++		res = platform_get_resource(pdev, IORESOURCE_IRQ, q);
++		if (NULL != res) {
++			free_irq(res->start,
++					(void *)(&vpif_obj.dev[q]->channel_id));
++		}
+ 	}
+ 
+ 	return err;
+--- /dev/null
++++ b/arch/arm/mach-davinci/pci-dm646x.c
+@@ -0,0 +1,139 @@
++/*
++ * pci-dm646x.c
++ *  Description:
++ *  DM6467 (and in some parts, EVM) specific PCI initialization.
++ *
++ * Copyright (C) 2009 Texas Instruments Incorporated - http://www.ti.com/
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License as
++ * published by the Free Software Foundation version 2.
++ *
++ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
++ * kind, whether express or implied; without even the implied warranty
++ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ */
++
++#undef DEBUG
++
++#include <linux/kernel.h>       /* pr_ wrappers */
++#include <linux/pci.h>		/* PCI data structures */
++#include <asm/mach/pci.h>	/* hw_pci */
++#include <linux/types.h>
++
++#include "pci.h"		/* Platform spec */
++
++#include <mach/cputype.h>
++#include <mach/dm646x.h>	/* SoC reg  defs, __REG, IO info etc */
++#include <linux/clk.h>		/* For clk_enable interface */
++
++/* NOTE:
++ * Most of the code in this file assumes that it is runnig as PCI Host and
++ * configures the system accordingly. The only place where it is checked if we
++ * are booted through PCI Boot, is the function dm646x_pci_init (below) before
++ * it registers with the bios. Thus, if we were not hosting the PCI bus the
++ * other functions wouldn;t get called anyway as the pci bios will not be
++ * invoked.
++ */
++
++/* Forward declarations */
++static void __init dm646x_pci_preinit(void);
++static int __init dm646x_pci_map_irq(struct pci_dev *dev, u8 slot, u8 pin);
++
++/* Specify the physical address and size information for Host windows to be
++ * configured in BAR0-5 registers. Note that _ALL_ of the 6 entries must be
++ * filled. For entries with no real window to be mapped, set bar_window_size=0.
++ */
++struct pcihost_bar_cfg bar_cfg[6] = {
++	{ PHYS_OFFSET /* bar_window_phys */ , 0x8000000 /* bar_window_size */},
++	{ 0                                 , 0                              },
++	{ 0                                 , 0                              },
++	{ 0                                 , 0                              },
++	{ 0                                 , 0                              },
++	{ 0                                 , 0                              }
++};
++
++/* Plug into Linux PCI BIOS Interface */
++static struct hw_pci davinci_pci __initdata = {
++	.nr_controllers     = 1,
++	.setup              = ti_pci_setup,
++	.scan               = ti_pci_scan,
++	.preinit            = dm646x_pci_preinit,
++	.postinit           = NULL,
++	.swizzle            = pci_std_swizzle,       /* Using default Linux
++							ARM-BIOS algorithm */
++	.map_irq            = dm646x_pci_map_irq
++};
++
++/* dm646x_pci_preinit
++ *  This function handles initializations to do before accessing PCI bus. This
++ *  function is optional and most of the things done here could be handled in
++ *  board/SoC level init.
++ */
++void dm646x_pci_preinit(void)
++{
++	/*
++	 * Use clk_enable interface to do the PSC init as well as take care of
++	 * pin muxing for PCI  module domain
++	 */
++	struct clk *pci_clk;
++
++	pr_info("PCI: Enabling Clock...\n");
++	pci_clk = clk_get(NULL, "pci");
++	if (IS_ERR(pci_clk))
++		return;
++
++	clk_enable(pci_clk);
++
++	/* At tis point, we assume here that the board level code has taken care
++	 * of driving RST# over PCI Bus (or, if not, then already taken care in
++	 * H/W - this is default behavior of the EVM)
++	 */
++}
++
++int dm646x_pci_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
++{
++	/*
++	 * Standard EVM doesn't have any dedicated lines connected to PCI
++	 * Interrupts.
++	 */
++
++	return -1;
++}
++
++/* dm646x_pci_init
++ *  PCI system initialization. Fills in required information for PCI BIOS to
++ *  perrform enumeratios and invokes pci_common_init.
++ */
++static int __init dm646x_pci_init(void)
++{
++	if (cpu_is_davinci_dm646x()) {
++		/* Since DM646x can act either as PCI host or target, we skip
++		 * setting up PCI BIOS for enumeration if we are 'target'.
++		 * This is determined by checking BOOTCFG BOOTMODE[0:3] and
++		 * PCIEN values.
++		 * Note : BOOTCFG values are latched across soft resets and thus
++		 * the check below cannot detect any change in actual boot mode.
++		 */
++		u32 bootcfg = __raw_readl(
++				(IO_ADDRESS(DAVINCI_SYSTEM_MODULE_BASE)
++				 + BOOTCFG));
++		u32 bootmode = bootcfg & 0xf;
++
++		pr_info("PCI: bootcfg = %#x, bootmode = %#x\n",
++			bootcfg, bootmode);
++
++		if (!((bootcfg & BIT(16))
++			&& ((bootmode == 2) || (bootmode == 3)))) {
++			pr_info("PCI: Invoking PCI BIOS...\n");
++			pci_common_init(&davinci_pci);
++		} else {
++			pr_info("PCI: Skipping PCI Host setup...\n");
++		}
++	}
++
++	return 0;
++}
++
++subsys_initcall(dm646x_pci_init);
+--- /dev/null
++++ b/drivers/media/video/davinci/davinci_platform.c
+@@ -0,0 +1,1281 @@
++/*
++ * Copyright (C) 2009 Texas Instruments Inc
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
++ */
++
++#include <linux/kernel.h>
++#include <linux/init.h>
++#include <linux/ctype.h>
++#include <linux/delay.h>
++#include <linux/device.h>
++#include <linux/attribute_container.h>
++#include <linux/platform_device.h>
++#include <mach/hardware.h>
++#include <mach/mux.h>
++#include <mach/cputype.h>
++#include <mach/io.h>
++#include <mach/i2c.h>
++#include <asm/io.h>
++#include <media/davinci/davinci_enc.h>
++#include <media/davinci/vid_encoder_types.h>
++#include <video/davinci_vpbe.h>
++#include <video/davinci_osd.h>
++#include <media/davinci/davinci_enc_mngr.h>
++#include <media/davinci/davinci_platform.h>
++#include "../ths7303.h"
++
++#define MSP430_I2C_ADDR		(0x25)
++#define PCA9543A_I2C_ADDR	(0x73)
++#define THS7303			0
++#define THS7303_I2C_ADDR	(0x2C)
++#define THS7353_I2C_ADDR	(0x2E)
++#define THS7353			1
++#define THS73XX_CHANNEL_1	1
++#define THS73XX_CHANNEL_2	2
++#define THS73XX_CHANNEL_3	3
++#define DM365_CPLD_REGISTER3	(0x04000018)
++#define DM365_TVP7002_SEL	(0x1)
++#define DM365_SENSOR_SEL	(0x2)
++#define DM365_TVP5146_SEL	(0x5)
++#define DM365_VIDEO_MUX_MASK	(0x7)
++#define DM644X_DDR2_CNTL_BASE	(0x20000000)
++
++struct davinci_venc_state {
++	spinlock_t lock;
++	struct device *vdev;
++	dma_addr_t venc_base_phys;
++	unsigned long venc_base;
++	unsigned long venc_size;
++};
++
++static struct davinci_venc_state venc_state;
++static struct davinci_venc_state *venc = &venc_state;
++
++enum ths73xx_filter_mode {
++	THS_FILTER_MODE_480I,
++	THS_FILTER_MODE_576I,
++	THS_FILTER_MODE_480P,
++	THS_FILTER_MODE_576P,
++	THS_FILTER_MODE_720P,
++	THS_FILTER_MODE_1080I,
++	THS_FILTER_MODE_1080P
++};
++
++extern struct vid_enc_device_mgr enc_dev[];
++
++struct enc_config davinci_enc_default[DAVINCI_ENC_MAX_CHANNELS] = {
++	{VID_ENC_OUTPUT_COMPOSITE,
++	 VID_ENC_STD_NTSC}
++};
++
++EXPORT_SYMBOL(davinci_enc_default);
++
++char *davinci_outputs[] = {
++	VID_ENC_OUTPUT_COMPOSITE,
++	VID_ENC_OUTPUT_COMPOSITE1,
++	VID_ENC_OUTPUT_SVIDEO,
++	VID_ENC_OUTPUT_SVIDEO1,
++	VID_ENC_OUTPUT_COMPONENT,
++	VID_ENC_OUTPUT_COMPONENT1,
++	VID_ENC_OUTPUT_LCD,
++	VID_ENC_OUTPUT_LCD1,
++	""
++};
++
++EXPORT_SYMBOL(davinci_outputs);
++
++char *davinci_modes[] = {
++	VID_ENC_STD_NTSC,
++	"ntsc",
++	VID_ENC_STD_NTSC_RGB,
++	VID_ENC_STD_PAL,
++	"pal",
++	VID_ENC_STD_PAL_RGB,
++	VID_ENC_STD_720P_24,
++	VID_ENC_STD_720P_25,
++	VID_ENC_STD_720P_30,
++	VID_ENC_STD_720P_50,
++	VID_ENC_STD_720P_60,
++	VID_ENC_STD_1080I_25,
++	VID_ENC_STD_1080I_30,
++	VID_ENC_STD_1080P_25,
++	VID_ENC_STD_1080P_30,
++	VID_ENC_STD_1080P_50,
++	VID_ENC_STD_1080P_60,
++	VID_ENC_STD_480P_60,
++	VID_ENC_STD_576P_50,
++	VID_ENC_STD_640x480,
++	VID_ENC_STD_640x400,
++	VID_ENC_STD_640x350,
++	VID_ENC_STD_800x480,
++	""
++};
++
++EXPORT_SYMBOL(davinci_modes);
++
++static __inline__ u32 dispc_reg_in(u32 offset)
++{
++	return (__raw_readl(venc->venc_base + offset));
++}
++
++static __inline__ u32 dispc_reg_out(u32 offset, u32 val)
++{
++	__raw_writel(val, (venc->venc_base + offset));
++
++	return (val);
++}
++
++static __inline__ u32 dispc_reg_merge(u32 offset, u32 val, u32 mask)
++{
++	u32 addr, new_val;
++
++	addr = venc->venc_base + offset;
++
++	new_val = (__raw_readl(addr) & ~mask) | (val & mask);
++	__raw_writel(new_val, addr);
++	return (new_val);
++}
++
++u32 venc_reg_in(u32 offset)
++{
++	return (__raw_readl(venc->venc_base + offset));
++}
++EXPORT_SYMBOL(venc_reg_in);
++
++u32 venc_reg_out(u32 offset, u32 val)
++{
++	__raw_writel(val, (venc->venc_base + offset));
++
++	return (val);
++}
++EXPORT_SYMBOL(venc_reg_out);
++
++u32 venc_reg_merge(u32 offset, u32 val, u32 mask)
++{
++	u32 addr, new_val;
++
++	addr = venc->venc_base + offset;
++
++	new_val = (__raw_readl(addr) & ~mask) | (val & mask);
++	__raw_writel(new_val, addr);
++	return (new_val);
++}
++EXPORT_SYMBOL(venc_reg_merge);
++
++static void __iomem *display_cntl_base;
++
++static DEFINE_SPINLOCK(reg_access_lock);
++static void davinci_enc_set_basep(int channel, unsigned basepx, unsigned basepy)
++{
++	spin_lock(&reg_access_lock);
++
++	osd_write_left_margin(basepx & OSD_BASEPX_BPX);
++	osd_write_upper_margin(basepy & OSD_BASEPY_BPY);
++	
++	spin_unlock(&reg_access_lock);
++}
++
++static void davinci_enc_get_basep(int channel, unsigned *basepx,
++				  unsigned *basepy)
++{
++	spin_lock(&reg_access_lock);
++
++	*basepx = (OSD_BASEPX_BPX & osd_read_left_margin());
++	*basepy = (OSD_BASEPY_BPY & osd_read_upper_margin());
++
++	spin_unlock(&reg_access_lock);
++}
++
++struct system_device {
++	struct module *owner;
++	struct device class_dev;
++};
++
++static struct system_device *davinci_system_device;
++
++#define to_system_dev(cdev)	container_of(cdev, \
++ struct system_device, class_dev)
++
++static void davinci_system_class_release(struct device *cdev)
++{
++	struct system_device *dev = to_system_dev(cdev);
++
++	if (dev != NULL)
++		kfree(dev);
++}
++
++struct class davinci_system_class = {
++	.name = "davinci_system",
++	.owner	= THIS_MODULE,
++	.dev_release = davinci_system_class_release,
++};
++
++static ssize_t
++reg_store(struct device *cdev, struct device_attribute *attr, const char *buffer, size_t count)
++{
++	char *str = 0;
++	char *bufv = 0;
++	int addr = 0;
++	int val = 0;
++	int len = 0;
++
++	if (!buffer || (count == 0) || (count >= 128))
++		return 0;
++
++	str = kmalloc(128, GFP_KERNEL);
++	if (0 == str)
++		return -ENOMEM;
++
++	strcpy(str, buffer);
++	/* overwrite the '\n' */
++	strcpy(str + count - 1, "\0");
++
++	/* format: <address> [<value>]
++	   if only <address> present, it is a read
++	   if <address> <value>, then it is a write */
++	len = strcspn(str, " ");
++	addr = simple_strtoul(str, NULL, 16);
++
++	if (len != count - 1) {
++		bufv = str;
++		strsep(&bufv, " ");
++		val = simple_strtoul(bufv, NULL, 16);
++	}
++
++	kfree(str);
++
++	/* for now, restrict this to access DDR2 controller
++	   Peripheral Bust Burst Priority Register PBBPR
++	   (addr: 0x20000020) only */
++	if (addr != (DM644X_DDR2_CNTL_BASE + 0x20))
++		return -EINVAL;
++
++	spin_lock(&reg_access_lock);
++	if (bufv != 0)
++		writel(val, display_cntl_base + addr - DM644X_DDR2_CNTL_BASE);
++	printk(KERN_NOTICE "%05x  %08x\n", addr,
++	       readl(display_cntl_base + addr - DM644X_DDR2_CNTL_BASE));
++	spin_unlock(&reg_access_lock);
++
++	return count;
++}
++
++static ssize_t reg_show(struct device *cdev, struct device_attribute *attr, char *buf)
++{
++	return 0;
++}
++
++static ssize_t osd_basepx_show(struct device *cdev, struct device_attribute *attr, char *buf)
++{
++	unsigned int basepx, basepy;
++	int p;
++
++	davinci_enc_get_basep(0, &basepx, &basepy);
++	p = sprintf(buf, "%d\n", basepx);
++	return p;
++}
++
++static ssize_t osd_basepx_store(struct device *cdev, struct device_attribute *attr, const char *buffer,
++				size_t count)
++{
++	unsigned int basepx, basepy;
++	char reg_val[10];
++
++	if (count >= 9) {
++		strncpy(reg_val, buffer, 9);
++		reg_val[9] = '\0';
++	} else {
++		/* overwrite the '\n' */
++		strcpy(reg_val, buffer);
++		strcpy(reg_val + count - 1, "\0");
++	}
++	davinci_enc_get_basep(0, &basepx, &basepy);
++	basepx = simple_strtoul(reg_val, NULL, 10);
++
++	if (basepx > OSD_BASEPX_BPX) {
++		printk(KERN_ERR "Invalid value for OSD basepx\n");
++		return count;
++	}
++	davinci_enc_set_basep(0, basepx, basepy);
++	return count;
++}
++
++static ssize_t osd_basepy_show(struct device *cdev, struct device_attribute *attr, char *buf)
++{
++	unsigned int basepx, basepy;
++	int p;
++
++	davinci_enc_get_basep(0, &basepx, &basepy);
++	p = sprintf(buf, "%d\n", basepy);
++	return p;
++}
++
++static ssize_t osd_basepy_store(struct device *cdev, struct device_attribute *attr, const char *buffer,
++				size_t count)
++{
++	unsigned int basepx, basepy;
++	char reg_val[10];
++
++	if (count >= 9) {
++		strncpy(reg_val, buffer, 9);
++		reg_val[9] = '\0';
++	} else {
++		/* overwrite the '\n' */
++		strcpy(reg_val, buffer);
++		strcpy(reg_val + count - 1, "\0");
++	}
++
++	davinci_enc_get_basep(0, &basepx, &basepy);
++	basepy = simple_strtoul(reg_val, NULL, 10);
++	if (basepy > OSD_BASEPY_BPY) {
++		printk(KERN_ERR "Invalid value for OSD basepy\n");
++		return count;
++	}
++	davinci_enc_set_basep(0, basepx, basepy);
++	return count;
++}
++
++#define DECLARE_ATTR(_name, _mode, _show, _store) {		\
++	.attr   = { .name = __stringify(_name), .mode = _mode,	\
++		    .owner = THIS_MODULE },  			\
++	.show   = _show,                                        \
++	.store  = _store,}
++
++static struct device_attribute system_device_attributes[] = {
++	DECLARE_ATTR(reg, S_IRWXUGO, reg_show, reg_store),
++	DECLARE_ATTR(vpbe_osd_basepx, S_IRWXUGO, osd_basepx_show,
++		     osd_basepx_store),
++	DECLARE_ATTR(vpbe_osd_basepy, S_IRWXUGO, osd_basepy_show,
++		     osd_basepy_store)
++};
++
++static void *create_sysfs_files(void)
++{
++	struct system_device *dev;
++	int ret;
++	int i;
++
++	dev = kzalloc(sizeof(struct system_device), GFP_KERNEL);
++	if (!dev)
++		return NULL;
++
++	dev->owner = THIS_MODULE;
++	dev->class_dev.class = &davinci_system_class;
++	dev_set_name(&dev->class_dev, "%s", "system");
++//	dev_set_drvdata(&dev->class_dev, dev);
++	ret = device_register(&dev->class_dev);
++	if (ret < 0) {
++		printk(KERN_ERR "DaVinci Platform: Error in device_register\n");
++		kfree(dev);
++		return NULL;
++	}
++
++	for (i = 0; i < ARRAY_SIZE(system_device_attributes); i++) {
++		ret = device_create_file(&dev->class_dev,
++					       &system_device_attributes
++					       [i]);
++		if (ret < 0) {
++			while (--i >= 0)
++				device_remove_file(&dev->class_dev,
++					 &system_device_attributes
++					 [i]);
++			device_unregister(&dev->class_dev);
++			printk(KERN_ERR "Error in device_create_file\n");
++			return NULL;
++		}
++	}
++
++	return dev;
++}
++
++static void remove_sysfs_files(struct system_device *dev)
++{
++	int i;
++
++	for (i = 0; i < ARRAY_SIZE(system_device_attributes); i++)
++		device_remove_file(&dev->class_dev,
++					 &system_device_attributes[i]);
++
++	device_unregister(&dev->class_dev);
++}
++
++/**
++ * function davinci_enc_select_venc_clk
++ * @clk_source: clock source defined by davinci_enc_clk_source_type
++ * Returns: Zero if successful, or non-zero otherwise
++ *
++ * Description:
++ *  Select the venc input clock based on the clk_source_type.
++ */
++int davinci_enc_select_venc_clock(int clk)
++{
++	return 0;
++}
++
++EXPORT_SYMBOL(davinci_enc_select_venc_clock);
++
++/* TODO */
++#if 0
++/* function to configure THS7303 filter */
++static int tvp73xx_setup_channel(u8 device, enum ths73xx_filter_mode mode)
++{
++	u8 val[2];
++	u8 input_bias_luma = 2, input_bias_chroma = 2, temp;
++	u8 i2c_addr = THS7303_I2C_ADDR;
++	int err = 0;
++
++	if (device == THS7353) {
++		i2c_addr = THS7353_I2C_ADDR;
++		input_bias_luma = 5;
++		input_bias_chroma = 4;
++	}
++
++	/* setup 7303
++	 * Input Mux A
++	 */
++	val[1] = 0;
++	switch (mode) {
++	case THS_FILTER_MODE_1080P:
++	{
++		/* LPF - 5MHz */
++		val[1] = (3 << 6);
++		/* LPF - bypass */
++		val[1] |= (3 << 3);
++		break;
++	}
++	case THS_FILTER_MODE_1080I:
++	case THS_FILTER_MODE_720P:
++	{
++		/* LPF - 5MHz */
++		val[1] = (2 << 6);
++		/* LPF - 35 MHz */
++		val[1] |= (2 << 3);
++		break;
++	}
++	case THS_FILTER_MODE_480P:
++	case THS_FILTER_MODE_576P:
++	{
++		/* LPF - 2.5MHz */
++		val[1] = (1 << 6);
++		/* LPF - 16 MHz */
++		val[1] |= (1 << 3);
++		break;
++	}
++	case THS_FILTER_MODE_480I:
++	case THS_FILTER_MODE_576I:
++	{
++		/* LPF - 500 KHz, LPF - 9 MHz. Do nothing */
++		break;
++	}
++	default:
++		return -1;
++	}
++	/* setup channel2 - Luma - Green */
++	temp = val[1];
++	val[1] |= input_bias_luma;
++	val[0] = THS73XX_CHANNEL_2;
++	err = davinci_i2c_write(2, val, i2c_addr);
++
++	/* setup channel1 chroam - Red */
++	val[1] = temp;
++	val[1] |= input_bias_chroma;
++
++	val[0] = THS73XX_CHANNEL_1;
++	err |= davinci_i2c_write(2, val, i2c_addr);
++
++	val[0] = THS73XX_CHANNEL_3;
++	err |= davinci_i2c_write(2, val, i2c_addr);
++	return 0;
++}
++#endif
++
++static void enableDigitalOutput(int bEnable)
++{
++	if (bEnable) {
++		dispc_reg_out(VENC_VMOD, 0);
++		dispc_reg_out(VENC_CVBS, 0);
++
++		if (cpu_is_davinci_dm644x())
++			__raw_writel(0, IO_ADDRESS(DM644X_VPBE_REG_BASE + VPBE_PCR));
++
++		dispc_reg_out(VENC_LCDOUT, 0);
++		dispc_reg_out(VENC_HSPLS, 0);
++		dispc_reg_out(VENC_HSTART, 0);
++		dispc_reg_out(VENC_HVALID, 0);
++		dispc_reg_out(VENC_HINT, 0);
++		dispc_reg_out(VENC_VSPLS, 0);
++		dispc_reg_out(VENC_VSTART, 0);
++		dispc_reg_out(VENC_VVALID, 0);
++		dispc_reg_out(VENC_VINT, 0);
++		dispc_reg_out(VENC_YCCCTL, 0);
++		dispc_reg_out(VENC_DACSEL, 0);
++
++	} else {
++		/* Initialize the VPSS Clock Control register */
++		__raw_writel(0x18, IO_ADDRESS(SYS_VPSS_CLKCTL));
++		if (cpu_is_davinci_dm644x())
++			__raw_writel(0, IO_ADDRESS(DM644X_VPBE_REG_BASE + VPBE_PCR));
++
++		/* Set PINMUX0 reg to enable LCD (all other settings are kept
++		   per boot)
++		 */
++		if (cpu_is_davinci_dm644x()) {
++			davinci_cfg_reg(DM644X_LOEEN);
++			davinci_cfg_reg(DM644X_LFLDEN);
++		}
++
++		/* disable VCLK output pin enable */
++		dispc_reg_out(VENC_VIDCTL, 0x141);
++
++		/* Disable output sync pins */
++		dispc_reg_out(VENC_SYNCCTL, 0);
++
++		/* Disable DCLOCK */
++		dispc_reg_out(VENC_DCLKCTL, 0);
++		dispc_reg_out(VENC_DRGBX1, 0x0000057C);
++
++		/* Disable LCD output control (accepting default polarity) */
++		dispc_reg_out(VENC_LCDOUT, 0);
++		if (!cpu_is_davinci_dm355())
++			dispc_reg_out(VENC_CMPNT, 0x100);
++		dispc_reg_out(VENC_HSPLS, 0);
++		dispc_reg_out(VENC_HINT, 0);
++		dispc_reg_out(VENC_HSTART, 0);
++		dispc_reg_out(VENC_HVALID, 0);
++
++		dispc_reg_out(VENC_VSPLS, 0);
++		dispc_reg_out(VENC_VINT, 0);
++		dispc_reg_out(VENC_VSTART, 0);
++		dispc_reg_out(VENC_VVALID, 0);
++
++		dispc_reg_out(VENC_HSDLY, 0);
++		dispc_reg_out(VENC_VSDLY, 0);
++
++		dispc_reg_out(VENC_YCCCTL, 0);
++		dispc_reg_out(VENC_VSTARTA, 0);
++
++		/* Set OSD clock and OSD Sync Adavance registers */
++		dispc_reg_out(VENC_OSDCLK0, 1);
++		dispc_reg_out(VENC_OSDCLK1, 2);
++	}
++}
++
++/*
++ * setting NTSC mode
++ */
++
++static void davinci_enc_set_ntsc(struct vid_enc_mode_info *mode_info)
++{
++	enableDigitalOutput(0);
++
++	if (cpu_is_davinci_dm355()) {
++		dispc_reg_out(VENC_CLKCTL, 0x01);
++		dispc_reg_out(VENC_VIDCTL, 0);
++		/* DM 350 Configure VDAC_CONFIG , why ?? */
++		__raw_writel(0x0E21A6B6, IO_ADDRESS(DM3XX_VDAC_CONFIG));
++	} else if (cpu_is_davinci_dm365()) {
++		dispc_reg_out(VENC_CLKCTL, 0x01);
++		dispc_reg_out(VENC_VIDCTL, 0);
++		__raw_writel(0x081141CF, IO_ADDRESS(DM3XX_VDAC_CONFIG));
++	} else {
++		/* to set VENC CLK DIV to 1 - final clock is 54 MHz */
++		dispc_reg_merge(VENC_VIDCTL, 0, 1 << 1);
++		/* Set REC656 Mode */
++		dispc_reg_out(VENC_YCCCTL, 0x1);
++		dispc_reg_merge(VENC_VDPRO, 0, VENC_VDPRO_DAFRQ);
++		dispc_reg_merge(VENC_VDPRO, 0, VENC_VDPRO_DAUPS);
++	}
++
++	osd_write_left_margin(mode_info->left_margin);
++	osd_write_upper_margin(mode_info->upper_margin);
++
++	dispc_reg_merge(VENC_VMOD, VENC_VMOD_VENC, VENC_VMOD_VENC);
++}
++
++/*
++ * setting PAL mode
++ */
++static void davinci_enc_set_pal(struct vid_enc_mode_info *mode_info)
++{
++
++	enableDigitalOutput(0);
++
++	if (cpu_is_davinci_dm355()) {
++		dispc_reg_out(VENC_CLKCTL, 0x1);
++		dispc_reg_out(VENC_VIDCTL, 0);
++		/* DM350 Configure VDAC_CONFIG  */
++		__raw_writel(0x0E21A6B6, IO_ADDRESS(DM3XX_VDAC_CONFIG));
++	} else if (cpu_is_davinci_dm365()) {
++		dispc_reg_out(VENC_CLKCTL, 0x1);
++		dispc_reg_out(VENC_VIDCTL, 0);
++		__raw_writel(0x081141CF, IO_ADDRESS(DM3XX_VDAC_CONFIG));
++	} else {
++		/* to set VENC CLK DIV to 1 - final clock is 54 MHz */
++		dispc_reg_merge(VENC_VIDCTL, 0, 1 << 1);
++		/* Set REC656 Mode */
++		dispc_reg_out(VENC_YCCCTL, 0x1);
++	}
++
++	dispc_reg_merge(VENC_SYNCCTL, 1 << VENC_SYNCCTL_OVD_SHIFT,
++			VENC_SYNCCTL_OVD);
++
++	
++	osd_write_left_margin(mode_info->left_margin);
++	/* PAL display shows shakiness in the OSD0 when
++	 * this is set to upper margin. Need to bump it
++	 * by 2 in the case of DM365
++	 */
++
++	if (cpu_is_davinci_dm365())
++		osd_write_upper_margin(mode_info->upper_margin + 2);
++	else
++		osd_write_upper_margin(mode_info->upper_margin);
++
++	dispc_reg_merge(VENC_VMOD, VENC_VMOD_VENC, VENC_VMOD_VENC);
++	dispc_reg_out(VENC_DACTST, 0x0);
++}
++
++/*
++ * davinci_enc_ntsc_pal_rgb
++ */
++/* This function configures the video encoder to NTSC RGB setting.*/
++static void davinci_enc_set_ntsc_pal_rgb(struct vid_enc_mode_info *mode_info)
++{
++	enableDigitalOutput(0);
++
++	osd_write_left_margin(mode_info->left_margin);
++	osd_write_upper_margin(mode_info->upper_margin);
++}
++
++/*
++ * davinci_enc_set_525p
++ */
++/* This function configures the video encoder to HDTV(525p) component setting.*/
++static void davinci_enc_set_525p(struct vid_enc_mode_info *mode_info)
++{
++	enableDigitalOutput(0);
++	if (cpu_is_davinci_dm365())
++		__raw_writel(0x18, IO_ADDRESS(SYS_VPSS_CLKCTL));
++	else
++		__raw_writel(0x19, IO_ADDRESS(SYS_VPSS_CLKCTL));
++
++	osd_write_left_margin(mode_info->left_margin);
++	osd_write_upper_margin(mode_info->upper_margin);
++
++	if (cpu_is_davinci_dm365()) {
++		ths7303_setval(THS7303_FILTER_MODE_480P_576P);
++		msleep(40);
++		__raw_writel(0x081141EF, IO_ADDRESS(DM3XX_VDAC_CONFIG));
++	}
++
++	if (cpu_is_davinci_dm644x())
++		__raw_writel(VPBE_PCR_VENC_DIV,
++			       IO_ADDRESS(DM644X_VPBE_REG_BASE + VPBE_PCR));
++	dispc_reg_out(VENC_OSDCLK0, 0);
++	dispc_reg_out(VENC_OSDCLK1, 1);
++	if (cpu_is_davinci_dm644x()) {
++		dispc_reg_merge(VENC_VDPRO, VENC_VDPRO_DAFRQ, VENC_VDPRO_DAFRQ);
++		dispc_reg_merge(VENC_VDPRO, VENC_VDPRO_DAUPS, VENC_VDPRO_DAUPS);
++	}
++
++	dispc_reg_merge(VENC_VMOD,
++			VENC_VMOD_VDMD_YCBCR8 <<
++			VENC_VMOD_VDMD_SHIFT, VENC_VMOD_VDMD);
++
++	/* Set REC656 Mode */
++	dispc_reg_out(VENC_YCCCTL, 0x1);
++	dispc_reg_merge(VENC_VMOD, VENC_VMOD_VENC, VENC_VMOD_VENC);
++}
++
++/*
++ *  davinci_enc_set_625p
++ */
++/* This function configures the video encoder to HDTV(625p) component setting.*/
++static void davinci_enc_set_625p(struct vid_enc_mode_info *mode_info)
++{
++	enableDigitalOutput(0);
++	if (cpu_is_davinci_dm365())
++		__raw_writel(0x18, IO_ADDRESS(SYS_VPSS_CLKCTL));
++	else
++		__raw_writel(0x19, IO_ADDRESS(SYS_VPSS_CLKCTL));
++
++	osd_write_left_margin(mode_info->left_margin);
++	osd_write_upper_margin(mode_info->upper_margin);
++
++	if (cpu_is_davinci_dm365()) {
++		ths7303_setval(THS7303_FILTER_MODE_480P_576P);
++		msleep(40);
++		__raw_writel(0x081141EF, IO_ADDRESS(DM3XX_VDAC_CONFIG));
++	}
++
++	if (cpu_is_davinci_dm644x())
++		__raw_writel(VPBE_PCR_VENC_DIV,
++			       IO_ADDRESS(DM644X_VPBE_REG_BASE + VPBE_PCR));
++	dispc_reg_out(VENC_OSDCLK0, 0);
++	dispc_reg_out(VENC_OSDCLK1, 1);
++
++	if (cpu_is_davinci_dm644x()) {
++		dispc_reg_merge(VENC_VDPRO, VENC_VDPRO_DAFRQ, VENC_VDPRO_DAFRQ);
++		dispc_reg_merge(VENC_VDPRO, VENC_VDPRO_DAUPS, VENC_VDPRO_DAUPS);
++	}
++
++	dispc_reg_merge(VENC_VMOD,
++			VENC_VMOD_VDMD_YCBCR8 <<
++			VENC_VMOD_VDMD_SHIFT, VENC_VMOD_VDMD);
++
++	/* Set REC656 Mode */
++	dispc_reg_out(VENC_YCCCTL, 0x1);
++	dispc_reg_merge(VENC_VMOD, VENC_VMOD_VENC, VENC_VMOD_VENC);
++}
++
++/*
++ * davinci_enc_set_display_timing
++ */
++/* This function sets the display timing from the fb_info structure*/
++void davinci_enc_set_display_timing(struct vid_enc_mode_info *mode)
++{
++	dispc_reg_out(VENC_HSPLS, mode->hsync_len);
++	dispc_reg_out(VENC_HSTART, mode->left_margin);
++	dispc_reg_out(VENC_HVALID, mode->xres);
++	dispc_reg_out(VENC_HINT,
++		      mode->xres + mode->left_margin + mode->right_margin - 1);
++
++	dispc_reg_out(VENC_VSPLS, mode->vsync_len);
++	dispc_reg_out(VENC_VSTART, mode->upper_margin);
++	dispc_reg_out(VENC_VVALID, mode->yres);
++	dispc_reg_out(VENC_VINT,
++		      mode->yres + mode->upper_margin + mode->lower_margin);
++};
++
++EXPORT_SYMBOL(davinci_enc_set_display_timing);
++
++/*
++ * davinci_enc_set_dclk_pattern
++ */
++/* This function sets the DCLK output mode and pattern using
++   DCLKPTN registers */
++void davinci_enc_set_dclk_pattern
++    (unsigned long enable, unsigned long long pattern) {
++	if (enable > 1)
++		enable = 1;
++
++	dispc_reg_out(VENC_DCLKPTN0, pattern & 0xFFFF);
++	dispc_reg_out(VENC_DCLKPTN1, (pattern >> 16) & 0xFFFF);
++	dispc_reg_out(VENC_DCLKPTN2, (pattern >> 32) & 0xFFFF);
++	dispc_reg_out(VENC_DCLKPTN3, (pattern >> 48) & 0xFFFF);
++
++	/* The pattern is to enable DCLK or
++	   to determine its level */
++	dispc_reg_merge(VENC_DCLKCTL,
++			enable << VENC_DCLKCTL_DCKEC_SHIFT, VENC_DCLKCTL_DCKEC);
++};
++EXPORT_SYMBOL(davinci_enc_set_dclk_pattern);
++
++/*
++ * davinci_enc_set_dclk_aux_pattern
++ */
++/* This function sets the auxiliary DCLK output pattern using
++   DCLKPTNnA registers */
++void davinci_enc_set_dclk_aux_pattern(unsigned long long pattern)
++{
++	dispc_reg_out(VENC_DCLKPTN0A, pattern & 0xFFFF);
++	dispc_reg_out(VENC_DCLKPTN1A, (pattern >> 16) & 0xFFFF);
++	dispc_reg_out(VENC_DCLKPTN2A, (pattern >> 32) & 0xFFFF);
++	dispc_reg_out(VENC_DCLKPTN3A, (pattern >> 48) & 0xFFFF);
++};
++EXPORT_SYMBOL(davinci_enc_set_dclk_aux_pattern);
++
++/*
++ * davinci_enc_set_dclk_pw
++ */
++/* This function sets the DCLK output pattern width using
++   DCLKCTL register, PCKPW is [0, 63] that makes real width [1, 64] */
++void davinci_enc_set_dclk_pw(unsigned long width)
++{
++	if (width > 0x3F)
++		width = 0;
++
++	dispc_reg_merge(VENC_DCLKCTL, width, VENC_DCLKCTL_DCKPW);
++};
++EXPORT_SYMBOL(davinci_enc_set_dclk_pw);
++
++/*
++ * setting DLCD 480P PRGB mode
++ */
++static void davinci_enc_set_prgb(struct vid_enc_mode_info *mode_info)
++{
++
++	enableDigitalOutput(1);
++
++	dispc_reg_out(VENC_VIDCTL, 0x141);
++	/* set VPSS clock */
++	__raw_writel(0x18, IO_ADDRESS(SYS_VPSS_CLKCTL));
++
++	dispc_reg_out(VENC_DCLKCTL, 0);
++	dispc_reg_out(VENC_DCLKPTN0, 0);
++
++	/* Set the OSD Divisor to 1. */
++	dispc_reg_out(VENC_OSDCLK0, 0);
++	dispc_reg_out(VENC_OSDCLK1, 1);
++	/* Clear composite mode register */
++	dispc_reg_out(VENC_CVBS, 0);
++
++	/* Set PINMUX1 to enable all outputs needed to support RGB666 */
++	if (cpu_is_davinci_dm355()) {
++		/* Enable the venc and dlcd clocks. */
++		dispc_reg_out(VENC_CLKCTL, 0x11);
++		davinci_cfg_reg(DM355_VOUT_FIELD_G70);
++		davinci_cfg_reg(DM355_VOUT_COUTL_EN);
++		davinci_cfg_reg(DM355_VOUT_COUTH_EN);
++	} else if (cpu_is_davinci_dm365()) {
++		/* DM365 pinmux */
++		dispc_reg_out(VENC_CLKCTL, 0x11);
++		davinci_cfg_reg(DM365_VOUT_FIELD_G81);
++		davinci_cfg_reg(DM365_VOUT_COUTL_EN);
++		davinci_cfg_reg(DM365_VOUT_COUTH_EN);
++	} else {
++		dispc_reg_out(VENC_CMPNT, 0x100);
++		davinci_cfg_reg(DM644X_GPIO46_47);
++		davinci_cfg_reg(DM644X_GPIO0);
++		davinci_cfg_reg(DM644X_RGB666);
++		davinci_cfg_reg(DM644X_LOEEN);
++		davinci_cfg_reg(DM644X_GPIO3);
++	}
++
++	osd_write_left_margin(mode_info->left_margin);
++	osd_write_upper_margin(mode_info->upper_margin);
++
++	/* Set VIDCTL to select VCLKE = 1,
++	   VCLKZ =0, SYDIR = 0 (set o/p), DOMD = 0 */
++	dispc_reg_merge(VENC_VIDCTL, 1 << VENC_VIDCTL_VCLKE_SHIFT,
++			VENC_VIDCTL_VCLKE);
++	dispc_reg_merge(VENC_VIDCTL, 0 << VENC_VIDCTL_VCLKZ_SHIFT,
++			VENC_VIDCTL_VCLKZ);
++	dispc_reg_merge(VENC_VIDCTL, 0 << VENC_VIDCTL_SYDIR_SHIFT,
++			VENC_VIDCTL_SYDIR);
++	dispc_reg_merge(VENC_VIDCTL, 0 << VENC_VIDCTL_YCDIR_SHIFT,
++			VENC_VIDCTL_YCDIR);
++
++	dispc_reg_merge(VENC_DCLKCTL,
++			1 << VENC_DCLKCTL_DCKEC_SHIFT, VENC_DCLKCTL_DCKEC);
++
++	dispc_reg_out(VENC_DCLKPTN0, 0x1);
++
++	davinci_enc_set_display_timing(mode_info);
++	dispc_reg_out(VENC_SYNCCTL,
++		      (VENC_SYNCCTL_SYEV |
++		       VENC_SYNCCTL_SYEH | VENC_SYNCCTL_HPL
++		       | VENC_SYNCCTL_VPL));
++
++	/* Configure VMOD. No change in VENC bit */
++	dispc_reg_out(VENC_VMOD, 0x2011);
++	dispc_reg_out(VENC_LCDOUT, 0x1);
++
++}
++
++/*
++ *
++ */
++static void davinci_enc_set_720p(struct vid_enc_mode_info *mode_info)
++{
++	/* Reset video encoder module */
++	dispc_reg_out(VENC_VMOD, 0);
++
++	enableDigitalOutput(1);
++
++	dispc_reg_out(VENC_VIDCTL, (VENC_VIDCTL_VCLKE | VENC_VIDCTL_VCLKP));
++	/* Setting DRGB Matrix registers back to default values */
++	dispc_reg_out(VENC_DRGBX0, 0x00000400);
++	dispc_reg_out(VENC_DRGBX1, 0x00000576);
++	dispc_reg_out(VENC_DRGBX2, 0x00000159);
++	dispc_reg_out(VENC_DRGBX3, 0x000002cb);
++	dispc_reg_out(VENC_DRGBX4, 0x000006ee);
++
++	/* Enable DCLOCK */
++	dispc_reg_out(VENC_DCLKCTL, VENC_DCLKCTL_DCKEC);
++	/* Set DCLOCK pattern */
++	dispc_reg_out(VENC_DCLKPTN0, 1);
++	dispc_reg_out(VENC_DCLKPTN1, 0);
++	dispc_reg_out(VENC_DCLKPTN2, 0);
++	dispc_reg_out(VENC_DCLKPTN3, 0);
++	dispc_reg_out(VENC_DCLKPTN0A, 2);
++	dispc_reg_out(VENC_DCLKPTN1A, 0);
++	dispc_reg_out(VENC_DCLKPTN2A, 0);
++	dispc_reg_out(VENC_DCLKPTN3A, 0);
++	dispc_reg_out(VENC_DCLKHS, 0);
++	dispc_reg_out(VENC_DCLKHSA, 1);
++	dispc_reg_out(VENC_DCLKHR, 0);
++	dispc_reg_out(VENC_DCLKVS, 0);
++	dispc_reg_out(VENC_DCLKVR, 0);
++	/* Set brightness start position and pulse width to zero */
++	dispc_reg_out(VENC_BRTS, 0);
++	dispc_reg_out(VENC_BRTW, 0);
++	/* Set LCD AC toggle interval and horizontal position to zero */
++	dispc_reg_out(VENC_ACCTL, 0);
++
++	/* Set PWM period and width to zero */
++	dispc_reg_out(VENC_PWMP, 0);
++	dispc_reg_out(VENC_PWMW, 0);
++
++	dispc_reg_out(VENC_CVBS, 0);
++	dispc_reg_out(VENC_CMPNT, 0);
++	/* turning on horizontal and vertical syncs */
++	dispc_reg_out(VENC_SYNCCTL, (VENC_SYNCCTL_SYEV | VENC_SYNCCTL_SYEH));
++	dispc_reg_out(VENC_OSDCLK0, 0);
++	dispc_reg_out(VENC_OSDCLK1, 1);
++	dispc_reg_out(VENC_OSDHADV, 0);
++
++	__raw_writel(0xa, IO_ADDRESS(SYS_VPSS_CLKCTL));
++	if (cpu_is_davinci_dm355()) {
++		dispc_reg_out(VENC_CLKCTL, 0x11);
++
++		osd_write_left_margin(mode_info->left_margin);
++		osd_write_upper_margin(mode_info->upper_margin);
++
++		davinci_cfg_reg(DM355_VOUT_FIELD_G70);
++		davinci_cfg_reg(DM355_VOUT_COUTL_EN);
++		davinci_cfg_reg(DM355_VOUT_COUTH_EN);
++	} else {
++		osd_write_left_margin(mode_info->left_margin);
++		osd_write_upper_margin(mode_info->upper_margin);
++
++		davinci_cfg_reg(DM644X_LOEEN);
++		davinci_cfg_reg(DM644X_GPIO3);
++	}
++
++	/* Set VENC for non-standard timing */
++	davinci_enc_set_display_timing(mode_info);
++
++	dispc_reg_out(VENC_HSDLY, 0);
++	dispc_reg_out(VENC_VSDLY, 0);
++	dispc_reg_out(VENC_YCCCTL, 0);
++	dispc_reg_out(VENC_VSTARTA, 0);
++
++	/* Enable all VENC, non-standard timing mode, master timing, HD,
++	   progressive
++	 */
++	if (cpu_is_davinci_dm355()) {
++		dispc_reg_out(VENC_VMOD, (VENC_VMOD_VENC | VENC_VMOD_VMD));
++	} else {
++		dispc_reg_out(VENC_VMOD,
++			      (VENC_VMOD_VENC | VENC_VMOD_VMD |
++			       VENC_VMOD_HDMD));
++	}
++	dispc_reg_out(VENC_LCDOUT, 1);
++}
++
++/*
++ *
++ */
++static void davinci_enc_set_1080i(struct vid_enc_mode_info *mode_info)
++{
++	/* Reset video encoder module */
++	dispc_reg_out(VENC_VMOD, 0);
++
++	enableDigitalOutput(1);
++	dispc_reg_out(VENC_VIDCTL, (VENC_VIDCTL_VCLKE | VENC_VIDCTL_VCLKP));
++	/* Setting DRGB Matrix registers back to default values */
++	dispc_reg_out(VENC_DRGBX0, 0x00000400);
++	dispc_reg_out(VENC_DRGBX1, 0x00000576);
++	dispc_reg_out(VENC_DRGBX2, 0x00000159);
++	dispc_reg_out(VENC_DRGBX3, 0x000002cb);
++	dispc_reg_out(VENC_DRGBX4, 0x000006ee);
++	/* Enable DCLOCK */
++	dispc_reg_out(VENC_DCLKCTL, VENC_DCLKCTL_DCKEC);
++	/* Set DCLOCK pattern */
++	dispc_reg_out(VENC_DCLKPTN0, 1);
++	dispc_reg_out(VENC_DCLKPTN1, 0);
++	dispc_reg_out(VENC_DCLKPTN2, 0);
++	dispc_reg_out(VENC_DCLKPTN3, 0);
++	dispc_reg_out(VENC_DCLKPTN0A, 2);
++	dispc_reg_out(VENC_DCLKPTN1A, 0);
++	dispc_reg_out(VENC_DCLKPTN2A, 0);
++	dispc_reg_out(VENC_DCLKPTN3A, 0);
++	dispc_reg_out(VENC_DCLKHS, 0);
++	dispc_reg_out(VENC_DCLKHSA, 1);
++	dispc_reg_out(VENC_DCLKHR, 0);
++	dispc_reg_out(VENC_DCLKVS, 0);
++	dispc_reg_out(VENC_DCLKVR, 0);
++	/* Set brightness start position and pulse width to zero */
++	dispc_reg_out(VENC_BRTS, 0);
++	dispc_reg_out(VENC_BRTW, 0);
++	/* Set LCD AC toggle interval and horizontal position to zero */
++	dispc_reg_out(VENC_ACCTL, 0);
++
++	/* Set PWM period and width to zero */
++	dispc_reg_out(VENC_PWMP, 0);
++	dispc_reg_out(VENC_PWMW, 0);
++
++	dispc_reg_out(VENC_CVBS, 0);
++	dispc_reg_out(VENC_CMPNT, 0);
++	/* turning on horizontal and vertical syncs */
++	dispc_reg_out(VENC_SYNCCTL, (VENC_SYNCCTL_SYEV | VENC_SYNCCTL_SYEH));
++	dispc_reg_out(VENC_OSDCLK0, 0);
++	dispc_reg_out(VENC_OSDCLK1, 1);
++	dispc_reg_out(VENC_OSDHADV, 0);
++
++	dispc_reg_out(VENC_HSDLY, 0);
++	dispc_reg_out(VENC_VSDLY, 0);
++	dispc_reg_out(VENC_YCCCTL, 0);
++	dispc_reg_out(VENC_VSTARTA, 13);
++
++	__raw_writel(0xa, IO_ADDRESS(SYS_VPSS_CLKCTL));
++	if (cpu_is_davinci_dm355()) {
++		dispc_reg_out(VENC_CLKCTL, 0x11);
++
++		osd_write_left_margin(mode_info->left_margin);
++		osd_write_upper_margin(mode_info->upper_margin);
++	
++		davinci_cfg_reg(DM355_VOUT_FIELD);
++		davinci_cfg_reg(DM355_VOUT_COUTL_EN);
++		davinci_cfg_reg(DM355_VOUT_COUTH_EN);
++	} else {
++		osd_write_left_margin(mode_info->left_margin);
++		osd_write_upper_margin(mode_info->upper_margin);
++
++		davinci_cfg_reg(DM644X_LFLDEN);
++	}
++
++	/* Set VENC for non-standard timing */
++	davinci_enc_set_display_timing(mode_info);
++
++	/* Enable all VENC, non-standard timing mode, master timing,
++	   HD, interlaced
++	 */
++	if (cpu_is_davinci_dm355()) {
++		dispc_reg_out(VENC_VMOD,
++			      (VENC_VMOD_VENC | VENC_VMOD_VMD |
++			       VENC_VMOD_NSIT));
++	} else {
++		dispc_reg_out(VENC_VMOD,
++			      (VENC_VMOD_VENC | VENC_VMOD_VMD | VENC_VMOD_HDMD |
++			       VENC_VMOD_NSIT));
++	}
++	dispc_reg_out(VENC_LCDOUT, 1);
++}
++
++static void davinci_enc_set_internal_hd(struct vid_enc_mode_info *mode_info)
++{
++	/* set sysclk4 to output 74.25 MHz from pll1 */
++	__raw_writel(0x38, IO_ADDRESS(SYS_VPSS_CLKCTL));
++
++	ths7303_setval(THS7303_FILTER_MODE_720P_1080I);
++	msleep(50);
++	__raw_writel(0x081141EF, IO_ADDRESS(DM3XX_VDAC_CONFIG));
++	return;
++}
++
++void davinci_enc_priv_setmode(struct vid_enc_device_mgr *mgr)
++{
++
++	switch (mgr->current_mode.if_type) {
++	case VID_ENC_IF_BT656:
++		dispc_reg_merge(VENC_VMOD,
++				VENC_VMOD_VDMD_YCBCR8 << VENC_VMOD_VDMD_SHIFT,
++				VENC_VMOD_VDMD);
++		dispc_reg_merge(VENC_YCCCTL, 1, 1);
++		break;
++	case VID_ENC_IF_BT1120:
++		break;
++	case VID_ENC_IF_YCC8:
++		dispc_reg_merge(VENC_VMOD,
++				VENC_VMOD_VDMD_YCBCR8 << VENC_VMOD_VDMD_SHIFT,
++				VENC_VMOD_VDMD);
++		break;
++	case VID_ENC_IF_YCC16:
++		dispc_reg_merge(VENC_VMOD,
++				VENC_VMOD_VDMD_YCBCR16 << VENC_VMOD_VDMD_SHIFT,
++				VENC_VMOD_VDMD);
++		break;
++	case VID_ENC_IF_SRGB:
++		dispc_reg_merge(VENC_VMOD,
++				VENC_VMOD_VDMD_RGB8 << VENC_VMOD_VDMD_SHIFT,
++				VENC_VMOD_VDMD);
++		break;
++	case VID_ENC_IF_PRGB:
++		dispc_reg_merge(VENC_VMOD,
++				VENC_VMOD_VDMD_RGB666 << VENC_VMOD_VDMD_SHIFT,
++				VENC_VMOD_VDMD);
++		break;
++	default:
++		break;
++	}
++
++	if (strcmp(mgr->current_mode.name, VID_ENC_STD_NTSC) == 0) {
++		davinci_enc_set_ntsc(&mgr->current_mode);
++	} else if (strcmp(mgr->current_mode.name, VID_ENC_STD_NTSC_RGB) == 0) {
++		davinci_enc_set_ntsc_pal_rgb(&mgr->current_mode);
++	} else if (strcmp(mgr->current_mode.name, VID_ENC_STD_PAL) == 0) {
++		davinci_enc_set_pal(&mgr->current_mode);
++	} else if (strcmp(mgr->current_mode.name, VID_ENC_STD_PAL_RGB) == 0) {
++		davinci_enc_set_ntsc_pal_rgb(&mgr->current_mode);
++	} else if (strcmp(mgr->current_mode.name, VID_ENC_STD_480P_60) == 0) {
++		davinci_enc_set_525p(&mgr->current_mode);
++	} else if (strcmp(mgr->current_mode.name, VID_ENC_STD_576P_50) == 0) {
++		davinci_enc_set_625p(&mgr->current_mode);
++	} else if (strcmp(mgr->current_mode.name, VID_ENC_STD_640x480) == 0 ||
++		strcmp(mgr->current_mode.name, VID_ENC_STD_640x400) == 0 ||
++		strcmp(mgr->current_mode.name, VID_ENC_STD_640x350) == 0 ||
++		strcmp(mgr->current_mode.name, VID_ENC_STD_800x480) == 0) {
++		davinci_enc_set_prgb(&mgr->current_mode);
++	} else if (strcmp(mgr->current_mode.name, VID_ENC_STD_720P_60) == 0) {
++		/* DM365 has built-in HD DAC; otherwise, they depend on
++		 * THS8200
++		 */
++		if (cpu_is_davinci_dm365()) {
++			davinci_enc_set_internal_hd(&mgr->current_mode);
++			/* changed for 720P demo */
++			davinci_enc_set_basep(0, 0xf0, 10);
++		} else
++			davinci_enc_set_720p(&mgr->current_mode);
++	} else if (strcmp(mgr->current_mode.name, VID_ENC_STD_1080I_30) == 0) {
++		if (cpu_is_davinci_dm365()) {
++			davinci_enc_set_internal_hd(&mgr->current_mode);
++			davinci_enc_set_basep(0, 0xd0, 10);
++		} else
++			davinci_enc_set_1080i(&mgr->current_mode);
++	}
++
++/* TODO */
++#if 0
++	/* turn off ping-pong buffer and field inversion to fix
++	 * the image shaking problem in 1080I mode. The problem i.d. by the
++	 * DM6446 Advisory 1.3.8 is not seen in 1080I mode, but the ping-pong
++	 * buffer workaround created a shaking problem.
++	 */
++	if ((cpu_is_davinci_dm644x_pg1x() || cpu_is_davinci_dm357()) &&
++		strcmp(mgr->current_mode.name, VID_ENC_STD_1080I_30) == 0)
++		davinci_disp_set_field_inversion(0);
++#endif
++
++	return;
++}
++
++void davinci_enc_set_mode_platform(int channel, struct vid_enc_device_mgr *mgr)
++{
++
++	if (0 == mgr->current_mode.std) {
++		davinci_enc_set_display_timing(&mgr->current_mode);
++		return;
++	}
++	davinci_enc_priv_setmode(mgr);
++}
++
++EXPORT_SYMBOL(davinci_enc_set_mode_platform);
++
++int davinci_disp_is_second_field(void)
++{
++	return ((__raw_readl(venc->venc_base + VENC_VSTAT) & VENC_VSTAT_FIDST)
++		== VENC_VSTAT_FIDST);
++}
++EXPORT_SYMBOL(davinci_disp_is_second_field);
++
++static int davinci_venc_probe(struct platform_device *pdev)
++{
++	struct resource *res;
++
++	venc->vdev = &pdev->dev;
++
++	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
++	if (!res) {
++		dev_err(venc->vdev, "Unable to get VENC register address map\n");
++		return -ENODEV;
++	}
++	venc->venc_base_phys = res->start;
++	venc->venc_size = res->end - res->start + 1;
++	if (!request_mem_region(venc->venc_base_phys, venc->venc_size,
++				"davinci_venc")) {
++		dev_err(venc->vdev, "Unable to reserve VENC MMIO region\n");
++		return -ENODEV;
++	}
++	venc->venc_base = (unsigned long)ioremap_nocache(res->start,
++							venc->venc_size);
++	if (!venc->venc_base) {
++		dev_err(venc->vdev, "Unable to map VENC MMIO\n");
++		goto release_venc;
++	}
++
++	return 0;
++
++release_venc:
++	release_mem_region(venc->venc_base_phys, venc->venc_size);
++
++	return -ENODEV;
++}
++
++static int davinci_venc_remove(struct platform_device *pdev)
++{
++	if (venc->venc_base)
++		iounmap((void *)venc->venc_base);
++	release_mem_region(venc->venc_base_phys, venc->venc_size);
++	
++	return 0;
++}
++
++static struct platform_driver davinci_venc_driver = {
++	.probe		= davinci_venc_probe,
++	.remove		= davinci_venc_remove,
++	.driver		= {
++		.name	= "davinci_venc",
++		.owner	= THIS_MODULE,
++	},
++};
++
++static int davinci_platform_init(void)
++{
++/* Sandeep */
++	display_cntl_base = ioremap(DM644X_DDR2_CNTL_BASE, 0x24);
++	if (!display_cntl_base) {
++		printk(KERN_ERR "Could not remap control registers\n");
++		return -EINVAL;
++	}
++	class_register(&davinci_system_class);
++
++	davinci_system_device = create_sysfs_files();
++	if (!davinci_system_device) {
++		printk(KERN_ERR "Could not create davinci system sysfs\n");
++		iounmap(display_cntl_base);
++		return -EINVAL;
++	}
++
++	/* Register the driver */
++	if (platform_driver_register(&davinci_venc_driver)) {
++		printk(KERN_ERR "Unable to register davinci platform driver\n");
++		return -ENODEV;
++	}
++
++	
++	return 0;
++}
++
++static void davinci_platform_exit(void)
++{
++/* Sandeep */
++	remove_sysfs_files(davinci_system_device);
++	class_unregister(&davinci_system_class);
++	iounmap(display_cntl_base);
++
++	platform_driver_unregister(&davinci_venc_driver);
++
++	return;
++}
++
++subsys_initcall(davinci_platform_init);
++module_exit(davinci_platform_exit);
++
++MODULE_LICENSE("GPL");
++MODULE_DESCRIPTION("DaVinci Platform Driver");
++MODULE_AUTHOR("Texas Instruments");
+--- a/sound/soc/davinci/davinci-evm.c
++++ b/sound/soc/davinci/davinci-evm.c
+@@ -45,7 +45,8 @@ static int evm_hw_params(struct snd_pcm_
+ 	unsigned sysclk;
+ 
+ 	/* ASP1 on DM355 EVM is clocked by an external oscillator */
+-	if (machine_is_davinci_dm355_evm() || machine_is_davinci_dm6467_evm())
++	if (machine_is_davinci_dm355_evm() || machine_is_davinci_dm6467_evm() ||
++	    machine_is_davinci_dm365_evm())
+ 		sysclk = 27000000;
+ 
+ 	/* ASP0 in DM6446 EVM is clocked by U55, as configured by
+@@ -176,7 +177,7 @@ static struct snd_soc_dai_link da8xx_evm
+ 	.ops = &evm_ops,
+ };
+ 
+-/* davinci-evm audio machine driver */
++/* davinci dm6446, dm355 or dm365 evm audio machine driver */
+ static struct snd_soc_card snd_soc_card_evm = {
+ 	.name = "DaVinci EVM",
+ 	.platform = &davinci_soc_platform,
+@@ -243,7 +244,7 @@ static int __init evm_init(void)
+ 	int index;
+ 	int ret;
+ 
+-	if (machine_is_davinci_evm()) {
++	if (machine_is_davinci_evm() || machine_is_davinci_dm365_evm()) {
+ 		evm_snd_dev_data = &evm_snd_devdata;
+ 		index = 0;
+ 	} else if (machine_is_davinci_dm355_evm()) {
+--- /dev/null
++++ b/drivers/char/dm355_ipipe_hw.c
+@@ -0,0 +1,1013 @@
++/*
++ * Copyright (C) 2005-2009 Texas Instruments Inc
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
++ */
++
++#include <linux/errno.h>
++#include <linux/delay.h>
++#include <linux/device.h>
++
++#include <media/davinci/dm355_ipipe.h>
++#include <media/davinci/vpss.h>
++
++#include "dm355_ipipe_hw.h"
++
++void ipipe_enable_reg_write(void)
++{
++	regw_ip(1, GCL_ARM);
++	/*enable the clock wb,cfa,dfc,d2f,pre modules */
++	regw_ip(0x06, GCL_CCD);
++}
++
++#ifdef CONFIG_IMP_DEBUG
++void ipipe_hw_dump_config(void)
++{
++	u32 utemp;
++	printk(KERN_NOTICE "IPIPEIF Registers\n");
++	printk(KERN_NOTICE
++	       "**************************************************\n");
++	utemp = regr_if(IPIPEIF_ENABLE);
++	printk(KERN_NOTICE "IPIPEIF ENABLE = 0x%x\n", utemp);
++	utemp = regr_if(IPIPEIF_GFG);
++	printk(KERN_NOTICE "IPIPEIF CFG = 0x%x\n", utemp);
++	utemp = regr_if(IPIPEIF_PPLN);
++	printk(KERN_NOTICE "IPIPEIF PPLN = 0x%x\n", utemp);
++	utemp = regr_if(IPIPEIF_LPFR);
++	printk(KERN_NOTICE "IPIPEIF LPFR = 0x%x\n", utemp);
++	utemp = regr_if(IPIPEIF_HNUM);
++	printk(KERN_NOTICE "IPIPEIF HNUM = 0x%x\n", utemp);
++	utemp = regr_if(IPIPEIF_VNUM);
++	printk(KERN_NOTICE "IPIPEIF VNUM = 0x%x\n", utemp);
++	utemp = regr_if(IPIPEIF_ADDRU);
++	printk(KERN_NOTICE "IPIPEIF ADDRU = 0x%x\n", utemp);
++	utemp = regr_if(IPIPEIF_ADDRL);
++	printk(KERN_NOTICE "IPIPEIF ADDRL = 0x%x\n", utemp);
++	utemp = regr_if(IPIPEIF_ADOFS);
++	printk(KERN_NOTICE "IPIPEIF ADOFS = 0x%x\n", utemp);
++	utemp = regr_if(IPIPEIF_RSZ);
++	printk(KERN_NOTICE "IPIPEIF RSZ = 0x%x\n", utemp);
++	utemp = regr_if(IPIPEIF_GAIN);
++	printk(KERN_NOTICE "IPIPEIF GAIN = 0x%x\n", utemp);
++	printk(KERN_NOTICE "IPIPE Registers\n");
++	printk(KERN_NOTICE
++	       "**************************************************\n");
++	utemp = regr_ip(IPIPE_EN);
++	printk(KERN_NOTICE "IPIPE ENABLE = 0x%x\n", utemp);
++	utemp = regr_ip(IPIPE_MODE);
++	printk(KERN_NOTICE "IPIPE MODE = 0x%x\n", utemp);
++	utemp = regr_ip(IPIPE_DPATHS);
++	printk(KERN_NOTICE "IPIPE DPATHS = 0x%x\n", utemp);
++	utemp = regr_ip(IPIPE_COLPAT);
++	printk(KERN_NOTICE "IPIPE COLPAT = 0x%x\n", utemp);
++	utemp = regr_ip(IPIPE_VST);
++	printk(KERN_NOTICE "IPIPE VST = 0x%x\n", utemp);
++	utemp = regr_ip(IPIPE_VSZ);
++	printk(KERN_NOTICE "IPIPE VSZ = 0x%x\n", utemp);
++	utemp = regr_ip(IPIPE_HST);
++	printk(KERN_NOTICE "IPIPE HST = 0x%x\n", utemp);
++	utemp = regr_ip(IPIPE_HSZ);
++	printk(KERN_NOTICE "IPIPE HSZ = 0x%x\n", utemp);
++	printk(KERN_NOTICE "Resizer Registers\n");
++	printk(KERN_NOTICE
++	       "**************************************************\n");
++	utemp = regr_ip(RSZ_EN_0);
++	printk(KERN_NOTICE "IPIPE RSZ 0 ENABLE = 0x%x\n", utemp);
++	utemp = regr_ip((RSZ_EN_0 + RSZ_MODE));
++	printk(KERN_NOTICE "IPIPE RSZ 0 MODE = 0x%x\n", utemp);
++	utemp = regr_ip((RSZ_EN_0 + RSZ_I_VST));
++	printk(KERN_NOTICE "IPIPE RSZ 0 I_VST = 0x%x\n", utemp);
++	utemp = regr_ip((RSZ_EN_0 + RSZ_I_VSZ));
++	printk(KERN_NOTICE "IPIPE RSZ 0 I_VSZ = 0x%x\n", utemp);
++	utemp = regr_ip((RSZ_EN_0 + RSZ_I_HST));
++	printk(KERN_NOTICE "IPIPE RSZ 0 I_HST = 0x%x\n", utemp);
++	utemp = regr_ip((RSZ_EN_0 + RSZ_O_VSZ));
++	printk(KERN_NOTICE "IPIPE RSZ 0 O_VSZ = 0x%x\n", utemp);
++	utemp = regr_ip((RSZ_EN_0 + RSZ_O_HST));
++	printk(KERN_NOTICE "IPIPE RSZ 0 O_HST = 0x%x\n", utemp);
++	utemp = regr_ip((RSZ_EN_0 + RSZ_O_HSZ));
++	printk(KERN_NOTICE "IPIPE RSZ 0 O_HSZ = 0x%x\n", utemp);
++	utemp = regr_ip((RSZ_EN_0 + RSZ_V_PHS));
++	printk(KERN_NOTICE "IPIPE RSZ 0 V_PHS = 0x%x\n", utemp);
++	utemp = regr_ip((RSZ_EN_0 + RSZ_V_PHS_O));
++	printk(KERN_NOTICE "IPIPE RSZ 0 V_PHS_O = 0x%x\n", utemp);
++	utemp = regr_ip((RSZ_EN_0 + RSZ_V_DIF));
++	printk(KERN_NOTICE "IPIPE RSZ 0 V_DIF = 0x%x\n", utemp);
++	utemp = regr_ip((RSZ_EN_0 + RSZ_V_SIZ_O));
++	printk(KERN_NOTICE "IPIPE RSZ 0 V_SIZ_O = 0x%x\n", utemp);
++	utemp = regr_ip((RSZ_EN_0 + RSZ_H_PHS));
++	printk(KERN_NOTICE "IPIPE RSZ 0 H_PHS = 0x%x\n", utemp);
++	utemp = regr_ip((RSZ_EN_0 + RSZ_H_DIF));
++	printk(KERN_NOTICE "IPIPE RSZ 0 H_DIF = 0x%x\n", utemp);
++	utemp = regr_ip((RSZ_EN_0 + RSZ_H_TYP));
++	printk(KERN_NOTICE "IPIPE RSZ 0 H_TYP = 0x%x\n", utemp);
++	utemp = regr_ip((RSZ_EN_0 + RSZ_H_LSE));
++	printk(KERN_NOTICE "IPIPE RSZ 0 H_LSE = 0x%x\n", utemp);
++	utemp = regr_ip((RSZ_EN_0 + RSZ_H_LPF));
++	printk(KERN_NOTICE "IPIPE RSZ 0 H_LPF = 0x%x\n", utemp);
++	utemp = regr_ip((RSZ_EN_0 + RSZ_RGB_EN));
++	printk(KERN_NOTICE "IPIPE RSZ 0 RGB_EN = 0x%x\n", utemp);
++	utemp = regr_ip((RSZ_EN_0 + RSZ_RGB_TYP));
++	printk(KERN_NOTICE "IPIPE RSZ 0 RGB_TYP = 0x%x\n", utemp);
++	utemp = regr_ip((RSZ_EN_0 + RSZ_RGB_BLD));
++	printk(KERN_NOTICE "IPIPE RSZ 0 RGB_BLD = 0x%x\n", utemp);
++	utemp = regr_ip((RSZ_EN_0 + RSZ_SDR_BAD_H));
++	printk(KERN_NOTICE "IPIPE RSZ 0 SDR_BAD_H = 0x%x\n", utemp);
++	utemp = regr_ip((RSZ_EN_0 + RSZ_SDR_BAD_L));
++	printk(KERN_NOTICE "IPIPE RSZ 0 SDR_BAD_L = 0x%x\n", utemp);
++	utemp = regr_ip((RSZ_EN_0 + RSZ_SDR_SAD_H));
++	printk(KERN_NOTICE "IPIPE RSZ 0 SDR_SAD_H = 0x%x\n", utemp);
++	utemp = regr_ip((RSZ_EN_0 + RSZ_SDR_SAD_L));
++	printk(KERN_NOTICE "IPIPE RSZ 0 SDR_SAD_L = 0x%x\n", utemp);
++	utemp = regr_ip((RSZ_EN_0 + RSZ_SDR_OFT));
++	printk(KERN_NOTICE "IPIPE RSZ 0 SDR_OFT = 0x%x\n", utemp);
++	utemp = regr_ip((RSZ_EN_0 + RSZ_SDR_PTR_S));
++	printk(KERN_NOTICE "IPIPE RSZ 0 SDR_PTR_S = 0x%x\n", utemp);
++	utemp = regr_ip((RSZ_EN_0 + RSZ_SDR_PTR_E));
++	printk(KERN_NOTICE "IPIPE RSZ 0 SDR_PTR_E = 0x%x\n", utemp);
++	utemp = regr_ip((RSZ_EN_0 + RSZ_SDR_PTR_O));
++	printk(KERN_NOTICE "IPIPE RSZ 0 SDR_PTR_O = 0x%x\n", utemp);
++	utemp = regr_ip(RSZ_EN_1);
++	printk(KERN_NOTICE
++	       "**************************************************\n");
++	printk(KERN_NOTICE "IPIPE RSZ 1 ENABLE = 0x%x\n", utemp);
++	utemp = regr_ip((RSZ_EN_1 + RSZ_MODE));
++	printk(KERN_NOTICE "IPIPE RSZ 1 MODE = 0x%x\n", utemp);
++	utemp = regr_ip((RSZ_EN_1 + RSZ_I_VST));
++	printk(KERN_NOTICE "IPIPE RSZ 1 I_VST = 0x%x\n", utemp);
++	utemp = regr_ip((RSZ_EN_1 + RSZ_I_VSZ));
++	printk(KERN_NOTICE "IPIPE RSZ 1 I_VSZ = 0x%x\n", utemp);
++	utemp = regr_ip((RSZ_EN_1 + RSZ_I_HST));
++	printk(KERN_NOTICE "IPIPE RSZ 1 I_HST = 0x%x\n", utemp);
++	utemp = regr_ip((RSZ_EN_1 + RSZ_O_VSZ));
++	printk(KERN_NOTICE "IPIPE RSZ 1 I_VSZ = 0x%x\n", utemp);
++	utemp = regr_ip((RSZ_EN_1 + RSZ_O_HST));
++	printk(KERN_NOTICE "IPIPE RSZ 1 O_HST = 0x%x\n", utemp);
++	utemp = regr_ip((RSZ_EN_1 + RSZ_O_HSZ));
++	printk(KERN_NOTICE "IPIPE RSZ 1 O_HSZ = 0x%x\n", utemp);
++	utemp = regr_ip((RSZ_EN_1 + RSZ_V_PHS));
++	printk(KERN_NOTICE "IPIPE RSZ 1 V_PHS = 0x%x\n", utemp);
++	utemp = regr_ip((RSZ_EN_1 + RSZ_V_PHS_O));
++	printk(KERN_NOTICE "IPIPE RSZ 1 V_PHS_O = 0x%x\n", utemp);
++	utemp = regr_ip((RSZ_EN_1 + RSZ_V_DIF));
++	printk(KERN_NOTICE "IPIPE RSZ 1 V_DIF = 0x%x\n", utemp);
++	utemp = regr_ip((RSZ_EN_1 + RSZ_V_SIZ_O));
++	printk(KERN_NOTICE "IPIPE RSZ 1 V_SIZ_O = 0x%x\n", utemp);
++	utemp = regr_ip((RSZ_EN_1 + RSZ_H_PHS));
++	printk(KERN_NOTICE "IPIPE RSZ 1 H_PHS = 0x%x\n", utemp);
++	utemp = regr_ip((RSZ_EN_1 + RSZ_H_DIF));
++	printk(KERN_NOTICE "IPIPE RSZ 1 H_DIF = 0x%x\n", utemp);
++	utemp = regr_ip((RSZ_EN_1 + RSZ_H_TYP));
++	printk(KERN_NOTICE "IPIPE RSZ 1 H_TYP = 0x%x\n", utemp);
++	utemp = regr_ip((RSZ_EN_1 + RSZ_H_LSE));
++	printk(KERN_NOTICE "IPIPE RSZ 1 H_LSE = 0x%x\n", utemp);
++	utemp = regr_ip((RSZ_EN_1 + RSZ_H_LPF));
++	printk(KERN_NOTICE "IPIPE RSZ 1 H_LPF = 0x%x\n", utemp);
++	utemp = regr_ip((RSZ_EN_1 + RSZ_RGB_EN));
++	printk(KERN_NOTICE "IPIPE RSZ 1 RGB_EN = 0x%x\n", utemp);
++	utemp = regr_ip((RSZ_EN_1 + RSZ_RGB_TYP));
++	printk(KERN_NOTICE "IPIPE RSZ 1 RGB_TYP = 0x%x\n", utemp);
++	utemp = regr_ip((RSZ_EN_1 + RSZ_RGB_BLD));
++	printk(KERN_NOTICE "IPIPE RSZ 1 RGB_BLD = 0x%x\n", utemp);
++	utemp = regr_ip((RSZ_EN_1 + RSZ_SDR_BAD_H));
++	printk(KERN_NOTICE "IPIPE RSZ 1 SDR_BAD_H = 0x%x\n", utemp);
++	utemp = regr_ip((RSZ_EN_1 + RSZ_SDR_BAD_L));
++	printk(KERN_NOTICE "IPIPE RSZ 1 SDR_BAD_L = 0x%x\n", utemp);
++	utemp = regr_ip((RSZ_EN_1 + RSZ_SDR_SAD_H));
++	printk(KERN_NOTICE "IPIPE RSZ 1 SDR_SAD_H = 0x%x\n", utemp);
++	utemp = regr_ip((RSZ_EN_1 + RSZ_SDR_SAD_L));
++	printk(KERN_NOTICE "IPIPE RSZ 1 SDR_SAD_L = 0x%x\n", utemp);
++	utemp = regr_ip((RSZ_EN_1 + RSZ_SDR_OFT));
++	printk(KERN_NOTICE "IPIPE RSZ 1 SDR_OFT = 0x%x\n", utemp);
++	utemp = regr_ip((RSZ_EN_1 + RSZ_SDR_PTR_S));
++	printk(KERN_NOTICE "IPIPE RSZ 1 SDR_PTR_S = 0x%x\n", utemp);
++	utemp = regr_ip((RSZ_EN_1 + RSZ_SDR_PTR_E));
++	printk(KERN_NOTICE "IPIPE RSZ 1 SDR_PTR_E = 0x%x\n", utemp);
++	utemp = regr_ip((RSZ_EN_1 + RSZ_SDR_PTR_O));
++	printk(KERN_NOTICE "IPIPE RSZ 1 SDR_PTR_O = 0x%x\n", utemp);
++}
++#else
++void ipipe_hw_dump_config(void)
++{
++}
++#endif
++
++/* ipipe_hw_setup:It is used for Hardware Setup */
++int ipipe_hw_setup(struct ipipe_params *config)
++{
++	u32 utemp = 0;
++	u32 data_format;
++	enum ipipeif_decimation decimation_en;
++	if (!config)
++		return -EINVAL;
++
++	/*Combine all the fields to make CFG register of IPIPEIF */
++	utemp = config->ipipeif_param.mode << 0;
++	utemp |= config->ipipeif_param.decimation << 1;
++	utemp |= config->ipipeif_param.source << 2;
++	utemp |= config->ipipeif_param.clk_div << 4;
++	utemp |= config->ipipeif_param.avg_filter << 7;
++	utemp |= config->ipipeif_param.pack_mode << 8;
++	utemp |= config->ipipeif_param.ialaw << 9;
++	utemp |= config->ipipeif_param.clock_select << 10;
++	utemp |= config->ipipeif_param.data_shift << 11;
++	regw_if(utemp, IPIPEIF_GFG);
++	switch (config->ipipeif_param.source) {
++	case CCDC:
++		regw_if(config->ipipeif_param.gain, IPIPEIF_GAIN);
++		break;
++
++	case SDRAM_RAW:
++	case CCDC_DARKFM:
++		regw_if(config->ipipeif_param.gain, IPIPEIF_GAIN);
++
++	case SDRAM_YUV:
++		regw_if(config->ipipeif_param.glob_hor_size, IPIPEIF_PPLN);
++		regw_if(config->ipipeif_param.glob_ver_size, IPIPEIF_LPFR);
++		regw_if(config->ipipeif_param.hnum, IPIPEIF_HNUM);
++		regw_if(config->ipipeif_param.vnum, IPIPEIF_VNUM);
++		vpss_dm355_assign_rblctrl_master(DM355_RBLCTRL_IPIPEIF);
++		break;
++
++	}
++	/*check if decimation is enable or not */
++	decimation_en = config->ipipeif_param.decimation;
++	if (decimation_en)
++		regw_if(config->ipipeif_param.rsz, IPIPEIF_RSZ);
++
++	/*set GCL_ARM reg before writting to ipipe registers */
++	ipipe_enable_reg_write();
++
++	data_format =
++	    (config->ipipe_dpaths_fmt | (config->ipipe_dpaths_bypass) << 2);
++
++	vpss_dm355_assign_wblctrl_master(DM355_WBLCTRL_IPIPE);
++
++	/*enable ipipe mode to either one shot or continuous */
++	utemp = regr_ip(IPIPE_MODE);
++	RESETBIT(utemp, 0);	/*first reset mode bit and then set it by
++				   config->ipipe_mode */
++	utemp |= config->ipipe_mode;
++	regw_ip(utemp, IPIPE_MODE);
++	regw_ip(data_format, IPIPE_DPATHS);
++	/*set size */
++	regw_ip(config->ipipe_vst, IPIPE_VST);
++	regw_ip(config->ipipe_hst, IPIPE_HST);
++	regw_ip(config->ipipe_vsz, IPIPE_VSZ);
++	regw_ip(config->ipipe_hsz, IPIPE_HSZ);
++	switch (data_format) {
++	case IPIPE_RAW2YUV:
++
++		/*Combine all the fields to make COLPAT register of IPIPE */
++		utemp = (config->ipipe_colpat_elep << 0);
++		utemp |= (config->ipipe_colpat_elop << 2);
++		utemp |= (config->ipipe_colpat_olep << 4);
++		utemp |= (config->ipipe_colpat_olop << 6);
++
++		regw_ip(utemp, IPIPE_COLPAT);
++		ipipe_set_rsz_regs(config);	/*set RSZ_SEQ registers */
++		ipipe_set_aal_regs(config);	/*set RSZ_AAL registers */
++		/*set the registers of either RSZ0 or RSZ1 */
++		ipipe_set_rsz_structs(config);
++
++		break;
++
++	case IPIPE_RAW2RAW:
++		ipipe_set_aal_regs(config);	/*set RSZ_AAL registers */
++		/*set the registers of RSZ0 and RSZ1 */
++		ipipe_set_rsz_structs(config);	/*...................CHECK */
++		break;
++
++	case IPIPE_YUV2YUV:
++		ipipe_set_rsz_regs(config);	/*set RSZ_SEQ registers */
++		ipipe_set_aal_regs(config);	/*set RSZ_AAL registers */
++		/*set the registers of either RSZ0 or RSZ1 */
++		ipipe_set_rsz_structs(config);
++		break;
++	}
++	return 0;
++}
++
++int ipipe_set_resizer_address(struct ipipe_params *params,
++			      int resize_no, unsigned int address)
++{
++	unsigned int utemp;
++	unsigned int rsz_start_add;
++
++	printk(KERN_DEBUG "ipipe_set_resizer_address %d\n", resize_no);
++	if (ISNULL(params)) {
++		printk(KERN_ERR "null ptr for params\n");
++		return -1;
++	}
++
++	if ((resize_no != 0) && (resize_no != 1)) {
++		printk(KERN_ERR "invalid resizer number\n");
++		return -1;
++	}
++
++	if (resize_no)
++		rsz_start_add = RSZ_EN_1;
++	else
++		rsz_start_add = RSZ_EN_0;
++	utemp = address & SET_LOW_ADD;
++
++	/* resizer must be enabled */
++	regw_ip(params->rsz_en[resize_no], rsz_start_add);
++	if ((params->rsz_en[resize_no]) && (address == 0)) {
++		printk(KERN_ERR "invalid address for resizer %d\n", resize_no);
++		return -1;
++	}
++	regw_ip(params->ext_mem_param[resize_no].rsz_sdr_oft,
++		rsz_start_add + RSZ_SDR_OFT);
++
++	printk(KERN_DEBUG "ipipe_set_resizer_address = %x:%x\n", utemp,
++	       address);
++	regw_ip(utemp, rsz_start_add + RSZ_SDR_BAD_L);
++	regw_ip(utemp, rsz_start_add + RSZ_SDR_SAD_L);
++
++	utemp = (address & SET_HIGH_ADD) >> 16;
++	printk(KERN_DEBUG "ipipe_set_resizer_address = %x:%x\n", utemp,
++	       address);
++	regw_ip(utemp, rsz_start_add + RSZ_SDR_BAD_H);
++	regw_ip(utemp, rsz_start_add + RSZ_SDR_SAD_H);
++	return 0;
++}
++
++int ipipe_set_ipipeif_address(struct ipipe_params *params, unsigned int address)
++{
++	unsigned int utemp, utemp_h, utemp_l;
++	if (params->ipipeif_param.source != 0) {
++		regw_if(((params->ipipeif_param.adofs) >> 5), IPIPEIF_ADOFS);
++
++		/*lower sixteen bit */
++		utemp = address;
++		utemp_l = utemp >> 5;
++		regw_if(utemp_l, IPIPEIF_ADDRL);
++		/*upper next seven bit */
++		utemp_h = utemp >> 21;
++		regw_if(utemp_h, IPIPEIF_ADDRU);
++	} else {
++		return -1;
++	}
++	return 0;
++}
++
++/*default configuratins for RAW2RAW mode*/
++int ipipe_default_raw2raw(struct ipipe_params *parameter)
++{
++	u32 utemp;
++	u32 bright = 0;
++	u32 contrast = 16;
++
++	vpss_dm355_assign_dfc_memory_master(DM355_DFC_MEM_IPIPE);
++	vpss_dm355_assign_int_memory_master(DM355_INT_MEM_IPIPE);
++	vpss_dm355_ipipe_enable_any_address(1);
++	regw_ip(1, GCL_SDR);
++
++	/*set this to 0 for dafault config */
++	regw_ip(0, FCS_EN);
++	/*set this to 0 for dafault config */
++	regw_ip(0, YEE_EN);
++	/*set default brightness and contrast */
++	utemp = ((contrast << 0) | (bright << 8));
++	regw_ip(utemp, YUV_ADJ);
++
++	/*set default luminance */
++	regw_ip(0, YUV_Y_MIN);
++	regw_ip(255, YUV_Y_MAX);
++
++	/*set default chrominance */
++	regw_ip(0, YUV_C_MIN);
++	regw_ip(255, YUV_C_MAX);
++	/*default config for resizer 1  registers */
++	ipipe_default_bypass_resizer(parameter);
++	return 0;
++}
++
++/*default configuratins for RAW2RAW mode*/
++int ipipe_default_bypass_resizer(struct ipipe_params *parameter)
++{
++	u32 utemp;
++	int seq_tmm = 0;
++
++	regw_ip(1, GCL_SDR);
++
++	/*set this to 0 for dafault config */
++	utemp =
++	    (parameter->rsz_seq_seq << 0) | (seq_tmm << 1) | (parameter->
++							      rsz_seq_hrv << 2)
++	    | (parameter->rsz_seq_vrv << 3) | (parameter->rsz_seq_crv << 4);
++	regw_ip(utemp, RSZ_SEQ);
++	/*set this to 0 for dafault config */
++	regw_ip(1, RSZ_EN_0);
++	regw_ip(0, RSZ_EN_0 + RSZ_I_HST);
++	regw_ip(0, RSZ_EN_0 + RSZ_I_VST);
++	regw_ip(0, RSZ_EN_0 + RSZ_O_HST);
++	regw_ip(0, RSZ_EN_0 + RSZ_V_PHS);
++	regw_ip(256, RSZ_EN_0 + RSZ_V_DIF);
++	regw_ip(256, RSZ_EN_0 + RSZ_H_DIF);
++	regw_ip(0, RSZ_EN_0 + RSZ_H_PHS);
++	regw_ip(0, RSZ_EN_0 + RSZ_H_TYP);
++	regw_ip(0, RSZ_EN_0 + RSZ_H_LSE);
++	regw_ip(0, RSZ_EN_0 + RSZ_H_LPF);
++	regw_ip(0, RSZ_EN_0 + RSZ_RGB_EN);
++	/*disable resizer 0 in default mode */
++	regw_ip(0, RSZ_EN_1);
++	return 0;
++}
++
++/*default configuratins for RAW2RAW_bypass mode*/
++int ipipe_default_bypass_ycbcr(struct ipipe_params *parameter)
++{
++	/*disable noise filter in default config */
++	regw_ip(0, D2F_EN);
++	/*disable defect coorection in default config */
++	regw_ip(0, DFC_EN);
++	/*disable prefilter filter in default config */
++	regw_ip(0, PRE_EN);
++	/*set default config for white balance */
++	regw_ip(256, WB2_DGN);
++	regw_ip(128, WB2_WG_R);
++	regw_ip(128, WB2_WG_GR);
++	regw_ip(128, WB2_WG_GB);
++	regw_ip(128, WB2_WG_B);
++	return 0;
++}
++
++int ipipe_set_dfc_regs(struct prev_dfc *dfc)
++{
++	u32 utemp;
++	unsigned int count;
++
++	ipipe_enable_reg_write();
++	vpss_dm355_assign_wblctrl_master(DM355_WBLCTRL_IPIPE);
++	regw_ip(dfc->en, DFC_EN);	/*writting to enable register */
++	if (1 == dfc->en) {
++		regw_ip(dfc->vert_copy_method, DFC_SEL);
++		regw_ip(DEF_COR_START_ADDR, DFC_ADR);
++		regw_ip(dfc->dfc_size, DFC_SIZE);
++		vpss_dm355_assign_dfc_memory_master(DM355_DFC_MEM_IPIPE);
++
++		/* set the auto increment,write only,dfc mode in RAM_MODE */
++		regw_ip(0x0034, RAM_MODE);
++		regw_ip(0x00, RAM_ADR);
++		if (dfc->table != NULL) {
++			count = 0;
++			while (count < dfc->dfc_size) {
++				regw_ip(dfc->table[count].horz_pos, RAM_WDT);
++				printk(KERN_INFO "###RAM_WDT[%d] = %x\n", count,
++				       regr_ip(RAM_WDT));
++				/*write next fifteen bit */
++				utemp =
++				    (dfc->table[count].
++				     vert_pos | (dfc->table[count].
++						 method << 12));
++				regw_ip(utemp, RAM_WDT);
++				printk(KERN_INFO "RAM_WDT[%d] = %x\n", count,
++				       regr_ip(RAM_WDT));
++				count++;
++			}
++		}
++	}
++	return 0;
++}
++
++/* 2D Noise filter */
++int ipipe_set_d2f_nf_regs(struct prev_nf *noise_filter)
++{
++	u32 utemp;
++	int count = 0;
++
++	ipipe_enable_reg_write();
++	regw_ip(noise_filter->en, D2F_EN);
++	if (1 == noise_filter->en) {
++		/*Combine all the fields to make D2F_CFG register of IPIPE */
++		utemp =
++		    (noise_filter->spread_val << 0) |
++		    (noise_filter->shft_val << 2) |
++		    (noise_filter->gr_sample_meth << 4);
++		regw_ip(utemp, D2F_CFG);
++		count = 0;
++		while (count < IPIPE_NF_STR_TABLE_SIZE) {
++			regw_ip(noise_filter->str[count], D2F_STR + count * 4);
++			count++;
++		}
++		count = 0;
++		while (count < IPIPE_NF_THR_TABLE_SIZE) {
++			regw_ip(noise_filter->thr[count], DFC_THR + count * 4);
++			count++;
++		}
++	}
++	return 0;
++}
++
++/* Pre filter */
++int ipipe_set_pf_regs(struct prev_prefilter *pre_filter)
++{
++	u32 utemp;
++
++	ipipe_enable_reg_write();
++	regw_ip(pre_filter->en, PRE_EN);
++	if (1 == pre_filter->en) {
++		/*Combine all the fields to make PRE_EN register of IPIPE */
++		utemp = ((pre_filter->aver_meth_gs2 << 0) |
++			 (pre_filter->aver_meth_gs1 << 1) |
++			 (pre_filter->en_adapt_prefilter << 2) |
++			 (pre_filter->en_adapt_dotred << 3));
++		regw_ip(utemp, PRE_TYP);
++		regw_ip(pre_filter->pre_shf, PRE_SHF);
++		regw_ip(pre_filter->pre_gain, PRE_GAIN);
++		regw_ip(pre_filter->pre_thr_g, PRE_THR_G);
++		regw_ip(pre_filter->pre_thr_b, PRE_THR_B);
++		regw_ip(pre_filter->pre_thr_1, PRE_THR_1);
++	}
++	return 0;
++}
++
++/* White balance */
++#define IPIPE_U10Q7(decimal,integer) \
++	(((decimal & 0x7f) | ((integer & 0x7) << 7)))
++#define IPIPE_U10Q8(decimal,integer) \
++	(((decimal & 0xff) | ((integer & 0x3) << 8)))
++int ipipe_set_wb_regs(struct prev_wb *wb)
++{
++	u32 utemp;
++
++	/* U10Q7 */
++	utemp = IPIPE_U10Q8((wb->dgn.decimal), (wb->dgn.integer));
++	ipipe_enable_reg_write();
++	regw_ip(utemp, WB2_DGN);
++	utemp = IPIPE_U10Q7((wb->gain_r.decimal), (wb->gain_r.integer));
++	regw_ip(utemp, WB2_WG_R);
++	utemp = IPIPE_U10Q7((wb->gain_gr.decimal), (wb->gain_gr.integer));
++	regw_ip(utemp, WB2_WG_GR);
++	utemp = IPIPE_U10Q7((wb->gain_gb.decimal), (wb->gain_gb.integer));
++	regw_ip(utemp, WB2_WG_GB);
++	utemp = IPIPE_U10Q7((wb->gain_b.decimal), (wb->gain_b.integer));
++	regw_ip(utemp, WB2_WG_B);
++	return 0;
++}
++
++#define IPIPE_S10Q8(decimal,integer) \
++	(((decimal & 0xff) | ((integer & 0x3) << 8)))
++/* RGB2YUV */
++int ipipe_set_rgb2ycbcr_regs(struct prev_rgb2yuv *yuv)
++{
++	u32 utemp;
++
++	/* S10Q8 */
++	ipipe_enable_reg_write();
++	utemp = IPIPE_S10Q8((yuv->coef_ry.decimal), (yuv->coef_ry.integer));
++	regw_ip(utemp, YUV_MUL_RY);
++	utemp = IPIPE_S10Q8((yuv->coef_gy.decimal), (yuv->coef_gy.integer));
++	regw_ip(utemp, YUV_MUL_GY);
++	utemp = IPIPE_S10Q8((yuv->coef_by.decimal), (yuv->coef_by.integer));
++	regw_ip(utemp, YUV_MUL_BY);
++	utemp = IPIPE_S10Q8((yuv->coef_rcb.decimal), (yuv->coef_rcb.integer));
++	regw_ip(utemp, YUV_MUL_RCB);
++	utemp = IPIPE_S10Q8((yuv->coef_gcb.decimal), (yuv->coef_gcb.integer));
++	regw_ip(utemp, YUV_MUL_GCB);
++	utemp = IPIPE_S10Q8((yuv->coef_bcb.decimal), (yuv->coef_bcb.integer));
++	regw_ip(utemp, YUV_MUL_BCB);
++	utemp = IPIPE_S10Q8((yuv->coef_rcr.decimal), (yuv->coef_rcr.integer));
++	regw_ip(utemp, YUV_MUL_RCR);
++	utemp = IPIPE_S10Q8((yuv->coef_gcr.decimal), (yuv->coef_gcr.integer));
++	regw_ip(utemp, YUV_MUL_GCR);
++	utemp = IPIPE_S10Q8((yuv->coef_bcr.decimal), (yuv->coef_bcr.integer));
++	regw_ip(utemp, YUV_MUL_BCR);
++	regw_ip(yuv->out_ofst_y, YUV_OFT_Y);
++	regw_ip(yuv->out_ofst_cb, YUV_OFT_CB);
++	regw_ip(yuv->out_ofst_cr, YUV_OFT_CR);
++	return 0;
++}
++
++/* Lumina adjustments */
++int ipipe_set_lum_adj_regs(struct prev_lum_adj *lum_adj)
++{
++	u32 utemp;
++
++	ipipe_enable_reg_write();
++	/*combine fields of YUV_ADJ to set brightness and contrast */
++	utemp = ((lum_adj->contast << 0) | (lum_adj->brightness << 8));
++	regw_ip(utemp, YUV_ADJ);
++	return 0;
++}
++
++/* YUV 422 conversion */
++int ipipe_set_yuv422_conv_regs(struct prev_yuv422_conv *conv)
++{
++	u32 utemp;
++
++	ipipe_enable_reg_write();
++	regw_ip(conv->lum_min, YUV_Y_MIN);
++	regw_ip(conv->lum_max, YUV_Y_MAX);
++	regw_ip(conv->chrom_min, YUV_C_MIN);
++	regw_ip(conv->chrom_max, YUV_C_MAX);
++	/*Combine all the fields to make YUV_PHS register of IPIPE */
++	utemp = ((conv->chrom_pos << 0) | (conv->en_chrom_lpf << 1));
++	regw_ip(utemp, YUV_PHS);
++	return 0;
++}
++
++/* rgb2rgb conversion */
++#define IPIPE_S12Q8(decimal,integer) \
++	(((decimal & 0xff) | ((integer & 0xf) << 8)))
++
++int ipipe_set_rgb2rgb_regs(struct prev_rgb2rgb *rgb)
++{
++	u32 utemp;
++
++	ipipe_enable_reg_write();
++	utemp = IPIPE_S12Q8((rgb->coef_rr.decimal), (rgb->coef_rr.integer));
++	regw_ip(utemp, RGB_MUL_RR);
++	utemp = IPIPE_S12Q8((rgb->coef_gr.decimal), (rgb->coef_gr.integer));
++	regw_ip(utemp, RGB_MUL_GR);
++	utemp = IPIPE_S12Q8((rgb->coef_br.decimal), (rgb->coef_br.integer));
++	regw_ip(utemp, RGB_MUL_BR);
++	utemp = IPIPE_S12Q8((rgb->coef_rg.decimal), (rgb->coef_rg.integer));
++	regw_ip(utemp, RGB_MUL_RG);
++	utemp = IPIPE_S12Q8((rgb->coef_gg.decimal), (rgb->coef_gg.integer));
++	regw_ip(utemp, RGB_MUL_GG);
++	utemp = IPIPE_S12Q8((rgb->coef_bg.decimal), (rgb->coef_bg.integer));
++	regw_ip(utemp, RGB_MUL_BG);
++	utemp = IPIPE_S12Q8((rgb->coef_rb.decimal), (rgb->coef_rb.integer));
++	regw_ip(utemp, RGB_MUL_RB);
++	utemp = IPIPE_S12Q8((rgb->coef_gb.decimal), (rgb->coef_gb.integer));
++	regw_ip(utemp, RGB_MUL_GB);
++	utemp = IPIPE_S12Q8((rgb->coef_bb.decimal), (rgb->coef_bb.integer));
++	regw_ip(utemp, RGB_MUL_BB);
++	regw_ip(rgb->out_ofst_r, RGB_MUL_OR);
++	regw_ip(rgb->out_ofst_g, RGB_MUL_OG);
++	regw_ip(rgb->out_ofst_b, RGB_MUL_OB);
++	return 0;
++}
++
++/* Gamma correction */
++int ipipe_set_gamma_regs(struct prev_gamma *gamma)
++{
++	u32 utemp;
++	int count, table_size = 0;
++
++	ipipe_enable_reg_write();
++	utemp = ((gamma->bypass_r << 0) |
++		 (gamma->bypass_b << 1) |
++		 (gamma->bypass_g << 2) |
++		 (gamma->tbl_sel << 4) | (gamma->tbl_size << 5));
++
++	regw_ip(utemp, GMM_CFG);
++
++	vpss_dm355_assign_wblctrl_master(DM355_WBLCTRL_IPIPE);
++	if (gamma->tbl_sel == IPIPE_GAMMA_TBL_RAM) {
++		if (gamma->tbl_size == IPIPE_GAMMA_TBL_SZ_128)
++			table_size = 128;
++		else if (gamma->tbl_size == IPIPE_GAMMA_TBL_SZ_256)
++			table_size = 256;
++		else if (gamma->tbl_size == IPIPE_GAMMA_TBL_SZ_512)
++			table_size = 512;
++		if (!(gamma->bypass_r)) {
++			if (gamma->table_r != NULL) {
++				/*set the auto increment,write only, gamma
++				   red mode in RAM_MODE */
++				regw_ip(0x0035, RAM_MODE);
++				/*set the starting address of gamma table */
++				regw_ip(0x00, RAM_ADR);
++
++				for (count = 0; count < table_size; count++) {
++					regw_ip(gamma->table_r[count].slope,
++						RAM_WDT);
++					regw_ip(gamma->table_r[count].offset,
++						RAM_WDT);
++				}
++			}
++		}
++		if (!(gamma->bypass_b)) {
++			if (gamma->table_b != NULL) {
++				/*set the auto increment,write only,
++				   gamma red mode in RAM_MODE */
++				regw_ip(0x0036, RAM_MODE);
++				/*set the starting address of gamma table */
++				regw_ip(0x00, RAM_ADR);
++				for (count = 0; count < table_size; count++) {
++					regw_ip(gamma->table_b[count].slope,
++						RAM_WDT);
++					regw_ip(gamma->table_b[count].offset,
++						RAM_WDT);
++				}
++			}
++		}
++		if (!(gamma->bypass_g)) {
++			if (gamma->table_g != NULL) {
++				/*set the auto increment,write only, gamma red
++				   mode in RAM_MODE */
++				regw_ip(0x0037, RAM_MODE);
++				/*set the starting address of gamma table */
++				regw_ip(0x00, RAM_ADR);
++				for (count = 0; count < table_size; count++) {
++					regw_ip(gamma->table_g[count].slope,
++						RAM_WDT);
++					regw_ip(gamma->table_g[count].offset,
++						RAM_WDT);
++				}
++			}
++		}
++
++		/*set the auto increment,write only, gamma red mode in
++		   RAM_MODE */
++		regw_ip(0x0038, RAM_MODE);
++		/*set the starting address of gamma table */
++		regw_ip(0x00, RAM_ADR);
++		if (gamma->table_rgb_all != NULL) {
++			for (count = 0; count < table_size; count++) {
++				regw_ip(gamma->table_rgb_all[count].slope,
++					RAM_WDT);
++				regw_ip(gamma->table_rgb_all[count].offset,
++					RAM_WDT);
++			}
++		}
++		regw_ip(0x00, RAM_MODE);
++	}
++	return 0;
++}
++
++/* Edge Enhancement */
++int ipipe_set_ee_regs(struct prev_yee *ee)
++{
++	unsigned int count;
++
++	ipipe_enable_reg_write();
++	vpss_dm355_assign_wblctrl_master(DM355_WBLCTRL_IPIPE);
++	regw_ip(ee->en, YEE_EN);
++	if (1 == ee->en) {
++		regw_ip(ee->en_emf, YEE_EMF);
++		regw_ip(ee->hpf_shft, YEE_SHF);
++		regw_ip(ee->hpf_coef_00, YEE_MUL_00);
++		regw_ip(ee->hpf_coef_01, YEE_MUL_01);
++		regw_ip(ee->hpf_coef_02, YEE_MUL_02);
++		regw_ip(ee->hpf_coef_10, YEE_MUL_10);
++		regw_ip(ee->hpf_coef_11, YEE_MUL_11);
++		regw_ip(ee->hpf_coef_12, YEE_MUL_12);
++		regw_ip(ee->hpf_coef_20, YEE_MUL_20);
++		regw_ip(ee->hpf_coef_21, YEE_MUL_21);
++		regw_ip(ee->hpf_coef_22, YEE_MUL_22);
++
++		/*set the auto increment,write only,ee mode in RAM_MODE */
++		regw_ip(0x0039, RAM_MODE);
++		regw_ip(0x000 /*0x1FF */ , RAM_ADR);
++		if (ee->table != NULL) {
++			for (count = 0; count < MAX_SIZE_EEC; count++)
++				regw_ip(ee->table[count], RAM_WDT);
++		}
++	}
++	return 0;
++}
++
++/* False color suppression */
++int ipipe_set_fcs_regs(struct prev_fcs *fcs)
++{
++	ipipe_enable_reg_write();
++	regw_ip(fcs->en, FCS_EN);
++	if (1 == fcs->en) {
++		regw_ip(fcs->type, FCS_TYP);
++		regw_ip(fcs->hpf_shft_y, FCS_SHF_Y);
++		regw_ip(fcs->gain_shft_c, FCS_SHF_C);
++		regw_ip(fcs->thr, FCS_THR);
++		regw_ip(fcs->sgn, FCS_SGN);
++		regw_ip(fcs->lth, FCS_LTH);
++	}
++	return 0;
++}
++
++int ipipe_set_rsz_regs(struct ipipe_params *param_resize)
++{
++	u32 utemp;
++	ipipe_enable_reg_write();
++	/*Combine all the fields to make RSZ_SEQ register of IPIPE */
++	utemp =
++	    (param_resize->rsz_seq_seq << 0) |
++	    (param_resize->rsz_seq_tmm << 1) |
++	    (param_resize->rsz_seq_hrv << 2) |
++	    (param_resize->rsz_seq_vrv << 3) | (param_resize->rsz_seq_crv << 4);
++	regw_ip(utemp, RSZ_SEQ);
++	return 0;
++}
++
++int ipipe_set_aal_regs(struct ipipe_params *param_resize)
++{
++	regw_ip(param_resize->rsz_aal, RSZ_AAL);
++	return 0;
++}
++
++int ipipe_set_output_size(struct ipipe_params *params)
++{
++	vpss_dm355_assign_dfc_memory_master(DM355_DFC_MEM_IPIPE);
++	vpss_dm355_assign_int_memory_master(DM355_INT_MEM_IPIPE);
++	vpss_dm355_ipipe_enable_any_address(1);
++	regw_ip(1, GCL_SDR);
++	/*setting rescale parameters */
++	regw_ip(params->rsz_rsc_param[0].rsz_o_vsz, RSZ_EN_0 + RSZ_O_VSZ);
++	regw_ip(params->rsz_rsc_param[0].rsz_o_hsz, RSZ_EN_0 + RSZ_O_HSZ);
++	regw_ip(params->rsz_rsc_param[0].rsz_v_dif, RSZ_EN_0 + RSZ_V_DIF);
++	regw_ip(params->rsz_rsc_param[0].rsz_h_dif, RSZ_EN_0 + RSZ_H_DIF);
++	regw_ip(params->rsz_rsc_param[1].rsz_o_vsz, RSZ_EN_1 + RSZ_O_VSZ);
++	regw_ip(params->rsz_rsc_param[1].rsz_o_hsz, RSZ_EN_1 + RSZ_O_HSZ);
++	regw_ip(params->rsz_rsc_param[1].rsz_v_dif, RSZ_EN_1 + RSZ_V_DIF);
++	regw_ip(params->rsz_rsc_param[1].rsz_h_dif, RSZ_EN_1 + RSZ_H_DIF);
++	return 0;
++}
++
++int ipipe_set_output_offsets(int resizer, struct ipipe_params *params)
++{
++	regw_ip(1, GCL_SDR);
++	if (resizer == 0) {
++		regw_ip(params->ext_mem_param[0].rsz_sdr_oft,
++			RSZ_EN_0 + RSZ_SDR_OFT);
++		regw_ip(params->ext_mem_param[0].rsz_sdr_ptr_s,
++			RSZ_EN_0 + RSZ_SDR_PTR_S);
++		regw_ip(params->ext_mem_param[0].rsz_sdr_ptr_e,
++			RSZ_EN_0 + RSZ_SDR_PTR_E);
++
++	} else {
++		regw_ip(params->ext_mem_param[1].rsz_sdr_oft,
++			RSZ_EN_0 + RSZ_SDR_OFT);
++		regw_ip(params->ext_mem_param[0].rsz_sdr_ptr_s,
++			RSZ_EN_0 + RSZ_SDR_PTR_S);
++		regw_ip(params->ext_mem_param[0].rsz_sdr_ptr_e,
++			RSZ_EN_0 + RSZ_SDR_PTR_E);
++	}
++	return 0;
++}
++
++int rsz_enable(int rsz_id, int enable)
++{
++	if (enable != 1)
++		enable = 0;
++	switch (rsz_id) {
++	case 0:
++		regw_ip(enable, RSZ_EN_0);
++		break;
++	case 1:
++		regw_ip(enable, RSZ_EN_1);
++		break;
++	default:
++		return -EINVAL;
++	}
++	return 0;
++}
++
++int ipipe_set_rsz_structs(struct ipipe_params *params)
++{				/*set the registers of either RSZ0 or RSZ1 */
++	u32 utemp;
++	u32 rsz_seq, rsz_tmm;
++
++	vpss_dm355_assign_dfc_memory_master(DM355_DFC_MEM_IPIPE);
++	vpss_dm355_assign_int_memory_master(DM355_INT_MEM_IPIPE);
++	vpss_dm355_ipipe_enable_any_address(1);
++	regw_ip(params->rsz_en[0], RSZ_EN_0);
++	if (params->rsz_en[0]) {
++		printk(KERN_DEBUG
++		       "ipipe_set_rsz_structs, resizer - 0 enabled\n");
++		/*testing--- for register write */
++		utemp = regr_ip(RSZ_EN_0);
++		/*enable RSZ clock */
++		regw_ip(1, GCL_SDR);
++		/*setting rescale parameters */
++		regw_ip(params->rsz_rsc_param[0].rsz_mode, RSZ_EN_0 + RSZ_MODE);
++		regw_ip(params->rsz_rsc_param[0].rsz_i_vst,
++			RSZ_EN_0 + RSZ_I_VST);
++		regw_ip(params->rsz_rsc_param[0].rsz_i_vsz,
++			RSZ_EN_0 + RSZ_I_VSZ);
++		regw_ip(params->rsz_rsc_param[0].rsz_i_hst,
++			RSZ_EN_0 + RSZ_I_HST);
++		regw_ip(params->rsz_rsc_param[0].rsz_o_vsz,
++			RSZ_EN_0 + RSZ_O_VSZ);
++		regw_ip(params->rsz_rsc_param[0].rsz_o_hsz,
++			RSZ_EN_0 + RSZ_O_HSZ);
++		regw_ip(params->rsz_rsc_param[0].rsz_o_hst,
++			RSZ_EN_0 + RSZ_O_HST);
++		regw_ip(params->rsz_rsc_param[0].rsz_v_phs,
++			RSZ_EN_0 + RSZ_V_PHS);
++		regw_ip(params->rsz_rsc_param[0].rsz_v_dif,
++			RSZ_EN_0 + RSZ_V_DIF);
++		regw_ip(params->rsz_rsc_param[0].rsz_h_phs,
++			RSZ_EN_0 + RSZ_H_PHS);
++		regw_ip(params->rsz_rsc_param[0].rsz_h_dif,
++			RSZ_EN_0 + RSZ_H_DIF);
++		regw_ip(params->rsz_rsc_param[0].rsz_h_typ,
++			RSZ_EN_0 + RSZ_H_TYP);
++		regw_ip(params->rsz_rsc_param[0].rsz_h_lse_sel,
++			RSZ_EN_0 + RSZ_H_LSE);
++		regw_ip(params->rsz_rsc_param[0].rsz_h_lpf,
++			RSZ_EN_0 + RSZ_H_LPF);
++
++		/*seting rgb conversion parameters */
++		regw_ip(params->rsz2rgb[0].rsz_rgb_en, RSZ_EN_0 + RSZ_RGB_EN);
++		regw_ip(params->rsz2rgb[0].rsz_rgb_en, RSZ_EN_0 + RSZ_RGB_EN);
++		utemp =
++		    ((params->rsz2rgb[0].rsz_rgb_typ << 0) |
++		     (params->rsz2rgb[0].rsz_rgb_msk0 << 1) |
++		     (params->rsz2rgb[0].rsz_rgb_msk1) << 2);
++		regw_ip(utemp, RSZ_RGB_TYP);
++		regw_ip(params->rsz2rgb[0].rsz_rgb_alpha_val,
++			RSZ_EN_0 + RSZ_RGB_BLD);
++
++		/*setting external memory parameters */
++		regw_ip(params->ext_mem_param[0].rsz_sdr_oft,
++			RSZ_EN_0 + RSZ_SDR_OFT);
++		regw_ip(params->ext_mem_param[0].rsz_sdr_ptr_s,
++			RSZ_EN_0 + RSZ_SDR_PTR_S);
++		regw_ip(params->ext_mem_param[0].rsz_sdr_ptr_e,
++			RSZ_EN_0 + RSZ_SDR_PTR_E);
++	}
++
++	regw_ip(params->rsz_en[1], RSZ_EN_1);
++	if (params->rsz_en[1]) {
++		/*testing---- for register write */
++		utemp = regr_ip(RSZ_EN_1);
++
++		/*enable RSZ clock */
++		regw_ip(1, GCL_SDR);
++		/*setting rescale parameters */
++		regw_ip(params->rsz_rsc_param[1].rsz_mode, RSZ_EN_1 + RSZ_MODE);
++		regw_ip(params->rsz_rsc_param[1].rsz_i_vst,
++			RSZ_EN_1 + RSZ_I_VST);
++		regw_ip(params->rsz_rsc_param[1].rsz_i_vsz,
++			RSZ_EN_1 + RSZ_I_VSZ);
++		regw_ip(params->rsz_rsc_param[1].rsz_i_hst,
++			RSZ_EN_1 + RSZ_I_HST);
++		regw_ip(params->rsz_rsc_param[1].rsz_o_vsz,
++			RSZ_EN_1 + RSZ_O_VSZ);
++		regw_ip(params->rsz_rsc_param[1].rsz_o_hsz,
++			RSZ_EN_1 + RSZ_O_HSZ);
++		regw_ip(params->rsz_rsc_param[1].rsz_o_hst,
++			RSZ_EN_1 + RSZ_O_HST);
++		regw_ip(params->rsz_rsc_param[1].rsz_v_phs,
++			RSZ_EN_1 + RSZ_V_PHS);
++		regw_ip(params->rsz_rsc_param[1].rsz_v_dif,
++			RSZ_EN_1 + RSZ_V_DIF);
++		regw_ip(params->rsz_rsc_param[1].rsz_h_phs,
++			RSZ_EN_1 + RSZ_H_PHS);
++		regw_ip(params->rsz_rsc_param[1].rsz_h_dif,
++			RSZ_EN_1 + RSZ_H_DIF);
++		regw_ip(params->rsz_rsc_param[1].rsz_h_typ,
++			RSZ_EN_1 + RSZ_H_TYP);
++		regw_ip(params->rsz_rsc_param[1].rsz_h_lse_sel,
++			RSZ_EN_1 + RSZ_H_LSE);
++		regw_ip(params->rsz_rsc_param[1].rsz_h_lpf,
++			RSZ_EN_1 + RSZ_H_LPF);
++
++		/*seting rgb conversion parameters */
++		regw_ip(params->rsz2rgb[1].rsz_rgb_en, RSZ_EN_1 + RSZ_RGB_EN);
++		regw_ip(params->rsz2rgb[1].rsz_rgb_en, RSZ_EN_1 + RSZ_RGB_EN);
++		utemp =
++		    ((params->rsz2rgb[1].rsz_rgb_typ << 0) |
++		     (params->rsz2rgb[1].rsz_rgb_msk0 << 1) |
++		     (params->rsz2rgb[1].rsz_rgb_msk1) << 2);
++		regw_ip(utemp, RSZ_RGB_TYP);
++		regw_ip(params->rsz2rgb[1].rsz_rgb_alpha_val,
++			RSZ_EN_1 + RSZ_RGB_BLD);
++
++		/*setting external memory parameters */
++		regw_ip(params->ext_mem_param[1].rsz_sdr_oft,
++			RSZ_EN_1 + RSZ_SDR_OFT);
++		regw_ip(params->ext_mem_param[1].rsz_sdr_ptr_s,
++			RSZ_EN_1 + RSZ_SDR_PTR_S);
++		regw_ip(params->ext_mem_param[1].rsz_sdr_ptr_e,
++			RSZ_EN_1 + RSZ_SDR_PTR_E);
++	}
++
++	if (!params->rsz_en[0] && !params->rsz_en[1]) {	/*resizer bypass mode */
++		rsz_tmm = 0;
++		rsz_seq = 0;
++		utemp =
++		    (params->rsz_seq_seq << 0) |
++		    (params->rsz_seq_tmm << 1) |
++		    (params->rsz_seq_hrv << 2) |
++		    (params->rsz_seq_vrv << 3) | (params->rsz_seq_crv << 4);
++		regw_ip(0, RSZ_AAL);
++		regw_ip(0, RSZ_EN_0 + RSZ_O_HST);
++		regw_ip(0, RSZ_EN_0 + RSZ_V_PHS);
++		regw_ip(256, RSZ_EN_0 + RSZ_V_DIF);
++		regw_ip(256, RSZ_EN_0 + RSZ_H_DIF);
++		regw_ip(0, RSZ_EN_0 + RSZ_H_LSE);
++		regw_ip(0, RSZ_EN_0 + RSZ_H_PHS);
++		regw_ip(0, RSZ_EN_1);
++		/*disable resizer clock, necessary to bypass resizer */
++		regw_ip(0, GCL_SDR);
++	}
++
++	utemp = regr_ip((RSZ_EN_0 + RSZ_SDR_BAD_H));
++	utemp = regr_ip((RSZ_EN_0 + RSZ_SDR_SAD_H));
++	return 0;
++}
+--- a/arch/arm/mach-davinci/devices-da8xx.c
++++ b/arch/arm/mach-davinci/devices-da8xx.c
+@@ -21,7 +21,6 @@
+ #include <mach/common.h>
+ #include <mach/time.h>
+ #include <mach/da8xx.h>
+-#include <video/da8xx-fb.h>
+ 
+ #include "clock.h"
+ 
+@@ -30,6 +29,7 @@
+ #define DA8XX_TPTC1_BASE		0x01c08400
+ #define DA8XX_WDOG_BASE			0x01c21000 /* DA8XX_TIMER64P1_BASE */
+ #define DA8XX_I2C0_BASE			0x01c22000
++#define DA8XX_RTC_BASE			0x01C23000
+ #define DA8XX_EMAC_CPPI_PORT_BASE	0x01e20000
+ #define DA8XX_EMAC_CPGMACSS_BASE	0x01e22000
+ #define DA8XX_EMAC_CPGMAC_BASE		0x01e23000
+@@ -43,6 +43,8 @@
+ #define DA8XX_MDIO_REG_OFFSET		0x4000
+ #define DA8XX_EMAC_CTRL_RAM_SIZE	SZ_8K
+ 
++void __iomem *da8xx_syscfg_base;
++
+ static struct plat_serial8250_port da8xx_serial_pdata[] = {
+ 	{
+ 		.mapbase	= DA8XX_UART0_BASE,
+@@ -81,11 +83,6 @@ struct platform_device da8xx_serial_devi
+ 	},
+ };
+ 
+-static const s8 da8xx_dma_chan_no_event[] = {
+-	20, 21,
+-	-1
+-};
+-
+ static const s8 da8xx_queue_tc_mapping[][2] = {
+ 	/* {event queue no, TC no} */
+ 	{0, 0},
+@@ -107,7 +104,6 @@ static struct edma_soc_info da8xx_edma_i
+ 		.n_slot			= 128,
+ 		.n_tc			= 2,
+ 		.n_cc			= 1,
+-		.noevent		= da8xx_dma_chan_no_event,
+ 		.queue_tc_mapping	= da8xx_queue_tc_mapping,
+ 		.queue_priority_mapping	= da8xx_queue_priority_mapping,
+ 	},
+@@ -282,6 +278,11 @@ static struct platform_device da8xx_emac
+ 	.resource	= da8xx_emac_resources,
+ };
+ 
++int __init da8xx_register_emac(void)
++{
++	return platform_device_register(&da8xx_emac_device);
++}
++
+ static struct resource da830_mcasp1_resources[] = {
+ 	{
+ 		.name	= "mcasp1",
+@@ -338,12 +339,7 @@ static struct platform_device da850_mcas
+ 	.resource	= da850_mcasp_resources,
+ };
+ 
+-int __init da8xx_register_emac(void)
+-{
+-	return platform_device_register(&da8xx_emac_device);
+-}
+-
+-void __init da8xx_init_mcasp(int id, struct snd_platform_data *pdata)
++void __init da8xx_register_mcasp(int id, struct snd_platform_data *pdata)
+ {
+ 	/* DA830/OMAP-L137 has 3 instances of McASP */
+ 	if (cpu_is_davinci_da830() && id == 1) {
+@@ -379,10 +375,16 @@ static struct lcd_ctrl_config lcd_cfg =
+ 	.raster_order		= 0,
+ };
+ 
+-static struct da8xx_lcdc_platform_data da850_evm_lcdc_pdata = {
+-	.manu_name = "sharp",
+-	.controller_data = &lcd_cfg,
+-	.type = "Sharp_LK043T1DG01",
++struct da8xx_lcdc_platform_data sharp_lcd035q3dg01_pdata = {
++	.manu_name		= "sharp",
++	.controller_data	= &lcd_cfg,
++	.type			= "Sharp_LCD035Q3DG01",
++};
++
++struct da8xx_lcdc_platform_data sharp_lk043t1dg01_pdata = {
++	.manu_name		= "sharp",
++	.controller_data	= &lcd_cfg,
++	.type			= "Sharp_LK043T1DG01",
+ };
+ 
+ static struct resource da8xx_lcdc_resources[] = {
+@@ -398,19 +400,17 @@ static struct resource da8xx_lcdc_resour
+ 	},
+ };
+ 
+-static struct platform_device da850_lcdc_device = {
++static struct platform_device da8xx_lcdc_device = {
+ 	.name		= "da8xx_lcdc",
+ 	.id		= 0,
+ 	.num_resources	= ARRAY_SIZE(da8xx_lcdc_resources),
+ 	.resource	= da8xx_lcdc_resources,
+-	.dev = {
+-		.platform_data = &da850_evm_lcdc_pdata,
+-	}
+ };
+ 
+-int __init da8xx_register_lcdc(void)
++int __init da8xx_register_lcdc(struct da8xx_lcdc_platform_data *pdata)
+ {
+-	return platform_device_register(&da850_lcdc_device);
++	da8xx_lcdc_device.dev.platform_data = pdata;
++	return platform_device_register(&da8xx_lcdc_device);
+ }
+ 
+ static struct resource da8xx_mmcsd0_resources[] = {
+@@ -448,3 +448,37 @@ int __init da8xx_register_mmcsd0(struct
+ 	da8xx_mmcsd0_device.dev.platform_data = config;
+ 	return platform_device_register(&da8xx_mmcsd0_device);
+ }
++
++static struct resource da8xx_rtc_resources[] = {
++	{
++		.start		= DA8XX_RTC_BASE,
++		.end		= DA8XX_RTC_BASE + SZ_4K - 1,
++		.flags		= IORESOURCE_MEM,
++	},
++	{ /* timer irq */
++		.start		= IRQ_DA8XX_RTC,
++		.end		= IRQ_DA8XX_RTC,
++		.flags		= IORESOURCE_IRQ,
++	},
++	{ /* alarm irq */
++		.start		= IRQ_DA8XX_RTC,
++		.end		= IRQ_DA8XX_RTC,
++		.flags		= IORESOURCE_IRQ,
++	},
++};
++
++static struct platform_device da8xx_rtc_device = {
++	.name           = "omap_rtc",
++	.id             = -1,
++	.num_resources	= ARRAY_SIZE(da8xx_rtc_resources),
++	.resource	= da8xx_rtc_resources,
++};
++
++int da8xx_register_rtc(void)
++{
++	/* Unlock the rtc's registers */
++	__raw_writel(0x83e70b13, IO_ADDRESS(DA8XX_RTC_BASE + 0x6c));
++	__raw_writel(0x95a4f1e0, IO_ADDRESS(DA8XX_RTC_BASE + 0x70));
++
++	return platform_device_register(&da8xx_rtc_device);
++}
+--- a/drivers/media/video/davinci/vpif_display.h
++++ b/drivers/media/video/davinci/vpif_display.h
+@@ -154,7 +154,7 @@ struct vpif_device {
+ 	struct v4l2_device v4l2_dev;
+ 	struct channel_obj *dev[VPIF_DISPLAY_NUM_CHANNELS];
+ 	struct v4l2_subdev **sd;
+-
++	struct clk *vpif_clk;
+ };
+ 
+ struct vpif_config_params {
+--- /dev/null
++++ b/arch/arm/mach-davinci/include/mach/usb.h
+@@ -0,0 +1,57 @@
++/*
++ * USB related definitions
++ *
++ * Copyright (C) 2009 MontaVista Software, Inc. <source@mvista.com>
++ *
++ * This file is licensed under the terms of the GNU General Public License
++ * version 2. This program is licensed "as is" without any warranty of any
++ * kind, whether express or implied.
++ */
++
++#ifndef __ASM_ARCH_USB_H
++#define __ASM_ARCH_USB_H
++
++/* DA8xx CFGCHIP2 (USB 2.0 PHY Control) register bits */
++#define CFGCHIP2_PHYCLKGD	(1 << 17)
++#define CFGCHIP2_VBUSSENSE	(1 << 16)
++#define CFGCHIP2_RESET		(1 << 15)
++#define CFGCHIP2_OTGMODE	(3 << 13)
++#define CFGCHIP2_NO_OVERRIDE	(0 << 13)
++#define CFGCHIP2_FORCE_HOST	(1 << 13)
++#define CFGCHIP2_FORCE_DEVICE 	(2 << 13)
++#define CFGCHIP2_FORCE_HOST_VBUS_LOW (3 << 13)
++#define CFGCHIP2_USB1PHYCLKMUX	(1 << 12)
++#define CFGCHIP2_USB2PHYCLKMUX	(1 << 11)
++#define CFGCHIP2_PHYPWRDN	(1 << 10)
++#define CFGCHIP2_OTGPWRDN	(1 << 9)
++#define CFGCHIP2_DATPOL 	(1 << 8)
++#define CFGCHIP2_USB1SUSPENDM	(1 << 7)
++#define CFGCHIP2_PHY_PLLON	(1 << 6)	/* override PLL suspend */
++#define CFGCHIP2_SESENDEN	(1 << 5)	/* Vsess_end comparator */
++#define CFGCHIP2_VBDTCTEN	(1 << 4)	/* Vbus comparator */
++#define CFGCHIP2_REFFREQ	(0xf << 0)
++#define CFGCHIP2_REFFREQ_12MHZ	(1 << 0)
++#define CFGCHIP2_REFFREQ_24MHZ	(2 << 0)
++#define CFGCHIP2_REFFREQ_48MHZ	(3 << 0)
++
++struct	da8xx_ohci_root_hub;
++
++typedef void (*da8xx_ocic_handler_t)(struct da8xx_ohci_root_hub *hub,
++				     unsigned port);
++
++/* Passed as the platform data to the OHCI driver */
++struct	da8xx_ohci_root_hub {
++	/* Switch the port power on/off */
++	int	(*set_power)(unsigned port, int on);
++	/* Read the port power status */
++	int	(*get_power)(unsigned port);
++	/* Read the port over-current indicator */
++	int	(*get_oci)(unsigned port);
++	/* Over-current indicator change notification (pass NULL to disable) */
++	int	(*ocic_notify)(da8xx_ocic_handler_t handler);
++
++	/* Time from power on to power good (in 2 ms units) */
++	u8	potpgt;
++};
++
++#endif	/* ifndef __ASM_ARCH_USB_H */
+--- /dev/null
++++ b/drivers/char/dm6446_imp.c
+@@ -0,0 +1,28 @@
++/*
++ * Copyright (C) 2008 Texas Instruments Inc
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
++ */
++/* dm6446_imp.c file. A dummy Image processor module for dm6446 */
++#include <media/davinci/imp_hw_if.h>
++
++/* This is a place holder for implementing imp interface for
++   DM6446. Currently this is not implemented and returns NULL
++*/
++struct imp_hw_interface *imp_get_hw_if(void)
++{
++	return NULL;
++}
++EXPORT_SYMBOL(imp_get_hw_if);
+--- /dev/null
++++ b/include/media/davinci/dm355_aew_hw.h
+@@ -0,0 +1,118 @@
++/*
++ * Copyright (C) 2009 Texas Instruments Inc
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
++ */
++
++#ifndef DM355_AEW_DRIVER_HW_H
++#define DM355_AEW_DRIVER_HW_H
++
++/* Include Files */
++#include <mach/hardware.h>
++
++#ifdef __KERNEL__
++
++/* Register Offsets */
++#define AEWPID		0x00000000	/*Peripheral Revision */
++#define AEWPCR		0x00000004	/*Peripheral Control Register */
++#define AEWWIN1		0x0000004c	/*Configuration for AE/AWB Windows */
++#define AEWINSTART	0x00000050	/*Start position for AE/AWB Windows */
++
++/* Start position and height for black line of AE/AWB Windows */
++#define AEWINBLK	0x00000054
++
++/* Configuration for subsampled data in AE/AWB windows */
++#define AEWSUBWIN       0x00000058
++
++/* SDRAM/DDRAM Start address for AEW Engine */
++#define AEWBUFST	0x0000005c
++
++#define AEW_RSDR_ADDR	0x00000060	/*SDRAM/DDRAM Read Address */
++#define AEW_RSDR_OFFSET	0x00000064	/*SDRAM/DDRAM Line Offset */
++#define AEW_SDR_FRSIZE	0x00000068	/*Frame Size for SDRAM read data */
++
++/* PID fields */
++#define AEW_TID		(0xFF << 16)
++#define AEW_CID		(0xFF << 8)
++#define AEW_PREV	0xFF
++
++/* PCR FIELDS */
++#define AVE2LMT			(0x3ff << 22)	/* Saturation Limit */
++#define AEW_SDR_FETCH_ENABLE	(1 << 21)
++#define AEW_INP_WIDTH		(1 << 20)
++#define AEW_INP_SRC		(1 << 19)
++#define AEW_ALAW_EN		(1 << 17)	/* Alaw Enable/Disable Bit */
++#define AEW_BUSYAF		(1 << 15)	/* Busy Bit for AF */
++#define AEW_BUSYAEWB		(1 << 18)	/* Busy bit for AEW */
++#define AEW_EN			(1 << 16)	/* AEW Engine Enable/Disable */
++
++/* AEWWIN1 fields */
++#define WINH			(0x7F << 24)	/* Window Height */
++#define WINW			(0x7f << 13)	/* Window Width */
++#define WINVC			(0x7f << 6)	/* Window vertical Count */
++#define WINHC			0x3f		/* Window Horizontal Count */
++
++/* AEWWINSTART fields */
++#define WINSV			(0xfff << 16)	/* Window Vertical Start */
++#define WINSH			0xfff		/* Window Horizontal start */
++
++/* AEWWINBLK fields */
++#define BLKWINSV		(0xfff << 16)	/* Black Window Start */
++#define BLKWINH			0x7f		/* Black Window height */
++
++/* AEWSUBWIN fields */
++#define AEWINCV             	(0xf << 8)	/* Vertical Lime Increment */
++#define AEWINCH			0xf		/*Horizontal Line Increment */
++
++/* BIT POSITIONS */
++#define AEW_AVE2LMT_SHIFT		22
++#define AEW_WINH_SHIFT			24
++#define AEW_WINW_SHIFT			13
++#define AEW_VT_COUNT_SHIFT		6
++#define AEW_VT_START_SHIFT		16
++#define AEW_LINE_INCR_SHIFT		8
++#define AEW_BLKWIN_VT_START_SHIFT	16
++#define AEW_EN_SHIFT			16
++#define AEW_BUSYAEWB_SHIFT		18
++#define AEW_INP_SRC_SHIFT		19
++#define AEW_SET_VAL(x)			(((x) / 2) - 1)
++#define AEW_NOT_EVEN			1
++#define AEW_CHECK_EVEN(x)		((x) % 2)
++
++#define AEW_CCDC		0
++#define AEW_INTSTATBASE		(IO_ADDRESS(0x01C7080C))
++#define AEW_EVNTSELADDR		(IO_ADDRESS(0x01C70814))
++#define AEW_GETINTSTAT		__raw_readl(AEW_INTSTATBASE)
++#define AEW_SETGAMMAWD		__raw_writel(0x00000010 ,\
++					IO_ADDRESS(0x01C70680))
++#define	AEW_CLKCTRL_ADDR	(IO_ADDRESS(0x01C70004))
++#define AEW_GETCLKCTRL		__raw_readl(AEW_CLKCTRL_ADDR)
++#define AEW_SETCLKCTRL(val)	__raw_writel(val , AEW_CLKCTRL_ADDR)
++#define AEW_IOBASE_VADDR 	(IO_ADDRESS(0x01c70080))
++
++#define regw(val,reg)		__raw_writel(val , (reg + AEW_IOBASE_VADDR))
++#define regr(reg)		__raw_readl(reg + AEW_IOBASE_VADDR)
++#define AEW_GETEVNT		__raw_readl(AEW_EVNTSELADDR)
++#define AEW_GET_PCR		__raw_readl(AEW_IOBASE_VADDR + AEWPCR);
++
++#define isbusy()			(regr(AEWPCR) & 0x40000)
++
++/* Function Declaration */
++int aew_register_setup(struct aew_device *);
++void aew_engine_setup(int);
++void aew_set_address(unsigned long);
++
++#endif
++#endif
+--- a/drivers/media/video/davinci/dm644x_ccdc.c
++++ b/drivers/media/video/davinci/dm644x_ccdc.c
+@@ -65,7 +65,7 @@ static struct ccdc_params_raw ccdc_hw_pa
+ static struct ccdc_params_ycbcr ccdc_hw_params_ycbcr = {
+ 	.pix_fmt = CCDC_PIXFMT_YCBCR_8BIT,
+ 	.frm_fmt = CCDC_FRMFMT_INTERLACED,
+-	.win = CCDC_WIN_PAL,
++	.win = CCDC_WIN_NTSC,
+ 	.fid_pol = VPFE_PINPOL_POSITIVE,
+ 	.vd_pol = VPFE_PINPOL_POSITIVE,
+ 	.hd_pol = VPFE_PINPOL_POSITIVE,
+@@ -85,7 +85,6 @@ static u32 ccdc_raw_yuv_pix_formats[] =
+ 	{V4L2_PIX_FMT_UYVY, V4L2_PIX_FMT_YUYV};
+ 
+ static void *__iomem ccdc_base_addr;
+-static int ccdc_addr_size;
+ static enum vpfe_hw_if_type ccdc_if_type;
+ 
+ /* register access routines */
+@@ -99,12 +98,6 @@ static inline void regw(u32 val, u32 off
+ 	__raw_writel(val, ccdc_base_addr + offset);
+ }
+ 
+-static void ccdc_set_ccdc_base(void *addr, int size)
+-{
+-	ccdc_base_addr = addr;
+-	ccdc_addr_size = size;
+-}
+-
+ static void ccdc_enable(int flag)
+ {
+ 	regw(flag, CCDC_PCR);
+@@ -671,7 +664,7 @@ void ccdc_config_raw(void)
+ 	ccdc_readregs();
+ }
+ 
+-static int ccdc_configure(void)
++static int ccdc_configure(int mode)
+ {
+ 	if (ccdc_if_type == VPFE_RAW_BAYER)
+ 		ccdc_config_raw();
+@@ -825,8 +818,10 @@ static int ccdc_set_hw_if_params(struct
+ 		ccdc_hw_params_ycbcr.vd_pol = params->vdpol;
+ 		ccdc_hw_params_ycbcr.hd_pol = params->hdpol;
+ 		break;
++	case VPFE_RAW_BAYER:
++		ccdc_hw_params_raw.vd_pol = params->vdpol;
++		ccdc_hw_params_raw.hd_pol = params->hdpol;
+ 	default:
+-		/* TODO add support for raw bayer here */
+ 		return -EINVAL;
+ 	}
+ 	return 0;
+@@ -838,7 +833,6 @@ static struct ccdc_hw_device ccdc_hw_dev
+ 	.hw_ops = {
+ 		.open = ccdc_open,
+ 		.close = ccdc_close,
+-		.set_ccdc_base = ccdc_set_ccdc_base,
+ 		.reset = ccdc_sbl_reset,
+ 		.enable = ccdc_enable,
+ 		.set_hw_if_params = ccdc_set_hw_if_params,
+@@ -859,19 +853,79 @@ static struct ccdc_hw_device ccdc_hw_dev
+ 	},
+ };
+ 
+-static int dm644x_ccdc_init(void)
++static int __init dm644x_ccdc_probe(struct platform_device *pdev)
+ {
+-	printk(KERN_NOTICE "dm644x_ccdc_init\n");
+-	if (vpfe_register_ccdc_device(&ccdc_hw_dev) < 0)
+-		return -1;
++	static resource_size_t  res_len;
++	struct resource	*res;
++	int status = 0;
++
++	/**
++	 * first try to register with vpfe. If not correct platform, then we
++	 * don't have to iomap
++	 */
++	status = vpfe_register_ccdc_device(&ccdc_hw_dev);
++	if (status < 0)
++		return status;
++
++	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
++	if (!res) {
++		status = -ENOENT;
++		goto fail_nores;
++	}
++
++	res_len = res->end - res->start + 1;
++
++	res = request_mem_region(res->start, res_len, res->name);
++	if (!res) {
++		status = -EBUSY;
++		goto fail_nores;
++	}
++
++	ccdc_base_addr = ioremap_nocache(res->start, res_len);
++	if (!ccdc_base_addr) {
++		status = -EBUSY;
++		goto fail;
++	}
++
+ 	printk(KERN_NOTICE "%s is registered with vpfe.\n",
+ 		ccdc_hw_dev.name);
+ 	return 0;
++fail:
++	release_mem_region(res->start, res_len);
++fail_nores:
++	vpfe_unregister_ccdc_device(&ccdc_hw_dev);
++	return status;
+ }
+ 
+-static void dm644x_ccdc_exit(void)
++static int dm644x_ccdc_remove(struct platform_device *pdev)
+ {
++	struct resource	*res;
++
++	iounmap(ccdc_base_addr);
++	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
++	if (res)
++		release_mem_region(res->start, res->end - res->start + 1);
+ 	vpfe_unregister_ccdc_device(&ccdc_hw_dev);
++	return 0;
++}
++
++static struct platform_driver dm644x_ccdc_driver = {
++	.driver = {
++		.name	= "dm644x_ccdc",
++		.owner = THIS_MODULE,
++	},
++	.remove = __devexit_p(dm644x_ccdc_remove),
++	.probe = dm644x_ccdc_probe,
++};
++
++static int dm644x_ccdc_init(void)
++{
++	return platform_driver_register(&dm644x_ccdc_driver);
++}
++
++static void dm644x_ccdc_exit(void)
++{
++	platform_driver_unregister(&dm644x_ccdc_driver);
+ }
+ 
+ module_init(dm644x_ccdc_init);
+--- /dev/null
++++ b/drivers/media/video/davinci/vpbe_encoder.c
+@@ -0,0 +1,886 @@
++/*
++ * Copyright (C) 2009 Texas Instruments Inc
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
++ */
++/* vpbe_encoder.c.. For internal encoder of the VPBE */
++
++/* Kernel Specific header files */
++
++#include <linux/kernel.h>
++#include <linux/autoconf.h>
++#include <linux/init.h>
++#include <linux/ctype.h>
++#include <linux/delay.h>
++#include <video/davinci_vpbe.h>
++#include <media/davinci/vid_encoder_if.h>
++#include <media/davinci/vpbe_encoder.h>
++#include <media/davinci/davinci_platform.h>
++#include <mach/hardware.h>
++#include <mach/io.h>
++#include <mach/cputype.h>
++
++#include <asm/io.h>
++
++struct vpbe_encoder_params {
++	int outindex;
++	char *mode;
++};
++
++struct vpbe_encoder_config {
++//	unsigned long vencregs;
++	int no_of_outputs;
++	struct {
++		char *output_name;
++		int no_of_standard;
++		char *standards[VPBE_ENCODER_MAX_NUM_STD];
++	} output[VPBE_ENCODER_MAX_NO_OUTPUTS];
++};
++
++struct vpbe_encoder_channel {
++	struct encoder_device *enc_device;
++	struct vpbe_encoder_params params;
++};
++
++/* Function prototypes */
++static int vpbe_encoder_initialize(struct vid_encoder_device *enc, int flag);
++static int vpbe_encoder_deinitialize(struct vid_encoder_device *enc);
++
++static int vpbe_encoder_setmode(struct vid_enc_mode_info *mode_info,
++				struct vid_encoder_device *enc);
++static int vpbe_encoder_getmode(struct vid_enc_mode_info *mode_info,
++				struct vid_encoder_device *enc);
++
++static int vpbe_encoder_setoutput(char *output, struct vid_encoder_device *enc);
++static int vpbe_encoder_getoutput(char *output, struct vid_encoder_device *enc);
++
++static int vpbe_encoder_enumoutput(int index,
++				   char *output,
++				   struct vid_encoder_device *enc);
++
++static int vpbe_encoder_enable(int flag, struct vid_encoder_device *enc);
++
++/* All Supported encoder modes */
++static struct vid_enc_mode_info vpbe_encoder_modes[VPBE_ENCODER_MAX_NUM_STD] = {
++	{
++	 .name = VID_ENC_STD_NTSC,
++	 .std = 1,
++	 .if_type = VID_ENC_IF_INT,
++	 .interlaced = 1,
++	 .xres = 720,
++	 .yres = 480,
++	 .fps = {30000, 1001},
++	 .left_margin = 0x79,
++	 .right_margin = 0,
++	 .upper_margin = 0x10,
++	 .lower_margin = 0,
++	 .hsync_len = 0,
++	 .vsync_len = 0,
++	 .flags = 0},
++	{
++	 .name = VID_ENC_STD_PAL,
++	 .std = 1,
++	 .if_type = VID_ENC_IF_INT,
++	 .interlaced = 1,
++	 .xres = 720,
++	 .yres = 576,
++	 .fps = {25, 1},
++	 .left_margin = 0x7E,
++	 .right_margin = 0,
++	 .upper_margin = 0x16,
++	 .lower_margin = 0,
++	 .hsync_len = 0,
++	 .vsync_len = 0,
++	 .flags = 0},
++	{
++	 .name = VID_ENC_STD_NTSC_RGB,
++	 .std = 1,
++	 .if_type = VID_ENC_IF_INT,
++	 .interlaced = 1,
++	 .xres = 720,
++	 .yres = 480,
++	 .fps = {30000, 1001},
++	 .left_margin = 0x80,
++	 .right_margin = 0,
++	 .upper_margin = 0x12,
++	 .lower_margin = 0,
++	 .hsync_len = 0,
++	 .vsync_len = 0,
++	 .flags = 0},
++	{
++	 .name = VID_ENC_STD_PAL_RGB,
++	 .std = 1,
++	 .if_type = VID_ENC_IF_INT,
++	 .interlaced = 1,
++	 .xres = 720,
++	 .yres = 576,
++	 .fps = {25, 1},
++	 .left_margin = 0x88,
++	 .right_margin = 0,
++	 .upper_margin = 0x18,
++	 .lower_margin = 0,
++	 .hsync_len = 0,
++	 .vsync_len = 0,
++	 .flags = 0},
++	{
++	 .name = VID_ENC_STD_480P_60,
++	 .std = 1,
++	 .if_type = VID_ENC_IF_INT,
++	 .interlaced = 0,
++	 .xres = 720,
++	 .yres = 480,
++	 .fps = {60, 1},
++	 .left_margin = 0x80,
++	 .right_margin = 0,
++	 .upper_margin = 0x20,
++	 .lower_margin = 0,
++	 .hsync_len = 0,
++	 .vsync_len = 0,
++	 .flags = 0},
++	{
++	 .name = VID_ENC_STD_576P_50,
++	 .std = 1,
++	 .if_type = VID_ENC_IF_INT,
++	 .interlaced = 0,
++	 .xres = 720,
++	 .yres = 576,
++	 .fps = {50, 1},
++	 .left_margin = 0x7E,
++	 .right_margin = 0,
++	 .upper_margin = 0x30,
++	 .lower_margin = 0,
++	 .hsync_len = 0,
++	 .vsync_len = 0,
++	 .flags = 0},
++	{
++	 .name = VID_ENC_STD_720P_60,
++	 .std = 1,
++	 .if_type = VID_ENC_IF_INT,
++	 .interlaced = 0,
++	 .xres = 1280,
++	 .yres = 720,
++	 .fps = {60, 1},
++	 .left_margin = 300,
++	 .right_margin = 70,
++	 .upper_margin = 26,
++	 .lower_margin = 3,
++	 .hsync_len = 80,
++	 .vsync_len = 5,
++	 .flags = 0},
++	{
++	 .name = VID_ENC_STD_720P_50,
++	 .std = 1,
++	 .if_type = VID_ENC_IF_INT,
++	 .interlaced = 0,
++	 .xres = 1280,
++	 .yres = 720,
++	 .fps = {50, 1},
++	 .left_margin = 300,
++	 .right_margin = 70,
++	 .upper_margin = 26,
++	 .lower_margin = 3,
++	 .hsync_len = 80,
++	 .vsync_len = 5,
++	 .flags = 0},
++	{
++	 .name = VID_ENC_STD_720P_30,
++	 .std = 1,
++	 .if_type = VID_ENC_IF_INT,
++	 .interlaced = 0,
++	 .xres = 1280,
++	 .yres = 720,
++	 .fps = {30, 1},
++	 .left_margin = 300,
++	 .right_margin = 70,
++	 .upper_margin = 26,
++	 .lower_margin = 3,
++	 .hsync_len = 80,
++	 .vsync_len = 5,
++	 .flags = 0},
++	{
++	 .name = VID_ENC_STD_720P_25,
++	 .std = 1,
++	 .if_type = VID_ENC_IF_INT,
++	 .interlaced = 0,
++	 .xres = 1280,
++	 .yres = 720,
++	 .fps = {25, 1},
++	 .left_margin = 300,
++	 .right_margin = 70,
++	 .upper_margin = 26,
++	 .lower_margin = 3,
++	 .hsync_len = 80,
++	 .vsync_len = 5,
++	 .flags = 0},
++	{
++	 .name = VID_ENC_STD_720P_24,
++	 .std = 1,
++	 .if_type = VID_ENC_IF_INT,
++	 .interlaced = 0,
++	 .xres = 1280,
++	 .yres = 720,
++	 .fps = {24, 1},
++	 .left_margin = 300,
++	 .right_margin = 70,
++	 .upper_margin = 26,
++	 .lower_margin = 3,
++	 .hsync_len = 80,
++	 .vsync_len = 5,
++	 .flags = 0},
++	{
++	 .name = VID_ENC_STD_1080I_30,
++	 .std = 1,
++	 .if_type = VID_ENC_IF_INT,
++	 .interlaced = 1,
++	 .xres = 1920,
++	 .yres = 1080,
++	 .fps = {30, 1},
++	 .left_margin = 200,
++	 .right_margin = 80,
++	 .upper_margin = 13,
++	 .lower_margin = 31,
++	 .hsync_len = 88,
++	 .vsync_len = 5,
++	 .flags = 0},
++	{
++	 .name = VID_ENC_STD_1080I_25,
++	 .std = 1,
++	 .if_type = VID_ENC_IF_INT,
++	 .interlaced = 1,
++	 .xres = 1920,
++	 .yres = 1080,
++	 .fps = {25, 1},
++	 .left_margin = 200,
++	 .right_margin = 80,
++	 .upper_margin = 13,
++	 .lower_margin = 31,
++	 .hsync_len = 88,
++	 .vsync_len = 5,
++	 .flags = 0},
++};
++
++static struct vpbe_encoder_config vpbe_encoder_configuration = {
++//	.vencregs = DM644X_VENC_REG_BASE,
++	.no_of_outputs = VPBE_DM644X_ENCODER_MAX_NO_OUTPUTS,
++	.output[0] = {
++		      .output_name = VID_ENC_OUTPUT_COMPOSITE,
++		      .no_of_standard = VPBE_DM644X_ENCODER_COMPOSITE_NUM_STD,
++		      .standards = {VID_ENC_STD_NTSC, VID_ENC_STD_PAL},
++		      },
++	.output[1] = {
++		      .output_name = VID_ENC_OUTPUT_SVIDEO,
++		      .no_of_standard = VPBE_DM644X_ENCODER_SVIDEO_NUM_STD,
++		      .standards = {VID_ENC_STD_NTSC, VID_ENC_STD_PAL},
++		      },
++	.output[2] = {
++		      .output_name = VID_ENC_OUTPUT_COMPONENT,
++		      .no_of_standard = VPBE_DM644X_ENCODER_COMPONENT_NUM_STD,
++		      .standards = {VID_ENC_STD_NTSC,
++				    VID_ENC_STD_PAL,
++				    VID_ENC_STD_NTSC_RGB,
++				    VID_ENC_STD_PAL_RGB,
++				    VID_ENC_STD_480P_60,
++				    VID_ENC_STD_576P_50},
++		      }
++};
++
++static struct vpbe_encoder_channel vpbe_encoder_channel_info = {
++	.params.outindex = 0,
++	.params.mode = VID_ENC_STD_NTSC,
++	.enc_device = NULL
++};
++
++static struct vid_enc_output_ops outputs_ops = {
++	.count = VPBE_ENCODER_MAX_NO_OUTPUTS,
++	.enumoutput = vpbe_encoder_enumoutput,
++	.setoutput = vpbe_encoder_setoutput,
++	.getoutput = vpbe_encoder_getoutput
++};
++
++static struct vid_enc_mode_ops modes_ops = {
++	.setmode = vpbe_encoder_setmode,
++	.getmode = vpbe_encoder_getmode,
++};
++
++static struct vid_enc_misc_ops miscs_ops = {
++	.reset = NULL,
++	.enable = vpbe_encoder_enable,
++};
++
++static struct vid_encoder_device vpbe_encoder_dev = {
++	.name = "VPBE_ENCODER",
++	.capabilities = 0,
++	.initialize = vpbe_encoder_initialize,
++	.mode_ops = &modes_ops,
++	.ctrl_ops = NULL,
++	.output_ops = &outputs_ops,
++	.params_ops = NULL,
++	.misc_ops = &miscs_ops,
++	.deinitialize = vpbe_encoder_deinitialize,
++};
++
++/*
++ * display controller register I/O routines
++ */
++#if 0
++static __inline__ u32 venc_reg_in(u32 offset)
++{
++	u32 addr;
++	addr = vpbe_encoder_configuration.vencregs + offset;
++	return (__raw_readl(IO_ADDRESS(addr)));
++}
++static __inline__ u32 venc_reg_out(u32 offset, u32 val)
++{
++	u32 addr = vpbe_encoder_configuration.vencregs + offset;
++	__raw_writel(val, IO_ADDRESS(addr));
++	return (val);
++}
++static __inline__ u32 venc_reg_merge(u32 offset, u32 val, u32 mask)
++{
++	u32 addr, new_val;
++	addr = vpbe_encoder_configuration.vencregs + offset;
++	new_val = (__raw_readl(IO_ADDRESS(addr)) & ~mask) | (val & mask);
++	__raw_writel(new_val, IO_ADDRESS(addr));
++	return (new_val);
++}
++#endif
++
++/* Function to enable/disable output */
++static int vpbe_encoder_enable(int flag, struct vid_encoder_device *enc)
++{
++	if (flag)
++		venc_reg_out(VENC_DACTST, 0);
++	else
++		venc_reg_out(VENC_DACTST, 0xF000);
++	return 0;
++}
++
++/* This function sets the dac of the VPBE for various outputs
++ */
++static int vpbe_encoder_set_dac(char *output)
++{
++	int error = 0;
++
++	if (cpu_is_davinci_dm644x() || cpu_is_davinci_dm365()) {
++		if (!strcmp(output, VID_ENC_OUTPUT_COMPOSITE)) {
++			printk(KERN_DEBUG "Setting output to Composite\n");
++			venc_reg_out(VENC_DACSEL, 0);
++		} else if (!strcmp(output, VID_ENC_OUTPUT_SVIDEO)) {
++			printk(KERN_DEBUG "Setting output to S-Video\n");
++			venc_reg_out(VENC_DACSEL, 0x210);
++		} else if (!strcmp(output, VID_ENC_OUTPUT_COMPONENT)) {
++			printk(KERN_DEBUG
++			       "Setting output to Component Video\n");
++			venc_reg_out(VENC_DACSEL, 0x543);
++		} else
++			error = -1;
++	} else if (!cpu_is_davinci_dm355())
++		error = -1;
++	return error;
++}
++
++/* This function is called by the encoder manager to initialize vpbe encoder driver.
++ * It initializes all registers of vpbe_encoder with the default values
++ */
++static int vpbe_encoder_initialize(struct vid_encoder_device *enc, int flag)
++{
++	int err = 0, outindex;
++	char *std, *output;
++	if (NULL == enc) {
++		printk(KERN_ERR "enc:NULL Pointer\n");
++		return -EINVAL;
++	}
++	vpbe_encoder_channel_info.enc_device = (struct encoder_device *)enc;
++
++	/* call set standard */
++	std = vpbe_encoder_channel_info.params.mode;
++	outindex = vpbe_encoder_channel_info.params.outindex;
++	output = vpbe_encoder_configuration.output[outindex].output_name;
++	err |= vpbe_encoder_setoutput(output, enc);
++	if (err < 0) {
++		err = -EINVAL;
++		printk(KERN_ERR "Error occured in setoutput\n");
++		vpbe_encoder_deinitialize(enc);
++		return err;
++	}
++	printk(KERN_DEBUG "VPBE Encoder initialized\n");
++	return err;
++}
++
++static int vpbe_encoder_deinitialize(struct vid_encoder_device *enc)
++{
++	if (NULL == enc) {
++		printk(KERN_ERR "NULL Pointer\n");
++		return -EINVAL;
++	}
++	if (cpu_is_davinci_dm644x() || cpu_is_davinci_dm365())
++		venc_reg_out(VENC_DACSEL, 0);
++
++	/* disable output */
++	venc_reg_out(VENC_DACTST, 0xF000);
++	venc_reg_out(VENC_VMOD, 0);
++
++	vpbe_encoder_channel_info.enc_device = NULL;
++	printk(KERN_DEBUG "VPBE Encoder de-initialized\n");
++	return 0;
++}
++
++/* Following function returns ptr to a mode_info structure*/
++static struct vid_enc_mode_info *get_modeinfo(char *mode_name)
++{
++	int i;
++	for (i = 0; i < VPBE_ENCODER_MAX_NUM_STD; i++) {
++		if (!strcmp(vpbe_encoder_modes[i].name, mode_name)) {
++			return &vpbe_encoder_modes[i];
++		}
++	}
++	return NULL;
++}
++
++/* Following function is used to set the mode*/
++static int vpbe_encoder_setmode(struct vid_enc_mode_info *mode_info,
++				struct vid_encoder_device *enc)
++{
++	int err = 0, outindex, i, dm6446 = 0, dm355 = 0, dm365 = 0;
++	char *mode;
++	struct vid_enc_mode_info *my_mode_info;
++
++	if ((NULL == enc) || (NULL == mode_info)) {
++		printk(KERN_ERR "NULL Pointer\n");
++		return -EINVAL;
++	}
++
++	if (NULL == (mode = mode_info->name)) {
++		printk(KERN_ERR "NULL Pointer\n");
++		return -EINVAL;
++	}
++	printk(KERN_DEBUG "Start of vpbe_encoder_setmode..\n");
++	outindex = vpbe_encoder_channel_info.params.outindex;
++	if (cpu_is_davinci_dm644x())
++		dm6446 = 1;
++	else if (cpu_is_davinci_dm355())
++		dm355 = 1;
++	else if (cpu_is_davinci_dm365())
++		dm365 = 1;
++	else
++		return -EINVAL;
++
++	if (mode_info->std) {
++		char *mymode = NULL;
++		/* This is a standard mode */
++		for (i = 0;
++		     i <
++		     vpbe_encoder_configuration.output[outindex].no_of_standard;
++		     i++) {
++			if (!strcmp
++			    (vpbe_encoder_configuration.output[outindex].
++			     standards[i], mode)) {
++				mymode =
++				    vpbe_encoder_configuration.output[outindex].
++				    standards[i];
++				break;
++			}
++		}
++		if ((i ==
++		     vpbe_encoder_configuration.output[outindex].no_of_standard)
++		    || (NULL == mymode)) {
++			printk(KERN_ERR "Invalid id...\n");
++			return -EINVAL;
++		}
++		/* Store the standard in global object of vpbe_encoder */
++		vpbe_encoder_channel_info.params.mode = mymode;
++		if (!strcmp(mymode, VID_ENC_STD_NTSC)) {
++			/* Setup NTSC */
++			venc_reg_out(VENC_VMOD, 0);
++			venc_reg_merge(VENC_VMOD,
++					(1 << VENC_VMOD_VIE_SHIFT),
++					VENC_VMOD_VIE);
++			venc_reg_merge(VENC_VMOD,
++					(0 << VENC_VMOD_VMD), VENC_VMOD_VMD);
++			venc_reg_merge(VENC_VMOD,
++					(0 << VENC_VMOD_TVTYP_SHIFT),
++					VENC_VMOD_TVTYP);
++		} else if (!strcmp(mymode, VID_ENC_STD_PAL)) {
++			/* Setup PAL */
++			venc_reg_out(VENC_VMOD, 0);
++			venc_reg_merge(VENC_VMOD,
++					(1 << VENC_VMOD_VIE_SHIFT),
++					VENC_VMOD_VIE);
++			venc_reg_merge(VENC_VMOD,
++					(0 << VENC_VMOD_VMD), VENC_VMOD_VMD);
++			venc_reg_merge(VENC_VMOD,
++					(1 << VENC_VMOD_TVTYP_SHIFT),
++					VENC_VMOD_TVTYP);
++		} else if (!strcmp(mymode, VID_ENC_STD_NTSC_RGB) &&
++			   (dm6446 || dm365)) {
++			/* Setup for NTSC RGB */
++			venc_reg_out(VENC_VMOD, 0);
++			venc_reg_merge(VENC_VMOD,
++					(0 << VENC_VMOD_VMD), VENC_VMOD_VMD);
++			venc_reg_merge(VENC_VMOD,
++					(0 << VENC_VMOD_TVTYP_SHIFT),
++					VENC_VMOD_TVTYP);
++			venc_reg_merge(VENC_CMPNT,
++					(1 << VENC_CMPNT_MRGB_SHIFT),
++					VENC_CMPNT_MRGB);
++		} else if (!strcmp(mymode, VID_ENC_STD_PAL_RGB) &&
++			   (dm6446 || dm365)) {
++			/* Setup for PAL RGB */
++			venc_reg_out(VENC_VMOD, 0);
++			venc_reg_merge(VENC_VMOD,
++					(1 << VENC_VMOD_VIE_SHIFT),
++					VENC_VMOD_VIE);
++			venc_reg_merge(VENC_VMOD,
++					(0 << VENC_VMOD_VMD), VENC_VMOD_VMD);
++			venc_reg_merge(VENC_VMOD,
++					(1 << VENC_VMOD_TVTYP_SHIFT),
++					VENC_VMOD_TVTYP);
++			venc_reg_merge(VENC_CMPNT,
++					(1 << VENC_CMPNT_MRGB_SHIFT),
++					VENC_CMPNT_MRGB);
++		} else if (!strcmp(mymode, VID_ENC_STD_480P_60) &&
++			   (dm6446 || dm365)) {
++			/* Setup for 480P, Progressive NTSC */
++			venc_reg_out(VENC_VMOD, 0);
++			venc_reg_merge(VENC_VMOD,
++					(1 << VENC_VMOD_VIE_SHIFT),
++					VENC_VMOD_VIE);
++			venc_reg_merge(VENC_VMOD,
++					VENC_VMOD_HDMD, VENC_VMOD_HDMD);
++			venc_reg_merge(VENC_VMOD,
++					(HDTV_525P << VENC_VMOD_TVTYP_SHIFT),
++					VENC_VMOD_TVTYP);
++
++		} else if (!strcmp(mymode, VID_ENC_STD_576P_50) &&
++			   (dm6446 || dm365)) {
++			venc_reg_out(VENC_VMOD, 0);
++			/* Setup for 576P, Progressive PAL */
++			venc_reg_merge(VENC_VMOD,
++					(1 << VENC_VMOD_VIE_SHIFT),
++					VENC_VMOD_VIE);
++			venc_reg_merge(VENC_VMOD,
++					VENC_VMOD_HDMD, VENC_VMOD_HDMD);
++			venc_reg_merge
++			    (VENC_VMOD,
++			     (HDTV_625P << VENC_VMOD_TVTYP_SHIFT),
++			     VENC_VMOD_TVTYP);
++		} else if (!strncmp(mymode, VID_ENC_STD_720P_60, 5) && dm365) {
++			char buf[16];
++			unsigned long xh, val;
++			strcpy(buf, mymode + 5);
++			venc_reg_out(VENC_VMOD, 0);
++			/* DM365 component HD mode */
++			venc_reg_merge(VENC_VMOD,
++					(1 << VENC_VMOD_VIE_SHIFT),
++					VENC_VMOD_VIE);
++			venc_reg_merge(VENC_VMOD,
++					VENC_VMOD_HDMD, VENC_VMOD_HDMD);
++			venc_reg_merge
++			    (VENC_VMOD,
++			     (HDTV_720P << VENC_VMOD_TVTYP_SHIFT),
++			     VENC_VMOD_TVTYP);
++			venc_reg_merge
++			    (VENC_VMOD,
++			     VENC_VMOD_VENC,
++			     VENC_VMOD_VENC);
++			/* DM365 VENC spec, Table 16 */
++			if (strict_strtoul(buf, 10, &val) != 0)
++				val = 60;
++			switch (val) {
++			case 60:
++			default:
++				xh = 0;
++				break;
++			case 50:
++				xh = 330;
++				break;
++			case 30:
++				xh = 1650;
++				break;
++			case 25:
++				xh = 2310;
++				break;
++			case 24:
++				xh = 2475;
++				break;
++			}
++			venc_reg_out(VENC_XHINTVL, xh);
++		} else if (!strncmp(mymode, VID_ENC_STD_1080I_30, 6) && dm365) {
++			char buf[16];
++			unsigned long xh, val;
++			strcpy(buf, mymode + 6);
++			venc_reg_out(VENC_VMOD, 0);
++			/* DM365 component HD mode */
++			venc_reg_merge(VENC_VMOD,
++					(1 << VENC_VMOD_VIE_SHIFT),
++					VENC_VMOD_VIE);
++			venc_reg_merge(VENC_VMOD,
++					VENC_VMOD_HDMD, VENC_VMOD_HDMD);
++			venc_reg_merge
++			    (VENC_VMOD,
++			     (HDTV_1080I << VENC_VMOD_TVTYP_SHIFT),
++			     VENC_VMOD_TVTYP);
++			venc_reg_merge
++			    (VENC_VMOD,
++			     VENC_VMOD_VENC,
++			     VENC_VMOD_VENC);
++			if (strict_strtoul(buf, 10, &val) != 0)
++				val = 30;
++			switch (val) {
++			case 30:
++			default:
++				xh = 0;
++				break;
++			case 25:
++				xh = 2640;
++				break;
++			}
++			venc_reg_out(VENC_XHINTVL, xh);
++		} else {
++			printk(KERN_ERR "Mode not supported..\n");
++			return -EINVAL;
++		}
++	} else {
++		/* Non- Standard mode. Check if we support it. If so
++		   save the timing info and return */
++		my_mode_info = get_modeinfo(VID_ENC_STD_NON_STANDARD);
++		if (my_mode_info) {
++			/* We support. So save timing info and return success
++			   interface type is same as what is currently is active
++			 */
++			vpbe_encoder_channel_info.params.mode =
++			    VID_ENC_STD_NON_STANDARD;
++			my_mode_info->std = 0;
++			my_mode_info->interlaced = mode_info->interlaced;
++			my_mode_info->xres = mode_info->xres;
++			my_mode_info->yres = mode_info->yres;
++			my_mode_info->fps = mode_info->fps;
++			my_mode_info->left_margin = mode_info->left_margin;
++			my_mode_info->right_margin = mode_info->right_margin;
++			my_mode_info->upper_margin = mode_info->upper_margin;
++			my_mode_info->lower_margin = mode_info->lower_margin;
++			my_mode_info->hsync_len = mode_info->hsync_len;
++			my_mode_info->vsync_len = mode_info->vsync_len;
++			my_mode_info->flags = mode_info->flags;
++			/* If we need to configure something in the encoder module, we need to
++			   do this here */
++			return 0;
++		}
++		printk(KERN_ERR "Mode not supported..\n");
++		return -EINVAL;
++	}
++	printk(KERN_DEBUG "</vpbe_encoder_setmode>\n");
++	return err;
++}
++
++/* Following function is used to get currently selected mode.*/
++static int vpbe_encoder_getmode(struct vid_enc_mode_info *mode_info,
++				struct vid_encoder_device *enc)
++{
++	int err = 0;
++	struct vid_enc_mode_info *my_mode_info;
++	if ((NULL == enc) || (NULL == mode_info)) {
++		printk(KERN_ERR "NULL Pointer\n");
++		return -EINVAL;
++	}
++	printk(KERN_DEBUG "<vpbe_encoder_getmode>\n");
++	my_mode_info = get_modeinfo(vpbe_encoder_channel_info.params.mode);
++	if (NULL == my_mode_info) {
++		printk(KERN_ERR "NULL Pointer for current mode info\n");
++		return -EINVAL;
++	}
++	memcpy(mode_info, my_mode_info, sizeof(struct vid_enc_mode_info));
++	printk(KERN_DEBUG "<vpbe_encoder_getmode/>\n");
++	return err;
++}
++
++/* Following function is used to set output format in VPBE DAC. The
++   output name is  passed as the argument to this function. */
++static int vpbe_encoder_setoutput(char *output, struct vid_encoder_device *enc)
++{
++	int err = 0, index;
++	struct vid_enc_mode_info *my_mode_info;
++	printk(KERN_DEBUG "<vpbe_encoder_setoutput>\n");
++	if (NULL == enc) {
++		printk(KERN_ERR "enc:NULL Pointer\n");
++		return -EINVAL;
++	}
++
++	/* check for null pointer */
++	if (output == NULL) {
++		printk(KERN_ERR "output: NULL Pointer.\n");
++		return -EINVAL;
++	}
++
++	for (index = 0; index < vpbe_encoder_configuration.no_of_outputs;
++	     index++) {
++		if (!strcmp
++		    (output,
++		     vpbe_encoder_configuration.output[index].output_name)) {
++			break;
++		}
++	}
++
++	if (index == vpbe_encoder_configuration.no_of_outputs) {
++		/* No output matching this name */
++		printk(KERN_ERR "No matching output: %s\n", output);
++		return -EINVAL;
++	}
++
++	if (vpbe_encoder_set_dac(output) < 0) {
++		printk(KERN_ERR
++		       "<vpbe_encoder_setoutput, error in setting DAC config>\n");
++		return -EINVAL;
++	}
++
++	vpbe_encoder_channel_info.params.outindex = index;
++
++	/* set default standard */
++	vpbe_encoder_channel_info.params.mode
++	    = vpbe_encoder_configuration.output[index].standards[0];
++
++	my_mode_info = get_modeinfo(vpbe_encoder_channel_info.params.mode);
++	if (NULL == my_mode_info) {
++		printk(KERN_ERR "No matching mode_info entry found\n");
++		return -EINVAL;
++	}
++
++	err |= vpbe_encoder_setmode(my_mode_info, enc);
++	if (err < 0) {
++		printk(KERN_ERR "Erron in setting default mode\n");
++		return err;
++	}
++	printk(KERN_DEBUG "</vpbe_encoder_setoutput>\n");
++	return err;
++}
++
++/* Following function is used to get output name of current output.*/
++static int vpbe_encoder_getoutput(char *output, struct vid_encoder_device *enc)
++{
++	int err = 0, index, len;
++	if (NULL == enc) {
++		printk(KERN_ERR "enc:NULL Pointer\n");
++		return -EINVAL;
++	}
++	printk(KERN_DEBUG "<vpbe_encoder_getoutput>\n");
++	/* check for null pointer */
++	if (output == NULL) {
++		printk(KERN_ERR "output:NULL Pointer.\n");
++		return -EINVAL;
++	}
++	index = vpbe_encoder_channel_info.params.outindex;
++	len = strlen(vpbe_encoder_configuration.output[index].output_name);
++	if (len > (VID_ENC_NAME_MAX_CHARS - 1))
++		len = VID_ENC_NAME_MAX_CHARS - 1;
++	strncpy(output, vpbe_encoder_configuration.output[index].output_name,
++		len);
++	output[len] = '\0';
++	printk(KERN_DEBUG "</vpbe_encoder_getoutput>\n");
++	return err;
++}
++
++/* Following function is used to enumerate outputs supported by the driver.
++   It fills in information about the output in the output. */
++static int vpbe_encoder_enumoutput(int index, char *output,
++				   struct vid_encoder_device *enc)
++{
++	int err = 0;
++
++	printk(KERN_DEBUG "<vpbe_encoder_enumoutput>\n");
++	if (NULL == enc) {
++		printk(KERN_ERR "enc:NULL Pointer.\n");
++		return -EINVAL;
++	}
++	/* check for null pointer */
++	if (output == NULL) {
++		printk(KERN_ERR "output:NULL Pointer.\n");
++		return -EINVAL;
++	}
++	/* Only one output is available */
++	if (index >= vpbe_encoder_configuration.no_of_outputs) {
++		return -EINVAL;
++	}
++	strncpy(output,
++		vpbe_encoder_configuration.output[index].output_name,
++		VID_ENC_NAME_MAX_CHARS);
++	printk(KERN_DEBUG "</vpbe_encoder_enumoutput>\n");
++	return err;
++}
++
++/* This function used to initialize the vpbe encoder driver */
++static int vpbe_encoder_init(void)
++{
++	int err = 0;
++
++	if (cpu_is_davinci_dm644x()) {
++		/* Do nothing. We have everything setup for DM6446 */
++	} else if (cpu_is_davinci_dm355()) {
++		outputs_ops.count = VPBE_DM355_ENCODER_MAX_NO_OUTPUTS;
++//		vpbe_encoder_configuration.vencregs = DM355_VENC_REG_BASE;
++		vpbe_encoder_configuration.no_of_outputs =
++		    VPBE_DM355_ENCODER_MAX_NO_OUTPUTS;
++		vpbe_encoder_configuration.output[0].no_of_standard =
++		    VPBE_DM355_ENCODER_COMPOSITE_NUM_STD;
++		/* If we have different no of standards for composite in
++		 * DM355 and DM6446 we need to fill the stanard names as
++		 * well here. Now both are the same.
++		 */
++	} else if (cpu_is_davinci_dm365()) {
++		outputs_ops.count = VPBE_DM365_ENCODER_MAX_NO_OUTPUTS;
++//		vpbe_encoder_configuration.vencregs = DM365_VENC_REG_BASE;
++		vpbe_encoder_configuration.no_of_outputs =
++		    VPBE_DM365_ENCODER_MAX_NO_OUTPUTS;
++		vpbe_encoder_configuration.output[0].no_of_standard =
++		    VPBE_DM365_ENCODER_COMPOSITE_NUM_STD;
++		vpbe_encoder_configuration.output[1].no_of_standard =
++		    VPBE_DM365_ENCODER_COMPONENT_NUM_STD;
++		vpbe_encoder_configuration.output[1].output_name =
++		    VID_ENC_OUTPUT_COMPONENT;
++		vpbe_encoder_configuration.output[1].standards[0] =
++		    VID_ENC_STD_480P_60;
++		vpbe_encoder_configuration.output[1].standards[1] =
++		    VID_ENC_STD_576P_50;
++		vpbe_encoder_configuration.output[1].standards[2] =
++		    VID_ENC_STD_720P_24;
++		vpbe_encoder_configuration.output[1].standards[3] =
++		    VID_ENC_STD_720P_25;
++		vpbe_encoder_configuration.output[1].standards[4] =
++		    VID_ENC_STD_720P_30;
++		vpbe_encoder_configuration.output[1].standards[5] =
++		    VID_ENC_STD_720P_50;
++		vpbe_encoder_configuration.output[1].standards[6] =
++		    VID_ENC_STD_720P_60;
++		vpbe_encoder_configuration.output[1].standards[7] =
++		    VID_ENC_STD_1080I_25;
++		vpbe_encoder_configuration.output[1].standards[8] =
++		    VID_ENC_STD_1080I_30;
++  } else
++		return -1;
++
++	err = vid_enc_register_encoder(&vpbe_encoder_dev);
++	printk(KERN_NOTICE "VPBE Encoder Initialized\n");
++	return err;
++}
++
++/* Function used to cleanup vpbe encoder driver */
++static void vpbe_encoder_cleanup(void)
++{
++	vid_enc_unregister_encoder(&vpbe_encoder_dev);
++}
++
++subsys_initcall(vpbe_encoder_init);
++module_exit(vpbe_encoder_cleanup);
++
++MODULE_LICENSE("GPL");
+--- /dev/null
++++ b/arch/arm/configs/davinci_dm646x_1ghz_defconfig
+@@ -0,0 +1,1953 @@
++#
++# Automatically generated make config: don't edit
++# Linux kernel version: 2.6.32-rc2-davinci1
++# Wed Oct 14 16:24:38 2009
++#
++CONFIG_ARM=y
++CONFIG_SYS_SUPPORTS_APM_EMULATION=y
++CONFIG_GENERIC_GPIO=y
++CONFIG_GENERIC_TIME=y
++CONFIG_GENERIC_CLOCKEVENTS=y
++CONFIG_GENERIC_HARDIRQS=y
++CONFIG_STACKTRACE_SUPPORT=y
++CONFIG_HAVE_LATENCYTOP_SUPPORT=y
++CONFIG_LOCKDEP_SUPPORT=y
++CONFIG_TRACE_IRQFLAGS_SUPPORT=y
++CONFIG_HARDIRQS_SW_RESEND=y
++CONFIG_GENERIC_IRQ_PROBE=y
++CONFIG_RWSEM_GENERIC_SPINLOCK=y
++CONFIG_GENERIC_HWEIGHT=y
++CONFIG_GENERIC_CALIBRATE_DELAY=y
++CONFIG_ZONE_DMA=y
++CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
++CONFIG_VECTORS_BASE=0xffff0000
++CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
++CONFIG_CONSTRUCTORS=y
++
++#
++# General setup
++#
++CONFIG_EXPERIMENTAL=y
++CONFIG_BROKEN_ON_SMP=y
++CONFIG_LOCK_KERNEL=y
++CONFIG_INIT_ENV_ARG_LIMIT=32
++CONFIG_LOCALVERSION=""
++CONFIG_LOCALVERSION_AUTO=y
++# CONFIG_SWAP is not set
++CONFIG_SYSVIPC=y
++CONFIG_SYSVIPC_SYSCTL=y
++CONFIG_POSIX_MQUEUE=y
++CONFIG_POSIX_MQUEUE_SYSCTL=y
++# CONFIG_BSD_PROCESS_ACCT is not set
++# CONFIG_TASKSTATS is not set
++# CONFIG_AUDIT is not set
++
++#
++# RCU Subsystem
++#
++CONFIG_TREE_RCU=y
++# CONFIG_TREE_PREEMPT_RCU is not set
++# CONFIG_RCU_TRACE is not set
++CONFIG_RCU_FANOUT=32
++# CONFIG_RCU_FANOUT_EXACT is not set
++# CONFIG_TREE_RCU_TRACE is not set
++CONFIG_IKCONFIG=y
++CONFIG_IKCONFIG_PROC=y
++CONFIG_LOG_BUF_SHIFT=14
++CONFIG_GROUP_SCHED=y
++CONFIG_FAIR_GROUP_SCHED=y
++# CONFIG_RT_GROUP_SCHED is not set
++CONFIG_USER_SCHED=y
++# CONFIG_CGROUP_SCHED is not set
++# CONFIG_CGROUPS is not set
++# CONFIG_SYSFS_DEPRECATED_V2 is not set
++# CONFIG_RELAY is not set
++# CONFIG_NAMESPACES is not set
++CONFIG_BLK_DEV_INITRD=y
++CONFIG_INITRAMFS_SOURCE=""
++CONFIG_RD_GZIP=y
++# CONFIG_RD_BZIP2 is not set
++# CONFIG_RD_LZMA is not set
++CONFIG_CC_OPTIMIZE_FOR_SIZE=y
++CONFIG_SYSCTL=y
++CONFIG_ANON_INODES=y
++CONFIG_EMBEDDED=y
++CONFIG_UID16=y
++CONFIG_SYSCTL_SYSCALL=y
++CONFIG_KALLSYMS=y
++# CONFIG_KALLSYMS_ALL is not set
++# CONFIG_KALLSYMS_EXTRA_PASS is not set
++CONFIG_HOTPLUG=y
++CONFIG_PRINTK=y
++CONFIG_BUG=y
++CONFIG_ELF_CORE=y
++CONFIG_BASE_FULL=y
++CONFIG_FUTEX=y
++CONFIG_EPOLL=y
++CONFIG_SIGNALFD=y
++CONFIG_TIMERFD=y
++CONFIG_EVENTFD=y
++CONFIG_SHMEM=y
++CONFIG_AIO=y
++
++#
++# Kernel Performance Events And Counters
++#
++CONFIG_VM_EVENT_COUNTERS=y
++CONFIG_SLUB_DEBUG=y
++CONFIG_COMPAT_BRK=y
++# CONFIG_SLAB is not set
++CONFIG_SLUB=y
++# CONFIG_SLOB is not set
++# CONFIG_PROFILING is not set
++CONFIG_HAVE_OPROFILE=y
++# CONFIG_KPROBES is not set
++CONFIG_HAVE_KPROBES=y
++CONFIG_HAVE_KRETPROBES=y
++CONFIG_HAVE_CLK=y
++
++#
++# GCOV-based kernel profiling
++#
++# CONFIG_GCOV_KERNEL is not set
++# CONFIG_SLOW_WORK is not set
++CONFIG_HAVE_GENERIC_DMA_COHERENT=y
++CONFIG_SLABINFO=y
++CONFIG_RT_MUTEXES=y
++CONFIG_BASE_SMALL=0
++CONFIG_MODULES=y
++# CONFIG_MODULE_FORCE_LOAD is not set
++CONFIG_MODULE_UNLOAD=y
++CONFIG_MODULE_FORCE_UNLOAD=y
++CONFIG_MODVERSIONS=y
++# CONFIG_MODULE_SRCVERSION_ALL is not set
++CONFIG_BLOCK=y
++CONFIG_LBDAF=y
++# CONFIG_BLK_DEV_BSG is not set
++# CONFIG_BLK_DEV_INTEGRITY is not set
++
++#
++# IO Schedulers
++#
++CONFIG_IOSCHED_NOOP=y
++CONFIG_IOSCHED_AS=y
++# CONFIG_IOSCHED_DEADLINE is not set
++# CONFIG_IOSCHED_CFQ is not set
++CONFIG_DEFAULT_AS=y
++# CONFIG_DEFAULT_DEADLINE is not set
++# CONFIG_DEFAULT_CFQ is not set
++# CONFIG_DEFAULT_NOOP is not set
++CONFIG_DEFAULT_IOSCHED="anticipatory"
++# CONFIG_FREEZER is not set
++
++#
++# System Type
++#
++CONFIG_MMU=y
++# CONFIG_ARCH_AAEC2000 is not set
++# CONFIG_ARCH_INTEGRATOR is not set
++# CONFIG_ARCH_REALVIEW is not set
++# CONFIG_ARCH_VERSATILE is not set
++# CONFIG_ARCH_AT91 is not set
++# CONFIG_ARCH_CLPS711X is not set
++# CONFIG_ARCH_GEMINI is not set
++# CONFIG_ARCH_EBSA110 is not set
++# CONFIG_ARCH_EP93XX is not set
++# CONFIG_ARCH_FOOTBRIDGE is not set
++# CONFIG_ARCH_MXC is not set
++# CONFIG_ARCH_STMP3XXX is not set
++# CONFIG_ARCH_NETX is not set
++# CONFIG_ARCH_H720X is not set
++# CONFIG_ARCH_NOMADIK is not set
++# CONFIG_ARCH_IOP13XX is not set
++# CONFIG_ARCH_IOP32X is not set
++# CONFIG_ARCH_IOP33X is not set
++# CONFIG_ARCH_IXP23XX is not set
++# CONFIG_ARCH_IXP2000 is not set
++# CONFIG_ARCH_IXP4XX is not set
++# CONFIG_ARCH_L7200 is not set
++# CONFIG_ARCH_KIRKWOOD is not set
++# CONFIG_ARCH_LOKI is not set
++# CONFIG_ARCH_MV78XX0 is not set
++# CONFIG_ARCH_ORION5X is not set
++# CONFIG_ARCH_MMP is not set
++# CONFIG_ARCH_KS8695 is not set
++# CONFIG_ARCH_NS9XXX is not set
++# CONFIG_ARCH_W90X900 is not set
++# CONFIG_ARCH_PNX4008 is not set
++# CONFIG_ARCH_PXA is not set
++# CONFIG_ARCH_MSM is not set
++# CONFIG_ARCH_RPC is not set
++# CONFIG_ARCH_SA1100 is not set
++# CONFIG_ARCH_S3C2410 is not set
++# CONFIG_ARCH_S3C64XX is not set
++# CONFIG_ARCH_S5PC1XX is not set
++# CONFIG_ARCH_SHARK is not set
++# CONFIG_ARCH_LH7A40X is not set
++# CONFIG_ARCH_U300 is not set
++CONFIG_ARCH_DAVINCI=y
++# CONFIG_ARCH_OMAP is not set
++# CONFIG_ARCH_BCMRING is not set
++CONFIG_AINTC=y
++CONFIG_ARCH_DAVINCI_DMx=y
++
++#
++# TI DaVinci Implementations
++#
++
++#
++# DaVinci Core Type
++#
++# CONFIG_ARCH_DAVINCI_DM644x is not set
++# CONFIG_ARCH_DAVINCI_DM355 is not set
++CONFIG_ARCH_DAVINCI_DM646x=y
++# CONFIG_ARCH_DAVINCI_DA830 is not set
++# CONFIG_ARCH_DAVINCI_DA850 is not set
++# CONFIG_ARCH_DAVINCI_DM365 is not set
++
++#
++# DaVinci Board Type
++#
++CONFIG_MACH_DAVINCI_DM6467_EVM=y
++CONFIG_DAVINCI_MUX=y
++CONFIG_DAVINCI_MUX_DEBUG=y
++CONFIG_DAVINCI_MUX_WARNINGS=y
++CONFIG_DAVINCI_RESET_CLOCKS=y
++CONFIG_OSC_CLK_FREQ=33000000
++
++#
++# Processor Type
++#
++CONFIG_CPU_32=y
++CONFIG_CPU_ARM926T=y
++CONFIG_CPU_32v5=y
++CONFIG_CPU_ABRT_EV5TJ=y
++CONFIG_CPU_PABRT_NOIFAR=y
++CONFIG_CPU_CACHE_VIVT=y
++CONFIG_CPU_COPY_V4WB=y
++CONFIG_CPU_TLB_V4WBI=y
++CONFIG_CPU_CP15=y
++CONFIG_CPU_CP15_MMU=y
++
++#
++# Processor Features
++#
++CONFIG_ARM_THUMB=y
++# CONFIG_CPU_ICACHE_DISABLE is not set
++# CONFIG_CPU_DCACHE_DISABLE is not set
++# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
++# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
++CONFIG_ARM_L1_CACHE_SHIFT=5
++CONFIG_COMMON_CLKDEV=y
++CONFIG_FORCE_MAX_ZONEORDER=13
++
++#
++# Bus support
++#
++# CONFIG_PCI is not set
++# CONFIG_PCI_SYSCALL is not set
++# CONFIG_ARCH_SUPPORTS_MSI is not set
++# CONFIG_PCCARD is not set
++
++#
++# Kernel Features
++#
++CONFIG_TICK_ONESHOT=y
++CONFIG_NO_HZ=y
++CONFIG_HIGH_RES_TIMERS=y
++CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
++CONFIG_VMSPLIT_3G=y
++# CONFIG_VMSPLIT_2G is not set
++# CONFIG_VMSPLIT_1G is not set
++CONFIG_PAGE_OFFSET=0xC0000000
++# CONFIG_PREEMPT_NONE is not set
++# CONFIG_PREEMPT_VOLUNTARY is not set
++CONFIG_PREEMPT=y
++CONFIG_HZ=100
++CONFIG_AEABI=y
++# CONFIG_OABI_COMPAT is not set
++# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
++# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
++# CONFIG_HIGHMEM is not set
++CONFIG_SELECT_MEMORY_MODEL=y
++CONFIG_FLATMEM_MANUAL=y
++# CONFIG_DISCONTIGMEM_MANUAL is not set
++# CONFIG_SPARSEMEM_MANUAL is not set
++CONFIG_FLATMEM=y
++CONFIG_FLAT_NODE_MEM_MAP=y
++CONFIG_PAGEFLAGS_EXTENDED=y
++CONFIG_SPLIT_PTLOCK_CPUS=4096
++# CONFIG_PHYS_ADDR_T_64BIT is not set
++CONFIG_ZONE_DMA_FLAG=1
++CONFIG_BOUNCE=y
++CONFIG_VIRT_TO_BUS=y
++CONFIG_HAVE_MLOCK=y
++CONFIG_HAVE_MLOCKED_PAGE_BIT=y
++# CONFIG_KSM is not set
++CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
++CONFIG_LEDS=y
++# CONFIG_LEDS_CPU is not set
++CONFIG_ALIGNMENT_TRAP=y
++# CONFIG_UACCESS_WITH_MEMCPY is not set
++
++#
++# Boot options
++#
++CONFIG_ZBOOT_ROM_TEXT=0x0
++CONFIG_ZBOOT_ROM_BSS=0x0
++CONFIG_CMDLINE=""
++# CONFIG_XIP_KERNEL is not set
++# CONFIG_KEXEC is not set
++
++#
++# CPU Power Management
++#
++# CONFIG_CPU_IDLE is not set
++
++#
++# Floating point emulation
++#
++
++#
++# At least one emulation must be selected
++#
++# CONFIG_VFP is not set
++
++#
++# Userspace binary formats
++#
++CONFIG_BINFMT_ELF=y
++# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
++CONFIG_HAVE_AOUT=y
++# CONFIG_BINFMT_AOUT is not set
++# CONFIG_BINFMT_MISC is not set
++
++#
++# Power management options
++#
++# CONFIG_PM is not set
++CONFIG_ARCH_SUSPEND_POSSIBLE=y
++CONFIG_NET=y
++
++#
++# Networking options
++#
++CONFIG_PACKET=y
++# CONFIG_PACKET_MMAP is not set
++CONFIG_UNIX=y
++CONFIG_XFRM=y
++# CONFIG_XFRM_USER is not set
++# CONFIG_XFRM_SUB_POLICY is not set
++# CONFIG_XFRM_MIGRATE is not set
++# CONFIG_XFRM_STATISTICS is not set
++# CONFIG_NET_KEY is not set
++CONFIG_INET=y
++# CONFIG_IP_MULTICAST is not set
++# CONFIG_IP_ADVANCED_ROUTER is not set
++CONFIG_IP_FIB_HASH=y
++CONFIG_IP_PNP=y
++CONFIG_IP_PNP_DHCP=y
++# CONFIG_IP_PNP_BOOTP is not set
++# CONFIG_IP_PNP_RARP is not set
++# CONFIG_NET_IPIP is not set
++# CONFIG_NET_IPGRE is not set
++# CONFIG_ARPD is not set
++# CONFIG_SYN_COOKIES is not set
++# CONFIG_INET_AH is not set
++# CONFIG_INET_ESP is not set
++# CONFIG_INET_IPCOMP is not set
++# CONFIG_INET_XFRM_TUNNEL is not set
++CONFIG_INET_TUNNEL=m
++CONFIG_INET_XFRM_MODE_TRANSPORT=y
++CONFIG_INET_XFRM_MODE_TUNNEL=y
++CONFIG_INET_XFRM_MODE_BEET=y
++# CONFIG_INET_LRO is not set
++CONFIG_INET_DIAG=y
++CONFIG_INET_TCP_DIAG=y
++# CONFIG_TCP_CONG_ADVANCED is not set
++CONFIG_TCP_CONG_CUBIC=y
++CONFIG_DEFAULT_TCP_CONG="cubic"
++# CONFIG_TCP_MD5SIG is not set
++CONFIG_IPV6=m
++# CONFIG_IPV6_PRIVACY is not set
++# CONFIG_IPV6_ROUTER_PREF is not set
++# CONFIG_IPV6_OPTIMISTIC_DAD is not set
++# CONFIG_INET6_AH is not set
++# CONFIG_INET6_ESP is not set
++# CONFIG_INET6_IPCOMP is not set
++# CONFIG_IPV6_MIP6 is not set
++# CONFIG_INET6_XFRM_TUNNEL is not set
++# CONFIG_INET6_TUNNEL is not set
++CONFIG_INET6_XFRM_MODE_TRANSPORT=m
++CONFIG_INET6_XFRM_MODE_TUNNEL=m
++CONFIG_INET6_XFRM_MODE_BEET=m
++# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
++CONFIG_IPV6_SIT=m
++CONFIG_IPV6_NDISC_NODETYPE=y
++# CONFIG_IPV6_TUNNEL is not set
++# CONFIG_IPV6_MULTIPLE_TABLES is not set
++# CONFIG_IPV6_MROUTE is not set
++# CONFIG_NETWORK_SECMARK is not set
++CONFIG_NETFILTER=y
++# CONFIG_NETFILTER_DEBUG is not set
++CONFIG_NETFILTER_ADVANCED=y
++
++#
++# Core Netfilter Configuration
++#
++# CONFIG_NETFILTER_NETLINK_QUEUE is not set
++# CONFIG_NETFILTER_NETLINK_LOG is not set
++# CONFIG_NF_CONNTRACK is not set
++# CONFIG_NETFILTER_XTABLES is not set
++# CONFIG_IP_VS is not set
++
++#
++# IP: Netfilter Configuration
++#
++# CONFIG_NF_DEFRAG_IPV4 is not set
++# CONFIG_IP_NF_QUEUE is not set
++# CONFIG_IP_NF_IPTABLES is not set
++# CONFIG_IP_NF_ARPTABLES is not set
++
++#
++# IPv6: Netfilter Configuration
++#
++# CONFIG_IP6_NF_QUEUE is not set
++# CONFIG_IP6_NF_IPTABLES is not set
++# CONFIG_IP_DCCP is not set
++# CONFIG_IP_SCTP is not set
++# CONFIG_RDS is not set
++# CONFIG_TIPC is not set
++# CONFIG_ATM is not set
++# CONFIG_BRIDGE is not set
++# CONFIG_NET_DSA is not set
++# CONFIG_VLAN_8021Q is not set
++# CONFIG_DECNET is not set
++# CONFIG_LLC2 is not set
++# CONFIG_IPX is not set
++# CONFIG_ATALK is not set
++# CONFIG_X25 is not set
++# CONFIG_LAPB is not set
++# CONFIG_ECONET is not set
++# CONFIG_WAN_ROUTER is not set
++# CONFIG_PHONET is not set
++# CONFIG_IEEE802154 is not set
++# CONFIG_NET_SCHED is not set
++# CONFIG_DCB is not set
++
++#
++# Network testing
++#
++# CONFIG_NET_PKTGEN is not set
++# CONFIG_HAMRADIO is not set
++# CONFIG_CAN is not set
++# CONFIG_IRDA is not set
++# CONFIG_BT is not set
++# CONFIG_AF_RXRPC is not set
++# CONFIG_WIRELESS is not set
++# CONFIG_WIMAX is not set
++# CONFIG_RFKILL is not set
++# CONFIG_NET_9P is not set
++
++#
++# Device Drivers
++#
++
++#
++# Generic Driver Options
++#
++CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
++# CONFIG_DEVTMPFS is not set
++CONFIG_STANDALONE=y
++CONFIG_PREVENT_FIRMWARE_BUILD=y
++# CONFIG_FW_LOADER is not set
++# CONFIG_DEBUG_DRIVER is not set
++# CONFIG_DEBUG_DEVRES is not set
++# CONFIG_SYS_HYPERVISOR is not set
++# CONFIG_CONNECTOR is not set
++CONFIG_MTD=y
++# CONFIG_MTD_DEBUG is not set
++# CONFIG_MTD_TESTS is not set
++# CONFIG_MTD_CONCAT is not set
++CONFIG_MTD_PARTITIONS=y
++# CONFIG_MTD_REDBOOT_PARTS is not set
++# CONFIG_MTD_CMDLINE_PARTS is not set
++# CONFIG_MTD_AFS_PARTS is not set
++# CONFIG_MTD_AR7_PARTS is not set
++
++#
++# User Modules And Translation Layers
++#
++CONFIG_MTD_CHAR=y
++CONFIG_MTD_BLKDEVS=y
++CONFIG_MTD_BLOCK=y
++# CONFIG_FTL is not set
++# CONFIG_NFTL is not set
++# CONFIG_INFTL is not set
++# CONFIG_RFD_FTL is not set
++# CONFIG_SSFDC is not set
++# CONFIG_MTD_OOPS is not set
++
++#
++# RAM/ROM/Flash chip drivers
++#
++CONFIG_MTD_CFI=y
++# CONFIG_MTD_JEDECPROBE is not set
++CONFIG_MTD_GEN_PROBE=y
++# CONFIG_MTD_CFI_ADV_OPTIONS is not set
++CONFIG_MTD_MAP_BANK_WIDTH_1=y
++CONFIG_MTD_MAP_BANK_WIDTH_2=y
++CONFIG_MTD_MAP_BANK_WIDTH_4=y
++# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
++# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
++# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
++CONFIG_MTD_CFI_I1=y
++CONFIG_MTD_CFI_I2=y
++# CONFIG_MTD_CFI_I4 is not set
++# CONFIG_MTD_CFI_I8 is not set
++CONFIG_MTD_CFI_INTELEXT=y
++CONFIG_MTD_CFI_AMDSTD=y
++# CONFIG_MTD_CFI_STAA is not set
++CONFIG_MTD_CFI_UTIL=y
++# CONFIG_MTD_RAM is not set
++# CONFIG_MTD_ROM is not set
++# CONFIG_MTD_ABSENT is not set
++
++#
++# Mapping drivers for chip access
++#
++# CONFIG_MTD_COMPLEX_MAPPINGS is not set
++CONFIG_MTD_PHYSMAP=y
++# CONFIG_MTD_PHYSMAP_COMPAT is not set
++# CONFIG_MTD_ARM_INTEGRATOR is not set
++# CONFIG_MTD_PLATRAM is not set
++
++#
++# Self-contained MTD device drivers
++#
++# CONFIG_MTD_DATAFLASH is not set
++# CONFIG_MTD_M25P80 is not set
++# CONFIG_MTD_SST25L is not set
++# CONFIG_MTD_SLRAM is not set
++# CONFIG_MTD_PHRAM is not set
++# CONFIG_MTD_MTDRAM is not set
++# CONFIG_MTD_BLOCK2MTD is not set
++
++#
++# Disk-On-Chip Device Drivers
++#
++# CONFIG_MTD_DOC2000 is not set
++# CONFIG_MTD_DOC2001 is not set
++# CONFIG_MTD_DOC2001PLUS is not set
++CONFIG_MTD_NAND=y
++# CONFIG_MTD_NAND_VERIFY_WRITE is not set
++# CONFIG_MTD_NAND_ECC_SMC is not set
++# CONFIG_MTD_NAND_MUSEUM_IDS is not set
++# CONFIG_MTD_NAND_GPIO is not set
++CONFIG_MTD_NAND_IDS=y
++# CONFIG_MTD_NAND_DISKONCHIP is not set
++# CONFIG_MTD_NAND_NANDSIM is not set
++# CONFIG_MTD_NAND_PLATFORM is not set
++# CONFIG_MTD_ALAUDA is not set
++CONFIG_MTD_NAND_DAVINCI=y
++# CONFIG_MTD_ONENAND is not set
++
++#
++# LPDDR flash memory drivers
++#
++# CONFIG_MTD_LPDDR is not set
++
++#
++# UBI - Unsorted block images
++#
++# CONFIG_MTD_UBI is not set
++# CONFIG_PARPORT is not set
++CONFIG_BLK_DEV=y
++# CONFIG_BLK_DEV_COW_COMMON is not set
++CONFIG_BLK_DEV_LOOP=y
++# CONFIG_BLK_DEV_CRYPTOLOOP is not set
++# CONFIG_BLK_DEV_NBD is not set
++# CONFIG_BLK_DEV_UB is not set
++CONFIG_BLK_DEV_RAM=y
++CONFIG_BLK_DEV_RAM_COUNT=1
++CONFIG_BLK_DEV_RAM_SIZE=65536
++# CONFIG_BLK_DEV_XIP is not set
++# CONFIG_CDROM_PKTCDVD is not set
++# CONFIG_ATA_OVER_ETH is not set
++# CONFIG_MG_DISK is not set
++CONFIG_MISC_DEVICES=y
++# CONFIG_ICS932S401 is not set
++# CONFIG_ENCLOSURE_SERVICES is not set
++# CONFIG_ISL29003 is not set
++# CONFIG_C2PORT is not set
++
++#
++# EEPROM support
++#
++CONFIG_EEPROM_AT24=y
++CONFIG_EEPROM_AT25=y
++# CONFIG_EEPROM_LEGACY is not set
++# CONFIG_EEPROM_MAX6875 is not set
++# CONFIG_EEPROM_93CX6 is not set
++CONFIG_HAVE_IDE=y
++CONFIG_IDE=y
++
++#
++# Please see Documentation/ide/ide.txt for help/info on IDE drives
++#
++CONFIG_IDE_XFER_MODE=y
++CONFIG_IDE_TIMINGS=y
++# CONFIG_BLK_DEV_IDE_SATA is not set
++CONFIG_IDE_GD=y
++CONFIG_IDE_GD_ATA=y
++# CONFIG_IDE_GD_ATAPI is not set
++# CONFIG_BLK_DEV_IDECD is not set
++# CONFIG_BLK_DEV_IDETAPE is not set
++# CONFIG_IDE_TASK_IOCTL is not set
++CONFIG_IDE_PROC_FS=y
++
++#
++# IDE chipset support/bugfixes
++#
++# CONFIG_BLK_DEV_PLATFORM is not set
++CONFIG_BLK_DEV_IDEDMA_SFF=y
++CONFIG_BLK_DEV_PALMCHIP_BK3710=y
++CONFIG_BLK_DEV_IDEDMA=y
++
++#
++# SCSI device support
++#
++# CONFIG_RAID_ATTRS is not set
++CONFIG_SCSI=y
++CONFIG_SCSI_DMA=y
++# CONFIG_SCSI_TGT is not set
++# CONFIG_SCSI_NETLINK is not set
++CONFIG_SCSI_PROC_FS=y
++
++#
++# SCSI support type (disk, tape, CD-ROM)
++#
++CONFIG_BLK_DEV_SD=y
++# CONFIG_CHR_DEV_ST is not set
++# CONFIG_CHR_DEV_OSST is not set
++# CONFIG_BLK_DEV_SR is not set
++# CONFIG_CHR_DEV_SG is not set
++# CONFIG_CHR_DEV_SCH is not set
++# CONFIG_SCSI_MULTI_LUN is not set
++# CONFIG_SCSI_CONSTANTS is not set
++# CONFIG_SCSI_LOGGING is not set
++# CONFIG_SCSI_SCAN_ASYNC is not set
++CONFIG_SCSI_WAIT_SCAN=m
++
++#
++# SCSI Transports
++#
++# CONFIG_SCSI_SPI_ATTRS is not set
++# CONFIG_SCSI_FC_ATTRS is not set
++# CONFIG_SCSI_ISCSI_ATTRS is not set
++# CONFIG_SCSI_SAS_LIBSAS is not set
++# CONFIG_SCSI_SRP_ATTRS is not set
++CONFIG_SCSI_LOWLEVEL=y
++# CONFIG_ISCSI_TCP is not set
++# CONFIG_LIBFC is not set
++# CONFIG_LIBFCOE is not set
++# CONFIG_SCSI_DEBUG is not set
++# CONFIG_SCSI_DH is not set
++# CONFIG_SCSI_OSD_INITIATOR is not set
++CONFIG_ATA=y
++# CONFIG_ATA_NONSTANDARD is not set
++CONFIG_ATA_VERBOSE_ERROR=y
++CONFIG_SATA_PMP=y
++CONFIG_ATA_SFF=y
++# CONFIG_SATA_MV is not set
++# CONFIG_PATA_PLATFORM is not set
++# CONFIG_MD is not set
++CONFIG_NETDEVICES=y
++# CONFIG_DUMMY is not set
++# CONFIG_BONDING is not set
++# CONFIG_MACVLAN is not set
++# CONFIG_EQUALIZER is not set
++CONFIG_TUN=y
++# CONFIG_VETH is not set
++CONFIG_PHYLIB=y
++
++#
++# MII PHY device drivers
++#
++# CONFIG_MARVELL_PHY is not set
++# CONFIG_DAVICOM_PHY is not set
++# CONFIG_QSEMI_PHY is not set
++CONFIG_LXT_PHY=y
++# CONFIG_CICADA_PHY is not set
++# CONFIG_VITESSE_PHY is not set
++# CONFIG_SMSC_PHY is not set
++# CONFIG_BROADCOM_PHY is not set
++# CONFIG_ICPLUS_PHY is not set
++# CONFIG_REALTEK_PHY is not set
++# CONFIG_NATIONAL_PHY is not set
++# CONFIG_STE10XP is not set
++CONFIG_LSI_ET1011C_PHY=y
++# CONFIG_FIXED_PHY is not set
++# CONFIG_MDIO_BITBANG is not set
++CONFIG_NET_ETHERNET=y
++CONFIG_MII=y
++# CONFIG_AX88796 is not set
++# CONFIG_SMC91X is not set
++CONFIG_TI_DAVINCI_EMAC=y
++CONFIG_DM9000=y
++CONFIG_DM9000_DEBUGLEVEL=4
++# CONFIG_DM9000_FORCE_SIMPLE_PHY_POLL is not set
++# CONFIG_ENC28J60 is not set
++# CONFIG_ETHOC is not set
++# CONFIG_SMC911X is not set
++# CONFIG_SMSC911X is not set
++# CONFIG_DNET is not set
++# CONFIG_IBM_NEW_EMAC_ZMII is not set
++# CONFIG_IBM_NEW_EMAC_RGMII is not set
++# CONFIG_IBM_NEW_EMAC_TAH is not set
++# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
++# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
++# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
++# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
++# CONFIG_B44 is not set
++# CONFIG_KS8842 is not set
++# CONFIG_KS8851 is not set
++# CONFIG_NETDEV_1000 is not set
++# CONFIG_NETDEV_10000 is not set
++CONFIG_WLAN=y
++# CONFIG_WLAN_PRE80211 is not set
++# CONFIG_WLAN_80211 is not set
++
++#
++# Enable WiMAX (Networking options) to see the WiMAX drivers
++#
++
++#
++# USB Network Adapters
++#
++# CONFIG_USB_CATC is not set
++# CONFIG_USB_KAWETH is not set
++# CONFIG_USB_PEGASUS is not set
++# CONFIG_USB_RTL8150 is not set
++# CONFIG_USB_USBNET is not set
++# CONFIG_WAN is not set
++CONFIG_PPP=y
++# CONFIG_PPP_MULTILINK is not set
++# CONFIG_PPP_FILTER is not set
++CONFIG_PPP_ASYNC=y
++CONFIG_PPP_SYNC_TTY=y
++CONFIG_PPP_DEFLATE=y
++# CONFIG_PPP_BSDCOMP is not set
++# CONFIG_PPP_MPPE is not set
++# CONFIG_PPPOE is not set
++# CONFIG_PPPOL2TP is not set
++# CONFIG_SLIP is not set
++CONFIG_SLHC=y
++CONFIG_NETCONSOLE=y
++# CONFIG_NETCONSOLE_DYNAMIC is not set
++CONFIG_NETPOLL=y
++CONFIG_NETPOLL_TRAP=y
++CONFIG_NET_POLL_CONTROLLER=y
++# CONFIG_ISDN is not set
++# CONFIG_PHONE is not set
++
++#
++# Input device support
++#
++CONFIG_INPUT=y
++# CONFIG_INPUT_FF_MEMLESS is not set
++# CONFIG_INPUT_POLLDEV is not set
++
++#
++# Userland interfaces
++#
++# CONFIG_INPUT_MOUSEDEV is not set
++# CONFIG_INPUT_JOYDEV is not set
++CONFIG_INPUT_EVDEV=y
++CONFIG_INPUT_EVBUG=y
++
++#
++# Input Device Drivers
++#
++CONFIG_INPUT_KEYBOARD=y
++# CONFIG_KEYBOARD_ADP5588 is not set
++CONFIG_KEYBOARD_ATKBD=m
++# CONFIG_QT2160 is not set
++# CONFIG_KEYBOARD_LKKBD is not set
++CONFIG_KEYBOARD_GPIO=y
++# CONFIG_KEYBOARD_MATRIX is not set
++# CONFIG_KEYBOARD_LM8323 is not set
++# CONFIG_KEYBOARD_MAX7359 is not set
++# CONFIG_KEYBOARD_NEWTON is not set
++# CONFIG_KEYBOARD_OPENCORES is not set
++# CONFIG_KEYBOARD_STOWAWAY is not set
++# CONFIG_KEYBOARD_SUNKBD is not set
++CONFIG_KEYBOARD_XTKBD=m
++# CONFIG_INPUT_MOUSE is not set
++# CONFIG_INPUT_JOYSTICK is not set
++# CONFIG_INPUT_TABLET is not set
++CONFIG_INPUT_TOUCHSCREEN=y
++# CONFIG_TOUCHSCREEN_ADS7846 is not set
++# CONFIG_TOUCHSCREEN_AD7877 is not set
++# CONFIG_TOUCHSCREEN_AD7879_I2C is not set
++# CONFIG_TOUCHSCREEN_AD7879_SPI is not set
++# CONFIG_TOUCHSCREEN_AD7879 is not set
++# CONFIG_TOUCHSCREEN_EETI is not set
++# CONFIG_TOUCHSCREEN_FUJITSU is not set
++# CONFIG_TOUCHSCREEN_GUNZE is not set
++# CONFIG_TOUCHSCREEN_ELO is not set
++# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
++# CONFIG_TOUCHSCREEN_MCS5000 is not set
++# CONFIG_TOUCHSCREEN_MTOUCH is not set
++# CONFIG_TOUCHSCREEN_INEXIO is not set
++# CONFIG_TOUCHSCREEN_MK712 is not set
++# CONFIG_TOUCHSCREEN_PENMOUNT is not set
++# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
++# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
++# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
++# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
++# CONFIG_TOUCHSCREEN_TSC2007 is not set
++# CONFIG_TOUCHSCREEN_W90X900 is not set
++# CONFIG_INPUT_MISC is not set
++
++#
++# Hardware I/O ports
++#
++CONFIG_SERIO=y
++CONFIG_SERIO_SERPORT=y
++CONFIG_SERIO_LIBPS2=y
++# CONFIG_SERIO_RAW is not set
++# CONFIG_GAMEPORT is not set
++
++#
++# Character devices
++#
++CONFIG_VT=y
++CONFIG_CONSOLE_TRANSLATIONS=y
++# CONFIG_VT_CONSOLE is not set
++CONFIG_HW_CONSOLE=y
++# CONFIG_VT_HW_CONSOLE_BINDING is not set
++CONFIG_DEVKMEM=y
++# CONFIG_SERIAL_NONSTANDARD is not set
++
++#
++# Serial drivers
++#
++CONFIG_SERIAL_8250=y
++CONFIG_SERIAL_8250_CONSOLE=y
++CONFIG_SERIAL_8250_NR_UARTS=3
++CONFIG_SERIAL_8250_RUNTIME_UARTS=3
++# CONFIG_SERIAL_8250_EXTENDED is not set
++
++#
++# Non-8250 serial port support
++#
++# CONFIG_SERIAL_MAX3100 is not set
++CONFIG_SERIAL_CORE=y
++CONFIG_SERIAL_CORE_CONSOLE=y
++CONFIG_UNIX98_PTYS=y
++# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
++CONFIG_LEGACY_PTYS=y
++CONFIG_LEGACY_PTY_COUNT=256
++# CONFIG_IPMI_HANDLER is not set
++# CONFIG_HW_RANDOM is not set
++# CONFIG_R3964 is not set
++# CONFIG_RAW_DRIVER is not set
++# CONFIG_TCG_TPM is not set
++CONFIG_VDCE=y
++CONFIG_CIR=y
++CONFIG_I2C=y
++CONFIG_I2C_BOARDINFO=y
++CONFIG_I2C_COMPAT=y
++CONFIG_I2C_CHARDEV=y
++CONFIG_I2C_HELPER_AUTO=y
++
++#
++# I2C Hardware Bus support
++#
++
++#
++# I2C system bus drivers (mostly embedded / system-on-chip)
++#
++CONFIG_I2C_DAVINCI=y
++# CONFIG_I2C_DESIGNWARE is not set
++# CONFIG_I2C_GPIO is not set
++# CONFIG_I2C_OCORES is not set
++# CONFIG_I2C_SIMTEC is not set
++
++#
++# External I2C/SMBus adapter drivers
++#
++# CONFIG_I2C_PARPORT_LIGHT is not set
++# CONFIG_I2C_TAOS_EVM is not set
++# CONFIG_I2C_TINY_USB is not set
++
++#
++# Other I2C/SMBus bus drivers
++#
++# CONFIG_I2C_PCA_PLATFORM is not set
++# CONFIG_I2C_STUB is not set
++
++#
++# Miscellaneous I2C Chip support
++#
++# CONFIG_DS1682 is not set
++# CONFIG_SENSORS_TSL2550 is not set
++# CONFIG_I2C_DEBUG_CORE is not set
++# CONFIG_I2C_DEBUG_ALGO is not set
++# CONFIG_I2C_DEBUG_BUS is not set
++# CONFIG_I2C_DEBUG_CHIP is not set
++CONFIG_SPI=y
++# CONFIG_SPI_DEBUG is not set
++CONFIG_SPI_MASTER=y
++
++#
++# SPI Master Controller Drivers
++#
++CONFIG_SPI_DAVINCI=y
++CONFIG_SPI_BITBANG=y
++CONFIG_SPI_GPIO=y
++
++#
++# SPI Protocol Masters
++#
++# CONFIG_SPI_SPIDEV is not set
++# CONFIG_SPI_TLE62X0 is not set
++
++#
++# PPS support
++#
++# CONFIG_PPS is not set
++CONFIG_ARCH_REQUIRE_GPIOLIB=y
++CONFIG_GPIOLIB=y
++# CONFIG_DEBUG_GPIO is not set
++# CONFIG_GPIO_SYSFS is not set
++
++#
++# Memory mapped GPIO expanders:
++#
++
++#
++# I2C GPIO expanders:
++#
++# CONFIG_GPIO_MAX732X is not set
++# CONFIG_GPIO_PCA953X is not set
++CONFIG_GPIO_PCF857X=y
++
++#
++# PCI GPIO expanders:
++#
++
++#
++# SPI GPIO expanders:
++#
++# CONFIG_GPIO_MAX7301 is not set
++# CONFIG_GPIO_MCP23S08 is not set
++# CONFIG_GPIO_MC33880 is not set
++
++#
++# AC97 GPIO expanders:
++#
++# CONFIG_W1 is not set
++# CONFIG_POWER_SUPPLY is not set
++CONFIG_HWMON=y
++# CONFIG_HWMON_VID is not set
++# CONFIG_HWMON_DEBUG_CHIP is not set
++
++#
++# Native drivers
++#
++# CONFIG_SENSORS_AD7414 is not set
++# CONFIG_SENSORS_AD7418 is not set
++# CONFIG_SENSORS_ADCXX is not set
++# CONFIG_SENSORS_ADM1021 is not set
++# CONFIG_SENSORS_ADM1025 is not set
++# CONFIG_SENSORS_ADM1026 is not set
++# CONFIG_SENSORS_ADM1029 is not set
++# CONFIG_SENSORS_ADM1031 is not set
++# CONFIG_SENSORS_ADM9240 is not set
++# CONFIG_SENSORS_ADT7462 is not set
++# CONFIG_SENSORS_ADT7470 is not set
++# CONFIG_SENSORS_ADT7473 is not set
++# CONFIG_SENSORS_ADT7475 is not set
++# CONFIG_SENSORS_ATXP1 is not set
++# CONFIG_SENSORS_DS1621 is not set
++# CONFIG_SENSORS_F71805F is not set
++# CONFIG_SENSORS_F71882FG is not set
++# CONFIG_SENSORS_F75375S is not set
++# CONFIG_SENSORS_G760A is not set
++# CONFIG_SENSORS_GL518SM is not set
++# CONFIG_SENSORS_GL520SM is not set
++# CONFIG_SENSORS_IT87 is not set
++# CONFIG_SENSORS_LM63 is not set
++# CONFIG_SENSORS_LM70 is not set
++# CONFIG_SENSORS_LM75 is not set
++# CONFIG_SENSORS_LM77 is not set
++# CONFIG_SENSORS_LM78 is not set
++# CONFIG_SENSORS_LM80 is not set
++# CONFIG_SENSORS_LM83 is not set
++# CONFIG_SENSORS_LM85 is not set
++# CONFIG_SENSORS_LM87 is not set
++# CONFIG_SENSORS_LM90 is not set
++# CONFIG_SENSORS_LM92 is not set
++# CONFIG_SENSORS_LM93 is not set
++# CONFIG_SENSORS_LTC4215 is not set
++# CONFIG_SENSORS_LTC4245 is not set
++# CONFIG_SENSORS_LM95241 is not set
++# CONFIG_SENSORS_MAX1111 is not set
++# CONFIG_SENSORS_MAX1619 is not set
++# CONFIG_SENSORS_MAX6650 is not set
++# CONFIG_SENSORS_PC87360 is not set
++# CONFIG_SENSORS_PC87427 is not set
++# CONFIG_SENSORS_PCF8591 is not set
++# CONFIG_SENSORS_SHT15 is not set
++# CONFIG_SENSORS_DME1737 is not set
++# CONFIG_SENSORS_SMSC47M1 is not set
++# CONFIG_SENSORS_SMSC47M192 is not set
++# CONFIG_SENSORS_SMSC47B397 is not set
++# CONFIG_SENSORS_ADS7828 is not set
++# CONFIG_SENSORS_THMC50 is not set
++# CONFIG_SENSORS_TMP401 is not set
++# CONFIG_SENSORS_TMP421 is not set
++# CONFIG_SENSORS_VT1211 is not set
++# CONFIG_SENSORS_W83781D is not set
++# CONFIG_SENSORS_W83791D is not set
++# CONFIG_SENSORS_W83792D is not set
++# CONFIG_SENSORS_W83793 is not set
++# CONFIG_SENSORS_W83L785TS is not set
++# CONFIG_SENSORS_W83L786NG is not set
++# CONFIG_SENSORS_W83627HF is not set
++# CONFIG_SENSORS_W83627EHF is not set
++# CONFIG_SENSORS_LIS3_SPI is not set
++# CONFIG_THERMAL is not set
++CONFIG_WATCHDOG=y
++# CONFIG_WATCHDOG_NOWAYOUT is not set
++
++#
++# Watchdog Device Drivers
++#
++# CONFIG_SOFT_WATCHDOG is not set
++CONFIG_DAVINCI_WATCHDOG=y
++
++#
++# USB-based Watchdog Cards
++#
++# CONFIG_USBPCWATCHDOG is not set
++CONFIG_SSB_POSSIBLE=y
++
++#
++# Sonics Silicon Backplane
++#
++# CONFIG_SSB is not set
++
++#
++# Multifunction device drivers
++#
++# CONFIG_MFD_CORE is not set
++# CONFIG_MFD_SM501 is not set
++# CONFIG_MFD_ASIC3 is not set
++# CONFIG_HTC_EGPIO is not set
++# CONFIG_HTC_PASIC3 is not set
++# CONFIG_TPS65010 is not set
++# CONFIG_TWL4030_CORE is not set
++# CONFIG_MFD_TMIO is not set
++# CONFIG_MFD_T7L66XB is not set
++# CONFIG_MFD_TC6387XB is not set
++# CONFIG_MFD_TC6393XB is not set
++# CONFIG_PMIC_DA903X is not set
++# CONFIG_MFD_WM8400 is not set
++# CONFIG_MFD_WM831X is not set
++# CONFIG_MFD_WM8350_I2C is not set
++# CONFIG_MFD_PCF50633 is not set
++# CONFIG_MFD_MC13783 is not set
++# CONFIG_AB3100_CORE is not set
++# CONFIG_EZX_PCAP is not set
++# CONFIG_REGULATOR is not set
++CONFIG_MEDIA_SUPPORT=y
++
++#
++# Multimedia core support
++#
++CONFIG_VIDEO_DEV=y
++CONFIG_VIDEO_V4L2_COMMON=y
++# CONFIG_VIDEO_ALLOW_V4L1 is not set
++# CONFIG_VIDEO_V4L1_COMPAT is not set
++# CONFIG_DVB_CORE is not set
++CONFIG_VIDEO_MEDIA=y
++
++#
++# Multimedia drivers
++#
++# CONFIG_MEDIA_ATTACH is not set
++CONFIG_MEDIA_TUNER=y
++# CONFIG_MEDIA_TUNER_CUSTOMISE is not set
++CONFIG_MEDIA_TUNER_SIMPLE=y
++CONFIG_MEDIA_TUNER_TDA8290=y
++CONFIG_MEDIA_TUNER_TDA9887=y
++CONFIG_MEDIA_TUNER_TEA5761=y
++CONFIG_MEDIA_TUNER_TEA5767=y
++CONFIG_MEDIA_TUNER_MT20XX=y
++CONFIG_MEDIA_TUNER_XC2028=y
++CONFIG_MEDIA_TUNER_XC5000=y
++CONFIG_MEDIA_TUNER_MC44S803=y
++CONFIG_VIDEO_V4L2=y
++CONFIG_VIDEOBUF_GEN=y
++CONFIG_VIDEOBUF_DMA_CONTIG=y
++CONFIG_VIDEO_CAPTURE_DRIVERS=y
++# CONFIG_VIDEO_ADV_DEBUG is not set
++# CONFIG_VIDEO_FIXED_MINOR_RANGES is not set
++# CONFIG_VIDEO_HELPER_CHIPS_AUTO is not set
++
++#
++# Encoders/decoders and other helper chips
++#
++
++#
++# Audio decoders
++#
++# CONFIG_VIDEO_TVAUDIO is not set
++# CONFIG_VIDEO_TDA7432 is not set
++# CONFIG_VIDEO_TDA9840 is not set
++# CONFIG_VIDEO_TDA9875 is not set
++# CONFIG_VIDEO_TEA6415C is not set
++# CONFIG_VIDEO_TEA6420 is not set
++# CONFIG_VIDEO_MSP3400 is not set
++# CONFIG_VIDEO_CS5345 is not set
++# CONFIG_VIDEO_CS53L32A is not set
++# CONFIG_VIDEO_M52790 is not set
++# CONFIG_VIDEO_TLV320AIC23B is not set
++# CONFIG_VIDEO_WM8775 is not set
++# CONFIG_VIDEO_WM8739 is not set
++# CONFIG_VIDEO_VP27SMPX is not set
++
++#
++# RDS decoders
++#
++# CONFIG_VIDEO_SAA6588 is not set
++
++#
++# Video decoders
++#
++# CONFIG_VIDEO_ADV7180 is not set
++# CONFIG_VIDEO_BT819 is not set
++# CONFIG_VIDEO_BT856 is not set
++# CONFIG_VIDEO_BT866 is not set
++# CONFIG_VIDEO_KS0127 is not set
++# CONFIG_VIDEO_OV7670 is not set
++# CONFIG_VIDEO_MT9V011 is not set
++# CONFIG_VIDEO_TCM825X is not set
++# CONFIG_VIDEO_SAA7110 is not set
++# CONFIG_VIDEO_SAA711X is not set
++# CONFIG_VIDEO_SAA717X is not set
++# CONFIG_VIDEO_TVP514X is not set
++# CONFIG_VIDEO_TVP5150 is not set
++CONFIG_VIDEO_TVP7002=y
++# CONFIG_VIDEO_VPX3220 is not set
++
++#
++# Video and audio decoders
++#
++# CONFIG_VIDEO_CX25840 is not set
++
++#
++# MPEG video encoders
++#
++# CONFIG_VIDEO_CX2341X is not set
++
++#
++# Video encoders
++#
++# CONFIG_VIDEO_SAA7127 is not set
++# CONFIG_VIDEO_SAA7185 is not set
++# CONFIG_VIDEO_ADV7170 is not set
++# CONFIG_VIDEO_ADV7175 is not set
++CONFIG_VIDEO_THS7303=y
++CONFIG_VIDEO_THS7353=y
++CONFIG_VIDEO_THS7353_LUMA_CHANNEL=3
++# CONFIG_VIDEO_ADV7343 is not set
++CONFIG_VIDEO_THS8200=y
++
++#
++# Video improvement chips
++#
++# CONFIG_VIDEO_UPD64031A is not set
++# CONFIG_VIDEO_UPD64083 is not set
++CONFIG_DISPLAY_DAVINCI_DM646X_EVM=y
++CONFIG_CAPTURE_DAVINCI_DM646X_EVM=y
++CONFIG_VIDEO_DAVINCI_VPIF=y
++# CONFIG_VIDEO_DAVINCI_DISPLAY is not set
++# CONFIG_DAVINCI_ENC_MNGR is not set
++# CONFIG_DAVINCI_OSD is not set
++# CONFIG_VIDEO_VIVI is not set
++# CONFIG_VIDEO_VPSS_SYSTEM is not set
++# CONFIG_VIDEO_VPFE_CAPTURE is not set
++# CONFIG_VIDEO_SAA5246A is not set
++# CONFIG_VIDEO_SAA5249 is not set
++# CONFIG_SOC_CAMERA is not set
++# CONFIG_SOC_CAMERA_MT9T031 is not set
++# CONFIG_V4L_USB_DRIVERS is not set
++# CONFIG_RADIO_ADAPTERS is not set
++# CONFIG_DAB is not set
++
++#
++# Graphics support
++#
++# CONFIG_VGASTATE is not set
++# CONFIG_VIDEO_OUTPUT_CONTROL is not set
++# CONFIG_FB is not set
++# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
++
++#
++# Display device support
++#
++# CONFIG_DISPLAY_SUPPORT is not set
++
++#
++# Console display driver support
++#
++# CONFIG_VGA_CONSOLE is not set
++CONFIG_DUMMY_CONSOLE=y
++CONFIG_SOUND=y
++# CONFIG_SOUND_OSS_CORE is not set
++CONFIG_SND=y
++CONFIG_SND_TIMER=y
++CONFIG_SND_PCM=y
++CONFIG_SND_JACK=y
++# CONFIG_SND_SEQUENCER is not set
++# CONFIG_SND_MIXER_OSS is not set
++# CONFIG_SND_PCM_OSS is not set
++# CONFIG_SND_HRTIMER is not set
++# CONFIG_SND_DYNAMIC_MINORS is not set
++CONFIG_SND_SUPPORT_OLD_API=y
++CONFIG_SND_VERBOSE_PROCFS=y
++# CONFIG_SND_VERBOSE_PRINTK is not set
++# CONFIG_SND_DEBUG is not set
++# CONFIG_SND_RAWMIDI_SEQ is not set
++# CONFIG_SND_OPL3_LIB_SEQ is not set
++# CONFIG_SND_OPL4_LIB_SEQ is not set
++# CONFIG_SND_SBAWE_SEQ is not set
++# CONFIG_SND_EMU10K1_SEQ is not set
++CONFIG_SND_DRIVERS=y
++# CONFIG_SND_DUMMY is not set
++# CONFIG_SND_MTPAV is not set
++# CONFIG_SND_SERIAL_U16550 is not set
++# CONFIG_SND_MPU401 is not set
++CONFIG_SND_ARM=y
++CONFIG_SND_SPI=y
++CONFIG_SND_USB=y
++# CONFIG_SND_USB_AUDIO is not set
++# CONFIG_SND_USB_CAIAQ is not set
++CONFIG_SND_SOC=y
++CONFIG_SND_DAVINCI_SOC=y
++CONFIG_SND_DAVINCI_SOC_MCASP=y
++CONFIG_SND_DM6467_SOC_EVM=y
++CONFIG_SND_SOC_I2C_AND_SPI=y
++# CONFIG_SND_SOC_ALL_CODECS is not set
++CONFIG_SND_SOC_SPDIF=y
++CONFIG_SND_SOC_TLV320AIC3X=y
++# CONFIG_SOUND_PRIME is not set
++CONFIG_HID_SUPPORT=y
++CONFIG_HID=y
++# CONFIG_HIDRAW is not set
++
++#
++# USB Input Devices
++#
++CONFIG_USB_HID=y
++# CONFIG_HID_PID is not set
++# CONFIG_USB_HIDDEV is not set
++
++#
++# Special HID drivers
++#
++CONFIG_HID_A4TECH=m
++CONFIG_HID_APPLE=m
++CONFIG_HID_BELKIN=m
++CONFIG_HID_CHERRY=m
++CONFIG_HID_CHICONY=m
++CONFIG_HID_CYPRESS=m
++# CONFIG_HID_DRAGONRISE is not set
++CONFIG_HID_EZKEY=m
++# CONFIG_HID_KYE is not set
++CONFIG_HID_GYRATION=m
++# CONFIG_HID_TWINHAN is not set
++# CONFIG_HID_KENSINGTON is not set
++CONFIG_HID_LOGITECH=m
++# CONFIG_LOGITECH_FF is not set
++# CONFIG_LOGIRUMBLEPAD2_FF is not set
++CONFIG_HID_MICROSOFT=m
++CONFIG_HID_MONTEREY=m
++# CONFIG_HID_NTRIG is not set
++CONFIG_HID_PANTHERLORD=m
++# CONFIG_PANTHERLORD_FF is not set
++CONFIG_HID_PETALYNX=m
++CONFIG_HID_SAMSUNG=m
++CONFIG_HID_SONY=m
++CONFIG_HID_SUNPLUS=m
++# CONFIG_HID_GREENASIA is not set
++# CONFIG_HID_SMARTJOYPLUS is not set
++# CONFIG_HID_TOPSEED is not set
++# CONFIG_HID_THRUSTMASTER is not set
++# CONFIG_HID_ZEROPLUS is not set
++CONFIG_USB_SUPPORT=y
++CONFIG_USB_ARCH_HAS_HCD=y
++# CONFIG_USB_ARCH_HAS_OHCI is not set
++# CONFIG_USB_ARCH_HAS_EHCI is not set
++CONFIG_USB=y
++# CONFIG_USB_DEBUG is not set
++# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
++
++#
++# Miscellaneous USB options
++#
++CONFIG_USB_DEVICEFS=y
++CONFIG_USB_DEVICE_CLASS=y
++# CONFIG_USB_DYNAMIC_MINORS is not set
++# CONFIG_USB_OTG is not set
++# CONFIG_USB_OTG_WHITELIST is not set
++# CONFIG_USB_OTG_BLACKLIST_HUB is not set
++CONFIG_USB_MON=y
++# CONFIG_USB_WUSB is not set
++# CONFIG_USB_WUSB_CBAF is not set
++
++#
++# USB Host Controller Drivers
++#
++# CONFIG_USB_C67X00_HCD is not set
++# CONFIG_USB_OXU210HP_HCD is not set
++# CONFIG_USB_ISP116X_HCD is not set
++# CONFIG_USB_ISP1760_HCD is not set
++# CONFIG_USB_ISP1362_HCD is not set
++# CONFIG_USB_SL811_HCD is not set
++# CONFIG_USB_R8A66597_HCD is not set
++# CONFIG_USB_HWA_HCD is not set
++CONFIG_USB_MUSB_HDRC=y
++CONFIG_USB_MUSB_SOC=y
++
++#
++# DaVinci 35x, 36x, 644x USB support
++#
++# CONFIG_USB_MUSB_HOST is not set
++CONFIG_USB_MUSB_PERIPHERAL=y
++# CONFIG_USB_MUSB_OTG is not set
++CONFIG_USB_GADGET_MUSB_HDRC=y
++CONFIG_MUSB_PIO_ONLY=y
++# CONFIG_USB_MUSB_DEBUG is not set
++
++#
++# USB Device Class drivers
++#
++# CONFIG_USB_ACM is not set
++# CONFIG_USB_PRINTER is not set
++# CONFIG_USB_WDM is not set
++# CONFIG_USB_TMC is not set
++
++#
++# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
++#
++
++#
++# also be needed; see USB_STORAGE Help for more info
++#
++CONFIG_USB_STORAGE=y
++# CONFIG_USB_STORAGE_DEBUG is not set
++# CONFIG_USB_STORAGE_DATAFAB is not set
++# CONFIG_USB_STORAGE_FREECOM is not set
++# CONFIG_USB_STORAGE_ISD200 is not set
++# CONFIG_USB_STORAGE_USBAT is not set
++# CONFIG_USB_STORAGE_SDDR09 is not set
++# CONFIG_USB_STORAGE_SDDR55 is not set
++# CONFIG_USB_STORAGE_JUMPSHOT is not set
++# CONFIG_USB_STORAGE_ALAUDA is not set
++# CONFIG_USB_STORAGE_ONETOUCH is not set
++# CONFIG_USB_STORAGE_KARMA is not set
++# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
++# CONFIG_USB_LIBUSUAL is not set
++
++#
++# USB Imaging devices
++#
++# CONFIG_USB_MDC800 is not set
++# CONFIG_USB_MICROTEK is not set
++
++#
++# USB port drivers
++#
++# CONFIG_USB_SERIAL is not set
++
++#
++# USB Miscellaneous drivers
++#
++# CONFIG_USB_EMI62 is not set
++# CONFIG_USB_EMI26 is not set
++# CONFIG_USB_ADUTUX is not set
++# CONFIG_USB_SEVSEG is not set
++# CONFIG_USB_RIO500 is not set
++# CONFIG_USB_LEGOTOWER is not set
++# CONFIG_USB_LCD is not set
++# CONFIG_USB_BERRY_CHARGE is not set
++# CONFIG_USB_LED is not set
++# CONFIG_USB_CYPRESS_CY7C63 is not set
++# CONFIG_USB_CYTHERM is not set
++# CONFIG_USB_IDMOUSE is not set
++# CONFIG_USB_FTDI_ELAN is not set
++# CONFIG_USB_APPLEDISPLAY is not set
++# CONFIG_USB_SISUSBVGA is not set
++# CONFIG_USB_LD is not set
++# CONFIG_USB_TRANCEVIBRATOR is not set
++# CONFIG_USB_IOWARRIOR is not set
++CONFIG_USB_TEST=y
++# CONFIG_USB_ISIGHTFW is not set
++# CONFIG_USB_VST is not set
++CONFIG_USB_GADGET=y
++# CONFIG_USB_GADGET_DEBUG is not set
++CONFIG_USB_GADGET_DEBUG_FILES=y
++CONFIG_USB_GADGET_DEBUG_FS=y
++CONFIG_USB_GADGET_VBUS_DRAW=2
++CONFIG_USB_GADGET_SELECTED=y
++# CONFIG_USB_GADGET_AT91 is not set
++# CONFIG_USB_GADGET_ATMEL_USBA is not set
++# CONFIG_USB_GADGET_FSL_USB2 is not set
++# CONFIG_USB_GADGET_LH7A40X is not set
++# CONFIG_USB_GADGET_OMAP is not set
++# CONFIG_USB_GADGET_PXA25X is not set
++# CONFIG_USB_GADGET_R8A66597 is not set
++# CONFIG_USB_GADGET_PXA27X is not set
++# CONFIG_USB_GADGET_S3C_HSOTG is not set
++# CONFIG_USB_GADGET_IMX is not set
++# CONFIG_USB_GADGET_S3C2410 is not set
++# CONFIG_USB_GADGET_M66592 is not set
++# CONFIG_USB_GADGET_AMD5536UDC is not set
++# CONFIG_USB_GADGET_FSL_QE is not set
++# CONFIG_USB_GADGET_CI13XXX is not set
++# CONFIG_USB_GADGET_NET2280 is not set
++# CONFIG_USB_GADGET_GOKU is not set
++# CONFIG_USB_GADGET_LANGWELL is not set
++# CONFIG_USB_GADGET_DUMMY_HCD is not set
++CONFIG_USB_GADGET_DUALSPEED=y
++# CONFIG_USB_ZERO is not set
++# CONFIG_USB_AUDIO is not set
++CONFIG_USB_ETH=y
++CONFIG_USB_ETH_RNDIS=y
++# CONFIG_USB_ETH_EEM is not set
++# CONFIG_USB_GADGETFS is not set
++# CONFIG_USB_FILE_STORAGE is not set
++# CONFIG_USB_G_SERIAL is not set
++# CONFIG_USB_MIDI_GADGET is not set
++# CONFIG_USB_G_PRINTER is not set
++# CONFIG_USB_CDC_COMPOSITE is not set
++
++#
++# OTG and related infrastructure
++#
++CONFIG_USB_OTG_UTILS=y
++# CONFIG_USB_GPIO_VBUS is not set
++CONFIG_NOP_USB_XCEIV=y
++CONFIG_MMC=y
++# CONFIG_MMC_DEBUG is not set
++# CONFIG_MMC_UNSAFE_RESUME is not set
++
++#
++# MMC/SD/SDIO Card Drivers
++#
++CONFIG_MMC_BLOCK=y
++# CONFIG_MMC_BLOCK_BOUNCE is not set
++# CONFIG_SDIO_UART is not set
++# CONFIG_MMC_TEST is not set
++
++#
++# MMC/SD/SDIO Host Controller Drivers
++#
++# CONFIG_MMC_SDHCI is not set
++# CONFIG_MMC_AT91 is not set
++# CONFIG_MMC_ATMELMCI is not set
++CONFIG_MMC_DAVINCI=y
++# CONFIG_MMC_SPI is not set
++# CONFIG_MEMSTICK is not set
++CONFIG_NEW_LEDS=y
++CONFIG_LEDS_CLASS=y
++
++#
++# LED drivers
++#
++# CONFIG_LEDS_PCA9532 is not set
++CONFIG_LEDS_GPIO=y
++CONFIG_LEDS_GPIO_PLATFORM=y
++# CONFIG_LEDS_LP3944 is not set
++# CONFIG_LEDS_PCA955X is not set
++# CONFIG_LEDS_DAC124S085 is not set
++# CONFIG_LEDS_BD2802 is not set
++
++#
++# LED Triggers
++#
++CONFIG_LEDS_TRIGGERS=y
++CONFIG_LEDS_TRIGGER_TIMER=y
++# CONFIG_LEDS_TRIGGER_IDE_DISK is not set
++CONFIG_LEDS_TRIGGER_HEARTBEAT=y
++# CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
++# CONFIG_LEDS_TRIGGER_GPIO is not set
++# CONFIG_LEDS_TRIGGER_DEFAULT_ON is not set
++
++#
++# iptables trigger is under Netfilter config (LED target)
++#
++# CONFIG_ACCESSIBILITY is not set
++CONFIG_RTC_LIB=y
++CONFIG_RTC_CLASS=y
++CONFIG_RTC_HCTOSYS=y
++CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
++# CONFIG_RTC_DEBUG is not set
++
++#
++# RTC interfaces
++#
++CONFIG_RTC_INTF_SYSFS=y
++CONFIG_RTC_INTF_PROC=y
++CONFIG_RTC_INTF_DEV=y
++# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
++# CONFIG_RTC_DRV_TEST is not set
++
++#
++# I2C RTC drivers
++#
++# CONFIG_RTC_DRV_DS1307 is not set
++# CONFIG_RTC_DRV_DS1374 is not set
++# CONFIG_RTC_DRV_DS1672 is not set
++# CONFIG_RTC_DRV_MAX6900 is not set
++# CONFIG_RTC_DRV_RS5C372 is not set
++# CONFIG_RTC_DRV_ISL1208 is not set
++# CONFIG_RTC_DRV_X1205 is not set
++# CONFIG_RTC_DRV_PCF8563 is not set
++# CONFIG_RTC_DRV_PCF8583 is not set
++# CONFIG_RTC_DRV_M41T80 is not set
++# CONFIG_RTC_DRV_S35390A is not set
++# CONFIG_RTC_DRV_FM3130 is not set
++# CONFIG_RTC_DRV_RX8581 is not set
++# CONFIG_RTC_DRV_RX8025 is not set
++
++#
++# SPI RTC drivers
++#
++# CONFIG_RTC_DRV_M41T94 is not set
++# CONFIG_RTC_DRV_DS1305 is not set
++# CONFIG_RTC_DRV_DS1390 is not set
++# CONFIG_RTC_DRV_MAX6902 is not set
++# CONFIG_RTC_DRV_R9701 is not set
++# CONFIG_RTC_DRV_RS5C348 is not set
++# CONFIG_RTC_DRV_DS3234 is not set
++# CONFIG_RTC_DRV_PCF2123 is not set
++
++#
++# Platform RTC drivers
++#
++# CONFIG_RTC_DRV_CMOS is not set
++# CONFIG_RTC_DRV_DS1286 is not set
++# CONFIG_RTC_DRV_DS1511 is not set
++# CONFIG_RTC_DRV_DS1553 is not set
++# CONFIG_RTC_DRV_DS1742 is not set
++# CONFIG_RTC_DRV_STK17TA8 is not set
++# CONFIG_RTC_DRV_M48T86 is not set
++# CONFIG_RTC_DRV_M48T35 is not set
++# CONFIG_RTC_DRV_M48T59 is not set
++# CONFIG_RTC_DRV_BQ4802 is not set
++# CONFIG_RTC_DRV_V3020 is not set
++
++#
++# on-CPU RTC drivers
++#
++# CONFIG_DMADEVICES is not set
++# CONFIG_AUXDISPLAY is not set
++# CONFIG_UIO is not set
++
++#
++# TI VLYNQ
++#
++# CONFIG_STAGING is not set
++
++#
++# File systems
++#
++CONFIG_EXT2_FS=y
++# CONFIG_EXT2_FS_XATTR is not set
++# CONFIG_EXT2_FS_XIP is not set
++CONFIG_EXT3_FS=y
++# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
++CONFIG_EXT3_FS_XATTR=y
++# CONFIG_EXT3_FS_POSIX_ACL is not set
++# CONFIG_EXT3_FS_SECURITY is not set
++# CONFIG_EXT4_FS is not set
++CONFIG_JBD=y
++# CONFIG_JBD_DEBUG is not set
++CONFIG_FS_MBCACHE=y
++# CONFIG_REISERFS_FS is not set
++# CONFIG_JFS_FS is not set
++# CONFIG_FS_POSIX_ACL is not set
++CONFIG_XFS_FS=m
++# CONFIG_XFS_QUOTA is not set
++# CONFIG_XFS_POSIX_ACL is not set
++# CONFIG_XFS_RT is not set
++# CONFIG_XFS_DEBUG is not set
++# CONFIG_GFS2_FS is not set
++# CONFIG_OCFS2_FS is not set
++# CONFIG_BTRFS_FS is not set
++# CONFIG_NILFS2_FS is not set
++CONFIG_FILE_LOCKING=y
++CONFIG_FSNOTIFY=y
++CONFIG_DNOTIFY=y
++CONFIG_INOTIFY=y
++CONFIG_INOTIFY_USER=y
++# CONFIG_QUOTA is not set
++# CONFIG_AUTOFS_FS is not set
++CONFIG_AUTOFS4_FS=m
++# CONFIG_FUSE_FS is not set
++
++#
++# Caches
++#
++# CONFIG_FSCACHE is not set
++
++#
++# CD-ROM/DVD Filesystems
++#
++# CONFIG_ISO9660_FS is not set
++# CONFIG_UDF_FS is not set
++
++#
++# DOS/FAT/NT Filesystems
++#
++CONFIG_FAT_FS=y
++CONFIG_MSDOS_FS=y
++CONFIG_VFAT_FS=y
++CONFIG_FAT_DEFAULT_CODEPAGE=437
++CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
++# CONFIG_NTFS_FS is not set
++
++#
++# Pseudo filesystems
++#
++CONFIG_PROC_FS=y
++CONFIG_PROC_SYSCTL=y
++CONFIG_PROC_PAGE_MONITOR=y
++CONFIG_SYSFS=y
++CONFIG_TMPFS=y
++# CONFIG_TMPFS_POSIX_ACL is not set
++# CONFIG_HUGETLB_PAGE is not set
++# CONFIG_CONFIGFS_FS is not set
++CONFIG_MISC_FILESYSTEMS=y
++# CONFIG_ADFS_FS is not set
++# CONFIG_AFFS_FS is not set
++# CONFIG_HFS_FS is not set
++# CONFIG_HFSPLUS_FS is not set
++# CONFIG_BEFS_FS is not set
++# CONFIG_BFS_FS is not set
++# CONFIG_EFS_FS is not set
++CONFIG_JFFS2_FS=y
++CONFIG_JFFS2_FS_DEBUG=0
++CONFIG_JFFS2_FS_WRITEBUFFER=y
++# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
++# CONFIG_JFFS2_SUMMARY is not set
++# CONFIG_JFFS2_FS_XATTR is not set
++# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
++CONFIG_JFFS2_ZLIB=y
++# CONFIG_JFFS2_LZO is not set
++CONFIG_JFFS2_RTIME=y
++# CONFIG_JFFS2_RUBIN is not set
++CONFIG_CRAMFS=y
++# CONFIG_SQUASHFS is not set
++# CONFIG_VXFS_FS is not set
++CONFIG_MINIX_FS=m
++# CONFIG_OMFS_FS is not set
++# CONFIG_HPFS_FS is not set
++# CONFIG_QNX4FS_FS is not set
++# CONFIG_ROMFS_FS is not set
++# CONFIG_SYSV_FS is not set
++# CONFIG_UFS_FS is not set
++CONFIG_NETWORK_FILESYSTEMS=y
++CONFIG_NFS_FS=y
++CONFIG_NFS_V3=y
++# CONFIG_NFS_V3_ACL is not set
++# CONFIG_NFS_V4 is not set
++CONFIG_ROOT_NFS=y
++CONFIG_NFSD=m
++CONFIG_NFSD_V3=y
++# CONFIG_NFSD_V3_ACL is not set
++# CONFIG_NFSD_V4 is not set
++CONFIG_LOCKD=y
++CONFIG_LOCKD_V4=y
++CONFIG_EXPORTFS=m
++CONFIG_NFS_COMMON=y
++CONFIG_SUNRPC=y
++# CONFIG_RPCSEC_GSS_KRB5 is not set
++# CONFIG_RPCSEC_GSS_SPKM3 is not set
++CONFIG_SMB_FS=m
++# CONFIG_SMB_NLS_DEFAULT is not set
++# CONFIG_CIFS is not set
++# CONFIG_NCP_FS is not set
++# CONFIG_CODA_FS is not set
++# CONFIG_AFS_FS is not set
++
++#
++# Partition Types
++#
++CONFIG_PARTITION_ADVANCED=y
++# CONFIG_ACORN_PARTITION is not set
++# CONFIG_OSF_PARTITION is not set
++# CONFIG_AMIGA_PARTITION is not set
++# CONFIG_ATARI_PARTITION is not set
++# CONFIG_MAC_PARTITION is not set
++CONFIG_MSDOS_PARTITION=y
++# CONFIG_BSD_DISKLABEL is not set
++# CONFIG_MINIX_SUBPARTITION is not set
++# CONFIG_SOLARIS_X86_PARTITION is not set
++# CONFIG_UNIXWARE_DISKLABEL is not set
++# CONFIG_LDM_PARTITION is not set
++# CONFIG_SGI_PARTITION is not set
++# CONFIG_ULTRIX_PARTITION is not set
++# CONFIG_SUN_PARTITION is not set
++# CONFIG_KARMA_PARTITION is not set
++# CONFIG_EFI_PARTITION is not set
++# CONFIG_SYSV68_PARTITION is not set
++CONFIG_NLS=y
++CONFIG_NLS_DEFAULT="iso8859-1"
++CONFIG_NLS_CODEPAGE_437=y
++# CONFIG_NLS_CODEPAGE_737 is not set
++# CONFIG_NLS_CODEPAGE_775 is not set
++# CONFIG_NLS_CODEPAGE_850 is not set
++# CONFIG_NLS_CODEPAGE_852 is not set
++# CONFIG_NLS_CODEPAGE_855 is not set
++# CONFIG_NLS_CODEPAGE_857 is not set
++# CONFIG_NLS_CODEPAGE_860 is not set
++# CONFIG_NLS_CODEPAGE_861 is not set
++# CONFIG_NLS_CODEPAGE_862 is not set
++# CONFIG_NLS_CODEPAGE_863 is not set
++# CONFIG_NLS_CODEPAGE_864 is not set
++# CONFIG_NLS_CODEPAGE_865 is not set
++# CONFIG_NLS_CODEPAGE_866 is not set
++# CONFIG_NLS_CODEPAGE_869 is not set
++# CONFIG_NLS_CODEPAGE_936 is not set
++# CONFIG_NLS_CODEPAGE_950 is not set
++# CONFIG_NLS_CODEPAGE_932 is not set
++# CONFIG_NLS_CODEPAGE_949 is not set
++# CONFIG_NLS_CODEPAGE_874 is not set
++# CONFIG_NLS_ISO8859_8 is not set
++# CONFIG_NLS_CODEPAGE_1250 is not set
++# CONFIG_NLS_CODEPAGE_1251 is not set
++CONFIG_NLS_ASCII=m
++CONFIG_NLS_ISO8859_1=y
++# CONFIG_NLS_ISO8859_2 is not set
++# CONFIG_NLS_ISO8859_3 is not set
++# CONFIG_NLS_ISO8859_4 is not set
++# CONFIG_NLS_ISO8859_5 is not set
++# CONFIG_NLS_ISO8859_6 is not set
++# CONFIG_NLS_ISO8859_7 is not set
++# CONFIG_NLS_ISO8859_9 is not set
++# CONFIG_NLS_ISO8859_13 is not set
++# CONFIG_NLS_ISO8859_14 is not set
++# CONFIG_NLS_ISO8859_15 is not set
++# CONFIG_NLS_KOI8_R is not set
++# CONFIG_NLS_KOI8_U is not set
++CONFIG_NLS_UTF8=m
++# CONFIG_DLM is not set
++
++#
++# Kernel hacking
++#
++# CONFIG_PRINTK_TIME is not set
++CONFIG_ENABLE_WARN_DEPRECATED=y
++CONFIG_ENABLE_MUST_CHECK=y
++CONFIG_FRAME_WARN=1024
++# CONFIG_MAGIC_SYSRQ is not set
++# CONFIG_STRIP_ASM_SYMS is not set
++# CONFIG_UNUSED_SYMBOLS is not set
++CONFIG_DEBUG_FS=y
++# CONFIG_HEADERS_CHECK is not set
++CONFIG_DEBUG_KERNEL=y
++# CONFIG_DEBUG_SHIRQ is not set
++CONFIG_DETECT_SOFTLOCKUP=y
++# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
++CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
++CONFIG_DETECT_HUNG_TASK=y
++# CONFIG_BOOTPARAM_HUNG_TASK_PANIC is not set
++CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=0
++CONFIG_SCHED_DEBUG=y
++# CONFIG_SCHEDSTATS is not set
++CONFIG_TIMER_STATS=y
++# CONFIG_DEBUG_OBJECTS is not set
++# CONFIG_SLUB_DEBUG_ON is not set
++# CONFIG_SLUB_STATS is not set
++# CONFIG_DEBUG_KMEMLEAK is not set
++CONFIG_DEBUG_PREEMPT=y
++CONFIG_DEBUG_RT_MUTEXES=y
++CONFIG_DEBUG_PI_LIST=y
++# CONFIG_RT_MUTEX_TESTER is not set
++# CONFIG_DEBUG_SPINLOCK is not set
++CONFIG_DEBUG_MUTEXES=y
++# CONFIG_DEBUG_LOCK_ALLOC is not set
++# CONFIG_PROVE_LOCKING is not set
++# CONFIG_LOCK_STAT is not set
++# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
++# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
++# CONFIG_DEBUG_KOBJECT is not set
++CONFIG_DEBUG_BUGVERBOSE=y
++# CONFIG_DEBUG_INFO is not set
++# CONFIG_DEBUG_VM is not set
++# CONFIG_DEBUG_WRITECOUNT is not set
++# CONFIG_DEBUG_MEMORY_INIT is not set
++# CONFIG_DEBUG_LIST is not set
++# CONFIG_DEBUG_SG is not set
++# CONFIG_DEBUG_NOTIFIERS is not set
++# CONFIG_DEBUG_CREDENTIALS is not set
++CONFIG_FRAME_POINTER=y
++# CONFIG_BOOT_PRINTK_DELAY is not set
++# CONFIG_RCU_TORTURE_TEST is not set
++# CONFIG_RCU_CPU_STALL_DETECTOR is not set
++# CONFIG_BACKTRACE_SELF_TEST is not set
++# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
++# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
++# CONFIG_FAULT_INJECTION is not set
++# CONFIG_LATENCYTOP is not set
++# CONFIG_SYSCTL_SYSCALL_CHECK is not set
++# CONFIG_PAGE_POISONING is not set
++CONFIG_HAVE_FUNCTION_TRACER=y
++CONFIG_TRACING_SUPPORT=y
++CONFIG_FTRACE=y
++# CONFIG_FUNCTION_TRACER is not set
++# CONFIG_IRQSOFF_TRACER is not set
++# CONFIG_PREEMPT_TRACER is not set
++# CONFIG_SCHED_TRACER is not set
++# CONFIG_ENABLE_DEFAULT_TRACERS is not set
++# CONFIG_BOOT_TRACER is not set
++CONFIG_BRANCH_PROFILE_NONE=y
++# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
++# CONFIG_PROFILE_ALL_BRANCHES is not set
++# CONFIG_STACK_TRACER is not set
++# CONFIG_KMEMTRACE is not set
++# CONFIG_WORKQUEUE_TRACER is not set
++# CONFIG_BLK_DEV_IO_TRACE is not set
++# CONFIG_DYNAMIC_DEBUG is not set
++# CONFIG_SAMPLES is not set
++CONFIG_HAVE_ARCH_KGDB=y
++# CONFIG_KGDB is not set
++# CONFIG_ARM_UNWIND is not set
++CONFIG_DEBUG_USER=y
++CONFIG_DEBUG_ERRORS=y
++# CONFIG_DEBUG_STACK_USAGE is not set
++# CONFIG_DEBUG_LL is not set
++
++#
++# Security options
++#
++# CONFIG_KEYS is not set
++# CONFIG_SECURITY is not set
++# CONFIG_SECURITYFS is not set
++# CONFIG_SECURITY_FILE_CAPABILITIES is not set
++CONFIG_CRYPTO=y
++
++#
++# Crypto core or helper
++#
++# CONFIG_CRYPTO_MANAGER is not set
++# CONFIG_CRYPTO_MANAGER2 is not set
++# CONFIG_CRYPTO_GF128MUL is not set
++# CONFIG_CRYPTO_NULL is not set
++# CONFIG_CRYPTO_CRYPTD is not set
++# CONFIG_CRYPTO_AUTHENC is not set
++# CONFIG_CRYPTO_TEST is not set
++
++#
++# Authenticated Encryption with Associated Data
++#
++# CONFIG_CRYPTO_CCM is not set
++# CONFIG_CRYPTO_GCM is not set
++# CONFIG_CRYPTO_SEQIV is not set
++
++#
++# Block modes
++#
++# CONFIG_CRYPTO_CBC is not set
++# CONFIG_CRYPTO_CTR is not set
++# CONFIG_CRYPTO_CTS is not set
++# CONFIG_CRYPTO_ECB is not set
++# CONFIG_CRYPTO_LRW is not set
++# CONFIG_CRYPTO_PCBC is not set
++# CONFIG_CRYPTO_XTS is not set
++
++#
++# Hash modes
++#
++# CONFIG_CRYPTO_HMAC is not set
++# CONFIG_CRYPTO_XCBC is not set
++# CONFIG_CRYPTO_VMAC is not set
++
++#
++# Digest
++#
++# CONFIG_CRYPTO_CRC32C is not set
++# CONFIG_CRYPTO_GHASH is not set
++# CONFIG_CRYPTO_MD4 is not set
++# CONFIG_CRYPTO_MD5 is not set
++# CONFIG_CRYPTO_MICHAEL_MIC is not set
++# CONFIG_CRYPTO_RMD128 is not set
++# CONFIG_CRYPTO_RMD160 is not set
++# CONFIG_CRYPTO_RMD256 is not set
++# CONFIG_CRYPTO_RMD320 is not set
++# CONFIG_CRYPTO_SHA1 is not set
++# CONFIG_CRYPTO_SHA256 is not set
++# CONFIG_CRYPTO_SHA512 is not set
++# CONFIG_CRYPTO_TGR192 is not set
++# CONFIG_CRYPTO_WP512 is not set
++
++#
++# Ciphers
++#
++# CONFIG_CRYPTO_AES is not set
++# CONFIG_CRYPTO_ANUBIS is not set
++# CONFIG_CRYPTO_ARC4 is not set
++# CONFIG_CRYPTO_BLOWFISH is not set
++# CONFIG_CRYPTO_CAMELLIA is not set
++# CONFIG_CRYPTO_CAST5 is not set
++# CONFIG_CRYPTO_CAST6 is not set
++# CONFIG_CRYPTO_DES is not set
++# CONFIG_CRYPTO_FCRYPT is not set
++# CONFIG_CRYPTO_KHAZAD is not set
++# CONFIG_CRYPTO_SALSA20 is not set
++# CONFIG_CRYPTO_SEED is not set
++# CONFIG_CRYPTO_SERPENT is not set
++# CONFIG_CRYPTO_TEA is not set
++# CONFIG_CRYPTO_TWOFISH is not set
++
++#
++# Compression
++#
++# CONFIG_CRYPTO_DEFLATE is not set
++# CONFIG_CRYPTO_ZLIB is not set
++# CONFIG_CRYPTO_LZO is not set
++
++#
++# Random Number Generation
++#
++# CONFIG_CRYPTO_ANSI_CPRNG is not set
++# CONFIG_CRYPTO_HW is not set
++# CONFIG_BINARY_PRINTF is not set
++
++#
++# Library routines
++#
++CONFIG_BITREVERSE=y
++CONFIG_GENERIC_FIND_LAST_BIT=y
++CONFIG_CRC_CCITT=y
++# CONFIG_CRC16 is not set
++CONFIG_CRC_T10DIF=m
++# CONFIG_CRC_ITU_T is not set
++CONFIG_CRC32=y
++# CONFIG_CRC7 is not set
++# CONFIG_LIBCRC32C is not set
++CONFIG_ZLIB_INFLATE=y
++CONFIG_ZLIB_DEFLATE=y
++CONFIG_DECOMPRESS_GZIP=y
++CONFIG_GENERIC_ALLOCATOR=y
++CONFIG_HAS_IOMEM=y
++CONFIG_HAS_IOPORT=y
++CONFIG_HAS_DMA=y
++CONFIG_NLATTR=y
+--- /dev/null
++++ b/drivers/input/keyboard/davinci_keyscan.c
+@@ -0,0 +1,345 @@
++/*
++ * DaVinci Key Scan Driver for TI platforms
++ *
++ * Copyright (C) 2009 Texas Instruments, Inc
++ *
++ * Author: Miguel Aguilar <miguel.aguilar@ridgerun.com>
++ *
++ * Intial Code: Sandeep Paulraj <s-paulraj@ti.com>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
++ */
++#include <linux/module.h>
++#include <linux/init.h>
++#include <linux/interrupt.h>
++#include <linux/types.h>
++#include <linux/input.h>
++#include <linux/kernel.h>
++#include <linux/delay.h>
++#include <linux/platform_device.h>
++#include <linux/errno.h>
++
++#include <asm/irq.h>
++
++#include <mach/hardware.h>
++#include <mach/irqs.h>
++#include <mach/keyscan.h>
++
++/* Key scan registers */
++#define DAVINCI_KEYSCAN_KEYCTRL		0x0000
++#define DAVINCI_KEYSCAN_INTENA		0x0004
++#define DAVINCI_KEYSCAN_INTFLAG		0x0008
++#define DAVINCI_KEYSCAN_INTCLR		0x000c
++#define DAVINCI_KEYSCAN_STRBWIDTH	0x0010
++#define DAVINCI_KEYSCAN_INTERVAL	0x0014
++#define DAVINCI_KEYSCAN_CONTTIME	0x0018
++#define DAVINCI_KEYSCAN_CURRENTST	0x001c
++#define DAVINCI_KEYSCAN_PREVSTATE	0x0020
++#define DAVINCI_KEYSCAN_EMUCTRL		0x0024
++#define DAVINCI_KEYSCAN_IODFTCTRL	0x002c
++
++/* Key Control Register (KEYCTRL) */
++#define DAVINCI_KEYSCAN_KEYEN		0x00000001
++#define DAVINCI_KEYSCAN_PREVMODE	0x00000002
++#define DAVINCI_KEYSCAN_CHATOFF		0x00000004
++#define DAVINCI_KEYSCAN_AUTODET		0x00000008
++#define DAVINCI_KEYSCAN_SCANMODE	0x00000010
++#define DAVINCI_KEYSCAN_OUTTYPE		0x00000020
++
++/* Masks for the interrupts */
++#define DAVINCI_KEYSCAN_INT_CONT	0x00000008
++#define DAVINCI_KEYSCAN_INT_OFF		0x00000004
++#define DAVINCI_KEYSCAN_INT_ON		0x00000002
++#define DAVINCI_KEYSCAN_INT_CHANGE	0x00000001
++#define DAVINCI_KEYSCAN_INT_ALL		0x0000000f
++
++struct davinci_ks {
++	struct input_dev		*input;
++	struct davinci_ks_platform_data	*pdata;
++	int				irq;
++	void __iomem			*base;
++	resource_size_t			pbase;
++	size_t				base_size;
++	unsigned short			keymap[];
++};
++
++/* Initializing the kp Module */
++static int __init davinci_ks_initialize(struct davinci_ks *davinci_ks)
++{
++	struct device *dev = &davinci_ks->input->dev;
++	struct davinci_ks_platform_data *pdata = davinci_ks->pdata;
++	u32 matrix_ctrl;
++
++	/* Enable all interrupts */
++	__raw_writel(DAVINCI_KEYSCAN_INT_ALL,
++		     davinci_ks->base + DAVINCI_KEYSCAN_INTENA);
++
++	/* Clear interrupts if any */
++	__raw_writel(DAVINCI_KEYSCAN_INT_ALL,
++		     davinci_ks->base + DAVINCI_KEYSCAN_INTCLR);
++
++	/* Setup the scan period = strobe + interval */
++	__raw_writel(pdata->strobe,
++		     davinci_ks->base + DAVINCI_KEYSCAN_STRBWIDTH);
++	__raw_writel(pdata->interval,
++		     davinci_ks->base + DAVINCI_KEYSCAN_INTERVAL);
++	__raw_writel(0x01,
++		     davinci_ks->base + DAVINCI_KEYSCAN_CONTTIME);
++
++	/* Define matrix type */
++	switch (pdata->matrix_type) {
++	case DAVINCI_KEYSCAN_MATRIX_4X4:
++		matrix_ctrl = 0;
++		break;
++	case DAVINCI_KEYSCAN_MATRIX_5X3:
++		matrix_ctrl = (1 << 6);
++		break;
++	default:
++		dev_err(dev->parent, "wrong matrix type\n");
++		return -EINVAL;
++	}
++
++	/* Enable key scan module and set matrix type */
++	__raw_writel(DAVINCI_KEYSCAN_AUTODET | DAVINCI_KEYSCAN_KEYEN |
++		     matrix_ctrl, davinci_ks->base + DAVINCI_KEYSCAN_KEYCTRL);
++
++	return 0;
++}
++
++static irqreturn_t davinci_ks_interrupt(int irq, void *dev_id)
++{
++	struct davinci_ks *davinci_ks = dev_id;
++	struct device *dev = &davinci_ks->input->dev;
++	unsigned short *keymap = davinci_ks->keymap;
++	int keymapsize = davinci_ks->pdata->keymapsize;
++	u32 prev_status, new_status, changed;
++	bool release;
++	int keycode = KEY_UNKNOWN;
++	int i;
++
++	/* Disable interrupt */
++	__raw_writel(0x0, davinci_ks->base + DAVINCI_KEYSCAN_INTENA);
++
++	/* Reading previous and new status of the key scan */
++	prev_status = __raw_readl(davinci_ks->base + DAVINCI_KEYSCAN_PREVSTATE);
++	new_status = __raw_readl(davinci_ks->base + DAVINCI_KEYSCAN_CURRENTST);
++
++	changed = prev_status ^ new_status;
++
++	if (changed) {
++		/*
++		 * It goes through all bits in 'changed' to ensure
++		 * that no key changes are being missed
++		 */
++		for (i = 0 ; i < keymapsize; i++) {
++			if ((changed>>i) & 0x1) {
++				keycode = keymap[i];
++				release = (new_status >> i) & 0x1;
++				dev_dbg(dev->parent, "key %d %s\n", keycode,
++					release ? "released" : "pressed");
++				input_report_key(davinci_ks->input, keycode,
++						 !release);
++				input_sync(davinci_ks->input);
++			}
++		}
++		/* Clearing interrupt */
++		__raw_writel(DAVINCI_KEYSCAN_INT_ALL,
++			     davinci_ks->base + DAVINCI_KEYSCAN_INTCLR);
++	}
++
++	/* Enable interrupts */
++	__raw_writel(0x1, davinci_ks->base + DAVINCI_KEYSCAN_INTENA);
++
++	return IRQ_HANDLED;
++}
++
++static int __init davinci_ks_probe(struct platform_device *pdev)
++{
++	struct davinci_ks *davinci_ks;
++	struct input_dev *key_dev;
++	struct resource *res, *mem;
++	struct device *dev = &pdev->dev;
++	struct davinci_ks_platform_data *pdata = pdev->dev.platform_data;
++	int error, i;
++
++	if (pdata->device_enable) {
++		error = pdata->device_enable(dev);
++		if (error < 0) {
++			dev_dbg(dev, "device enable function failed\n");
++			return error;
++		}
++	}
++
++	if (!pdata->keymap) {
++		dev_dbg(dev, "no keymap from pdata\n");
++		return -EINVAL;
++	}
++
++	davinci_ks = kzalloc(sizeof(struct davinci_ks) +
++		sizeof(unsigned short) * pdata->keymapsize, GFP_KERNEL);
++	if (!davinci_ks) {
++		dev_dbg(dev, "could not allocate memory for private data\n");
++		return -ENOMEM;
++	}
++
++	memcpy(davinci_ks->keymap, pdata->keymap,
++		sizeof(unsigned short) * pdata->keymapsize);
++
++	key_dev = input_allocate_device();
++	if (!key_dev) {
++		dev_dbg(dev, "could not allocate input device\n");
++		error = -ENOMEM;
++		goto fail1;
++	}
++
++	davinci_ks->input = key_dev;
++
++	davinci_ks->irq = platform_get_irq(pdev, 0);
++	if (davinci_ks->irq < 0) {
++		dev_err(dev, "no key scan irq\n");
++		error = davinci_ks->irq;
++		goto fail2;
++	}
++
++	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
++	if (!res) {
++		dev_err(dev, "no mem resource\n");
++		error = -EINVAL;
++		goto fail2;
++	}
++
++	davinci_ks->pbase = res->start;
++	davinci_ks->base_size = resource_size(res);
++
++	mem = request_mem_region(davinci_ks->pbase, davinci_ks->base_size,
++				 pdev->name);
++	if (!mem) {
++		dev_err(dev, "key scan registers at %08x are not free\n",
++			davinci_ks->pbase);
++		error = -EBUSY;
++		goto fail2;
++	}
++
++	davinci_ks->base = ioremap(davinci_ks->pbase, davinci_ks->base_size);
++	if (!davinci_ks->base) {
++		dev_err(dev, "can't ioremap MEM resource.\n");
++		error = -ENOMEM;
++		goto fail3;
++	}
++
++	/* Enable auto repeat feature of Linux input subsystem */
++	if (pdata->rep)
++		__set_bit(EV_REP, key_dev->evbit);
++
++	/* Setup input device */
++	__set_bit(EV_KEY, key_dev->evbit);
++
++	/* Setup the platform data */
++	davinci_ks->pdata = pdata;
++
++	for (i = 0; i < davinci_ks->pdata->keymapsize; i++)
++		__set_bit(davinci_ks->pdata->keymap[i], key_dev->keybit);
++
++	key_dev->name = "davinci_keyscan";
++	key_dev->phys = "davinci_keyscan/input0";
++	key_dev->dev.parent = &pdev->dev;
++	key_dev->id.bustype = BUS_HOST;
++	key_dev->id.vendor = 0x0001;
++	key_dev->id.product = 0x0001;
++	key_dev->id.version = 0x0001;
++	key_dev->keycode = davinci_ks->keymap;
++	key_dev->keycodesize = sizeof(davinci_ks->keymap[0]);
++	key_dev->keycodemax = davinci_ks->pdata->keymapsize;
++
++	error = input_register_device(davinci_ks->input);
++	if (error < 0) {
++		dev_err(dev, "unable to register davinci key scan device\n");
++		goto fail4;
++	}
++
++	error = request_irq(davinci_ks->irq, davinci_ks_interrupt,
++			  IRQF_DISABLED, pdev->name, davinci_ks);
++	if (error < 0) {
++		dev_err(dev, "unable to register davinci key scan interrupt\n");
++		goto fail5;
++	}
++
++	error = davinci_ks_initialize(davinci_ks);
++	if (error < 0) {
++		dev_err(dev, "unable to initialize davinci key scan device\n");
++		goto fail6;
++	}
++
++	platform_set_drvdata(pdev, davinci_ks);
++	return 0;
++
++fail6:
++	free_irq(davinci_ks->irq, davinci_ks);
++fail5:
++	input_unregister_device(davinci_ks->input);
++	key_dev = NULL;
++fail4:
++	iounmap(davinci_ks->base);
++fail3:
++	release_mem_region(davinci_ks->pbase, davinci_ks->base_size);
++fail2:
++	input_free_device(key_dev);
++fail1:
++	kfree(davinci_ks);
++
++	return error;
++}
++
++static int __devexit davinci_ks_remove(struct platform_device *pdev)
++{
++	struct davinci_ks *davinci_ks = platform_get_drvdata(pdev);
++
++	free_irq(davinci_ks->irq, davinci_ks);
++
++	input_unregister_device(davinci_ks->input);
++
++	iounmap(davinci_ks->base);
++	release_mem_region(davinci_ks->pbase, davinci_ks->base_size);
++
++	platform_set_drvdata(pdev, NULL);
++
++	kfree(davinci_ks);
++
++	return 0;
++}
++
++static struct platform_driver davinci_ks_driver = {
++	.driver	= {
++		.name = "davinci_keyscan",
++		.owner = THIS_MODULE,
++	},
++	.remove	= __devexit_p(davinci_ks_remove),
++};
++
++static int __init davinci_ks_init(void)
++{
++	return platform_driver_probe(&davinci_ks_driver, davinci_ks_probe);
++}
++module_init(davinci_ks_init);
++
++static void __exit davinci_ks_exit(void)
++{
++	platform_driver_unregister(&davinci_ks_driver);
++}
++module_exit(davinci_ks_exit);
++
++MODULE_AUTHOR("Miguel Aguilar");
++MODULE_DESCRIPTION("Texas Instruments DaVinci Key Scan Driver");
++MODULE_LICENSE("GPL");
+--- /dev/null
++++ b/arch/arm/configs/davinci_dm365_defconfig
+@@ -0,0 +1,1855 @@
++#
++# Automatically generated make config: don't edit
++# Linux kernel version: 2.6.32-rc2-davinci1
++# Mon Nov  2 10:40:20 2009
++#
++CONFIG_ARM=y
++CONFIG_SYS_SUPPORTS_APM_EMULATION=y
++CONFIG_GENERIC_GPIO=y
++CONFIG_GENERIC_TIME=y
++CONFIG_GENERIC_CLOCKEVENTS=y
++CONFIG_GENERIC_HARDIRQS=y
++CONFIG_STACKTRACE_SUPPORT=y
++CONFIG_HAVE_LATENCYTOP_SUPPORT=y
++CONFIG_LOCKDEP_SUPPORT=y
++CONFIG_TRACE_IRQFLAGS_SUPPORT=y
++CONFIG_HARDIRQS_SW_RESEND=y
++CONFIG_GENERIC_IRQ_PROBE=y
++CONFIG_RWSEM_GENERIC_SPINLOCK=y
++CONFIG_GENERIC_HWEIGHT=y
++CONFIG_GENERIC_CALIBRATE_DELAY=y
++CONFIG_ZONE_DMA=y
++CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
++CONFIG_VECTORS_BASE=0xffff0000
++CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
++CONFIG_CONSTRUCTORS=y
++
++#
++# General setup
++#
++CONFIG_EXPERIMENTAL=y
++CONFIG_BROKEN_ON_SMP=y
++CONFIG_LOCK_KERNEL=y
++CONFIG_INIT_ENV_ARG_LIMIT=32
++CONFIG_LOCALVERSION=""
++CONFIG_LOCALVERSION_AUTO=y
++# CONFIG_SWAP is not set
++CONFIG_SYSVIPC=y
++CONFIG_SYSVIPC_SYSCTL=y
++CONFIG_POSIX_MQUEUE=y
++CONFIG_POSIX_MQUEUE_SYSCTL=y
++# CONFIG_BSD_PROCESS_ACCT is not set
++# CONFIG_TASKSTATS is not set
++# CONFIG_AUDIT is not set
++
++#
++# RCU Subsystem
++#
++CONFIG_TREE_RCU=y
++# CONFIG_TREE_PREEMPT_RCU is not set
++# CONFIG_RCU_TRACE is not set
++CONFIG_RCU_FANOUT=32
++# CONFIG_RCU_FANOUT_EXACT is not set
++# CONFIG_TREE_RCU_TRACE is not set
++CONFIG_IKCONFIG=y
++CONFIG_IKCONFIG_PROC=y
++CONFIG_LOG_BUF_SHIFT=14
++CONFIG_GROUP_SCHED=y
++CONFIG_FAIR_GROUP_SCHED=y
++# CONFIG_RT_GROUP_SCHED is not set
++CONFIG_USER_SCHED=y
++# CONFIG_CGROUP_SCHED is not set
++# CONFIG_CGROUPS is not set
++# CONFIG_SYSFS_DEPRECATED_V2 is not set
++# CONFIG_RELAY is not set
++# CONFIG_NAMESPACES is not set
++CONFIG_BLK_DEV_INITRD=y
++CONFIG_INITRAMFS_SOURCE=""
++CONFIG_RD_GZIP=y
++# CONFIG_RD_BZIP2 is not set
++# CONFIG_RD_LZMA is not set
++CONFIG_CC_OPTIMIZE_FOR_SIZE=y
++CONFIG_SYSCTL=y
++CONFIG_ANON_INODES=y
++CONFIG_EMBEDDED=y
++CONFIG_UID16=y
++CONFIG_SYSCTL_SYSCALL=y
++CONFIG_KALLSYMS=y
++# CONFIG_KALLSYMS_ALL is not set
++# CONFIG_KALLSYMS_EXTRA_PASS is not set
++CONFIG_HOTPLUG=y
++CONFIG_PRINTK=y
++CONFIG_BUG=y
++CONFIG_ELF_CORE=y
++CONFIG_BASE_FULL=y
++CONFIG_FUTEX=y
++CONFIG_EPOLL=y
++CONFIG_SIGNALFD=y
++CONFIG_TIMERFD=y
++CONFIG_EVENTFD=y
++CONFIG_SHMEM=y
++CONFIG_AIO=y
++
++#
++# Kernel Performance Events And Counters
++#
++CONFIG_VM_EVENT_COUNTERS=y
++CONFIG_SLUB_DEBUG=y
++CONFIG_COMPAT_BRK=y
++# CONFIG_SLAB is not set
++CONFIG_SLUB=y
++# CONFIG_SLOB is not set
++# CONFIG_PROFILING is not set
++CONFIG_HAVE_OPROFILE=y
++# CONFIG_KPROBES is not set
++CONFIG_HAVE_KPROBES=y
++CONFIG_HAVE_KRETPROBES=y
++CONFIG_HAVE_CLK=y
++
++#
++# GCOV-based kernel profiling
++#
++# CONFIG_GCOV_KERNEL is not set
++# CONFIG_SLOW_WORK is not set
++CONFIG_HAVE_GENERIC_DMA_COHERENT=y
++CONFIG_SLABINFO=y
++CONFIG_RT_MUTEXES=y
++CONFIG_BASE_SMALL=0
++CONFIG_MODULES=y
++# CONFIG_MODULE_FORCE_LOAD is not set
++CONFIG_MODULE_UNLOAD=y
++CONFIG_MODULE_FORCE_UNLOAD=y
++CONFIG_MODVERSIONS=y
++# CONFIG_MODULE_SRCVERSION_ALL is not set
++CONFIG_BLOCK=y
++CONFIG_LBDAF=y
++# CONFIG_BLK_DEV_BSG is not set
++# CONFIG_BLK_DEV_INTEGRITY is not set
++
++#
++# IO Schedulers
++#
++CONFIG_IOSCHED_NOOP=y
++CONFIG_IOSCHED_AS=y
++# CONFIG_IOSCHED_DEADLINE is not set
++# CONFIG_IOSCHED_CFQ is not set
++CONFIG_DEFAULT_AS=y
++# CONFIG_DEFAULT_DEADLINE is not set
++# CONFIG_DEFAULT_CFQ is not set
++# CONFIG_DEFAULT_NOOP is not set
++CONFIG_DEFAULT_IOSCHED="anticipatory"
++# CONFIG_FREEZER is not set
++
++#
++# System Type
++#
++CONFIG_MMU=y
++# CONFIG_ARCH_AAEC2000 is not set
++# CONFIG_ARCH_INTEGRATOR is not set
++# CONFIG_ARCH_REALVIEW is not set
++# CONFIG_ARCH_VERSATILE is not set
++# CONFIG_ARCH_AT91 is not set
++# CONFIG_ARCH_CLPS711X is not set
++# CONFIG_ARCH_GEMINI is not set
++# CONFIG_ARCH_EBSA110 is not set
++# CONFIG_ARCH_EP93XX is not set
++# CONFIG_ARCH_FOOTBRIDGE is not set
++# CONFIG_ARCH_MXC is not set
++# CONFIG_ARCH_STMP3XXX is not set
++# CONFIG_ARCH_NETX is not set
++# CONFIG_ARCH_H720X is not set
++# CONFIG_ARCH_NOMADIK is not set
++# CONFIG_ARCH_IOP13XX is not set
++# CONFIG_ARCH_IOP32X is not set
++# CONFIG_ARCH_IOP33X is not set
++# CONFIG_ARCH_IXP23XX is not set
++# CONFIG_ARCH_IXP2000 is not set
++# CONFIG_ARCH_IXP4XX is not set
++# CONFIG_ARCH_L7200 is not set
++# CONFIG_ARCH_KIRKWOOD is not set
++# CONFIG_ARCH_LOKI is not set
++# CONFIG_ARCH_MV78XX0 is not set
++# CONFIG_ARCH_ORION5X is not set
++# CONFIG_ARCH_MMP is not set
++# CONFIG_ARCH_KS8695 is not set
++# CONFIG_ARCH_NS9XXX is not set
++# CONFIG_ARCH_W90X900 is not set
++# CONFIG_ARCH_PNX4008 is not set
++# CONFIG_ARCH_PXA is not set
++# CONFIG_ARCH_MSM is not set
++# CONFIG_ARCH_RPC is not set
++# CONFIG_ARCH_SA1100 is not set
++# CONFIG_ARCH_S3C2410 is not set
++# CONFIG_ARCH_S3C64XX is not set
++# CONFIG_ARCH_S5PC1XX is not set
++# CONFIG_ARCH_SHARK is not set
++# CONFIG_ARCH_LH7A40X is not set
++# CONFIG_ARCH_U300 is not set
++CONFIG_ARCH_DAVINCI=y
++# CONFIG_ARCH_OMAP is not set
++# CONFIG_ARCH_BCMRING is not set
++CONFIG_AINTC=y
++CONFIG_ARCH_DAVINCI_DMx=y
++
++#
++# TI DaVinci Implementations
++#
++
++#
++# DaVinci Core Type
++#
++# CONFIG_ARCH_DAVINCI_DM644x is not set
++# CONFIG_ARCH_DAVINCI_DM355 is not set
++# CONFIG_ARCH_DAVINCI_DM646x is not set
++# CONFIG_ARCH_DAVINCI_DA830 is not set
++# CONFIG_ARCH_DAVINCI_DA850 is not set
++CONFIG_ARCH_DAVINCI_DM365=y
++
++#
++# DaVinci Board Type
++#
++CONFIG_MACH_DAVINCI_DM365_EVM=y
++CONFIG_DAVINCI_MUX=y
++# CONFIG_DAVINCI_MUX_DEBUG is not set
++# CONFIG_DAVINCI_MUX_WARNINGS is not set
++CONFIG_DAVINCI_RESET_CLOCKS=y
++CONFIG_OSC_CLK_FREQ=27000000
++
++#
++# Processor Type
++#
++CONFIG_CPU_32=y
++CONFIG_CPU_ARM926T=y
++CONFIG_CPU_32v5=y
++CONFIG_CPU_ABRT_EV5TJ=y
++CONFIG_CPU_PABRT_NOIFAR=y
++CONFIG_CPU_CACHE_VIVT=y
++CONFIG_CPU_COPY_V4WB=y
++CONFIG_CPU_TLB_V4WBI=y
++CONFIG_CPU_CP15=y
++CONFIG_CPU_CP15_MMU=y
++
++#
++# Processor Features
++#
++CONFIG_ARM_THUMB=y
++# CONFIG_CPU_ICACHE_DISABLE is not set
++# CONFIG_CPU_DCACHE_DISABLE is not set
++# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
++# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
++CONFIG_ARM_L1_CACHE_SHIFT=5
++CONFIG_COMMON_CLKDEV=y
++CONFIG_FORCE_MAX_ZONEORDER=13
++
++#
++# Bus support
++#
++# CONFIG_PCI_SYSCALL is not set
++# CONFIG_ARCH_SUPPORTS_MSI is not set
++# CONFIG_PCCARD is not set
++
++#
++# Kernel Features
++#
++CONFIG_TICK_ONESHOT=y
++CONFIG_NO_HZ=y
++CONFIG_HIGH_RES_TIMERS=y
++CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
++CONFIG_VMSPLIT_3G=y
++# CONFIG_VMSPLIT_2G is not set
++# CONFIG_VMSPLIT_1G is not set
++CONFIG_PAGE_OFFSET=0xC0000000
++# CONFIG_PREEMPT_NONE is not set
++# CONFIG_PREEMPT_VOLUNTARY is not set
++CONFIG_PREEMPT=y
++CONFIG_HZ=100
++CONFIG_AEABI=y
++# CONFIG_OABI_COMPAT is not set
++# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
++# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
++# CONFIG_HIGHMEM is not set
++CONFIG_SELECT_MEMORY_MODEL=y
++CONFIG_FLATMEM_MANUAL=y
++# CONFIG_DISCONTIGMEM_MANUAL is not set
++# CONFIG_SPARSEMEM_MANUAL is not set
++CONFIG_FLATMEM=y
++CONFIG_FLAT_NODE_MEM_MAP=y
++CONFIG_PAGEFLAGS_EXTENDED=y
++CONFIG_SPLIT_PTLOCK_CPUS=4096
++# CONFIG_PHYS_ADDR_T_64BIT is not set
++CONFIG_ZONE_DMA_FLAG=1
++CONFIG_BOUNCE=y
++CONFIG_VIRT_TO_BUS=y
++CONFIG_HAVE_MLOCK=y
++CONFIG_HAVE_MLOCKED_PAGE_BIT=y
++# CONFIG_KSM is not set
++CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
++CONFIG_LEDS=y
++# CONFIG_LEDS_CPU is not set
++CONFIG_ALIGNMENT_TRAP=y
++# CONFIG_UACCESS_WITH_MEMCPY is not set
++
++#
++# Boot options
++#
++CONFIG_ZBOOT_ROM_TEXT=0x0
++CONFIG_ZBOOT_ROM_BSS=0x0
++CONFIG_CMDLINE=""
++# CONFIG_XIP_KERNEL is not set
++# CONFIG_KEXEC is not set
++
++#
++# CPU Power Management
++#
++# CONFIG_CPU_IDLE is not set
++
++#
++# Floating point emulation
++#
++
++#
++# At least one emulation must be selected
++#
++# CONFIG_VFP is not set
++
++#
++# Userspace binary formats
++#
++CONFIG_BINFMT_ELF=y
++# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
++CONFIG_HAVE_AOUT=y
++# CONFIG_BINFMT_AOUT is not set
++# CONFIG_BINFMT_MISC is not set
++
++#
++# Power management options
++#
++# CONFIG_PM is not set
++CONFIG_ARCH_SUSPEND_POSSIBLE=y
++CONFIG_NET=y
++
++#
++# Networking options
++#
++CONFIG_PACKET=y
++# CONFIG_PACKET_MMAP is not set
++CONFIG_UNIX=y
++CONFIG_XFRM=y
++# CONFIG_XFRM_USER is not set
++# CONFIG_XFRM_SUB_POLICY is not set
++# CONFIG_XFRM_MIGRATE is not set
++# CONFIG_XFRM_STATISTICS is not set
++# CONFIG_NET_KEY is not set
++CONFIG_INET=y
++# CONFIG_IP_MULTICAST is not set
++# CONFIG_IP_ADVANCED_ROUTER is not set
++CONFIG_IP_FIB_HASH=y
++CONFIG_IP_PNP=y
++CONFIG_IP_PNP_DHCP=y
++# CONFIG_IP_PNP_BOOTP is not set
++# CONFIG_IP_PNP_RARP is not set
++# CONFIG_NET_IPIP is not set
++# CONFIG_NET_IPGRE is not set
++# CONFIG_ARPD is not set
++# CONFIG_SYN_COOKIES is not set
++# CONFIG_INET_AH is not set
++# CONFIG_INET_ESP is not set
++# CONFIG_INET_IPCOMP is not set
++# CONFIG_INET_XFRM_TUNNEL is not set
++CONFIG_INET_TUNNEL=m
++CONFIG_INET_XFRM_MODE_TRANSPORT=y
++CONFIG_INET_XFRM_MODE_TUNNEL=y
++CONFIG_INET_XFRM_MODE_BEET=y
++# CONFIG_INET_LRO is not set
++CONFIG_INET_DIAG=y
++CONFIG_INET_TCP_DIAG=y
++# CONFIG_TCP_CONG_ADVANCED is not set
++CONFIG_TCP_CONG_CUBIC=y
++CONFIG_DEFAULT_TCP_CONG="cubic"
++# CONFIG_TCP_MD5SIG is not set
++CONFIG_IPV6=m
++# CONFIG_IPV6_PRIVACY is not set
++# CONFIG_IPV6_ROUTER_PREF is not set
++# CONFIG_IPV6_OPTIMISTIC_DAD is not set
++# CONFIG_INET6_AH is not set
++# CONFIG_INET6_ESP is not set
++# CONFIG_INET6_IPCOMP is not set
++# CONFIG_IPV6_MIP6 is not set
++# CONFIG_INET6_XFRM_TUNNEL is not set
++# CONFIG_INET6_TUNNEL is not set
++CONFIG_INET6_XFRM_MODE_TRANSPORT=m
++CONFIG_INET6_XFRM_MODE_TUNNEL=m
++CONFIG_INET6_XFRM_MODE_BEET=m
++# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
++CONFIG_IPV6_SIT=m
++CONFIG_IPV6_NDISC_NODETYPE=y
++# CONFIG_IPV6_TUNNEL is not set
++# CONFIG_IPV6_MULTIPLE_TABLES is not set
++# CONFIG_IPV6_MROUTE is not set
++# CONFIG_NETWORK_SECMARK is not set
++CONFIG_NETFILTER=y
++# CONFIG_NETFILTER_DEBUG is not set
++CONFIG_NETFILTER_ADVANCED=y
++
++#
++# Core Netfilter Configuration
++#
++# CONFIG_NETFILTER_NETLINK_QUEUE is not set
++# CONFIG_NETFILTER_NETLINK_LOG is not set
++# CONFIG_NF_CONNTRACK is not set
++# CONFIG_NETFILTER_XTABLES is not set
++# CONFIG_IP_VS is not set
++
++#
++# IP: Netfilter Configuration
++#
++# CONFIG_NF_DEFRAG_IPV4 is not set
++# CONFIG_IP_NF_QUEUE is not set
++# CONFIG_IP_NF_IPTABLES is not set
++# CONFIG_IP_NF_ARPTABLES is not set
++
++#
++# IPv6: Netfilter Configuration
++#
++# CONFIG_IP6_NF_QUEUE is not set
++# CONFIG_IP6_NF_IPTABLES is not set
++# CONFIG_IP_DCCP is not set
++# CONFIG_IP_SCTP is not set
++# CONFIG_RDS is not set
++# CONFIG_TIPC is not set
++# CONFIG_ATM is not set
++# CONFIG_BRIDGE is not set
++# CONFIG_NET_DSA is not set
++# CONFIG_VLAN_8021Q is not set
++# CONFIG_DECNET is not set
++# CONFIG_LLC2 is not set
++# CONFIG_IPX is not set
++# CONFIG_ATALK is not set
++# CONFIG_X25 is not set
++# CONFIG_LAPB is not set
++# CONFIG_ECONET is not set
++# CONFIG_WAN_ROUTER is not set
++# CONFIG_PHONET is not set
++# CONFIG_IEEE802154 is not set
++# CONFIG_NET_SCHED is not set
++# CONFIG_DCB is not set
++
++#
++# Network testing
++#
++# CONFIG_NET_PKTGEN is not set
++# CONFIG_HAMRADIO is not set
++# CONFIG_CAN is not set
++# CONFIG_IRDA is not set
++# CONFIG_BT is not set
++# CONFIG_AF_RXRPC is not set
++CONFIG_WIRELESS=y
++CONFIG_CFG80211=y
++# CONFIG_NL80211_TESTMODE is not set
++# CONFIG_CFG80211_DEVELOPER_WARNINGS is not set
++# CONFIG_CFG80211_REG_DEBUG is not set
++CONFIG_CFG80211_DEFAULT_PS=y
++CONFIG_CFG80211_DEFAULT_PS_VALUE=1
++# CONFIG_CFG80211_DEBUGFS is not set
++CONFIG_WIRELESS_OLD_REGULATORY=y
++CONFIG_WIRELESS_EXT=y
++CONFIG_WIRELESS_EXT_SYSFS=y
++CONFIG_LIB80211=y
++# CONFIG_LIB80211_DEBUG is not set
++# CONFIG_MAC80211 is not set
++# CONFIG_WIMAX is not set
++# CONFIG_RFKILL is not set
++# CONFIG_NET_9P is not set
++
++#
++# Device Drivers
++#
++
++#
++# Generic Driver Options
++#
++CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
++# CONFIG_DEVTMPFS is not set
++CONFIG_STANDALONE=y
++CONFIG_PREVENT_FIRMWARE_BUILD=y
++CONFIG_FW_LOADER=y
++CONFIG_FIRMWARE_IN_KERNEL=y
++CONFIG_EXTRA_FIRMWARE=""
++# CONFIG_DEBUG_DRIVER is not set
++# CONFIG_DEBUG_DEVRES is not set
++# CONFIG_SYS_HYPERVISOR is not set
++# CONFIG_CONNECTOR is not set
++CONFIG_MTD=y
++# CONFIG_MTD_DEBUG is not set
++CONFIG_MTD_TESTS=m
++# CONFIG_MTD_CONCAT is not set
++CONFIG_MTD_PARTITIONS=y
++# CONFIG_MTD_REDBOOT_PARTS is not set
++CONFIG_MTD_CMDLINE_PARTS=y
++# CONFIG_MTD_AFS_PARTS is not set
++# CONFIG_MTD_AR7_PARTS is not set
++
++#
++# User Modules And Translation Layers
++#
++CONFIG_MTD_CHAR=y
++CONFIG_MTD_BLKDEVS=y
++CONFIG_MTD_BLOCK=y
++# CONFIG_FTL is not set
++# CONFIG_NFTL is not set
++# CONFIG_INFTL is not set
++# CONFIG_RFD_FTL is not set
++# CONFIG_SSFDC is not set
++# CONFIG_MTD_OOPS is not set
++
++#
++# RAM/ROM/Flash chip drivers
++#
++# CONFIG_MTD_CFI is not set
++# CONFIG_MTD_JEDECPROBE is not set
++CONFIG_MTD_MAP_BANK_WIDTH_1=y
++CONFIG_MTD_MAP_BANK_WIDTH_2=y
++CONFIG_MTD_MAP_BANK_WIDTH_4=y
++# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
++# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
++# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
++CONFIG_MTD_CFI_I1=y
++CONFIG_MTD_CFI_I2=y
++# CONFIG_MTD_CFI_I4 is not set
++# CONFIG_MTD_CFI_I8 is not set
++# CONFIG_MTD_RAM is not set
++# CONFIG_MTD_ROM is not set
++# CONFIG_MTD_ABSENT is not set
++
++#
++# Mapping drivers for chip access
++#
++# CONFIG_MTD_COMPLEX_MAPPINGS is not set
++# CONFIG_MTD_PLATRAM is not set
++
++#
++# Self-contained MTD device drivers
++#
++# CONFIG_MTD_DATAFLASH is not set
++# CONFIG_MTD_M25P80 is not set
++# CONFIG_MTD_SST25L is not set
++# CONFIG_MTD_SLRAM is not set
++# CONFIG_MTD_PHRAM is not set
++# CONFIG_MTD_MTDRAM is not set
++# CONFIG_MTD_BLOCK2MTD is not set
++
++#
++# Disk-On-Chip Device Drivers
++#
++# CONFIG_MTD_DOC2000 is not set
++# CONFIG_MTD_DOC2001 is not set
++# CONFIG_MTD_DOC2001PLUS is not set
++CONFIG_MTD_NAND=y
++# CONFIG_MTD_NAND_VERIFY_WRITE is not set
++# CONFIG_MTD_NAND_ECC_SMC is not set
++# CONFIG_MTD_NAND_MUSEUM_IDS is not set
++# CONFIG_MTD_NAND_GPIO is not set
++CONFIG_MTD_NAND_IDS=y
++# CONFIG_MTD_NAND_DISKONCHIP is not set
++# CONFIG_MTD_NAND_NANDSIM is not set
++# CONFIG_MTD_NAND_PLATFORM is not set
++# CONFIG_MTD_ALAUDA is not set
++CONFIG_MTD_NAND_DAVINCI=y
++# CONFIG_MTD_ONENAND is not set
++
++#
++# LPDDR flash memory drivers
++#
++# CONFIG_MTD_LPDDR is not set
++
++#
++# UBI - Unsorted block images
++#
++# CONFIG_MTD_UBI is not set
++# CONFIG_PARPORT is not set
++CONFIG_BLK_DEV=y
++# CONFIG_BLK_DEV_COW_COMMON is not set
++CONFIG_BLK_DEV_LOOP=m
++# CONFIG_BLK_DEV_CRYPTOLOOP is not set
++# CONFIG_BLK_DEV_NBD is not set
++# CONFIG_BLK_DEV_UB is not set
++CONFIG_BLK_DEV_RAM=y
++CONFIG_BLK_DEV_RAM_COUNT=1
++CONFIG_BLK_DEV_RAM_SIZE=32768
++# CONFIG_BLK_DEV_XIP is not set
++# CONFIG_CDROM_PKTCDVD is not set
++# CONFIG_ATA_OVER_ETH is not set
++# CONFIG_MG_DISK is not set
++CONFIG_MISC_DEVICES=y
++# CONFIG_ICS932S401 is not set
++# CONFIG_ENCLOSURE_SERVICES is not set
++# CONFIG_ISL29003 is not set
++# CONFIG_C2PORT is not set
++
++#
++# EEPROM support
++#
++CONFIG_EEPROM_AT24=y
++CONFIG_EEPROM_AT25=y
++# CONFIG_EEPROM_LEGACY is not set
++# CONFIG_EEPROM_MAX6875 is not set
++# CONFIG_EEPROM_93CX6 is not set
++CONFIG_HAVE_IDE=y
++# CONFIG_IDE is not set
++
++#
++# SCSI device support
++#
++# CONFIG_RAID_ATTRS is not set
++CONFIG_SCSI=y
++CONFIG_SCSI_DMA=y
++# CONFIG_SCSI_TGT is not set
++# CONFIG_SCSI_NETLINK is not set
++CONFIG_SCSI_PROC_FS=y
++
++#
++# SCSI support type (disk, tape, CD-ROM)
++#
++CONFIG_BLK_DEV_SD=y
++# CONFIG_CHR_DEV_ST is not set
++# CONFIG_CHR_DEV_OSST is not set
++# CONFIG_BLK_DEV_SR is not set
++# CONFIG_CHR_DEV_SG is not set
++# CONFIG_CHR_DEV_SCH is not set
++# CONFIG_SCSI_MULTI_LUN is not set
++# CONFIG_SCSI_CONSTANTS is not set
++# CONFIG_SCSI_LOGGING is not set
++# CONFIG_SCSI_SCAN_ASYNC is not set
++CONFIG_SCSI_WAIT_SCAN=m
++
++#
++# SCSI Transports
++#
++# CONFIG_SCSI_SPI_ATTRS is not set
++# CONFIG_SCSI_FC_ATTRS is not set
++# CONFIG_SCSI_ISCSI_ATTRS is not set
++# CONFIG_SCSI_SAS_LIBSAS is not set
++# CONFIG_SCSI_SRP_ATTRS is not set
++CONFIG_SCSI_LOWLEVEL=y
++# CONFIG_ISCSI_TCP is not set
++# CONFIG_LIBFC is not set
++# CONFIG_LIBFCOE is not set
++# CONFIG_SCSI_DEBUG is not set
++# CONFIG_SCSI_DH is not set
++# CONFIG_SCSI_OSD_INITIATOR is not set
++# CONFIG_ATA is not set
++# CONFIG_MD is not set
++CONFIG_NETDEVICES=y
++# CONFIG_DUMMY is not set
++# CONFIG_BONDING is not set
++# CONFIG_MACVLAN is not set
++# CONFIG_EQUALIZER is not set
++CONFIG_TUN=m
++# CONFIG_VETH is not set
++CONFIG_PHYLIB=y
++
++#
++# MII PHY device drivers
++#
++# CONFIG_MARVELL_PHY is not set
++# CONFIG_DAVICOM_PHY is not set
++# CONFIG_QSEMI_PHY is not set
++CONFIG_LXT_PHY=y
++# CONFIG_CICADA_PHY is not set
++# CONFIG_VITESSE_PHY is not set
++# CONFIG_SMSC_PHY is not set
++# CONFIG_BROADCOM_PHY is not set
++# CONFIG_ICPLUS_PHY is not set
++# CONFIG_REALTEK_PHY is not set
++# CONFIG_NATIONAL_PHY is not set
++# CONFIG_STE10XP is not set
++CONFIG_LSI_ET1011C_PHY=y
++# CONFIG_FIXED_PHY is not set
++# CONFIG_MDIO_BITBANG is not set
++CONFIG_NET_ETHERNET=y
++# CONFIG_MII is not set
++# CONFIG_AX88796 is not set
++# CONFIG_SMC91X is not set
++CONFIG_TI_DAVINCI_EMAC=y
++# CONFIG_DM9000 is not set
++# CONFIG_ENC28J60 is not set
++# CONFIG_ETHOC is not set
++# CONFIG_SMC911X is not set
++# CONFIG_SMSC911X is not set
++# CONFIG_DNET is not set
++# CONFIG_IBM_NEW_EMAC_ZMII is not set
++# CONFIG_IBM_NEW_EMAC_RGMII is not set
++# CONFIG_IBM_NEW_EMAC_TAH is not set
++# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
++# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
++# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
++# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
++# CONFIG_B44 is not set
++# CONFIG_KS8842 is not set
++# CONFIG_KS8851 is not set
++# CONFIG_NETDEV_1000 is not set
++# CONFIG_NETDEV_10000 is not set
++CONFIG_WLAN=y
++# CONFIG_WLAN_PRE80211 is not set
++CONFIG_WLAN_80211=y
++CONFIG_LIBERTAS=m
++# CONFIG_LIBERTAS_USB is not set
++CONFIG_LIBERTAS_SDIO=m
++# CONFIG_LIBERTAS_SPI is not set
++CONFIG_LIBERTAS_DEBUG=y
++# CONFIG_USB_ZD1201 is not set
++# CONFIG_USB_NET_RNDIS_WLAN is not set
++# CONFIG_ATH_COMMON is not set
++# CONFIG_HOSTAP is not set
++# CONFIG_IWM is not set
++
++#
++# Enable WiMAX (Networking options) to see the WiMAX drivers
++#
++
++#
++# USB Network Adapters
++#
++# CONFIG_USB_CATC is not set
++# CONFIG_USB_KAWETH is not set
++# CONFIG_USB_PEGASUS is not set
++# CONFIG_USB_RTL8150 is not set
++# CONFIG_USB_USBNET is not set
++# CONFIG_WAN is not set
++CONFIG_PPP=m
++# CONFIG_PPP_MULTILINK is not set
++# CONFIG_PPP_FILTER is not set
++CONFIG_PPP_ASYNC=m
++CONFIG_PPP_SYNC_TTY=m
++CONFIG_PPP_DEFLATE=m
++# CONFIG_PPP_BSDCOMP is not set
++# CONFIG_PPP_MPPE is not set
++# CONFIG_PPPOE is not set
++# CONFIG_PPPOL2TP is not set
++# CONFIG_SLIP is not set
++CONFIG_SLHC=m
++CONFIG_NETCONSOLE=y
++# CONFIG_NETCONSOLE_DYNAMIC is not set
++CONFIG_NETPOLL=y
++CONFIG_NETPOLL_TRAP=y
++CONFIG_NET_POLL_CONTROLLER=y
++# CONFIG_ISDN is not set
++# CONFIG_PHONE is not set
++
++#
++# Input device support
++#
++CONFIG_INPUT=y
++CONFIG_INPUT_FF_MEMLESS=y
++# CONFIG_INPUT_POLLDEV is not set
++
++#
++# Userland interfaces
++#
++# CONFIG_INPUT_MOUSEDEV is not set
++# CONFIG_INPUT_JOYDEV is not set
++CONFIG_INPUT_EVDEV=y
++CONFIG_INPUT_EVBUG=y
++
++#
++# Input Device Drivers
++#
++# CONFIG_INPUT_KEYBOARD is not set
++# CONFIG_INPUT_MOUSE is not set
++# CONFIG_INPUT_JOYSTICK is not set
++# CONFIG_INPUT_TABLET is not set
++# CONFIG_INPUT_TOUCHSCREEN is not set
++# CONFIG_INPUT_MISC is not set
++
++#
++# Hardware I/O ports
++#
++CONFIG_SERIO=y
++CONFIG_SERIO_SERPORT=y
++CONFIG_SERIO_LIBPS2=y
++# CONFIG_SERIO_RAW is not set
++# CONFIG_GAMEPORT is not set
++
++#
++# Character devices
++#
++CONFIG_VT=y
++CONFIG_CONSOLE_TRANSLATIONS=y
++# CONFIG_VT_CONSOLE is not set
++CONFIG_HW_CONSOLE=y
++# CONFIG_VT_HW_CONSOLE_BINDING is not set
++CONFIG_DEVKMEM=y
++# CONFIG_SERIAL_NONSTANDARD is not set
++
++#
++# Serial drivers
++#
++CONFIG_SERIAL_8250=y
++CONFIG_SERIAL_8250_CONSOLE=y
++CONFIG_SERIAL_8250_NR_UARTS=2
++CONFIG_SERIAL_8250_RUNTIME_UARTS=2
++# CONFIG_SERIAL_8250_EXTENDED is not set
++
++#
++# Non-8250 serial port support
++#
++# CONFIG_SERIAL_MAX3100 is not set
++CONFIG_SERIAL_CORE=y
++CONFIG_SERIAL_CORE_CONSOLE=y
++CONFIG_UNIX98_PTYS=y
++# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
++CONFIG_LEGACY_PTYS=y
++CONFIG_LEGACY_PTY_COUNT=256
++# CONFIG_IPMI_HANDLER is not set
++# CONFIG_HW_RANDOM is not set
++# CONFIG_R3964 is not set
++# CONFIG_RAW_DRIVER is not set
++# CONFIG_TCG_TPM is not set
++CONFIG_DM365_IPIPE=y
++CONFIG_IMP_PREVIEWER=y
++CONFIG_IMP_RESIZER=y
++# CONFIG_IMP_DEBUG is not set
++CONFIG_I2C=y
++CONFIG_I2C_BOARDINFO=y
++CONFIG_I2C_COMPAT=y
++CONFIG_I2C_CHARDEV=y
++CONFIG_I2C_HELPER_AUTO=y
++
++#
++# I2C Hardware Bus support
++#
++
++#
++# I2C system bus drivers (mostly embedded / system-on-chip)
++#
++CONFIG_I2C_DAVINCI=y
++# CONFIG_I2C_DESIGNWARE is not set
++# CONFIG_I2C_GPIO is not set
++# CONFIG_I2C_OCORES is not set
++# CONFIG_I2C_SIMTEC is not set
++
++#
++# External I2C/SMBus adapter drivers
++#
++# CONFIG_I2C_PARPORT_LIGHT is not set
++# CONFIG_I2C_TAOS_EVM is not set
++# CONFIG_I2C_TINY_USB is not set
++
++#
++# Other I2C/SMBus bus drivers
++#
++# CONFIG_I2C_PCA_PLATFORM is not set
++# CONFIG_I2C_STUB is not set
++
++#
++# Miscellaneous I2C Chip support
++#
++# CONFIG_DS1682 is not set
++# CONFIG_SENSORS_TSL2550 is not set
++# CONFIG_I2C_DEBUG_CORE is not set
++# CONFIG_I2C_DEBUG_ALGO is not set
++# CONFIG_I2C_DEBUG_BUS is not set
++# CONFIG_I2C_DEBUG_CHIP is not set
++CONFIG_SPI=y
++# CONFIG_SPI_DEBUG is not set
++CONFIG_SPI_MASTER=y
++
++#
++# SPI Master Controller Drivers
++#
++CONFIG_SPI_DAVINCI=y
++CONFIG_SPI_BITBANG=y
++# CONFIG_SPI_GPIO is not set
++
++#
++# SPI Protocol Masters
++#
++# CONFIG_SPI_SPIDEV is not set
++# CONFIG_SPI_TLE62X0 is not set
++
++#
++# PPS support
++#
++# CONFIG_PPS is not set
++CONFIG_ARCH_REQUIRE_GPIOLIB=y
++CONFIG_GPIOLIB=y
++# CONFIG_DEBUG_GPIO is not set
++# CONFIG_GPIO_SYSFS is not set
++
++#
++# Memory mapped GPIO expanders:
++#
++
++#
++# I2C GPIO expanders:
++#
++# CONFIG_GPIO_MAX732X is not set
++# CONFIG_GPIO_PCA953X is not set
++CONFIG_GPIO_PCF857X=y
++
++#
++# PCI GPIO expanders:
++#
++
++#
++# SPI GPIO expanders:
++#
++# CONFIG_GPIO_MAX7301 is not set
++# CONFIG_GPIO_MCP23S08 is not set
++# CONFIG_GPIO_MC33880 is not set
++
++#
++# AC97 GPIO expanders:
++#
++# CONFIG_W1 is not set
++# CONFIG_POWER_SUPPLY is not set
++CONFIG_HWMON=y
++# CONFIG_HWMON_VID is not set
++# CONFIG_HWMON_DEBUG_CHIP is not set
++
++#
++# Native drivers
++#
++# CONFIG_SENSORS_AD7414 is not set
++# CONFIG_SENSORS_AD7418 is not set
++# CONFIG_SENSORS_ADCXX is not set
++# CONFIG_SENSORS_ADM1021 is not set
++# CONFIG_SENSORS_ADM1025 is not set
++# CONFIG_SENSORS_ADM1026 is not set
++# CONFIG_SENSORS_ADM1029 is not set
++# CONFIG_SENSORS_ADM1031 is not set
++# CONFIG_SENSORS_ADM9240 is not set
++# CONFIG_SENSORS_ADT7462 is not set
++# CONFIG_SENSORS_ADT7470 is not set
++# CONFIG_SENSORS_ADT7473 is not set
++# CONFIG_SENSORS_ADT7475 is not set
++# CONFIG_SENSORS_ATXP1 is not set
++# CONFIG_SENSORS_DS1621 is not set
++# CONFIG_SENSORS_F71805F is not set
++# CONFIG_SENSORS_F71882FG is not set
++# CONFIG_SENSORS_F75375S is not set
++# CONFIG_SENSORS_G760A is not set
++# CONFIG_SENSORS_GL518SM is not set
++# CONFIG_SENSORS_GL520SM is not set
++# CONFIG_SENSORS_IT87 is not set
++# CONFIG_SENSORS_LM63 is not set
++# CONFIG_SENSORS_LM70 is not set
++# CONFIG_SENSORS_LM75 is not set
++# CONFIG_SENSORS_LM77 is not set
++# CONFIG_SENSORS_LM78 is not set
++# CONFIG_SENSORS_LM80 is not set
++# CONFIG_SENSORS_LM83 is not set
++# CONFIG_SENSORS_LM85 is not set
++# CONFIG_SENSORS_LM87 is not set
++# CONFIG_SENSORS_LM90 is not set
++# CONFIG_SENSORS_LM92 is not set
++# CONFIG_SENSORS_LM93 is not set
++# CONFIG_SENSORS_LTC4215 is not set
++# CONFIG_SENSORS_LTC4245 is not set
++# CONFIG_SENSORS_LM95241 is not set
++# CONFIG_SENSORS_MAX1111 is not set
++# CONFIG_SENSORS_MAX1619 is not set
++# CONFIG_SENSORS_MAX6650 is not set
++# CONFIG_SENSORS_PC87360 is not set
++# CONFIG_SENSORS_PC87427 is not set
++# CONFIG_SENSORS_PCF8591 is not set
++# CONFIG_SENSORS_SHT15 is not set
++# CONFIG_SENSORS_DME1737 is not set
++# CONFIG_SENSORS_SMSC47M1 is not set
++# CONFIG_SENSORS_SMSC47M192 is not set
++# CONFIG_SENSORS_SMSC47B397 is not set
++# CONFIG_SENSORS_ADS7828 is not set
++# CONFIG_SENSORS_THMC50 is not set
++# CONFIG_SENSORS_TMP401 is not set
++# CONFIG_SENSORS_TMP421 is not set
++# CONFIG_SENSORS_VT1211 is not set
++# CONFIG_SENSORS_W83781D is not set
++# CONFIG_SENSORS_W83791D is not set
++# CONFIG_SENSORS_W83792D is not set
++# CONFIG_SENSORS_W83793 is not set
++# CONFIG_SENSORS_W83L785TS is not set
++# CONFIG_SENSORS_W83L786NG is not set
++# CONFIG_SENSORS_W83627HF is not set
++# CONFIG_SENSORS_W83627EHF is not set
++# CONFIG_SENSORS_LIS3_SPI is not set
++# CONFIG_THERMAL is not set
++CONFIG_WATCHDOG=y
++# CONFIG_WATCHDOG_NOWAYOUT is not set
++
++#
++# Watchdog Device Drivers
++#
++# CONFIG_SOFT_WATCHDOG is not set
++CONFIG_DAVINCI_WATCHDOG=y
++
++#
++# USB-based Watchdog Cards
++#
++# CONFIG_USBPCWATCHDOG is not set
++CONFIG_SSB_POSSIBLE=y
++
++#
++# Sonics Silicon Backplane
++#
++# CONFIG_SSB is not set
++
++#
++# Multifunction device drivers
++#
++# CONFIG_MFD_CORE is not set
++# CONFIG_MFD_SM501 is not set
++# CONFIG_MFD_ASIC3 is not set
++# CONFIG_HTC_EGPIO is not set
++# CONFIG_HTC_PASIC3 is not set
++# CONFIG_TPS65010 is not set
++# CONFIG_TWL4030_CORE is not set
++# CONFIG_MFD_TMIO is not set
++# CONFIG_MFD_T7L66XB is not set
++# CONFIG_MFD_TC6387XB is not set
++# CONFIG_MFD_TC6393XB is not set
++# CONFIG_PMIC_DA903X is not set
++# CONFIG_MFD_WM8400 is not set
++# CONFIG_MFD_WM831X is not set
++# CONFIG_MFD_WM8350_I2C is not set
++# CONFIG_MFD_PCF50633 is not set
++# CONFIG_MFD_MC13783 is not set
++# CONFIG_AB3100_CORE is not set
++# CONFIG_EZX_PCAP is not set
++# CONFIG_REGULATOR is not set
++CONFIG_MEDIA_SUPPORT=y
++
++#
++# Multimedia core support
++#
++CONFIG_VIDEO_DEV=y
++CONFIG_VIDEO_V4L2_COMMON=y
++# CONFIG_VIDEO_ALLOW_V4L1 is not set
++# CONFIG_VIDEO_V4L1_COMPAT is not set
++# CONFIG_DVB_CORE is not set
++CONFIG_VIDEO_MEDIA=y
++
++#
++# Multimedia drivers
++#
++# CONFIG_MEDIA_ATTACH is not set
++CONFIG_MEDIA_TUNER=y
++# CONFIG_MEDIA_TUNER_CUSTOMISE is not set
++CONFIG_MEDIA_TUNER_SIMPLE=y
++CONFIG_MEDIA_TUNER_TDA8290=y
++CONFIG_MEDIA_TUNER_TDA9887=y
++CONFIG_MEDIA_TUNER_TEA5761=y
++CONFIG_MEDIA_TUNER_TEA5767=y
++CONFIG_MEDIA_TUNER_MT20XX=y
++CONFIG_MEDIA_TUNER_XC2028=y
++CONFIG_MEDIA_TUNER_XC5000=y
++CONFIG_MEDIA_TUNER_MC44S803=y
++CONFIG_VIDEO_V4L2=y
++CONFIG_VIDEOBUF_GEN=y
++CONFIG_VIDEOBUF_VMALLOC=y
++CONFIG_VIDEOBUF_DMA_CONTIG=y
++CONFIG_VIDEO_CAPTURE_DRIVERS=y
++# CONFIG_VIDEO_ADV_DEBUG is not set
++# CONFIG_VIDEO_FIXED_MINOR_RANGES is not set
++# CONFIG_VIDEO_HELPER_CHIPS_AUTO is not set
++
++#
++# Encoders/decoders and other helper chips
++#
++
++#
++# Audio decoders
++#
++# CONFIG_VIDEO_TVAUDIO is not set
++# CONFIG_VIDEO_TDA7432 is not set
++# CONFIG_VIDEO_TDA9840 is not set
++# CONFIG_VIDEO_TDA9875 is not set
++# CONFIG_VIDEO_TEA6415C is not set
++# CONFIG_VIDEO_TEA6420 is not set
++# CONFIG_VIDEO_MSP3400 is not set
++# CONFIG_VIDEO_CS5345 is not set
++# CONFIG_VIDEO_CS53L32A is not set
++# CONFIG_VIDEO_M52790 is not set
++# CONFIG_VIDEO_TLV320AIC23B is not set
++# CONFIG_VIDEO_WM8775 is not set
++# CONFIG_VIDEO_WM8739 is not set
++# CONFIG_VIDEO_VP27SMPX is not set
++
++#
++# RDS decoders
++#
++# CONFIG_VIDEO_SAA6588 is not set
++
++#
++# Video decoders
++#
++# CONFIG_VIDEO_ADV7180 is not set
++# CONFIG_VIDEO_BT819 is not set
++# CONFIG_VIDEO_BT856 is not set
++# CONFIG_VIDEO_BT866 is not set
++# CONFIG_VIDEO_KS0127 is not set
++# CONFIG_VIDEO_OV7670 is not set
++# CONFIG_VIDEO_MT9V011 is not set
++# CONFIG_VIDEO_TCM825X is not set
++# CONFIG_VIDEO_SAA7110 is not set
++# CONFIG_VIDEO_SAA711X is not set
++# CONFIG_VIDEO_SAA717X is not set
++CONFIG_VIDEO_TVP514X=y
++# CONFIG_VIDEO_TVP5150 is not set
++CONFIG_VIDEO_TVP7002=y
++# CONFIG_VIDEO_VPX3220 is not set
++
++#
++# Video and audio decoders
++#
++# CONFIG_VIDEO_CX25840 is not set
++
++#
++# MPEG video encoders
++#
++# CONFIG_VIDEO_CX2341X is not set
++
++#
++# Video encoders
++#
++# CONFIG_VIDEO_SAA7127 is not set
++# CONFIG_VIDEO_SAA7185 is not set
++# CONFIG_VIDEO_ADV7170 is not set
++# CONFIG_VIDEO_ADV7175 is not set
++CONFIG_VIDEO_THS7303=y
++CONFIG_VIDEO_THS7353=y
++CONFIG_VIDEO_THS7353_LUMA_CHANNEL=2
++# CONFIG_VIDEO_ADV7343 is not set
++# CONFIG_VIDEO_THS8200 is not set
++
++#
++# Video improvement chips
++#
++# CONFIG_VIDEO_UPD64031A is not set
++# CONFIG_VIDEO_UPD64083 is not set
++CONFIG_VIDEO_DAVINCI_DISPLAY=y
++CONFIG_DAVINCI_ENC_MNGR=y
++CONFIG_ENC_MNGR_MAX_CHANNELS=1
++CONFIG_DAVINCI_OSD=y
++CONFIG_DAVINCI_VPBE_ENCODER=y
++CONFIG_DAVINCI_LOGICPD_ENCODER=y
++# CONFIG_DAVINCI_AVNET_ENCODER is not set
++# CONFIG_VIDEO_VIVI is not set
++CONFIG_VIDEO_VPSS_SYSTEM=y
++CONFIG_VIDEO_VPFE_CAPTURE=y
++CONFIG_VIDEO_DM365_ISIF=y
++CONFIG_VIDEO_DM365_3A_HW=y
++CONFIG_VIDEO_DM365_AF=y
++CONFIG_VIDEO_DM365_AEW=y
++# CONFIG_VIDEO_SAA5246A is not set
++# CONFIG_VIDEO_SAA5249 is not set
++# CONFIG_SOC_CAMERA is not set
++CONFIG_SOC_CAMERA_MT9T031=y
++# CONFIG_V4L_USB_DRIVERS is not set
++# CONFIG_RADIO_ADAPTERS is not set
++# CONFIG_DAB is not set
++
++#
++# Graphics support
++#
++# CONFIG_VGASTATE is not set
++CONFIG_VIDEO_OUTPUT_CONTROL=y
++CONFIG_FB=y
++# CONFIG_FIRMWARE_EDID is not set
++# CONFIG_FB_DDC is not set
++# CONFIG_FB_BOOT_VESA_SUPPORT is not set
++CONFIG_FB_CFB_FILLRECT=y
++CONFIG_FB_CFB_COPYAREA=y
++CONFIG_FB_CFB_IMAGEBLIT=y
++# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
++# CONFIG_FB_SYS_FILLRECT is not set
++# CONFIG_FB_SYS_COPYAREA is not set
++# CONFIG_FB_SYS_IMAGEBLIT is not set
++# CONFIG_FB_FOREIGN_ENDIAN is not set
++# CONFIG_FB_SYS_FOPS is not set
++# CONFIG_FB_SVGALIB is not set
++# CONFIG_FB_MACMODES is not set
++# CONFIG_FB_BACKLIGHT is not set
++# CONFIG_FB_MODE_HELPERS is not set
++# CONFIG_FB_TILEBLITTING is not set
++
++#
++# Frame buffer hardware drivers
++#
++# CONFIG_FB_S1D13XXX is not set
++CONFIG_FB_DAVINCI=y
++# CONFIG_FB_VIRTUAL is not set
++# CONFIG_FB_METRONOME is not set
++# CONFIG_FB_MB862XX is not set
++# CONFIG_FB_BROADSHEET is not set
++# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
++
++#
++# Display device support
++#
++# CONFIG_DISPLAY_SUPPORT is not set
++
++#
++# Console display driver support
++#
++# CONFIG_VGA_CONSOLE is not set
++CONFIG_DUMMY_CONSOLE=y
++# CONFIG_FRAMEBUFFER_CONSOLE is not set
++CONFIG_LOGO=y
++CONFIG_LOGO_LINUX_MONO=y
++CONFIG_LOGO_LINUX_VGA16=y
++CONFIG_LOGO_LINUX_CLUT224=y
++CONFIG_SOUND=y
++# CONFIG_SOUND_OSS_CORE is not set
++CONFIG_SND=y
++CONFIG_SND_TIMER=y
++CONFIG_SND_PCM=y
++CONFIG_SND_JACK=y
++# CONFIG_SND_SEQUENCER is not set
++# CONFIG_SND_MIXER_OSS is not set
++# CONFIG_SND_PCM_OSS is not set
++# CONFIG_SND_HRTIMER is not set
++# CONFIG_SND_DYNAMIC_MINORS is not set
++CONFIG_SND_SUPPORT_OLD_API=y
++CONFIG_SND_VERBOSE_PROCFS=y
++# CONFIG_SND_VERBOSE_PRINTK is not set
++# CONFIG_SND_DEBUG is not set
++# CONFIG_SND_RAWMIDI_SEQ is not set
++# CONFIG_SND_OPL3_LIB_SEQ is not set
++# CONFIG_SND_OPL4_LIB_SEQ is not set
++# CONFIG_SND_SBAWE_SEQ is not set
++# CONFIG_SND_EMU10K1_SEQ is not set
++CONFIG_SND_DRIVERS=y
++# CONFIG_SND_DUMMY is not set
++# CONFIG_SND_MTPAV is not set
++# CONFIG_SND_SERIAL_U16550 is not set
++# CONFIG_SND_MPU401 is not set
++CONFIG_SND_ARM=y
++CONFIG_SND_SPI=y
++# CONFIG_SND_USB is not set
++CONFIG_SND_SOC=y
++CONFIG_SND_DAVINCI_SOC=y
++CONFIG_SND_DAVINCI_SOC_I2S=y
++CONFIG_SND_DAVINCI_SOC_EVM=y
++CONFIG_SND_SOC_I2C_AND_SPI=y
++# CONFIG_SND_SOC_ALL_CODECS is not set
++CONFIG_SND_SOC_TLV320AIC3X=y
++# CONFIG_SOUND_PRIME is not set
++CONFIG_HID_SUPPORT=y
++CONFIG_HID=y
++# CONFIG_HIDRAW is not set
++
++#
++# USB Input Devices
++#
++CONFIG_USB_HID=y
++# CONFIG_HID_PID is not set
++# CONFIG_USB_HIDDEV is not set
++
++#
++# Special HID drivers
++#
++CONFIG_HID_A4TECH=m
++CONFIG_HID_APPLE=m
++CONFIG_HID_BELKIN=m
++CONFIG_HID_CHERRY=m
++CONFIG_HID_CHICONY=m
++CONFIG_HID_CYPRESS=m
++# CONFIG_HID_DRAGONRISE is not set
++CONFIG_HID_EZKEY=m
++# CONFIG_HID_KYE is not set
++CONFIG_HID_GYRATION=m
++# CONFIG_HID_TWINHAN is not set
++# CONFIG_HID_KENSINGTON is not set
++CONFIG_HID_LOGITECH=y
++# CONFIG_LOGITECH_FF is not set
++# CONFIG_LOGIRUMBLEPAD2_FF is not set
++CONFIG_HID_MICROSOFT=y
++CONFIG_HID_MONTEREY=m
++# CONFIG_HID_NTRIG is not set
++CONFIG_HID_PANTHERLORD=m
++# CONFIG_PANTHERLORD_FF is not set
++CONFIG_HID_PETALYNX=m
++CONFIG_HID_SAMSUNG=m
++CONFIG_HID_SONY=m
++CONFIG_HID_SUNPLUS=m
++# CONFIG_HID_GREENASIA is not set
++# CONFIG_HID_SMARTJOYPLUS is not set
++# CONFIG_HID_TOPSEED is not set
++# CONFIG_HID_THRUSTMASTER is not set
++# CONFIG_HID_ZEROPLUS is not set
++CONFIG_USB_SUPPORT=y
++CONFIG_USB_ARCH_HAS_HCD=y
++# CONFIG_USB_ARCH_HAS_OHCI is not set
++# CONFIG_USB_ARCH_HAS_EHCI is not set
++CONFIG_USB=y
++# CONFIG_USB_DEBUG is not set
++# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
++
++#
++# Miscellaneous USB options
++#
++CONFIG_USB_DEVICEFS=y
++CONFIG_USB_DEVICE_CLASS=y
++# CONFIG_USB_DYNAMIC_MINORS is not set
++# CONFIG_USB_OTG is not set
++# CONFIG_USB_OTG_WHITELIST is not set
++# CONFIG_USB_OTG_BLACKLIST_HUB is not set
++# CONFIG_USB_MON is not set
++# CONFIG_USB_WUSB is not set
++# CONFIG_USB_WUSB_CBAF is not set
++
++#
++# USB Host Controller Drivers
++#
++# CONFIG_USB_C67X00_HCD is not set
++# CONFIG_USB_OXU210HP_HCD is not set
++# CONFIG_USB_ISP116X_HCD is not set
++# CONFIG_USB_ISP1760_HCD is not set
++# CONFIG_USB_ISP1362_HCD is not set
++# CONFIG_USB_SL811_HCD is not set
++# CONFIG_USB_R8A66597_HCD is not set
++# CONFIG_USB_HWA_HCD is not set
++CONFIG_USB_MUSB_HDRC=y
++CONFIG_USB_MUSB_SOC=y
++
++#
++# DaVinci 35x, 36x, 644x USB support
++#
++CONFIG_USB_MUSB_HOST=y
++# CONFIG_USB_MUSB_PERIPHERAL is not set
++# CONFIG_USB_MUSB_OTG is not set
++# CONFIG_MUSB_SCHEDULE_INTR_EP is not set
++CONFIG_USB_MUSB_HDRC_HCD=y
++# CONFIG_MUSB_PIO_ONLY is not set
++# CONFIG_USB_INVENTRA_DMA is not set
++CONFIG_USB_TI_CPPI_DMA=y
++# CONFIG_USB_MUSB_DEBUG is not set
++
++#
++# USB Device Class drivers
++#
++# CONFIG_USB_ACM is not set
++# CONFIG_USB_PRINTER is not set
++# CONFIG_USB_WDM is not set
++# CONFIG_USB_TMC is not set
++
++#
++# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
++#
++
++#
++# also be needed; see USB_STORAGE Help for more info
++#
++CONFIG_USB_STORAGE=y
++# CONFIG_USB_STORAGE_DEBUG is not set
++# CONFIG_USB_STORAGE_DATAFAB is not set
++# CONFIG_USB_STORAGE_FREECOM is not set
++# CONFIG_USB_STORAGE_ISD200 is not set
++# CONFIG_USB_STORAGE_USBAT is not set
++# CONFIG_USB_STORAGE_SDDR09 is not set
++# CONFIG_USB_STORAGE_SDDR55 is not set
++# CONFIG_USB_STORAGE_JUMPSHOT is not set
++# CONFIG_USB_STORAGE_ALAUDA is not set
++# CONFIG_USB_STORAGE_ONETOUCH is not set
++# CONFIG_USB_STORAGE_KARMA is not set
++# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
++# CONFIG_USB_LIBUSUAL is not set
++
++#
++# USB Imaging devices
++#
++# CONFIG_USB_MDC800 is not set
++# CONFIG_USB_MICROTEK is not set
++
++#
++# USB port drivers
++#
++# CONFIG_USB_SERIAL is not set
++
++#
++# USB Miscellaneous drivers
++#
++# CONFIG_USB_EMI62 is not set
++# CONFIG_USB_EMI26 is not set
++# CONFIG_USB_ADUTUX is not set
++# CONFIG_USB_SEVSEG is not set
++# CONFIG_USB_RIO500 is not set
++# CONFIG_USB_LEGOTOWER is not set
++# CONFIG_USB_LCD is not set
++# CONFIG_USB_BERRY_CHARGE is not set
++# CONFIG_USB_LED is not set
++# CONFIG_USB_CYPRESS_CY7C63 is not set
++# CONFIG_USB_CYTHERM is not set
++# CONFIG_USB_IDMOUSE is not set
++# CONFIG_USB_FTDI_ELAN is not set
++# CONFIG_USB_APPLEDISPLAY is not set
++# CONFIG_USB_SISUSBVGA is not set
++# CONFIG_USB_LD is not set
++# CONFIG_USB_TRANCEVIBRATOR is not set
++# CONFIG_USB_IOWARRIOR is not set
++CONFIG_USB_TEST=y
++# CONFIG_USB_ISIGHTFW is not set
++# CONFIG_USB_VST is not set
++# CONFIG_USB_GADGET is not set
++
++#
++# OTG and related infrastructure
++#
++CONFIG_USB_OTG_UTILS=y
++# CONFIG_USB_GPIO_VBUS is not set
++CONFIG_NOP_USB_XCEIV=y
++CONFIG_MMC=y
++# CONFIG_MMC_DEBUG is not set
++# CONFIG_MMC_UNSAFE_RESUME is not set
++
++#
++# MMC/SD/SDIO Card Drivers
++#
++CONFIG_MMC_BLOCK=y
++# CONFIG_MMC_BLOCK_BOUNCE is not set
++CONFIG_SDIO_UART=y
++# CONFIG_MMC_TEST is not set
++
++#
++# MMC/SD/SDIO Host Controller Drivers
++#
++# CONFIG_MMC_SDHCI is not set
++# CONFIG_MMC_AT91 is not set
++# CONFIG_MMC_ATMELMCI is not set
++CONFIG_MMC_DAVINCI=y
++# CONFIG_MMC_SPI is not set
++# CONFIG_MEMSTICK is not set
++CONFIG_NEW_LEDS=y
++CONFIG_LEDS_CLASS=m
++
++#
++# LED drivers
++#
++# CONFIG_LEDS_PCA9532 is not set
++CONFIG_LEDS_GPIO=m
++CONFIG_LEDS_GPIO_PLATFORM=y
++# CONFIG_LEDS_LP3944 is not set
++# CONFIG_LEDS_PCA955X is not set
++# CONFIG_LEDS_DAC124S085 is not set
++# CONFIG_LEDS_BD2802 is not set
++
++#
++# LED Triggers
++#
++CONFIG_LEDS_TRIGGERS=y
++CONFIG_LEDS_TRIGGER_TIMER=m
++CONFIG_LEDS_TRIGGER_HEARTBEAT=m
++# CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
++# CONFIG_LEDS_TRIGGER_GPIO is not set
++# CONFIG_LEDS_TRIGGER_DEFAULT_ON is not set
++
++#
++# iptables trigger is under Netfilter config (LED target)
++#
++# CONFIG_ACCESSIBILITY is not set
++CONFIG_RTC_LIB=y
++# CONFIG_RTC_CLASS is not set
++# CONFIG_DMADEVICES is not set
++# CONFIG_AUXDISPLAY is not set
++# CONFIG_UIO is not set
++
++#
++# TI VLYNQ
++#
++# CONFIG_STAGING is not set
++
++#
++# File systems
++#
++CONFIG_EXT2_FS=y
++# CONFIG_EXT2_FS_XATTR is not set
++# CONFIG_EXT2_FS_XIP is not set
++CONFIG_EXT3_FS=y
++# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
++CONFIG_EXT3_FS_XATTR=y
++# CONFIG_EXT3_FS_POSIX_ACL is not set
++# CONFIG_EXT3_FS_SECURITY is not set
++# CONFIG_EXT4_FS is not set
++CONFIG_JBD=y
++# CONFIG_JBD_DEBUG is not set
++CONFIG_FS_MBCACHE=y
++# CONFIG_REISERFS_FS is not set
++# CONFIG_JFS_FS is not set
++# CONFIG_FS_POSIX_ACL is not set
++CONFIG_XFS_FS=m
++# CONFIG_XFS_QUOTA is not set
++# CONFIG_XFS_POSIX_ACL is not set
++# CONFIG_XFS_RT is not set
++# CONFIG_XFS_DEBUG is not set
++# CONFIG_GFS2_FS is not set
++# CONFIG_OCFS2_FS is not set
++# CONFIG_BTRFS_FS is not set
++# CONFIG_NILFS2_FS is not set
++CONFIG_FILE_LOCKING=y
++CONFIG_FSNOTIFY=y
++CONFIG_DNOTIFY=y
++CONFIG_INOTIFY=y
++CONFIG_INOTIFY_USER=y
++# CONFIG_QUOTA is not set
++# CONFIG_AUTOFS_FS is not set
++CONFIG_AUTOFS4_FS=m
++# CONFIG_FUSE_FS is not set
++
++#
++# Caches
++#
++# CONFIG_FSCACHE is not set
++
++#
++# CD-ROM/DVD Filesystems
++#
++# CONFIG_ISO9660_FS is not set
++# CONFIG_UDF_FS is not set
++
++#
++# DOS/FAT/NT Filesystems
++#
++CONFIG_FAT_FS=y
++CONFIG_MSDOS_FS=y
++CONFIG_VFAT_FS=y
++CONFIG_FAT_DEFAULT_CODEPAGE=437
++CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
++# CONFIG_NTFS_FS is not set
++
++#
++# Pseudo filesystems
++#
++CONFIG_PROC_FS=y
++CONFIG_PROC_SYSCTL=y
++CONFIG_PROC_PAGE_MONITOR=y
++CONFIG_SYSFS=y
++CONFIG_TMPFS=y
++# CONFIG_TMPFS_POSIX_ACL is not set
++# CONFIG_HUGETLB_PAGE is not set
++# CONFIG_CONFIGFS_FS is not set
++CONFIG_MISC_FILESYSTEMS=y
++# CONFIG_ADFS_FS is not set
++# CONFIG_AFFS_FS is not set
++# CONFIG_HFS_FS is not set
++# CONFIG_HFSPLUS_FS is not set
++# CONFIG_BEFS_FS is not set
++# CONFIG_BFS_FS is not set
++# CONFIG_EFS_FS is not set
++CONFIG_JFFS2_FS=y
++CONFIG_JFFS2_FS_DEBUG=0
++CONFIG_JFFS2_FS_WRITEBUFFER=y
++# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
++# CONFIG_JFFS2_SUMMARY is not set
++# CONFIG_JFFS2_FS_XATTR is not set
++# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
++CONFIG_JFFS2_ZLIB=y
++# CONFIG_JFFS2_LZO is not set
++CONFIG_JFFS2_RTIME=y
++# CONFIG_JFFS2_RUBIN is not set
++CONFIG_CRAMFS=y
++# CONFIG_SQUASHFS is not set
++# CONFIG_VXFS_FS is not set
++CONFIG_MINIX_FS=m
++# CONFIG_OMFS_FS is not set
++# CONFIG_HPFS_FS is not set
++# CONFIG_QNX4FS_FS is not set
++# CONFIG_ROMFS_FS is not set
++# CONFIG_SYSV_FS is not set
++# CONFIG_UFS_FS is not set
++CONFIG_NETWORK_FILESYSTEMS=y
++CONFIG_NFS_FS=y
++CONFIG_NFS_V3=y
++# CONFIG_NFS_V3_ACL is not set
++# CONFIG_NFS_V4 is not set
++CONFIG_ROOT_NFS=y
++CONFIG_NFSD=m
++CONFIG_NFSD_V3=y
++# CONFIG_NFSD_V3_ACL is not set
++# CONFIG_NFSD_V4 is not set
++CONFIG_LOCKD=y
++CONFIG_LOCKD_V4=y
++CONFIG_EXPORTFS=m
++CONFIG_NFS_COMMON=y
++CONFIG_SUNRPC=y
++# CONFIG_RPCSEC_GSS_KRB5 is not set
++# CONFIG_RPCSEC_GSS_SPKM3 is not set
++CONFIG_SMB_FS=m
++# CONFIG_SMB_NLS_DEFAULT is not set
++# CONFIG_CIFS is not set
++# CONFIG_NCP_FS is not set
++# CONFIG_CODA_FS is not set
++# CONFIG_AFS_FS is not set
++
++#
++# Partition Types
++#
++CONFIG_PARTITION_ADVANCED=y
++# CONFIG_ACORN_PARTITION is not set
++# CONFIG_OSF_PARTITION is not set
++# CONFIG_AMIGA_PARTITION is not set
++# CONFIG_ATARI_PARTITION is not set
++# CONFIG_MAC_PARTITION is not set
++CONFIG_MSDOS_PARTITION=y
++# CONFIG_BSD_DISKLABEL is not set
++# CONFIG_MINIX_SUBPARTITION is not set
++# CONFIG_SOLARIS_X86_PARTITION is not set
++# CONFIG_UNIXWARE_DISKLABEL is not set
++# CONFIG_LDM_PARTITION is not set
++# CONFIG_SGI_PARTITION is not set
++# CONFIG_ULTRIX_PARTITION is not set
++# CONFIG_SUN_PARTITION is not set
++# CONFIG_KARMA_PARTITION is not set
++# CONFIG_EFI_PARTITION is not set
++# CONFIG_SYSV68_PARTITION is not set
++CONFIG_NLS=y
++CONFIG_NLS_DEFAULT="iso8859-1"
++CONFIG_NLS_CODEPAGE_437=y
++# CONFIG_NLS_CODEPAGE_737 is not set
++# CONFIG_NLS_CODEPAGE_775 is not set
++# CONFIG_NLS_CODEPAGE_850 is not set
++# CONFIG_NLS_CODEPAGE_852 is not set
++# CONFIG_NLS_CODEPAGE_855 is not set
++# CONFIG_NLS_CODEPAGE_857 is not set
++# CONFIG_NLS_CODEPAGE_860 is not set
++# CONFIG_NLS_CODEPAGE_861 is not set
++# CONFIG_NLS_CODEPAGE_862 is not set
++# CONFIG_NLS_CODEPAGE_863 is not set
++# CONFIG_NLS_CODEPAGE_864 is not set
++# CONFIG_NLS_CODEPAGE_865 is not set
++# CONFIG_NLS_CODEPAGE_866 is not set
++# CONFIG_NLS_CODEPAGE_869 is not set
++# CONFIG_NLS_CODEPAGE_936 is not set
++# CONFIG_NLS_CODEPAGE_950 is not set
++# CONFIG_NLS_CODEPAGE_932 is not set
++# CONFIG_NLS_CODEPAGE_949 is not set
++# CONFIG_NLS_CODEPAGE_874 is not set
++# CONFIG_NLS_ISO8859_8 is not set
++# CONFIG_NLS_CODEPAGE_1250 is not set
++# CONFIG_NLS_CODEPAGE_1251 is not set
++CONFIG_NLS_ASCII=m
++CONFIG_NLS_ISO8859_1=y
++# CONFIG_NLS_ISO8859_2 is not set
++# CONFIG_NLS_ISO8859_3 is not set
++# CONFIG_NLS_ISO8859_4 is not set
++# CONFIG_NLS_ISO8859_5 is not set
++# CONFIG_NLS_ISO8859_6 is not set
++# CONFIG_NLS_ISO8859_7 is not set
++# CONFIG_NLS_ISO8859_9 is not set
++# CONFIG_NLS_ISO8859_13 is not set
++# CONFIG_NLS_ISO8859_14 is not set
++# CONFIG_NLS_ISO8859_15 is not set
++# CONFIG_NLS_KOI8_R is not set
++# CONFIG_NLS_KOI8_U is not set
++CONFIG_NLS_UTF8=m
++# CONFIG_DLM is not set
++
++#
++# Kernel hacking
++#
++# CONFIG_PRINTK_TIME is not set
++CONFIG_ENABLE_WARN_DEPRECATED=y
++CONFIG_ENABLE_MUST_CHECK=y
++CONFIG_FRAME_WARN=1024
++# CONFIG_MAGIC_SYSRQ is not set
++# CONFIG_STRIP_ASM_SYMS is not set
++# CONFIG_UNUSED_SYMBOLS is not set
++CONFIG_DEBUG_FS=y
++# CONFIG_HEADERS_CHECK is not set
++CONFIG_DEBUG_KERNEL=y
++# CONFIG_DEBUG_SHIRQ is not set
++CONFIG_DETECT_SOFTLOCKUP=y
++# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
++CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
++CONFIG_DETECT_HUNG_TASK=y
++# CONFIG_BOOTPARAM_HUNG_TASK_PANIC is not set
++CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=0
++CONFIG_SCHED_DEBUG=y
++# CONFIG_SCHEDSTATS is not set
++CONFIG_TIMER_STATS=y
++# CONFIG_DEBUG_OBJECTS is not set
++# CONFIG_SLUB_DEBUG_ON is not set
++# CONFIG_SLUB_STATS is not set
++# CONFIG_DEBUG_KMEMLEAK is not set
++CONFIG_DEBUG_PREEMPT=y
++CONFIG_DEBUG_RT_MUTEXES=y
++CONFIG_DEBUG_PI_LIST=y
++# CONFIG_RT_MUTEX_TESTER is not set
++# CONFIG_DEBUG_SPINLOCK is not set
++CONFIG_DEBUG_MUTEXES=y
++# CONFIG_DEBUG_LOCK_ALLOC is not set
++# CONFIG_PROVE_LOCKING is not set
++# CONFIG_LOCK_STAT is not set
++# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
++# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
++# CONFIG_DEBUG_KOBJECT is not set
++CONFIG_DEBUG_BUGVERBOSE=y
++# CONFIG_DEBUG_INFO is not set
++# CONFIG_DEBUG_VM is not set
++# CONFIG_DEBUG_WRITECOUNT is not set
++# CONFIG_DEBUG_MEMORY_INIT is not set
++# CONFIG_DEBUG_LIST is not set
++# CONFIG_DEBUG_SG is not set
++# CONFIG_DEBUG_NOTIFIERS is not set
++# CONFIG_DEBUG_CREDENTIALS is not set
++CONFIG_FRAME_POINTER=y
++# CONFIG_BOOT_PRINTK_DELAY is not set
++# CONFIG_RCU_TORTURE_TEST is not set
++# CONFIG_RCU_CPU_STALL_DETECTOR is not set
++# CONFIG_BACKTRACE_SELF_TEST is not set
++# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
++# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
++# CONFIG_FAULT_INJECTION is not set
++# CONFIG_LATENCYTOP is not set
++# CONFIG_SYSCTL_SYSCALL_CHECK is not set
++# CONFIG_PAGE_POISONING is not set
++CONFIG_HAVE_FUNCTION_TRACER=y
++CONFIG_TRACING_SUPPORT=y
++CONFIG_FTRACE=y
++# CONFIG_FUNCTION_TRACER is not set
++# CONFIG_IRQSOFF_TRACER is not set
++# CONFIG_PREEMPT_TRACER is not set
++# CONFIG_SCHED_TRACER is not set
++# CONFIG_ENABLE_DEFAULT_TRACERS is not set
++# CONFIG_BOOT_TRACER is not set
++CONFIG_BRANCH_PROFILE_NONE=y
++# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
++# CONFIG_PROFILE_ALL_BRANCHES is not set
++# CONFIG_STACK_TRACER is not set
++# CONFIG_KMEMTRACE is not set
++# CONFIG_WORKQUEUE_TRACER is not set
++# CONFIG_BLK_DEV_IO_TRACE is not set
++# CONFIG_DYNAMIC_DEBUG is not set
++# CONFIG_SAMPLES is not set
++CONFIG_HAVE_ARCH_KGDB=y
++# CONFIG_KGDB is not set
++# CONFIG_ARM_UNWIND is not set
++CONFIG_DEBUG_USER=y
++CONFIG_DEBUG_ERRORS=y
++# CONFIG_DEBUG_STACK_USAGE is not set
++# CONFIG_DEBUG_LL is not set
++
++#
++# Security options
++#
++# CONFIG_KEYS is not set
++# CONFIG_SECURITY is not set
++# CONFIG_SECURITYFS is not set
++# CONFIG_SECURITY_FILE_CAPABILITIES is not set
++CONFIG_CRYPTO=y
++
++#
++# Crypto core or helper
++#
++CONFIG_CRYPTO_ALGAPI=y
++CONFIG_CRYPTO_ALGAPI2=y
++CONFIG_CRYPTO_AEAD2=y
++CONFIG_CRYPTO_BLKCIPHER=y
++CONFIG_CRYPTO_BLKCIPHER2=y
++CONFIG_CRYPTO_HASH2=y
++CONFIG_CRYPTO_RNG2=y
++CONFIG_CRYPTO_PCOMP=y
++CONFIG_CRYPTO_MANAGER=y
++CONFIG_CRYPTO_MANAGER2=y
++# CONFIG_CRYPTO_GF128MUL is not set
++# CONFIG_CRYPTO_NULL is not set
++CONFIG_CRYPTO_WORKQUEUE=y
++# CONFIG_CRYPTO_CRYPTD is not set
++# CONFIG_CRYPTO_AUTHENC is not set
++# CONFIG_CRYPTO_TEST is not set
++
++#
++# Authenticated Encryption with Associated Data
++#
++# CONFIG_CRYPTO_CCM is not set
++# CONFIG_CRYPTO_GCM is not set
++# CONFIG_CRYPTO_SEQIV is not set
++
++#
++# Block modes
++#
++# CONFIG_CRYPTO_CBC is not set
++# CONFIG_CRYPTO_CTR is not set
++# CONFIG_CRYPTO_CTS is not set
++CONFIG_CRYPTO_ECB=y
++# CONFIG_CRYPTO_LRW is not set
++# CONFIG_CRYPTO_PCBC is not set
++# CONFIG_CRYPTO_XTS is not set
++
++#
++# Hash modes
++#
++# CONFIG_CRYPTO_HMAC is not set
++# CONFIG_CRYPTO_XCBC is not set
++# CONFIG_CRYPTO_VMAC is not set
++
++#
++# Digest
++#
++# CONFIG_CRYPTO_CRC32C is not set
++# CONFIG_CRYPTO_GHASH is not set
++# CONFIG_CRYPTO_MD4 is not set
++# CONFIG_CRYPTO_MD5 is not set
++# CONFIG_CRYPTO_MICHAEL_MIC is not set
++# CONFIG_CRYPTO_RMD128 is not set
++# CONFIG_CRYPTO_RMD160 is not set
++# CONFIG_CRYPTO_RMD256 is not set
++# CONFIG_CRYPTO_RMD320 is not set
++# CONFIG_CRYPTO_SHA1 is not set
++# CONFIG_CRYPTO_SHA256 is not set
++# CONFIG_CRYPTO_SHA512 is not set
++# CONFIG_CRYPTO_TGR192 is not set
++# CONFIG_CRYPTO_WP512 is not set
++
++#
++# Ciphers
++#
++CONFIG_CRYPTO_AES=y
++# CONFIG_CRYPTO_ANUBIS is not set
++CONFIG_CRYPTO_ARC4=y
++# CONFIG_CRYPTO_BLOWFISH is not set
++# CONFIG_CRYPTO_CAMELLIA is not set
++# CONFIG_CRYPTO_CAST5 is not set
++# CONFIG_CRYPTO_CAST6 is not set
++# CONFIG_CRYPTO_DES is not set
++# CONFIG_CRYPTO_FCRYPT is not set
++# CONFIG_CRYPTO_KHAZAD is not set
++# CONFIG_CRYPTO_SALSA20 is not set
++# CONFIG_CRYPTO_SEED is not set
++# CONFIG_CRYPTO_SERPENT is not set
++# CONFIG_CRYPTO_TEA is not set
++# CONFIG_CRYPTO_TWOFISH is not set
++
++#
++# Compression
++#
++# CONFIG_CRYPTO_DEFLATE is not set
++# CONFIG_CRYPTO_ZLIB is not set
++# CONFIG_CRYPTO_LZO is not set
++
++#
++# Random Number Generation
++#
++# CONFIG_CRYPTO_ANSI_CPRNG is not set
++# CONFIG_CRYPTO_HW is not set
++# CONFIG_BINARY_PRINTF is not set
++
++#
++# Library routines
++#
++CONFIG_BITREVERSE=y
++CONFIG_GENERIC_FIND_LAST_BIT=y
++CONFIG_CRC_CCITT=m
++# CONFIG_CRC16 is not set
++CONFIG_CRC_T10DIF=m
++# CONFIG_CRC_ITU_T is not set
++CONFIG_CRC32=y
++# CONFIG_CRC7 is not set
++# CONFIG_LIBCRC32C is not set
++CONFIG_ZLIB_INFLATE=y
++CONFIG_ZLIB_DEFLATE=y
++CONFIG_DECOMPRESS_GZIP=y
++CONFIG_GENERIC_ALLOCATOR=y
++CONFIG_HAS_IOMEM=y
++CONFIG_HAS_IOPORT=y
++CONFIG_HAS_DMA=y
++CONFIG_NLATTR=y
+--- a/drivers/media/video/davinci/vpif.h
++++ b/drivers/media/video/davinci/vpif.h
+@@ -592,6 +592,8 @@ struct vpif_channel_config_params {
+ 					 * supports capturing vbi or not */
+ 	u8 hd_sd;
+ 	v4l2_std_id stdid;
++	u32 clk_rate;			/* Pixel clock required for
++					   this mode */
+ };
+ 
+ struct vpif_video_params;
+@@ -602,6 +604,13 @@ int vpif_set_video_params(struct vpif_pa
+ void vpif_set_vbi_display_params(struct vpif_vbi_params *vbiparams,
+ 							u8 channel_id);
+ int vpif_channel_getfid(u8 channel_id);
++void vpif_base_addr_init(void __iomem *base);
++
++/* Enumerated data types */
++enum vpif_capture_pinpol {
++	VPIF_CAPTURE_PINPOL_SAME	= 0,
++	VPIF_CAPTURE_PINPOL_INVERT	= 1
++};
+ 
+ enum data_size {
+ 	_8BITS = 0,
+@@ -609,6 +618,13 @@ enum data_size {
+ 	_12BITS,
+ };
+ 
++struct vpif_capture_params_raw {
++	enum data_size data_sz;
++	enum vpif_capture_pinpol fid_pol;
++	enum vpif_capture_pinpol vd_pol;
++	enum vpif_capture_pinpol hd_pol;
++};
++
+ /* Structure for vpif parameters for raw vbi data */
+ struct vpif_vbi_params {
+ 	__u32 hstart0;  /* Horizontal start of raw vbi data for first field */
+--- a/drivers/rtc/Kconfig
++++ b/drivers/rtc/Kconfig
+@@ -585,6 +585,16 @@ config RTC_DRV_RTC7301
+ 
+ comment "on-CPU RTC drivers"
+ 
++config RTC_DRV_DAVINCI
++	tristate "TI DaVinci RTC"
++	depends on ARCH_DAVINCI_DM365
++	help
++	  If you say yes here you get support for the RTC on the
++	  DaVinci platforms (DM365).
++
++	  This driver can also be built as a module. If so, the module
++	  will be called rtc-davinci.
++
+ config RTC_DRV_OMAP
+ 	tristate "TI OMAP1"
+ 	depends on ARCH_OMAP15XX || ARCH_OMAP16XX || ARCH_OMAP730
+--- /dev/null
++++ b/drivers/media/video/davinci/dm355_af_hw.c
+@@ -0,0 +1,193 @@
++/*
++ * Copyright (C) 2009 Texas Instruments Inc
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
++ */
++
++#include <media/davinci/dm355_af_hw.h>
++#include <linux/device.h>
++
++extern struct device *afdev;
++int af_register_setup(struct af_device *af_dev)
++{
++	unsigned int pcr = 0, pax1 = 0, pax2 = 0, paxstart = 0;
++	unsigned int coef = 0;
++	unsigned int base_coef_set0 = 0;
++	unsigned int base_coef_set1 = 0;
++	int index;
++
++	/*
++	 * Configure Hardware Registers
++	 * Set PCR Register
++	 */
++	pcr = regr(AFPCR);
++
++	/* Set Accumulator Mode */
++	if (af_dev->config->mode == ACCUMULATOR_PEAK)
++		pcr |= FVMODE;
++	else
++		pcr &= ~FVMODE;
++
++	/* Set A-law */
++	if (af_dev->config->alaw_enable == H3A_AF_ENABLE)
++		pcr |= AF_ALAW_EN;
++	else
++		pcr &= ~AF_ALAW_EN;
++
++	/* Set RGB Position */
++	pcr &= ~RGBPOS;
++	pcr |= (af_dev->config->rgb_pos) << AF_RGBPOS_SHIFT;
++
++	/* HMF Configurations */
++	if (af_dev->config->hmf_config.enable == H3A_AF_ENABLE) {
++		pcr &= ~AF_MED_EN;
++		/* Enable HMF */
++		pcr |= AF_MED_EN;
++
++		/* Set Median Threshold */
++		pcr &= ~MED_TH;
++		pcr |=
++		    (af_dev->config->hmf_config.threshold) << AF_MED_TH_SHIFT;
++	} else
++		pcr &= ~AF_MED_EN;
++
++	/* Set Input Source as CCDC */
++	pcr &= ~AF_INP_SRC;
++	pcr |= (AF_CCDC) << AF_INP_SRC_SHIFT;
++
++	/* Set PCR Register */
++	regw(pcr, AFPCR);
++
++	/* 
++	 * Configure AFPAX1 Paxel parameter configuration
++	 * Set Width in AFPAX1 Register
++	 */
++	pax1 &= ~PAXW;
++	pax1 |=
++	    (AF_SET_VAL(af_dev->config->paxel_config.width)) << AF_PAXW_SHIFT;
++
++	/* Set height in AFPAX1 */
++	pax1 &= ~PAXH;
++	pax1 |= (AF_SET_VAL(af_dev->config->paxel_config.height));
++
++	regw(pax1, AFPAX1);
++
++	/*
++	 * Configure AFPAX2 Register
++	 * Set Line Increment in AFPAX2 Register
++	 */
++	pax2 &= ~AFINCV;
++	pax2 |=
++	    (AF_SET_VAL(af_dev->config->paxel_config.line_incr)) <<
++	    AF_LINE_INCR_SHIFT;
++
++	/* Set Vertical Count */
++	pax2 &= ~PAXVC;
++	pax2 |= (af_dev->config->paxel_config.vt_cnt - 1) << AF_VT_COUNT_SHIFT;
++
++	/* Set Horizontal Count */
++	pax2 &= ~PAXHC;
++	pax2 |= (af_dev->config->paxel_config.hz_cnt - 1);
++	regw(pax2, AFPAX2);
++
++	/* 
++	 * Configure PAXSTART Register
++	 *Configure Horizontal Start
++	 */
++	paxstart &= ~PAXSH;
++	paxstart |=
++	    (af_dev->config->paxel_config.hz_start) << AF_HZ_START_SHIFT;
++
++	/* Configure Vertical Start */
++	paxstart &= ~PAXSV;
++	paxstart |= af_dev->config->paxel_config.vt_start;
++	regw(paxstart, AFPAXSTART);
++
++	/*Set IIRSH Register */
++	regw(af_dev->config->iir_config.hz_start_pos, AFIIRSH);
++
++	/* Set IIR Filter0 Coefficients */
++	base_coef_set0 = AFCOEF010;
++	for (index = 0; index <= 8; index += 2) {
++		coef &= ~COEF_MASK0;
++		coef |= af_dev->config->iir_config.coeff_set0[index];
++		coef &= ~COEF_MASK1;
++		coef |=
++		    (af_dev->config->iir_config.
++		     coeff_set0[index + 1]) << AF_COEF_SHIFT;
++		regw(coef, base_coef_set0);
++		dev_dbg(afdev, "\n COEF0 %x", regr(base_coef_set0));
++		base_coef_set0 = base_coef_set0 + AFCOEF_OFFSET;
++	}
++
++	/* Set AFCOEF0010 Register */
++	regw(af_dev->config->iir_config.coeff_set0[10], AFCOEF0010);
++
++	/*Set IIR Filter1 Coefficients */
++	base_coef_set1 = AFCOEF110;
++	for (index = 0; index <= 8; index += 2) {
++		coef &= ~COEF_MASK0;
++		coef |= af_dev->config->iir_config.coeff_set1[index];
++		coef &= ~COEF_MASK1;
++		coef |=
++		    (af_dev->config->iir_config.
++		     coeff_set1[index + 1]) << AF_COEF_SHIFT;
++		regw(coef, base_coef_set1);
++		dev_dbg(afdev, "\n COEF1 %x", regr(base_coef_set1));
++		base_coef_set1 = base_coef_set1 + AFCOEF_OFFSET;
++	}
++
++	/* Set AFCOEF0110 */
++	regw(af_dev->config->iir_config.coeff_set1[10], AFCOEF1010);
++
++	/* Set AFBUFST to Current buffer Physical Address */
++	regw((unsigned int)(virt_to_phys(af_dev->buff_curr)), AFBUFST);
++
++	AF_SETGAMMAWD;
++	dev_dbg(afdev, "\n PCR %x", pcr);
++	dev_dbg(afdev, "\n AFPAX1 %x", regr(AFPAX1));
++	dev_dbg(afdev, "\n PAXSTART %x", paxstart);
++	dev_dbg(afdev, "\n PAX2 %x", regr(AFPAX2));
++	dev_dbg(afdev, "\n COEF 10  %x", regr(AFCOEF0010));
++	dev_dbg(afdev, "\n COEF 10  %x", regr(AFCOEF1010));
++	dev_dbg(afdev, "\n AFBUFST %x", regr(AFBUFST));
++
++	return 0;
++}
++
++/* Function to Enable/Disable AF Engine */
++inline void af_engine_setup(int enable)
++{
++	unsigned int pcr;
++
++	pcr = regr(AFPCR);
++	dev_dbg(afdev, "\nEngine Setup value before PCR : %x", pcr);
++
++	/* Set AF_EN bit in PCR Register */
++	if (enable)
++		pcr |= AF_EN;
++	else
++		pcr &= ~AF_EN;
++
++	regw(pcr, AFPCR);
++
++	dev_dbg(afdev, "\n Engine Setup value after PCR : %x", pcr);
++}
++
++/* Function to set address */
++inline void af_set_address(unsigned long address)
++{
++	regw(address, AFBUFST);
++}
+--- a/include/media/davinci/vpfe_capture.h
++++ b/include/media/davinci/vpfe_capture.h
+@@ -47,6 +47,8 @@ struct vpfe_pixel_format {
+ 	struct v4l2_fmtdesc fmtdesc;
+ 	/* bytes per pixel */
+ 	int bpp;
++	/* decoder format */
++	u32 subdev_pix_fmt;
+ };
+ 
+ struct vpfe_std_info {
+@@ -54,6 +56,7 @@ struct vpfe_std_info {
+ 	int active_lines;
+ 	/* current frame format */
+ 	int frame_format;
++	struct v4l2_fract fps;
+ };
+ 
+ struct vpfe_route {
+@@ -61,9 +64,15 @@ struct vpfe_route {
+ 	u32 output;
+ };
+ 
++enum vpfe_subdev_id {
++	VPFE_SUBDEV_TVP5146 = 1,
++	VPFE_SUBDEV_MT9T031 = 2,
++	VPFE_SUBDEV_TVP7002 = 3,
++};
++
+ struct vpfe_subdev_info {
+-	/* Sub device name */
+-	char name[32];
++	/* Sub device module name */
++	char module_name[32];
+ 	/* Sub device group id */
+ 	int grp_id;
+ 	/* Number of inputs supported */
+@@ -72,12 +81,16 @@ struct vpfe_subdev_info {
+ 	struct v4l2_input *inputs;
+ 	/* Sub dev routing information for each input */
+ 	struct vpfe_route *routes;
+-	/* check if sub dev supports routing */
+-	int can_route;
+ 	/* ccdc bus/interface configuration */
+ 	struct vpfe_hw_if_param ccdc_if_params;
+ 	/* i2c subdevice board info */
+ 	struct i2c_board_info board_info;
++	/* Is this a camera sub device ? */
++	unsigned is_camera:1;
++	/* check if sub dev supports routing */
++	unsigned can_route:1;
++	/* registered ? */
++	unsigned registered:1;
+ };
+ 
+ struct vpfe_config {
+@@ -89,9 +102,19 @@ struct vpfe_config {
+ 	char *card_name;
+ 	/* ccdc name */
+ 	char *ccdc;
+-	/* vpfe clock */
+-	struct clk *vpssclk;
+-	struct clk *slaveclk;
++	/* setup function for the input path */
++	int (*setup_input)(enum vpfe_subdev_id id);
++	/* number of clocks */
++	int num_clocks;
++	/* clocks used for vpfe capture */
++	char *clocks[];
++};
++
++/* TODO - revisit for MC */
++enum output_src {
++	VPFE_CCDC_OUT,
++	VPFE_IMP_PREV_OUT,
++	VPFE_IMP_RSZ_OUT
+ };
+ 
+ struct vpfe_device {
+@@ -102,6 +125,8 @@ struct vpfe_device {
+ 	struct v4l2_subdev **sd;
+ 	/* vpfe cfg */
+ 	struct vpfe_config *cfg;
++	/* clock ptrs for vpfe capture */
++	struct clk **clks;
+ 	/* V4l2 device */
+ 	struct v4l2_device v4l2_dev;
+ 	/* parent device */
+@@ -114,8 +139,27 @@ struct vpfe_device {
+ 	u32 field_id;
+ 	/* flag to indicate whether decoder is initialized */
+ 	u8 initialized;
+-	/* current interface type */
+-	struct vpfe_hw_if_param vpfe_if_params;
++	/* TODO for MC. Previewer is always present if IMP is chained */
++	unsigned char imp_chained;
++	/* Resizer is chained at the output of previewer */
++	unsigned char rsz_present;
++	/* if second resolution output is present */
++	unsigned char second_output;
++	/* offset where second buffer starts from the starting of
++	 * the buffer. This is for storing the second IPIPE resizer
++	 * output
++	 */
++	u32 second_off;
++	/* Size of second output image */
++	int second_out_img_sz;
++	/* output from CCDC or IPIPE */
++	enum output_src out_from;
++	/* skip frame count */
++	u8 skip_frame_count;
++	/* skip frame count init value */
++	u8 skip_frame_count_init;
++	/* time per frame for skipping */
++	struct v4l2_fract timeperframe;
+ 	/* ptr to currently selected sub device */
+ 	struct vpfe_subdev_info *current_subdev;
+ 	/* current input at the sub device */
+@@ -124,6 +168,8 @@ struct vpfe_device {
+ 	struct vpfe_std_info std_info;
+ 	/* std index into std table */
+ 	int std_index;
++	/* IRQ number for DMA transfer completion at the image processor */
++	unsigned int imp_dma_irq;
+ 	/* CCDC IRQs used when CCDC/ISIF output to SDRAM */
+ 	unsigned int ccdc_irq0;
+ 	unsigned int ccdc_irq1;
+@@ -195,4 +241,7 @@ struct vpfe_config_params {
+  **/
+ #define VPFE_CMD_S_CCDC_RAW_PARAMS _IOW('V', BASE_VIDIOC_PRIVATE + 1, \
+ 					void *)
++#define VPFE_CMD_G_CCDC_RAW_PARAMS _IOR('V', BASE_VIDIOC_PRIVATE + 2, \
++					void *)
++
+ #endif				/* _DAVINCI_VPFE_H */
+--- /dev/null
++++ b/include/media/davinci/imp_hw_if.h
+@@ -0,0 +1,182 @@
++/*
++ * Copyright (C) 2008 Texas Instruments Inc
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
++ *
++ **************************************************************************/
++
++#ifndef _IMP_HW_IF_H
++#define _IMP_HW_IF_H
++
++#ifdef __KERNEL__
++#include <media/davinci/imp_common.h>
++#include <media/davinci/vpfe_types.h>
++
++struct prev_module_if {
++	/* Version of the preview module */
++	char *version;
++	/* Module IDs as defined above */
++	unsigned short module_id;
++	/* Name of the module */
++	char *module_name;
++	/* control allowed in continous mode ? 1 - allowed , 0 - not allowed */
++	char control;
++	/* path in which module sits */
++	enum imp_data_paths path;
++	int (*set)(struct device *dev, void *param, int len);
++	int (*get)(struct device *dev, void *param, int len);
++};
++
++struct imp_hw_interface {
++	/* Name of the image processor hardware */
++	char *name;
++	/* module owner */
++	struct module *owner;
++	/*
++	 * enumerate preview modules. Return interface to the
++	 * the module
++	 */
++	struct prev_module_if *(*prev_enum_modules) (struct device *dev,
++						     int index);
++	/*
++	 *  get preview operation mode
++	 */
++	unsigned int (*get_preview_oper_mode) (void);
++	/* get resize operation mode */
++	unsigned int (*get_resize_oper_mode) (void);
++	/* check if hw is busy in continuous mode.
++	 * Used for checking if hw is used by ccdc driver in
++	 * continuous mode. If streaming is ON, this will be
++	 * set to busy
++	 */
++	unsigned int (*get_hw_state) (void);
++	/* set hw state */
++	void (*set_hw_state) (unsigned int state);
++	/* is resizer chained ? */
++	unsigned int (*resizer_chain) (void);
++	/* this is used to lock shared resource */
++	void (*lock_chain) (void);
++	/* this is used unlock shared resouce */
++	void (*unlock_chain) (void);
++	/* Allocate a shared or exclusive config block for hardware
++	 * configuration
++	 */
++	void *(*alloc_config_block) (struct device *dev, int shared);
++	/* hw serialization enabled ?? */
++	int (*serialize) (void);
++	/* De-allocate the exclusive config block */
++	void (*dealloc_config_block) (struct device *dev, void *config);
++	/* Allocate a user confguration block */
++	void *(*alloc_user_config_block) (struct device *dev,
++					  enum imp_log_chan_t chan_type,
++					  unsigned int oper_mode, int *len);
++
++	/* de-allocate user config block */
++	void (*dealloc_user_config_block) (struct device *dev, void *config);
++
++	/* set default configuration in the config block */
++	void (*set_user_config_defaults) (struct device *dev,
++					  enum imp_log_chan_t chan_type,
++					  unsigned int oper_mode,
++					  void *user_config);
++	/* set user configuration for preview */
++	int (*set_preview_config) (struct device *dev,
++				   unsigned int oper_mode,
++				   void *user_config, void *config);
++	/* set user configuration for resize */
++	int (*set_resizer_config) (struct device *dev,
++				   unsigned int oper_mode,
++				   int resizer_chained,
++				   void *user_config, void *config);
++
++	int (*reconfig_resizer) (struct device *dev,
++				struct rsz_reconfig *user_config,
++				void *config);
++
++	/* update output buffer address for a channel
++	 * if config is NULL, the shared config is assumed
++	 * this is used only in single shot mode
++	 */
++	int (*update_inbuf_address) (void *config, unsigned int address);
++	/* update output buffer address for a channel
++	 * if config is NULL, the shared config is assumed
++	 */
++	int (*update_outbuf1_address) (void *config, unsigned int address);
++	/* update output buffer address for a channel
++	 * if config is NULL, the shared config is assumed
++	 */
++	int (*update_outbuf2_address) (void *config, unsigned int address);
++	/* enable or disable hw */
++	void (*enable) (unsigned char en, void *config);
++	/* enable or disable resizer to allow frame by frame resize in
++	 * continuous mode
++	 */
++	void (*enable_resize) (int en);
++	/* setup hardware for processing. if config is NULL,
++	 * shared channel is assumed
++	 */
++	int (*hw_setup) (struct device *dev, void *config);
++	/* Get preview irq numbers */
++	void (*get_preview_irq) (struct irq_numbers *irq);
++	/* Get resize irq numbers */
++	void (*get_rsz_irq) (struct irq_numbers *irq);
++	/* Get configuration state of resizer in continuous mode */
++	unsigned int (*get_resizer_config_state) (void);
++	/* Get configuration state of previewer in continuous mode */
++	unsigned int (*get_previewer_config_state) (void);
++
++	/* Below APIs assume we are using shared configuration since
++	 * oper mode is continuous
++	 */
++	/* Set the input crop window at the IMP interface and IMP */
++	int (*set_input_win) (struct imp_window *win);
++	/* Get current input crop window param at the IMP */
++	int (*get_input_win) (struct imp_window *win);
++	/* Set interface parameter at IPIPEIF. Only valid for DM360 */
++	int (*set_hw_if_param) (struct vpfe_hw_if_param *param);
++	/* Set input pixel format */
++	int (*set_in_pixel_format) (enum imp_pix_formats pix_fmt);
++	/* set output pixel format */
++	int (*set_out_pixel_format) (enum imp_pix_formats pix_fmt);
++	/* 0 - interleaved, 1 - field seperated */
++	int (*set_buftype) (unsigned char buf_type);
++	/* 0 - interlaced, 1 - progressive */
++	int (*set_frame_format) (unsigned char frm_fmt);
++	/* Set the output window at the IMP, output selection
++	 * done by out_sel. 0 - output 1 and 1 - output 2
++	 */
++	int (*set_output_win) (struct imp_window *win);
++	/* Get output enable/disable status */
++	int (*get_output_state) (unsigned char out_sel);
++	/* Get output line lenght */
++	int (*get_line_length) (unsigned char out_sel);
++	/* Get the output image height */
++	int (*get_image_height) (unsigned char out_sel);
++	/* Get current output window param at the IMP */
++	int (*get_output_win) (struct imp_window *win);
++	/* Dump HW configuration to console. only for debug purpose */
++	void (*dump_hw_config) (void);
++	/* get maximum output width of rsz-a or rsz_b*/
++	int (*get_max_output_width) (int rsz);
++	/* get maximum output height of rsa-a or rsz-b */
++	int (*get_max_output_height) (int rsz);
++	/* Enumerate pixel format for a given input format */
++	int (*enum_pix) (u32 *output_pix, int index);
++};
++
++struct imp_hw_interface *imp_get_hw_if(void);
++
++#endif
++#endif
+--- /dev/null
++++ b/drivers/media/video/davinci/dm355_aew.c
+@@ -0,0 +1,852 @@
++/*
++ * Copyright (C) 2009 Texas Instruments Inc
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
++ */
++#include <linux/module.h>
++#include <linux/init.h>
++#include <linux/kernel.h>
++#include <linux/slab.h>
++#include <linux/fs.h>
++#include <linux/errno.h>
++#include <linux/types.h>
++#include <linux/cdev.h>
++#include <linux/interrupt.h>
++#include <linux/dma-mapping.h>
++#include <asm/uaccess.h>
++#include <linux/wait.h>
++#include <linux/mutex.h>
++#include <linux/platform_device.h>
++#include <linux/major.h>
++#include <linux/device.h>
++#include <media/davinci/dm355_aew.h>
++#include <media/davinci/dm355_aew_hw.h>
++#include <media/davinci/vpss.h>
++
++static struct class *aew_class;
++struct aew_device *aew_dev_configptr;
++struct device *aewdev;
++static dev_t dev;
++static struct cdev c_dev;
++
++int aew_validate_parameters(void)
++{
++	int result = 0;
++
++	/* Check horizontal Count */
++	if ((aew_dev_configptr->config->window_config.hz_cnt <
++		AEW_WINDOW_HORIZONTAL_COUNT_MIN) ||
++		(aew_dev_configptr->config->window_config.hz_cnt >
++		AEW_WINDOW_HORIZONTAL_COUNT_MAX)) {
++			dev_err(aewdev, "\n Horizontal Count"
++				" is incorrect");
++			result = -EINVAL;
++	}
++
++	/* Check Vertical Count */
++	if ((aew_dev_configptr->config->window_config.vt_cnt <
++		AEW_WINDOW_VERTICAL_COUNT_MIN) ||
++		(aew_dev_configptr->config->window_config.vt_cnt >
++		AEW_WINDOW_VERTICAL_COUNT_MAX)) {
++			dev_err(aewdev, "\n Vertical Count"
++				" is incorrect");
++			result = -EINVAL;
++	}
++
++	/* Check line increment */
++	if ((AEW_NOT_EVEN ==
++		AEW_CHECK_EVEN(aew_dev_configptr->config->window_config.
++		hz_line_incr)) ||
++		(aew_dev_configptr->config->window_config.hz_line_incr <
++		AEW_HZ_LINEINCR_MIN) ||
++		(aew_dev_configptr->config->window_config.hz_line_incr >
++		AEW_HZ_LINEINCR_MAX)) {
++			dev_err(aewdev, "\n Invalid Parameters");
++			dev_err(aewdev, "\n Horizontal Line"
++				" Increment is incorrect");
++			result = -EINVAL;
++	}
++
++	/* Check line increment */
++	if ((AEW_NOT_EVEN ==
++		AEW_CHECK_EVEN(aew_dev_configptr->config->window_config.
++		vt_line_incr)) ||
++		(aew_dev_configptr->config->window_config.vt_line_incr <
++		AEW_VT_LINEINCR_MIN) ||
++		(aew_dev_configptr->config->window_config.vt_line_incr >
++		AEW_VT_LINEINCR_MAX)) {
++			dev_err(aewdev, "\n Invalid Parameters");
++			dev_err(aewdev, "\n Vertical Line"
++				" Increment is incorrect");
++			result = -EINVAL;
++	}
++
++	/* Check width */
++	if ((AEW_NOT_EVEN ==
++		AEW_CHECK_EVEN(aew_dev_configptr->config->window_config.
++		width)) ||
++		(aew_dev_configptr->config->window_config.width <
++		AEW_WIDTH_MIN) ||
++		(aew_dev_configptr->config->window_config.width > AEW_WIDTH_MAX)) {
++			dev_err(aewdev, "\n Width is incorrect");
++
++			result = -EINVAL;
++	}
++
++	/* Check Height */
++	if ((AEW_NOT_EVEN ==
++	     	AEW_CHECK_EVEN(aew_dev_configptr->config->window_config.
++		height)) || (aew_dev_configptr->config->window_config.height <
++		AEW_HEIGHT_MIN) ||
++		(aew_dev_configptr->config->window_config.height >
++		AEW_HEIGHT_MAX)) {
++			dev_err(aewdev, "\n height incorrect");
++			result = -EINVAL;
++	}
++
++	/* Check Horizontal Start */
++	if ((aew_dev_configptr->config->window_config.hz_start <
++		AEW_HZSTART_MIN) ||
++		(aew_dev_configptr->config->window_config.hz_start >
++		AEW_HZSTART_MAX)) {
++			dev_err(aewdev, "\n horizontal start"
++				" is  incorrect");
++			result = -EINVAL;
++	}
++
++	if ((aew_dev_configptr->config->window_config.vt_start >
++	     AEW_VTSTART_MAX)) {
++		dev_err(aewdev, "\n Vertical start is  incorrect");
++		result = -EINVAL;
++	}
++
++	if ((aew_dev_configptr->config->alaw_enable > H3A_AEW_ENABLE) ||
++		(aew_dev_configptr->config->alaw_enable < H3A_AEW_DISABLE)) {
++		dev_err(aewdev, "\n A Law setting is incorrect");
++		result = -EINVAL;
++	}
++
++	if (aew_dev_configptr->config->saturation_limit > AEW_AVELMT_MAX) {
++		dev_err(aewdev, "\n Saturation Limit is incorrect");
++		result = -EINVAL;
++	}
++
++	/* Check Black Window Height */
++	if (AEW_NOT_EVEN ==
++		AEW_CHECK_EVEN(aew_dev_configptr->config->blackwindow_config.
++		height) ||
++		(aew_dev_configptr->config->blackwindow_config.height <
++		AEW_BLKWINHEIGHT_MIN) ||
++		(aew_dev_configptr->config->blackwindow_config.height >
++		AEW_BLKWINHEIGHT_MAX)) {
++			dev_err(aewdev, "\n Black Window height incorrect");
++			result = -EINVAL;
++	}
++
++	/* Check Black Window Height */
++	if ((AEW_NOT_EVEN ==
++		AEW_CHECK_EVEN(aew_dev_configptr->config->blackwindow_config.
++		height)) ||
++		(aew_dev_configptr->config->blackwindow_config.vt_start <
++		AEW_BLKWINVTSTART_MIN) ||
++		(aew_dev_configptr->config->blackwindow_config.vt_start >
++		AEW_BLKWINVTSTART_MAX)) {
++			dev_err(aewdev, "\n Black Window vertical"
++				" Start is incorrect");
++			result = -EINVAL;
++	}
++
++	if (((aew_dev_configptr->config->window_config.vt_cnt) *
++		(aew_dev_configptr->config->window_config.height) +
++		(aew_dev_configptr->config->window_config.vt_start)) > 156) {
++			dev_err(aewdev, "\n Only 156 Lines are"
++				" supported for CCDC mode");
++			dev_err(aewdev, "\n Vertical count * Height +"
++				" vertical Start should not exceed 156");
++		result = -EINVAL;
++	}
++
++	return result;
++}
++
++/* inline function to free reserver pages */
++void inline aew_free_pages(unsigned long addr, unsigned long bufsize)
++{
++	unsigned long tempaddr;
++	unsigned long size;
++
++	tempaddr = addr;
++	if (!addr)
++		return;
++
++	size = PAGE_SIZE << (get_order(bufsize));
++	while (size > 0) {
++		ClearPageReserved(virt_to_page(addr));
++		addr += PAGE_SIZE;
++		size -= PAGE_SIZE;
++	}
++
++	free_pages(tempaddr, get_order(bufsize));
++}
++
++/* Function to perform hardware Configuration */
++int aew_hardware_setup(void)
++{
++	int result;
++	int buff_size = 0;
++	unsigned long adr;
++	unsigned long size;
++	unsigned int busyaew;
++
++	/* Get the value of PCR register */
++	busyaew = AEW_GET_PCR;
++
++	/* Mask with BUSYAF bit */
++	busyaew = busyaew & AEW_BUSYAEWB;
++
++	/* Shift it 18 times to get value of 1 or 0 */
++	busyaew = busyaew >> AEW_BUSYAEWB_SHIFT;
++
++	/* If H3A Engine is busy then return */
++	if (busyaew == 1) {
++		dev_err(aewdev, "\n Error : AEW Engine is busy");
++		return -EBUSY;
++	}
++
++	result = aew_validate_parameters();
++
++	dev_dbg(aewdev, "Result =  %d\n", result);
++	if (result < 0) {
++		dev_err(aewdev, "Error : Parameters are incorrect \n");
++		return result;
++	}
++
++	/* Deallocate the previously allocated buffers */
++	if (aew_dev_configptr->buff_old)
++		aew_free_pages((unsigned long)aew_dev_configptr->buff_old,
++			aew_dev_configptr->size_window);
++
++	if (aew_dev_configptr->buff_curr)
++		aew_free_pages((unsigned long)aew_dev_configptr->
++			buff_curr, aew_dev_configptr->size_window);
++
++	if (aew_dev_configptr->buff_app)
++		aew_free_pages((unsigned long)aew_dev_configptr->
++			buff_app, aew_dev_configptr->size_window);
++
++	/* 
++	 * Allocat the buffers as per the new buffer size
++	 * Allocate memory for old buffer 
++	 */
++	buff_size = (aew_dev_configptr->config->window_config.hz_cnt) *
++			(aew_dev_configptr->config->window_config.vt_cnt) *
++			AEW_WINDOW_SIZE;
++
++	aew_dev_configptr->buff_old = (void *)__get_free_pages(GFP_KERNEL |
++					GFP_DMA, get_order(buff_size));
++
++	if (aew_dev_configptr->buff_old == NULL)
++		return -ENOMEM;
++
++	/* Make pages reserved so that they will be swapped out */
++	adr = (unsigned long)aew_dev_configptr->buff_old;
++	size = PAGE_SIZE << (get_order(buff_size));
++
++	while (size > 0) {
++		/* 
++		 * Make sure the frame buffers
++		 * are never swapped out of memory
++		 */
++		SetPageReserved(virt_to_page(adr));
++		adr += PAGE_SIZE;
++		size -= PAGE_SIZE;
++	}
++
++	/*Allocate memory for current buffer */
++	aew_dev_configptr->buff_curr = (void *)__get_free_pages(GFP_KERNEL |
++					GFP_DMA, get_order(buff_size));
++
++	if (aew_dev_configptr->buff_curr == NULL) {
++		/* Free all  buffer that are allocated */
++		if (aew_dev_configptr->buff_old)
++			aew_free_pages((unsigned long)aew_dev_configptr->
++					buff_old, buff_size);
++		return -ENOMEM;
++	}
++
++	/* Make pages reserved so that they will be swapped out */
++	adr = (unsigned long)aew_dev_configptr->buff_curr;
++	size = PAGE_SIZE << (get_order(buff_size));
++	while (size > 0) {
++		/* 
++		 * Make sure the frame buffers
++		 * are never swapped out of memory
++		 */
++		SetPageReserved(virt_to_page(adr));
++		adr += PAGE_SIZE;
++		size -= PAGE_SIZE;
++	}
++
++	/* Allocate memory for application buffer */
++	aew_dev_configptr->buff_app = (void *)__get_free_pages(GFP_KERNEL |
++					GFP_DMA, get_order(buff_size));
++
++	if (aew_dev_configptr->buff_app == NULL) {
++		/* Free all buffer that were allocated previously */
++		if (aew_dev_configptr->buff_old)
++			aew_free_pages((unsigned long)aew_dev_configptr->
++				       buff_old, buff_size);
++		if (aew_dev_configptr->buff_curr)
++			aew_free_pages((unsigned long)aew_dev_configptr->
++				       buff_curr, buff_size);
++		return -ENOMEM;
++	}
++
++	/* Make pages reserved so that they will be swapped out */
++	adr = (unsigned long)aew_dev_configptr->buff_app;
++	size = PAGE_SIZE << (get_order(buff_size));
++	while (size > 0) {
++		/* 
++		 * Make sure the frame buffers
++		 * are never swapped out of memory
++		 */
++		SetPageReserved(virt_to_page(adr));
++		adr += PAGE_SIZE;
++		size -= PAGE_SIZE;
++	}
++
++	/* Set the registers */
++	aew_register_setup(aew_dev_configptr);
++	aew_dev_configptr->size_window = buff_size;
++	aew_dev_configptr->aew_config = H3A_AEW_CONFIG;
++
++	return 0;
++}
++
++static int aew_open(struct inode *inode, struct file *filp)
++{
++	/* Return if Device is in use (Single Channel Support is provided) */
++	if (aew_dev_configptr->in_use == AEW_IN_USE)
++		return -EBUSY;
++
++	/* Set the aew_dev_configptr structure */
++	aew_dev_configptr->config = NULL;
++
++	/* Allocate memory for configuration  structure of this channel */
++	aew_dev_configptr->config = (struct aew_configuration *)
++		kmalloc(sizeof(struct aew_configuration), GFP_KERNEL);
++
++	if (aew_dev_configptr->config == NULL) {
++		dev_err(aewdev, "Error : Kmalloc fail\n");
++		return -ENOMEM;
++	}
++
++	/* Initiaze the wait queue */
++	init_waitqueue_head(&(aew_dev_configptr->aew_wait_queue));
++
++	/* Device is in use */
++	aew_dev_configptr->in_use = AEW_IN_USE;
++
++	/* No Hardware Set up done */
++	aew_dev_configptr->aew_config = H3A_AEW_CONFIG_NOT_DONE;
++
++	/* No statistics are available */
++	aew_dev_configptr->buffer_filled = 0;
++
++	/* Set Window Size to 0 */
++	aew_dev_configptr->size_window = 0;
++
++	/* Initialize the mutex */
++	mutex_init(&(aew_dev_configptr->read_blocked));
++
++	return 0;
++}
++
++static void aew_platform_release(struct device *device)
++{
++	/* This is called when the reference count goes to zero */
++}
++
++static int aew_probe(struct device *device)
++{
++	aewdev = device;
++	return 0;
++}
++
++static int aew_remove(struct device *device)
++{
++	return 0;
++}
++
++/* This Function is called when driver is closed */
++static int aew_release(struct inode *inode, struct file *filp)
++{
++	aew_engine_setup(0);
++
++	/* The Application has closed device so device is not in use */
++	aew_dev_configptr->in_use = AEW_NOT_IN_USE;
++
++	/* Release memory for configuration structure of this channel */
++	if (aew_dev_configptr->config)
++		kfree(aew_dev_configptr->config);
++
++	/* Free Old Buffer */
++	if (aew_dev_configptr->buff_old)
++		aew_free_pages((unsigned long)aew_dev_configptr->buff_old,
++			aew_dev_configptr->size_window);
++
++	/* Free Current Buffer */
++	if (aew_dev_configptr->buff_curr)
++		aew_free_pages((unsigned long)aew_dev_configptr->
++			buff_curr, aew_dev_configptr->size_window);
++
++	/* Free Application Buffer */
++	if (aew_dev_configptr->buff_app)
++		aew_free_pages((unsigned long)aew_dev_configptr->buff_app,
++			aew_dev_configptr->size_window);
++
++	aew_dev_configptr->buff_old	= NULL;
++	aew_dev_configptr->buff_curr	= NULL;
++	aew_dev_configptr->config	= NULL;
++	aew_dev_configptr->buff_app	= NULL;
++
++	return 0;
++}
++
++/*
++ * This function will process IOCTL commands sent by the application and
++ * control the devices IO operations.
++ */
++static int aew_ioctl(struct inode *inode, struct file *filep,
++		     unsigned int cmd, unsigned long arg)
++{
++	/* Stores Previous Configurations */
++	struct aew_configuration aewconfig = *(aew_dev_configptr->config);
++	int result = 0;
++
++	/* Decrement the mutex */
++	result = mutex_lock_interruptible(&aew_dev_configptr->read_blocked);
++	if (result)
++		return result;
++
++	/*
++	 * Extract the type and number bitfields and 
++	 * don't decode wrong cmds 
++	 * verify the magic number
++	 */
++	if (_IOC_TYPE(cmd) != AEW_MAGIC_NO) {
++		mutex_unlock(&aew_dev_configptr->read_blocked);
++		return -ENOTTY;
++	}
++
++	/* verify the command number */
++	if (_IOC_NR(cmd) > AEW_IOC_MAXNR) {
++		/* Release mutex in case of fault */
++		mutex_unlock(&aew_dev_configptr->read_blocked);
++		return -ENOTTY;
++	}
++
++	/* check for the permission of the operation */
++	if (_IOC_DIR(cmd) & _IOC_READ)
++		result = !access_ok(VERIFY_WRITE, (void __user *)arg,
++				_IOC_SIZE(cmd));
++	else if (_IOC_DIR(cmd) & _IOC_WRITE)
++		result = !access_ok(VERIFY_READ, (void __user *)arg,
++				_IOC_SIZE(cmd));
++
++	if (result) {
++		/* Release mutex in case of fault */
++		mutex_unlock(&aew_dev_configptr->read_blocked);
++		return -EFAULT;
++	}
++
++	/* Switch according to IOCTL command */
++	switch (cmd) {
++		/*
++		 * This ioctl is used to perform hardware set up
++		 * and will set all the regiseters for AF engine
++		 */
++	case AEW_S_PARAM:
++
++		/* Copy config structure passed by user */
++		if (copy_from_user(aew_dev_configptr->config,
++				   (struct aew_configuration *)arg,
++				   sizeof(struct aew_configuration))) {
++			*(aew_dev_configptr->config) = aewconfig;
++			mutex_unlock(&aew_dev_configptr->read_blocked);
++			return -EFAULT;
++		}
++
++		/* Call aew_hardware_setup to perform register configuration */
++		result = aew_hardware_setup();
++		if (!result) {
++			/*
++			 * Hardware Set up is successful
++			 * Return the no of bytes required for buffer
++			 */
++			result = aew_dev_configptr->size_window;
++		} else {
++			/* Change Configuration Structure to original */
++			*(aew_dev_configptr->config) = aewconfig;
++			dev_err(aewdev, "Error : AEW_S_PARAM  failed\n");
++		}
++
++		break;
++
++		/* This ioctl is used to return parameters in user space */
++	case AEW_G_PARAM:
++		if (aew_dev_configptr->aew_config == H3A_AEW_CONFIG) {
++			if (copy_to_user
++			    ((struct aew_configuration *)arg,
++			     aew_dev_configptr->config,
++			     sizeof(struct aew_configuration))) {
++				mutex_unlock(&aew_dev_configptr->read_blocked);
++				return -EFAULT;
++			} else
++				result = aew_dev_configptr->size_window;
++		} else {
++			dev_err(aewdev,
++				"Error : AEW Hardware is not configured.\n");
++			result = -EINVAL;
++		}
++		break;
++
++		/* This ioctl is used to enable AEW Engine */
++	case AEW_ENABLE:
++		/*Enable AEW Engine if Hardware set up is done */
++		if (aew_dev_configptr->aew_config == H3A_AEW_CONFIG_NOT_DONE) {
++			dev_err(aewdev,
++				"Error : AEW Hardware is not configured.\n");
++			result = -EINVAL;
++		} else
++			/* Enable AF Engine */
++			aew_engine_setup(1);
++		break;
++
++		/* This ioctl is used to disable AEW Engine */
++	case AEW_DISABLE:
++		/* Disable AEW Engine */
++		aew_engine_setup(0);
++		break;
++
++		/* Invalid Command */
++	default:
++		dev_err(aewdev, "Error: It should not come here!!\n");
++		result = -ENOTTY;
++		break;
++	}
++
++	/*Release the mutex */
++	mutex_unlock(&aew_dev_configptr->read_blocked);
++
++	return result;
++}
++
++/* This function will return statistics to user */
++static ssize_t aew_read(struct file *filep, char *kbuff,
++			size_t size, loff_t *offset)
++{
++	void *buffer_temp;
++	int result = 0;
++	int ret;
++
++	/* Mutex will return immediately if read call is busy */
++	ret = mutex_lock_interruptible(&(aew_dev_configptr->read_blocked));
++	if (ret != 0) {
++		dev_dbg(aewdev, "Read Call : busy  : %d\n", ret);
++		return -EBUSY;
++	}
++
++	/* First Check the size given by user */
++	if (size < aew_dev_configptr->size_window) {
++		/* 
++		 * Return Failure to applicaiton
++		 * if size is less than required size
++		 */
++		dev_dbg(aewdev, "Error : Invalid size of buffer\n");
++		mutex_unlock(&(aew_dev_configptr->read_blocked));
++		return -1;
++	}
++
++	/*
++	 * The value of buffer_filled flag determines
++	 * the status of statistics
++	 */
++	if (aew_dev_configptr->buffer_filled == 0) {
++		/* Decrement the mutex */
++		dev_dbg(aewdev, "READ CALL IS BLOCKED............\n");
++		/* Block the read call */
++		wait_event_interruptible_timeout(aew_dev_configptr->
++						 aew_wait_queue,
++						 aew_dev_configptr->
++						 buffer_filled, AEW_TIMEOUT);
++		dev_dbg(aewdev, "Read Call is unbloked and waking up.....\n");
++		dev_dbg(aewdev, "Buffer Filled.... %d\n",
++			aew_dev_configptr->buffer_filled);
++	}
++
++	if (aew_dev_configptr->buffer_filled == 1) {
++		/* Disable the interrupts and then swap the buffers */
++		dev_dbg(aewdev, "READING............\n");
++		disable_irq(4);
++
++		/* New Statistics are availaible */
++		aew_dev_configptr->buffer_filled = 0;
++
++		/* Swap application buffer and old buffer */
++		buffer_temp = aew_dev_configptr->buff_old;
++		aew_dev_configptr->buff_old = aew_dev_configptr->buff_app;
++		aew_dev_configptr->buff_app = buffer_temp;
++
++		/* Interrupts are enabled */
++		enable_irq(4);
++
++		/*
++		 * Copy the entire statistics located in application
++		 * buffer to user space
++		 */
++		if (copy_to_user(kbuff, aew_dev_configptr->buff_app,
++				 aew_dev_configptr->size_window)) {
++			dev_err(aewdev, "Error : Read Fault\n");
++			mutex_unlock(&(aew_dev_configptr->read_blocked));
++			return -EFAULT;
++		} else
++			result = aew_dev_configptr->size_window;
++
++		dev_dbg(aewdev, "Reading Done........................\n");
++	}
++
++	dev_dbg(aewdev, "APP BUFF VALUE %x\n",
++		(*((unsigned int *)(aew_dev_configptr->buff_app))));
++
++	/* Increment the mutex */
++	mutex_unlock(&(aew_dev_configptr->read_blocked));
++
++	return result;
++}
++
++/* This function will handle interrupt generated by H3A Engine */
++static irqreturn_t aew_isr(int irq, void *dev_id)
++{
++	/* Busy AF Bit */
++	unsigned int busyaew;
++
++	/* Temporary Buffer for Swapping */
++	void *buffer_temp;
++
++	/* Get the value of PCR register */
++	busyaew = AEW_GET_PCR;
++
++	/* If AEW engine is not enabled, interrupt is not for AEW */
++	if (((busyaew & 0x10000) >> 16) == 0)
++		return IRQ_RETVAL(IRQ_NONE);
++
++	/*
++	 * Interrupt is generated by AEW, so Service the Interrupt
++	 * Swap current buffer and old buffer
++	 */
++	if (aew_dev_configptr) {
++		buffer_temp = aew_dev_configptr->buff_curr;
++		aew_dev_configptr->buff_curr = aew_dev_configptr->buff_old;
++		aew_dev_configptr->buff_old = buffer_temp;
++
++		/* Set the AEWBUFSTAT Register to current buffer Address */
++		aew_set_address((unsigned
++			long)(virt_to_phys(aew_dev_configptr->buff_curr)));
++
++		/*
++		 * Set buffer filled flag to indicate
++		 * statistics are available
++		 */
++		aew_dev_configptr->buffer_filled = 1;
++
++		/* 
++		 * New statistics are available
++		 * Wake up the read call
++		 */
++		wake_up(&(aew_dev_configptr->aew_wait_queue));
++
++		return IRQ_RETVAL(IRQ_HANDLED);
++	}
++	return IRQ_RETVAL(IRQ_NONE);
++}
++
++/* File Operation Structure */
++static struct file_operations aew_fops = {
++	.owner		= THIS_MODULE,
++	.open		= aew_open,
++	.read		= aew_read,
++	.ioctl		= aew_ioctl,
++	.release	= aew_release,
++};
++
++static struct platform_device aewdevice = {
++	.name	= "dm355_aew",
++	.id	= 2,
++	.dev	= {
++		.release = aew_platform_release,
++	}
++};
++
++static struct device_driver aew_driver = {
++	.name	= "dm355_aew",
++	.bus	= &platform_bus_type,
++	.probe	= aew_probe,
++	.remove	= aew_remove,
++};
++
++#define DRIVERNAME  "DM355AEW"
++/* Function to register the AF character device driver */
++int __init aew_init(void)
++{
++	int err;
++	int result = 0;
++	unsigned int vpssclk;
++
++	/*
++	 * Register the driver in the kernel
++	 * dynmically get the major number for
++	 * the driver using alloc_chrdev_region function
++	 */
++	result = alloc_chrdev_region(&dev, 0, 1, DRIVERNAME);
++
++	if (result < 0) {
++		printk("Error :  Could not register character device");
++		return -ENODEV;
++	}
++
++	printk(KERN_INFO "aew major#: %d, minor# %d\n", MAJOR(dev), MINOR(dev));
++
++	/* Allocate memory for device structure and initialize it with 0 */
++	aew_dev_configptr =
++	    (struct aew_device *)kmalloc(sizeof(struct aew_device),
++		GFP_KERNEL);
++	if (!aew_dev_configptr) {
++		printk("Error : kmalloc fail");
++		unregister_chrdev_region(dev, AEW_NR_DEVS);
++		return -ENOMEM;
++	}
++
++	/* Initialize character device */
++	cdev_init(&c_dev, &aew_fops);
++	c_dev.owner = THIS_MODULE;
++	c_dev.ops = &aew_fops;
++
++	err = cdev_add(&c_dev, dev, 1);
++	if (err) {
++		printk("Error : Error in  Adding Davinci AEW");
++		unregister_chrdev_region(dev, AEW_NR_DEVS);
++		if (aew_dev_configptr)
++			kfree(aew_dev_configptr);
++		return -err;
++	}
++
++	/* Register driver as a platform driver */
++	if (driver_register(&aew_driver) != 0) {
++		unregister_chrdev_region(dev, 1);
++		cdev_del(&c_dev);
++		return -EINVAL;
++	}
++
++	/* Register the drive as a platform device */
++	if (platform_device_register(&aewdevice) != 0) {
++		driver_unregister(&aew_driver);
++		unregister_chrdev_region(dev, 1);
++		cdev_del(&c_dev);
++		return -EINVAL;
++	}
++
++	aew_class = class_create(THIS_MODULE, "dm355_aew");
++	if (!aew_class) {
++		printk("aew_init: error in creating device class\n");
++		driver_unregister(&aew_driver);
++		platform_device_unregister(&aewdevice);
++		unregister_chrdev_region(dev, 1);
++		unregister_chrdev(MAJOR(dev), DRIVERNAME);
++		cdev_del(&c_dev);
++		return -EINVAL;
++	}
++
++	device_create(aew_class, NULL, dev, NULL, "dm355_aew");
++
++	/* AEW_SELINT(interrupt_no) */
++	AEW_SETGAMMAWD;
++	vpssclk = AEW_GETCLKCTRL;
++	vpssclk |= (1 << 4);
++	AEW_SETCLKCTRL(vpssclk);
++	/* Set up the Interrupt handler for H3AINT interrupt */
++	result = request_irq(4, aew_isr, IRQF_SHARED, "dm355h3a_aew",
++				(void *)aew_dev_configptr);
++
++	if (result != 0) {
++		printk("Error : Request IRQ Failed");
++		unregister_chrdev_region(dev, AEW_NR_DEVS);
++		device_destroy(aew_class, dev);
++		class_destroy(aew_class);
++		if (aew_dev_configptr)
++			kfree(aew_dev_configptr);
++		driver_unregister(&aew_driver);
++		platform_device_unregister(&aewdevice);
++		cdev_del(&c_dev);
++		return result;
++	}
++
++	/* Initialize device structure */
++	memset(aew_dev_configptr, 0, sizeof(struct aew_device));
++
++	aew_dev_configptr->in_use = AEW_NOT_IN_USE;
++	aew_dev_configptr->buffer_filled = 0;
++
++	return 0;
++}
++
++/*
++ * This Function is called by the kernel while unloading the driver
++ * This will unregister the Character Device Driver
++ */
++void __exit aew_cleanup(void)
++{
++	/* Device is in use */
++	if (aew_dev_configptr->in_use == AEW_IN_USE) {
++		printk("Error : Driver in use");
++		return;
++	}
++
++	free_irq(4, aew_dev_configptr);
++
++	/* Free device structure */
++	if (aew_dev_configptr)
++		kfree(aew_dev_configptr);
++
++	aew_dev_configptr = NULL;
++	unregister_chrdev_region(dev, AEW_NR_DEVS);
++
++	driver_unregister(&aew_driver);
++
++	device_destroy(aew_class, dev);
++
++	class_destroy(aew_class);
++
++	platform_device_unregister(&aewdevice);
++
++	cdev_del(&c_dev);
++
++	/* Unregistering the driver from the kernel */
++	unregister_chrdev(MAJOR(dev), DEVICE_NAME);
++}
++
++module_init(aew_init)
++module_exit(aew_cleanup)
++MODULE_LICENSE("GPL");
+--- a/drivers/i2c/chips/Makefile
++++ b/drivers/i2c/chips/Makefile
+@@ -16,4 +16,3 @@ obj-$(CONFIG_SENSORS_TSL2550)	+= tsl2550
+ ifeq ($(CONFIG_I2C_DEBUG_CHIP),y)
+ EXTRA_CFLAGS += -DDEBUG
+ endif
+-
+--- /dev/null
++++ b/include/media/davinci/davinci_platform.h
+@@ -0,0 +1,45 @@
++/*
++ * Copyright (C) 2007 Texas Instruments Inc
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
++ */
++
++#ifndef DAVINCI_PLATFORM_H
++#define DAVINCI_PLATFORM_H
++#include <linux/kernel.h>
++#include <linux/init.h>
++#include <linux/ctype.h>
++#include <linux/delay.h>
++#include <linux/device.h>
++#include <mach/hardware.h>
++#include <mach/mux.h>
++#include <mach/cputype.h>
++#include <mach/io.h>
++#include <media/davinci/davinci_enc.h>
++#include <media/davinci/vid_encoder_types.h>
++#include <video/davinci_vpbe.h>
++#include <media/davinci/davinci_enc_mngr.h>
++
++#ifdef __KERNEL__
++int davinci_enc_select_venc_clock(int clk);
++void davinci_enc_set_display_timing(struct vid_enc_mode_info *mode);
++void davinci_enc_set_mode_platform(int channel, struct vid_enc_device_mgr *mgr);
++
++u32 venc_reg_in(u32 offset);
++u32 venc_reg_out(u32 offset, u32 val);
++u32 venc_reg_merge(u32 offset, u32 val, u32 mask);
++#endif				/* End of __KERNEL__ */
++
++#endif				/* End of ifndef DAVINCI_PLATFORM_H */
+--- /dev/null
++++ b/include/media/tvp7002.h
+@@ -0,0 +1,536 @@
++/*
++ * Copyright (C) 2007-2009 Texas Instruments Inc
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
++ */
++#ifndef TVP7002_H
++#define TVP7002_H
++
++#ifdef __KERNEL__
++#if 0
++#include <linux/i2c.h>
++#include <linux/device.h>
++#include <linux/videodev.h>
++#include <media/davinci/vid_decoder_if.h>
++#endif
++#include <linux/videodev2.h>
++#endif				/* __KERNEL__ */
++
++#define V4L2_STD_TVP7002_ALL        (V4L2_STD_720P_60 | \
++					V4L2_STD_720P_50 | \
++					V4L2_STD_1080I_60 | \
++					V4L2_STD_1080I_50 | \
++					V4L2_STD_525P_60)
++
++/* enum */
++enum tvp7002_mode {
++	TVP7002_MODE_480i_30FPS = 0,
++	TVP7002_MODE_576i_25FPS,
++	TVP7002_MODE_480p_30FPS,
++	TVP7002_MODE_576p_25FPS,
++	TVP7002_MODE_720p_30FPS,
++	TVP7002_MODE_1080i_30FPS,
++	TVP7002_MODE_1080p_30FPS,
++	TVP7002_MODE_1080i_25FPS
++};
++
++enum tvp7002_alc_vertical_coeff {
++	TVP7002_VCOEFF_1,
++	TVP7002_VCOEFF_2,
++	TVP7002_VCOEFF_4,
++	TVP7002_VCOEFF_8,
++	TVP7002_VCOEFF_16,
++	TVP7002_VCOEFF_32,
++	TVP7002_VCOEFF_64,
++	TVP7002_VCOEFF_128,
++	TVP7002_VCOEFF_256,
++	TVP7002_VCOEFF_512,
++	TVP7002_VCOEFF_1024
++};
++
++enum tvp7002_alc_horizontal_coeff {
++	TVP7002_HCOEFF_2,
++	TVP7002_HCOEFF_4,
++	TVP7002_HCOEFF_8,
++	TVP7002_HCOEFF_16,
++	TVP7002_HCOEFF_32,
++	TVP7002_HCOEFF_64,
++	TVP7002_HCOEFF_128,
++	TVP7002_HCOEFF_256,
++	TVP7002_HCOEFF_512
++} ;
++
++enum tvp7002_post_divider {
++	HPLL_POST_DIVIDE_1 = 0,
++	HPLL_POST_DIVIDE_2
++};
++
++enum tvp7002_vco_gain {
++	VCO_GAIN_ULTRA_LOW = 0,
++	VCO_GAIN_LOW,
++	VCO_GAIN_MEDIUM,
++	VCO_GAIN_HIGH
++};
++
++enum tvp7002_cp_current {
++	CP_CURRENT_SMALL,
++	CP_CURRENT_DEFAULT,
++	CP_CURRENT_LARGE
++};
++
++/*structures*/
++
++struct alc_filter {
++	int alc_enable;
++	enum tvp7002_alc_vertical_coeff vcoeff;
++	enum tvp7002_alc_horizontal_coeff hcoeff;
++};
++
++struct tvp7002_format_params {
++	unsigned char hpll_divider_msb;
++	unsigned char hpll_divider_lsb;
++	enum tvp7002_vco_gain hpll_vco_control;
++	enum tvp7002_cp_current hpll_cp_current;
++	unsigned char hpll_phase_select;
++	enum tvp7002_post_divider hpll_post_divider;
++	unsigned char hpll_control;
++	unsigned char avid_start_msb;
++	unsigned char avid_start_lsb;
++	unsigned char avid_stop_msb;
++	unsigned char avid_stop_lsb;
++	unsigned char vblk_start_f0_line_offset;
++	unsigned char vblk_start_f1_line_offset;
++	unsigned char vblk_f0_duration;
++	unsigned char vblk_f1_duration;
++	unsigned char alc_placement;
++	unsigned char clamp_start, clamp_width;
++	unsigned char hpll_pre_coast;
++	unsigned char hpll_post_coast;
++	unsigned char reserved;
++};
++
++struct tvp7002_offset {
++	unsigned char blue_fine_offset;
++	unsigned char green_fine_offset;
++	unsigned char red_fine_offset;
++	unsigned char blue_fine_offset_lsb;
++	unsigned char green_fine_offset_lsb;
++	unsigned char red_fine_offset_lsb;
++	unsigned char blue_coarse_offset;
++	unsigned char green_coarse_offset;
++	unsigned char red_coarse_offset;
++};
++
++struct tvp7002_gain {
++	unsigned char blue_fine_gain;
++	unsigned char green_fine_gain;
++	unsigned char red_fine_gain;
++	unsigned char blue_coarse_gain;
++	unsigned char green_coarse_gain;
++	unsigned char red_coarse_gain;
++};
++
++struct tvp7002_params {
++	v4l2_std_id std;
++	int inputidx;
++	struct alc_filter alc;
++	struct tvp7002_gain gain;
++	struct tvp7002_offset offset;
++	struct tvp7002_format_params format;
++};
++
++#ifdef __KERNEL__
++
++#define TVP7002_NUM_CHANNELS                    1
++
++/* Macros */
++#define TVP7002_LINES_720       0x2EE
++#define TVP7002_LINES_1080_60   0x465
++#define TVP7002_LINES_1080_50   0x465
++
++/*
++ * Clocks per line = ppln * internal clock / pixel rate
++ * Clocks per line assuming 6.5 MHz internal clock +- 6%
++*/
++#define TVP7002_CPL_1080P_60_LOWER	90
++#define TVP7002_CPL_1080P_60_UPPER	102
++
++#define TVP7002_CPL_1080_60_LOWER	181
++#define TVP7002_CPL_1080_60_UPPER	205
++
++#define TVP7002_CPL_1080_50_LOWER	217
++#define TVP7002_CPL_1080_50_UPPER	245
++
++#define TVP7002_CPL_720P_50_LOWER	163
++#define TVP7002_CPL_720P_50_UPPER	183
++
++#define TVP7002_CPL_720P_60_LOWER	135
++#define TVP7002_CPL_720P_60_UPPER	153
++
++#define INTERLACED_VIDEO                         0
++#define PROGRESSIVE_VIDEO                        1
++
++#define GENERATE_MASK(bits, pos) ((((0xFFFFFFFF) << (32-bits)) >> \
++		(32-bits)) << pos)
++
++/* Defines for input supported */
++#define TVP7002_HD				0
++
++/* Macros for default register values */
++#define TVP7002_HPLL_MSB_DEFAULT                0x67
++#define TVP7002_HPLL_LSB_DEFAULT                0x20
++#define TVP7002_HPLL_CONTROL_DEFAULT            0xA0
++#define TVP7002_HPLL_PHASE_SEL_DEFAULT          0x80
++#define TVP7002_CLAMP_START_DEFAULT             0x32
++#define TVP7002_CLAMP_WIDTH_DEFAULT             0x20
++#define TVP7002_HSYNC_OUTWIDTH_DEFAULT          0x60
++#define TVP7002_BLUE_FINE_GAIN_DEFAULT          0x00
++#define TVP7002_GREEN_FINE_GAIN_DEFAULT         0x00
++#define TVP7002_RED_FINE_GAIN_DEFAULT           0x00
++#define TVP7002_BLUEF_OFFSETMSB_DEFAULT         0x80
++#define TVP7002_GREENF_OFFSETMSB_DEFAULT        0x80
++#define TVP7002_REDF_OFFSETMSB_DEFAULT          0x80
++#define TVP7002_SYNC_CONTROL1_DEFAULT           0x20
++#define TVP7002_HPLL_CLAMP_CTRL_DEFAULT         0x2E
++#define TVP7002_SYNC_GREEN_THLD_DEFAULT         0x5D
++#define TVP7002_SYNC_SEP_THLD_DEFAULT           0x47
++#define TVP7002_HPLL_PRE_COAST_DEFAULT          0x00
++#define TVP7002_HPLL_POST_COAST_DEFAULT         0x00
++#define TVP7002_OUTPUT_FORMATTER_DEFAULT        0x47
++#define TVP7002_MISC_CONTROL1_DEFAULT           0x01
++#define TVP7002_MISC_CONTROL2_DEFAULT           0x00
++#define TVP7002_MISC_CONTROL3_DEFAULT           0x01
++#define TVP7002_INPUT_MUX_SELECT1_DEFAULT       0x00
++#define TVP7002_INPUT_MUX_SELECT2_DEFAULT       0x67
++#define TVP7002_BLUE_GREEN_COARSE_GAIN_DEFAULT  0x77
++#define TVP7002_RED_COARSE_GAIN_DEFAULT         0x07
++#define TVP7002_FINE_OFFSET_LSBS_DEFAULT        0x00
++#define TVP7002_BLUE_COARSE_OFFSET_DEFUALT      0x10
++#define TVP7002_GREEN_COARSE_OFFSET_DEFAULT     0x10
++#define TVP7002_RED_COARSE_OFFSET_DEFAULT       0x10
++#define TVP7002_RED_COARSE_OFFSET_DEFAULT       0x10
++#define TVP7002_HSOUT_OUTPUT_START_DEFAULT      0x08
++#define TVP7002_MISC_CONTROL4_DEFAULT           0x00
++#define TVP7002_ALC_ENABLE_DEFAULT              0x80
++#define TVP7002_ALC_FILTER_DEFAULT              0x53
++#define TVP7002_FINE_CLAMP_CONTROL_DEFAULT      0x07
++#define TVP7002_POWER_CONTROL_DEFAULT           0x00
++#define TVP7002_ADC_SETUP_DEFAULT               0x50
++#define TVP7002_COARSE_CLAMP_CONTROL_DEFAULT    0x00
++#define TVP7002_SOG_CLAMP_DEFAULT               0x80
++#define TVP7002_ALC_PLACEMENT_DEFAULT           0x5A
++#define TVP7002_VSYNC_ALIGNMENT_DEFAULT         0x10
++#define TVP7002_SYNC_BYPASS_DEFAULT             0x00
++#define TVP7002_LINE_LENGTH_TOLERENCE_DEFAULT   0x03
++#define TVP7002_ADC_REF_SETUP_DEFAULT           0x04
++#define TVP7002_POWER_DOWN			0x7F
++#define TVP7002_VIDEO_BANDWIDTH_CONTROL_DEFAULT	0x01
++#define TVP7002_AVID_START_PIXEL_DEFAULT	0x01
++
++/* Macros for horizontal PLL */
++#define FEEDBACK_DIVIDER_MSB_720p               0x67
++#define FEEDBACK_DIVIDER_LSB_720p               0x02
++#define VCO_CONTROL_720p                        0x02
++#define CP_CURRENT_720p                         0x04
++#define PHASE_SELECT_720p                       0x16
++#define POST_DIVIDER_720p                       0x0
++#define HPLL_CONTROL_720p			0xA0
++#define AVID_START_PIXEL_LSB_720p		0x47
++#define AVID_START_PIXEL_MSB_720p		0x01
++#define AVID_STOP_PIXEL_LSB_720p		0x4B
++#define AVID_STOP_PIXEL_MSB_720p		0x06
++#define VBLK_F0_START_LINE_OFFSET_720p		0x05
++#define VBLK_F1_START_LINE_OFFSET_720p		0x00
++#define VBLK_F0_DURATION_720p			0x2D
++#define VBLK_F1_DURATION_720p			0x00
++#define RESERVED_720p				0x03
++
++#define FEEDBACK_DIVIDER_MSB_720p_50            0x7B
++#define FEEDBACK_DIVIDER_LSB_720p_50            0x0C
++#define VCO_CONTROL_720p_50                     0x02
++#define CP_CURRENT_720p_50                      0x03
++#define PHASE_SELECT_720p_50                    0x16
++#define POST_DIVIDER_720p_50                    0x0
++#define HPLL_CONTROL_720p_50			0x98
++#define AVID_START_PIXEL_LSB_720p_50		0x47
++#define AVID_START_PIXEL_MSB_720p_50		0x01
++#define AVID_STOP_PIXEL_LSB_720p_50		0x4B
++#define AVID_STOP_PIXEL_MSB_720p_50		0x06
++#define VBLK_F0_START_LINE_OFFSET_720p_50	0x05
++#define VBLK_F1_START_LINE_OFFSET_720p_50	0x00
++#define VBLK_F0_DURATION_720p_50		0x2D
++#define VBLK_F1_DURATION_720p_50		0x00
++#define RESERVED_720p				0x03
++
++#define FEEDBACK_DIVIDER_MSB_1080i              0x89
++#define FEEDBACK_DIVIDER_LSB_1080i              0x08
++#define VCO_CONTROL_1080i                       0x02
++#define CP_CURRENT_1080i                        0x03
++#define PHASE_SELECT_1080i                      0x14
++#define POST_DIVIDER_1080i                      0x0
++#define HPLL_CONTROL_1080i			0x98
++#define AVID_START_PIXEL_LSB_1080i		0x06
++#define AVID_START_PIXEL_MSB_1080i		0x01
++#define AVID_STOP_PIXEL_LSB_1080i		0x8A
++#define AVID_STOP_PIXEL_MSB_1080i		0x08
++#define VBLK_F0_START_LINE_OFFSET_1080i		0x02
++#define VBLK_F1_START_LINE_OFFSET_1080i		0x02
++#define VBLK_F0_DURATION_1080i			0x16
++#define VBLK_F1_DURATION_1080i			0x17
++#define RESERVED_1080i				0x02
++
++#define FEEDBACK_DIVIDER_MSB_1080i_50           0xA5
++#define FEEDBACK_DIVIDER_LSB_1080i_50           0x00
++#define VCO_CONTROL_1080i_50                    0x02
++#define CP_CURRENT_1080i_50                     0x02
++#define PHASE_SELECT_1080i_50                   0x14
++#define POST_DIVIDER_1080i_50                   0x0
++#define HPLL_CONTROL_1080i_50			0x90
++#define AVID_START_PIXEL_LSB_1080i_50		0x06
++#define AVID_START_PIXEL_MSB_1080i_50		0x01
++#define AVID_STOP_PIXEL_LSB_1080i_50		0x8A
++#define AVID_STOP_PIXEL_MSB_1080i_50		0x08
++#define VBLK_F0_START_LINE_OFFSET_1080i_50	0x02
++#define VBLK_F1_START_LINE_OFFSET_1080i_50	0x02
++#define VBLK_F0_DURATION_1080i_50		0x16
++#define VBLK_F1_DURATION_1080i_50		0x17
++#define RESERVED_1080i_50			0x02
++
++#define FEEDBACK_DIVIDER_MSB_1080p		0x89
++#define FEEDBACK_DIVIDER_LSB_1080p		0x08
++#define VCO_CONTROL_1080p			0x03
++#define CP_CURRENT_1080p			0x04
++#define PHASE_SELECT_1080p			0x14
++#define POST_DIVIDER_1080p			0x0
++#define HPLL_CONTROL_1080p			0xE0
++#define AVID_START_PIXEL_LSB_1080p		0x06
++#define AVID_START_PIXEL_MSB_1080p		0x01
++#define AVID_STOP_PIXEL_LSB_1080p		0x8A
++#define AVID_STOP_PIXEL_MSB_1080p		0x08
++#define VBLK_F0_START_LINE_OFFSET_1080p		0x02
++#define VBLK_F1_START_LINE_OFFSET_1080p		0x02
++#define VBLK_F0_DURATION_1080p			0x16
++#define VBLK_F1_DURATION_1080p			0x17
++#define RESERVED_1080p				0x02
++
++#define FEEDBACK_DIVIDER_MSB_480P		0x35
++#define FEEDBACK_DIVIDER_LSB_480P		0x0A
++#define VCO_CONTROL_480P			0x02
++#define CP_CURRENT_480P				0x02
++#define PHASE_SELECT_480P			0x14
++#define POST_DIVIDER_480P			0x0
++#define HPLL_CONTROL_480P			0x18
++#define AVID_START_PIXEL_LSB_480P		0x91
++#define AVID_START_PIXEL_MSB_480P		0x00
++#define AVID_STOP_PIXEL_LSB_480P		0x0B
++#define AVID_STOP_PIXEL_MSB_480P		0x00
++#define VBLK_F0_START_LINE_OFFSET_480P		0x03
++#define VBLK_F1_START_LINE_OFFSET_480P		0x01
++#define VBLK_F0_DURATION_480P			0x13
++#define VBLK_F1_DURATION_480P			0x13
++#define RESERVED_1080i_50                       0x02
++
++#define FEEDBACK_DIVIDER_MSB_576P               0x36
++#define FEEDBACK_DIVIDER_LSB_576P               0x00
++#define VCO_CONTROL_576P                        0x02
++#define CP_CURRENT_576P                         0x02
++#define PHASE_SELECT_576P                       0x14
++#define POST_DIVIDER_576P                       0x0
++#define HPLL_CONTROL_576P                       0x18
++#define AVID_START_PIXEL_LSB_576P               0x9B
++#define AVID_START_PIXEL_MSB_576P               0x00
++#define AVID_STOP_PIXEL_LSB_576P                0x0F
++#define AVID_STOP_PIXEL_MSB_576P                0x00
++#define VBLK_F0_START_LINE_OFFSET_576P          0x00
++#define VBLK_F1_START_LINE_OFFSET_576P          0x00
++#define VBLK_F0_DURATION_576P                   0x2D
++#define VBLK_F1_DURATION_576P                   0x00
++#define RESERVED_1080i_50                       0x02
++
++#define TVP7002_HD_ALC_PLACEMENT		0x5A
++#define TVP7002_ED_ALC_PLACEMENT		0x18
++
++#define TVP7002_HD_CLAMP_START			0x32
++#define TVP7002_ED_CLAMP_START			0x06
++
++#define TVP7002_HD_CLAMP_WIDTH			0x20
++#define TVP7002_ED_CLAMP_WIDTH			0x10
++
++#define TVP7002_HD_PRE_COAST			0x0
++#define TVP7002_ED_PRE_COAST			0x03
++
++#define TVP7002_HD_POST_COAST			0x0
++#define TVP7002_ED_POST_COAST			0x0C
++
++/* HPLL masks and shifts */
++#define HPLL_DIVIDER_LSB_MASK                   GENERATE_MASK(4, 0)
++#define HPLL_DIVIDER_LSB_SHIFT                  4
++#define VCO_CONTROL_MASK                        GENERATE_MASK(2, 0)
++#define CP_CURRENT_MASK                         GENERATE_MASK(3, 0)
++#define VCO_CONTROL_SHIFT                       6
++#define CP_CURRENT_SHIFT                        3
++#define PHASE_SELECT_MASK                       GENERATE_MASK(5, 0)
++#define PHASE_SELECT_SHIFT                      3
++
++#define POST_DIVIDER_MASK                       GENERATE_MASK(1, 0)
++
++#define LINES_PER_FRAME_MSB_MASK                GENERATE_MASK(4, 8)
++#define LINES_PER_FRAME_MSB_SHIFT               8
++
++#define VIDEO_DETECTION_MASK                    GENERATE_MASK(1, 5)
++#define VIDEO_DETECTION_SHIFT			5
++
++/* Gain and offset masks */
++
++#define BLUE_COARSE_GAIN_MASK                   GENERATE_MASK(4, 0)
++#define GREEN_COARSE_GAIN_MASK                  GENERATE_MASK(4, 0)
++#define RED_COARSE_GAIN_MASK                    GENERATE_MASK(4, 0)
++#define GREEN_COARSE_GAIN_SHIFT                 4
++
++#define FINE_OFFSET_LSB_MASK                    0x03
++
++#define FINE_OFFSET_LSB_SHIFT_GREEN             2
++#define FINE_OFFSET_LSB_SHIFT_RED               4
++
++#define COARSE_OFFSET_MASK                      GENERATE_MASK(6, 0)
++
++/* Defines for TVP7002 register address */
++#define TVP7002_HPLL_DIVIDER_MSB                0x01
++#define TVP7002_HPLL_DIVIDER_LSB                0x02
++#define TVP7002_HPLL_CONTROL                    0x03
++#define TVP7002_HPLL_PHASE_SELECT               0x04
++#define TVP7002_CLAMP_START                     0x05
++#define TVP7002_CLAMP_WIDTH                     0x06
++#define TVP7002_HSYNC_OUTPUT_WIDTH              0x07
++
++#define TVP7002_BLUE_FINE_GAIN                  0x08
++#define TVP7002_GREEN_FINE_GAIN                 0x09
++#define TVP7002_RED_FINE_GAIN                   0x0A
++#define TVP7002_BLUE_FINE_OFFSETMSB             0x0B
++#define TVP7002_GREEN_FINE_OFFSETMSB            0x0C
++#define TVP7002_RED_FINE_OFFSETMSB              0x0D
++
++#define TVP7002_SYNC_CONTROL_1                  0x0E
++#define TVP7002_HPLL_CLAMP_CONTROL              0x0F
++#define TVP7002_SYNC_ON_GREEN_THLD              0x10
++#define TVP7002_SYNC_SEPARATER_THLD             0x11
++#define TVP7002_HPLL_PRE_COAST                  0x12
++#define TVP7002_HPLL_POST_COAST                 0x13
++
++#define TVP7002_OUTPUT_FORMATTER                0x15
++#define TVP7002_MISC_CONTROL_1                  0x16
++#define TVP7002_MISC_CONTROL_2                  0x17
++#define TVP7002_MISC_CONTROL_3                  0x18
++#define TVP7002_INPUT_MUX_SELECT_1              0x19
++#define TVP7002_INPUT_MUX_SELECT_2              0x1A
++#define TVP7002_BLUE_GREEN_COARSE_GAIN          0x1B
++#define TVP7002_RED_COARSE_GAIN                 0x1C
++#define TVP7002_FINE_OFFSET_LSBS                0x1D
++#define TVP7002_BLUE_COARSE_OFFSET              0x1E
++#define TVP7002_GREEN_COARSE_OFFSET             0x1F
++#define TVP7002_RED_COARSE_OFFSET               0x20
++#define TVP7002_HSOUT_OUTPUT_START              0x21
++#define TVP7002_MISC_CONTROL_4                  0x22
++#define TVP7002_ALC_ENABLE                      0x26
++#define TVP7002_ALC_FILTER                      0x28
++#define TVP7002_FINE_CLAMP_CONTROL              0x2A
++#define TVP7002_POWER_CONTROL                   0x2B
++#define TVP7002_ADC_SETUP                       0x2C
++#define TVP7002_COARSE_CLAMP_CONTROL            0x2D
++#define TVP7002_SOG_CLAMP                       0x2E
++#define TVP7002_ALC_PLACEMENT                   0x31
++#define TVP7002_VSYNC_ALIGNMENT                 0x35
++#define TVP7002_SYNC_BYPASS                     0x36
++#define TVP7002_LINES_PER_FRAME_STATUS_LOW      0x37
++#define TVP7002_LINES_PER_FRAME_STATUS_HIGH     0x38
++#define TVP7002_CLOCK_PER_LINE_STATUS_LSB	0x39
++#define TVP7002_CLOCK_PER_LINE_STATUS_MSB	0x3A
++
++#define TVP7002_LINE_LENGTH_TOLERENCE           0x3D
++#define TVP7002_ADC_REF_SETUP                   0x3E
++#define TVP7002_VIDEO_BANDWIDTH_CONTROL		0x3F
++#define TVP7002_AVID_START_PIXEL_LOW            0x40
++#define TVP7002_AVID_START_PIXEL_HIGH           0x41
++#define TVP7002_AVID_STOP_PIXEL_LOW             0x42
++#define TVP7002_AVID_STOP_PIXEL_HIGH            0x43
++#define TVP7002_VBLK_FIELD0_START_OFFSET        0x44
++#define TVP7002_VBLK_FIELD1_START_OFFSET        0x45
++#define TVP7002_VBLK_FIELD0_DURATION            0x46
++#define TVP7002_VBLK_FIELD1_DURATION            0x47
++#define TVP7002_FBIT_FIELD0_START_OFFSET        0x48
++#define TVP7002_FBIT_FIELD1_START_OFFSET        0x49
++
++#define TVP7002_HD_INPUT                        0x00
++
++/* decoder standard related strctures */
++#define TVP7002_MAX_NO_INPUTS			1
++#define TVP7002_MAX_NO_STANDARDS		8
++#define TVP7002_MAX_NO_CONTROLS			0
++
++#define TVP7002_ALC_VCOEFF_SHIFT		4
++
++#define TVP7002_STANDARD_INFO_SIZE      (TVP7002_MAX_NO_STANDARDS)
++
++/* Number of pixels and number of lines per frame for different standards */
++#define NTSC_NUM_ACTIVE_PIXELS          (720)
++#define NTSC_NUM_ACTIVE_LINES           (480)
++#define PAL_NUM_ACTIVE_PIXELS           (720)
++#define PAL_NUM_ACTIVE_LINES            (576)
++#define HD_720_NUM_ACTIVE_PIXELS        (1280)
++#define HD_720_NUM_ACTIVE_LINES         (720)
++#define HD_1080_NUM_ACTIVE_PIXELS       (1920)
++#define HD_1080_NUM_ACTIVE_LINES        (1080)
++
++/* Platform dependent data */
++struct tvp7002_platform_data {
++	bool clk_polarity;
++	bool hs_polarity;
++	bool vs_polarity;
++	bool fid_polarity;
++};
++
++struct tvp7002_control_info {
++	int register_address;
++	struct v4l2_queryctrl query_control;
++};
++
++struct tvp7002_config {
++	int no_of_inputs;
++	struct {
++		int input_type;
++		struct v4l2_input input_info;
++		int no_of_standard;
++		struct v4l2_standard *standard;
++		v4l2_std_id def_std;
++		struct tvp7002_format_params *format;
++		int no_of_controls;
++		struct tvp7002_control_info *controls;
++	} input[TVP7002_MAX_NO_INPUTS];
++	struct tvp7002_params def_params;
++};
++
++struct tvp7002_channel {
++	struct {
++		struct i2c_client client;
++		struct i2c_driver driver;
++		u32 i2c_addr;
++		int i2c_registration;
++	} i2c_dev;
++	struct decoder_device *dec_device;
++	struct tvp7002_params params;
++};
++
++#endif				/* __KERNEL__ */
++#endif
+--- a/drivers/input/keyboard/Makefile
++++ b/drivers/input/keyboard/Makefile
+@@ -37,3 +37,4 @@ obj-$(CONFIG_KEYBOARD_TOSA)		+= tosakbd.
+ obj-$(CONFIG_KEYBOARD_TWL4030)		+= twl4030_keypad.o
+ obj-$(CONFIG_KEYBOARD_XTKBD)		+= xtkbd.o
+ obj-$(CONFIG_KEYBOARD_W90P910)		+= w90p910_keypad.o
++obj-$(CONFIG_KEYBOARD_DAVINCI)		+= davinci_keyscan.o
+--- a/drivers/input/misc/Kconfig
++++ b/drivers/input/misc/Kconfig
+@@ -288,6 +288,15 @@ config INPUT_DM355EVM
+ 	  To compile this driver as a module, choose M here: the
+ 	  module will be called dm355evm_keys.
+ 
++config INPUT_DM365EVM
++	tristate "TI DaVinci DM365 EVM IR Remote"
++	depends on MACH_DAVINCI_DM365_EVM
++	help
++	  Supports the IR remote used with the DM365 EVM board.
++
++	  To compile this driver as a module, choose M here: the
++	  module will be called dm365evm_keys.
++
+ config INPUT_BFIN_ROTARY
+ 	tristate "Blackfin Rotary support"
+ 	depends on BF54x || BF52x
+--- /dev/null
++++ b/arch/arm/configs/da8xx_omapl_defconfig
+@@ -0,0 +1,1261 @@
++#
++# Automatically generated make config: don't edit
++# Linux kernel version: 2.6.32-rc2-davinci1
++# Mon Sep 28 16:00:25 2009
++#
++CONFIG_ARM=y
++CONFIG_SYS_SUPPORTS_APM_EMULATION=y
++CONFIG_GENERIC_GPIO=y
++CONFIG_GENERIC_TIME=y
++CONFIG_GENERIC_CLOCKEVENTS=y
++CONFIG_GENERIC_HARDIRQS=y
++CONFIG_STACKTRACE_SUPPORT=y
++CONFIG_HAVE_LATENCYTOP_SUPPORT=y
++CONFIG_LOCKDEP_SUPPORT=y
++CONFIG_TRACE_IRQFLAGS_SUPPORT=y
++CONFIG_HARDIRQS_SW_RESEND=y
++CONFIG_GENERIC_IRQ_PROBE=y
++CONFIG_RWSEM_GENERIC_SPINLOCK=y
++CONFIG_GENERIC_HWEIGHT=y
++CONFIG_GENERIC_CALIBRATE_DELAY=y
++CONFIG_ZONE_DMA=y
++CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
++CONFIG_VECTORS_BASE=0xffff0000
++CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
++CONFIG_CONSTRUCTORS=y
++
++#
++# General setup
++#
++CONFIG_EXPERIMENTAL=y
++CONFIG_BROKEN_ON_SMP=y
++CONFIG_LOCK_KERNEL=y
++CONFIG_INIT_ENV_ARG_LIMIT=32
++CONFIG_LOCALVERSION=""
++CONFIG_LOCALVERSION_AUTO=y
++# CONFIG_SWAP is not set
++CONFIG_SYSVIPC=y
++CONFIG_SYSVIPC_SYSCTL=y
++CONFIG_POSIX_MQUEUE=y
++CONFIG_POSIX_MQUEUE_SYSCTL=y
++# CONFIG_BSD_PROCESS_ACCT is not set
++# CONFIG_TASKSTATS is not set
++# CONFIG_AUDIT is not set
++
++#
++# RCU Subsystem
++#
++CONFIG_TREE_RCU=y
++# CONFIG_TREE_PREEMPT_RCU is not set
++# CONFIG_RCU_TRACE is not set
++CONFIG_RCU_FANOUT=32
++# CONFIG_RCU_FANOUT_EXACT is not set
++# CONFIG_TREE_RCU_TRACE is not set
++CONFIG_IKCONFIG=y
++CONFIG_IKCONFIG_PROC=y
++CONFIG_LOG_BUF_SHIFT=14
++CONFIG_GROUP_SCHED=y
++CONFIG_FAIR_GROUP_SCHED=y
++# CONFIG_RT_GROUP_SCHED is not set
++CONFIG_USER_SCHED=y
++# CONFIG_CGROUP_SCHED is not set
++# CONFIG_CGROUPS is not set
++# CONFIG_SYSFS_DEPRECATED_V2 is not set
++# CONFIG_RELAY is not set
++# CONFIG_NAMESPACES is not set
++CONFIG_BLK_DEV_INITRD=y
++CONFIG_INITRAMFS_SOURCE=""
++CONFIG_RD_GZIP=y
++# CONFIG_RD_BZIP2 is not set
++# CONFIG_RD_LZMA is not set
++CONFIG_CC_OPTIMIZE_FOR_SIZE=y
++CONFIG_SYSCTL=y
++CONFIG_ANON_INODES=y
++CONFIG_EMBEDDED=y
++CONFIG_UID16=y
++CONFIG_SYSCTL_SYSCALL=y
++CONFIG_KALLSYMS=y
++# CONFIG_KALLSYMS_ALL is not set
++# CONFIG_KALLSYMS_EXTRA_PASS is not set
++CONFIG_HOTPLUG=y
++CONFIG_PRINTK=y
++CONFIG_BUG=y
++CONFIG_ELF_CORE=y
++CONFIG_BASE_FULL=y
++CONFIG_FUTEX=y
++CONFIG_EPOLL=y
++CONFIG_SIGNALFD=y
++CONFIG_TIMERFD=y
++CONFIG_EVENTFD=y
++CONFIG_SHMEM=y
++CONFIG_AIO=y
++
++#
++# Kernel Performance Events And Counters
++#
++CONFIG_VM_EVENT_COUNTERS=y
++CONFIG_SLUB_DEBUG=y
++CONFIG_COMPAT_BRK=y
++# CONFIG_SLAB is not set
++CONFIG_SLUB=y
++# CONFIG_SLOB is not set
++# CONFIG_PROFILING is not set
++CONFIG_HAVE_OPROFILE=y
++# CONFIG_KPROBES is not set
++CONFIG_HAVE_KPROBES=y
++CONFIG_HAVE_KRETPROBES=y
++CONFIG_HAVE_CLK=y
++
++#
++# GCOV-based kernel profiling
++#
++# CONFIG_GCOV_KERNEL is not set
++# CONFIG_SLOW_WORK is not set
++CONFIG_HAVE_GENERIC_DMA_COHERENT=y
++CONFIG_SLABINFO=y
++CONFIG_RT_MUTEXES=y
++CONFIG_BASE_SMALL=0
++CONFIG_MODULES=y
++# CONFIG_MODULE_FORCE_LOAD is not set
++CONFIG_MODULE_UNLOAD=y
++CONFIG_MODULE_FORCE_UNLOAD=y
++CONFIG_MODVERSIONS=y
++# CONFIG_MODULE_SRCVERSION_ALL is not set
++CONFIG_BLOCK=y
++CONFIG_LBDAF=y
++# CONFIG_BLK_DEV_BSG is not set
++# CONFIG_BLK_DEV_INTEGRITY is not set
++
++#
++# IO Schedulers
++#
++CONFIG_IOSCHED_NOOP=y
++CONFIG_IOSCHED_AS=y
++# CONFIG_IOSCHED_DEADLINE is not set
++# CONFIG_IOSCHED_CFQ is not set
++CONFIG_DEFAULT_AS=y
++# CONFIG_DEFAULT_DEADLINE is not set
++# CONFIG_DEFAULT_CFQ is not set
++# CONFIG_DEFAULT_NOOP is not set
++CONFIG_DEFAULT_IOSCHED="anticipatory"
++# CONFIG_FREEZER is not set
++
++#
++# System Type
++#
++CONFIG_MMU=y
++# CONFIG_ARCH_AAEC2000 is not set
++# CONFIG_ARCH_INTEGRATOR is not set
++# CONFIG_ARCH_REALVIEW is not set
++# CONFIG_ARCH_VERSATILE is not set
++# CONFIG_ARCH_AT91 is not set
++# CONFIG_ARCH_CLPS711X is not set
++# CONFIG_ARCH_GEMINI is not set
++# CONFIG_ARCH_EBSA110 is not set
++# CONFIG_ARCH_EP93XX is not set
++# CONFIG_ARCH_FOOTBRIDGE is not set
++# CONFIG_ARCH_MXC is not set
++# CONFIG_ARCH_STMP3XXX is not set
++# CONFIG_ARCH_NETX is not set
++# CONFIG_ARCH_H720X is not set
++# CONFIG_ARCH_NOMADIK is not set
++# CONFIG_ARCH_IOP13XX is not set
++# CONFIG_ARCH_IOP32X is not set
++# CONFIG_ARCH_IOP33X is not set
++# CONFIG_ARCH_IXP23XX is not set
++# CONFIG_ARCH_IXP2000 is not set
++# CONFIG_ARCH_IXP4XX is not set
++# CONFIG_ARCH_L7200 is not set
++# CONFIG_ARCH_KIRKWOOD is not set
++# CONFIG_ARCH_LOKI is not set
++# CONFIG_ARCH_MV78XX0 is not set
++# CONFIG_ARCH_ORION5X is not set
++# CONFIG_ARCH_MMP is not set
++# CONFIG_ARCH_KS8695 is not set
++# CONFIG_ARCH_NS9XXX is not set
++# CONFIG_ARCH_W90X900 is not set
++# CONFIG_ARCH_PNX4008 is not set
++# CONFIG_ARCH_PXA is not set
++# CONFIG_ARCH_MSM is not set
++# CONFIG_ARCH_RPC is not set
++# CONFIG_ARCH_SA1100 is not set
++# CONFIG_ARCH_S3C2410 is not set
++# CONFIG_ARCH_S3C64XX is not set
++# CONFIG_ARCH_S5PC1XX is not set
++# CONFIG_ARCH_SHARK is not set
++# CONFIG_ARCH_LH7A40X is not set
++# CONFIG_ARCH_U300 is not set
++CONFIG_ARCH_DAVINCI=y
++# CONFIG_ARCH_OMAP is not set
++# CONFIG_ARCH_BCMRING is not set
++CONFIG_CP_INTC=y
++
++#
++# TI DaVinci Implementations
++#
++
++#
++# DaVinci Core Type
++#
++# CONFIG_ARCH_DAVINCI_DM644x is not set
++# CONFIG_ARCH_DAVINCI_DM355 is not set
++# CONFIG_ARCH_DAVINCI_DM646x is not set
++CONFIG_ARCH_DAVINCI_DA830=y
++CONFIG_ARCH_DAVINCI_DA850=y
++CONFIG_ARCH_DAVINCI_DA8XX=y
++# CONFIG_ARCH_DAVINCI_DM365 is not set
++
++#
++# DaVinci Board Type
++#
++CONFIG_MACH_DAVINCI_DA830_EVM=y
++# CONFIG_DA830_UI is not set
++CONFIG_MACH_DAVINCI_DA850_EVM=y
++CONFIG_DAVINCI_MUX=y
++# CONFIG_DAVINCI_MUX_DEBUG is not set
++# CONFIG_DAVINCI_MUX_WARNINGS is not set
++CONFIG_DAVINCI_RESET_CLOCKS=y
++
++#
++# Processor Type
++#
++CONFIG_CPU_32=y
++CONFIG_CPU_ARM926T=y
++CONFIG_CPU_32v5=y
++CONFIG_CPU_ABRT_EV5TJ=y
++CONFIG_CPU_PABRT_NOIFAR=y
++CONFIG_CPU_CACHE_VIVT=y
++CONFIG_CPU_COPY_V4WB=y
++CONFIG_CPU_TLB_V4WBI=y
++CONFIG_CPU_CP15=y
++CONFIG_CPU_CP15_MMU=y
++
++#
++# Processor Features
++#
++CONFIG_ARM_THUMB=y
++# CONFIG_CPU_ICACHE_DISABLE is not set
++# CONFIG_CPU_DCACHE_DISABLE is not set
++# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
++# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
++CONFIG_ARM_L1_CACHE_SHIFT=5
++CONFIG_COMMON_CLKDEV=y
++
++#
++# Bus support
++#
++# CONFIG_PCI_SYSCALL is not set
++# CONFIG_ARCH_SUPPORTS_MSI is not set
++# CONFIG_PCCARD is not set
++
++#
++# Kernel Features
++#
++CONFIG_TICK_ONESHOT=y
++CONFIG_NO_HZ=y
++CONFIG_HIGH_RES_TIMERS=y
++CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
++CONFIG_VMSPLIT_3G=y
++# CONFIG_VMSPLIT_2G is not set
++# CONFIG_VMSPLIT_1G is not set
++CONFIG_PAGE_OFFSET=0xC0000000
++# CONFIG_PREEMPT_NONE is not set
++# CONFIG_PREEMPT_VOLUNTARY is not set
++CONFIG_PREEMPT=y
++CONFIG_HZ=100
++CONFIG_AEABI=y
++# CONFIG_OABI_COMPAT is not set
++# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
++# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
++# CONFIG_HIGHMEM is not set
++CONFIG_SELECT_MEMORY_MODEL=y
++CONFIG_FLATMEM_MANUAL=y
++# CONFIG_DISCONTIGMEM_MANUAL is not set
++# CONFIG_SPARSEMEM_MANUAL is not set
++CONFIG_FLATMEM=y
++CONFIG_FLAT_NODE_MEM_MAP=y
++CONFIG_PAGEFLAGS_EXTENDED=y
++CONFIG_SPLIT_PTLOCK_CPUS=4096
++# CONFIG_PHYS_ADDR_T_64BIT is not set
++CONFIG_ZONE_DMA_FLAG=1
++CONFIG_BOUNCE=y
++CONFIG_VIRT_TO_BUS=y
++CONFIG_HAVE_MLOCK=y
++CONFIG_HAVE_MLOCKED_PAGE_BIT=y
++# CONFIG_KSM is not set
++CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
++CONFIG_LEDS=y
++# CONFIG_LEDS_CPU is not set
++CONFIG_ALIGNMENT_TRAP=y
++# CONFIG_UACCESS_WITH_MEMCPY is not set
++
++#
++# Boot options
++#
++CONFIG_ZBOOT_ROM_TEXT=0x0
++CONFIG_ZBOOT_ROM_BSS=0x0
++CONFIG_CMDLINE=""
++# CONFIG_XIP_KERNEL is not set
++# CONFIG_KEXEC is not set
++
++#
++# CPU Power Management
++#
++# CONFIG_CPU_IDLE is not set
++
++#
++# Floating point emulation
++#
++
++#
++# At least one emulation must be selected
++#
++# CONFIG_VFP is not set
++
++#
++# Userspace binary formats
++#
++CONFIG_BINFMT_ELF=y
++# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
++CONFIG_HAVE_AOUT=y
++# CONFIG_BINFMT_AOUT is not set
++# CONFIG_BINFMT_MISC is not set
++
++#
++# Power management options
++#
++# CONFIG_PM is not set
++CONFIG_ARCH_SUSPEND_POSSIBLE=y
++CONFIG_NET=y
++
++#
++# Networking options
++#
++CONFIG_PACKET=y
++# CONFIG_PACKET_MMAP is not set
++CONFIG_UNIX=y
++CONFIG_XFRM=y
++# CONFIG_XFRM_USER is not set
++# CONFIG_XFRM_SUB_POLICY is not set
++# CONFIG_XFRM_MIGRATE is not set
++# CONFIG_XFRM_STATISTICS is not set
++# CONFIG_NET_KEY is not set
++CONFIG_INET=y
++# CONFIG_IP_MULTICAST is not set
++# CONFIG_IP_ADVANCED_ROUTER is not set
++CONFIG_IP_FIB_HASH=y
++CONFIG_IP_PNP=y
++CONFIG_IP_PNP_DHCP=y
++# CONFIG_IP_PNP_BOOTP is not set
++# CONFIG_IP_PNP_RARP is not set
++# CONFIG_NET_IPIP is not set
++# CONFIG_NET_IPGRE is not set
++# CONFIG_ARPD is not set
++# CONFIG_SYN_COOKIES is not set
++# CONFIG_INET_AH is not set
++# CONFIG_INET_ESP is not set
++# CONFIG_INET_IPCOMP is not set
++# CONFIG_INET_XFRM_TUNNEL is not set
++CONFIG_INET_TUNNEL=m
++CONFIG_INET_XFRM_MODE_TRANSPORT=y
++CONFIG_INET_XFRM_MODE_TUNNEL=y
++CONFIG_INET_XFRM_MODE_BEET=y
++# CONFIG_INET_LRO is not set
++CONFIG_INET_DIAG=y
++CONFIG_INET_TCP_DIAG=y
++# CONFIG_TCP_CONG_ADVANCED is not set
++CONFIG_TCP_CONG_CUBIC=y
++CONFIG_DEFAULT_TCP_CONG="cubic"
++# CONFIG_TCP_MD5SIG is not set
++CONFIG_IPV6=m
++# CONFIG_IPV6_PRIVACY is not set
++# CONFIG_IPV6_ROUTER_PREF is not set
++# CONFIG_IPV6_OPTIMISTIC_DAD is not set
++# CONFIG_INET6_AH is not set
++# CONFIG_INET6_ESP is not set
++# CONFIG_INET6_IPCOMP is not set
++# CONFIG_IPV6_MIP6 is not set
++# CONFIG_INET6_XFRM_TUNNEL is not set
++# CONFIG_INET6_TUNNEL is not set
++CONFIG_INET6_XFRM_MODE_TRANSPORT=m
++CONFIG_INET6_XFRM_MODE_TUNNEL=m
++CONFIG_INET6_XFRM_MODE_BEET=m
++# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
++CONFIG_IPV6_SIT=m
++CONFIG_IPV6_NDISC_NODETYPE=y
++# CONFIG_IPV6_TUNNEL is not set
++# CONFIG_IPV6_MULTIPLE_TABLES is not set
++# CONFIG_IPV6_MROUTE is not set
++# CONFIG_NETWORK_SECMARK is not set
++CONFIG_NETFILTER=y
++# CONFIG_NETFILTER_DEBUG is not set
++CONFIG_NETFILTER_ADVANCED=y
++
++#
++# Core Netfilter Configuration
++#
++# CONFIG_NETFILTER_NETLINK_QUEUE is not set
++# CONFIG_NETFILTER_NETLINK_LOG is not set
++# CONFIG_NF_CONNTRACK is not set
++# CONFIG_NETFILTER_XTABLES is not set
++# CONFIG_IP_VS is not set
++
++#
++# IP: Netfilter Configuration
++#
++# CONFIG_NF_DEFRAG_IPV4 is not set
++# CONFIG_IP_NF_QUEUE is not set
++# CONFIG_IP_NF_IPTABLES is not set
++# CONFIG_IP_NF_ARPTABLES is not set
++
++#
++# IPv6: Netfilter Configuration
++#
++# CONFIG_IP6_NF_QUEUE is not set
++# CONFIG_IP6_NF_IPTABLES is not set
++# CONFIG_IP_DCCP is not set
++# CONFIG_IP_SCTP is not set
++# CONFIG_RDS is not set
++# CONFIG_TIPC is not set
++# CONFIG_ATM is not set
++# CONFIG_BRIDGE is not set
++# CONFIG_NET_DSA is not set
++# CONFIG_VLAN_8021Q is not set
++# CONFIG_DECNET is not set
++# CONFIG_LLC2 is not set
++# CONFIG_IPX is not set
++# CONFIG_ATALK is not set
++# CONFIG_X25 is not set
++# CONFIG_LAPB is not set
++# CONFIG_ECONET is not set
++# CONFIG_WAN_ROUTER is not set
++# CONFIG_PHONET is not set
++# CONFIG_IEEE802154 is not set
++# CONFIG_NET_SCHED is not set
++# CONFIG_DCB is not set
++
++#
++# Network testing
++#
++# CONFIG_NET_PKTGEN is not set
++# CONFIG_HAMRADIO is not set
++# CONFIG_CAN is not set
++# CONFIG_IRDA is not set
++# CONFIG_BT is not set
++# CONFIG_AF_RXRPC is not set
++# CONFIG_WIRELESS is not set
++# CONFIG_WIMAX is not set
++# CONFIG_RFKILL is not set
++# CONFIG_NET_9P is not set
++
++#
++# Device Drivers
++#
++
++#
++# Generic Driver Options
++#
++CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
++# CONFIG_DEVTMPFS is not set
++CONFIG_STANDALONE=y
++CONFIG_PREVENT_FIRMWARE_BUILD=y
++# CONFIG_FW_LOADER is not set
++# CONFIG_DEBUG_DRIVER is not set
++# CONFIG_DEBUG_DEVRES is not set
++# CONFIG_SYS_HYPERVISOR is not set
++# CONFIG_CONNECTOR is not set
++# CONFIG_MTD is not set
++# CONFIG_PARPORT is not set
++CONFIG_BLK_DEV=y
++# CONFIG_BLK_DEV_COW_COMMON is not set
++CONFIG_BLK_DEV_LOOP=m
++# CONFIG_BLK_DEV_CRYPTOLOOP is not set
++# CONFIG_BLK_DEV_NBD is not set
++CONFIG_BLK_DEV_RAM=y
++CONFIG_BLK_DEV_RAM_COUNT=1
++CONFIG_BLK_DEV_RAM_SIZE=32768
++# CONFIG_BLK_DEV_XIP is not set
++# CONFIG_CDROM_PKTCDVD is not set
++# CONFIG_ATA_OVER_ETH is not set
++# CONFIG_MG_DISK is not set
++CONFIG_MISC_DEVICES=y
++# CONFIG_ICS932S401 is not set
++# CONFIG_ENCLOSURE_SERVICES is not set
++# CONFIG_ISL29003 is not set
++# CONFIG_C2PORT is not set
++
++#
++# EEPROM support
++#
++CONFIG_EEPROM_AT24=y
++# CONFIG_EEPROM_LEGACY is not set
++# CONFIG_EEPROM_MAX6875 is not set
++# CONFIG_EEPROM_93CX6 is not set
++CONFIG_HAVE_IDE=y
++# CONFIG_IDE is not set
++
++#
++# SCSI device support
++#
++# CONFIG_RAID_ATTRS is not set
++CONFIG_SCSI=m
++CONFIG_SCSI_DMA=y
++# CONFIG_SCSI_TGT is not set
++# CONFIG_SCSI_NETLINK is not set
++CONFIG_SCSI_PROC_FS=y
++
++#
++# SCSI support type (disk, tape, CD-ROM)
++#
++CONFIG_BLK_DEV_SD=m
++# CONFIG_CHR_DEV_ST is not set
++# CONFIG_CHR_DEV_OSST is not set
++# CONFIG_BLK_DEV_SR is not set
++# CONFIG_CHR_DEV_SG is not set
++# CONFIG_CHR_DEV_SCH is not set
++# CONFIG_SCSI_MULTI_LUN is not set
++# CONFIG_SCSI_CONSTANTS is not set
++# CONFIG_SCSI_LOGGING is not set
++# CONFIG_SCSI_SCAN_ASYNC is not set
++CONFIG_SCSI_WAIT_SCAN=m
++
++#
++# SCSI Transports
++#
++# CONFIG_SCSI_SPI_ATTRS is not set
++# CONFIG_SCSI_FC_ATTRS is not set
++# CONFIG_SCSI_ISCSI_ATTRS is not set
++# CONFIG_SCSI_SAS_LIBSAS is not set
++# CONFIG_SCSI_SRP_ATTRS is not set
++CONFIG_SCSI_LOWLEVEL=y
++# CONFIG_ISCSI_TCP is not set
++# CONFIG_LIBFC is not set
++# CONFIG_LIBFCOE is not set
++# CONFIG_SCSI_DEBUG is not set
++# CONFIG_SCSI_DH is not set
++# CONFIG_SCSI_OSD_INITIATOR is not set
++# CONFIG_ATA is not set
++# CONFIG_MD is not set
++CONFIG_NETDEVICES=y
++# CONFIG_DUMMY is not set
++# CONFIG_BONDING is not set
++# CONFIG_MACVLAN is not set
++# CONFIG_EQUALIZER is not set
++CONFIG_TUN=m
++# CONFIG_VETH is not set
++CONFIG_PHYLIB=y
++
++#
++# MII PHY device drivers
++#
++# CONFIG_MARVELL_PHY is not set
++# CONFIG_DAVICOM_PHY is not set
++# CONFIG_QSEMI_PHY is not set
++CONFIG_LXT_PHY=y
++# CONFIG_CICADA_PHY is not set
++# CONFIG_VITESSE_PHY is not set
++# CONFIG_SMSC_PHY is not set
++# CONFIG_BROADCOM_PHY is not set
++# CONFIG_ICPLUS_PHY is not set
++# CONFIG_REALTEK_PHY is not set
++# CONFIG_NATIONAL_PHY is not set
++# CONFIG_STE10XP is not set
++CONFIG_LSI_ET1011C_PHY=y
++# CONFIG_FIXED_PHY is not set
++# CONFIG_MDIO_BITBANG is not set
++CONFIG_NET_ETHERNET=y
++CONFIG_MII=y
++# CONFIG_AX88796 is not set
++# CONFIG_SMC91X is not set
++CONFIG_TI_DAVINCI_EMAC=y
++# CONFIG_DM9000 is not set
++# CONFIG_ETHOC is not set
++# CONFIG_SMC911X is not set
++# CONFIG_SMSC911X is not set
++# CONFIG_DNET is not set
++# CONFIG_IBM_NEW_EMAC_ZMII is not set
++# CONFIG_IBM_NEW_EMAC_RGMII is not set
++# CONFIG_IBM_NEW_EMAC_TAH is not set
++# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
++# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
++# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
++# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
++# CONFIG_B44 is not set
++# CONFIG_KS8842 is not set
++# CONFIG_NETDEV_1000 is not set
++# CONFIG_NETDEV_10000 is not set
++CONFIG_WLAN=y
++# CONFIG_WLAN_PRE80211 is not set
++# CONFIG_WLAN_80211 is not set
++
++#
++# Enable WiMAX (Networking options) to see the WiMAX drivers
++#
++# CONFIG_WAN is not set
++# CONFIG_PPP is not set
++# CONFIG_SLIP is not set
++CONFIG_NETCONSOLE=y
++# CONFIG_NETCONSOLE_DYNAMIC is not set
++CONFIG_NETPOLL=y
++CONFIG_NETPOLL_TRAP=y
++CONFIG_NET_POLL_CONTROLLER=y
++# CONFIG_ISDN is not set
++# CONFIG_PHONE is not set
++
++#
++# Input device support
++#
++CONFIG_INPUT=y
++# CONFIG_INPUT_FF_MEMLESS is not set
++# CONFIG_INPUT_POLLDEV is not set
++
++#
++# Userland interfaces
++#
++CONFIG_INPUT_MOUSEDEV=m
++CONFIG_INPUT_MOUSEDEV_PSAUX=y
++CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
++CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
++# CONFIG_INPUT_JOYDEV is not set
++CONFIG_INPUT_EVDEV=m
++CONFIG_INPUT_EVBUG=m
++
++#
++# Input Device Drivers
++#
++CONFIG_INPUT_KEYBOARD=y
++# CONFIG_KEYBOARD_ADP5588 is not set
++CONFIG_KEYBOARD_ATKBD=m
++# CONFIG_QT2160 is not set
++# CONFIG_KEYBOARD_LKKBD is not set
++CONFIG_KEYBOARD_GPIO=y
++# CONFIG_KEYBOARD_MATRIX is not set
++# CONFIG_KEYBOARD_MAX7359 is not set
++# CONFIG_KEYBOARD_NEWTON is not set
++# CONFIG_KEYBOARD_OPENCORES is not set
++# CONFIG_KEYBOARD_STOWAWAY is not set
++# CONFIG_KEYBOARD_SUNKBD is not set
++CONFIG_KEYBOARD_XTKBD=m
++# CONFIG_INPUT_MOUSE is not set
++# CONFIG_INPUT_JOYSTICK is not set
++# CONFIG_INPUT_TABLET is not set
++CONFIG_INPUT_TOUCHSCREEN=y
++# CONFIG_TOUCHSCREEN_AD7879_I2C is not set
++# CONFIG_TOUCHSCREEN_AD7879 is not set
++# CONFIG_TOUCHSCREEN_EETI is not set
++# CONFIG_TOUCHSCREEN_FUJITSU is not set
++# CONFIG_TOUCHSCREEN_GUNZE is not set
++# CONFIG_TOUCHSCREEN_ELO is not set
++# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
++# CONFIG_TOUCHSCREEN_MCS5000 is not set
++# CONFIG_TOUCHSCREEN_MTOUCH is not set
++# CONFIG_TOUCHSCREEN_INEXIO is not set
++# CONFIG_TOUCHSCREEN_MK712 is not set
++# CONFIG_TOUCHSCREEN_PENMOUNT is not set
++# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
++# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
++# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
++# CONFIG_TOUCHSCREEN_TSC2007 is not set
++# CONFIG_TOUCHSCREEN_W90X900 is not set
++# CONFIG_INPUT_MISC is not set
++
++#
++# Hardware I/O ports
++#
++CONFIG_SERIO=y
++CONFIG_SERIO_SERPORT=y
++CONFIG_SERIO_LIBPS2=y
++# CONFIG_SERIO_RAW is not set
++# CONFIG_GAMEPORT is not set
++
++#
++# Character devices
++#
++CONFIG_VT=y
++CONFIG_CONSOLE_TRANSLATIONS=y
++# CONFIG_VT_CONSOLE is not set
++CONFIG_HW_CONSOLE=y
++# CONFIG_VT_HW_CONSOLE_BINDING is not set
++CONFIG_DEVKMEM=y
++# CONFIG_SERIAL_NONSTANDARD is not set
++
++#
++# Serial drivers
++#
++CONFIG_SERIAL_8250=y
++CONFIG_SERIAL_8250_CONSOLE=y
++CONFIG_SERIAL_8250_NR_UARTS=3
++CONFIG_SERIAL_8250_RUNTIME_UARTS=3
++# CONFIG_SERIAL_8250_EXTENDED is not set
++
++#
++# Non-8250 serial port support
++#
++CONFIG_SERIAL_CORE=y
++CONFIG_SERIAL_CORE_CONSOLE=y
++CONFIG_UNIX98_PTYS=y
++# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
++CONFIG_LEGACY_PTYS=y
++CONFIG_LEGACY_PTY_COUNT=256
++# CONFIG_IPMI_HANDLER is not set
++CONFIG_HW_RANDOM=m
++# CONFIG_HW_RANDOM_TIMERIOMEM is not set
++# CONFIG_R3964 is not set
++# CONFIG_RAW_DRIVER is not set
++# CONFIG_TCG_TPM is not set
++CONFIG_I2C=y
++CONFIG_I2C_BOARDINFO=y
++CONFIG_I2C_COMPAT=y
++CONFIG_I2C_CHARDEV=y
++CONFIG_I2C_HELPER_AUTO=y
++
++#
++# I2C Hardware Bus support
++#
++
++#
++# I2C system bus drivers (mostly embedded / system-on-chip)
++#
++CONFIG_I2C_DAVINCI=y
++# CONFIG_I2C_DESIGNWARE is not set
++# CONFIG_I2C_GPIO is not set
++# CONFIG_I2C_OCORES is not set
++# CONFIG_I2C_SIMTEC is not set
++
++#
++# External I2C/SMBus adapter drivers
++#
++# CONFIG_I2C_PARPORT_LIGHT is not set
++# CONFIG_I2C_TAOS_EVM is not set
++
++#
++# Other I2C/SMBus bus drivers
++#
++# CONFIG_I2C_PCA_PLATFORM is not set
++# CONFIG_I2C_STUB is not set
++
++#
++# Miscellaneous I2C Chip support
++#
++# CONFIG_DS1682 is not set
++# CONFIG_SENSORS_TSL2550 is not set
++# CONFIG_I2C_DEBUG_CORE is not set
++# CONFIG_I2C_DEBUG_ALGO is not set
++# CONFIG_I2C_DEBUG_BUS is not set
++# CONFIG_I2C_DEBUG_CHIP is not set
++# CONFIG_SPI is not set
++
++#
++# PPS support
++#
++# CONFIG_PPS is not set
++CONFIG_ARCH_REQUIRE_GPIOLIB=y
++CONFIG_GPIOLIB=y
++# CONFIG_DEBUG_GPIO is not set
++# CONFIG_GPIO_SYSFS is not set
++
++#
++# Memory mapped GPIO expanders:
++#
++
++#
++# I2C GPIO expanders:
++#
++# CONFIG_GPIO_MAX732X is not set
++# CONFIG_GPIO_PCA953X is not set
++CONFIG_GPIO_PCF857X=m
++
++#
++# PCI GPIO expanders:
++#
++
++#
++# SPI GPIO expanders:
++#
++
++#
++# AC97 GPIO expanders:
++#
++# CONFIG_W1 is not set
++# CONFIG_POWER_SUPPLY is not set
++# CONFIG_HWMON is not set
++# CONFIG_THERMAL is not set
++CONFIG_WATCHDOG=y
++# CONFIG_WATCHDOG_NOWAYOUT is not set
++
++#
++# Watchdog Device Drivers
++#
++# CONFIG_SOFT_WATCHDOG is not set
++# CONFIG_DAVINCI_WATCHDOG is not set
++CONFIG_SSB_POSSIBLE=y
++
++#
++# Sonics Silicon Backplane
++#
++# CONFIG_SSB is not set
++
++#
++# Multifunction device drivers
++#
++# CONFIG_MFD_CORE is not set
++# CONFIG_MFD_SM501 is not set
++# CONFIG_MFD_ASIC3 is not set
++# CONFIG_HTC_EGPIO is not set
++# CONFIG_HTC_PASIC3 is not set
++# CONFIG_TPS65010 is not set
++# CONFIG_TWL4030_CORE is not set
++# CONFIG_MFD_TMIO is not set
++# CONFIG_MFD_T7L66XB is not set
++# CONFIG_MFD_TC6387XB is not set
++# CONFIG_MFD_TC6393XB is not set
++# CONFIG_PMIC_DA903X is not set
++# CONFIG_MFD_WM8400 is not set
++# CONFIG_MFD_WM831X is not set
++# CONFIG_MFD_WM8350_I2C is not set
++# CONFIG_MFD_PCF50633 is not set
++# CONFIG_AB3100_CORE is not set
++# CONFIG_REGULATOR is not set
++# CONFIG_MEDIA_SUPPORT is not set
++
++#
++# Graphics support
++#
++# CONFIG_VGASTATE is not set
++# CONFIG_VIDEO_OUTPUT_CONTROL is not set
++# CONFIG_FB is not set
++# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
++
++#
++# Display device support
++#
++# CONFIG_DISPLAY_SUPPORT is not set
++
++#
++# Console display driver support
++#
++# CONFIG_VGA_CONSOLE is not set
++CONFIG_DUMMY_CONSOLE=y
++CONFIG_SOUND=m
++# CONFIG_SOUND_OSS_CORE is not set
++CONFIG_SND=m
++CONFIG_SND_TIMER=m
++CONFIG_SND_PCM=m
++CONFIG_SND_JACK=y
++# CONFIG_SND_SEQUENCER is not set
++# CONFIG_SND_MIXER_OSS is not set
++# CONFIG_SND_PCM_OSS is not set
++# CONFIG_SND_HRTIMER is not set
++# CONFIG_SND_DYNAMIC_MINORS is not set
++CONFIG_SND_SUPPORT_OLD_API=y
++CONFIG_SND_VERBOSE_PROCFS=y
++# CONFIG_SND_VERBOSE_PRINTK is not set
++# CONFIG_SND_DEBUG is not set
++# CONFIG_SND_RAWMIDI_SEQ is not set
++# CONFIG_SND_OPL3_LIB_SEQ is not set
++# CONFIG_SND_OPL4_LIB_SEQ is not set
++# CONFIG_SND_SBAWE_SEQ is not set
++# CONFIG_SND_EMU10K1_SEQ is not set
++CONFIG_SND_DRIVERS=y
++# CONFIG_SND_DUMMY is not set
++# CONFIG_SND_MTPAV is not set
++# CONFIG_SND_SERIAL_U16550 is not set
++# CONFIG_SND_MPU401 is not set
++CONFIG_SND_ARM=y
++CONFIG_SND_SOC=m
++CONFIG_SND_DAVINCI_SOC=m
++# CONFIG_SND_DA830_SOC_EVM is not set
++# CONFIG_SND_DA850_SOC_EVM is not set
++CONFIG_SND_SOC_I2C_AND_SPI=m
++# CONFIG_SND_SOC_ALL_CODECS is not set
++# CONFIG_SOUND_PRIME is not set
++# CONFIG_HID_SUPPORT is not set
++# CONFIG_USB_SUPPORT is not set
++# CONFIG_MMC is not set
++# CONFIG_MEMSTICK is not set
++# CONFIG_NEW_LEDS is not set
++# CONFIG_ACCESSIBILITY is not set
++CONFIG_RTC_LIB=y
++# CONFIG_RTC_CLASS is not set
++# CONFIG_DMADEVICES is not set
++# CONFIG_AUXDISPLAY is not set
++# CONFIG_UIO is not set
++
++#
++# TI VLYNQ
++#
++# CONFIG_STAGING is not set
++
++#
++# File systems
++#
++CONFIG_EXT2_FS=y
++# CONFIG_EXT2_FS_XATTR is not set
++# CONFIG_EXT2_FS_XIP is not set
++CONFIG_EXT3_FS=y
++# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
++CONFIG_EXT3_FS_XATTR=y
++# CONFIG_EXT3_FS_POSIX_ACL is not set
++# CONFIG_EXT3_FS_SECURITY is not set
++# CONFIG_EXT4_FS is not set
++CONFIG_JBD=y
++# CONFIG_JBD_DEBUG is not set
++CONFIG_FS_MBCACHE=y
++# CONFIG_REISERFS_FS is not set
++# CONFIG_JFS_FS is not set
++# CONFIG_FS_POSIX_ACL is not set
++CONFIG_XFS_FS=m
++# CONFIG_XFS_QUOTA is not set
++# CONFIG_XFS_POSIX_ACL is not set
++# CONFIG_XFS_RT is not set
++# CONFIG_XFS_DEBUG is not set
++# CONFIG_GFS2_FS is not set
++# CONFIG_OCFS2_FS is not set
++# CONFIG_BTRFS_FS is not set
++# CONFIG_NILFS2_FS is not set
++CONFIG_FILE_LOCKING=y
++CONFIG_FSNOTIFY=y
++CONFIG_DNOTIFY=y
++CONFIG_INOTIFY=y
++CONFIG_INOTIFY_USER=y
++# CONFIG_QUOTA is not set
++# CONFIG_AUTOFS_FS is not set
++CONFIG_AUTOFS4_FS=m
++# CONFIG_FUSE_FS is not set
++
++#
++# Caches
++#
++# CONFIG_FSCACHE is not set
++
++#
++# CD-ROM/DVD Filesystems
++#
++# CONFIG_ISO9660_FS is not set
++# CONFIG_UDF_FS is not set
++
++#
++# DOS/FAT/NT Filesystems
++#
++CONFIG_FAT_FS=y
++CONFIG_MSDOS_FS=y
++CONFIG_VFAT_FS=y
++CONFIG_FAT_DEFAULT_CODEPAGE=437
++CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
++# CONFIG_NTFS_FS is not set
++
++#
++# Pseudo filesystems
++#
++CONFIG_PROC_FS=y
++CONFIG_PROC_SYSCTL=y
++CONFIG_PROC_PAGE_MONITOR=y
++CONFIG_SYSFS=y
++CONFIG_TMPFS=y
++# CONFIG_TMPFS_POSIX_ACL is not set
++# CONFIG_HUGETLB_PAGE is not set
++# CONFIG_CONFIGFS_FS is not set
++CONFIG_MISC_FILESYSTEMS=y
++# CONFIG_ADFS_FS is not set
++# CONFIG_AFFS_FS is not set
++# CONFIG_HFS_FS is not set
++# CONFIG_HFSPLUS_FS is not set
++# CONFIG_BEFS_FS is not set
++# CONFIG_BFS_FS is not set
++# CONFIG_EFS_FS is not set
++CONFIG_CRAMFS=y
++# CONFIG_SQUASHFS is not set
++# CONFIG_VXFS_FS is not set
++CONFIG_MINIX_FS=m
++# CONFIG_OMFS_FS is not set
++# CONFIG_HPFS_FS is not set
++# CONFIG_QNX4FS_FS is not set
++# CONFIG_ROMFS_FS is not set
++# CONFIG_SYSV_FS is not set
++# CONFIG_UFS_FS is not set
++CONFIG_NETWORK_FILESYSTEMS=y
++CONFIG_NFS_FS=y
++CONFIG_NFS_V3=y
++# CONFIG_NFS_V3_ACL is not set
++# CONFIG_NFS_V4 is not set
++CONFIG_ROOT_NFS=y
++CONFIG_NFSD=m
++CONFIG_NFSD_V3=y
++# CONFIG_NFSD_V3_ACL is not set
++# CONFIG_NFSD_V4 is not set
++CONFIG_LOCKD=y
++CONFIG_LOCKD_V4=y
++CONFIG_EXPORTFS=m
++CONFIG_NFS_COMMON=y
++CONFIG_SUNRPC=y
++# CONFIG_RPCSEC_GSS_KRB5 is not set
++# CONFIG_RPCSEC_GSS_SPKM3 is not set
++CONFIG_SMB_FS=m
++# CONFIG_SMB_NLS_DEFAULT is not set
++# CONFIG_CIFS is not set
++# CONFIG_NCP_FS is not set
++# CONFIG_CODA_FS is not set
++# CONFIG_AFS_FS is not set
++
++#
++# Partition Types
++#
++CONFIG_PARTITION_ADVANCED=y
++# CONFIG_ACORN_PARTITION is not set
++# CONFIG_OSF_PARTITION is not set
++# CONFIG_AMIGA_PARTITION is not set
++# CONFIG_ATARI_PARTITION is not set
++# CONFIG_MAC_PARTITION is not set
++CONFIG_MSDOS_PARTITION=y
++# CONFIG_BSD_DISKLABEL is not set
++# CONFIG_MINIX_SUBPARTITION is not set
++# CONFIG_SOLARIS_X86_PARTITION is not set
++# CONFIG_UNIXWARE_DISKLABEL is not set
++# CONFIG_LDM_PARTITION is not set
++# CONFIG_SGI_PARTITION is not set
++# CONFIG_ULTRIX_PARTITION is not set
++# CONFIG_SUN_PARTITION is not set
++# CONFIG_KARMA_PARTITION is not set
++# CONFIG_EFI_PARTITION is not set
++# CONFIG_SYSV68_PARTITION is not set
++CONFIG_NLS=y
++CONFIG_NLS_DEFAULT="iso8859-1"
++CONFIG_NLS_CODEPAGE_437=y
++# CONFIG_NLS_CODEPAGE_737 is not set
++# CONFIG_NLS_CODEPAGE_775 is not set
++# CONFIG_NLS_CODEPAGE_850 is not set
++# CONFIG_NLS_CODEPAGE_852 is not set
++# CONFIG_NLS_CODEPAGE_855 is not set
++# CONFIG_NLS_CODEPAGE_857 is not set
++# CONFIG_NLS_CODEPAGE_860 is not set
++# CONFIG_NLS_CODEPAGE_861 is not set
++# CONFIG_NLS_CODEPAGE_862 is not set
++# CONFIG_NLS_CODEPAGE_863 is not set
++# CONFIG_NLS_CODEPAGE_864 is not set
++# CONFIG_NLS_CODEPAGE_865 is not set
++# CONFIG_NLS_CODEPAGE_866 is not set
++# CONFIG_NLS_CODEPAGE_869 is not set
++# CONFIG_NLS_CODEPAGE_936 is not set
++# CONFIG_NLS_CODEPAGE_950 is not set
++# CONFIG_NLS_CODEPAGE_932 is not set
++# CONFIG_NLS_CODEPAGE_949 is not set
++# CONFIG_NLS_CODEPAGE_874 is not set
++# CONFIG_NLS_ISO8859_8 is not set
++# CONFIG_NLS_CODEPAGE_1250 is not set
++# CONFIG_NLS_CODEPAGE_1251 is not set
++CONFIG_NLS_ASCII=m
++CONFIG_NLS_ISO8859_1=y
++# CONFIG_NLS_ISO8859_2 is not set
++# CONFIG_NLS_ISO8859_3 is not set
++# CONFIG_NLS_ISO8859_4 is not set
++# CONFIG_NLS_ISO8859_5 is not set
++# CONFIG_NLS_ISO8859_6 is not set
++# CONFIG_NLS_ISO8859_7 is not set
++# CONFIG_NLS_ISO8859_9 is not set
++# CONFIG_NLS_ISO8859_13 is not set
++# CONFIG_NLS_ISO8859_14 is not set
++# CONFIG_NLS_ISO8859_15 is not set
++# CONFIG_NLS_KOI8_R is not set
++# CONFIG_NLS_KOI8_U is not set
++CONFIG_NLS_UTF8=m
++# CONFIG_DLM is not set
++
++#
++# Kernel hacking
++#
++# CONFIG_PRINTK_TIME is not set
++CONFIG_ENABLE_WARN_DEPRECATED=y
++CONFIG_ENABLE_MUST_CHECK=y
++CONFIG_FRAME_WARN=1024
++# CONFIG_MAGIC_SYSRQ is not set
++# CONFIG_STRIP_ASM_SYMS is not set
++# CONFIG_UNUSED_SYMBOLS is not set
++CONFIG_DEBUG_FS=y
++# CONFIG_HEADERS_CHECK is not set
++CONFIG_DEBUG_KERNEL=y
++# CONFIG_DEBUG_SHIRQ is not set
++CONFIG_DETECT_SOFTLOCKUP=y
++# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
++CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
++CONFIG_DETECT_HUNG_TASK=y
++# CONFIG_BOOTPARAM_HUNG_TASK_PANIC is not set
++CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=0
++CONFIG_SCHED_DEBUG=y
++# CONFIG_SCHEDSTATS is not set
++CONFIG_TIMER_STATS=y
++# CONFIG_DEBUG_OBJECTS is not set
++# CONFIG_SLUB_DEBUG_ON is not set
++# CONFIG_SLUB_STATS is not set
++# CONFIG_DEBUG_KMEMLEAK is not set
++CONFIG_DEBUG_PREEMPT=y
++CONFIG_DEBUG_RT_MUTEXES=y
++CONFIG_DEBUG_PI_LIST=y
++# CONFIG_RT_MUTEX_TESTER is not set
++# CONFIG_DEBUG_SPINLOCK is not set
++CONFIG_DEBUG_MUTEXES=y
++# CONFIG_DEBUG_LOCK_ALLOC is not set
++# CONFIG_PROVE_LOCKING is not set
++# CONFIG_LOCK_STAT is not set
++# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
++# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
++# CONFIG_DEBUG_KOBJECT is not set
++CONFIG_DEBUG_BUGVERBOSE=y
++# CONFIG_DEBUG_INFO is not set
++# CONFIG_DEBUG_VM is not set
++# CONFIG_DEBUG_WRITECOUNT is not set
++# CONFIG_DEBUG_MEMORY_INIT is not set
++# CONFIG_DEBUG_LIST is not set
++# CONFIG_DEBUG_SG is not set
++# CONFIG_DEBUG_NOTIFIERS is not set
++# CONFIG_DEBUG_CREDENTIALS is not set
++# CONFIG_BOOT_PRINTK_DELAY is not set
++# CONFIG_RCU_TORTURE_TEST is not set
++# CONFIG_RCU_CPU_STALL_DETECTOR is not set
++# CONFIG_BACKTRACE_SELF_TEST is not set
++# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
++# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
++# CONFIG_FAULT_INJECTION is not set
++# CONFIG_LATENCYTOP is not set
++# CONFIG_SYSCTL_SYSCALL_CHECK is not set
++# CONFIG_PAGE_POISONING is not set
++CONFIG_HAVE_FUNCTION_TRACER=y
++CONFIG_TRACING_SUPPORT=y
++CONFIG_FTRACE=y
++# CONFIG_FUNCTION_TRACER is not set
++# CONFIG_IRQSOFF_TRACER is not set
++# CONFIG_PREEMPT_TRACER is not set
++# CONFIG_SCHED_TRACER is not set
++# CONFIG_ENABLE_DEFAULT_TRACERS is not set
++# CONFIG_BOOT_TRACER is not set
++CONFIG_BRANCH_PROFILE_NONE=y
++# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
++# CONFIG_PROFILE_ALL_BRANCHES is not set
++# CONFIG_STACK_TRACER is not set
++# CONFIG_KMEMTRACE is not set
++# CONFIG_WORKQUEUE_TRACER is not set
++# CONFIG_BLK_DEV_IO_TRACE is not set
++# CONFIG_DYNAMIC_DEBUG is not set
++# CONFIG_SAMPLES is not set
++CONFIG_HAVE_ARCH_KGDB=y
++# CONFIG_KGDB is not set
++CONFIG_ARM_UNWIND=y
++CONFIG_DEBUG_USER=y
++CONFIG_DEBUG_ERRORS=y
++# CONFIG_DEBUG_STACK_USAGE is not set
++# CONFIG_DEBUG_LL is not set
++
++#
++# Security options
++#
++# CONFIG_KEYS is not set
++# CONFIG_SECURITY is not set
++# CONFIG_SECURITYFS is not set
++# CONFIG_SECURITY_FILE_CAPABILITIES is not set
++CONFIG_CRYPTO=y
++
++#
++# Crypto core or helper
++#
++# CONFIG_CRYPTO_MANAGER is not set
++# CONFIG_CRYPTO_MANAGER2 is not set
++# CONFIG_CRYPTO_GF128MUL is not set
++# CONFIG_CRYPTO_NULL is not set
++# CONFIG_CRYPTO_CRYPTD is not set
++# CONFIG_CRYPTO_AUTHENC is not set
++# CONFIG_CRYPTO_TEST is not set
++
++#
++# Authenticated Encryption with Associated Data
++#
++# CONFIG_CRYPTO_CCM is not set
++# CONFIG_CRYPTO_GCM is not set
++# CONFIG_CRYPTO_SEQIV is not set
++
++#
++# Block modes
++#
++# CONFIG_CRYPTO_CBC is not set
++# CONFIG_CRYPTO_CTR is not set
++# CONFIG_CRYPTO_CTS is not set
++# CONFIG_CRYPTO_ECB is not set
++# CONFIG_CRYPTO_LRW is not set
++# CONFIG_CRYPTO_PCBC is not set
++# CONFIG_CRYPTO_XTS is not set
++
++#
++# Hash modes
++#
++# CONFIG_CRYPTO_HMAC is not set
++# CONFIG_CRYPTO_XCBC is not set
++# CONFIG_CRYPTO_VMAC is not set
++
++#
++# Digest
++#
++# CONFIG_CRYPTO_CRC32C is not set
++# CONFIG_CRYPTO_GHASH is not set
++# CONFIG_CRYPTO_MD4 is not set
++# CONFIG_CRYPTO_MD5 is not set
++# CONFIG_CRYPTO_MICHAEL_MIC is not set
++# CONFIG_CRYPTO_RMD128 is not set
++# CONFIG_CRYPTO_RMD160 is not set
++# CONFIG_CRYPTO_RMD256 is not set
++# CONFIG_CRYPTO_RMD320 is not set
++# CONFIG_CRYPTO_SHA1 is not set
++# CONFIG_CRYPTO_SHA256 is not set
++# CONFIG_CRYPTO_SHA512 is not set
++# CONFIG_CRYPTO_TGR192 is not set
++# CONFIG_CRYPTO_WP512 is not set
++
++#
++# Ciphers
++#
++# CONFIG_CRYPTO_AES is not set
++# CONFIG_CRYPTO_ANUBIS is not set
++# CONFIG_CRYPTO_ARC4 is not set
++# CONFIG_CRYPTO_BLOWFISH is not set
++# CONFIG_CRYPTO_CAMELLIA is not set
++# CONFIG_CRYPTO_CAST5 is not set
++# CONFIG_CRYPTO_CAST6 is not set
++# CONFIG_CRYPTO_DES is not set
++# CONFIG_CRYPTO_FCRYPT is not set
++# CONFIG_CRYPTO_KHAZAD is not set
++# CONFIG_CRYPTO_SALSA20 is not set
++# CONFIG_CRYPTO_SEED is not set
++# CONFIG_CRYPTO_SERPENT is not set
++# CONFIG_CRYPTO_TEA is not set
++# CONFIG_CRYPTO_TWOFISH is not set
++
++#
++# Compression
++#
++# CONFIG_CRYPTO_DEFLATE is not set
++# CONFIG_CRYPTO_ZLIB is not set
++# CONFIG_CRYPTO_LZO is not set
++
++#
++# Random Number Generation
++#
++# CONFIG_CRYPTO_ANSI_CPRNG is not set
++# CONFIG_CRYPTO_HW is not set
++# CONFIG_BINARY_PRINTF is not set
++
++#
++# Library routines
++#
++CONFIG_BITREVERSE=y
++CONFIG_GENERIC_FIND_LAST_BIT=y
++CONFIG_CRC_CCITT=m
++# CONFIG_CRC16 is not set
++CONFIG_CRC_T10DIF=m
++# CONFIG_CRC_ITU_T is not set
++CONFIG_CRC32=y
++# CONFIG_CRC7 is not set
++# CONFIG_LIBCRC32C is not set
++CONFIG_ZLIB_INFLATE=y
++CONFIG_DECOMPRESS_GZIP=y
++CONFIG_GENERIC_ALLOCATOR=y
++CONFIG_HAS_IOMEM=y
++CONFIG_HAS_IOPORT=y
++CONFIG_HAS_DMA=y
++CONFIG_NLATTR=y
+--- /dev/null
++++ b/drivers/media/video/davinci/davinci_display.c
+@@ -0,0 +1,1839 @@
++/*
++ * Copyright (C) 2009 Texas Instruments Inc
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
++ */
++#include <linux/kernel.h>
++#include <linux/init.h>
++#include <linux/module.h>
++#include <linux/errno.h>
++#include <linux/fs.h>
++#include <linux/interrupt.h>
++#include <linux/string.h>
++#include <media/v4l2-dev.h>
++#include <media/v4l2-common.h>
++#include <media/v4l2-ioctl.h>
++#include <media/v4l2-device.h>
++#include <linux/wait.h>
++#include <linux/time.h>
++#include <linux/platform_device.h>
++#include <linux/irq.h>
++#include <linux/mm.h>
++#include <linux/mutex.h>
++#include <linux/videodev2.h>
++#include <asm/pgtable.h>
++#include <mach/cputype.h>
++#include <media/davinci/davinci_enc.h>
++#include <media/davinci/davinci_display.h>
++
++#define DAVINCI_DISPLAY_DRIVER "davinci_v4l2"
++#define DM355_EVM_CARD  "DM355 EVM"
++#define DM644X_EVM_CARD "DM644X EVM"
++#define DM365_EVM_CARD  "DM365 EVM"
++
++static u32 video2_numbuffers = 3;
++static u32 video3_numbuffers = 3;
++
++#define DAVINCI_DISPLAY_HD_BUF_SIZE (1280*720*2)
++#define DAVINCI_DISPLAY_SD_BUF_SIZE (720*576*2)
++
++static u32 video2_bufsize = DAVINCI_DISPLAY_SD_BUF_SIZE;
++static u32 video3_bufsize = DAVINCI_DISPLAY_SD_BUF_SIZE;
++
++module_param(video2_numbuffers, uint, S_IRUGO);
++module_param(video3_numbuffers, uint, S_IRUGO);
++
++module_param(video2_bufsize, uint, S_IRUGO);
++module_param(video3_bufsize, uint, S_IRUGO);
++
++#define DAVINCI_DEFAULT_NUM_BUFS 3
++static struct buf_config_params display_buf_config_params = {
++	.min_numbuffers = DAVINCI_DEFAULT_NUM_BUFS,
++	.numbuffers[0] = DAVINCI_DEFAULT_NUM_BUFS,
++	.numbuffers[1] = DAVINCI_DEFAULT_NUM_BUFS,
++	.min_bufsize[0] = DAVINCI_DISPLAY_SD_BUF_SIZE,
++	.min_bufsize[1] = DAVINCI_DISPLAY_SD_BUF_SIZE,
++	.layer_bufsize[0] = DAVINCI_DISPLAY_SD_BUF_SIZE,
++	.layer_bufsize[1] = DAVINCI_DISPLAY_SD_BUF_SIZE,
++};
++
++static int davinci_display_nr[] = { 2, 3 };
++
++/* global variables */
++static struct davinci_display davinci_dm;
++
++struct device *davinci_display_dev = NULL;
++
++static struct v4l2_capability davinci_display_videocap = {
++	.driver = DAVINCI_DISPLAY_DRIVER,
++	.bus_info = "Platform",
++	.version = DAVINCI_DISPLAY_VERSION_CODE,
++	.capabilities = V4L2_CAP_VIDEO_OUTPUT | V4L2_CAP_STREAMING
++};
++
++static struct v4l2_fract ntsc_aspect = DAVINCI_DISPLAY_PIXELASPECT_NTSC;
++static struct v4l2_fract pal_aspect = DAVINCI_DISPLAY_PIXELASPECT_PAL;
++static struct v4l2_fract sp_aspect = DAVINCI_DISPLAY_PIXELASPECT_SP;
++
++static struct v4l2_rect ntsc_bounds = DAVINCI_DISPLAY_WIN_NTSC;
++static struct v4l2_rect pal_bounds = DAVINCI_DISPLAY_WIN_PAL;
++static struct v4l2_rect vga_bounds = DAVINCI_DISPLAY_WIN_640_480;
++static struct v4l2_rect hd_720p_bounds = DAVINCI_DISPLAY_WIN_720P;
++static struct v4l2_rect hd_1080i_bounds = DAVINCI_DISPLAY_WIN_1080I;
++
++/*
++ * davinci_buffer_prepare()
++ * This is the callback function called from videobuf_qbuf() function
++ * the buffer is prepared and user space virtual address is converted into
++ * physical address
++ */
++static int davinci_buffer_prepare(struct videobuf_queue *q,
++				  struct videobuf_buffer *vb,
++				  enum v4l2_field field)
++{
++	unsigned long addr;
++	int ret = 0;
++
++	dev_dbg(davinci_display_dev, "<davinci_buffer_prepare>\n");
++
++	/* If buffer is not initialized, initialize it */
++	if (VIDEOBUF_NEEDS_INIT == vb->state) {
++		vb->width = davinci_dm.mode_info.xres;
++		vb->height = davinci_dm.mode_info.yres;
++		vb->size = vb->width * vb->height;
++		vb->field = field;
++
++		ret = videobuf_iolock(q, vb, NULL);
++		if (ret < 0) {
++			dev_err(davinci_display_dev, "Failed to map \
++				user address\n");
++			goto buf_align_exit;
++		}
++
++		addr = videobuf_to_dma_contig(vb);
++
++		if (q->streaming) {
++			if (!ISALIGNED(addr)) {
++				dev_err(davinci_display_dev, "buffer_prepare:offset is \
++					not aligned to 32 bytes\n");
++				goto buf_align_exit;
++			}
++		}
++		vb->state = VIDEOBUF_PREPARED;
++	}
++
++	return 0;
++
++buf_align_exit:
++	return -EINVAL;
++}
++/*
++ * davinci_buffer_setup()
++ * This function allocates memory for the buffers
++ */
++static int davinci_buffer_setup(struct videobuf_queue *q, unsigned int *count,
++				unsigned int *size)
++{
++	/* Get the file handle object and layer object */
++	struct davinci_fh *fh = q->priv_data;
++	struct display_obj *layer = fh->layer;
++	int buf_size;
++
++	dev_dbg(davinci_display_dev, "<davinci_buffer_setup>\n");
++
++	*size = layer->pix_fmt.sizeimage;
++	buf_size = display_buf_config_params.layer_bufsize[layer->device_id];
++
++	/**
++	 * For MMAP, limit the memory allocation as per bootarg
++	 * configured buffer size
++	 */
++	if (V4L2_MEMORY_MMAP == layer->memory)
++		if (*size > buf_size)
++			*size = buf_size;
++
++	/* Store number of buffers allocated in numbuffer member */
++	if (*count < display_buf_config_params.min_numbuffers)
++		*count = layer->numbuffers = display_buf_config_params.numbuffers[layer->device_id];
++	dev_dbg(davinci_display_dev, "</davinci_buffer_setup>\n");
++	return 0;
++}
++
++/*
++ * davinci_buffer_queue()
++ * This function adds the buffer to DMA queue
++ */
++static void davinci_buffer_queue(struct videobuf_queue *q,
++				 struct videobuf_buffer *vb)
++{
++	/* Get the file handle object and layer object */
++	struct davinci_fh *fh = q->priv_data;
++	struct display_obj *layer = fh->layer;
++	dev_dbg(davinci_display_dev, "<davinci_buffer_queue>\n");
++
++	/* add the buffer to the DMA queue */
++	list_add_tail(&vb->queue, &layer->dma_queue);
++	/* Change state of the buffer */
++	vb->state = VIDEOBUF_QUEUED;
++	dev_dbg(davinci_display_dev, "</davinci_buffer_queue>\n");
++}
++
++/*
++ * davinci_buffer_release()
++ * This function is called from the videobuf layer to free memory allocated to
++ * the buffers
++ */
++static void davinci_buffer_release(struct videobuf_queue *q,
++				   struct videobuf_buffer *vb)
++{
++	/* Get the file handle object and layer object */
++	struct davinci_fh *fh = q->priv_data;
++	struct display_obj *layer = fh->layer;
++	unsigned int buf_size = 0;
++	dev_dbg(davinci_display_dev, "<davinci_buffer_release>\n");
++
++	if (V4L2_MEMORY_USERPTR != layer->memory)
++		videobuf_dma_contig_free(q, vb);
++
++	vb->state = VIDEOBUF_NEEDS_INIT;
++
++
++	/* If memory type is not mmap, return */
++	if (V4L2_MEMORY_MMAP != layer->memory)
++		return;
++	/* Calculate the size of the buffer */
++	buf_size = display_buf_config_params.layer_bufsize[layer->device_id];
++
++	dev_dbg(davinci_display_dev, "</davinci_buffer_release>\n");
++}
++
++static struct videobuf_queue_ops video_qops = {
++	.buf_setup = davinci_buffer_setup,
++	.buf_prepare = davinci_buffer_prepare,
++	.buf_queue = davinci_buffer_queue,
++	.buf_release = davinci_buffer_release,
++};
++
++static u8 layer_first_int = 1;
++
++/* davinci_display_isr()
++ * ISR function. It changes status of the displayed buffer, takes next buffer
++ * from the queue and sets its address in VPBE registers
++ */
++static void davinci_display_isr(unsigned int event, void *dispObj)
++{
++	unsigned long jiffies_time = get_jiffies_64();
++	struct timeval timevalue;
++	int i, fid;
++	unsigned long addr = 0;
++	struct display_obj *layer = NULL;
++	struct davinci_display *dispDevice = (struct davinci_display *)dispObj;
++
++	/* Convert time represention from jiffies to timeval */
++	jiffies_to_timeval(jiffies_time, &timevalue);
++
++	for (i = 0; i < DAVINCI_DISPLAY_MAX_DEVICES; i++) {
++		layer = dispDevice->dev[i];
++		/* If streaming is started in this layer */
++		if (!layer->started)
++			continue;
++		/* Check the field format */
++		if ((V4L2_FIELD_NONE == layer->pix_fmt.field) &&
++		    (!list_empty(&layer->dma_queue)) &&
++		    (event & DAVINCI_DISP_END_OF_FRAME)) {
++			/* Progressive mode */
++			if (layer_first_int) {
++				layer_first_int = 0;
++				continue;
++			} else {
++				/* Mark status of the curFrm to
++				 * done and unlock semaphore on it
++				 */
++				if (layer->curFrm != layer->nextFrm) {
++					layer->curFrm->ts = timevalue;
++					layer->curFrm->state = VIDEOBUF_DONE;
++					wake_up_interruptible(&layer->curFrm->done);
++					/* Make curFrm pointing to nextFrm */
++					layer->curFrm = layer->nextFrm;
++				}
++			}
++			/* Get the next buffer from buffer queue */
++			layer->nextFrm =
++			    list_entry(layer->dma_queue.next,
++				       struct videobuf_buffer, queue);
++			/* Remove that buffer from the buffer queue */
++			list_del(&layer->nextFrm->queue);
++			/* Mark status of the buffer as active */
++			layer->nextFrm->state = VIDEOBUF_ACTIVE;
++			
++			addr = videobuf_to_dma_contig(layer->nextFrm);
++			davinci_disp_start_layer(layer->layer_info.id,
++						 addr,
++						 davinci_dm.cbcr_ofst);
++		} else {
++			/* Interlaced mode
++			 * If it is first interrupt, ignore it
++			 */
++			if (layer_first_int) {
++				layer_first_int = 0;
++				return;
++			}
++
++			layer->field_id ^= 1;
++			if (event & DAVINCI_DISP_FIRST_FIELD)
++				fid = 0;
++			else if (event & DAVINCI_DISP_SECOND_FIELD)
++				fid = 1;
++			else
++				return;
++
++			/* If field id does not match with stored
++			 * field id
++			 */
++			if (fid != layer->field_id) {
++				/* Make them in sync */
++				if (0 == fid) {
++					layer->field_id = fid;
++				}
++				return;
++			}
++			/* device field id and local field id are
++			 * in sync. If this is even field
++			 */
++			if (0 == fid) {
++				if (layer->curFrm == layer->nextFrm)
++					continue;
++				/* one frame is displayed If next frame is
++				 * available, release curFrm and move on
++				 * Copy frame display time
++				 */
++				layer->curFrm->ts = timevalue;
++				/* Change status of the curFrm */
++				layer->curFrm->state = VIDEOBUF_DONE;
++				/* unlock semaphore on curFrm */
++				wake_up_interruptible(&layer->curFrm->done);
++				/* Make curFrm pointing to
++				 * nextFrm
++				 */
++				layer->curFrm = layer->nextFrm;
++			} else if (1 == fid) {	/* odd field */
++				if (list_empty(&layer->dma_queue)
++				    || (layer->curFrm != layer->nextFrm))
++					continue;
++
++				/* one field is displayed configure
++				 * the next frame if it is available
++				 * otherwise hold on current frame
++				 * Get next from the buffer queue
++				 */
++				layer->nextFrm = list_entry(layer->
++							    dma_queue.
++							    next, struct
++							    videobuf_buffer,
++							    queue);
++
++				/* Remove that from the
++				 * buffer queue
++				 */
++				list_del(&layer->nextFrm->queue);
++
++				/* Mark state of the frame
++				 * to active
++				 */
++				layer->nextFrm->state = VIDEOBUF_ACTIVE;
++
++				addr = videobuf_to_dma_contig(layer->nextFrm);
++				davinci_disp_start_layer(layer->layer_info.id,
++							addr,
++							davinci_dm.cbcr_ofst);
++			}
++		}
++	}
++}
++
++static struct display_obj*
++_davinci_disp_get_other_win(struct display_obj *layer)
++{
++	enum davinci_display_device_id thiswin, otherwin;
++	thiswin = layer->device_id;
++
++	otherwin = (thiswin == DAVINCI_DISPLAY_DEVICE_0) ?
++		DAVINCI_DISPLAY_DEVICE_1 : DAVINCI_DISPLAY_DEVICE_0;
++	return davinci_dm.dev[otherwin];
++}
++
++static int davinci_config_layer(enum davinci_display_device_id id);
++
++static int davinci_set_video_display_params(struct display_obj *layer)
++{
++	unsigned long addr;
++
++	addr = videobuf_to_dma_contig(layer->curFrm);
++	/* Set address in the display registers */
++	davinci_disp_start_layer(layer->layer_info.id,
++				 addr,
++				 davinci_dm.cbcr_ofst);
++	davinci_disp_enable_layer(layer->layer_info.id, 0);
++	/* Enable the window */
++	layer->layer_info.enable = 1;
++	if (layer->layer_info.config.pixfmt == PIXFMT_NV12) {
++		struct display_obj *otherlayer =
++			_davinci_disp_get_other_win(layer);
++		davinci_disp_enable_layer(otherlayer->layer_info.id, 1);
++		otherlayer->layer_info.enable = 1;
++	}
++	return 0;
++}
++
++static void davinci_disp_calculate_scale_factor(struct display_obj *layer,
++						int expected_xsize,
++						int expected_ysize)
++{
++	struct display_layer_info *layer_info = &layer->layer_info;
++	struct v4l2_pix_format *pixfmt = &layer->pix_fmt;
++	int h_scale = 0, v_scale = 0, h_exp = 0, v_exp = 0, temp;
++	/* Application initially set the image format. Current display
++	 * size is obtained from the encoder manager. expected_xsize
++	 * and expected_ysize are set through S_CROP ioctl. Based on this,
++	 * driver will calculate the scale factors for vertical and
++	 * horizontal direction so that the image is displayed scaled
++	 * and expanded. Application uses expansion to display the image
++	 * in a square pixel. Otherwise it is displayed using displays
++	 * pixel aspect ratio.It is expected that application chooses
++	 * the crop coordinates for cropped or scaled display. if crop
++	 * size is less than the image size, it is displayed cropped or
++	 * it is displayed scaled and/or expanded.
++	 *
++	 * to begin with, set the crop window same as expected. Later we
++	 * will override with scaled window size
++	 */
++	layer->layer_info.config.xsize = pixfmt->width;
++	layer->layer_info.config.ysize = pixfmt->height;
++	layer_info->h_zoom = ZOOM_X1;	/* no horizontal zoom */
++	layer_info->v_zoom = ZOOM_X1;	/* no horizontal zoom */
++	layer_info->h_exp = H_EXP_OFF;	/* no horizontal zoom */
++	layer_info->v_exp = V_EXP_OFF;	/* no horizontal zoom */
++
++	if (pixfmt->width < expected_xsize) {
++		h_scale = davinci_dm.mode_info.xres / pixfmt->width;
++		if (h_scale < 2)
++			h_scale = 1;
++		else if (h_scale >= 4)
++			h_scale = 4;
++		else
++			h_scale = 2;
++		layer->layer_info.config.xsize *= h_scale;
++		if (layer->layer_info.config.xsize < expected_xsize) {
++			if (!strcmp(davinci_dm.mode_info.name, VID_ENC_STD_NTSC)
++			    || !strcmp(davinci_dm.mode_info.name,
++				       VID_ENC_STD_PAL)) {
++				temp =
++				    (layer->layer_info.config.xsize *
++				     DAVINCI_DISPLAY_H_EXP_RATIO_N)
++				    / DAVINCI_DISPLAY_H_EXP_RATIO_D;
++				if (temp <= expected_xsize) {
++					h_exp = 1;
++					layer->layer_info.config.xsize = temp;
++				}
++			}
++		}
++		if (h_scale == 2)
++			layer_info->h_zoom = ZOOM_X2;
++		else if (h_scale == 4)
++			layer_info->h_zoom = ZOOM_X4;
++		if (h_exp)
++			layer_info->h_exp = H_EXP_9_OVER_8;
++	} else {
++		/* no scaling, only cropping. Set display area to crop area */
++		layer->layer_info.config.xsize = expected_xsize;
++	}
++
++	if (pixfmt->height < expected_ysize) {
++		v_scale = expected_ysize / pixfmt->height;
++		if (v_scale < 2)
++			v_scale = 1;
++		else if (v_scale >= 4)
++			v_scale = 4;
++		else
++			v_scale = 2;
++		layer->layer_info.config.ysize *= v_scale;
++		if (layer->layer_info.config.ysize < expected_ysize) {
++			if (!strcmp(davinci_dm.mode_info.name, "PAL")) {
++				temp =
++				    (layer->layer_info.config.ysize *
++				     DAVINCI_DISPLAY_V_EXP_RATIO_N)
++				    / DAVINCI_DISPLAY_V_EXP_RATIO_D;
++				if (temp <= expected_ysize) {
++					v_exp = 1;
++					layer->layer_info.config.ysize = temp;
++				}
++			}
++		}
++		if (v_scale == 2)
++			layer_info->v_zoom = ZOOM_X2;
++		else if (v_scale == 4)
++			layer_info->v_zoom = ZOOM_X4;
++		if (v_exp)
++			layer_info->h_exp = V_EXP_6_OVER_5;
++	} else {
++		/* no scaling, only cropping. Set display area to crop area */
++		layer->layer_info.config.ysize = expected_ysize;
++	}
++	dev_dbg(davinci_display_dev,
++		"crop display xsize = %d, ysize = %d\n",
++		layer->layer_info.config.xsize, layer->layer_info.config.ysize);
++}
++
++static void davinci_disp_adj_position(struct display_obj *layer, int top,
++				      int left)
++{
++	layer->layer_info.config.xpos = 0;
++	layer->layer_info.config.ypos = 0;
++	if (left + layer->layer_info.config.xsize <= davinci_dm.mode_info.xres)
++		layer->layer_info.config.xpos = left;
++	if (top + layer->layer_info.config.ysize <= davinci_dm.mode_info.yres)
++		layer->layer_info.config.ypos = top;
++	dev_dbg(davinci_display_dev,
++		"new xpos = %d, ypos = %d\n",
++		layer->layer_info.config.xpos, layer->layer_info.config.ypos);
++}
++
++static int davinci_disp_check_window_params(struct v4l2_rect *c)
++{
++	if ((c->width == 0)
++	    || ((c->width + c->left) > davinci_dm.mode_info.xres)
++	    || (c->height == 0)
++	    || ((c->height + c->top) > davinci_dm.mode_info.yres)) {
++		dev_err(davinci_display_dev, "Invalid crop values\n");
++		return -1;
++	}
++	if ((c->height & 0x1) && (davinci_dm.mode_info.interlaced)) {
++		dev_err(davinci_display_dev,
++			"window height must be even for interlaced display\n");
++		return -1;
++	}
++	return 0;
++}
++
++/* vpbe_try_format()
++ * If user application provides width and height, and have bytesperline set
++ * to zero, driver calculates bytesperline and sizeimage based on hardware
++ * limits. If application likes to add pads at the end of each line and
++ * end of the buffer , it can set bytesperline to line size and sizeimage to
++ * bytesperline * height of the buffer. If driver fills zero for active
++ * video width and height, and has requested user bytesperline and sizeimage,
++ * width and height is adjusted to maximum display limit or buffer width
++ * height which ever is lower
++ */
++static int vpbe_try_format(struct v4l2_pix_format *pixfmt, int check)
++{
++	struct vid_enc_mode_info *mode_info;
++	int min_sizeimage, bpp, min_height = 1, min_width = 32,
++		max_width, max_height, user_info = 0;
++
++	mode_info = &davinci_dm.mode_info;
++	davinci_enc_get_mode(0, mode_info);
++
++	if ((pixfmt->pixelformat != V4L2_PIX_FMT_UYVY) &&
++	    (pixfmt->pixelformat != V4L2_PIX_FMT_NV12))
++		/* choose default as V4L2_PIX_FMT_UYVY */
++		pixfmt->pixelformat = V4L2_PIX_FMT_UYVY;
++
++	if (pixfmt->field == V4L2_FIELD_ANY) {
++		if (mode_info->interlaced)
++			pixfmt->field = V4L2_FIELD_INTERLACED;
++		else
++			pixfmt->field = V4L2_FIELD_NONE;
++	}
++
++	if (pixfmt->field == V4L2_FIELD_INTERLACED)
++		min_height = 2;
++
++	if (pixfmt->pixelformat == V4L2_PIX_FMT_NV12)
++		bpp = 1;
++	else
++		bpp = 2;
++
++	max_width = mode_info->xres;
++	max_height = mode_info->yres;
++
++	min_width /= bpp;
++
++	if (!pixfmt->width && !pixfmt->bytesperline) {
++		dev_err(davinci_display_dev, "bytesperline and width"
++			" cannot be zero\n");
++		return -EINVAL;
++	}
++
++	/* if user provided bytesperline, it must provide sizeimage as well */
++	if (pixfmt->bytesperline && !pixfmt->sizeimage) {
++		dev_err(davinci_display_dev,
++			"sizeimage must be non zero, when user"
++			" provides bytesperline\n");
++		return -EINVAL;
++	}
++
++	/* adjust bytesperline as per hardware - multiple of 32 */
++	if (!pixfmt->width)
++		pixfmt->width = pixfmt->bytesperline / bpp;
++
++	if (!pixfmt->bytesperline)
++		pixfmt->bytesperline = pixfmt->width * bpp;
++	else
++		user_info = 1;
++	pixfmt->bytesperline = ((pixfmt->bytesperline + 31) & ~31);
++
++	if (pixfmt->width < min_width) {
++		if (check) {
++			dev_err(davinci_display_dev,
++				"height is less than minimum,"
++				"input width = %d, min_width = %d \n",
++				pixfmt->width, min_width);
++			return -EINVAL;
++		}
++		pixfmt->width = min_width;
++	}
++
++	if (pixfmt->width > max_width) {
++		if (check) {
++			dev_err(davinci_display_dev,
++				"width is more than maximum,"
++				"input width = %d, max_width = %d\n",
++				pixfmt->width, max_width);
++			return -EINVAL;
++		}
++		pixfmt->width = max_width;
++	}
++
++	/* If height is zero, then atleast we need to have sizeimage
++	 * to calculate height
++	 */
++	if (!pixfmt->height) {
++		if (user_info) {
++			if (pixfmt->pixelformat == V4L2_PIX_FMT_NV12) {
++				/* for NV12 format, sizeimage is y-plane size
++				 * + CbCr plane which is half of y-plane
++				 */
++				pixfmt->height = pixfmt->sizeimage /
++						(pixfmt->bytesperline +
++						(pixfmt->bytesperline >> 1));
++			} else
++				pixfmt->height = pixfmt->sizeimage/
++						pixfmt->bytesperline;
++		}
++	}
++
++	if (pixfmt->height > max_height) {
++		if (check && !user_info) {
++			dev_err(davinci_display_dev,
++				"height is more than maximum,"
++				"input height = %d, max_height = %d\n",
++				pixfmt->height, max_height);
++			return -EINVAL;
++		}
++		pixfmt->height = max_height;
++	}
++
++	if (pixfmt->height < min_height) {
++		if (check && !user_info) {
++			dev_err(davinci_display_dev,
++				"width is less than minimum,"
++				"input height = %d, min_height = %d\n",
++				pixfmt->height, min_height);
++			return -EINVAL;
++		}
++		pixfmt->height = min_width;
++	}
++
++	/* if user has not provided bytesperline calculate it based on width */
++	if (!user_info)
++		pixfmt->bytesperline = (((pixfmt->width * bpp) + 31) & ~31);
++
++	if (pixfmt->pixelformat == V4L2_PIX_FMT_NV12)
++		min_sizeimage = pixfmt->bytesperline * pixfmt->height +
++				(pixfmt->bytesperline * pixfmt->height >> 1);
++	else
++		min_sizeimage = pixfmt->bytesperline * pixfmt->height;
++
++	if (pixfmt->sizeimage < min_sizeimage) {
++		if (check && user_info) {
++			dev_err(davinci_display_dev, "sizeimage is less, %d\n",
++				min_sizeimage);
++			return -EINVAL;
++		}
++		pixfmt->sizeimage = min_sizeimage;
++	}
++	return 0;
++}
++
++static int vpbe_g_priority(struct file *file, void *priv,
++				enum v4l2_priority *p)
++{
++	struct davinci_fh *fh = file->private_data;
++	struct display_obj *layer = fh->layer;
++
++	*p = v4l2_prio_max(&layer->prio);
++
++	return 0;
++}
++
++static int vpbe_s_priority(struct file *file, void *priv,
++				enum v4l2_priority p)
++{
++	struct davinci_fh *fh = file->private_data;
++	struct display_obj *layer = fh->layer;
++	int ret;
++
++	ret = v4l2_prio_change(&layer->prio, &fh->prio, p);
++
++	return ret;
++}
++
++static int vpbe_querycap(struct file *file, void  *priv,
++			       struct v4l2_capability *cap)
++{
++	struct davinci_fh *fh = file->private_data;
++	struct display_obj *layer = fh->layer;
++
++	dev_dbg(davinci_display_dev, "VIDIOC_QUERYCAP, layer id = %d\n",
++			layer->device_id);
++	
++	memset(cap, 0, sizeof(*cap));
++	*cap = davinci_display_videocap;
++
++	return 0;
++}
++
++static int vpbe_s_crop(struct file *file, void *priv,
++			     struct v4l2_crop *crop)
++{
++	int ret = 0;
++	struct davinci_fh *fh = file->private_data;
++	struct display_obj *layer = fh->layer;
++
++	dev_dbg(davinci_display_dev,
++				"VIDIOC_S_CROP, layer id = %d\n",
++				layer->device_id);
++
++	if (crop->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {
++		struct v4l2_rect *rect = &crop->c;
++
++		if (rect->top < 0 || rect->left < 0) {
++			dev_err(davinci_display_dev,
++					"Error in S_CROP params"
++					" Negative values for"
++					" top/left" );
++			return -EINVAL;
++
++		}
++
++		if (davinci_disp_check_window_params(rect)) {
++			dev_err(davinci_display_dev,
++					"Error in S_CROP params\n");
++					return -EINVAL;
++		}
++		ret = mutex_lock_interruptible(&davinci_dm.lock);
++		if (ret)
++			return ret;
++				
++		davinci_disp_get_layer_config(layer->layer_info.id,
++						&layer->layer_info.config);
++
++		davinci_disp_calculate_scale_factor(layer, rect->width,
++							rect->height);
++
++		davinci_disp_adj_position(layer, rect->top, rect->left);
++
++		if (davinci_disp_set_layer_config(layer->layer_info.id,
++			&layer->layer_info.config)) {
++		
++			dev_err(davinci_display_dev,
++					"Error in S_CROP params\n");
++			mutex_unlock(&davinci_dm.lock);
++			return -EINVAL;
++		}
++
++		/* apply zooming and h or v expansion */
++		davinci_disp_set_zoom(layer->layer_info.id,
++				     layer->layer_info.h_zoom,
++				     layer->layer_info.v_zoom);
++
++		davinci_disp_set_vid_expansion(layer->layer_info.h_exp,
++						layer->layer_info.v_exp);
++
++		if ((layer->layer_info.h_zoom != ZOOM_X1) ||
++			(layer->layer_info.v_zoom != ZOOM_X1) ||
++			(layer->layer_info.h_exp != H_EXP_OFF) ||
++			(layer->layer_info.v_exp != V_EXP_OFF))
++				/* Enable expansion filter */
++				davinci_disp_set_interpolation_filter(1);
++		else
++				davinci_disp_set_interpolation_filter(0);
++				mutex_unlock(&davinci_dm.lock);
++	} else {
++		dev_err(davinci_display_dev, "Invalid buf type \n");
++		return -EINVAL;
++	}
++	
++	return ret;
++}
++
++static int vpbe_g_crop(struct file *file, void *priv,
++			     struct v4l2_crop *crop)
++{
++	int ret = 0;
++	struct davinci_fh *fh = file->private_data;
++	struct display_obj *layer = fh->layer;
++	
++	dev_dbg(davinci_display_dev, "VIDIOC_G_CROP, layer id = %d\n",
++			layer->device_id);
++
++	if (crop->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {
++		struct v4l2_rect *rect = &crop->c;
++		ret = mutex_lock_interruptible(&davinci_dm.lock);
++		if (ret)
++			return ret;
++				
++		davinci_disp_get_layer_config(layer->layer_info.id,
++						&layer->layer_info.config);
++		rect->top = layer->layer_info.config.ypos;
++		rect->left = layer->layer_info.config.xpos;
++		rect->width = layer->layer_info.config.xsize;
++		rect->height = layer->layer_info.config.ysize;
++		mutex_unlock(&davinci_dm.lock);
++	} else {
++		dev_err(davinci_display_dev,"Invalid buf type \n");
++		ret = -EINVAL;
++	}
++	
++	return ret;
++}
++
++static int vpbe_cropcap(struct file *file, void *priv,
++			      struct v4l2_cropcap *cropcap)
++{
++	int ret = 0;
++
++	dev_dbg(davinci_display_dev, "\nStart of VIDIOC_CROPCAP ioctl");
++			
++	if (davinci_enc_get_mode(0, &davinci_dm.mode_info)) {
++		dev_err(davinci_display_dev,
++			"Error in getting current display mode"
++			" from enc mngr\n");
++		return -EINVAL;
++	}
++			
++	ret = mutex_lock_interruptible(&davinci_dm.lock);
++	if (ret)
++		return ret;
++			
++	cropcap->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
++	if (!strcmp(davinci_dm.mode_info.name, VID_ENC_STD_NTSC)) {
++		cropcap->bounds = cropcap->defrect = ntsc_bounds;
++		cropcap->pixelaspect = ntsc_aspect;
++	} else if (!strcmp(davinci_dm.mode_info.name, VID_ENC_STD_PAL)) {
++		cropcap->bounds = cropcap->defrect = pal_bounds;
++		cropcap->pixelaspect = pal_aspect;
++	} else if (!strcmp(davinci_dm.mode_info.name,VID_ENC_STD_640x480)) {
++		cropcap->bounds = cropcap->defrect = vga_bounds;
++		cropcap->pixelaspect = sp_aspect;
++	} else if (!strcmp(davinci_dm.mode_info.name, VID_ENC_STD_640x400)) {
++		cropcap->bounds = cropcap->defrect = vga_bounds;
++		cropcap->bounds.height = cropcap->defrect.height = 400;
++		cropcap->pixelaspect = sp_aspect;
++	} else if (!strcmp(davinci_dm.mode_info.name, VID_ENC_STD_640x350)) {
++		cropcap->bounds = cropcap->defrect = vga_bounds;
++		cropcap->bounds.height = cropcap->defrect.height = 350;
++		cropcap->pixelaspect = sp_aspect;
++	} else if (!strcmp(davinci_dm.mode_info.name, VID_ENC_STD_720P_60)) {
++		cropcap->bounds = cropcap->defrect = hd_720p_bounds;
++		cropcap->pixelaspect = sp_aspect;
++	} else if (!strcmp(davinci_dm.mode_info.name, VID_ENC_STD_1080I_30)) {
++		cropcap->bounds = cropcap->defrect = hd_1080i_bounds;
++		cropcap->pixelaspect = sp_aspect;
++	} else {
++		dev_err(davinci_display_dev, "Unknown encoder display mode\n");
++		return -EINVAL;
++	}
++	
++	mutex_unlock(&davinci_dm.lock);
++	dev_dbg(davinci_display_dev, "\nEnd of VIDIOC_CROPCAP ioctl");
++
++	return ret;
++}
++
++static int vpbe_streamoff(struct file *file, void *priv,
++			  enum v4l2_buf_type buf_type)
++{
++	int ret = 0;
++	struct davinci_fh *fh = file->private_data;
++	struct display_obj *layer = fh->layer;
++
++	dev_dbg(davinci_display_dev, "VIDIOC_STREAMOFF,layer id = %d\n",
++		layer->device_id);
++	/* If io is allowed for this file handle, return error */
++	if (!fh->io_allowed) {
++		dev_err(davinci_display_dev, "No io_allowed\n");
++		return -EACCES;
++	}
++			
++	/* If streaming is not started, return error */
++	if (!layer->started) {
++		dev_err(davinci_display_dev, "streaming not started in layer"
++			" id = %d\n", layer->device_id);
++		return -EINVAL;
++	}
++			
++	ret = mutex_lock_interruptible(&davinci_dm.lock);
++	if (ret)
++		return ret;
++	davinci_disp_disable_layer(layer->layer_info.id);
++	layer->started = 0;
++	mutex_unlock(&davinci_dm.lock);
++	ret = videobuf_streamoff(&layer->buffer_queue);
++
++	return ret;
++}
++
++static int vpbe_streamon(struct file *file, void *priv,
++			 enum v4l2_buf_type buf_type)
++{
++	int ret = 0;
++	struct davinci_fh *fh = file->private_data;
++	struct display_obj *layer = fh->layer;
++
++	dev_dbg(davinci_display_dev, "VIDIOC_STREAMON, layer id = %d\n",
++			layer->device_id);
++	/* If file handle is not allowed IO, return error */
++	if (!fh->io_allowed) {
++		dev_err(davinci_display_dev, "No io_allowed\n");
++		return -EACCES;
++	}
++	/* If Streaming is already started, return error */
++	if (layer->started) {
++		dev_err(davinci_display_dev, "layer is already streaming\n");
++		return -EBUSY;
++	}
++
++	/*
++	 * Call videobuf_streamon to start streaming
++	 * in videobuf
++	 */
++	ret = videobuf_streamon(&layer->buffer_queue);
++	if (ret) {
++		dev_err(davinci_display_dev,
++		"error in videobuf_streamon\n");
++		return ret;
++	}
++	ret = mutex_lock_interruptible(&davinci_dm.lock);
++	if (ret)
++		return ret;
++	/* If buffer queue is empty, return error */
++	if (list_empty(&layer->dma_queue)) {
++		dev_err(davinci_display_dev, "buffer queue is empty\n");
++		mutex_unlock(&davinci_dm.lock);
++		return -EIO;
++	}
++	/* Get the next frame from the buffer queue */
++	layer->nextFrm = layer->curFrm = list_entry(layer->dma_queue.next,
++				struct videobuf_buffer, queue);
++	/* Remove buffer from the buffer queue */
++	list_del(&layer->curFrm->queue);
++	/* Mark state of the current frame to active */
++	layer->curFrm->state = VIDEOBUF_ACTIVE;
++	/* Initialize field_id and started member */
++
++	layer->field_id = 0;
++
++	/* Set parameters in OSD and VENC */
++	ret = davinci_set_video_display_params(layer);
++	if (ret < 0) {
++		mutex_unlock(&davinci_dm.lock);
++		return ret;
++	}
++	/* if request format is yuv420 semiplanar, need to
++	 * enable both video windows
++	 */
++
++	layer->started = 1;
++	dev_dbg(davinci_display_dev, "Started streaming on layer id = %d,"
++		" ret = %d\n", layer->device_id, ret);
++			
++	layer_first_int = 1;
++	mutex_unlock(&davinci_dm.lock);
++
++	return ret;
++}
++
++static int vpbe_dqbuf(struct file *file, void *priv,
++		      struct v4l2_buffer *buf)
++{
++	int ret = 0;
++	struct davinci_fh *fh = file->private_data;
++	struct display_obj *layer = fh->layer;
++
++	dev_dbg(davinci_display_dev, "VIDIOC_DQBUF, layer id = %d\n",
++			layer->device_id);
++
++	/* If this file handle is not allowed to do IO, return error */
++	if (!fh->io_allowed) {
++		dev_err(davinci_display_dev, "No io_allowed\n");
++		return -EACCES;
++	}
++	if (file->f_flags & O_NONBLOCK)
++		/* Call videobuf_dqbuf for non blocking mode */
++		ret = videobuf_dqbuf(&layer->buffer_queue, buf, 1);
++	else
++		/* Call videobuf_dqbuf for blocking mode */
++		ret = videobuf_dqbuf(&layer->buffer_queue, buf, 0);
++
++	return ret;
++}
++
++static int vpbe_qbuf(struct file *file, void *priv,
++		     struct v4l2_buffer *p)
++{
++	struct davinci_fh *fh = file->private_data;
++	struct display_obj *layer = fh->layer;
++
++	dev_dbg(davinci_display_dev, "VIDIOC_QBUF, layer id = %d\n",
++		layer->device_id);
++
++	/* If this file handle is not allowed to do IO, return error */
++	if (!fh->io_allowed) {
++		dev_err(davinci_display_dev, "No io_allowed\n");
++		return -EACCES;
++	}
++
++	return videobuf_qbuf(&layer->buffer_queue, p);
++}
++
++static int vpbe_querybuf(struct file *file, void *priv,
++			 struct v4l2_buffer *buf)
++{
++	int ret = 0;
++	struct davinci_fh *fh = file->private_data;
++	struct display_obj *layer = fh->layer;
++
++	dev_dbg(davinci_display_dev, "VIDIOC_QUERYBUF, layer id = %d\n",
++			layer->device_id);
++
++	/* Call videobuf_querybuf to get information */
++	ret = videobuf_querybuf(&layer->buffer_queue, buf);
++
++	return ret;
++}
++
++static int vpbe_reqbufs(struct file *file, void *priv,
++			struct v4l2_requestbuffers *req_buf)
++{
++	int ret = 0;
++	struct davinci_fh *fh = file->private_data;
++	struct display_obj *layer = fh->layer;
++
++	dev_dbg(davinci_display_dev, "VIDIOC_REQBUFS, count= %d, type = %d,"
++			"memory = %d\n",
++			req_buf->count, req_buf->type, req_buf->memory);
++
++	/* If io users of the layer is not zero, return error */
++	if (0 != layer->io_usrs) {
++		dev_err(davinci_display_dev, "not IO user\n");
++		return -EBUSY;
++	}
++	ret = mutex_lock_interruptible(&davinci_dm.lock);
++	if (ret)
++		return ret;
++	/* Initialize videobuf queue as per the buffer type */
++			
++	videobuf_queue_dma_contig_init(&layer->buffer_queue,
++					    &video_qops, davinci_display_dev,
++					    &layer->irqlock,
++					    V4L2_BUF_TYPE_VIDEO_OUTPUT,
++					    layer->pix_fmt.field,
++					    sizeof(struct videobuf_buffer), fh);
++
++	/* Set io allowed member of file handle to TRUE */
++	fh->io_allowed = 1;
++	/* Increment io usrs member of layer object to 1 */
++	layer->io_usrs = 1;
++	/* Store type of memory requested in layer object */
++	layer->memory = req_buf->memory;
++	/* Initialize buffer queue */
++	INIT_LIST_HEAD(&layer->dma_queue);
++	/* Allocate buffers */
++	ret = videobuf_reqbufs(&layer->buffer_queue, req_buf);
++	mutex_unlock(&davinci_dm.lock);
++
++	return ret;
++}
++
++static int vpbe_s_fmt(struct file *file, void *priv,
++				struct v4l2_format *fmt)
++{
++	int ret = 0;
++	struct davinci_fh *fh = file->private_data;
++	struct display_obj *layer = fh->layer;
++
++	dev_dbg(davinci_display_dev, "VIDIOC_S_FMT, layer id = %d\n",
++			layer->device_id);
++
++	/* If streaming is started, return error */
++	if (layer->started) {
++		dev_err(davinci_display_dev, "Streaming is started\n");
++		return -EBUSY;
++	}
++	if (V4L2_BUF_TYPE_VIDEO_OUTPUT == fmt->type) {
++		struct v4l2_pix_format *pixfmt = &fmt->fmt.pix;
++		/* Check for valid field format */
++		ret = vpbe_try_format(pixfmt, 1);
++		if (ret)
++			return ret;
++
++	/* YUV420 is requested, check availability of the other video window */
++	ret = mutex_lock_interruptible(&davinci_dm.lock);
++	if (ret)
++		return ret;
++
++	layer->pix_fmt = *pixfmt;
++	if (pixfmt->pixelformat == V4L2_PIX_FMT_NV12 &&
++		cpu_is_davinci_dm365()) {
++		struct display_obj *otherlayer =
++			_davinci_disp_get_other_win(layer);
++
++		/* if other layer is available, only
++		 * claim it, do not configure it
++		 */
++		if (davinci_disp_request_layer(otherlayer->layer_info.id)) {
++			/* Couldn't get layer */
++			dev_err(davinci_display_dev,
++						"Display Manager"
++						" failed to allocate"
++						" the other layer:"
++						"vidwin %d\n",
++						otherlayer->
++						layer_info.id);
++			mutex_unlock(&davinci_dm.lock);
++			return -EBUSY;
++		}
++	}
++				
++	/* store the pixel format in the layer object */
++	davinci_disp_get_layer_config(layer->layer_info.id,
++		&layer->layer_info.config);
++
++	layer->layer_info.config.xsize = pixfmt->width;
++	layer->layer_info.config.ysize = pixfmt->height;
++	layer->layer_info.config.line_length = pixfmt->bytesperline;
++	layer->layer_info.config.ypos = 0;
++	layer->layer_info.config.xpos = 0;
++	layer->layer_info.config.interlaced =
++			davinci_dm.mode_info.interlaced;
++
++	/* change of the default pixel format for both vid windows */
++	if (V4L2_PIX_FMT_NV12 == pixfmt->pixelformat) {
++		struct display_obj *otherlayer;
++		layer->layer_info.config.pixfmt = PIXFMT_NV12;
++		otherlayer = _davinci_disp_get_other_win(layer);
++		otherlayer->layer_info.config.pixfmt = PIXFMT_NV12;
++	}
++
++	if (davinci_disp_set_layer_config(layer->layer_info.id,
++					&layer->layer_info.config)) {
++		dev_err(davinci_display_dev, "Error in S_FMT params:\n");
++		mutex_unlock(&davinci_dm.lock);
++		return -EINVAL;
++	}
++
++	/* readback and fill the local copy of current pix format */
++	davinci_disp_get_layer_config(layer->layer_info.id,
++					&layer->layer_info.config);
++		
++	/* verify if readback values are as expected */
++	if (layer->pix_fmt.width != layer->layer_info.config.xsize ||
++		layer->pix_fmt.height != layer->layer_info.config.ysize ||
++		layer->pix_fmt.bytesperline != layer->layer_info.config.line_length ||
++		(layer->layer_info.config.interlaced && layer->pix_fmt.field !=
++		V4L2_FIELD_INTERLACED) || (!layer->layer_info.config.interlaced &&
++		layer->pix_fmt.field != V4L2_FIELD_NONE)) {
++		dev_err(davinci_display_dev, "mismatch with layer config"
++				" params:\n");
++		dev_err(davinci_display_dev, "layer->layer_info.config.xsize ="
++				"%d layer->pix_fmt.width = %d\n",
++				layer->layer_info.config.xsize,
++				layer->pix_fmt.width);
++		dev_err(davinci_display_dev,
++				"layer->layer_info.config.ysize ="
++				"%d layer->pix_fmt.height = %d\n",
++				layer->layer_info.config.ysize,
++				layer->pix_fmt.height);
++		dev_err(davinci_display_dev, "layer->layer_info.config."
++				"line_length= %d layer->pix_fmt"
++				".bytesperline = %d\n",
++				layer->layer_info.config.line_length,
++				layer->pix_fmt.bytesperline);
++		dev_err(davinci_display_dev, "layer->layer_info.config."
++				"interlaced =%d layer->pix_fmt."
++				"field = %d\n", layer->layer_info.config.interlaced,
++				layer->pix_fmt.field);
++		mutex_unlock(&davinci_dm.lock);
++		return -EFAULT;
++	}
++
++		dev_notice(davinci_display_dev,
++				"Before finishing with S_FMT:\n"
++				"layer.pix_fmt.bytesperline = %d,\n"
++				" layer.pix_fmt.width = %d, \n"
++				" layer.pix_fmt.height = %d, \n"
++				" layer.pix_fmt.sizeimage =%d\n",
++				layer->pix_fmt.bytesperline,
++				layer->pix_fmt.width,
++				layer->pix_fmt.height,
++				layer->pix_fmt.sizeimage);
++
++		dev_notice(davinci_display_dev,
++				"pixfmt->width = %d,\n"
++				" layer->layer_info.config.line_length"
++				"= %d\n",
++				pixfmt->width,
++				layer->layer_info.config.line_length);
++
++		mutex_unlock(&davinci_dm.lock);
++	} else {
++		dev_err(davinci_display_dev, "invalid type\n");
++		return -EINVAL;
++	}
++
++	return ret;
++}
++
++static int vpbe_try_fmt(struct file *file, void *priv,
++				  struct v4l2_format *fmt)
++{
++	int ret = 0;
++
++	dev_dbg(davinci_display_dev, "VIDIOC_TRY_FMT\n");
++
++	if (V4L2_BUF_TYPE_VIDEO_OUTPUT == fmt->type) {
++		struct v4l2_pix_format *pixfmt = &fmt->fmt.pix;
++		/* Check for valid field format */
++		ret = vpbe_try_format(pixfmt, 0);
++	} else {
++		dev_err(davinci_display_dev, "invalid type\n");
++		ret = -EINVAL;
++	}
++
++	return ret;
++}
++
++static int vpbe_enum_fmt(struct file *file, void  *priv,
++				   struct v4l2_fmtdesc *fmt)
++{
++	int ret = 0;
++	struct davinci_fh *fh = file->private_data;
++	struct display_obj *layer = fh->layer;
++	unsigned int index = 0;
++
++	dev_dbg(davinci_display_dev, "VIDIOC_ENUM_FMT, layer id = %d\n",
++		layer->device_id);
++	if (fmt->index > 0) {
++		dev_err(davinci_display_dev,
++			"Invalid format index\n");
++		return -EINVAL;
++	}
++	/* Fill in the information about format */
++
++	index = fmt->index;
++	memset(fmt, 0, sizeof(*fmt));
++	fmt->index = index;
++	fmt->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
++	if (index == 0) {
++		strcpy(fmt->description, "YUV 4:2:2 - UYVY");
++		fmt->pixelformat = V4L2_PIX_FMT_UYVY;
++	} else if (index == 1) {
++		strcpy(fmt->description, "Y/CbCr 4:2:0");
++		fmt->pixelformat = V4L2_PIX_FMT_NV12;
++	}
++
++	return ret;
++}
++
++static int vpbe_g_fmt(struct file *file, void *priv,
++				struct v4l2_format *fmt)
++{
++	int ret = 0;
++	struct davinci_fh *fh = file->private_data;
++	struct display_obj *layer = fh->layer;
++
++	dev_dbg(davinci_display_dev, "VIDIOC_G_FMT, layer id = %d\n",
++			layer->device_id);
++
++	/* If buffer type is video output */
++	if (V4L2_BUF_TYPE_VIDEO_OUTPUT == fmt->type) {
++		struct v4l2_pix_format *pixfmt = &fmt->fmt.pix;
++		/* Fill in the information about format */
++		ret = mutex_lock_interruptible(&davinci_dm.lock);
++		if (!ret) {
++			*pixfmt = layer->pix_fmt;
++			mutex_unlock(&davinci_dm.lock);
++		}
++	} else {
++		dev_err(davinci_display_dev, "invalid type\n");
++		ret = -EINVAL;
++	}
++
++	return ret;
++}
++
++static long vpbe_param_handler(struct file *file, void *priv,
++		int cmd, void *param)
++{
++	int ret = 0;
++
++	ret = mutex_lock_interruptible(&davinci_dm.lock);
++	if (ret)
++		return ret;
++
++	switch (cmd) {
++	case VIDIOC_S_COFST:
++		davinci_dm.cbcr_ofst = *((unsigned long *) param);
++		mutex_unlock(&davinci_dm.lock);
++		break;
++	default:
++		ret = -EINVAL;
++	}
++
++	return ret;
++}
++
++/*
++ * davinci_mmap()
++ * It is used to map kernel space buffers into user spaces
++ */
++static int davinci_mmap(struct file *filep, struct vm_area_struct *vma)
++{
++	/* Get the layer object and file handle object */
++	struct davinci_fh *fh = filep->private_data;
++	struct display_obj *layer = fh->layer;
++	int err = 0;
++	dev_dbg(davinci_display_dev, "<davinci_mmap>\n");
++
++	err = videobuf_mmap_mapper(&layer->buffer_queue, vma);
++	dev_dbg(davinci_display_dev, "</davinci_mmap>\n");
++	return err;
++}
++
++/* davinci_poll(): It is used for select/poll system call
++ */
++static unsigned int davinci_poll(struct file *filep, poll_table *wait)
++{
++	int err = 0;
++	struct davinci_fh *fh = filep->private_data;
++	struct display_obj *layer = fh->layer;
++
++	dev_dbg(davinci_display_dev, "<davinci_poll>");
++
++	if (layer->started)
++		err = videobuf_poll_stream(filep, &layer->buffer_queue, wait);
++	dev_dbg(davinci_display_dev, "</davinci_poll>");
++	return err;
++}
++
++static int davinci_config_layer(enum davinci_display_device_id id)
++{
++	int err = 0;
++	struct davinci_layer_config *layer_config;
++	struct vid_enc_mode_info *mode_info;
++	struct display_obj *layer = davinci_dm.dev[id];
++
++	/* First claim the layer for this device */
++	if (davinci_disp_request_layer(layer->layer_info.id)) {
++		/* Couldn't get layer */
++		dev_err(davinci_display_dev,
++			"Display Manager failed to allocate layer\n");
++		return -EBUSY;
++	}
++
++	/* get the current video display mode from encoder manager */
++	mode_info = &davinci_dm.mode_info;
++	if (davinci_enc_get_mode(0, mode_info)) {
++		dev_err(davinci_display_dev,
++			"Error in getting current display mode from enc mngr\n");
++		return -1;
++	}
++
++	layer_config = &layer->layer_info.config;
++	/* Set the default image and crop values */
++	layer_config->pixfmt = PIXFMT_YCbCrI;
++	layer->pix_fmt.pixelformat = V4L2_PIX_FMT_UYVY;
++	layer->pix_fmt.bytesperline = layer_config->line_length =
++	    mode_info->xres * 2;
++
++	layer->pix_fmt.width = layer_config->xsize = mode_info->xres;
++	layer->pix_fmt.height = layer_config->ysize = mode_info->yres;
++	layer->pix_fmt.sizeimage =
++	    layer->pix_fmt.bytesperline * layer->pix_fmt.height;
++	layer_config->xpos = 0;
++	layer_config->ypos = 0;
++	layer_config->interlaced = mode_info->interlaced;
++
++	/* turn off ping-pong buffer and field inversion to fix
++	 * the image shaking problem in 1080I mode
++	 */
++
++	if (layer->layer_info.config.interlaced)
++		layer->pix_fmt.field = V4L2_FIELD_INTERLACED;
++	else
++		layer->pix_fmt.field = V4L2_FIELD_NONE;
++	davinci_disp_set_layer_config(layer->layer_info.id, layer_config);
++	return err;
++}
++
++/*
++ * davinci_open()
++ * It creates object of file handle structure and stores it in private_data
++ * member of filepointer
++ */
++static int davinci_open(struct file *filep)
++{
++	int minor = iminor(filep->f_path.dentry->d_inode);
++	int found = -1;
++	int i = 0;
++	struct display_obj *layer;
++	struct davinci_fh *fh = NULL;
++
++	/* Check for valid minor number */
++	for (i = 0; i < DAVINCI_DISPLAY_MAX_DEVICES; i++) {
++		/* Get the pointer to the layer object */
++		layer = davinci_dm.dev[i];
++		if (minor == layer->video_dev->minor) {
++			found = i;
++			break;
++		}
++	}
++
++	/* If not found, return error no device */
++	if (0 > found) {
++		dev_err(davinci_display_dev, "device not found\n");
++		return -ENODEV;
++	}
++
++	/* Allocate memory for the file handle object */
++	fh = kmalloc(sizeof(struct davinci_fh), GFP_KERNEL);
++	if (ISNULL(fh)) {
++		dev_err(davinci_display_dev,
++			"unable to allocate memory for file handle object\n");
++		return -ENOMEM;
++	}
++	dev_dbg(davinci_display_dev, "<davinci open> plane = %d\n",
++		layer->device_id);
++	/* store pointer to fh in private_data member of filep */
++	filep->private_data = fh;
++	fh->layer = layer;
++
++	if (!layer->usrs) {
++		/* Configure the default values for the layer */
++		if (davinci_config_layer(layer->device_id)) {
++			dev_err(davinci_display_dev,
++				"Unable to configure video layer for id = %d\n",
++				layer->device_id);
++			return -EINVAL;
++		}
++	}
++
++	/* Increment layer usrs counter */
++	layer->usrs++;
++	/* Set io_allowed member to false */
++	fh->io_allowed = 0;
++	/* Initialize priority of this instance to default priority */
++	fh->prio = V4L2_PRIORITY_UNSET;
++	v4l2_prio_open(&layer->prio, &fh->prio);
++	dev_dbg(davinci_display_dev, "</davinci_open>\n");
++	return 0;
++}
++
++/*
++ * davinci_release()
++ * This function deletes buffer queue, frees the buffers and the davinci
++ * display file * handle
++ */
++static int davinci_release(struct file *filep)
++{
++	int ret = 0;
++	/* Get the layer object and file handle object */
++	struct davinci_fh *fh = filep->private_data;
++	struct display_obj *layer = fh->layer;
++
++	dev_dbg(davinci_display_dev, "<davinci_release>\n");
++	/* If this is doing IO and other layer are not closed */
++	if ((layer->usrs != 1) && fh->io_allowed) {
++		dev_err(davinci_display_dev, "Close other instances\n");
++		return -EAGAIN;
++	}
++	/* Get the lock on layer object */
++	ret = mutex_lock_interruptible(&davinci_dm.lock);
++	if (ret)
++		return ret;
++
++	/* if this instance is doing IO */
++	if (fh->io_allowed) {
++		/* Reset io_usrs member of layer object */
++		layer->io_usrs = 0;
++		davinci_disp_disable_layer(layer->layer_info.id);
++		layer->started = 0;
++		/* Free buffers allocated */
++		videobuf_queue_cancel(&layer->buffer_queue);
++		videobuf_mmap_free(&layer->buffer_queue);
++	}
++
++	/* Decrement layer usrs counter */
++	layer->usrs--;
++	/* If this file handle has initialize encoder device, reset it */
++	if (!layer->usrs) {
++		if (layer->layer_info.config.pixfmt == PIXFMT_NV12) {
++			struct display_obj *otherlayer;
++			otherlayer = _davinci_disp_get_other_win(layer);
++			davinci_disp_disable_layer(otherlayer->layer_info.id);
++			davinci_disp_release_layer(otherlayer->layer_info.id);
++		}
++		davinci_disp_disable_layer(layer->layer_info.id);
++		davinci_disp_release_layer(layer->layer_info.id);
++	}
++
++	/* Close the priority */
++	v4l2_prio_close(&layer->prio, &fh->prio);
++	filep->private_data = NULL;
++
++	/* Free memory allocated to file handle object */
++	if (!ISNULL(fh))
++		kfree(fh);
++	/* unlock mutex on layer object */
++	mutex_unlock(&davinci_dm.lock);
++
++	davinci_dm.cbcr_ofst = 0;
++
++	dev_dbg(davinci_display_dev, "</davinci_release>\n");
++	return 0;
++}
++
++static void davinci_platform_release(struct device
++				     *device)
++{
++	/* This is called when the reference count goes to zero */
++}
++
++static struct v4l2_file_operations vpbe_fops = {
++	.owner = THIS_MODULE,
++	.open = davinci_open,
++	.release = davinci_release,
++	.ioctl = video_ioctl2,
++	.mmap = davinci_mmap,
++	.poll = davinci_poll
++};
++
++/* vpbe capture ioctl operations */
++static const struct v4l2_ioctl_ops vpbe_ioctl_ops = {
++	.vidioc_querycap	 = vpbe_querycap,
++	.vidioc_g_fmt_vid_out    = vpbe_g_fmt,
++	.vidioc_enum_fmt_vid_out = vpbe_enum_fmt,
++	.vidioc_s_fmt_vid_out    = vpbe_s_fmt,
++	.vidioc_try_fmt_vid_out  = vpbe_try_fmt,
++	.vidioc_reqbufs		 = vpbe_reqbufs,
++	.vidioc_querybuf	 = vpbe_querybuf,
++	.vidioc_qbuf		 = vpbe_qbuf,
++	.vidioc_dqbuf		 = vpbe_dqbuf,
++	.vidioc_streamon	 = vpbe_streamon,
++	.vidioc_streamoff	 = vpbe_streamoff,
++	.vidioc_cropcap		 = vpbe_cropcap,
++	.vidioc_g_crop		 = vpbe_g_crop,
++	.vidioc_s_crop		 = vpbe_s_crop,
++	.vidioc_g_priority	 = vpbe_g_priority,
++	.vidioc_s_priority	 = vpbe_s_priority,
++	.vidioc_default		 = vpbe_param_handler,
++};
++
++/*
++ * davinci_probe()
++ * This function creates device entries by register itself to the V4L2 driver
++ * and initializes fields of each layer objects
++ */
++static __init int davinci_probe(struct device *device)
++{
++	int i, j = 0, k, err = 0;
++	struct video_device *vbd = NULL;
++	struct display_obj *layer = NULL;
++	struct platform_device *pdev;
++
++	davinci_display_dev = device;
++
++	dev_dbg(davinci_display_dev, "<davinci_probe>\n");
++
++	/* First request memory region for io */
++	pdev = to_platform_device(device);
++	if (pdev->num_resources != 0) {
++		dev_err(davinci_display_dev, "probed for an unknown device\n");
++		return -ENODEV;
++	}
++	for (i = 0; i < DAVINCI_DISPLAY_MAX_DEVICES; i++) {
++		/* Get the pointer to the layer object */
++		layer = davinci_dm.dev[i];
++		/* Allocate memory for video device */
++		vbd = video_device_alloc();
++		if (ISNULL(vbd)) {
++			for (j = 0; j < i; j++) {
++				video_device_release
++				    (davinci_dm.dev[j]->video_dev);
++			}
++			dev_err(davinci_display_dev, "ran out of memory\n");
++			return -ENOMEM;
++		}
++
++		/* Initialize field of video device */
++		vbd->dev = *device;
++		vbd->release 		= video_device_release;
++		vbd->fops		= &vpbe_fops;
++		vbd->ioctl_ops		= &vpbe_ioctl_ops;
++		vbd->minor		= -1;
++		vbd->current_norm	= V4L2_STD_NTSC;
++
++		snprintf(vbd->name, sizeof(vbd->name),
++			 "DaVinci_VPBEDisplay_DRIVER_V%d.%d.%d",
++			 (DAVINCI_DISPLAY_VERSION_CODE >> 16)
++			 & 0xff,
++			 (DAVINCI_DISPLAY_VERSION_CODE >> 8) &
++			 0xff, (DAVINCI_DISPLAY_VERSION_CODE) & 0xff);
++		/* Set video_dev to the video device */
++		layer->video_dev = vbd;
++		layer->device_id = i;
++		layer->layer_info.id =
++		    ((i == DAVINCI_DISPLAY_DEVICE_0) ? WIN_VID0 : WIN_VID1);
++		if (display_buf_config_params.numbuffers[i] == 0)
++			layer->memory = V4L2_MEMORY_USERPTR;
++		else
++			layer->memory = V4L2_MEMORY_MMAP;
++		/* Initialize field of the layer objects */
++		layer->usrs = layer->io_usrs = 0;
++		layer->started = 0;
++
++		/* Initialize prio member of layer object */
++		v4l2_prio_init(&layer->prio);
++
++		/* register video device */
++		printk(KERN_NOTICE
++		       "Trying to register davinci display video device.\n");
++		printk(KERN_NOTICE "layer=%x,layer->video_dev=%x\n", (int)layer,
++		       (int)&layer->video_dev);
++
++		err = video_register_device(layer->
++					    video_dev,
++					    VFL_TYPE_GRABBER,
++					    davinci_display_nr[i]);
++		if (err)
++			goto probe_out;
++	}
++	/* Initialize mutex */
++	mutex_init(&davinci_dm.lock);
++	return 0;
++
++probe_out:
++	for (k = 0; k < j; k++) {
++		/* Get the pointer to the layer object */
++		layer = davinci_dm.dev[k];
++		/* Unregister video device */
++		video_unregister_device(layer->video_dev);
++		/* Release video device */
++		video_device_release(layer->video_dev);
++		layer->video_dev = NULL;
++	}
++	return err;
++}
++
++/*
++ * davinci_remove()
++ * It un-register hardware planes from V4L2 driver
++ */
++static int davinci_remove(struct device *device)
++{
++	int i;
++	struct display_obj *plane;
++	dev_dbg(davinci_display_dev, "<davinci_remove>\n");
++	/* un-register device */
++	for (i = 0; i < DAVINCI_DISPLAY_MAX_DEVICES; i++) {
++		/* Get the pointer to the layer object */
++		plane = davinci_dm.dev[i];
++		/* Unregister video device */
++		video_unregister_device(plane->video_dev);
++
++		plane->video_dev = NULL;
++	}
++
++	dev_dbg(davinci_display_dev, "</davinci_remove>\n");
++	return 0;
++}
++
++static struct device_driver davinci_driver = {
++	.name = DAVINCI_DISPLAY_DRIVER,
++	.bus = &platform_bus_type,
++	.probe = davinci_probe,
++	.remove = davinci_remove,
++};
++static struct platform_device _davinci_display_device = {
++	.name = DAVINCI_DISPLAY_DRIVER,
++	.id = 1,
++	.dev = {
++		.release = davinci_platform_release,
++		.coherent_dma_mask = DMA_BIT_MASK(32),
++		}
++};
++
++/*
++ * davinci_display_init()
++ * This function registers device and driver to the kernel, requests irq
++ * handler and allocates memory for layer objects
++ */
++static __init int davinci_display_init(void)
++{
++	int err = 0, i, j;
++	int free_layer_objects_index;
++	int free_buffer_layer_index;
++	int free_buffer_index;
++
++
++	printk(KERN_DEBUG "<davinci_display_init>\n");
++
++	/* Default number of buffers should be 3 */
++	if ((video2_numbuffers > 0) &&
++	    (video2_numbuffers < display_buf_config_params.min_numbuffers))
++		video2_numbuffers = display_buf_config_params.min_numbuffers;
++	if ((video3_numbuffers > 0) &&
++	    (video3_numbuffers < display_buf_config_params.min_numbuffers))
++		video3_numbuffers = display_buf_config_params.min_numbuffers;
++
++	/* Set buffer size to min buffers size if invalid buffer size is
++	 * given */
++	if (video2_bufsize <
++	    display_buf_config_params.min_bufsize[DAVINCI_DISPLAY_DEVICE_0])
++		video2_bufsize =
++		    display_buf_config_params.
++		    min_bufsize[DAVINCI_DISPLAY_DEVICE_0];
++
++	if (video3_bufsize <
++	    display_buf_config_params.min_bufsize[DAVINCI_DISPLAY_DEVICE_1])
++		video3_bufsize =
++		    display_buf_config_params.
++		    min_bufsize[DAVINCI_DISPLAY_DEVICE_1];
++
++	/* set number of buffers, they could come from boot/args */
++	display_buf_config_params.numbuffers[DAVINCI_DISPLAY_DEVICE_0] =
++		video2_numbuffers;
++	display_buf_config_params.numbuffers[DAVINCI_DISPLAY_DEVICE_1] =
++		video3_numbuffers;
++
++	if (cpu_is_davinci_dm355()) {
++		strcpy(davinci_display_videocap.card, DM355_EVM_CARD);
++	} else if (cpu_is_davinci_dm365())
++		strcpy(davinci_display_videocap.card, DM365_EVM_CARD);
++	else
++		strcpy(davinci_display_videocap.card, DM644X_EVM_CARD);
++
++
++	/* Allocate memory for four plane display objects */
++	for (i = 0; i < DAVINCI_DISPLAY_MAX_DEVICES; i++) {
++		davinci_dm.dev[i] =
++		    kmalloc(sizeof(struct display_obj), GFP_KERNEL);
++		/* If memory allocation fails, return error */
++		if (!davinci_dm.dev[i]) {
++			free_layer_objects_index = i;
++			printk(KERN_ERR "ran out of memory\n");
++			err = -ENOMEM;
++			goto davinci_init_free_layer_objects;
++		}
++		spin_lock_init(&davinci_dm.dev[i]->irqlock);
++	}
++	free_layer_objects_index = DAVINCI_DISPLAY_MAX_DEVICES;
++
++	if (display_buf_config_params.numbuffers[0] == 0)
++		printk(KERN_ERR "no vid2 buffer allocated\n");
++	if (display_buf_config_params.numbuffers[1] == 0)
++		printk(KERN_ERR "no vid3 buffer allocated\n");
++	free_buffer_layer_index = DAVINCI_DISPLAY_MAX_DEVICES;
++	free_buffer_index = display_buf_config_params.numbuffers[i - 1];
++	/* Register driver to the kernel */
++	err = driver_register(&davinci_driver);
++	if (0 != err)
++		goto davinci_init_free_layer_objects;
++
++	/* register device as a platform device to the kernel */
++	err = platform_device_register(&_davinci_display_device);
++	if (0 != err) {
++		goto davinci_init_unregister_driver;
++	}
++
++	davinci_dm.event_callback.mask = (DAVINCI_DISP_END_OF_FRAME |
++					  DAVINCI_DISP_FIRST_FIELD |
++					  DAVINCI_DISP_SECOND_FIELD);
++
++	davinci_dm.event_callback.arg = &davinci_dm;
++	davinci_dm.event_callback.handler = davinci_display_isr;
++
++	err = davinci_disp_register_callback(&davinci_dm.event_callback);
++
++	if (0 != err) {
++		goto davinci_init_unregister_driver;
++	}
++	printk(KERN_NOTICE
++	       "davinci_init:DaVinci V4L2 Display Driver V1.0 loaded\n");
++	printk(KERN_DEBUG "</davinci_init>\n");
++	return 0;
++
++davinci_init_unregister_driver:
++	driver_unregister(&davinci_driver);
++
++davinci_init_free_layer_objects:
++	for (j = 0; j < free_layer_objects_index; j++) {
++		if (davinci_dm.dev[i]) {
++			kfree(davinci_dm.dev[j]);
++			davinci_dm.dev[i] = NULL;
++		}
++	}
++	return err;
++}
++
++/*
++ * davinci_cleanup()
++ * This function un-registers device and driver to the kernel, frees requested
++ * irq handler and de-allocates memory allocated for layer objects.
++ */
++static void davinci_cleanup(void)
++{
++	int i = 0;
++	printk(KERN_INFO "<davinci_cleanup>\n");
++
++	davinci_disp_unregister_callback(&davinci_dm.event_callback);
++	platform_device_unregister(&_davinci_display_device);
++	driver_unregister(&davinci_driver);
++	for (i = 0; i < DAVINCI_DISPLAY_MAX_DEVICES; i++) {
++		if (davinci_dm.dev[i]) {
++			kfree(davinci_dm.dev[i]);
++			davinci_dm.dev[i] = NULL;
++		}
++	}
++	printk(KERN_INFO "</davinci_cleanup>\n");
++}
++
++EXPORT_SYMBOL(davinci_display_dev);
++MODULE_LICENSE("GPL");
++/* Function for module initialization and cleanup */
++module_init(davinci_display_init);
++module_exit(davinci_cleanup);
+--- /dev/null
++++ b/include/media/davinci/avnetlcd_encoder.h
+@@ -0,0 +1,55 @@
++/*
++ * Copyright (C) 2008 Texas Instruments Inc
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
++ */
++
++#ifndef AVNETLCD_ENCODER_H
++#define AVNETLCD_ENCODER_H
++
++#ifdef __KERNEL__
++/* Kernel Header files */
++#include <linux/i2c.h>
++#include <linux/device.h>
++#endif
++
++#ifdef __KERNEL__
++/* encoder standard related strctures */
++#define AVNETLCD_ENCODER_MAX_NO_OUTPUTS			(1)
++#define AVNETLCD_ENCODER_GRAPHICS_NUM_STD		(1)
++
++struct avnetlcd_encoder_params {
++	int outindex;
++	char *mode;
++};
++
++struct avnetlcd_encoder_config {
++	int no_of_outputs;
++	struct {
++		char *output_name;
++		int no_of_standard;
++		struct vid_enc_mode_info
++		 standards[AVNETLCD_ENCODER_GRAPHICS_NUM_STD];
++	} output[AVNETLCD_ENCODER_MAX_NO_OUTPUTS];
++};
++
++struct avnetlcd_encoder_channel {
++	struct encoder_device *enc_device;
++	struct avnetlcd_encoder_params params;
++};
++
++#endif				/* End of #ifdef __KERNEL__ */
++
++#endif				/* End of #ifndef AVNETLCD_ENCODER_H */
+--- /dev/null
++++ b/arch/arm/mach-davinci/include/mach/spi.h
+@@ -0,0 +1,51 @@
++/*
++ * Copyright 2009 Texas Instruments.
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
++ */
++
++#ifndef __ARCH_ARM_DAVINCI_SPI_H
++#define __ARCH_ARM_DAVINCI_SPI_H
++
++#define SPI_INTERN_CS	0xFF
++
++/* resource flags for IORESOURCE_DMA resources */
++#define IORESOURCE_DMA_RX_CHAN		0x01
++#define IORESOURCE_DMA_TX_CHAN		0x02
++#define IORESOURCE_DMA_EVENT_Q		0x04
++
++enum {
++	SPI_VERSION_1, /* For DM355/DM365/DM6467*/
++	SPI_VERSION_2, /* For DA8xx */
++};
++
++struct davinci_spi_platform_data {
++	u8	version;
++	u16	num_chipselect;
++	u32	wdelay;
++	u32	odd_parity;
++	u32	parity_enable;
++	u32	wait_enable;
++	u32	timer_disable;
++	u32	clk_internal;
++	u32	cs_hold;
++	u32	intr_level;
++	u32	poll_mode;
++	u32	use_dma;
++	u8	c2tdelay;
++	u8	t2cdelay;
++};
++
++#endif	/* __ARCH_ARM_DAVINCI_SPI_H */
+--- a/arch/arm/mach-davinci/Makefile
++++ b/arch/arm/mach-davinci/Makefile
+@@ -8,6 +8,7 @@ obj-y 			:= time.o clock.o serial.o io.o
+ 			   gpio.o dma.o usb.o common.o sram.o
+ 
+ obj-$(CONFIG_DAVINCI_MUX)		+= mux.o
++obj-$(CONFIG_PCI)			+= pci-generic.o
+ 
+ # Chip specific
+ obj-$(CONFIG_ARCH_DAVINCI_DM644x)       += dm644x.o devices.o
+@@ -17,6 +18,11 @@ obj-$(CONFIG_ARCH_DAVINCI_DM365)	+= dm36
+ obj-$(CONFIG_ARCH_DAVINCI_DA830)        += da830.o devices-da8xx.o
+ obj-$(CONFIG_ARCH_DAVINCI_DA850)        += da850.o devices-da8xx.o
+ 
++# PCI - Chip specific
++ifeq ($(CONFIG_PCI), y)
++obj-$(CONFIG_ARCH_DAVINCI_DM646x)	+= pci-dm646x.o
++endif
++
+ obj-$(CONFIG_AINTC)			+= irq.o
+ obj-$(CONFIG_CP_INTC)			+= cp_intc.o
+ 
+@@ -25,7 +31,7 @@ obj-$(CONFIG_MACH_DAVINCI_EVM)  	+= boar
+ obj-$(CONFIG_MACH_SFFSDR)		+= board-sffsdr.o
+ obj-$(CONFIG_MACH_DAVINCI_DM355_EVM)	+= board-dm355-evm.o
+ obj-$(CONFIG_MACH_DM355_LEOPARD)	+= board-dm355-leopard.o
+-obj-$(CONFIG_MACH_DAVINCI_DM6467_EVM)	+= board-dm646x-evm.o
++obj-$(CONFIG_MACH_DAVINCI_DM6467_EVM)	+= board-dm646x-evm.o cdce949.o
+ obj-$(CONFIG_MACH_DAVINCI_DM365_EVM)	+= board-dm365-evm.o
+ obj-$(CONFIG_MACH_DAVINCI_DA830_EVM)	+= board-da830-evm.o
+ obj-$(CONFIG_MACH_DAVINCI_DA850_EVM)	+= board-da850-evm.o
+--- /dev/null
++++ b/include/media/davinci/davinci_enc.h
+@@ -0,0 +1,248 @@
++/*
++ * Copyright (C) 2007 Texas Instruments Inc
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
++ *
++ *
++ * davinci_enc.h.
++ * This file contains APIs exported by Davinci Encoder Manager. Davinci Encoder
++ * manager uses the services from encoder interface for implementing it's
++ * functionality.
++ * It also configure the VENC/DLCD to support a specific video/graphics mode
++ * This interface allows set/get of output, mode , parameters and controls at
++ * the encoder. encoder may support multiple channels, each with a set of
++ * encoders So encoder manager support registration of encoders and APIs
++ * on a per channel basis.
++ */
++
++#ifndef DAVINCI_ENC_H
++#define DAVINCI_ENC_H
++
++#ifdef __KERNEL__
++#include <media/davinci/vid_encoder_types.h>
++
++/**
++ *  Maximum channels supported by encoder manager. Set to 1 for DM355 & DM6446.
++ * If a platform support multiple channel, this needs to be changed. Channel
++ * number starts with 0
++ */
++#define DAVINCI_ENC_MAX_CHANNELS	CONFIG_ENC_MNGR_MAX_CHANNELS
++
++/**
++ * function davinci_enc_setparams
++ * @params: pointer to params structure.
++ * @channel: channel number.
++ * Returns: Zero if successful, or non-zero otherwise
++ *
++ * Description:
++ *   Set parameters at current active encoder. params will be defined by
++ * the specific encoder and used by user space applications to set
++ * encoder parameters.
++ */
++int davinci_enc_setparams(int channel, void *params);
++
++/**
++ * function davinci_enc_getparams
++ * @params: pointer to params structure.
++ * @channel: channel number, 0 for first channel and so forth
++ * Returns: Zero if successful, or non-zero otherwise
++ *
++ * Description:
++ *   Get parameters at current active encoder. params will be defined by
++ * the specific encoder and used by user space applications to get
++ * encoder parameters.
++ */
++int davinci_enc_getparams(int channel, void *params);
++
++/**
++ * function davinci_enc_set_mode
++ * @channel: channel number.
++ * @mode_info: ptr to vid_enc_mode_info structure
++ * Returns: Zero if successful, or non-zero otherwise
++ *
++ * Description:
++ *   set standard or non-standard mode at current encoder's active output.
++ * Encoder Manager first configure the VENC or associated SoC hardware
++ * before calling the setmode() API of the encoder. To do so, encoder Manager
++ * calls the getmode() to get the mode_info for this mode and configure the
++ * mode based on the timing information present in this structure.
++ */
++int davinci_enc_set_mode(int channel, struct vid_enc_mode_info *mode_info);
++/**
++ * function davinci_enc_get_mode
++ * @channel: channel number, starting index 0.
++ * @mode_info: ptr to vid_enc_mode_info structure. This is updated by
++ * encoder manager
++ * Returns: Zero if successful, or non-zero otherwise
++ *
++ * Description:
++ *   get video or graphics mode at current encoder's active output.
++ *
++ */
++int davinci_enc_get_mode(int channel, struct vid_enc_mode_info *mode_info);
++
++/**
++ * function davinci_enc_set_control
++ * @channel: channel number.
++ * @ctrl: davinci_vid_enc_control type
++ * @val:  control value to be set
++ * Returns: Zero if successful, or non-zero otherwise
++ *
++ * Description:
++ *   Set controls at the current encoder's output.
++ *
++ */
++int davinci_enc_set_control(int channel, enum vid_enc_ctrl_id ctrl, char val);
++
++/**
++ * function davinci_enc_get_control
++ * @channel: channel number.
++ * @ctrl: control type as per davinci_vid_enc_ctrl_type
++ * @val:  ptr to value that gets updated
++ * Returns: Zero if successful, or non-zero otherwise
++ *
++ * Description:
++ *   Get controls at the current encoder's output.
++ *
++ */
++int davinci_enc_get_control(int channel, enum vid_enc_ctrl_id ctrl, char *val);
++
++/**
++ * function davinci_enc_set_output
++ * @channel: channel number.
++ * @output: ptr to output name string
++ * Returns: Zero if successful, or non-zero otherwise
++ *
++ * Description:
++ *   Set output - Set channel's output to the one identified by output string
++ * The encoder manager calls enumoutput() of each of the encoder to determine
++ * the encoder that supports this output and set this encoder as the current
++ * encoder. It calls setoutput() of the selected encoder. Encoder is expected
++ * to set a default mode on this output internally. Manager calls the getmode()
++ * to get information about the mode to configure the SoC hardware (VENC/DLCD
++ * for Davinci/DM355. During configuration of the SoC hardware for timing,
++ * mgr would call enable() to disable and re-enable the output of the encoder
++ * to avoid noise at the display. It may also call reset() to make sure the
++ * encoder is reset if required by the encoder hardware.
++ */
++int davinci_enc_set_output(int channel, char *output);
++
++/**
++ * function davinci_enc_get_output
++ * @channel: channel number.
++ * @output: ptr to array of char to hold output name. size
++ * VID_ENC_NAME_MAX_CHARS
++ * Returns: Zero if successful, or non-zero otherwise
++ *
++ * Description:
++ *   Get output - Get channel's output. User call this to get the current
++ *   output name
++ */
++int davinci_enc_get_output(int channel, char *output);
++
++/**
++ * function davinci_enc_reset
++ * @channel: channel number. DAVINCI_ENC_MAX_CHANNELS set to 1
++ * Returns: Zero if successful, or non-zero otherwise
++ *
++ * Description:
++ *  Do a software Reset the current encoder. Some of the encoders require this.
++ * This shouldn't affect the contents of the registers configured already for
++ * for output, standard, control etc. If there is no support, encoder doesn't
++ * implement this API.
++ */
++int davinci_enc_reset(int channel);
++
++/**
++ * function davinci_enc_enable_output
++ * @channel: channel number. DAVINCI_ENC_MAX_CHANNELS set to 1
++ * @flag: flag to indicate enable or disable, 0 - disable, 1 - enable
++ * Returns: Zero if successful, or non-zero otherwise
++ *
++ * Description:
++ *  Enable/Disable the current ouput. While the VPSS is configured for a
++ * video mode or graphics mode, you may observe noise on the display device
++ * due to timing changes. To avoid this, the output may be disabled during
++ * configuration of the VENC or related hardware in the VPSS and re-enabled
++ * using this API. This will switch the output DACs Off or On based on the
++ * flag.
++ */
++int davinci_enc_enable_output(int channel, int flag);
++
++/**
++ * davinci_enc_enable_vbi
++ * @flag: flag which tells whether to enable or disable raw vbi
++ * Returns: Zero if successful, or non-zero otherwise
++ *
++ * Description:
++ * This function is used to enable/disable RAW VBI sending in
++ * the encoder.
++ */
++int davinci_enc_enable_vbi(int channel, int flag);
++
++/**
++ * davinci_enc_enable_hbi
++ * @channel: channel number (0 to MAX_CHANNELS-1)
++ * @flag: flag which tells whether to enable or disable raw hbi
++ * Returns: Zero if successful, or non-zero otherwise
++ *
++ * Description:
++ * This function is used to enable/disable RAW HBI sending in
++ * the encoder.
++ */
++int davinci_enc_enable_hbi(int channel, int flag);
++
++/**
++ * davinci_enc_enable_sliced_vbi
++ * @channel: channel number.
++ * @encoder: pointer to the encoder device structure
++ * Returns: Zero if successful, or non-zero otherwise
++ *
++ * Description:
++ * Following funcion is used to enable support for
++ * sending set of sliced vbi services. Caller calls
++ * this function with pointer to the structure vid_enc_sliced_vbi_service
++ */
++int davinci_enc_enable_sliced_vbi(int channel,
++				  struct vid_enc_sliced_vbi_service *service);
++/**
++ * davinci_enc_enable_sliced_vbi
++ * @channel: channel number.
++ * @service: pointer to the structure vid_enc_sliced_vbi_service
++ * Returns: Zero if successful, or non-zero otherwise
++ *
++ * Description:
++ * Following funcion is used to enable support for
++ * sending set of sliced vbi services. Caller calls
++ * this function with pointer to the structure vid_enc_sliced_vbi_service
++ */
++int davinci_enc_get_sliced_cap(int channel,
++			       struct vid_enc_sliced_vbi_service *services);
++
++/**
++ * davinci_enc_write_sliced_vbi_data
++ * @channel: channel number.
++ * @data: pointer to the structure vid_enc_sliced_vbi_data
++ * Returns: Zero if successful, or non-zero otherwise
++ *
++ * Description:
++ * Register the encoder module with the encoder manager
++ * This is implemented by the encoder Manager
++ */
++int davinci_enc_write_sliced_vbi_data(int channel,
++				      struct vid_enc_sliced_vbi_data *data);
++
++#endif				/* #ifdef __KERNEL__ */
++#endif				/* #ifdef DAVINCI_ENC_H */
+--- /dev/null
++++ b/drivers/char/dm365_ipipe_hw.h
+@@ -0,0 +1,541 @@
++/*
++ * Copyright (C) 2008-2009 Texas Instruments Inc
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
++ */
++
++#ifndef _DM365_IPIPE_HW_H
++#define _DM365_IPIPE_HW_H
++
++#ifdef __KERNEL__
++
++#include <linux/kernel.h>
++#include <linux/io.h>
++
++#define IPIPE_IOBASE_VADDR 		IO_ADDRESS(0x01C70800)
++#define RSZ_IOBASE_VADDR		IO_ADDRESS(0x01C70400)
++#define IPIPE_INT_TABLE_IOBASE_VADDR	IO_ADDRESS(0x01C70000)
++
++#define SET_LOW_ADD     0x0000FFFF
++#define SET_HIGH_ADD    0xFFFF0000
++
++/* Below are the internal tables */
++#define DPC_TB0_START_ADDR	(0x8000)
++#define DPC_TB1_START_ADDR	(0x8400)
++
++#define GAMMA_R_START_ADDR     (0xA800)
++#define GAMMA_G_START_ADDR     (0xB000)
++#define GAMMA_B_START_ADDR     (0xB800)
++
++/* RAM table addresses for edge enhancement correction*/
++#define YEE_TB_START_ADDR	(0x8800)
++
++/* RAM table address for GBC LUT */
++#define GBCE_TB_START_ADDR	(0x9000)
++
++/* RAM table for 3D NF LUT */
++#define D3L_TB0_START_ADDR	(0x9800)
++#define D3L_TB1_START_ADDR	(0x9C00)
++#define D3L_TB2_START_ADDR	(0xA000)
++#define D3L_TB3_START_ADDR	(0xA400)
++
++/* IPIPE Register Offsets from the base address */
++#define IPIPE_SRC_EN 		(0x0000)
++#define IPIPE_SRC_MODE 		(0x0004)
++#define IPIPE_SRC_FMT 		(0x0008)
++#define IPIPE_SRC_COL		(0x000C)
++#define IPIPE_SRC_VPS		(0x0010)
++#define IPIPE_SRC_VSZ 		(0x0014)
++#define IPIPE_SRC_HPS		(0x0018)
++#define IPIPE_SRC_HSZ 		(0x001C)
++
++#define IPIPE_SEL_SBU 		(0x0020)
++
++#define IPIPE_DMA_STA		(0x0024)
++#define IPIPE_GCK_MMR 		(0x0028)
++#define IPIPE_GCK_PIX		(0x002C)
++#define IPIPE_RESERVED0		(0x0030)
++
++/* Defect Correction */
++#define DPC_LUT_EN		(0x0034)
++#define DPC_LUT_SEL		(0x0038)
++#define DPC_LUT_ADR		(0x003C)
++#define DPC_LUT_SIZ		(0x0040)
++#define DPC_OTF_EN		(0x0044)
++#define DPC_OTF_TYP		(0x0048)
++#define DPC_OTF_2D_THR_R	(0x004C)
++#define DPC_OTF_2D_THR_GR	(0x0050)
++#define DPC_OTF_2D_THR_GB	(0x0054)
++#define DPC_OTF_2D_THR_B	(0x0058)
++#define DPC_OTF_2C_THR_R	(0x005C)
++#define DPC_OTF_2C_THR_GR	(0x0060)
++#define DPC_OTF_2C_THR_GB	(0x0064)
++#define DPC_OTF_2C_THR_B	(0x0068)
++#define DPC_OTF_3_SHF		(0x006C)
++#define DPC_OTF_3D_THR		(0x0070)
++#define DPC_OTF_3D_SLP		(0x0074)
++#define DPC_OTF_3D_MIN		(0x0078)
++#define DPC_OTF_3D_MAX		(0x007C)
++#define DPC_OTF_3C_THR		(0x0080)
++#define DPC_OTF_3C_SLP		(0x0084)
++#define DPC_OTF_3C_MIN		(0x0088)
++#define DPC_OTF_3C_MAX		(0x008C)
++
++/* Lense Shading Correction */
++#define LSC_VOFT		(0x90)
++#define LSC_VA2			(0x94)
++#define LSC_VA1			(0x98)
++#define LSC_VS			(0x9C)
++#define LSC_HOFT		(0xA0)
++#define LSC_HA2			(0xA4)
++#define LSC_HA1			(0xA8)
++#define LSC_HS			(0xAC)
++#define LSC_GAIN_R		(0xB0)
++#define LSC_GAIN_GR		(0xB4)
++#define LSC_GAIN_GB		(0xB8)
++#define LSC_GAIN_B		(0xBC)
++#define LSC_OFT_R		(0xC0)
++#define LSC_OFT_GR		(0xC4)
++#define LSC_OFT_GB		(0xC8)
++#define LSC_OFT_B		(0xCC)
++#define LSC_SHF			(0xD0)
++#define LSC_MAX			(0xD4)
++
++/* Noise Filter 1. Ofsets from start address given */
++#define D2F_1ST			(0xD8)
++#define D2F_EN			(0x0)
++#define D2F_TYP			(0x4)
++#define D2F_THR			(0x8)
++#define D2F_STR			(0x28)
++#define D2F_SPR			(0x48)
++#define D2F_EDG_MIN		(0x68)
++#define D2F_EDG_MAX		(0x6C)
++
++/* Noise Filter 2 */
++#define D2F_2ND			(0x148)
++
++/* GIC */
++#define GIC_EN			(0x1B8)
++#define GIC_TYP			(0x1BC)
++#define GIC_GAN			(0x1C0)
++#define GIC_NFGAN		(0x1C4)
++#define GIC_THR			(0x1C8)
++#define GIC_SLP			(0x1CC)
++
++/* White Balance */
++#define WB2_OFT_R		(0x1D0)
++#define WB2_OFT_GR		(0x1D4)
++#define WB2_OFT_GB		(0x1D8)
++#define WB2_OFT_B		(0x1DC)
++#define WB2_WGN_R		(0x1E0)
++#define WB2_WGN_GR		(0x1E4)
++#define WB2_WGN_GB		(0x1E8)
++#define WB2_WGN_B		(0x1EC)
++
++/* CFA interpolation */
++#define CFA_MODE		(0x1F0)
++#define CFA_2DIR_HPF_THR	(0x1F4)
++#define CFA_2DIR_HPF_SLP	(0x1F8)
++#define CFA_2DIR_MIX_THR	(0x1FC)
++#define CFA_2DIR_MIX_SLP	(0x200)
++#define CFA_2DIR_DIR_THR	(0x204)
++#define CFA_2DIR_DIR_SLP	(0x208)
++#define CFA_2DIR_NDWT		(0x20C)
++#define CFA_MONO_HUE_FRA	(0x210)
++#define CFA_MONO_EDG_THR	(0x214)
++#define CFA_MONO_THR_MIN	(0x218)
++#define CFA_MONO_THR_SLP	(0x21C)
++#define CFA_MONO_SLP_MIN	(0x220)
++#define CFA_MONO_SLP_SLP	(0x224)
++#define CFA_MONO_LPWT		(0x228)
++
++/* RGB to RGB conversiona - 1st */
++#define RGB1_MUL_BASE		(0x22C)
++/* Offsets from base */
++#define RGB_MUL_RR		(0x0)
++#define RGB_MUL_GR		(0x4)
++#define RGB_MUL_BR		(0x8)
++#define RGB_MUL_RG		(0xC)
++#define RGB_MUL_GG		(0x10)
++#define RGB_MUL_BG		(0x14)
++#define RGB_MUL_RB		(0x18)
++#define RGB_MUL_GB		(0x1C)
++#define RGB_MUL_BB		(0x20)
++#define RGB_OFT_OR		(0x24)
++#define RGB_OFT_OG		(0x28)
++#define RGB_OFT_OB		(0x2C)
++
++/* Gamma */
++#define GMM_CFG			(0x25C)
++
++/* RGB to RGB conversiona - 2nd */
++#define RGB2_MUL_BASE		(0x260)
++
++/* 3D LUT */
++#define D3LUT_EN		(0x290)
++
++/* RGB to YUV(YCbCr) conversion */
++#define YUV_ADJ 		(0x294)
++#define YUV_MUL_RY 		(0x298)
++#define YUV_MUL_GY 		(0x29C)
++#define YUV_MUL_BY 		(0x2A0)
++#define YUV_MUL_RCB 		(0x2A4)
++#define YUV_MUL_GCB 		(0x2A8)
++#define YUV_MUL_BCB 		(0x2AC)
++#define YUV_MUL_RCR 		(0x2B0)
++#define YUV_MUL_GCR 		(0x2B4)
++#define YUV_MUL_BCR 		(0x2B8)
++#define YUV_OFT_Y 		(0x2BC)
++#define YUV_OFT_CB 		(0x2C0)
++#define YUV_OFT_CR 		(0x2C4)
++#define YUV_PHS 		(0x2C8)
++
++/* Global Brightness and Contrast */
++#define GBCE_EN			(0x2CC)
++#define GBCE_TYP		(0x2D0)
++
++/* Edge Enhancer */
++#define YEE_EN			(0x2D4)
++#define YEE_TYP			(0x2D8)
++#define YEE_SHF			(0x2DC)
++#define YEE_MUL_00		(0x2E0)
++#define YEE_MUL_01		(0x2E4)
++#define YEE_MUL_02		(0x2E8)
++#define YEE_MUL_10		(0x2EC)
++#define YEE_MUL_11		(0x2F0)
++#define YEE_MUL_12		(0x2F4)
++#define YEE_MUL_20		(0x2F8)
++#define YEE_MUL_21		(0x2FC)
++#define YEE_MUL_22		(0x300)
++#define YEE_THR			(0x304)
++#define YEE_E_GAN		(0x308)
++#define YEE_E_THR1		(0x30C)
++#define YEE_E_THR2		(0x310)
++#define YEE_G_GAN		(0x314)
++#define YEE_G_OFT		(0x318)
++
++/* Chroma Artifact Reduction */
++#define CAR_EN			(0x31C)
++#define CAR_TYP			(0x320)
++#define CAR_SW			(0x324)
++#define CAR_HPF_TYP		(0x328)
++#define CAR_HPF_SHF		(0x32C)
++#define	CAR_HPF_THR		(0x330)
++#define CAR_GN1_GAN		(0x334)
++#define CAR_GN1_SHF		(0x338)
++#define CAR_GN1_MIN		(0x33C)
++#define CAR_GN2_GAN		(0x340)
++#define CAR_GN2_SHF		(0x344)
++#define CAR_GN2_MIN		(0x348)
++
++/* Chroma Gain Suppression */
++#define CGS_EN			(0x34C)
++#define CGS_GN1_L_THR		(0x350)
++#define CGS_GN1_L_GAN		(0x354)
++#define CGS_GN1_L_SHF		(0x358)
++#define CGS_GN1_L_MIN		(0x35C)
++#define CGS_GN1_H_THR		(0x360)
++#define CGS_GN1_H_GAN		(0x364)
++#define CGS_GN1_H_SHF		(0x368)
++#define CGS_GN1_H_MIN		(0x36C)
++#define CGS_GN2_L_THR		(0x370)
++#define CGS_GN2_L_GAN		(0x374)
++#define CGS_GN2_L_SHF		(0x378)
++#define CGS_GN2_L_MIN		(0x37C)
++
++/* Resizer */
++#define RSZ_SRC_EN		(0x0)
++#define RSZ_SRC_MODE		(0x4)
++#define RSZ_SRC_FMT0		(0x8)
++#define RSZ_SRC_FMT1		(0xC)
++#define RSZ_SRC_VPS		(0x10)
++#define RSZ_SRC_VSZ		(0x14)
++#define RSZ_SRC_HPS		(0x18)
++#define RSZ_SRC_HSZ		(0x1C)
++#define RSZ_DMA_RZA		(0x20)
++#define RSZ_DMA_RZB		(0x24)
++#define RSZ_DMA_STA		(0x28)
++#define RSZ_GCK_MMR		(0x2C)
++#define RSZ_RESERVED0		(0x30)
++#define RSZ_GCK_SDR  		(0x34)
++#define RSZ_IRQ_RZA  		(0x38)
++#define RSZ_IRQ_RZB  		(0x3C)
++#define RSZ_YUV_Y_MIN		(0x40)
++#define RSZ_YUV_Y_MAX		(0x44)
++#define RSZ_YUV_C_MIN		(0x48)
++#define RSZ_YUV_C_MAX		(0x4C)
++#define RSZ_YUV_PHS  		(0x50)
++#define RSZ_SEQ			(0x54)
++
++/* Resizer Rescale Parameters */
++#define RSZ_EN_A		(0x58)
++#define RSZ_EN_B		(0xE8)
++/* offset of the registers to be added with base register of
++   either RSZ0 or RSZ1
++*/
++#define RSZ_MODE		(0x4)
++#define RSZ_420			(0x8)
++#define RSZ_I_VPS		(0xC)
++#define RSZ_I_HPS		(0x10)
++#define RSZ_O_VSZ		(0x14)
++#define RSZ_O_HSZ		(0x18)
++#define RSZ_V_PHS_Y		(0x1C)
++#define RSZ_V_PHS_C		(0x20)
++#define RSZ_V_DIF		(0x24)
++#define RSZ_V_TYP		(0x28)
++#define RSZ_V_LPF		(0x2C)
++#define RSZ_H_PHS		(0x30)
++#define RSZ_H_PHS_ADJ		(0x34)
++#define RSZ_H_DIF		(0x38)
++#define RSZ_H_TYP		(0x3C)
++#define RSZ_H_LPF		(0x40)
++#define RSZ_DWN_EN		(0x44)
++#define RSZ_DWN_AV		(0x48)
++
++/* Resizer RGB Conversion Parameters */
++#define RSZ_RGB_EN		(0x4C)
++#define RSZ_RGB_TYP		(0x50)
++#define RSZ_RGB_BLD		(0x54)
++
++/* Resizer External Memory Parameters */
++#define RSZ_SDR_Y_BAD_H		(0x58)
++#define RSZ_SDR_Y_BAD_L		(0x5C)
++#define RSZ_SDR_Y_SAD_H		(0x60)
++#define RSZ_SDR_Y_SAD_L		(0x64)
++#define RSZ_SDR_Y_OFT		(0x68)
++#define RSZ_SDR_Y_PTR_S		(0x6C)
++#define RSZ_SDR_Y_PTR_E		(0x70)
++#define RSZ_SDR_C_BAD_H		(0x74)
++#define RSZ_SDR_C_BAD_L		(0x78)
++#define RSZ_SDR_C_SAD_H		(0x7C)
++#define RSZ_SDR_C_SAD_L		(0x80)
++#define RSZ_SDR_C_OFT		(0x84)
++#define RSZ_SDR_C_PTR_S		(0x88)
++#define RSZ_SDR_C_PTR_E		(0x8C)
++
++/* Macro for resizer */
++#define IPIPE_RESIZER_A(i)  (RSZ_IOBASE_VADDR + RSZ_EN_A + i)
++#define IPIPE_RESIZER_B(i)  (RSZ_IOBASE_VADDR + RSZ_EN_B + i)
++
++#define RSZ_YUV_Y_MIN		(0x40)
++#define RSZ_YUV_Y_MAX		(0x44)
++#define RSZ_YUV_C_MIN		(0x48)
++#define RSZ_YUV_C_MAX		(0x4C)
++
++#define IPIPE_GCK_MMR_DEFAULT	(1)
++#define IPIPE_GCK_PIX_DEFAULT	(0xE)
++#define RSZ_GCK_MMR_DEFAULT	(1)
++#define RSZ_GCK_SDR_DEFAULT	(1)
++
++/* Below defines for masks and shifts */
++#define COLPAT_EE_SHIFT		(0)
++#define COLPAT_EO_SHIFT		(2)
++#define COLPAT_OE_SHIFT		(4)
++#define COLPAT_OO_SHIFT		(6)
++
++/* LUTDPC */
++#define LUTDPC_TBL_256_EN	(0 << 1)
++#define LUTDPC_INF_TBL_EN	(1)
++#define LUT_DPC_START_ADDR	(0)
++#define LUT_DPC_H_POS_MASK	(0x1FFF)
++#define LUT_DPC_V_POS_MASK	(0x1FFF)
++#define LUT_DPC_V_POS_SHIFT	(13)
++#define LUT_DPC_CORR_METH_SHIFT	(26)
++#define LUT_DPC_MAX_SIZE	(256)
++#define LUT_DPC_SIZE_MASK	(0x3FF)
++
++/* OTFDPC */
++#define OTFDPC_DPC2_THR_MASK	(0xFFF)
++#define OTF_DET_METHOD_SHIFT	(1)
++#define OTF_DPC3_0_SHF_MASK	(3)
++#define OTF_DPC3_0_THR_SHIFT	(6)
++#define OTF_DPC3_0_THR_MASK	(0x3F)
++#define OTF_DPC3_0_SLP_MASK	(0x3F)
++#define OTF_DPC3_0_DET_MASK	(0xFFF)
++#define OTF_DPC3_0_CORR_MASK	(0xFFF)
++
++/* NF (D2F) */
++#define D2F_SPR_VAL_MASK 		(0x1F)
++#define D2F_SPR_VAL_SHIFT 		(0)
++#define D2F_SHFT_VAL_MASK 		(3)
++#define D2F_SHFT_VAL_SHIFT 		(5)
++#define D2F_SAMPLE_METH_SHIFT		(7)
++#define D2F_APPLY_LSC_GAIN_SHIFT	(8)
++#define D2F_USE_SPR_REG_VAL		(0 << 9)
++#define D2F_STR_VAL_MASK		(0x1F)
++#define D2F_THR_VAL_MASK		(0x3FF)
++#define D2F_EDGE_DET_THR_MASK		(0x7FF)
++
++/* Green Imbalance Correction */
++#define GIC_TYP_SHIFT			(0)
++#define GIC_THR_SEL_SHIFT		(1)
++#define	GIC_APPLY_LSC_GAIN_SHIFT	(2)
++#define GIC_GAIN_MASK			(0xFF)
++#define GIC_THR_MASK			(0xFFF)
++#define GIC_SLOPE_MASK			(0xFFF)
++#define GIC_NFGAN_INT_MASK		(7)
++#define GIC_NFGAN_DECI_MASK		(0x1F)
++
++/* WB */
++#define WB_OFFSET_MASK			(0xFFF)
++#define WB_GAIN_INT_MASK		(0xF)
++#define WB_GAIN_DECI_MASK		(0x1FF)
++
++/* CFA */
++#define CFA_HPF_THR_2DIR_MASK		(0x1FFF)
++#define CFA_HPF_SLOPE_2DIR_MASK		(0x3FF)
++#define CFA_HPF_MIX_THR_2DIR_MASK	(0x1FFF)
++#define CFA_HPF_MIX_SLP_2DIR_MASK	(0x3FF)
++#define CFA_DIR_THR_2DIR_MASK		(0x3FF)
++#define CFA_DIR_SLP_2DIR_MASK		(0x7F)
++#define CFA_ND_WT_2DIR_MASK		(0x3F)
++#define CFA_DAA_HUE_FRA_MASK		(0x3F)
++#define CFA_DAA_EDG_THR_MASK		(0xFF)
++#define CFA_DAA_THR_MIN_MASK		(0x3FF)
++#define CFA_DAA_THR_SLP_MASK		(0x3FF)
++#define CFA_DAA_SLP_MIN_MASK		(0x3FF)
++#define CFA_DAA_SLP_SLP_MASK		(0x3FF)
++#define CFA_DAA_LP_WT_MASK		(0x3F)
++
++/* RGB2RGB */
++#define RGB2RGB_1_OFST_MASK		(0x1FFF)
++#define RGB2RGB_1_GAIN_INT_MASK		(0xF)
++#define RGB2RGB_GAIN_DECI_MASK		(0xFF)
++#define RGB2RGB_2_OFST_MASK		(0x7FF)
++#define RGB2RGB_2_GAIN_INT_MASK		(0x7)
++
++/* Gamma */
++#define GAMMA_BYPR_SHIFT		(0)
++#define GAMMA_BYPG_SHIFT		(1)
++#define GAMMA_BYPB_SHIFT		(2)
++#define GAMMA_TBL_SEL_SHIFT		(4)
++#define GAMMA_TBL_SIZE_SHIFT		(5)
++#define GAMMA_MASK			(0x3FF)
++#define GAMMA_SHIFT			(10)
++
++/* 3D LUT */
++#define D3_LUT_ENTRY_MASK		(0x3FF)
++#define D3_LUT_ENTRY_R_SHIFT		(20)
++#define D3_LUT_ENTRY_G_SHIFT		(10)
++#define D3_LUT_ENTRY_B_SHIFT		(0)
++
++/* Lumina adj */
++#define	LUM_ADJ_CONTR_SHIFT		(0)
++#define	LUM_ADJ_BRIGHT_SHIFT		(8)
++
++/* RGB2YCbCr */
++#define RGB2YCBCR_OFST_MASK		(0x7FF)
++#define RGB2YCBCR_COEF_INT_MASK		(0xF)
++#define RGB2YCBCR_COEF_DECI_MASK	(0xFF)
++
++/* GBCE */
++#define GBCE_Y_VAL_MASK			(0xFF)
++#define GBCE_GAIN_VAL_MASK		(0x3FF)
++#define GBCE_ENTRY_SHIFT		(10)
++
++/* Edge Enhancements */
++#define YEE_HALO_RED_EN_SHIFT		(1)
++#define YEE_HPF_SHIFT_MASK		(0xF)
++#define YEE_COEF_MASK			(0x3FF)
++#define YEE_THR_MASK			(0x3F)
++#define YEE_ES_GAIN_MASK		(0xFFF)
++#define YEE_ES_THR1_MASK		(0xFFF)
++#define YEE_ENTRY_SHIFT			(9)
++#define YEE_ENTRY_MASK			(0x1FF)
++
++/* CAR */
++#define CAR_MF_THR			(0xFF)
++#define CAR_SW1_SHIFT			(8)
++#define CAR_GAIN1_SHFT_MASK		(7)
++#define CAR_GAIN_MIN_MASK		(0x1FF)
++#define CAR_GAIN2_SHFT_MASK		(0xF)
++#define CAR_HPF_SHIFT_MASK		(3)
++
++/* CGS */
++#define CAR_SHIFT_MASK			(3)
++
++/* Resizer */
++#define RSZ_BYPASS_SHIFT		(1)
++#define RSZ_SRC_IMG_FMT_SHIFT		(1)
++#define RSZ_SRC_Y_C_SEL_SHIFT		(2)
++#define IPIPE_RSZ_VPS_MASK		(0xFFFF)
++#define IPIPE_RSZ_HPS_MASK		(0xFFFF)
++#define IPIPE_RSZ_VSZ_MASK		(0x1FFF)
++#define IPIPE_RSZ_HSZ_MASK		(0x1FFF)
++#define RSZ_HPS_MASK			(0x1FFF)
++#define RSZ_VPS_MASK			(0x1FFF)
++#define RSZ_O_HSZ_MASK			(0x1FFF)
++#define RSZ_O_VSZ_MASK			(0x1FFF)
++#define RSZ_V_PHS_MASK			(0x3FFF)
++#define RSZ_V_DIF_MASK			(0x3FFF)
++
++#define RSZA_H_FLIP_SHIFT		(0)
++#define RSZA_V_FLIP_SHIFT		(1)
++#define RSZB_H_FLIP_SHIFT		(2)
++#define RSZB_V_FLIP_SHIFT		(3)
++#define RSZ_A				(0)
++#define RSZ_B				(1)
++#define RSZ_CEN_SHIFT			(1)
++#define RSZ_YEN_SHIFT			(0)
++#define RSZ_TYP_Y_SHIFT			(0)
++#define RSZ_TYP_C_SHIFT			(1)
++#define RSZ_LPF_INT_MASK		(0x3F)
++#define RSZ_LPF_INT_MASK		(0x3F)
++#define RSZ_LPF_INT_C_SHIFT		(6)
++#define RSZ_H_PHS_MASK			(0x3FFF)
++#define RSZ_H_DIF_MASK			(0x3FFF)
++#define RSZ_DIFF_DOWN_THR		(256)
++#define RSZ_DWN_SCALE_AV_SZ_V_SHIFT	(3)
++#define RSZ_DWN_SCALE_AV_SZ_MASK	(7)
++#define RSZ_RGB_MSK1_SHIFT		(2)
++#define RSZ_RGB_MSK0_SHIFT		(1)
++#define RSZ_RGB_TYP_SHIFT		(0)
++#define RSZ_RGB_ALPHA_MASK		(0xFF)
++
++static inline u32 regr_ip(u32 offset)
++{
++	return __raw_readl(IPIPE_IOBASE_VADDR + offset);
++}
++
++static inline u32 regw_ip(u32 val, u32 offset)
++{
++	__raw_writel(val, IPIPE_IOBASE_VADDR + offset);
++	return val;
++}
++
++static inline u32 r_ip_table(u32 offset)
++{
++	return __raw_readl(IPIPE_INT_TABLE_IOBASE_VADDR + offset);
++}
++
++static inline u32 w_ip_table(u32 val, u32 offset)
++{
++	__raw_writel(val, IPIPE_INT_TABLE_IOBASE_VADDR + offset);
++	return val;
++}
++
++static inline u32 regr_rsz(u32 offset)
++{
++	return __raw_readl(RSZ_IOBASE_VADDR + offset);
++}
++
++static inline u32 regw_rsz(u32 val, u32 offset)
++{
++	__raw_writel(val, RSZ_IOBASE_VADDR + offset);
++	return val;
++}
++
++#endif /* End of #ifdef __KERNEL__ */
++#endif  /* End of #ifdef _DM365_IPIPE_HW_H */
+--- /dev/null
++++ b/drivers/rtc/rtc-davinci.c
+@@ -0,0 +1,703 @@
++/*
++ * DaVinci Power Management and Real Time Clock Driver for TI platforms
++ *
++ * Copyright (C) 2009 Texas Instruments, Inc
++ *
++ * Author: Miguel Aguilar <miguel.aguilar@ridgerun.com>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
++ */
++#include <linux/kernel.h>
++#include <linux/init.h>
++#include <linux/module.h>
++#include <linux/ioport.h>
++#include <linux/delay.h>
++#include <linux/spinlock.h>
++#include <linux/rtc.h>
++#include <linux/bcd.h>
++#include <linux/platform_device.h>
++#include <linux/io.h>
++
++/*
++ * The DaVinci RTC is a simple RTC with the following
++ * Sec: 0 - 59 : BCD count
++ * Min: 0 - 59 : BCD count
++ * Hour: 0 - 23 : BCD count
++ * Day: 0 - 0x7FFF(32767) : Binary count ( Over 89 years )
++ */
++
++/* PRTC interface registers */
++#define DAVINCI_PRTCIF_PID			0x00
++#define DAVINCI_PRTCIF_CTLR			0x04
++#define DAVINCI_PRTCIF_LDATA			0x08
++#define DAVINCI_PRTCIF_UDATA			0x0C
++#define DAVINCI_PRTCIF_INTEN			0x10
++#define DAVINCI_PRTCIF_INTFLG			0x14
++
++/* DAVINCI_PRTCIF_CTLR bit fields */
++#define DAVINCI_PRTCIF_CTLR_BUSY		BIT(31)
++#define DAVINCI_PRTCIF_CTLR_SIZE		BIT(25)
++#define DAVINCI_PRTCIF_CTLR_DIR			BIT(24)
++#define DAVINCI_PRTCIF_CTLR_BENU_MSB		BIT(23)
++#define DAVINCI_PRTCIF_CTLR_BENU_3RD_BYTE	BIT(22)
++#define DAVINCI_PRTCIF_CTLR_BENU_2ND_BYTE	BIT(21)
++#define DAVINCI_PRTCIF_CTLR_BENU_LSB		BIT(20)
++#define DAVINCI_PRTCIF_CTLR_BENU_MASK		(0x00F00000)
++#define DAVINCI_PRTCIF_CTLR_BENL_MSB		BIT(19)
++#define DAVINCI_PRTCIF_CTLR_BENL_3RD_BYTE	BIT(18)
++#define DAVINCI_PRTCIF_CTLR_BENL_2ND_BYTE	BIT(17)
++#define DAVINCI_PRTCIF_CTLR_BENL_LSB		BIT(16)
++#define DAVINCI_PRTCIF_CTLR_BENL_MASK		(0x000F0000)
++
++/* DAVINCI_PRTCIF_INTEN bit fields */
++#define DAVINCI_PRTCIF_INTEN_RTCSS		BIT(1)
++#define DAVINCI_PRTCIF_INTEN_RTCIF		BIT(0)
++#define DAVINCI_PRTCIF_INTEN_MASK		(DAVINCI_PRTCIF_INTEN_RTCSS \
++						| DAVINCI_PRTCIF_INTEN_RTCIF)
++
++/* DAVINCI_PRTCIF_INTFLG bit fields */
++#define DAVINCI_PRTCIF_INTFLG_RTCSS		BIT(1)
++#define DAVINCI_PRTCIF_INTFLG_RTCIF		BIT(0)
++#define DAVINCI_PRTCIF_INTFLG_MASK		(DAVINCI_PRTCIF_INTFLG_RTCSS \
++						| DAVINCI_PRTCIF_INTFLG_RTCIF)
++
++/* PRTC subsystem registers */
++#define DAVINCI_PRTCSS_RTC_INTC_EXTENA1		(0x0C)
++#define DAVINCI_PRTCSS_RTC_CTRL			(0x10)
++#define DAVINCI_PRTCSS_RTC_WDT			(0x11)
++#define DAVINCI_PRTCSS_RTC_TMR0			(0x12)
++#define DAVINCI_PRTCSS_RTC_TMR1			(0x13)
++#define DAVINCI_PRTCSS_RTC_CCTRL		(0x14)
++#define DAVINCI_PRTCSS_RTC_SEC			(0x15)
++#define DAVINCI_PRTCSS_RTC_MIN			(0x16)
++#define DAVINCI_PRTCSS_RTC_HOUR			(0x17)
++#define DAVINCI_PRTCSS_RTC_DAY0			(0x18)
++#define DAVINCI_PRTCSS_RTC_DAY1			(0x19)
++#define DAVINCI_PRTCSS_RTC_AMIN			(0x1A)
++#define DAVINCI_PRTCSS_RTC_AHOUR		(0x1B)
++#define DAVINCI_PRTCSS_RTC_ADAY0		(0x1C)
++#define DAVINCI_PRTCSS_RTC_ADAY1		(0x1D)
++#define DAVINCI_PRTCSS_RTC_CLKC_CNT		(0x20)
++
++/* DAVINCI_PRTCSS_RTC_INTC_EXTENA1 */
++#define DAVINCI_PRTCSS_RTC_INTC_EXTENA1_MASK	(0x07)
++
++/* DAVINCI_PRTCSS_RTC_CTRL bit fields */
++#define DAVINCI_PRTCSS_RTC_CTRL_WDTBUS		BIT(7)
++#define DAVINCI_PRTCSS_RTC_CTRL_WEN		BIT(6)
++#define DAVINCI_PRTCSS_RTC_CTRL_WDRT		BIT(5)
++#define DAVINCI_PRTCSS_RTC_CTRL_WDTFLG		BIT(4)
++#define DAVINCI_PRTCSS_RTC_CTRL_TE		BIT(3)
++#define DAVINCI_PRTCSS_RTC_CTRL_TIEN		BIT(2)
++#define DAVINCI_PRTCSS_RTC_CTRL_TMRFLG		BIT(1)
++#define DAVINCI_PRTCSS_RTC_CTRL_TMMD		BIT(0)
++
++/* DAVINCI_PRTCSS_RTC_CCTRL bit fields */
++#define DAVINCI_PRTCSS_RTC_CCTRL_CALBUSY	BIT(7)
++#define DAVINCI_PRTCSS_RTC_CCTRL_DAEN		BIT(5)
++#define DAVINCI_PRTCSS_RTC_CCTRL_HAEN		BIT(4)
++#define DAVINCI_PRTCSS_RTC_CCTRL_MAEN		BIT(3)
++#define DAVINCI_PRTCSS_RTC_CCTRL_ALMFLG		BIT(2)
++#define DAVINCI_PRTCSS_RTC_CCTRL_AIEN		BIT(1)
++#define DAVINCI_PRTCSS_RTC_CCTRL_CAEN		BIT(0)
++
++static DEFINE_SPINLOCK(davinci_rtc_lock);
++
++struct davinci_rtc {
++	struct rtc_device 		*rtc;
++	void __iomem			*base;
++	resource_size_t			pbase;
++	size_t				base_size;
++	int				irq;
++};
++
++static inline void davinci_rtcif_write(struct davinci_rtc *davinci_rtc,
++				       u32 val, u32 addr)
++{
++	writel(val, davinci_rtc->base + addr);
++}
++
++static inline u32 davinci_rtcif_read(struct davinci_rtc *davinci_rtc, u32 addr)
++{
++	return readl(davinci_rtc->base + addr);
++}
++
++static inline void davinci_rtcif_wait(struct davinci_rtc *davinci_rtc)
++{
++    while (davinci_rtcif_read(davinci_rtc, DAVINCI_PRTCIF_CTLR) &
++	       DAVINCI_PRTCIF_CTLR_BUSY)
++		cpu_relax();
++}
++
++static inline void davinci_rtcss_write(struct davinci_rtc *davinci_rtc,
++				unsigned long val, u8 addr)
++{
++	davinci_rtcif_wait(davinci_rtc);
++
++	davinci_rtcif_write(davinci_rtc, DAVINCI_PRTCIF_CTLR_BENL_LSB | addr,
++			    DAVINCI_PRTCIF_CTLR);
++	davinci_rtcif_write(davinci_rtc, val, DAVINCI_PRTCIF_LDATA);
++
++	davinci_rtcif_wait(davinci_rtc);
++}
++
++static inline u8 davinci_rtcss_read(struct davinci_rtc *davinci_rtc, u8 addr)
++{
++	davinci_rtcif_wait(davinci_rtc);
++
++	davinci_rtcif_write(davinci_rtc, DAVINCI_PRTCIF_CTLR_DIR |
++			    DAVINCI_PRTCIF_CTLR_BENL_LSB |
++			    addr, DAVINCI_PRTCIF_CTLR);
++
++	davinci_rtcif_wait(davinci_rtc);
++
++	return davinci_rtcif_read(davinci_rtc, DAVINCI_PRTCIF_LDATA);
++}
++
++static inline void davinci_rtcss_calendar_wait(struct davinci_rtc *davinci_rtc)
++{
++	while (davinci_rtcss_read(davinci_rtc, DAVINCI_PRTCSS_RTC_CCTRL) &
++	       DAVINCI_PRTCSS_RTC_CCTRL_CALBUSY)
++		cpu_relax();
++}
++
++static irqreturn_t davinci_rtc_interrupt(int irq, void *class_dev)
++{
++	struct davinci_rtc *davinci_rtc = class_dev;
++	unsigned long events = 0;
++	u32 irq_flg;
++	u8 alm_irq, tmr_irq;
++	u8 rtc_ctrl, rtc_cctrl;
++	int ret = IRQ_NONE;
++
++	irq_flg = davinci_rtcif_read(davinci_rtc, DAVINCI_PRTCIF_INTFLG) &
++		  DAVINCI_PRTCIF_INTFLG_RTCSS;
++
++	alm_irq = davinci_rtcss_read(davinci_rtc, DAVINCI_PRTCSS_RTC_CCTRL) &
++		  DAVINCI_PRTCSS_RTC_CCTRL_ALMFLG;
++
++	tmr_irq = davinci_rtcss_read(davinci_rtc, DAVINCI_PRTCSS_RTC_CTRL) &
++		  DAVINCI_PRTCSS_RTC_CTRL_TMRFLG;
++
++	if (irq_flg) {
++		if (alm_irq) {
++			events |= RTC_IRQF | RTC_AF;
++			rtc_cctrl = davinci_rtcss_read(davinci_rtc,
++						    DAVINCI_PRTCSS_RTC_CCTRL);
++			rtc_cctrl |=  DAVINCI_PRTCSS_RTC_CCTRL_ALMFLG;
++			davinci_rtcss_write(davinci_rtc, rtc_cctrl,
++					    DAVINCI_PRTCSS_RTC_CCTRL);
++		} else if (tmr_irq) {
++			events |= RTC_IRQF | RTC_PF;
++			rtc_ctrl = davinci_rtcss_read(davinci_rtc,
++						      DAVINCI_PRTCSS_RTC_CTRL);
++			rtc_ctrl |=  DAVINCI_PRTCSS_RTC_CTRL_TMRFLG;
++			davinci_rtcss_write(davinci_rtc, rtc_ctrl,
++					    DAVINCI_PRTCSS_RTC_CTRL);
++		}
++
++		davinci_rtcif_write(davinci_rtc, DAVINCI_PRTCIF_INTFLG_RTCSS,
++				    DAVINCI_PRTCIF_INTFLG);
++		rtc_update_irq(davinci_rtc->rtc, 1, events);
++		ret = IRQ_HANDLED;
++	}
++
++	return ret;
++}
++
++static int
++davinci_rtc_ioctl(struct device *dev, unsigned int cmd, unsigned long arg)
++{
++	struct davinci_rtc *davinci_rtc = dev_get_drvdata(dev);
++	u8 rtc_ctrl;
++	unsigned long flags;
++	int ret = 0;
++
++	spin_lock_irqsave(&davinci_rtc_lock, flags);
++
++	rtc_ctrl = davinci_rtcss_read(davinci_rtc, DAVINCI_PRTCSS_RTC_CTRL);
++
++	switch (cmd) {
++	case RTC_WIE_ON:
++		rtc_ctrl |= (DAVINCI_PRTCSS_RTC_CTRL_WEN |
++			    DAVINCI_PRTCSS_RTC_CTRL_WDTFLG);
++		break;
++	case RTC_WIE_OFF:
++		rtc_ctrl &= ~DAVINCI_PRTCSS_RTC_CTRL_WEN;
++		break;
++	case RTC_UIE_OFF:
++	case RTC_UIE_ON:
++		ret = -ENOTTY;
++		break;
++	default:
++		ret = -ENOIOCTLCMD;
++	}
++
++	davinci_rtcss_write(davinci_rtc, rtc_ctrl, DAVINCI_PRTCSS_RTC_CTRL);
++
++	spin_unlock_irqrestore(&davinci_rtc_lock, flags);
++
++	return ret;
++}
++
++static int convertfromdays(u16 days, struct rtc_time *tm)
++{
++	int tmp_days, year, mon;
++
++	for (year = 2000;; year++) {
++		tmp_days = rtc_year_days(1, 12, year);
++		if (days >= tmp_days)
++			days -= tmp_days;
++		else {
++			for (mon = 0;; mon++) {
++				tmp_days = rtc_month_days(mon, year);
++				if (days >= tmp_days) {
++					days -= tmp_days;
++				} else {
++					tm->tm_year = year - 1900;
++					tm->tm_mon = mon;
++					tm->tm_mday = days + 1;
++					break;
++				}
++			}
++			break;
++		}
++	}
++	return 0;
++}
++
++static int convert2days(u16 *days, struct rtc_time *tm)
++{
++	int i;
++	*days = 0;
++
++	/* epoch == 1900 */
++	if (tm->tm_year < 100 || tm->tm_year > 199)
++		return -EINVAL;
++
++	for (i = 2000; i < 1900 + tm->tm_year; i++)
++		*days += rtc_year_days(1, 12, i);
++
++	*days += rtc_year_days(tm->tm_mday, tm->tm_mon, 1900 + tm->tm_year);
++
++	return 0;
++}
++
++static int davinci_rtc_read_time(struct device *dev, struct rtc_time *tm)
++{
++	struct davinci_rtc *davinci_rtc = dev_get_drvdata(dev);
++	u16 days = 0;
++	u8 day0, day1;
++	unsigned long flags;
++
++	spin_lock_irqsave(&davinci_rtc_lock, flags);
++
++	davinci_rtcss_calendar_wait(davinci_rtc);
++	tm->tm_sec = bcd2bin(davinci_rtcss_read(davinci_rtc,
++						DAVINCI_PRTCSS_RTC_SEC));
++
++	davinci_rtcss_calendar_wait(davinci_rtc);
++	tm->tm_min = bcd2bin(davinci_rtcss_read(davinci_rtc,
++						DAVINCI_PRTCSS_RTC_MIN));
++
++	davinci_rtcss_calendar_wait(davinci_rtc);
++	tm->tm_hour = bcd2bin(davinci_rtcss_read(davinci_rtc,
++						 DAVINCI_PRTCSS_RTC_HOUR));
++
++	davinci_rtcss_calendar_wait(davinci_rtc);
++	day0 = davinci_rtcss_read(davinci_rtc, DAVINCI_PRTCSS_RTC_DAY0);
++
++	davinci_rtcss_calendar_wait(davinci_rtc);
++	day1 = davinci_rtcss_read(davinci_rtc, DAVINCI_PRTCSS_RTC_DAY1);
++
++	spin_unlock_irqrestore(&davinci_rtc_lock, flags);
++
++	days |= day1;
++	days <<= 8;
++	days |= day0;
++
++	if (convertfromdays(days, tm) < 0)
++		return -EINVAL;
++
++	return 0;
++}
++
++static int davinci_rtc_set_time(struct device *dev, struct rtc_time *tm)
++{
++	struct davinci_rtc *davinci_rtc = dev_get_drvdata(dev);
++	u16 days;
++	u8 rtc_cctrl;
++	unsigned long flags;
++
++	if (convert2days(&days, tm) < 0)
++		return -EINVAL;
++
++	spin_lock_irqsave(&davinci_rtc_lock, flags);
++
++	davinci_rtcss_calendar_wait(davinci_rtc);
++	davinci_rtcss_write(davinci_rtc, bin2bcd(tm->tm_sec),
++			    DAVINCI_PRTCSS_RTC_SEC);
++
++	davinci_rtcss_calendar_wait(davinci_rtc);
++	davinci_rtcss_write(davinci_rtc, bin2bcd(tm->tm_min),
++			    DAVINCI_PRTCSS_RTC_MIN);
++
++	davinci_rtcss_calendar_wait(davinci_rtc);
++	davinci_rtcss_write(davinci_rtc, bin2bcd(tm->tm_hour),
++			    DAVINCI_PRTCSS_RTC_HOUR);
++
++	davinci_rtcss_calendar_wait(davinci_rtc);
++	davinci_rtcss_write(davinci_rtc, days & 0xFF,
++			    DAVINCI_PRTCSS_RTC_DAY0);
++
++	davinci_rtcss_calendar_wait(davinci_rtc);
++	davinci_rtcss_write(davinci_rtc, (days & 0xFF00) >> 8,
++			    DAVINCI_PRTCSS_RTC_DAY1);
++
++	rtc_cctrl = davinci_rtcss_read(davinci_rtc, DAVINCI_PRTCSS_RTC_CCTRL);
++
++	rtc_cctrl |= DAVINCI_PRTCSS_RTC_CCTRL_CAEN;
++
++	davinci_rtcss_write(davinci_rtc, rtc_cctrl, DAVINCI_PRTCSS_RTC_CCTRL);
++
++	spin_unlock_irqrestore(&davinci_rtc_lock, flags);
++
++	return 0;
++}
++
++static int davinci_rtc_alarm_irq_enable(struct device *dev,
++					unsigned int enabled)
++{
++	struct davinci_rtc *davinci_rtc = dev_get_drvdata(dev);
++	unsigned long flags;
++	u8 rtc_cctrl = davinci_rtcss_read(davinci_rtc,
++					  DAVINCI_PRTCSS_RTC_CCTRL);
++
++	spin_lock_irqsave(&davinci_rtc_lock, flags);
++
++	if (enabled)
++		rtc_cctrl |= (DAVINCI_PRTCSS_RTC_CCTRL_DAEN |
++			      DAVINCI_PRTCSS_RTC_CCTRL_HAEN |
++			      DAVINCI_PRTCSS_RTC_CCTRL_MAEN |
++			      DAVINCI_PRTCSS_RTC_CCTRL_ALMFLG |
++			      DAVINCI_PRTCSS_RTC_CCTRL_AIEN);
++	else
++		rtc_cctrl &= ~DAVINCI_PRTCSS_RTC_CCTRL_AIEN;
++
++	davinci_rtcss_calendar_wait(davinci_rtc);
++	davinci_rtcss_write(davinci_rtc, rtc_cctrl, DAVINCI_PRTCSS_RTC_CCTRL);
++
++	spin_unlock_irqrestore(&davinci_rtc_lock, flags);
++
++	return 0;
++}
++
++static int davinci_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alm)
++{
++	struct davinci_rtc *davinci_rtc = dev_get_drvdata(dev);
++	u16 days = 0;
++	u8 day0, day1;
++	unsigned long flags;
++
++	spin_lock_irqsave(&davinci_rtc_lock, flags);
++
++	davinci_rtcss_calendar_wait(davinci_rtc);
++	alm->time.tm_min = bcd2bin(davinci_rtcss_read(davinci_rtc,
++				   DAVINCI_PRTCSS_RTC_AMIN));
++
++	davinci_rtcss_calendar_wait(davinci_rtc);
++	alm->time.tm_hour = bcd2bin(davinci_rtcss_read(davinci_rtc,
++				    DAVINCI_PRTCSS_RTC_AHOUR));
++
++	davinci_rtcss_calendar_wait(davinci_rtc);
++	day0 = davinci_rtcss_read(davinci_rtc, DAVINCI_PRTCSS_RTC_ADAY0);
++
++	davinci_rtcss_calendar_wait(davinci_rtc);
++	day1 = davinci_rtcss_read(davinci_rtc, DAVINCI_PRTCSS_RTC_ADAY1);
++
++	spin_unlock_irqrestore(&davinci_rtc_lock, flags);
++	days |= day1;
++	days <<= 8;
++	days |= day0;
++
++	if (convertfromdays(days, &alm->time) < 0)
++		return -EINVAL;
++
++	alm->pending = !!(davinci_rtcss_read(davinci_rtc,
++			  DAVINCI_PRTCSS_RTC_CCTRL) &
++			DAVINCI_PRTCSS_RTC_CCTRL_AIEN);
++	alm->enabled = alm->pending && device_may_wakeup(dev);
++
++	return 0;
++}
++
++static int davinci_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alm)
++{
++	struct davinci_rtc *davinci_rtc = dev_get_drvdata(dev);
++	unsigned long flags;
++	u16 days;
++
++	if (alm->time.tm_mday <= 0 && alm->time.tm_mon < 0
++	    && alm->time.tm_year < 0) {
++		struct rtc_time tm;
++		unsigned long now, then;
++
++		davinci_rtc_read_time(dev, &tm);
++		rtc_tm_to_time(&tm, &now);
++
++		alm->time.tm_mday = tm.tm_mday;
++		alm->time.tm_mon = tm.tm_mon;
++		alm->time.tm_year = tm.tm_year;
++		rtc_tm_to_time(&alm->time, &then);
++
++		if (then < now) {
++			rtc_time_to_tm(now + 24 * 60 * 60, &tm);
++			alm->time.tm_mday = tm.tm_mday;
++			alm->time.tm_mon = tm.tm_mon;
++			alm->time.tm_year = tm.tm_year;
++		}
++	}
++
++	if (convert2days(&days, &alm->time) < 0)
++		return -EINVAL;
++
++	spin_lock_irqsave(&davinci_rtc_lock, flags);
++
++	davinci_rtcss_calendar_wait(davinci_rtc);
++	davinci_rtcss_write(davinci_rtc, bin2bcd(alm->time.tm_min),
++			    DAVINCI_PRTCSS_RTC_AMIN);
++
++	davinci_rtcss_calendar_wait(davinci_rtc);
++	davinci_rtcss_write(davinci_rtc, bin2bcd(alm->time.tm_hour),
++			    DAVINCI_PRTCSS_RTC_AHOUR);
++
++	davinci_rtcss_calendar_wait(davinci_rtc);
++	davinci_rtcss_write(davinci_rtc, days & 0xFF,
++			    DAVINCI_PRTCSS_RTC_ADAY0);
++
++	davinci_rtcss_calendar_wait(davinci_rtc);
++	davinci_rtcss_write(davinci_rtc, (days & 0xFF00) >> 8,
++			    DAVINCI_PRTCSS_RTC_ADAY1);
++
++	spin_unlock_irqrestore(&davinci_rtc_lock, flags);
++
++	return 0;
++}
++
++static int davinci_rtc_irq_set_state(struct device *dev, int enabled)
++{
++	struct davinci_rtc *davinci_rtc = dev_get_drvdata(dev);
++	unsigned long flags;
++	u8 rtc_ctrl;
++
++	spin_lock_irqsave(&davinci_rtc_lock, flags);
++
++	rtc_ctrl = davinci_rtcss_read(davinci_rtc, DAVINCI_PRTCSS_RTC_CTRL);
++
++	if (enabled) {
++		while (davinci_rtcss_read(davinci_rtc, DAVINCI_PRTCSS_RTC_CTRL)
++		       & DAVINCI_PRTCSS_RTC_CTRL_WDTBUS)
++			cpu_relax();
++
++		rtc_ctrl |= DAVINCI_PRTCSS_RTC_CTRL_TE;
++		davinci_rtcss_write(davinci_rtc, rtc_ctrl,
++				    DAVINCI_PRTCSS_RTC_CTRL);
++
++		davinci_rtcss_write(davinci_rtc, 0x0,
++				    DAVINCI_PRTCSS_RTC_CLKC_CNT);
++		rtc_ctrl |= DAVINCI_PRTCSS_RTC_CTRL_TIEN |
++			    DAVINCI_PRTCSS_RTC_CTRL_TMMD |
++			    DAVINCI_PRTCSS_RTC_CTRL_TMRFLG;
++	} else
++		rtc_ctrl &= ~DAVINCI_PRTCSS_RTC_CTRL_TIEN;
++
++	davinci_rtcss_write(davinci_rtc, rtc_ctrl, DAVINCI_PRTCSS_RTC_CTRL);
++
++	spin_unlock_irqrestore(&davinci_rtc_lock, flags);
++
++	return 0;
++}
++
++static int davinci_rtc_irq_set_freq(struct device *dev, int freq)
++{
++	struct davinci_rtc *davinci_rtc = dev_get_drvdata(dev);
++	unsigned long flags;
++	u16 tmr_counter = (0x8000 >> (ffs(freq) - 1));
++
++	spin_lock_irqsave(&davinci_rtc_lock, flags);
++
++	davinci_rtcss_write(davinci_rtc, tmr_counter & 0xFF,
++			    DAVINCI_PRTCSS_RTC_TMR0);
++	davinci_rtcss_write(davinci_rtc, (tmr_counter & 0xFF00) >> 8,
++			    DAVINCI_PRTCSS_RTC_TMR1);
++
++	spin_unlock_irqrestore(&davinci_rtc_lock, flags);
++
++	return 0;
++}
++
++static struct rtc_class_ops davinci_rtc_ops = {
++	.ioctl			= davinci_rtc_ioctl,
++	.read_time		= davinci_rtc_read_time,
++	.set_time		= davinci_rtc_set_time,
++	.alarm_irq_enable	= davinci_rtc_alarm_irq_enable,
++	.read_alarm		= davinci_rtc_read_alarm,
++	.set_alarm		= davinci_rtc_set_alarm,
++	.irq_set_state		= davinci_rtc_irq_set_state,
++	.irq_set_freq		= davinci_rtc_irq_set_freq,
++};
++
++static int __init davinci_rtc_probe(struct platform_device *pdev)
++{
++	struct device *dev = &pdev->dev;
++	struct davinci_rtc *davinci_rtc;
++	struct resource *res, *mem;
++	int ret = 0;
++
++	davinci_rtc = kzalloc(sizeof(struct davinci_rtc), GFP_KERNEL);
++	if (!davinci_rtc) {
++		dev_dbg(dev, "could not allocate memory for private data\n");
++		return -ENOMEM;
++	}
++
++	davinci_rtc->irq = platform_get_irq(pdev, 0);
++	if (davinci_rtc->irq < 0) {
++		dev_err(dev, "no RTC irq\n");
++		ret = davinci_rtc->irq;
++		goto fail1;
++	}
++
++	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
++	if (!res) {
++		dev_err(dev, "no mem resource\n");
++		ret = -EINVAL;
++		goto fail1;
++	}
++
++	davinci_rtc->pbase = res->start;
++	davinci_rtc->base_size = resource_size(res);
++
++	mem = request_mem_region(davinci_rtc->pbase, davinci_rtc->base_size,
++				 pdev->name);
++	if (!mem) {
++		dev_err(dev, "RTC registers at %08x are not free\n",
++			davinci_rtc->pbase);
++		ret = -EBUSY;
++		goto fail1;
++	}
++
++	davinci_rtc->base = ioremap(davinci_rtc->pbase, davinci_rtc->base_size);
++	if (!davinci_rtc->base) {
++		dev_err(dev, "unable to ioremap MEM resource\n");
++		ret = -ENOMEM;
++		goto fail2;
++	}
++
++	davinci_rtc->rtc = rtc_device_register(pdev->name, &pdev->dev,
++				    &davinci_rtc_ops, THIS_MODULE);
++	if (IS_ERR(davinci_rtc->rtc)) {
++		dev_err(dev, "unable to register RTC device, err %ld\n",
++				PTR_ERR(davinci_rtc->rtc));
++		goto fail3;
++	}
++
++	davinci_rtcif_write(davinci_rtc, DAVINCI_PRTCIF_INTFLG_RTCSS,
++			    DAVINCI_PRTCIF_INTFLG);
++	davinci_rtcif_write(davinci_rtc, 0, DAVINCI_PRTCIF_INTEN);
++	davinci_rtcss_write(davinci_rtc, 0, DAVINCI_PRTCSS_RTC_INTC_EXTENA1);
++
++	davinci_rtcss_write(davinci_rtc, 0, DAVINCI_PRTCSS_RTC_CTRL);
++	davinci_rtcss_write(davinci_rtc, 0, DAVINCI_PRTCSS_RTC_CCTRL);
++
++	ret = request_irq(davinci_rtc->irq, davinci_rtc_interrupt,
++			  IRQF_DISABLED, "davinci_rtc", davinci_rtc);
++	if (ret < 0) {
++		dev_err(dev, "unable to register davinci RTC interrupt\n");
++		goto fail4;
++	}
++
++	/* Enable interrupts */
++	davinci_rtcif_write(davinci_rtc, DAVINCI_PRTCIF_INTEN_RTCSS,
++			    DAVINCI_PRTCIF_INTEN);
++	davinci_rtcss_write(davinci_rtc, DAVINCI_PRTCSS_RTC_INTC_EXTENA1_MASK,
++			    DAVINCI_PRTCSS_RTC_INTC_EXTENA1);
++
++	davinci_rtcss_write(davinci_rtc, DAVINCI_PRTCSS_RTC_CCTRL_CAEN,
++			    DAVINCI_PRTCSS_RTC_CCTRL);
++
++	platform_set_drvdata(pdev, davinci_rtc);
++
++	device_init_wakeup(&pdev->dev, 0);
++
++	return 0;
++
++fail4:
++	rtc_device_unregister(davinci_rtc->rtc);
++fail3:
++	iounmap(davinci_rtc->base);
++fail2:
++	release_mem_region(davinci_rtc->pbase, davinci_rtc->base_size);
++fail1:
++	kfree(davinci_rtc);
++
++	return ret;
++}
++
++static int __devexit davinci_rtc_remove(struct platform_device *pdev)
++{
++	struct davinci_rtc *davinci_rtc = platform_get_drvdata(pdev);
++
++	device_init_wakeup(&pdev->dev, 0);
++
++	davinci_rtcif_write(davinci_rtc, 0, DAVINCI_PRTCIF_INTEN);
++
++	free_irq(davinci_rtc->irq, davinci_rtc);
++
++	rtc_device_unregister(davinci_rtc->rtc);
++
++	iounmap(davinci_rtc->base);
++	release_mem_region(davinci_rtc->pbase, davinci_rtc->base_size);
++
++	platform_set_drvdata(pdev, NULL);
++
++	kfree(davinci_rtc);
++
++	return 0;
++}
++
++static struct platform_driver davinci_rtc_driver = {
++	.probe		= davinci_rtc_probe,
++	.remove		= __devexit_p(davinci_rtc_remove),
++	.driver		= {
++		.name = "rtc_davinci",
++		.owner = THIS_MODULE,
++	},
++};
++
++static int __init rtc_init(void)
++{
++	return platform_driver_probe(&davinci_rtc_driver, davinci_rtc_probe);
++}
++module_init(rtc_init);
++
++static void __exit rtc_exit(void)
++{
++	platform_driver_unregister(&davinci_rtc_driver);
++}
++module_exit(rtc_exit);
++
++MODULE_AUTHOR("Miguel Aguilar");
++MODULE_DESCRIPTION("Texas Instruments DaVinci PRTC Driver");
++MODULE_LICENSE("GPL");
+--- a/drivers/mmc/host/Makefile
++++ b/drivers/mmc/host/Makefile
+@@ -25,6 +25,7 @@ obj-$(CONFIG_MMC_ATMELMCI)	+= atmel-mci.
+ obj-$(CONFIG_MMC_TIFM_SD)	+= tifm_sd.o
+ obj-$(CONFIG_MMC_MSM7X00A)	+= msm_sdcc.o
+ obj-$(CONFIG_MMC_MVSDIO)	+= mvsdio.o
++obj-$(CONFIG_MMC_DAVINCI)       += davinci_mmc.o
+ obj-$(CONFIG_MMC_SPI)		+= mmc_spi.o
+ ifeq ($(CONFIG_OF),y)
+ obj-$(CONFIG_MMC_SPI)		+= of_mmc_spi.o
+--- /dev/null
++++ b/include/video/davinci_osd.h
+@@ -0,0 +1,910 @@
++/*
++ * Header file for the TI DaVinci On-Screen Display Manager
++ *
++ * Andy Lowe (alowe@mvista.com), MontaVista Software
++ *
++ * 2007 (c) MontaVista Software, Inc. This file is licensed under
++ * the terms of the GNU General Public License version 2. This program
++ * is licensed "as is" without any warranty of any kind, whether express
++ * or implied.
++ */
++
++#ifndef _DAVINCI_OSD_H
++#define _DAVINCI_OSD_H
++
++enum soc_type {
++	DM6446 = 0,
++	DM355,
++	DM365,
++};
++
++struct davinci_osd_platform_data {
++	enum soc_type type;
++};
++
++/**
++ * enum davinci_disp_layer
++ * @WIN_OSD0: On-Screen Display Window 0
++ * @WIN_VID0: Video Window 0
++ * @WIN_OSD1: On-Screen Display Window 1
++ * @WIN_VID1: Video Window 1
++ *
++ * Description:
++ * An enumeration of the DaVinci display layers.
++ */
++enum davinci_disp_layer {
++	WIN_OSD0,
++	WIN_VID0,
++	WIN_OSD1,
++	WIN_VID1,
++};
++
++/**
++ * enum davinci_osd_layer
++ * @OSDWIN_OSD0: On-Screen Display Window 0
++ * @OSDWIN_OSD1: On-Screen Display Window 1
++ *
++ * Description:
++ * An enumeration of the DaVinci OSD layers.
++ */
++enum davinci_osd_layer {
++	OSDWIN_OSD0,
++	OSDWIN_OSD1,
++};
++
++/**
++ * enum davinci_pix_format
++ * @PIXFMT_1BPP: 1-bit-per-pixel bitmap
++ * @PIXFMT_2BPP: 2-bits-per-pixel bitmap
++ * @PIXFMT_4BPP: 4-bits-per-pixel bitmap
++ * @PIXFMT_8BPP: 8-bits-per-pixel bitmap
++ * @PIXFMT_RGB565: 16-bits-per-pixel RGB565
++ * @PIXFMT_YCbCrI: YUV 4:2:2
++ * @PIXFMT_RGB888: 24-bits-per-pixel RGB888
++ * @PIXFMT_YCrCbI: YUV 4:2:2 with chroma swap
++ * @PIXFMT_NV12: YUV 4:2:0 planar
++ * @PIXFMT_OSD_ATTR: OSD Attribute Window pixel format (4bpp)
++ *
++ * Description:
++ * An enumeration of the DaVinci pixel formats.
++ */
++enum davinci_pix_format {
++	PIXFMT_1BPP = 0,
++	PIXFMT_2BPP,
++	PIXFMT_4BPP,
++	PIXFMT_8BPP,
++	PIXFMT_RGB565,
++	PIXFMT_YCbCrI,
++	PIXFMT_RGB888,
++	PIXFMT_YCrCbI,
++	PIXFMT_NV12,
++	PIXFMT_OSD_ATTR,
++};
++
++/**
++ * enum davinci_h_exp_ratio
++ * @H_EXP_OFF: no expansion (1/1)
++ * @H_EXP_9_OVER_8: 9/8 expansion ratio
++ * @H_EXP_3_OVER_2: 3/2 expansion ratio
++ *
++ * Description:
++ * An enumeration of the available horizontal expansion ratios.
++ */
++enum davinci_h_exp_ratio {
++	H_EXP_OFF,
++	H_EXP_9_OVER_8,
++	H_EXP_3_OVER_2,
++};
++
++/**
++ * enum davinci_v_exp_ratio
++ * @V_EXP_OFF: no expansion (1/1)
++ * @V_EXP_6_OVER_5: 6/5 expansion ratio
++ *
++ * Description:
++ * An enumeration of the available vertical expansion ratios.
++ */
++enum davinci_v_exp_ratio {
++	V_EXP_OFF,
++	V_EXP_6_OVER_5,
++};
++
++/**
++ * enum davinci_zoom_factor
++ * @ZOOM_X1: no zoom (x1)
++ * @ZOOM_X2: x2 zoom
++ * @ZOOM_X4: x4 zoom
++ *
++ * Description:
++ * An enumeration of the available zoom factors.
++ */
++enum davinci_zoom_factor {
++	ZOOM_X1,
++	ZOOM_X2,
++	ZOOM_X4,
++};
++
++/**
++ * enum davinci_clut
++ * @ROM_CLUT: ROM CLUT
++ * @RAM_CLUT: RAM CLUT
++ *
++ * Description:
++ * An enumeration of the available Color Lookup Tables (CLUTs).
++ */
++enum davinci_clut {
++	ROM_CLUT,
++	RAM_CLUT,
++};
++
++/**
++ * enum davinci_rom_clut
++ * @ROM_CLUT0: Macintosh CLUT
++ * @ROM_CLUT1: CLUT from DM270 and prior devices
++ *
++ * Description:
++ * An enumeration of the ROM Color Lookup Table (CLUT) options.
++ */
++enum davinci_rom_clut {
++	ROM_CLUT0,
++	ROM_CLUT1,
++};
++
++/**
++ * enum davinci_blending_factor
++ * @OSD_0_VID_8: OSD pixels are fully transparent
++ * @OSD_1_VID_7: OSD pixels contribute 1/8, video pixels contribute 7/8
++ * @OSD_2_VID_6: OSD pixels contribute 2/8, video pixels contribute 6/8
++ * @OSD_3_VID_5: OSD pixels contribute 3/8, video pixels contribute 5/8
++ * @OSD_4_VID_4: OSD pixels contribute 4/8, video pixels contribute 4/8
++ * @OSD_5_VID_3: OSD pixels contribute 5/8, video pixels contribute 3/8
++ * @OSD_6_VID_2: OSD pixels contribute 6/8, video pixels contribute 2/8
++ * @OSD_8_VID_0: OSD pixels are fully opaque
++ *
++ * Description:
++ * An enumeration of the DaVinci pixel blending factor options.
++ */
++enum davinci_blending_factor {
++	OSD_0_VID_8,
++	OSD_1_VID_7,
++	OSD_2_VID_6,
++	OSD_3_VID_5,
++	OSD_4_VID_4,
++	OSD_5_VID_3,
++	OSD_6_VID_2,
++	OSD_8_VID_0,
++};
++
++/**
++ * enum davinci_blink_interval
++ * @BLINK_X1: blink interval is 1 vertical refresh cycle
++ * @BLINK_X2: blink interval is 2 vertical refresh cycles
++ * @BLINK_X3: blink interval is 3 vertical refresh cycles
++ * @BLINK_X4: blink interval is 4 vertical refresh cycles
++ *
++ * Description:
++ * An enumeration of the DaVinci pixel blinking interval options.
++ */
++enum davinci_blink_interval {
++	BLINK_X1,
++	BLINK_X2,
++	BLINK_X3,
++	BLINK_X4,
++};
++
++/**
++ * enum davinci_cursor_h_width
++ * @H_WIDTH_1: horizontal line width is 1 pixel
++ * @H_WIDTH_4: horizontal line width is 4 pixels
++ * @H_WIDTH_8: horizontal line width is 8 pixels
++ * @H_WIDTH_12: horizontal line width is 12 pixels
++ * @H_WIDTH_16: horizontal line width is 16 pixels
++ * @H_WIDTH_20: horizontal line width is 20 pixels
++ * @H_WIDTH_24: horizontal line width is 24 pixels
++ * @H_WIDTH_28: horizontal line width is 28 pixels
++ */
++enum davinci_cursor_h_width {
++	H_WIDTH_1,
++	H_WIDTH_4,
++	H_WIDTH_8,
++	H_WIDTH_12,
++	H_WIDTH_16,
++	H_WIDTH_20,
++	H_WIDTH_24,
++	H_WIDTH_28,
++};
++
++/**
++ * enum davinci_cursor_v_width
++ * @V_WIDTH_1: vertical line width is 1 line
++ * @V_WIDTH_2: vertical line width is 2 lines
++ * @V_WIDTH_4: vertical line width is 4 lines
++ * @V_WIDTH_6: vertical line width is 6 lines
++ * @V_WIDTH_8: vertical line width is 8 lines
++ * @V_WIDTH_10: vertical line width is 10 lines
++ * @V_WIDTH_12: vertical line width is 12 lines
++ * @V_WIDTH_14: vertical line width is 14 lines
++ */
++enum davinci_cursor_v_width {
++	V_WIDTH_1,
++	V_WIDTH_2,
++	V_WIDTH_4,
++	V_WIDTH_6,
++	V_WIDTH_8,
++	V_WIDTH_10,
++	V_WIDTH_12,
++	V_WIDTH_14,
++};
++
++/**
++ * struct davinci_cursor_config
++ * @xsize: horizontal size in pixels
++ * @ysize: vertical size in lines
++ * @xpos: horizontal offset in pixels from the left edge of the display
++ * @ypos: vertical offset in lines from the top of the display
++ * @interlaced: Non-zero if the display is interlaced, or zero otherwise
++ * @h_width: horizontal line width
++ * @v_width: vertical line width
++ * @clut: the CLUT selector (ROM or RAM) for the cursor color
++ * @clut_index: an index into the CLUT for the cursor color
++ *
++ * Description:
++ * A structure describing the configuration parameters of the hardware
++ * rectangular cursor.
++ */
++struct davinci_cursor_config {
++	unsigned xsize;
++	unsigned ysize;
++	unsigned xpos;
++	unsigned ypos;
++	int interlaced;
++	enum davinci_cursor_h_width h_width;
++	enum davinci_cursor_v_width v_width;
++	enum davinci_clut clut;
++	unsigned char clut_index;
++};
++
++/**
++ * struct davinci_disp_callback
++ * @next: used internally by the display manager to maintain a liked list of
++ *        callbacks
++ * @mask: a bitmask specifying the display manager event(s) for which the
++ *        callback will be invoked
++ * @handler: the callback routine
++ * @arg: a null pointer that is passed as the second argument to the callback
++ *       routine
++ */
++struct davinci_disp_callback {
++	struct davinci_disp_callback *next;
++	unsigned mask;
++	void (*handler) (unsigned event, void *arg);
++	void *arg;
++};
++
++/* display manager events */
++#define DAVINCI_DISP_END_OF_FRAME	1
++#define DAVINCI_DISP_FIRST_FIELD	2
++#define DAVINCI_DISP_SECOND_FIELD	4
++
++/**
++ * struct davinci_layer_config
++ * @pixfmt: pixel format
++ * @line_length: offset in bytes between start of each line in memory
++ * @xsize: number of horizontal pixels displayed per line
++ * @ysize: number of lines displayed
++ * @xpos: horizontal offset in pixels from the left edge of the display
++ * @ypos: vertical offset in lines from the top of the display
++ * @interlaced: Non-zero if the display is interlaced, or zero otherwise
++ *
++ * Description:
++ * A structure describing the configuration parameters of an On-Screen Display
++ * (OSD) or video layer related to how the image is stored in memory.
++ * @line_length must be a multiple of the cache line size (32 bytes).
++ */
++struct davinci_layer_config {
++	enum davinci_pix_format pixfmt;
++	unsigned line_length;
++	unsigned xsize;
++	unsigned ysize;
++	unsigned xpos;
++	unsigned ypos;
++	int interlaced;
++};
++
++/**
++ * davinci_disp_request_layer
++ * @layer: layer id
++ * Returns: Zero if successful, or non-zero otherwise
++ *
++ * Description:
++ * Request to use an On-Screen Display (OSD) or video layer (window).
++ */
++int davinci_disp_request_layer(enum davinci_disp_layer layer);
++
++/**
++ * davinci_disp_release_layer
++ * @layer: layer id
++ *
++ * Description:
++ * Release a layer previously obtained via davinci_disp_request_layer().
++ */
++void davinci_disp_release_layer(enum davinci_disp_layer layer);
++
++/**
++ * davinci_disp_init_layer
++ * @layer: layer id
++ *
++ * Description:
++ * Initialize all parameters that are uniquely associated with the specified
++ * display layer to their default values.  Parameters that are common to
++ * multiple display layers (e.g. expansion ratios) are not affected.  The
++ * default state of a layer is disabled with X1 zoom.  The OSD layers default
++ * to 8-bits-per-pixel bitmap format, RAM CLUT, REC601 attenuation disabled,
++ * color key blending disabled, and are fully opaque.  Video layers maintain
++ * their current pixel format, either YCbCrI or YCrCbI, but will default to
++ * YCbCrI when first initialized.
++ * In general, it is not necessary for a display manager user to call this
++ * routine.  The display manager calls this routine automatically for every
++ * layer at initialization time and for an individual layer when the layer is
++ * released.
++ */
++void davinci_disp_init_layer(enum davinci_disp_layer layer);
++
++/**
++ * davinci_disp_enable_layer
++ * @layer: layer id
++ * Returns: Zero if successful, or non-zero otherwise
++ *
++ * Description:
++ * Enable a video layer so that it is displayed.
++ */
++int davinci_disp_enable_layer(enum davinci_disp_layer layer, int otherwin);
++
++/**
++ * davinci_disp_disable_layer
++ * @layer: layer id
++ *
++ * Description:
++ * Disable a video layer so that it is not displayed.
++ */
++void davinci_disp_disable_layer(enum davinci_disp_layer layer);
++
++/**
++ * davinci_disp_layer_is_enabled
++ * @layer: layer id
++ * Returns: 1 if the layer is enabled, or 0 otherwise
++ *
++ * Description:
++ * Determine whether or not a video layer is enabled..
++ */
++int davinci_disp_layer_is_enabled(enum davinci_disp_layer layer);
++
++/**
++ * davinci_disp_set_layer_config
++ * @layer: layer id
++ * @lconfig: a pointer to a davinci_layer_config structure
++ * Returns: 1 if the requested configuration is rejected, or 0 otherwise.
++ *          When the configuration is rejected, the value of @lconfig on
++ *          exit will be the current layer configuration.
++ *
++ * Description:
++ * Configure the parameters of an On-Screen Display (OSD) or video layer
++ * related to how the image is stored in memory.  On entry, the values of the
++ * members of the @lconfig struct specify the desired configuration.  On exit,
++ * the values of the members of the @lconfig struct will be updated to reflect
++ * the actual configuration, which is subject to the constraints of the
++ * DaVinci OSD controller.
++ */
++int davinci_disp_set_layer_config(enum davinci_disp_layer layer,
++				  struct davinci_layer_config *lconfig);
++
++/**
++ * davinci_disp_try_layer_config
++ * @layer: layer id
++ * @lconfig: a pointer to a davinci_layer_config structure
++ * Returns: 1 if the requested configuration is rejected, or 0 otherwise.
++ *          When the configuration is rejected, the value of @lconfig on
++ *          exit will be the current layer configuration.
++ *
++ * Description:
++ * Evaluate the parameters of an On-Screen Display (OSD) or video layer
++ * configuration.  On entry, the values of the members of the @lconfig struct
++ * specify the desired configuration.  On exit, the values of the members of the
++ * @lconfig struct will be updated to reflect the closest actual configuration
++ * which could currently be set and enabled subject to the constraints of the
++ * DaVinci OSD controller.  The actual layer configuration is not modified by
++ * this routine.
++ *
++ * Note that some of the constraints depend on the current configuration of
++ * other windows, so it is possible for a configuration returned by
++ * davinci_disp_try_layer_config() to fail to be set or enabled successfully
++ * if the configuration of other windows has changed.
++ */
++int davinci_disp_try_layer_config(enum davinci_disp_layer layer,
++				  struct davinci_layer_config *lconfig);
++
++/**
++ * davinci_disp_get_layer_config
++ * @layer: layer id
++ * @lconfig: a pointer to a davinci_layer_config structure
++ *
++ * Description:
++ * Get the parameters of an On-Screen Display (OSD) or video layer
++ * related to how the image is stored in memory.  On exit, the values of the
++ * members of the @lconfig struct will be updated to reflect the current
++ * configuration.
++ */
++void davinci_disp_get_layer_config(enum davinci_disp_layer layer,
++				   struct davinci_layer_config *lconfig);
++
++/**
++ * davinci_disp_start_layer
++ * @layer: layer id
++ * @fb_base_phys: physical base address of the framebuffer
++ *
++ * Description:
++ * Initialize the framebuffer base address \of an On-Screen Display (OSD) or
++ * video layer.  Display of the layer may be either enabled or disabled on
++ * entry and will be unchanged on exit.  @fb_base_phys must be cache-line
++ * (32-byte) aligned.
++ */
++void davinci_disp_start_layer(enum davinci_disp_layer layer,
++			      unsigned long fb_base_phys,
++			      unsigned long cbcr_ofst);
++
++/**
++ * davinci_disp_set_interpolation_filter
++ * @filter: non-zero to enable the interpolation filter, or zero to disable
++ *
++ * Description:
++ * Globally enable or disable the scaling (zoom and expansion) interpolation
++ * filter.  It applies to all OSD and video windows.
++ */
++void davinci_disp_set_interpolation_filter(int filter);
++
++/**
++ * davinci_disp_get_interpolation_filter
++ * Returns: 1 if the interpolation filter is enabled, or 0 otherwise
++ *
++ * Description:
++ * Get the enabled/disabled status of the scaling (zoom and expansion)
++ * interpolation filter.
++ */
++int davinci_disp_get_interpolation_filter(void);
++
++/**
++ * davinci_disp_set_osd_expansion
++ * @h_exp: the horizontal expansion ratio
++ * @v_exp: the vertical expansion ratio
++ * Returns: zero if successful, or non-zero otherwise
++ *
++ * Description:
++ * Configure the expansion ratio for the OSD windows.
++ */
++int davinci_disp_set_osd_expansion(enum davinci_h_exp_ratio h_exp,
++				   enum davinci_v_exp_ratio v_exp);
++
++/**
++ * davinci_disp_get_osd_expansion
++ * @h_exp: the horizontal expansion ratio
++ * @v_exp: the vertical expansion ratio
++ *
++ * Description:
++ * Get the expansion ratio for the OSD windows.
++ */
++void davinci_disp_get_osd_expansion(enum davinci_h_exp_ratio *h_exp,
++				    enum davinci_v_exp_ratio *v_exp);
++
++/**
++ * davinci_disp_set_vid_expansion
++ * @h_exp: the horizontal expansion ratio
++ * @v_exp: the vertical expansion ratio
++ * Returns: zero if successful, or non-zero otherwise
++ *
++ * Description:
++ * Configure the expansion ratio for the video windows.
++ */
++int davinci_disp_set_vid_expansion(enum davinci_h_exp_ratio h_exp,
++				   enum davinci_v_exp_ratio v_exp);
++
++/**
++ * davinci_disp_get_vid_expansion
++ * @h_exp: the horizontal expansion ratio
++ * @v_exp: the vertical expansion ratio
++ *
++ * Description:
++ * Get the expansion ratio for the video windows.
++ */
++void davinci_disp_get_vid_expansion(enum davinci_h_exp_ratio *h_exp,
++				    enum davinci_v_exp_ratio *v_exp);
++
++/**
++ * davinci_disp_set_zoom
++ * @layer: layer id
++ * @h_zoom: horizontal zoom factor
++ * @v_zoom: vertical zoom factor
++ *
++ * Description:
++ * Set the horizontal and vertical zoom factors.
++ */
++void davinci_disp_set_zoom(enum davinci_disp_layer layer,
++			   enum davinci_zoom_factor h_zoom,
++			   enum davinci_zoom_factor v_zoom);
++
++/**
++ * davinci_disp_get_zoom
++ * @layer: layer id
++ * @h_zoom: horizontal zoom factor
++ * @v_zoom: vertical zoom factor
++ *
++ * Description:
++ * Get the horizontal and vertical zoom factors.
++ */
++void davinci_disp_get_zoom(enum davinci_disp_layer layer,
++			   enum davinci_zoom_factor *h_zoom,
++			   enum davinci_zoom_factor *v_zoom);
++
++/**
++ * davinci_disp_set_background
++ * @clut: the CLUT selector
++ * @clut_index: an index into the CLUT
++ *
++ * Description:
++ * Set the background color that is displayed in any region not covered by one
++ * of the display layers.  The color is selected by specifying a Color Lookup
++ * Table (either ROM or RAM) and an index into the CLUT.
++ */
++void davinci_disp_set_background(enum davinci_clut clut,
++				 unsigned char clut_index);
++
++/**
++ * davinci_disp_get_background
++ * @clut: the CLUT selector
++ * @clut_index: an index into the CLUT
++ *
++ * Description:
++ * Get the background color that is displayed in any region not covered by one
++ * of the display layers.  The color is selected by specifying a Color Lookup
++ * Table (either ROM or RAM) and an index into the CLUT.
++ */
++void davinci_disp_get_background(enum davinci_clut *clut,
++				 unsigned char *clut_index);
++
++/**
++ * davinci_disp_set_rom_clut
++ * @rom_clut: the ROM CLUT selector
++ *
++ * Description:
++ * Choose which of the two ROM Color Lookup Tables will be used.
++ */
++void davinci_disp_set_rom_clut(enum davinci_rom_clut rom_clut);
++
++/**
++ * davinci_disp_get_rom_clut
++ * Returns: the ROM CLUT selector
++ *
++ * Description:
++ * Query which of the two ROM Color Lookup Tables is currently selected.
++ */
++enum davinci_rom_clut davinci_disp_get_rom_clut(void);
++
++/**
++ * davinci_disp_set_clut_ycbcr
++ * @clut_index: an index into the CLUT
++ * @y: Luma (Y) value
++ * @cb: Blue Chroma (Cb) value
++ * @cr: Red Chroma (Cr) value
++ *
++ * Description:
++ * Set a YCbCr value in the Color Lookup Table (CLUT).
++ */
++void davinci_disp_set_clut_ycbcr(unsigned char clut_index, unsigned char y,
++				 unsigned char cb, unsigned char cr);
++
++/**
++ * davinci_disp_set_clut_rgb
++ * @clut_index: an index into the CLUT
++ * @r: Red value
++ * @g: Green value
++ * @b: Blue value
++ *
++ * Description:
++ * Set an RGB value in the Color Lookup Table (CLUT).
++ */
++void davinci_disp_set_clut_rgb(unsigned char clut_index, unsigned char r,
++			       unsigned char g, unsigned char b);
++
++/**
++ * davinci_disp_set_osd_clut
++ * @osdwin: OSD0 or OSD1 layer id
++ * @clut: the CLUT selector
++ *
++ * Description:
++ * Select whether the RAM CLUT or the ROM CLUT is to be used for an OSD window.
++ * The selection is only significant if the window is using a 1-, 2-, 4-, or
++ * 8-bit pixel format.
++ */
++void davinci_disp_set_osd_clut(enum davinci_osd_layer osdwin,
++			       enum davinci_clut clut);
++
++/**
++ * davinci_disp_get_osd_clut
++ * @osdwin: OSD0 or OSD1 layer id
++ * Returns: the CLUT selector
++ *
++ * Description:
++ * Query whether the RAM CLUT or the ROM CLUT is currently selected for an OSD
++ * window.  The selection is only significant if the window is using a 1-, 2-,
++ * 4-, or 8-bit pixel format.
++ */
++enum davinci_clut davinci_disp_get_osd_clut(enum davinci_osd_layer osdwin);
++
++/**
++ * davinci_disp_enable_color_key
++ * @osdwin: OSD0 or OSD1 layer id
++ * @colorkey: the transparency color key
++ *
++ * Description:
++ * Enable transparency color key blending.  Any pixel in the specified OSD
++ * window which matches the color key will be transparent (or partially
++ * transparent) and allow the underlying video pixel to be displayed based on
++ * the blending factor.
++ *
++ * Interpretation of the @colorkey argument is determined by the pixel format
++ * assigned to the window.  The pixel format must be specified via
++ * davinci_disp_set_layer_config() before calling this routine.
++ *
++ * %PIXFMT_1BPP pixels matching @colorkey bit 0 are blended.
++ * %PIXFMT_2BPP pixels matching @colorkey bits 1-0 are blended.
++ * %PIXFMT_4BPP pixels matching @colorkey bits 3-0 are blended.
++ * %PIXFMT_8BPP pixels matching @colorkey bits 7-0 are blended.
++ * %PIXFMT_RGB565 pixels matching @colorkey bits 15-0 are blended.
++ * %PIXFMT_YCbCrI pixels with Luma (Y) matching @colorkey bits 15-8 are blended.
++ * %PIXFMT_RGB888 pixels matching @colorkey bits 23-0 are blended.
++ * %PIXFMT_YCrCbI pixels with Luma (Y) matching @colorkey bits 15-8 are blended.
++ * Color keying is not applicable to %PIXFMT_OSD_ATTR pixels.
++ *
++ * For DM644x processors, only the four %PIXFMT_nBPP pixel formats and
++ * %PIXFMT_RGB565 are supported.  The color key for the bitmap formats is fixed
++ * at zero on DM644x processors, so the value passed in the @colorkey argument
++ * is only significant for the %PIXFMT_RGB565 pixel format.
++ */
++void davinci_disp_enable_color_key(enum davinci_osd_layer osdwin,
++				   unsigned colorkey);
++
++/**
++ * davinci_disp_disable_color_key
++ * @osdwin: OSD0 or OSD1 layer id
++ *
++ * Description:
++ * Disable transparency color key blending for the specified OSD layer.  All
++ * pixels in the OSD window will be blended with video pixels according to the
++ * blending factor.
++ */
++void davinci_disp_disable_color_key(enum davinci_osd_layer osdwin);
++
++/**
++ * davinci_disp_set_blending_factor
++ * @osdwin: OSD0 or OSD1 layer id
++ * @blend: the blending factor
++ *
++ * Description:
++ * Set the blending factor for an OSD window.  The blending factor determines
++ * the degree of opacity or transparency of OSD pixels.  Transparent or
++ * partially transparent pixels allow the underlying video pixels to be
++ * displayed based on the blending factor.  All OSD pixels are blended unless
++ * color keying is enabled, in which case only pixels matching the color key
++ * are blended.
++ */
++void davinci_disp_set_blending_factor(enum davinci_osd_layer osdwin,
++				      enum davinci_blending_factor blend);
++
++/**
++ * davinci_disp_get_blending_factor
++ * @osdwin: OSD0 or OSD1 layer id
++ * Returns: the blending factor
++ *
++ * Description:
++ * Get the blending factor for an OSD window.
++ */
++enum davinci_blending_factor davinci_disp_get_blending_factor(enum
++							      davinci_osd_layer
++							      osdwin);
++
++/**
++ * davinci_disp_set_rec601_attenuation
++ * @osdwin: OSD0 or OSD1 layer id
++ * @enable: non-zero to enable REC601 attenuation, or zero to disable
++ *
++ * Description:
++ * Enable or disable REC601 attenuation of data in an OSD window.
++ */
++void davinci_disp_set_rec601_attenuation(enum davinci_osd_layer osdwin,
++					 int enable);
++
++/**
++ * davinci_disp_get_rec601_attenuation
++ * @osdwin: OSD0 or OSD1 layer id
++ * Returns: 1 if REC601 attenuation is enabled, or 0 otherwise
++ *
++ * Description:
++ * Get the REC601 attenuation status for an OSD window.
++ */
++int davinci_disp_get_rec601_attenuation(enum davinci_osd_layer osdwin);
++
++/**
++ * davinci_disp_set_palette_map
++ * @osdwin: OSD0 or OSD1 layer id
++ * @pixel_value: a bitmap pixel value
++ * @clut_index: an index into the CLUT
++ *
++ * Description:
++ * A 256-entry Color Lookup Table (CLUT) is used for bitmap pixel formats.
++ * Every entry in the CLUT is used when the color depth is 8 bits.  However,
++ * only a subset of the CLUT entries are needed for color depths of 1, 2,
++ * or 4 bits.  Each pixel value for color depths of 1, 2, or 4 bits can be
++ * mapped to any of the 256 CLUT entries.  Two CLUT entries are used for a
++ * color depth of 1 bit, four CLUT entries are used for a color depth of
++ * 2 bits, and sixteen CLUT entries are used for a color depth of 4 bits.
++ *
++ * Interpretation of the @pixel_value argument is determined by the pixel
++ * format assigned to the window.  The pixel format must be specified via
++ * davinci_disp_set_layer_config() before calling this routine.
++ */
++void davinci_disp_set_palette_map(enum davinci_osd_layer osdwin,
++				  unsigned char pixel_value,
++				  unsigned char clut_index);
++
++/**
++ * davinci_disp_get_palette_map
++ * @osdwin: OSD0 or OSD1 layer id
++ * @pixel_value: a bitmap pixel value
++ * Returns: an index into the CLUT
++ *
++ * Description:
++ * Given a pixel value, return the corresponding clut index from the palette
++ * map.
++ *
++ * Interpretation of the @pixel_value argument is determined by the pixel
++ * format assigned to the window.  The pixel format must be specified via
++ * davinci_disp_set_layer_config() before calling this routine.
++ */
++unsigned char davinci_disp_get_palette_map(enum davinci_osd_layer osdwin,
++				  unsigned char pixel_value);
++
++/**
++ * davinci_disp_set_blink_attribute
++ * @enable: non-zero to enable blinking, zero to disable
++ * @blink: the blinking interval
++ *
++ * Description:
++ * Set the blinking attributes when OSD1 is configured as an attribute window.
++ * If blinking is enabled, then OSD0 pixels which have their corresponding
++ * per-pixel blinking bit set in OSD1 will blink.  The blinking interval is a
++ * multiple of the vertical refresh interval.
++ */
++void davinci_disp_set_blink_attribute(int enable,
++				      enum davinci_blink_interval blink);
++
++/**
++ * davinci_disp_get_blink_attribute
++ * @enable: one if blinking is enabled, or zero if disabled
++ * @blink: the blinking interval
++ *
++ * Description:
++ * Get the blinking attributes when OSD1 is configured as an attribute window.
++ * If blinking is enabled, then OSD0 pixels which have their corresponding
++ * per-pixel blinking bit set in OSD1 will blink.  The blinking interval is a
++ * multiple of the vertical refresh interval.
++ */
++void davinci_disp_get_blink_attribute(int *enable,
++				      enum davinci_blink_interval *blink);
++
++/**
++ * davinci_disp_cursor_enable
++ *
++ * Description:
++ * Enable display of the hardware cursor.
++ */
++void davinci_disp_cursor_enable(void);
++
++/**
++ * davinci_disp_cursor_disable
++ *
++ * Description:
++ * Disable display of the hardware cursor.
++ */
++void davinci_disp_cursor_disable(void);
++
++/**
++ * davinci_disp_cursor_is_enabled
++ * Returns: 1 if cursor is enabled, or 0 otherwise
++ *
++ * Description:
++ * Query whether or not display of the hardware cursor is enabled.
++ */
++int davinci_disp_cursor_is_enabled(void);
++
++/**
++ * davinci_disp_set_cursor_config
++ * @cursor: the cursor configuration
++ *
++ * Description:
++ * Set the configuration (color, line width, position, and size) of the hardware
++ * rectangular cursor.
++ */
++void davinci_disp_set_cursor_config(struct davinci_cursor_config *cursor);
++
++/**
++ * davinci_disp_get_cursor_config
++ * @cursor: the cursor configuration
++ *
++ * Description:
++ * Get the configuration (color, line width, position, and size) of the hardware
++ * rectangular cursor.
++ */
++void davinci_disp_get_cursor_config(struct davinci_cursor_config *cursor);
++
++/**
++ * davinci_disp_set_field_inversion
++ * @enable: non-zero to enable field signal inversion, or zero to disable
++ *
++ * Description:
++ * Enable or disable field signal inversion, which inverts the polarity of the
++ * field ID signal from the video encoder.  This setting applies to all OSD and
++ * video windows.  It is only significant when the display is interlaced.
++ */
++void davinci_disp_set_field_inversion(int enable);
++
++/**
++ * davinci_disp_get_field_inversion
++ * Returns: 1 if field signal inversion is enabled, or 0 otherwise
++ *
++ * Description:
++ * Get the field signal inversion state.
++ */
++int davinci_disp_get_field_inversion(void);
++
++/**
++ * davinci_disp_register_callback
++ * @callback: a pointer to a davinci_disp_callback struct
++ * Returns: zero if successful, or non-zero otherwise
++ *
++ * Description:
++ * Register a callback routine for a DaVinci display manager event.
++ * @callback->handler is a pointer to the callback routine.  The first argument
++ * passed to the callback routine is the display manager event bitmask
++ * indicating which event(s) occurred.  The second argument passed to the
++ * callback routine is @callback->arg.  @callback->mask is a bitmask specifying
++ * the events for which the caller wishes to be notified.  @callback->next is
++ * used internally by the display manager and need not be initialized by the
++ * caller.  Once a callback routine has been registered, the caller must not
++ * modify the @callback struct until the callback has been unregistered.
++ *
++ * The display manager events are %DAVINCI_DISP_END_OF_FRAME,
++ * %DAVINCI_DISP_FIRST_FIELD, and %DAVINCI_DISP_SECOND_FIELD.
++ */
++int davinci_disp_register_callback(struct davinci_disp_callback *callback);
++
++/**
++ * davinci_disp_unregister_callback
++ * @callback: a pointer to a davinci_disp_callback struct
++ * Returns: zero if successful, or non-zero otherwise
++ *
++ * Description:
++ * Unregister a display manager callback routine previously registered with
++ * davinci_disp_register_callback().
++ */
++int davinci_disp_unregister_callback(struct davinci_disp_callback *callback);
++
++#ifdef __KERNEL__
++void osd_write_left_margin(u32 val);
++
++void osd_write_upper_margin(u32 val);
++
++u32 osd_read_left_margin(void);
++
++u32 osd_read_upper_margin(void);
++#endif
++
++#endif
+--- /dev/null
++++ b/arch/arm/mach-davinci/include/mach/pci.h
+@@ -0,0 +1,44 @@
++/*
++ * pci.h
++ *  Description:
++ *  Resource data for PCI host. Currently only has DM6467 specific information
++ *  since other DaVinci family SoCs do not have PCI Host support.
++ *
++ * Copyright (C) 2009 Texas Instruments Incorporated - http://www.ti.com/
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License as
++ * published by the Free Software Foundation version 2.
++ *
++ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
++ * kind, whether express or implied; without even the implied warranty
++ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ */
++#ifndef __MACH_PCI_H
++#define __MACH_PCI_H
++
++/* Enumeration flag: Checked during PCI Enumeration of Bridges */
++#define pcibios_assign_all_busses()     1
++
++/*
++ * PCI Resource allocation
++ */
++
++/* PCI IO window.
++ * This could be set anywhere in the 4G space by adjusting PCIBIOS_MIN_IO and
++ * PCIBIOS_MAX_IO, which, in turn are used by in/out macros to distinguish
++ * between PCI IO and normal MMIO.
++ */
++
++/* Using 32M reserved window from DM6467 memory map as PCI IO region */
++#define PCIBIOS_MIN_IO          	(0x4A000000)
++#define PCIBIOS_MAX_IO          	(0x4BFFFFFF)
++
++/* PCI Memory window base */
++#define PCIBIOS_MIN_MEM         	(0x30000000)
++
++/* PCI Control register base (backend) */
++#define PCICTL_REG_BASE			(0x01C1A000)
++
++#endif /* !__MACH_PCI_H */
+--- a/arch/arm/mach-davinci/usb.c
++++ b/arch/arm/mach-davinci/usb.c
+@@ -14,8 +14,10 @@
+ #include <mach/hardware.h>
+ #include <mach/irqs.h>
+ #include <mach/cputype.h>
++#include <mach/usb.h>
+ 
+-#define DAVINCI_USB_OTG_BASE 0x01C64000
++#define DAVINCI_USB_OTG_BASE	0x01c64000
++#define DA8XX_USB1_BASE 	0x01e25000
+ 
+ #if defined(CONFIG_USB_MUSB_HDRC) || defined(CONFIG_USB_MUSB_HDRC_MODULE)
+ static struct musb_hdrc_eps_bits musb_eps[] = {
+@@ -108,3 +110,36 @@ void __init setup_usb(unsigned mA, unsig
+ 
+ #endif  /* CONFIG_USB_MUSB_HDRC */
+ 
++#ifdef	CONFIG_ARCH_DAVINCI_DA8XX
++static struct resource da8xx_usb11_resources[] = {
++	[0] = {
++		.start	= DA8XX_USB1_BASE,
++		.end	= DA8XX_USB1_BASE + SZ_4K - 1,
++		.flags	= IORESOURCE_MEM,
++	},
++	[1] = {
++		.start	= IRQ_DA8XX_IRQN,
++		.end	= IRQ_DA8XX_IRQN,
++		.flags	= IORESOURCE_IRQ,
++	},
++};
++
++static u64 da8xx_usb11_dma_mask = DMA_BIT_MASK(32);
++
++static struct platform_device da8xx_usb11_device = {
++	.name		= "ohci",
++	.id		= 0,
++	.dev = {
++		.dma_mask		= &da8xx_usb11_dma_mask,
++		.coherent_dma_mask	= DMA_BIT_MASK(32),
++	},
++	.num_resources	= ARRAY_SIZE(da8xx_usb11_resources),
++	.resource	= da8xx_usb11_resources,
++};
++
++int __init da8xx_register_usb11(struct da8xx_ohci_root_hub *pdata)
++{
++	da8xx_usb11_device.dev.platform_data = pdata;
++	return platform_device_register(&da8xx_usb11_device);
++}
++#endif	/* CONFIG_DAVINCI_DA8XX */
+--- a/include/media/davinci/vpss.h
++++ b/include/media/davinci/vpss.h
+@@ -26,10 +26,23 @@
+ #ifndef _VPSS_H
+ #define _VPSS_H
+ 
++
+ /* selector for ccdc input selection on DM355 */
+ enum vpss_ccdc_source_sel {
+ 	VPSS_CCDCIN,
+-	VPSS_HSSIIN
++	VPSS_HSSIIN,
++	VPSS_PGLPBK,
++	VPSS_CCDCPG
++};
++
++struct vpss_sync_pol {
++	unsigned int ccdpg_hdpol:1;
++	unsigned int ccdpg_vdpol:1;
++};
++
++struct vpss_pg_frame_size {
++	short hlpfr;
++	short pplen;
+ };
+ 
+ /* Used for enable/diable VPSS Clock */
+@@ -47,12 +60,38 @@ enum vpss_clock_sel {
+ 	 */
+ 	VPSS_VENC_CLOCK_SEL,
+ 	VPSS_VPBE_CLOCK,
++	/* DM365 only clocks */
++	VPSS_IPIPEIF_CLOCK,
++	VPSS_RSZ_CLOCK,
++	VPSS_BL_CLOCK,
++	/*
++	 * When using VPSS_PCLK_INTERNAL in vpss_enable_clock() api
++	 * following applies:-
++	 * en = 0 disable internal PCLK
++	 * en = 1 enables internal PCLK
++	 */
++	VPSS_PCLK_INTERNAL,
++	/*
++	 * When using VPSS_PSYNC_CLOCK_SEL in vpss_enable_clock() api
++	 * following applies:-
++	 * en = 0 enables MMR clock
++	 * en = 1 enables VPSS clock
++	 */
++	VPSS_PSYNC_CLOCK_SEL,
++	VPSS_LDC_CLOCK_SEL,
++	VPSS_OSD_CLOCK_SEL,
++	VPSS_FDIF_CLOCK,
++	VPSS_LDC_CLOCK
+ };
+ 
+ /* select input to ccdc on dm355 */
+ int vpss_select_ccdc_source(enum vpss_ccdc_source_sel src_sel);
+ /* enable/disable a vpss clock, 0 - success, -1 - failure */
+ int vpss_enable_clock(enum vpss_clock_sel clock_sel, int en);
++/* set sync polarity, only applicable for DM365*/
++void vpss_set_sync_pol(struct vpss_sync_pol);
++/* set the PG_FRAME_SIZE register, only implemented for DM365 */
++void vpss_set_pg_frame_size(struct vpss_pg_frame_size);
+ 
+ /* wbl reset for dm644x */
+ enum vpss_wbl_sel {
+@@ -65,5 +104,43 @@ enum vpss_wbl_sel {
+ 	VPSS_PCR_PREV_WBL_0,
+ 	VPSS_PCR_CCDC_WBL_O,
+ };
++/* clear wbl overflow flag for DM6446 */
+ int vpss_clear_wbl_overflow(enum vpss_wbl_sel wbl_sel);
++
++enum dm355_int_mem_sel {
++	DM355_INT_MEM_IPIPE,
++	DM355_INT_MEM_CFALD,
++};
++void vpss_dm355_assign_int_memory_master(enum dm355_int_mem_sel master);
++
++enum dm355_dfc_mem_sel {
++	DM355_DFC_MEM_IPIPE,
++	DM355_DFC_MEM_CCDC,
++};
++void vpss_dm355_assign_dfc_memory_master(enum dm355_dfc_mem_sel master);
++
++enum dm355_rblctrl {
++	DM355_RBLCTRL_IPIPEIF,
++	DM355_RBLCTRL_CFALD,
++	DM355_RBLCTRL_H3A,
++};
++void vpss_dm355_assign_rblctrl_master(enum dm355_rblctrl master);
++
++enum dm355_wblctrl {
++	DM355_WBLCTRL_IPIPE,
++	DM355_WBLCTRL_CFALD,
++};
++void vpss_dm355_assign_wblctrl_master(enum dm355_wblctrl master);
++void vpss_dm355_ipipe_enable_any_address(int en);
++/**
++ * vpss_check_and_clear_interrupt - check and clear interrupt
++ * @irq - common enumerator for IRQ
++ *
++ * Following return values used:-
++ * 0 - interrupt occured and cleared
++ * 1 - interrupt not occured 
++ * 2 - interrupt status not available
++ */
++int vpss_dma_complete_interrupt(void);
++
+ #endif
+--- a/arch/arm/mach-davinci/devices.c
++++ b/arch/arm/mach-davinci/devices.c
+@@ -177,7 +177,7 @@ void __init davinci_setup_mmc(int module
+ 			mmcsd1_resources[0].start = DM365_MMCSD1_BASE;
+ 			mmcsd1_resources[0].end = DM365_MMCSD1_BASE +
+ 							SZ_4K - 1;
+-			mmcsd0_resources[2].start = IRQ_DM365_SDIOINT1;
++			mmcsd1_resources[2].start = IRQ_DM365_SDIOINT1;
+ 		} else
+ 			break;
+ 
+--- /dev/null
++++ b/drivers/char/dm365_ipipe_hw.c
+@@ -0,0 +1,1192 @@
++/*
++ * Copyright (C) 2008-2009 Texas Instruments Inc
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
++ */
++
++#include <linux/errno.h>
++#include <linux/delay.h>
++#include <linux/device.h>
++#include <media/davinci/dm365_ipipe.h>
++#include <media/davinci/dm3xx_ipipe.h>
++#include "dm365_ipipe_hw.h"
++
++static void ipipe_clock_enable(void)
++{
++	/* enable IPIPE MMR for register write access */
++	regw_ip(IPIPE_GCK_MMR_DEFAULT, IPIPE_GCK_MMR);
++	/* enable the clock wb,cfa,dfc,d2f,pre modules */
++	regw_ip(IPIPE_GCK_PIX_DEFAULT, IPIPE_GCK_PIX);
++	/* enable RSZ MMR for register write access */
++}
++
++
++#ifdef CONFIG_IMP_DEBUG
++void ipipe_hw_dump_config(void)
++{
++	u32 utemp;
++
++	ipipeif_dump_register();
++	utemp = regr_ip(IPIPE_SRC_EN);
++	printk(KERN_NOTICE "IPIPE_SRC_EN = 0x%x\n", utemp);
++	utemp = regr_ip(IPIPE_SRC_MODE);
++	printk(KERN_NOTICE "IPIPE_SRC_MODE = 0x%x\n", utemp);
++	utemp = regr_ip(IPIPE_SRC_FMT);
++	printk(KERN_NOTICE "IPIPE_SRC_FMT = 0x%x\n", utemp);
++	utemp = regr_ip(IPIPE_SRC_COL);
++	printk(KERN_NOTICE "IPIPE_SRC_COL = 0x%x\n", utemp);
++	utemp = regr_ip(IPIPE_SRC_VPS);
++	printk(KERN_NOTICE "IPIPE_SRC_VPS = 0x%x\n", utemp);
++	utemp = regr_ip(IPIPE_SRC_VSZ);
++	printk(KERN_NOTICE "IPIPE_SRC_VSZ = 0x%x\n", utemp);
++	utemp = regr_ip(IPIPE_SRC_HPS);
++	printk(KERN_NOTICE "IPIPE_SRC_HPS = 0x%x\n", utemp);
++	utemp = regr_ip(IPIPE_SRC_HSZ);
++	printk(KERN_NOTICE "IPIPE_SRC_HSZ = 0x%x\n", utemp);
++	utemp = regr_ip(IPIPE_SEL_SBU);
++	printk(KERN_NOTICE "IPIPE_SEL_SBU = 0x%x\n", utemp);
++	utemp = regr_ip(IPIPE_DMA_STA);
++	printk(KERN_NOTICE "IPIPE_DMA_STA = 0x%x\n", utemp);
++	utemp = regr_ip(IPIPE_GCK_MMR);
++	printk(KERN_NOTICE "IPIPE_GCK_MMR = 0x%x\n", utemp);
++	utemp = regr_ip(IPIPE_GCK_PIX);
++	printk(KERN_NOTICE "IPIPE_GCK_PIX = 0x%x\n", utemp);
++	printk(KERN_NOTICE "Resizer Registers\n");
++	printk(KERN_NOTICE
++	       "**************************************************\n");
++	utemp = regr_rsz(RSZ_SRC_EN);
++	printk(KERN_NOTICE "RSZ_SRC_EN = 0x%x\n", utemp);
++	utemp = regr_rsz(RSZ_SRC_MODE);
++	printk(KERN_NOTICE "RSZ_SRC_MODE = 0x%x\n", utemp);
++	utemp = regr_rsz(RSZ_SRC_FMT0);
++	printk(KERN_NOTICE "RSZ_SRC_FMT0 = 0x%x\n", utemp);
++	utemp = regr_rsz(RSZ_SRC_FMT1);
++	printk(KERN_NOTICE "RSZ_SRC_FMT1 = 0x%x\n", utemp);
++	utemp = regr_rsz(RSZ_SRC_VPS);
++	printk(KERN_NOTICE "RSZ_SRC_VPS = 0x%x\n", utemp);
++	utemp = regr_rsz(RSZ_SRC_VSZ);
++	printk(KERN_NOTICE "RSZ_SRC_VSZ = 0x%x\n", utemp);
++	utemp = regr_rsz(RSZ_SRC_HPS);
++	printk(KERN_NOTICE "RSZ_SRC_HPS = 0x%x\n", utemp);
++	utemp = regr_rsz(RSZ_SRC_HSZ);
++	printk(KERN_NOTICE "RSZ_SRC_HSZ = 0x%x\n", utemp);
++	utemp = regr_rsz(RSZ_DMA_RZA);
++	printk(KERN_NOTICE "RSZ_DMA_RZA = 0x%x\n", utemp);
++	utemp = regr_rsz(RSZ_DMA_RZB);
++	printk(KERN_NOTICE "RSZ_DMA_RZB = 0x%x\n", utemp);
++	utemp = regr_rsz(RSZ_DMA_STA);
++	printk(KERN_NOTICE "RSZ_DMA_STA = 0x%x\n", utemp);
++	utemp = regr_rsz(RSZ_GCK_MMR);
++	printk(KERN_NOTICE "RSZ_GCK_MMR = 0x%x\n", utemp);
++	utemp = regr_rsz(RSZ_GCK_SDR);
++	printk(KERN_NOTICE "RSZ_GCK_SDR = 0x%x\n", utemp);
++	utemp = regr_rsz(RSZ_IRQ_RZA);
++	printk(KERN_NOTICE "RSZ_IRQ_RZA = 0x%x\n", utemp);
++	utemp = regr_rsz(RSZ_IRQ_RZB);
++	printk(KERN_NOTICE "RSZ_IRQ_RZB = 0x%x\n", utemp);
++	utemp = regr_rsz(RSZ_YUV_Y_MIN);
++	printk(KERN_NOTICE "RSZ_YUV_Y_MIN = 0x%x\n", utemp);
++	utemp = regr_rsz(RSZ_YUV_Y_MAX);
++	printk(KERN_NOTICE "RSZ_YUV_Y_MAX = 0x%x\n", utemp);
++	utemp = regr_rsz(RSZ_YUV_C_MIN);
++	printk(KERN_NOTICE "RSZ_YUV_C_MIN = 0x%x\n", utemp);
++	utemp = regr_rsz(RSZ_YUV_C_MAX);
++	printk(KERN_NOTICE "RSZ_YUV_C_MAX = 0x%x\n", utemp);
++	utemp = regr_rsz(RSZ_YUV_PHS);
++	printk(KERN_NOTICE "RSZ_YUV_PHS = 0x%x\n", utemp);
++	utemp = regr_rsz(RSZ_SEQ);
++	printk(KERN_NOTICE "RSZ_SEQ = 0x%x\n", utemp);
++
++	/* Resize - A registers */
++	utemp = regr_rsz((RSZ_EN_A));
++	printk(KERN_NOTICE "RSZ A EN = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_A + RSZ_MODE));
++	printk(KERN_NOTICE "RSZ A MODE = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_A + RSZ_420));
++	printk(KERN_NOTICE "RSZ A 420 = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_A + RSZ_I_VPS));
++	printk(KERN_NOTICE "RSZ A I_VPS = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_A + RSZ_I_HPS));
++	printk(KERN_NOTICE "RSZ A I_HPS = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_A + RSZ_O_VSZ));
++	printk(KERN_NOTICE "RSZ A O_VSZ = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_A + RSZ_O_HSZ));
++	printk(KERN_NOTICE "RSZ A O_HSZ = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_A + RSZ_V_PHS_Y));
++	printk(KERN_NOTICE "RSZ A V_PHS_Y = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_A + RSZ_V_PHS_C));
++	printk(KERN_NOTICE "RSZ A V_PHS_C = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_A + RSZ_V_DIF));
++	printk(KERN_NOTICE "RSZ A V_DIF = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_A + RSZ_V_TYP));
++	printk(KERN_NOTICE "RSZ A V_TYP = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_A + RSZ_V_LPF));
++	printk(KERN_NOTICE "RSZ A V_LPF = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_A + RSZ_H_PHS));
++	printk(KERN_NOTICE "RSZ A H_PHS = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_A + RSZ_H_PHS_ADJ));
++	printk(KERN_NOTICE "RSZ A H_PHS_ADJ = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_A + RSZ_H_DIF));
++	printk(KERN_NOTICE "RSZ A H_DIF = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_A + RSZ_H_TYP));
++	printk(KERN_NOTICE "RSZ A H_TYP = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_A + RSZ_H_LPF));
++	printk(KERN_NOTICE "RSZ A H_LPF = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_A + RSZ_DWN_EN));
++	printk(KERN_NOTICE "RSZ A DWN_EN = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_A + RSZ_DWN_AV));
++	printk(KERN_NOTICE "RSZ A DWN_AV = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_A + RSZ_RGB_EN));
++	printk(KERN_NOTICE "RSZ A RGB_EN = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_A + RSZ_RGB_TYP));
++	printk(KERN_NOTICE "RSZ A RGB_TYP = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_A + RSZ_RGB_BLD));
++	printk(KERN_NOTICE "RSZ A RGB_BLD = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_A + RSZ_SDR_Y_BAD_H));
++	printk(KERN_NOTICE "RSZ A SDR_Y_BAD_H = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_A + RSZ_SDR_Y_BAD_L));
++	printk(KERN_NOTICE "RSZ A SDR_Y_BAD_L = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_A + RSZ_SDR_Y_SAD_H));
++	printk(KERN_NOTICE "RSZ A SDR_Y_SAD_H = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_A + RSZ_SDR_Y_SAD_L));
++	printk(KERN_NOTICE "RSZ A SDR_Y_SAD_L = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_A + RSZ_SDR_Y_OFT));
++	printk(KERN_NOTICE "RSZ A SDR_Y_OFT = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_A + RSZ_SDR_Y_PTR_S));
++	printk(KERN_NOTICE "RSZ A SDR_Y_Y_PTR_S = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_A + RSZ_SDR_Y_PTR_E));
++	printk(KERN_NOTICE "RSZ A SDR_Y_PTR_E = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_A + RSZ_SDR_C_BAD_H));
++	printk(KERN_NOTICE "RSZ A SDR_C_BAD_H = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_A + RSZ_SDR_C_BAD_L));
++	printk(KERN_NOTICE "RSZ A SDR_C_BAD_L = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_A + RSZ_SDR_C_SAD_H));
++	printk(KERN_NOTICE "RSZ A SDR_C_SAD_H = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_A + RSZ_SDR_C_SAD_L));
++	printk(KERN_NOTICE "RSZ A SDR_C_SAD_L = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_A + RSZ_SDR_C_OFT));
++	printk(KERN_NOTICE "RSZ A SDR_C_OFT = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_A + RSZ_SDR_C_PTR_S));
++	printk(KERN_NOTICE "RSZ A SDR_C_PTR_S = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_A + RSZ_SDR_C_PTR_E));
++	printk(KERN_NOTICE "RSZ A SDR_C_PTR_E = 0x%x\n", utemp);
++
++	/* Resize - B registers */
++	utemp = regr_rsz((RSZ_EN_B));
++	printk(KERN_NOTICE "RSZ B EN = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_B + RSZ_MODE));
++	printk(KERN_NOTICE "RSZ B MODE = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_B + RSZ_420));
++	printk(KERN_NOTICE "RSZ B 420 = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_B + RSZ_I_VPS));
++	printk(KERN_NOTICE "RSZ B I_VPS = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_B + RSZ_I_HPS));
++	printk(KERN_NOTICE "RSZ B I_HPS = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_B + RSZ_O_VSZ));
++	printk(KERN_NOTICE "RSZ B O_VSZ = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_B + RSZ_O_HSZ));
++	printk(KERN_NOTICE "RSZ B O_HSZ = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_B + RSZ_V_PHS_Y));
++	printk(KERN_NOTICE "RSZ B V_PHS_Y = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_B + RSZ_V_PHS_C));
++	printk(KERN_NOTICE "RSZ B V_PHS_C = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_B + RSZ_V_DIF));
++	printk(KERN_NOTICE "RSZ B V_DIF = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_B + RSZ_V_TYP));
++	printk(KERN_NOTICE "RSZ B V_TYP = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_B + RSZ_V_LPF));
++	printk(KERN_NOTICE "RSZ B V_LPF = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_B + RSZ_H_PHS));
++	printk(KERN_NOTICE "RSZ B H_PHS = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_B + RSZ_H_PHS_ADJ));
++	printk(KERN_NOTICE "RSZ B H_PHS_ADJ = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_B + RSZ_H_DIF));
++	printk(KERN_NOTICE "RSZ B H_DIF = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_B + RSZ_H_TYP));
++	printk(KERN_NOTICE "RSZ B H_TYP = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_B + RSZ_H_LPF));
++	printk(KERN_NOTICE "RSZ B H_LPF = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_B + RSZ_DWN_EN));
++	printk(KERN_NOTICE "RSZ B DWN_EN = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_B + RSZ_DWN_AV));
++	printk(KERN_NOTICE "RSZ B DWN_AV = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_B + RSZ_RGB_EN));
++	printk(KERN_NOTICE "RSZ B RGB_EN = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_B + RSZ_RGB_TYP));
++	printk(KERN_NOTICE "RSZ B RGB_TYP = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_B + RSZ_RGB_BLD));
++	printk(KERN_NOTICE "RSZ B RGB_BLD = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_B + RSZ_SDR_Y_BAD_H));
++	printk(KERN_NOTICE "RSZ B SDR_Y_BAD_H = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_B + RSZ_SDR_Y_BAD_L));
++	printk(KERN_NOTICE "RSZ B SDR_Y_BAD_L = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_B + RSZ_SDR_Y_SAD_H));
++	printk(KERN_NOTICE "RSZ B SDR_Y_SAD_H = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_B + RSZ_SDR_Y_SAD_L));
++	printk(KERN_NOTICE "RSZ B SDR_Y_SAD_L = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_B + RSZ_SDR_Y_OFT));
++	printk(KERN_NOTICE "RSZ B SDR_Y_OFT = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_B + RSZ_SDR_Y_PTR_S));
++	printk(KERN_NOTICE "RSZ B SDR_Y_Y_PTR_S = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_B + RSZ_SDR_Y_PTR_E));
++	printk(KERN_NOTICE "RSZ B SDR_Y_PTR_E = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_B + RSZ_SDR_C_BAD_H));
++	printk(KERN_NOTICE "RSZ b SDR_C_BAD_H = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_B + RSZ_SDR_C_BAD_L));
++	printk(KERN_NOTICE "RSZ B SDR_C_BAD_L = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_B + RSZ_SDR_C_SAD_H));
++	printk(KERN_NOTICE "RSZ B SDR_C_SAD_H = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_B + RSZ_SDR_C_SAD_L));
++	printk(KERN_NOTICE "RSZ B SDR_C_SAD_L = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_B + RSZ_SDR_C_OFT));
++	printk(KERN_NOTICE "RSZ B SDR_C_OFT = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_B + RSZ_SDR_C_PTR_S));
++	printk(KERN_NOTICE "RSZ B SDR_C_PTR_S = 0x%x\n", utemp);
++	utemp = regr_rsz((RSZ_EN_B + RSZ_SDR_C_PTR_E));
++	printk(KERN_NOTICE "RSZ B SDR_C_PTR_E = 0x%x\n", utemp);
++}
++#else
++void ipipe_hw_dump_config(void)
++{
++}
++#endif
++
++/* Set input channel format to either 420 Y or C format */
++int rsz_set_in_pix_format(unsigned char y_c)
++{
++	u32 utemp;
++	utemp = regr_rsz(RSZ_SRC_FMT1);
++	utemp |= (y_c & 1);
++	regw_rsz(utemp, RSZ_SRC_FMT1);
++	return 0;
++}
++
++static int rsz_set_common_params(struct ipipe_params *params)
++{
++	u32 utemp;
++	struct rsz_common_params *rsz_common = &params->rsz_common;
++
++	/* Set mode */
++	regw_rsz(params->ipipe_mode, RSZ_SRC_MODE);
++
++	/* data source selection  and bypass */
++	utemp = ((rsz_common->passthrough << RSZ_BYPASS_SHIFT) |
++		(rsz_common->source));
++
++	regw_rsz(utemp, RSZ_SRC_FMT0);
++	utemp = regr_rsz(RSZ_SRC_MODE);
++	/* src image selection */
++	utemp = (rsz_common->raw_flip & 1) |
++		(rsz_common->src_img_fmt << RSZ_SRC_IMG_FMT_SHIFT) |
++		((rsz_common->y_c & 1) << RSZ_SRC_Y_C_SEL_SHIFT);
++
++	regw_rsz(utemp, RSZ_SRC_FMT1);
++	regw_rsz(rsz_common->vps & IPIPE_RSZ_VPS_MASK, RSZ_SRC_VPS);
++	regw_rsz(rsz_common->hps & IPIPE_RSZ_HPS_MASK, RSZ_SRC_HPS);
++	regw_rsz(rsz_common->vsz & IPIPE_RSZ_VSZ_MASK, RSZ_SRC_VSZ);
++	regw_rsz(rsz_common->hsz & IPIPE_RSZ_HSZ_MASK, RSZ_SRC_HSZ);
++	regw_rsz(rsz_common->yuv_y_min, RSZ_YUV_Y_MIN);
++	regw_rsz(rsz_common->yuv_y_max, RSZ_YUV_Y_MAX);
++	regw_rsz(rsz_common->yuv_c_min, RSZ_YUV_C_MIN);
++	regw_rsz(rsz_common->yuv_c_max, RSZ_YUV_C_MAX);
++	/* chromatic position */
++	regw_rsz(rsz_common->out_chr_pos, RSZ_YUV_PHS);
++	utemp = regr_rsz(RSZ_SRC_MODE);
++	return 0;
++}
++
++static void rsz_set_rsz_regs(unsigned int rsz_id, struct ipipe_params *params)
++{
++	struct ipipe_rsz_rescale_param *rsc_params;
++	struct ipipe_rsz_resize2rgb *rgb;
++	struct ipipe_ext_mem_param *ext_mem;
++	u32 utemp, reg_base;
++
++	utemp = regr_rsz(RSZ_SEQ);
++	if (rsz_id == RSZ_A) {
++		rsc_params = &params->rsz_rsc_param[RSZ_A];
++		rgb = &params->rsz2rgb[RSZ_A];
++		ext_mem = &params->ext_mem_param[RSZ_A];
++		utemp = rsc_params->h_flip << RSZA_H_FLIP_SHIFT;
++		utemp |= rsc_params->v_flip << RSZA_V_FLIP_SHIFT;
++		reg_base = RSZ_EN_A;
++	} else {
++		rsc_params = &params->rsz_rsc_param[RSZ_B];
++		rgb = &params->rsz2rgb[RSZ_B];
++		ext_mem = &params->ext_mem_param[RSZ_B];
++		utemp = rsc_params->h_flip << RSZB_H_FLIP_SHIFT;
++		utemp |= rsc_params->v_flip << RSZB_V_FLIP_SHIFT;
++		reg_base = RSZ_EN_B;
++	}
++	/* update flip settings */
++	regw_rsz(utemp, RSZ_SEQ);
++
++	regw_rsz(rsc_params->mode, reg_base + RSZ_MODE);
++	utemp = (rsc_params->cen << RSZ_CEN_SHIFT) | rsc_params->yen;
++	regw_rsz(utemp, reg_base + RSZ_420);
++	regw_rsz(rsc_params->i_vps & RSZ_VPS_MASK, reg_base + RSZ_I_VPS);
++	regw_rsz(rsc_params->i_hps & RSZ_HPS_MASK, reg_base + RSZ_I_HPS);
++	regw_rsz(rsc_params->o_vsz & RSZ_O_VSZ_MASK, reg_base + RSZ_O_VSZ);
++	regw_rsz(rsc_params->o_hsz & RSZ_O_HSZ_MASK, reg_base + RSZ_O_HSZ);
++	regw_rsz(rsc_params->v_phs_y & RSZ_V_PHS_MASK, reg_base + RSZ_V_PHS_Y);
++	regw_rsz(rsc_params->v_phs_c & RSZ_V_PHS_MASK, reg_base + RSZ_V_PHS_C);
++	/* keep this additional adjustment to zero for now */
++	regw_rsz(rsc_params->v_dif & RSZ_V_DIF_MASK, reg_base + RSZ_V_DIF);
++
++	utemp = (rsc_params->v_typ_y & 1)
++		| ((rsc_params->v_typ_c & 1) << RSZ_TYP_C_SHIFT);
++	regw_rsz(utemp, reg_base + RSZ_V_TYP);
++
++	utemp = (rsc_params->v_lpf_int_y & RSZ_LPF_INT_MASK) |
++		 ((rsc_params->v_lpf_int_c & RSZ_LPF_INT_MASK) <<
++		 RSZ_LPF_INT_C_SHIFT);
++	regw_rsz(utemp, reg_base + RSZ_V_LPF);
++
++	regw_rsz(rsc_params->h_phs & RSZ_H_PHS_MASK, reg_base + RSZ_H_PHS);
++	regw_rsz(0, reg_base + RSZ_H_PHS_ADJ);
++	regw_rsz(rsc_params->h_dif & RSZ_H_DIF_MASK, reg_base + RSZ_H_DIF);
++	utemp = (rsc_params->h_typ_y & 1) |
++		((rsc_params->h_typ_c & 1) << RSZ_TYP_C_SHIFT);
++	regw_rsz(utemp, reg_base + RSZ_H_TYP);
++	utemp = (rsc_params->h_lpf_int_y & RSZ_LPF_INT_MASK) |
++		 ((rsc_params->h_lpf_int_c & RSZ_LPF_INT_MASK) <<
++		 RSZ_LPF_INT_C_SHIFT);
++	regw_rsz(utemp, reg_base + RSZ_H_LPF);
++
++	regw_rsz(rsc_params->dscale_en & 1, reg_base + RSZ_DWN_EN);
++	utemp = rsc_params->h_dscale_ave_sz & RSZ_DWN_SCALE_AV_SZ_MASK;
++	utemp |= ((rsc_params->v_dscale_ave_sz & RSZ_DWN_SCALE_AV_SZ_MASK) <<
++		  RSZ_DWN_SCALE_AV_SZ_V_SHIFT);
++	regw_rsz(utemp, reg_base + RSZ_DWN_AV);
++
++	/* setting rgb conversion parameters */
++	regw_rsz(rgb->rgb_en, reg_base + RSZ_RGB_EN);
++	utemp = ((rgb->rgb_typ << RSZ_RGB_TYP_SHIFT) |
++		 (rgb->rgb_msk0 << RSZ_RGB_MSK0_SHIFT) |
++		 (rgb->rgb_msk1) << RSZ_RGB_MSK1_SHIFT);
++	regw_rsz(utemp, reg_base + RSZ_RGB_TYP);
++	regw_rsz(rgb->rgb_alpha_val & RSZ_RGB_ALPHA_MASK,
++		reg_base + RSZ_RGB_BLD);
++
++	/* setting external memory parameters */
++	regw_rsz(ext_mem->rsz_sdr_oft_y, reg_base + RSZ_SDR_Y_OFT);
++	regw_rsz(ext_mem->rsz_sdr_ptr_s_y, reg_base + RSZ_SDR_Y_PTR_S);
++	regw_rsz(ext_mem->rsz_sdr_ptr_e_y, reg_base + RSZ_SDR_Y_PTR_E);
++	regw_rsz(ext_mem->rsz_sdr_oft_c, reg_base + RSZ_SDR_C_OFT);
++	regw_rsz(ext_mem->rsz_sdr_ptr_s_c, reg_base + RSZ_SDR_C_PTR_S);
++	regw_rsz((ext_mem->rsz_sdr_ptr_e_c >> 1), reg_base + RSZ_SDR_C_PTR_E);
++}
++
++static int ipipe_setup_resizer(struct ipipe_params *params)
++{				/*set the registers of either RSZ0 or RSZ1 */
++	u32 utemp;
++
++	/* enable MMR gate to write to Resizer */
++	regw_rsz(1, RSZ_GCK_MMR);
++
++	/* Enable resizer if it is not in bypass mode */
++	if (params->rsz_common.passthrough)
++		regw_rsz(0, RSZ_GCK_SDR);
++	else
++		regw_rsz(1, RSZ_GCK_SDR);
++
++	rsz_set_common_params(params);
++
++	regw_rsz(params->rsz_en[0], RSZ_EN_A);
++	if (params->rsz_en[0]) {
++		printk(KERN_DEBUG
++		       "ipipe_set_resizer, resizer - A enabled\n");
++		/*setting rescale parameters */
++		rsz_set_rsz_regs(RSZ_A, params);
++	}
++
++	regw_rsz(params->rsz_en[1], RSZ_EN_B);
++	if (params->rsz_en[1]) {
++		printk(KERN_DEBUG
++		       "ipipe_set_resizer, resizer - B enabled\n");
++		rsz_set_rsz_regs(RSZ_B, params);
++	}
++	utemp = regr_rsz(RSZ_SRC_MODE);
++	return 0;
++}
++
++/* ipipe_hw_setup:It is used for Hardware Setup */
++int ipipe_hw_setup(struct ipipe_params *config)
++{
++	u32 utemp = 0;
++	u32 data_format;
++
++	if (!config) {
++		printk(KERN_ERR "NULL config block received\n");
++		return -EINVAL;
++	}
++
++	if (ipipeif_hw_setup(&config->ipipeif_param) < 0) {
++		printk(KERN_ERR "Unable to configure IPIPEIF");
++		return -EINVAL;
++	}
++
++	/* enable clock to IPIPE */
++	vpss_enable_clock(VPSS_IPIPE_CLOCK, 1);
++	/* enable clock to MMR and modules before writting
++	 * to ipipe registers
++	 */
++	ipipe_clock_enable();
++
++	if (config->rsz_common.source == IPIPEIF_DATA) {
++		/* we need to skip configuring IPIPE */
++		regw_ip(0, IPIPE_SRC_EN);
++	} else {
++		/* enable ipipe mode to either one shot or continuous */
++		utemp = config->ipipe_mode;
++		regw_ip((utemp), IPIPE_SRC_MODE);
++		regw_ip(1, IPIPE_SRC_EN);
++		data_format = config->ipipe_dpaths_fmt;
++		regw_ip(data_format, IPIPE_SRC_FMT);
++		/* set size */
++		regw_ip(config->ipipe_vps & IPIPE_RSZ_VPS_MASK, IPIPE_SRC_VPS);
++		regw_ip(config->ipipe_hps & IPIPE_RSZ_HPS_MASK, IPIPE_SRC_HPS);
++		regw_ip(config->ipipe_vsz & IPIPE_RSZ_VSZ_MASK, IPIPE_SRC_VSZ);
++		regw_ip(config->ipipe_hsz & IPIPE_RSZ_HSZ_MASK, IPIPE_SRC_HSZ);
++
++		if ((data_format == IPIPE_RAW2YUV) ||
++		    (data_format == IPIPE_RAW2RAW)) {
++			/* Combine all the fields to make COLPAT register
++			 * of IPIPE
++			 */
++			utemp = (config->ipipe_colpat_elep <<
++				COLPAT_EE_SHIFT);
++			utemp |= (config->ipipe_colpat_elop <<
++				COLPAT_EO_SHIFT);
++			utemp |= (config->ipipe_colpat_olep <<
++				COLPAT_OE_SHIFT);
++			utemp |= (config->ipipe_colpat_olop <<
++				COLPAT_OO_SHIFT);
++			regw_ip(utemp, IPIPE_SRC_COL);
++		}
++	}
++	return ipipe_setup_resizer(config);
++}
++
++static void rsz_set_y_address(unsigned int address, unsigned int offset)
++{
++	u32 utemp;
++	utemp = (address & SET_LOW_ADD);
++	regw_rsz(utemp, offset + RSZ_SDR_Y_BAD_L);
++	regw_rsz(utemp, offset + RSZ_SDR_Y_SAD_L);
++	utemp = (address & SET_HIGH_ADD) >> 16;
++	regw_rsz(utemp, offset + RSZ_SDR_Y_BAD_H);
++	regw_rsz(utemp, offset + RSZ_SDR_Y_SAD_H);
++}
++
++static void rsz_set_c_address(unsigned int address, unsigned int offset)
++{
++	u32 utemp;
++	utemp = (address & SET_LOW_ADD);
++
++	regw_rsz(utemp, offset + RSZ_SDR_C_BAD_L);
++	regw_rsz(utemp, offset + RSZ_SDR_C_SAD_L);
++	utemp = (address & SET_HIGH_ADD) >> 16;
++	regw_rsz(utemp, offset + RSZ_SDR_C_BAD_H);
++	regw_rsz(utemp, offset + RSZ_SDR_C_SAD_H);
++}
++
++/* Assume we get a valid params ptr and resize_no set to RSZ_A
++ * or RSZ_B. This could be called in the interrupt context and
++ * must be efficient
++ */
++int rsz_set_output_address(struct ipipe_params *params,
++			   int resize_no, unsigned int address)
++{
++	unsigned int utemp;
++	unsigned int rsz_start_add;
++	struct ipipe_ext_mem_param *mem_param =
++		&params->ext_mem_param[resize_no];
++	struct rsz_common_params *rsz_common =
++		&params->rsz_common;
++	struct ipipe_rsz_rescale_param *rsc_param =
++		&params->rsz_rsc_param[resize_no];
++
++	printk(KERN_DEBUG "rsz_set_output_address %d\n", resize_no);
++	if (resize_no == RSZ_A)
++		rsz_start_add = RSZ_EN_A;
++	else
++		rsz_start_add = RSZ_EN_B;
++	/* y_c = 0 for y, = 1 for c */
++	if (rsz_common->src_img_fmt == RSZ_IMG_420) {
++		if (rsz_common->y_c) {
++			/* C channel */
++			utemp = (address + mem_param->flip_ofst_c);
++			rsz_set_c_address(utemp, rsz_start_add);
++		} else {
++			utemp = (address + mem_param->flip_ofst_y);
++			rsz_set_y_address(utemp, rsz_start_add);
++		}
++	} else {
++		if (rsc_param->cen && rsc_param->yen) {
++			/* 420 */
++		utemp = (address + mem_param->c_offset);
++			utemp = (address + mem_param->c_offset
++				+ mem_param->flip_ofst_c);
++			utemp += mem_param->user_y_ofst + mem_param->user_c_ofst;
++			if (resize_no == RSZ_B)
++				utemp += params->ext_mem_param[RSZ_A].user_y_ofst +
++				params->ext_mem_param[RSZ_A].user_c_ofst;
++			/* set C address */
++			rsz_set_c_address(utemp, rsz_start_add);
++		}
++		utemp = (address + mem_param->flip_ofst_y);
++		utemp += mem_param->user_y_ofst;
++		if (resize_no == RSZ_B)
++			utemp += params->ext_mem_param[RSZ_A].user_y_ofst +
++				params->ext_mem_param[RSZ_A].user_c_ofst;
++		/* set Y address */
++		rsz_set_y_address(utemp, rsz_start_add);
++	}
++	/* resizer must be enabled */
++	regw_rsz(params->rsz_en[resize_no], rsz_start_add);
++	return 0;
++}
++
++int ipipe_set_lutdpc_regs(struct prev_lutdpc *dpc)
++{
++	u32 utemp, count, lut_start_addr = DPC_TB0_START_ADDR,
++		max_tbl_size = (LUT_DPC_MAX_SIZE >> 1);
++
++	ipipe_clock_enable();
++	regw_ip(dpc->en, DPC_LUT_EN);
++	if (1 == dpc->en) {
++		utemp = LUTDPC_TBL_256_EN;
++		utemp |= (dpc->repl_white & 1);
++		regw_ip(utemp, DPC_LUT_SEL);
++
++		regw_ip(LUT_DPC_START_ADDR, DPC_LUT_ADR);
++		regw_ip(dpc->dpc_size, DPC_LUT_SIZ & LUT_DPC_SIZE_MASK);
++		if (dpc->table != NULL) {
++			count = 0;
++			while (count < dpc->dpc_size) {
++				if (count >= max_tbl_size)
++					lut_start_addr = DPC_TB1_START_ADDR;
++				utemp =
++				    (dpc->table[count].horz_pos
++					& LUT_DPC_H_POS_MASK);
++				utemp |= ((dpc->table[count].vert_pos
++					 & LUT_DPC_V_POS_MASK)
++					 << LUT_DPC_V_POS_SHIFT);
++				utemp |= (dpc->table[count].method
++					 << LUT_DPC_CORR_METH_SHIFT);
++				w_ip_table(utemp, (lut_start_addr +
++					((count % max_tbl_size) << 2)));
++				count++;
++			}
++		}
++
++	}
++	return 0;
++}
++
++static void set_dpc_thresholds(struct prev_otfdpc_2_0 *dpc_thr)
++{
++	regw_ip((dpc_thr->corr_thr.r & OTFDPC_DPC2_THR_MASK),
++		DPC_OTF_2C_THR_R);
++	regw_ip((dpc_thr->corr_thr.gr & OTFDPC_DPC2_THR_MASK),
++		DPC_OTF_2C_THR_GR);
++	regw_ip((dpc_thr->corr_thr.gb & OTFDPC_DPC2_THR_MASK),
++		DPC_OTF_2C_THR_GB);
++	regw_ip((dpc_thr->corr_thr.b & OTFDPC_DPC2_THR_MASK),
++		DPC_OTF_2C_THR_B);
++	regw_ip((dpc_thr->det_thr.r & OTFDPC_DPC2_THR_MASK),
++		DPC_OTF_2D_THR_R);
++	regw_ip((dpc_thr->det_thr.gr & OTFDPC_DPC2_THR_MASK),
++		DPC_OTF_2D_THR_GR);
++	regw_ip((dpc_thr->det_thr.gb & OTFDPC_DPC2_THR_MASK),
++		DPC_OTF_2D_THR_GB);
++	regw_ip((dpc_thr->det_thr.b & OTFDPC_DPC2_THR_MASK),
++		DPC_OTF_2D_THR_B);
++}
++
++int ipipe_set_otfdpc_regs(struct prev_otfdpc *otfdpc)
++{
++	u32 utemp;
++	struct prev_otfdpc_2_0 *dpc_2_0 = &otfdpc->alg_cfg.dpc_2_0;
++	struct prev_otfdpc_3_0 *dpc_3_0 = &otfdpc->alg_cfg.dpc_3_0;
++
++	ipipe_clock_enable();
++
++	regw_ip((otfdpc->en & 1), DPC_OTF_EN);
++	if (1 == otfdpc->en) {
++		utemp = (otfdpc->det_method << OTF_DET_METHOD_SHIFT);
++		utemp |= otfdpc->alg;
++		regw_ip(utemp, DPC_OTF_TYP);
++		if (otfdpc->det_method == IPIPE_DPC_OTF_MIN_MAX) {
++			/* ALG= 0, TYP = 0, DPC_OTF_2D_THR_[x]=0
++			 * DPC_OTF_2C_THR_[x] = Maximum thresohld
++			 * MinMax method
++			 */
++			dpc_2_0->det_thr.r = dpc_2_0->det_thr.gb =
++			dpc_2_0->det_thr.gr = dpc_2_0->det_thr.b = 0;
++			set_dpc_thresholds(dpc_2_0);
++		} else {
++			/* MinMax2 */
++			if (otfdpc->alg == IPIPE_OTFDPC_2_0)
++				set_dpc_thresholds(dpc_2_0);
++			else {
++				regw_ip((dpc_3_0->act_adj_shf
++					& OTF_DPC3_0_SHF_MASK), DPC_OTF_3_SHF);
++				/* Detection thresholds */
++				regw_ip(((dpc_3_0->det_thr
++					& OTF_DPC3_0_THR_MASK) <<
++					OTF_DPC3_0_THR_SHIFT), DPC_OTF_3D_THR);
++				regw_ip((dpc_3_0->det_slp
++					& OTF_DPC3_0_SLP_MASK),
++					DPC_OTF_3D_SLP);
++				regw_ip((dpc_3_0->det_thr_min
++					& OTF_DPC3_0_DET_MASK),
++					DPC_OTF_3D_MIN);
++				regw_ip((dpc_3_0->det_thr_max
++					& OTF_DPC3_0_DET_MASK),
++					DPC_OTF_3D_MAX);
++				/* Correction thresholds */
++				regw_ip(((dpc_3_0->corr_thr
++					& OTF_DPC3_0_THR_MASK) <<
++					OTF_DPC3_0_THR_SHIFT), DPC_OTF_3C_THR);
++				regw_ip((dpc_3_0->corr_slp
++					& OTF_DPC3_0_SLP_MASK),
++					DPC_OTF_3C_SLP);
++				regw_ip((dpc_3_0->corr_thr_min
++					& OTF_DPC3_0_CORR_MASK),
++					DPC_OTF_3C_MIN);
++				regw_ip((dpc_3_0->corr_thr_max
++					& OTF_DPC3_0_CORR_MASK),
++					DPC_OTF_3C_MAX);
++			}
++		}
++	}
++	return 0;
++}
++
++/* 2D Noise filter */
++int ipipe_set_d2f_regs(unsigned int id, struct prev_nf *noise_filter)
++{
++	u32 utemp;
++	int count = 0;
++	u32 offset = D2F_1ST;
++
++	/* id = 0 , NF1 & id = 1, NF 2 */
++	if (id)
++		offset = D2F_2ND;
++	ipipe_clock_enable();
++	regw_ip(noise_filter->en & 1, offset + D2F_EN);
++	if (1 == noise_filter->en) {
++		/* Combine all the fields to make D2F_CFG register of IPIPE */
++		utemp = ((noise_filter->spread_val & D2F_SPR_VAL_MASK) <<
++			 D2F_SPR_VAL_SHIFT) |
++			 ((noise_filter->shft_val & D2F_SHFT_VAL_MASK) <<
++			 D2F_SHFT_VAL_SHIFT) |
++			 (noise_filter->gr_sample_meth <<
++			 D2F_SAMPLE_METH_SHIFT) |
++			 ((noise_filter->apply_lsc_gain & 1) <<
++			 D2F_APPLY_LSC_GAIN_SHIFT) | D2F_USE_SPR_REG_VAL;
++
++		regw_ip(utemp, offset + D2F_TYP);
++		/* edge detection minimum */
++		regw_ip(noise_filter->edge_det_min_thr & D2F_EDGE_DET_THR_MASK,
++			offset + D2F_EDG_MIN);
++		/* edge detection maximum */
++		regw_ip(noise_filter->edge_det_max_thr & D2F_EDGE_DET_THR_MASK,
++			offset + D2F_EDG_MAX);
++		count = 0;
++		while (count < IPIPE_NF_STR_TABLE_SIZE) {
++			regw_ip((noise_filter->str[count] & D2F_STR_VAL_MASK),
++				offset + D2F_STR + count * 4);
++			count++;
++		}
++		count = 0;
++		while (count < IPIPE_NF_THR_TABLE_SIZE) {
++			regw_ip(noise_filter->thr[count] & D2F_THR_VAL_MASK,
++				offset + D2F_THR + count * 4);
++			count++;
++		}
++	}
++	return 0;
++}
++
++#define IPIPE_U8Q5(decimal, integer) \
++	(((decimal & 0x1f) | ((integer & 0x7) << 5)))
++
++/* Green Imbalance Correction */
++int ipipe_set_gic_regs(struct prev_gic *gic)
++{
++	u32 utemp;
++	ipipe_clock_enable();
++	regw_ip(gic->en & 1, GIC_EN);
++	if (gic->en) {
++		utemp = gic->wt_fn_type << GIC_TYP_SHIFT;
++		utemp |= (gic->thr_sel << GIC_THR_SEL_SHIFT);
++		utemp |= ((gic->apply_lsc_gain & 1) <<
++				GIC_APPLY_LSC_GAIN_SHIFT);
++		regw_ip(utemp, GIC_TYP);
++		regw_ip(gic->gain & GIC_GAIN_MASK, GIC_GAN);
++		if (gic->gic_alg == IPIPE_GIC_ALG_ADAPT_GAIN) {
++			if (gic->thr_sel == IPIPE_GIC_THR_REG) {
++				regw_ip(gic->thr & GIC_THR_MASK, GIC_THR);
++				regw_ip(gic->slope & GIC_SLOPE_MASK, GIC_SLP);
++			} else {
++				/* Use NF thresholds */
++				utemp = IPIPE_U8Q5(gic->nf2_thr_gain.decimal, \
++						gic->nf2_thr_gain.integer);
++				regw_ip(utemp, GIC_NFGAN);
++			}
++		} else
++			/* Constant Gain. Set threshold to maximum */
++			regw_ip(GIC_THR_MASK, GIC_THR);
++	}
++	return 0;
++}
++
++#define IPIPE_U13Q9(decimal, integer) \
++	(((decimal & 0x1ff) | ((integer & 0xf) << 9)))
++/* White balance */
++int ipipe_set_wb_regs(struct prev_wb *wb)
++{
++	u32 utemp;
++
++	ipipe_clock_enable();
++	/* Ofsets. S12 */
++	regw_ip(wb->ofst_r & WB_OFFSET_MASK, WB2_OFT_R);
++	regw_ip(wb->ofst_gr & WB_OFFSET_MASK, WB2_OFT_GR);
++	regw_ip(wb->ofst_gb & WB_OFFSET_MASK, WB2_OFT_GB);
++	regw_ip(wb->ofst_b & WB_OFFSET_MASK, WB2_OFT_B);
++
++	/* Gains. U13Q9 */
++	utemp = IPIPE_U13Q9((wb->gain_r.decimal), (wb->gain_r.integer));
++	regw_ip(utemp, WB2_WGN_R);
++	utemp = IPIPE_U13Q9((wb->gain_gr.decimal), (wb->gain_gr.integer));
++	regw_ip(utemp, WB2_WGN_GR);
++	utemp = IPIPE_U13Q9((wb->gain_gb.decimal), (wb->gain_gb.integer));
++	regw_ip(utemp, WB2_WGN_GB);
++	utemp = IPIPE_U13Q9((wb->gain_b.decimal), (wb->gain_b.integer));
++	regw_ip(utemp, WB2_WGN_B);
++	return 0;
++}
++
++/* CFA */
++int ipipe_set_cfa_regs(struct prev_cfa *cfa)
++{
++	ipipe_clock_enable();
++	regw_ip(cfa->alg, CFA_MODE);
++	regw_ip(cfa->hpf_thr_2dir & CFA_HPF_THR_2DIR_MASK, CFA_2DIR_HPF_THR);
++	regw_ip(cfa->hpf_slp_2dir & CFA_HPF_SLOPE_2DIR_MASK, CFA_2DIR_HPF_SLP);
++	regw_ip(cfa->hp_mix_thr_2dir & CFA_HPF_MIX_THR_2DIR_MASK,
++			CFA_2DIR_MIX_THR);
++	regw_ip(cfa->hp_mix_slope_2dir & CFA_HPF_MIX_SLP_2DIR_MASK,
++			CFA_2DIR_MIX_SLP);
++	regw_ip(cfa->dir_thr_2dir & CFA_DIR_THR_2DIR_MASK, CFA_2DIR_DIR_THR);
++	regw_ip(cfa->dir_slope_2dir & CFA_DIR_SLP_2DIR_MASK, CFA_2DIR_DIR_SLP);
++	regw_ip(cfa->nd_wt_2dir & CFA_ND_WT_2DIR_MASK, CFA_2DIR_NDWT);
++	regw_ip(cfa->hue_fract_daa & CFA_DAA_HUE_FRA_MASK, CFA_MONO_HUE_FRA);
++	regw_ip(cfa->edge_thr_daa & CFA_DAA_EDG_THR_MASK, CFA_MONO_EDG_THR);
++	regw_ip(cfa->thr_min_daa & CFA_DAA_THR_MIN_MASK, CFA_MONO_THR_MIN);
++	regw_ip(cfa->thr_slope_daa & CFA_DAA_THR_SLP_MASK, CFA_MONO_THR_SLP);
++	regw_ip(cfa->slope_min_daa & CFA_DAA_SLP_MIN_MASK, CFA_MONO_SLP_MIN);
++	regw_ip(cfa->slope_slope_daa & CFA_DAA_SLP_SLP_MASK, CFA_MONO_SLP_SLP);
++	regw_ip(cfa->lp_wt_daa & CFA_DAA_LP_WT_MASK, CFA_MONO_LPWT);
++	return 0;
++}
++
++int ipipe_set_rgb2rgb_regs(unsigned int id, struct prev_rgb2rgb *rgb)
++{
++	u32 utemp, offset = RGB1_MUL_BASE, offset_mask = RGB2RGB_1_OFST_MASK,
++		integ_mask = 0xf;
++
++	ipipe_clock_enable();
++
++	if (id) {
++		/* For second RGB module, gain integer is 3 bits instead
++		of 4, offset has 11 bits insread of 13 */
++		offset = RGB2_MUL_BASE;
++		integ_mask = 0x7;
++		offset_mask = RGB2RGB_2_OFST_MASK;
++	}
++	/* Gains */
++	utemp = ((rgb->coef_rr.decimal & 0xff) |
++		(((rgb->coef_rr.integer) & integ_mask) << 8));
++	regw_ip(utemp, offset + RGB_MUL_RR);
++	utemp = ((rgb->coef_gr.decimal & 0xff) |
++		(((rgb->coef_gr.integer) & integ_mask) << 8));
++	regw_ip(utemp, offset + RGB_MUL_GR);
++	utemp = ((rgb->coef_br.decimal & 0xff) |
++		(((rgb->coef_br.integer) & integ_mask) << 8));
++	regw_ip(utemp, offset + RGB_MUL_BR);
++	utemp = ((rgb->coef_rg.decimal & 0xff) |
++		(((rgb->coef_rg.integer) & integ_mask) << 8));
++	regw_ip(utemp, offset + RGB_MUL_RG);
++	utemp = ((rgb->coef_gg.decimal & 0xff) |
++		(((rgb->coef_gg.integer) & integ_mask) << 8));
++	regw_ip(utemp, offset + RGB_MUL_GG);
++	utemp = ((rgb->coef_bg.decimal & 0xff) |
++		(((rgb->coef_bg.integer) & integ_mask) << 8));
++	regw_ip(utemp, offset + RGB_MUL_BG);
++	utemp = ((rgb->coef_rb.decimal & 0xff) |
++		(((rgb->coef_rb.integer) & integ_mask) << 8));
++	regw_ip(utemp, offset + RGB_MUL_RB);
++	utemp = ((rgb->coef_gb.decimal & 0xff) |
++		(((rgb->coef_gb.integer) & integ_mask) << 8));
++	regw_ip(utemp, offset + RGB_MUL_GB);
++	utemp = ((rgb->coef_bb.decimal & 0xff) |
++		(((rgb->coef_bb.integer) & integ_mask) << 8));
++	regw_ip(utemp, offset + RGB_MUL_BB);
++
++	/* Offsets */
++	regw_ip(rgb->out_ofst_r & offset_mask, offset + RGB_OFT_OR);
++	regw_ip(rgb->out_ofst_g & offset_mask, offset + RGB_OFT_OG);
++	regw_ip(rgb->out_ofst_b & offset_mask, offset + RGB_OFT_OB);
++	return 0;
++}
++
++static void ipipe_update_gamma_tbl(struct ipipe_gamma_entry *table,
++				   int size, u32 addr)
++{
++	int count;
++	u32 utemp;
++
++	for (count = 0; count < size; count++) {
++		utemp = table[count].slope & GAMMA_MASK;
++		utemp |= ((table[count].offset & GAMMA_MASK) << GAMMA_SHIFT);
++		w_ip_table(utemp, (addr + (count * 4)));
++	}
++}
++
++/* Gamma correction */
++int ipipe_set_gamma_regs(struct prev_gamma *gamma)
++{
++	u32 utemp;
++	int table_size = 0;
++
++	ipipe_clock_enable();
++	utemp = ((gamma->bypass_r << GAMMA_BYPR_SHIFT)
++		| (gamma->bypass_b << GAMMA_BYPG_SHIFT)
++		| (gamma->bypass_g << GAMMA_BYPB_SHIFT)
++		| (gamma->tbl_sel << GAMMA_TBL_SEL_SHIFT)
++		| (gamma->tbl_size << GAMMA_TBL_SIZE_SHIFT));
++
++	regw_ip(utemp, GMM_CFG);
++	if (gamma->tbl_sel == IPIPE_GAMMA_TBL_RAM) {
++		if (gamma->tbl_size == IPIPE_GAMMA_TBL_SZ_64)
++			table_size = 64;
++		else if (gamma->tbl_size == IPIPE_GAMMA_TBL_SZ_128)
++			table_size = 128;
++		else if (gamma->tbl_size == IPIPE_GAMMA_TBL_SZ_256)
++			table_size = 256;
++		else if (gamma->tbl_size == IPIPE_GAMMA_TBL_SZ_512)
++			table_size = 512;
++		if (!(gamma->bypass_r)) {
++			if (gamma->table_r != NULL)
++				ipipe_update_gamma_tbl(gamma->table_r,
++						       table_size,
++						       GAMMA_R_START_ADDR);
++		}
++		if (!(gamma->bypass_b)) {
++			if (gamma->table_b != NULL)
++				ipipe_update_gamma_tbl(gamma->table_b,
++						       table_size,
++						       GAMMA_B_START_ADDR);
++		}
++		if (!(gamma->bypass_g)) {
++			if (gamma->table_g != NULL)
++				ipipe_update_gamma_tbl(gamma->table_g,
++						       table_size,
++						       GAMMA_G_START_ADDR);
++		}
++
++	}
++	return 0;
++}
++
++/* 3D LUT */
++int ipipe_set_3d_lut_regs(struct prev_3d_lut *lut_3d)
++{
++	u32 utemp, i, bnk_index, tbl_index;
++	struct ipipe_3d_lut_entry *tbl;
++
++	ipipe_clock_enable();
++	regw_ip(lut_3d->en, D3LUT_EN);
++	if (lut_3d->en) {
++		if (lut_3d->table) {
++			tbl = lut_3d->table;
++			for (i = 0 ; i < MAX_SIZE_3D_LUT; i++) {
++				/* Each entry has 0-9 (B), 10-19 (G) and
++				20-29 R values */
++				utemp = (tbl[i].b & D3_LUT_ENTRY_MASK);
++				utemp |= ((tbl[i].g & D3_LUT_ENTRY_MASK) <<
++					 D3_LUT_ENTRY_G_SHIFT);
++				utemp |= ((tbl[i].r & D3_LUT_ENTRY_MASK) <<
++					 D3_LUT_ENTRY_R_SHIFT);
++				bnk_index = (i % 4);
++				tbl_index = (i >> 2);
++				tbl_index <<= 2;
++				if (bnk_index == 0)
++					w_ip_table(utemp,
++						tbl_index + D3L_TB0_START_ADDR);
++				else if (bnk_index == 1)
++					w_ip_table(utemp,
++						tbl_index + D3L_TB1_START_ADDR);
++				else if (bnk_index == 2)
++					w_ip_table(utemp,
++						tbl_index + D3L_TB2_START_ADDR);
++				else
++					w_ip_table(utemp,
++						tbl_index + D3L_TB3_START_ADDR);
++			}
++		}
++	}
++	return 0;
++}
++
++/* Lumina adjustments */
++int ipipe_set_lum_adj_regs(struct prev_lum_adj *lum_adj)
++{
++	u32 utemp;
++
++	ipipe_clock_enable();
++	/* combine fields of YUV_ADJ to set brightness and contrast */
++	utemp = ((lum_adj->contrast << LUM_ADJ_CONTR_SHIFT)
++		|(lum_adj->brightness << LUM_ADJ_BRIGHT_SHIFT));
++	regw_ip(utemp, YUV_ADJ);
++	return 0;
++}
++
++#define IPIPE_S12Q8(decimal, integer) \
++	(((decimal & 0xff) | ((integer & 0xf) << 8)))
++/* RGB2YUV */
++int ipipe_set_rgb2ycbcr_regs(struct prev_rgb2yuv *yuv)
++{
++	u32 utemp;
++
++	/* S10Q8 */
++	ipipe_clock_enable();
++	utemp = IPIPE_S12Q8((yuv->coef_ry.decimal), (yuv->coef_ry.integer));
++	regw_ip(utemp, YUV_MUL_RY);
++	utemp = IPIPE_S12Q8((yuv->coef_gy.decimal), (yuv->coef_gy.integer));
++	regw_ip(utemp, YUV_MUL_GY);
++	utemp = IPIPE_S12Q8((yuv->coef_by.decimal), (yuv->coef_by.integer));
++	regw_ip(utemp, YUV_MUL_BY);
++	utemp = IPIPE_S12Q8((yuv->coef_rcb.decimal), (yuv->coef_rcb.integer));
++	regw_ip(utemp, YUV_MUL_RCB);
++	utemp = IPIPE_S12Q8((yuv->coef_gcb.decimal), (yuv->coef_gcb.integer));
++	regw_ip(utemp, YUV_MUL_GCB);
++	utemp = IPIPE_S12Q8((yuv->coef_bcb.decimal), (yuv->coef_bcb.integer));
++	regw_ip(utemp, YUV_MUL_BCB);
++	utemp = IPIPE_S12Q8((yuv->coef_rcr.decimal), (yuv->coef_rcr.integer));
++	regw_ip(utemp, YUV_MUL_RCR);
++	utemp = IPIPE_S12Q8((yuv->coef_gcr.decimal), (yuv->coef_gcr.integer));
++	regw_ip(utemp, YUV_MUL_GCR);
++	utemp = IPIPE_S12Q8((yuv->coef_bcr.decimal), (yuv->coef_bcr.integer));
++	regw_ip(utemp, YUV_MUL_BCR);
++	regw_ip(yuv->out_ofst_y & RGB2YCBCR_OFST_MASK, YUV_OFT_Y);
++	regw_ip(yuv->out_ofst_cb & RGB2YCBCR_OFST_MASK, YUV_OFT_CB);
++	regw_ip(yuv->out_ofst_cr & RGB2YCBCR_OFST_MASK, YUV_OFT_CR);
++	return 0;
++}
++
++/* YUV 422 conversion */
++int ipipe_set_yuv422_conv_regs(struct prev_yuv422_conv *conv)
++{
++	u32 utemp;
++
++	ipipe_clock_enable();
++	/* Combine all the fields to make YUV_PHS register of IPIPE */
++	utemp = ((conv->chrom_pos << 0) | (conv->en_chrom_lpf << 1));
++	regw_ip(utemp, YUV_PHS);
++	return 0;
++}
++
++/* GBCE */
++int ipipe_set_gbce_regs(struct prev_gbce *gbce)
++{
++	unsigned int count, tbl_index;
++	u32 utemp = 0, mask = GBCE_Y_VAL_MASK;
++
++	if (gbce->type == IPIPE_GBCE_GAIN_TBL)
++		mask = GBCE_GAIN_VAL_MASK;
++
++	ipipe_clock_enable();
++	regw_ip(gbce->en & 1, GBCE_EN);
++	if (gbce->en) {
++		regw_ip(gbce->type, GBCE_TYP);
++		if (gbce->table) {
++			for (count = 0; count < MAX_SIZE_GBCE_LUT; count++) {
++				tbl_index = count >> 1;
++				tbl_index <<= 2;
++				/* Each table has 2 LUT entries, first in LS
++				 * and second in MS positions
++				 */
++				if (count % 2) {
++					utemp |=
++						((gbce->table[count] & mask) <<
++						GBCE_ENTRY_SHIFT);
++					w_ip_table(utemp,
++						tbl_index + GBCE_TB_START_ADDR);
++				} else
++					utemp = gbce->table[count] & mask;
++			}
++		}
++	}
++	return 0;
++}
++/* Edge Enhancement */
++int ipipe_set_ee_regs(struct prev_yee *ee)
++{
++	unsigned int count, tbl_index;
++	u32 utemp;
++
++	ipipe_clock_enable();
++	regw_ip(ee->en, YEE_EN);
++	if (1 == ee->en) {
++		utemp = ee->en_halo_red & 1;
++		utemp |= (ee->merge_meth << YEE_HALO_RED_EN_SHIFT);
++		regw_ip(utemp, YEE_TYP);
++		regw_ip(ee->hpf_shft, YEE_SHF);
++		regw_ip(ee->hpf_coef_00 & YEE_COEF_MASK, YEE_MUL_00);
++		regw_ip(ee->hpf_coef_01 & YEE_COEF_MASK, YEE_MUL_01);
++		regw_ip(ee->hpf_coef_02 & YEE_COEF_MASK, YEE_MUL_02);
++		regw_ip(ee->hpf_coef_10 & YEE_COEF_MASK, YEE_MUL_10);
++		regw_ip(ee->hpf_coef_11 & YEE_COEF_MASK, YEE_MUL_11);
++		regw_ip(ee->hpf_coef_12 & YEE_COEF_MASK, YEE_MUL_12);
++		regw_ip(ee->hpf_coef_20 & YEE_COEF_MASK, YEE_MUL_20);
++		regw_ip(ee->hpf_coef_21 & YEE_COEF_MASK, YEE_MUL_21);
++		regw_ip(ee->hpf_coef_22 & YEE_COEF_MASK, YEE_MUL_22);
++		regw_ip(ee->yee_thr & YEE_THR_MASK, YEE_THR);
++		regw_ip(ee->es_gain & YEE_ES_GAIN_MASK, YEE_E_GAN);
++		regw_ip(ee->es_thr1 & YEE_ES_THR1_MASK, YEE_E_THR1);
++		regw_ip(ee->es_thr2 & YEE_THR_MASK, YEE_E_THR2);
++		regw_ip(ee->es_gain_grad & YEE_THR_MASK, YEE_G_GAN);
++		regw_ip(ee->es_ofst_grad & YEE_THR_MASK, YEE_G_OFT);
++
++		if (ee->table != NULL) {
++			for (count = 0; count < MAX_SIZE_YEE_LUT; count++) {
++				tbl_index = count >> 1;
++				tbl_index <<= 2;
++				/* Each table has 2 LUT entries, first in LS
++				 * and second in MS positions
++				 */
++				if (count % 2) {
++					utemp |= ((ee->table[count] &
++						YEE_ENTRY_MASK) <<
++						YEE_ENTRY_SHIFT);
++					w_ip_table(utemp,
++						tbl_index + YEE_TB_START_ADDR);
++				} else
++					utemp = ee->table[count] &
++						YEE_ENTRY_MASK;
++			}
++		}
++	}
++	return 0;
++}
++
++/* Chromatic Artifact Correction. CAR */
++static void ipipe_set_mf(void)
++{
++	/* typ to dynamic switch */
++	regw_ip(IPIPE_CAR_DYN_SWITCH, CAR_TYP);
++	/* Set SW0 to maximum */
++	regw_ip(CAR_MF_THR, CAR_SW);
++}
++
++static void ipipe_set_gain_ctrl(struct prev_car *car)
++{
++	regw_ip(IPIPE_CAR_CHR_GAIN_CTRL, CAR_TYP);
++	regw_ip(car->hpf, CAR_HPF_TYP);
++	regw_ip(car->hpf_shft & CAR_HPF_SHIFT_MASK, CAR_HPF_SHF);
++	regw_ip(car->hpf_thr, CAR_HPF_THR);
++	regw_ip(car->gain1.gain, CAR_GN1_GAN);
++	regw_ip(car->gain1.shft & CAR_GAIN1_SHFT_MASK, CAR_GN1_SHF);
++	regw_ip(car->gain1.gain_min & CAR_GAIN_MIN_MASK, CAR_GN1_MIN);
++	regw_ip(car->gain2.gain, CAR_GN2_GAN);
++	regw_ip(car->gain2.shft & CAR_GAIN2_SHFT_MASK, CAR_GN2_SHF);
++	regw_ip(car->gain2.gain_min & CAR_GAIN_MIN_MASK, CAR_GN2_MIN);
++}
++
++int ipipe_set_car_regs(struct prev_car *car)
++{
++	u32 utemp;
++	ipipe_clock_enable();
++	regw_ip(car->en, CAR_EN);
++	if (car->en) {
++		switch (car->meth) {
++		case IPIPE_CAR_MED_FLTR:
++			{
++				ipipe_set_mf();
++				break;
++			}
++		case IPIPE_CAR_CHR_GAIN_CTRL:
++			{
++				ipipe_set_gain_ctrl(car);
++				break;
++			}
++		default:
++			{
++				/* Dynamic switch between MF and Gain Ctrl. */
++				ipipe_set_mf();
++				ipipe_set_gain_ctrl(car);
++				/* Set the threshold for switching between
++				 * the two Here we overwrite the MF SW0 value
++				 */
++				regw_ip(IPIPE_CAR_DYN_SWITCH, CAR_TYP);
++				utemp = car->sw1;
++				utemp <<= CAR_SW1_SHIFT;
++				utemp |= car->sw0;
++				regw_ip(utemp, CAR_SW);
++			}
++		}
++	}
++	return 0;
++}
++
++/* Chromatic Gain Suppression */
++int ipipe_set_cgs_regs(struct prev_cgs *cgs)
++{
++	ipipe_clock_enable();
++	regw_ip(cgs->en, CGS_EN);
++	if (cgs->en) {
++		/* Set the bright side parameters */
++		regw_ip(cgs->h_thr, CGS_GN1_H_THR);
++		regw_ip(cgs->h_slope, CGS_GN1_H_GAN);
++		regw_ip(cgs->h_shft & CAR_SHIFT_MASK, CGS_GN1_H_SHF);
++		regw_ip(cgs->h_min, CGS_GN1_H_MIN);
++	}
++	return 0;
++}
++
++void rsz_src_enable(int enable)
++{
++	regw_rsz(enable, RSZ_SRC_EN);
++}
++
++int rsz_enable(int rsz_id, int enable)
++{
++	if (rsz_id == RSZ_A) {
++		regw_rsz(enable, RSZ_EN_A);
++		/* We always enable RSZ_A. RSZ_B is enable upon request from
++		 * application. So enable RSZ_SRC_EN along with RSZ_A
++		 */
++		regw_rsz(enable, RSZ_SRC_EN);
++	} else if (rsz_id == RSZ_B)
++		regw_rsz(enable, RSZ_EN_B);
++	else
++		return -EINVAL;
++	return 0;
++}
+--- /dev/null
++++ b/include/media/davinci/dm365_a3_hw.h
+@@ -0,0 +1,255 @@
++/* *
++ * Copyright (C) 2009 Texas Instruments Inc
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
++ */
++
++#ifndef DM365_A3_HW_H
++#define DM365_A3_HW_H
++
++#ifdef __KERNEL__
++#include <asm/io.h>
++#include <linux/device.h>
++#include <mach/hardware.h>
++#include "dm365_aew.h"
++#include "dm365_af.h"
++
++/* AF/AE/AWB Base address and range */
++#define DM365_A3_HW_ADDR	0x1c71400
++#define DM365_A3_HW_ADDR_SIZE	128
++/* AF Register Offsets */
++
++/* Peripheral Revision and Class Information */
++#define AFPID			0x0
++/* Peripheral Control Register */
++#define AFPCR			0x4
++/* Setup for the Paxel Configuration */
++#define AFPAX1			0x8
++/* Setup for the Paxel Configuration */
++#define AFPAX2			0xc
++/* Start Position for AF Engine Paxels */
++#define AFPAXSTART		0x10
++/* Start Position for IIRSH */
++#define AFIIRSH			0x14
++/* SDRAM/DDRAM Start address */
++#define AFBUFST			0x18
++/* IIR filter coefficient data for SET 0 */
++#define AFCOEF010		0x1c
++/* IIR filter coefficient data for SET 0 */
++#define AFCOEF032		0x20
++/* IIR filter coefficient data for SET 0 */
++#define AFCOEF054		0x24
++/* IIR filter coefficient data for SET 0 */
++#define AFCOEF076		0x28
++/* IIR filter coefficient data for SET 0 */
++#define AFCOEF098		0x2c
++/* IIR filter coefficient data for SET 0 */
++#define AFCOEF0010		0x30
++/* IIR filter coefficient data for SET 1 */
++#define AFCOEF110		0x34
++/* IIR filter coefficient data for SET 1 */
++#define AFCOEF132		0x38
++/* IIR filter coefficient data for SET 1 */
++#define AFCOEF154		0x3c
++/* IIR filter coefficient data for SET 1 */
++#define AFCOEF176		0x40
++/* IIR filter coefficient data for SET 1 */
++#define AFCOEF198		0x44
++/* IIR filter coefficient data for SET 1 */
++#define AFCOEF1010		0x48
++
++/* Vertical Focus vlaue configuration 1 */
++#define AF_VFV_CFG1		0x68
++/* Vertical Focus vlaue configuration 2 */
++#define AF_VFV_CFG2		0x6c
++/* Vertical Focus vlaue configuration 3 */
++#define AF_VFV_CFG3		0x70
++/* Vertical Focus vlaue configuration 4 */
++#define AF_VFV_CFG4		0x74
++/* Horizontal Focus vlaue Threshold */
++#define AF_HFV_THR		0x78
++/* COEFFICIENT BASE ADDRESS */
++
++#define AF_OFFSET	0x00000004
++
++/* AEW Register offsets */
++#define AEWPID			AFPID
++/* Peripheral Control Register */
++#define AEWPCR			AFPCR
++/* Configuration for AE/AWB Windows */
++#define AEWWIN1			0x4c
++/* Start position for AE/AWB Windows */
++#define AEWINSTART		0x50
++/* Start position and height for black linr of AE/AWB Windows */
++#define AEWINBLK		0x54
++/* Configuration for subsampled data in AE/AWB windows */
++#define AEWSUBWIN		0x58
++/* SDRAM/DDRAM Start address for AEW Engine */
++#define AEWBUFST       		0x5c
++/* Line start */
++#define LINE_START		0x64
++
++/* AEW Engine configuration */
++#define AEW_CFG			0x60
++
++/* PID fields */
++#define PID_MINOR			(0x3f << 0)
++#define PID_MAJOR			(7 << 8)
++#define PID_RTL				(0x1f << 11)
++#define PID_FUNC			(0xFFF << 16)
++#define PID_SCHEME			(3 << 30)
++
++/* PCR FIELDS */
++
++/*Saturation Limit */
++#define AVE2LMT			(0x3ff << 22)
++#define AF_VF_EN		(1 << 20)
++#define AEW_MED_EN		(1 << 19)
++/* Busy bit for AEW */
++#define AEW_BUSYAEWB		(1 << 18)
++/* Alaw Enable/Disable Bit */
++#define AEW_ALAW_EN		(1 << 17)
++/* AEW Engine Enable/Disable bit */
++#define AEW_EN			(1 << 16)
++/* Busy Bit for AF */
++#define AF_BUSYAF		(1 << 15)
++#define FVMODE			(1 << 14)
++#define RGBPOS			(7 << 11)
++#define MED_TH			(0xFF << 3)
++#define AF_MED_EN		(1 << 2)
++#define AF_ALAW_EN		(1 << 1)
++#define AF_EN			(1 << 0)
++
++/*
++ * AFPAX1 fields
++ */
++#define PAXW			(0xFF << 16)
++#define PAXH			(0xFF)
++
++/*
++ * AFPAX2 fields
++ */
++#define  AFINCH			(0xF << 17)
++#define  AFINCV			(0xF << 13)
++#define  PAXVC			(0x7F << 6)
++#define  PAXHC			(0x3F)
++
++/*
++ * AFPAXSTART fields
++ */
++#define  PAXSH			(0xFFF << 16)
++#define  PAXSV			(0xFFF)
++
++/*
++ * IIR COEFFICIENT MASKS
++ */
++#define COEF_MASK0		(0xFFF)
++#define COEF_MASK1		(0xFFF << 16)
++
++/*
++ * VFV_CFGX COEFFICIENT MASKS
++ */
++#define VFV_COEF_MASK0		(0xFF)
++#define VFV_COEF_MASK1		(0xFF << 8)
++#define VFV_COEF_MASK2		(0xFF << 16)
++#define VFV_COEF_MASK3		(0xFF << 24)
++
++/* HFV THR MASKS */
++#define HFV_THR0_MASK		(0xFFFF)
++#define HFV_THR2_SHIFT		(16)
++#define HFV_THR2_MASK		(0xFFFF << HFV_THR2_SHIFT)
++
++/* VFV THR MASKS */
++#define VFV_THR_SHIFT		(16)
++#define VFV_THR_MASK		(0xFFFF << VFV_THR_SHIFT)
++
++/* BIT SHIFTS */
++#define AF_BUSYAF_SHIFT			15
++#define AEW_EN_SHIFT			16
++#define AEW_BUSYAEW_SHIFT		18
++#define AF_RGBPOS_SHIFT			11
++#define AF_MED_TH_SHIFT			3
++#define AF_PAXW_SHIFT			16
++#define AF_LINE_INCR_SHIFT		13
++#define AF_COLUMN_INCR_SHIFT		17
++#define AF_VT_COUNT_SHIFT		6
++#define AF_HZ_START_SHIFT		16
++#define AF_COEF_SHIFT			16
++
++/* AEWWIN1 fields */
++/* Window Height */
++#define WINH			(0x7F << 24)
++/* Window Width */
++#define WINW			(0x7f << 13)
++/* Window vertical Count */
++#define WINVC			(0x7f << 6)
++/* Window Horizontal Count */
++#define WINHC			(0x3f)
++
++/* AEWWINSTART fields */
++/* Window Vertical Start */
++#define WINSV			(0xfff << 16)
++/* Window Horizontal start */
++#define WINSH			(0xfff)
++
++/* AEWWINBLK fields
++ * Black Window Vertical Start
++ */
++#define BLKWINSV		(0xfff << 16)
++/* Black Window height */
++#define BLKWINH			(0x7f)
++
++/* AEWSUBWIN fields
++ * Vertical Lime Increment
++ */
++#define AEWINCV			(0xf << 8)
++/* Horizontal Line Increment */
++#define AEWINCH			(0xf)
++
++/* BIT POSITIONS */
++#define AEW_AVE2LMT_SHIFT		22
++
++#define AEW_WINH_SHIFT			24
++#define AEW_WINW_SHIFT              	13
++#define AEW_VT_COUNT_SHIFT		6
++#define AEW_VT_START_SHIFT		16
++#define AEW_LINE_INCR_SHIFT		8
++#define AEW_BLKWIN_VT_START_SHIFT   	16
++#define AEW_EN_SHIFT                	16
++#define AEW_BUSYAEWB_SHIFT          	18
++
++#define AEFMT_SHFT			8
++#define AEFMT_MASK			(3 << AEFMT_SHFT)
++#define AEW_SUMSHFT_MASK		(0xf)
++
++#define SET_VAL(x)		(((x) / 2) - 1)
++#define NOT_EVEN		1
++#define CHECK_EVEN(x)		((x) % 2)
++
++/* Function declaration for af */
++int af_register_setup(struct device *, struct af_device *);
++void af_engine_setup(struct device *, int);
++void af_set_address(struct device *, unsigned long);
++/* Function Declaration for aew */
++int aew_register_setup(struct device *, struct aew_device *);
++void aew_engine_setup(struct device *, int);
++void aew_set_address(struct device *, unsigned long);
++u32 af_get_hw_state(void);
++u32 aew_get_hw_state(void);
++u32 af_get_enable(void);
++u32 aew_get_enable(void);
++
++#endif				/*end of #ifdef __KERNEL__ */
++#endif				/*end of #ifdef __DAVINCI_A3_HW_H */
+--- /dev/null
++++ b/drivers/media/video/davinci/dm365_af.c
+@@ -0,0 +1,830 @@
++/* *
++ * Copyright (C) 2009 Texas Instruments Inc
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
++ */
++#include <linux/module.h>
++#include <linux/init.h>
++#include <linux/kernel.h>
++#include <linux/slab.h>
++#include <linux/fs.h>
++#include <linux/errno.h>
++#include <linux/types.h>
++#include <linux/cdev.h>
++#include <linux/interrupt.h>
++#include <linux/dma-mapping.h>
++#include <linux/uaccess.h>
++#include <linux/platform_device.h>
++#include <linux/major.h>
++#include <media/davinci/dm365_a3_hw.h>
++#include <media/davinci/vpss.h>
++
++
++/*Global structure for device */
++struct af_device *af_dev_configptr;
++
++/* For registeration of character device */
++static struct cdev c_dev;
++
++/* device structure to make entry in device */
++static struct class *af_class;
++static dev_t dev;
++struct device *afdev;
++
++/* inline function to free reserver pages  */
++inline void af_free_pages(unsigned long addr, unsigned long bufsize)
++{
++	unsigned long tempaddr;
++	unsigned long size;
++	tempaddr = addr;
++	if (!addr)
++		return;
++	size = PAGE_SIZE << (get_order(bufsize));
++	while (size > 0) {
++		ClearPageReserved(virt_to_page(addr));
++		addr += PAGE_SIZE;
++		size -= PAGE_SIZE;
++	}
++	free_pages(tempaddr, get_order(bufsize));
++}
++
++/* Function to check paxel parameters */
++static int af_validate_parameters(void)
++{
++	int result = 0;
++	dev_dbg(afdev, "E\n");
++	/* Check horizontal Count */
++	if ((af_dev_configptr->config->paxel_config.hz_cnt <
++	     AF_PAXEL_HORIZONTAL_COUNT_MIN) ||
++	   (af_dev_configptr->config->paxel_config.hz_cnt >
++		AF_PAXEL_HORIZONTAL_COUNT_MAX)) {
++		dev_err(afdev, "\n Invalid Parameters");
++		dev_err(afdev, "\n Paxel Horizontal Count is incorrect");
++		result = -EINVAL;
++	}
++	/* Check Vertical Count */
++	if ((af_dev_configptr->config->paxel_config.vt_cnt <
++	     AF_PAXEL_VERTICAL_COUNT_MIN) ||
++	    (af_dev_configptr->config->paxel_config.vt_cnt >
++		AF_PAXEL_VERTICAL_COUNT_MAX)) {
++		dev_err(afdev, "\n Invalid Parameters");
++		dev_err(afdev, "\n Paxel Vertical Count is incorrect");
++		result = -EINVAL;
++	}
++	/* Check line increment */
++	if ((NOT_EVEN ==
++	     CHECK_EVEN(af_dev_configptr->config->paxel_config.line_incr)) ||
++	   (af_dev_configptr->config->paxel_config.line_incr <
++		AF_LINE_INCR_MIN) ||
++	   (af_dev_configptr->config->paxel_config.line_incr >
++		AF_LINE_INCR_MAX)) {
++		dev_err(afdev, "\n Invalid Parameters");
++		dev_err(afdev, "\n Paxel Line Increment is incorrect");
++		result = -EINVAL;
++	}
++	if (af_dev_configptr->config->fv_sel == AF_HFV_AND_VFV) {
++		if ((NOT_EVEN ==
++			CHECK_EVEN(af_dev_configptr->config->\
++				paxel_config.column_incr)) ||
++			(af_dev_configptr->config->paxel_config.column_incr <
++				AF_COLUMN_INCR_MIN) ||
++			(af_dev_configptr->config->paxel_config.column_incr >
++				AF_COLUMN_INCR_MAX)) {
++			dev_err(afdev, "\n Invalid Parameters");
++			dev_err(afdev, "\n Paxel Column Increment is"
++					"incorrect");
++			result = -EINVAL;
++		}
++	}
++	/* Check width */
++	if ((NOT_EVEN ==
++	     CHECK_EVEN(af_dev_configptr->config->paxel_config.width)) ||
++	    (af_dev_configptr->config->paxel_config.width < AF_WIDTH_MIN) ||
++	    (af_dev_configptr->config->paxel_config.width > AF_WIDTH_MAX)) {
++		dev_err(afdev, "\n Invalid Parameters");
++		dev_err(afdev, "\n Paxel Width is incorrect");
++		result = -EINVAL;
++	}
++	/* Check Height */
++	if ((NOT_EVEN ==
++	     CHECK_EVEN(af_dev_configptr->config->paxel_config.height)) ||
++	    (af_dev_configptr->config->paxel_config.height < AF_HEIGHT_MIN) ||
++	    (af_dev_configptr->config->paxel_config.height > AF_HEIGHT_MAX)) {
++		dev_err(afdev, "\n Invalid Parameters");
++		dev_err(afdev, "\n Paxel Height is incorrect");
++		result = -EINVAL;
++	}
++	/* Check Horizontal Start */
++	if ((NOT_EVEN ==
++	     CHECK_EVEN(af_dev_configptr->config->paxel_config.hz_start)) ||
++	    (af_dev_configptr->config->paxel_config.hz_start <
++		(af_dev_configptr->config->iir_config.hz_start_pos + 2)) ||
++	    (af_dev_configptr->config->paxel_config.hz_start <
++		AF_HZSTART_MIN) ||
++	    (af_dev_configptr->config->paxel_config.hz_start >
++		AF_HZSTART_MAX)) {
++		dev_err(afdev, "\n Invalid Parameters");
++		dev_err(afdev, "\n Paxel horizontal start is  incorrect");
++		result = -EINVAL;
++	}
++	/* Check Vertical Start */
++	if ((af_dev_configptr->config->paxel_config.vt_start <
++		AF_VTSTART_MIN) ||
++	   (af_dev_configptr->config->paxel_config.vt_start >
++		AF_VTSTART_MAX)) {
++		dev_err(afdev, "\n Invalid Parameters");
++		dev_err(afdev, "\n Paxel vertical start is  incorrect");
++		result = -EINVAL;
++	}
++	/* Check Threshold  */
++	if ((af_dev_configptr->config->hmf_config.threshold > AF_MEDTH_MAX) &&
++	   (af_dev_configptr->config->hmf_config.enable == H3A_AF_ENABLE)) {
++		dev_err(afdev, "\n Invalid Parameters");
++		dev_err(afdev,
++			"\n Horizontal Median Filter Threshold is incorrect");
++		result = -EINVAL;
++	}
++	/* Check IIRSH start */
++	if (af_dev_configptr->config->iir_config.hz_start_pos > AF_IIRSH_MAX) {
++		dev_err(afdev, "\n Invalid Parameters");
++		dev_err(afdev,
++			"\n IIR FITLER  horizontal start position incorrect");
++		result = -EINVAL;
++	}
++	/* Verify ALaw */
++	if ((af_dev_configptr->config->alaw_enable < H3A_AF_DISABLE) ||
++	   (af_dev_configptr->config->alaw_enable > H3A_AF_ENABLE)) {
++		dev_err(afdev, "\n Invalid Parameters");
++		dev_err(afdev, "\n ALaw Setting is incorrect");
++		result = -EINVAL;
++	}
++	/* Verify Horizontal Median Filter Setting */
++	if ((af_dev_configptr->config->hmf_config.enable < H3A_AF_DISABLE) ||
++	   (af_dev_configptr->config->hmf_config.enable > H3A_AF_ENABLE)) {
++		dev_err(afdev, "\n Invalid Parameters");
++		dev_err(afdev,
++			"\n Horizontal Median Filter Setting is incorrect");
++		result = -EINVAL;
++	}
++	/* Check RGB position if HFV used */
++	if (af_dev_configptr->config->fv_sel == AF_HFV_ONLY &&
++	   ((af_dev_configptr->config->rgb_pos < GR_GB_BAYER) ||
++	   (af_dev_configptr->config->rgb_pos > RB_GG_CUSTOM))) {
++		dev_err(afdev, "\n Invalid Parameters");
++		dev_err(afdev, "\n RGB Position Setting is incorrect");
++		result = -EINVAL;
++	}
++	if (af_dev_configptr->config->fv_sel == AF_HFV_AND_VFV) {
++		/* Check for threshold values */
++		if (af_dev_configptr->config->fir_config.hfv_thr1 >
++			AF_HFV_THR_MAX ||
++			af_dev_configptr->config->fir_config.hfv_thr2 >
++			AF_HFV_THR_MAX) {
++			dev_err(afdev, "\n Invalid Parameters");
++			dev_err(afdev, "\n HFV FIR 1 or FIR 2 Threshold"
++					" incorrect");
++			result = -EINVAL;
++		}
++		if (af_dev_configptr->config->fir_config.vfv_thr1 >
++			AF_VFV_THR_MAX ||
++			af_dev_configptr->config->fir_config.vfv_thr2 >
++			AF_VFV_THR_MAX) {
++			dev_err(afdev, "\n Invalid Parameters");
++			dev_err(afdev, "\n VFV FIR 1 or FIR 2 Threshold"
++				" incorrect");
++			result = -EINVAL;
++		}
++	}
++	dev_dbg(afdev, "L\n");
++	return result;
++}
++
++/* Function to perform hardware set up */
++int af_hardware_setup(void)
++{
++	int result;
++
++	/* Size for buffer in bytes */
++	int buff_size;
++	unsigned long adr, size;
++	unsigned int busyaf;
++	dev_dbg(afdev, "E\n");
++
++	/* Get the value of PCR register */
++	busyaf = af_get_hw_state();
++
++	/* If busy bit is 1 then busy lock registers caanot be configured */
++	if (busyaf == 1) {
++		/* Hardware cannot be configure while engine is busy */
++		dev_err(afdev, "AF_register_setup_ERROR : Engine Busy");
++		dev_err(afdev, "\n Configuration cannot be done ");
++		return -EBUSY;
++	}
++
++	/* Check IIR Coefficient and start Values */
++	result = af_validate_parameters();
++	if (result < 0)
++		return result;
++
++	/* Compute buffer size */
++	if (af_dev_configptr->config->fv_sel == AF_HFV_ONLY)
++		buff_size =
++			(af_dev_configptr->config->paxel_config.hz_cnt) *
++			(af_dev_configptr->config->paxel_config.vt_cnt) *
++			AF_PAXEL_SIZE_HF_ONLY;
++	else
++		buff_size =
++			(af_dev_configptr->config->paxel_config.hz_cnt) *
++			(af_dev_configptr->config->paxel_config.vt_cnt) *
++			AF_PAXEL_SIZE_HF_VF;
++
++	/* Deallocate the previosu buffers free old buffers */
++	if (af_dev_configptr->buff_old)
++		af_free_pages((unsigned long)af_dev_configptr->buff_old,
++			      af_dev_configptr->size_paxel);
++
++	/* Free current buffer */
++	if (af_dev_configptr->buff_curr)
++		af_free_pages((unsigned long)af_dev_configptr->buff_curr,
++			      af_dev_configptr->size_paxel);
++
++	/* Free application buffers */
++	if (af_dev_configptr->buff_app)
++		af_free_pages((unsigned long)af_dev_configptr->buff_app,
++			      af_dev_configptr->size_paxel);
++
++	/*
++	 * Reallocate the buffer as per new paxel configurations
++	 * Allocate memory for old buffer
++	 */
++	af_dev_configptr->buff_old =
++	    (void *)__get_free_pages(GFP_KERNEL | GFP_DMA,
++				     get_order(buff_size));
++
++	if (af_dev_configptr->buff_old == NULL)
++		return -ENOMEM;
++
++	/* allocate the memory for storing old statistics */
++	adr = (unsigned long)af_dev_configptr->buff_old;
++	size = PAGE_SIZE << (get_order(buff_size));
++	while (size > 0) {
++		/*
++		 * make sure the frame buffers
++		 * are never swapped out of memory
++		 */
++		SetPageReserved(virt_to_page(adr));
++		adr += PAGE_SIZE;
++		size -= PAGE_SIZE;
++	}
++
++	/* Allocate memory for current buffer */
++	af_dev_configptr->buff_curr =
++	    (void *)__get_free_pages(GFP_KERNEL | GFP_DMA,
++				     get_order(buff_size));
++
++	/* Free the previously allocated buffer */
++	if (af_dev_configptr->buff_curr == NULL) {
++		if (af_dev_configptr->buff_old)
++			af_free_pages((unsigned long)af_dev_configptr->
++				      buff_old, buff_size);
++		return -ENOMEM;
++	}
++
++	adr = (unsigned long)af_dev_configptr->buff_curr;
++	size = PAGE_SIZE << (get_order(buff_size));
++	while (size > 0) {
++		/*
++		 * make sure the frame buffers
++		 * are never swapped out of memory
++		 */
++		SetPageReserved(virt_to_page(adr));
++		adr += PAGE_SIZE;
++		size -= PAGE_SIZE;
++	}
++
++	/* Allocate memory for old buffer */
++	af_dev_configptr->buff_app =
++	    (void *)__get_free_pages(GFP_KERNEL | GFP_DMA,
++				     get_order(buff_size));
++
++	if (af_dev_configptr->buff_app == NULL) {
++
++		/* Free the previously allocated buffer */
++		if (af_dev_configptr->buff_curr)
++			af_free_pages((unsigned long)af_dev_configptr->
++				      buff_curr, buff_size);
++		/* Free the previously allocated buffer */
++		if (af_dev_configptr->buff_old)
++			af_free_pages((unsigned long)af_dev_configptr->
++				      buff_old, buff_size);
++		return -ENOMEM;
++	}
++
++	adr = (unsigned long)af_dev_configptr->buff_app;
++	size = PAGE_SIZE << (get_order(buff_size));
++	while (size > 0) {
++		/*
++		 * make sure the frame buffers
++		 * are never swapped out of memory
++		 */
++		SetPageReserved(virt_to_page(adr));
++		adr += PAGE_SIZE;
++		size -= PAGE_SIZE;
++	}
++
++	result = af_register_setup(afdev, af_dev_configptr);
++	if (result < 0)
++		return result;
++	af_dev_configptr->size_paxel = buff_size;
++
++	/* Set configuration flag to indicate HW setup done */
++	af_dev_configptr->af_config = H3A_AF_CONFIG;
++
++	dev_dbg(afdev, "L\n");
++	return 0;
++}
++
++/*
++ * This function called when driver is opened.It creates Channel
++ * Configuration Structure
++ */
++static int af_open(struct inode *inode, struct file *filp)
++{
++	dev_dbg(afdev, "E\n");
++
++	/* Return if device is in use */
++	if (af_dev_configptr->in_use == AF_IN_USE)
++		return -EBUSY;
++	af_dev_configptr->config = NULL;
++
++	/* Allocate memory for Device Structure */
++	af_dev_configptr->config = kmalloc(sizeof(struct af_configuration)
++						, GFP_KERNEL);
++	if (af_dev_configptr->config == NULL) {
++		dev_err(afdev, "Error : Kmalloc fail\n");
++		return -ENOMEM;
++	}
++
++	/* Initialize the wait queue */
++	init_waitqueue_head(&(af_dev_configptr->af_wait_queue));
++
++	/* Driver is in use */
++	af_dev_configptr->in_use = AF_IN_USE;
++
++	/* Hardware is not set up */
++	af_dev_configptr->af_config = H3A_AF_CONFIG_NOT_DONE;
++	af_dev_configptr->buffer_filled = 0;
++
++	/* Initialize the mutex */
++	mutex_init(&(af_dev_configptr->read_blocked));
++	dev_dbg(afdev, "L\n");
++	return 0;
++}
++
++/*
++ * This function called when driver is closed.
++ * It will deallocate all the buffers.
++ */
++static int af_release(struct inode *inode, struct file *filp)
++{
++	dev_dbg(afdev, "E\n");
++
++	af_engine_setup(afdev, 0);
++	/* free current buffer */
++	if (af_dev_configptr->buff_curr)
++		af_free_pages((unsigned long)af_dev_configptr->buff_curr,
++			      af_dev_configptr->size_paxel);
++
++	/* Free old buffer */
++	if (af_dev_configptr->buff_old)
++		af_free_pages((unsigned long)af_dev_configptr->buff_old,
++			      af_dev_configptr->size_paxel);
++
++	/* Free application buffer */
++	if (af_dev_configptr->buff_app)
++		af_free_pages((unsigned long)af_dev_configptr->buff_app,
++			      af_dev_configptr->size_paxel);
++
++	/* Release memory for configuration structure of this channel */
++	af_dev_configptr->buff_curr = NULL;
++	af_dev_configptr->buff_old = NULL;
++	af_dev_configptr->buff_app = NULL;
++	kfree(af_dev_configptr->config);
++	af_dev_configptr->config = NULL;
++
++	/* Device is not in use */
++	af_dev_configptr->in_use = AF_NOT_IN_USE;
++
++	dev_dbg(afdev, "L\n");
++
++	return 0;
++}
++static void af_platform_release(struct device *device)
++{
++	/* This is called when the reference count goes to zero */
++}
++static int af_probe(struct device *device)
++{
++	afdev = device;
++	return 0;
++}
++
++static int af_remove(struct device *device)
++{
++	return 0;
++}
++
++/*
++ * This function will process IOCTL commands sent by the application and
++ * control the device IO operations.
++ */
++static int af_ioctl(struct inode *inode, struct file *filep,
++		    unsigned int cmd, unsigned long arg)
++{
++	struct af_configuration afconfig = *(af_dev_configptr->config);
++	int result = 0;
++	dev_dbg(afdev, "E\n");
++
++	/* Block the mutex while ioctl is called */
++	result = mutex_lock_interruptible(&af_dev_configptr->read_blocked);
++	if (result)
++		return result;
++
++	/* Extract the type and number bitfields, and don't decode wrong cmds */
++	if (_IOC_TYPE(cmd) != AF_MAGIC_NO) {
++		mutex_unlock(&af_dev_configptr->read_blocked);
++		return -ENOTTY;
++	}
++
++	if (_IOC_NR(cmd) > AF_IOC_MAXNR) {
++		mutex_unlock(&af_dev_configptr->read_blocked);
++		return -ENOTTY;
++	}
++
++	/* Use 'access_ok' to validate user space pointer */
++	if (_IOC_DIR(cmd) & _IOC_READ)
++		result =
++		    !access_ok(VERIFY_WRITE, (void __user *)arg,
++			       _IOC_SIZE(cmd));
++	else if (_IOC_DIR(cmd) & _IOC_WRITE)
++		result =
++		    !access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd));
++
++	if (result) {
++		mutex_unlock(&af_dev_configptr->read_blocked);
++		return -EFAULT;
++	}
++
++	switch (cmd) {
++
++		/*
++		 * This ioctl is used to perform hardware
++		 * set up for AF Engine. It will configure all the registers.
++		 */
++	case AF_S_PARAM:
++		if (copy_from_user(af_dev_configptr->config,
++				   (struct af_configuration *)arg,
++				   sizeof(struct af_configuration))) {
++			/* Release the semaphore */
++			mutex_unlock(&af_dev_configptr->read_blocked);
++			return -EFAULT;
++		}
++
++		/* Call AF_hardware_setup to perform register configuration */
++		result = af_hardware_setup();
++		if (!result) {
++			result = af_dev_configptr->size_paxel;
++		} else {
++			dev_err(afdev, "Error : AF_S_PARAM failed");
++			*(af_dev_configptr->config) = afconfig;
++		}
++		break;
++
++		/* This ioctl will get the paramters from application */
++	case AF_G_PARAM:
++		/* Check if Hardware is configured or not */
++		if (af_dev_configptr->af_config == H3A_AF_CONFIG) {
++			if (copy_to_user((struct af_configuration *)arg,
++					 af_dev_configptr->config,
++					 sizeof(struct af_configuration))) {
++				mutex_unlock(&af_dev_configptr->read_blocked);
++				return -EFAULT;
++			} else
++				result = af_dev_configptr->size_paxel;
++
++		} else {
++			dev_dbg(afdev, "Error : AF Hardware not configured.");
++			result = -EINVAL;
++		}
++
++		break;
++
++		/*
++		 * This ioctl will enable AF Engine if hardware configuration
++		 * is done
++		 */
++	case AF_ENABLE:
++		/* Check if hardware is configured or not */
++		if (af_dev_configptr->af_config == H3A_AF_CONFIG_NOT_DONE) {
++			dev_err(afdev, "Error :  AF Hardware not configured.");
++			result = -EINVAL;
++		} else
++			af_engine_setup(afdev, 1);
++		break;
++
++		/* This ioctl will disable AF Engine */
++	case AF_DISABLE:
++		af_engine_setup(afdev, 0);
++		break;
++
++	default:
++		dev_err(afdev, "Error : Invalid IOCTL!");
++		result = -ENOTTY;
++		break;
++	}
++
++	/* Before returning increment semaphore */
++	mutex_unlock(&af_dev_configptr->read_blocked);
++	dev_dbg(afdev, "L\n");
++	return result;
++}
++
++/* Function will return the statistics to user */
++ssize_t af_read(struct file *filep, char *kbuff, size_t size, loff_t *offset)
++{
++	void *buff_temp;
++	int result = 0;
++	int ret;
++	dev_dbg(afdev, "E\n");
++
++	ret = mutex_trylock(&(af_dev_configptr->read_blocked));
++	if (!ret) {
++		dev_err(afdev, "\n Read Call : busy");
++		return -EBUSY;
++	}
++
++	/*
++	 * If no of bytes specified by the user is less than that of buffer
++	 * return error
++	 */
++	if (size < af_dev_configptr->size_paxel) {
++		dev_err(afdev, "\n Error : Invalid buffer size");
++		mutex_unlock(&(af_dev_configptr->read_blocked));
++		return -1;
++	}
++
++	/*
++	 * The value of bufffer_filled flag determines
++	 * the status of statistics
++	 */
++	if (af_dev_configptr->buffer_filled == 0) {
++		dev_dbg(afdev, "Read call is blocked .......................");
++		/*
++		 * Block the read call until new statistics are available
++		 * or timer expires Decrement the semaphore count
++		 */
++		wait_event_interruptible_timeout(af_dev_configptr->
++						 af_wait_queue,
++						 af_dev_configptr->
++						 buffer_filled, AF_TIMEOUT);
++		dev_dbg(afdev,
++			"\n Read Call Unblocked..........................");
++	}
++	if (af_dev_configptr->buffer_filled == 1) {
++		/*
++		 * New Statistics are available. Disable the interrupts while
++		 * swapping the buffers
++		 */
++		dev_dbg(afdev, "\n Reading.............................");
++		disable_irq(3);
++
++		af_dev_configptr->buffer_filled = 0;
++
++		/* Swap application buffer and old buffer */
++		buff_temp = af_dev_configptr->buff_old;
++		af_dev_configptr->buff_old = af_dev_configptr->buff_app;
++		af_dev_configptr->buff_app = buff_temp;
++
++		dev_dbg(afdev, "\n Reading Done.............................");
++
++		/* Enable the interrupts  once swapping is done */
++		enable_irq(3);
++
++		/*
++		 * New Statistics are not availaible copy the application
++		 * buffer to user. Return the entire statistics to user
++		 */
++		if (copy_to_user(kbuff, af_dev_configptr->buff_app,
++				 af_dev_configptr->size_paxel)) {
++			/* Release the semaphore in case of fault */
++			mutex_unlock(&(af_dev_configptr->read_blocked));
++			return -EFAULT;
++		} else
++			result = af_dev_configptr->size_paxel;
++	}
++
++	/* Release the Mutex */
++	mutex_unlock(&(af_dev_configptr->read_blocked));
++	dev_dbg(afdev, "\n Read APPLICATION  BUFFER %d",
++		*((int *)((af_dev_configptr->buff_app))));
++	dev_dbg(afdev, "L\n");
++	return result;
++}
++
++/* This function will handle the H3A interrupt. */
++static irqreturn_t af_isr(int irq, void *dev_id)
++{
++	/* Temporary buffer for swapping */
++	void *buff_temp;
++	int enaf;
++
++	dev_dbg(afdev, "E\n");
++
++	/* Get the value of PCR register */
++	enaf = af_get_enable();
++
++	/* If AF Engine has enabled, interrupt is not for AF */
++	if (!enaf)
++		return IRQ_RETVAL(IRQ_NONE);
++
++	/*
++	 * Service  the Interrupt.  Set buffer filled flag to indicate
++	 * statistics are available. Swap current buffer and old buffer
++	 */
++	if (af_dev_configptr) {
++		buff_temp = af_dev_configptr->buff_curr;
++		af_dev_configptr->buff_curr = af_dev_configptr->buff_old;
++		af_dev_configptr->buff_old = buff_temp;
++
++		/* Set AF Buf st to current register address */
++		if (af_dev_configptr->buff_curr)
++			af_set_address(afdev, (unsigned long)
++			       virt_to_phys(af_dev_configptr->buff_curr));
++
++		/* Wake up read as new statistics are available */
++		af_dev_configptr->buffer_filled = 1;
++		wake_up(&(af_dev_configptr->af_wait_queue));
++		dev_dbg(afdev, "L\n");
++		return IRQ_RETVAL(IRQ_HANDLED);
++	}
++	return IRQ_RETVAL(IRQ_NONE);
++}
++
++/* File Operation Structure */
++static const struct file_operations af_fops = {
++	.owner = THIS_MODULE,
++	.open = af_open,
++	.ioctl = af_ioctl,
++	.read = af_read,
++	.release = af_release
++};
++static struct platform_device afdevice = {
++	.name = "dm365_af",
++	.id = 2,
++	.dev = {
++		.release = af_platform_release,
++		}
++};
++
++static struct device_driver af_driver = {
++	.name = "dm365_af",
++	.bus = &platform_bus_type,
++	.probe = af_probe,
++	.remove = af_remove,
++};
++
++/* Function to register the AF character device driver. */
++#define DRIVERNAME  "DM365AF"
++int __init af_init(void)
++{
++	int err;
++	int result = 0;
++
++	/*
++	 * Register the driver in the kernel
++	 * dynmically get the major number for the driver using
++	 * alloc_chrdev_region function
++	 */
++	result = alloc_chrdev_region(&dev, 0, 1, DRIVERNAME);
++
++	if (result < 0) {
++		printk(KERN_ERR "Error :  Could not register character device");
++		return -ENODEV;
++	}
++	printk(KERN_INFO "af major#: %d, minor# %d\n", MAJOR(dev), MINOR(dev));
++	/* allocate memory for device structure and initialize it with 0 */
++	af_dev_configptr =
++	    kmalloc(sizeof(struct af_device), GFP_KERNEL);
++	if (!af_dev_configptr) {
++		printk(KERN_ERR "Error : kmalloc fail");
++		unregister_chrdev_region(dev, AF_NR_DEVS);
++		return -ENOMEM;
++	}
++	/* Initialize character device */
++	cdev_init(&c_dev, &af_fops);
++	c_dev.owner = THIS_MODULE;
++	c_dev.ops = &af_fops;
++	err = cdev_add(&c_dev, dev, 1);
++	if (err) {
++		printk(KERN_ERR "Error : Error in  Adding Davinci AF");
++		unregister_chrdev_region(dev, AF_NR_DEVS);
++		kfree(af_dev_configptr);
++		return -err;
++	}
++	/* register driver as a platform driver */
++	if (driver_register(&af_driver) != 0) {
++		unregister_chrdev_region(dev, 1);
++		cdev_del(&c_dev);
++		return -EINVAL;
++	}
++
++	/* Register the drive as a platform device */
++	if (platform_device_register(&afdevice) != 0) {
++		driver_unregister(&af_driver);
++		unregister_chrdev_region(dev, 1);
++		cdev_del(&c_dev);
++		return -EINVAL;
++	}
++	af_class = class_create(THIS_MODULE, "dm365_af");
++	if (!af_class) {
++		printk(KERN_ERR "af_init: error in creating device class\n");
++		driver_unregister(&af_driver);
++		platform_device_unregister(&afdevice);
++		unregister_chrdev_region(dev, 1);
++		unregister_chrdev(MAJOR(dev), DRIVERNAME);
++		cdev_del(&c_dev);
++		return -EINVAL;
++	}
++	/* register device class */
++	device_create(af_class, NULL, dev, NULL, "dm365_af");
++
++	/* Set up the Interrupt handler for H3AINT interrupt */
++	result = request_irq(3, af_isr, IRQF_SHARED, "dm365_h3a_af",
++			     (void *)af_dev_configptr);
++
++	if (result != 0) {
++		printk(KERN_ERR "Error : Request IRQ Failed");
++		unregister_chrdev_region(dev, AF_NR_DEVS);
++		kfree(af_dev_configptr);
++		device_destroy(af_class, dev);
++		class_destroy(af_class);
++		driver_unregister(&af_driver);
++		platform_device_unregister(&afdevice);
++		cdev_del(&c_dev);
++		return result;
++	}
++
++	/* Initialize device structure */
++	memset((unsigned char *)af_dev_configptr, 0, sizeof(struct af_device));
++
++	af_dev_configptr->in_use = AF_NOT_IN_USE;
++	af_dev_configptr->buffer_filled = 0;
++	printk(KERN_ERR "AF Driver initialized\n");
++	return 0;
++}
++
++/*
++ * This function is called by the kernel while unloading the driver.
++ * It will unregister character device driver
++ */
++void __exit af_cleanup(void)
++{
++	/* Return if driver is busy */
++	if (af_dev_configptr->in_use == AF_IN_USE) {
++		printk(KERN_ERR "Error : Driver in use. Can't remove.");
++		return;
++	}
++	free_irq(3, af_dev_configptr);
++	/* Free device structure */
++	kfree(af_dev_configptr);
++
++	unregister_chrdev_region(dev, AF_NR_DEVS);
++
++	driver_unregister(&af_driver);
++
++	device_destroy(af_class, dev);
++
++	class_destroy(af_class);
++
++	platform_device_unregister(&afdevice);
++	/* unregistering the driver from the kernel */
++	cdev_del(&c_dev);
++
++}
++
++module_init(af_init)
++module_exit(af_cleanup)
++/* Module License */
++MODULE_LICENSE("GPL");
+--- /dev/null
++++ b/drivers/char/dm365_def_para.c
+@@ -0,0 +1,486 @@
++/*
++ *
++ * Copyright (C) 2008 Texas Instruments Inc
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
++ *
++ **************************************************************************/
++#include <media/davinci/dm365_ipipe.h>
++/* Defaults for lutdpc */
++struct prev_lutdpc dm365_lutdpc_defaults = {
++	.en = 0
++};
++
++/* Defaults for otfdpc */
++struct prev_lutdpc dm365_otfdpc_defaults = {
++	.en = 0
++};
++
++/* Defaults for 2D - nf */
++struct prev_nf dm365_nf_defaults = {
++	.en = 0
++};
++
++/* defaults for GIC */
++struct prev_gic dm365_gic_defaults = {
++	.en = 0
++};
++
++/* Defaults for white balance */
++struct prev_wb dm365_wb_defaults = {
++	.gain_r = {2, 0x00},
++	.gain_gr = {2, 0x00},
++	.gain_gb = {2, 0x00},
++	.gain_b = {2, 0x00}
++};
++
++/* Defaults for CFA */
++struct prev_cfa dm365_cfa_defaults = {
++	.alg = IPIPE_CFA_ALG_2DIRAC,
++	.hpf_thr_2dir = 0,
++	.hpf_slp_2dir = 0,
++	.hp_mix_thr_2dir = 0,
++	.hp_mix_slope_2dir = 0,
++	.dir_thr_2dir = 0,
++	.dir_slope_2dir = 0,
++	.nd_wt_2dir = 0,
++	.hue_fract_daa = 0,
++	.edge_thr_daa = 0,
++	.thr_min_daa = 0,
++	.thr_slope_daa = 0,
++	.slope_min_daa = 0,
++	.slope_slope_daa = 0,
++	.lp_wt_daa = 0
++};
++
++/* Defaults for rgb2rgb */
++struct prev_rgb2rgb dm365_rgb2rgb_defaults = {
++	.coef_rr = {1, 0},	/* 256 */
++	.coef_gr = {0, 0},
++	.coef_br = {0, 0},
++	.coef_rg = {0, 0},
++	.coef_gg = {1, 0},	/* 256 */
++	.coef_bg = {0, 0},
++	.coef_rb = {0, 0},
++	.coef_gb = {0, 0},
++	.coef_bb = {1, 0},	/* 256 */
++	.out_ofst_r = 0,
++	.out_ofst_g = 0,
++	.out_ofst_b = 0
++};
++
++/* Defaults for gamma correction */
++struct prev_gamma dm365_gamma_defaults = {
++	.bypass_r = 0,
++	.bypass_b = 0,
++	.bypass_g = 0,
++	.tbl_sel = IPIPE_GAMMA_TBL_ROM
++};
++
++/* Defaults for 3d lut */
++struct prev_3d_lut dm365_3d_lut_defaults = {
++	.en = 0
++};
++
++/* Defaults for lumina adjustments */
++struct prev_lum_adj dm365_lum_adj_defaults = {
++	.brightness = 0,
++	.contrast = 16
++};
++
++/* Defaults for rgb2yuv conversion */
++struct prev_rgb2yuv dm365_rgb2yuv_defaults = {
++	.coef_ry = {0, 0x4D},
++	.coef_gy = {0, 0x96},
++	.coef_by = {0, 0x1D},
++	.coef_rcb = {0xF, 0xD5},
++	.coef_gcb = {0xF, 0xAB},
++	.coef_bcb = {0, 0x80},
++	.coef_rcr = {0, 0x80},
++	.coef_gcr = {0xF, 0x95},
++	.coef_bcr = {0xF, 0xEB},
++	.out_ofst_y = 0,
++	.out_ofst_cb = 0x80,
++	.out_ofst_cr = 0x80
++};
++
++/* Defaults for GBCE */
++struct prev_gbce dm365_gbce_defaults = {
++	.en = 0
++};
++
++/* Defaults for yuv 422 conversion */
++struct prev_yuv422_conv dm365_yuv422_conv_defaults = {
++	.en_chrom_lpf = 0,
++	.chrom_pos = IPIPE_YUV422_CHR_POS_COSITE
++};
++
++/* Defaults for Edge Ehnancements  */
++struct prev_yee dm365_yee_defaults = {
++	.en = 0,
++};
++
++/* Defaults for CAR conversion */
++struct prev_car dm365_car_defaults = {
++	.en = 0,
++};
++
++/* Defaults for CGS */
++struct prev_cgs dm365_cgs_defaults = {
++	.en = 0,
++};
++
++#define  WIDTH_I 640
++#define  HEIGHT_I 480
++#define  WIDTH_O 640
++#define  HEIGHT_O 480
++
++/* default ipipeif settings */
++struct ipipeif_5_1 ipipeif_5_1_defaults = {
++	.pack_mode = IPIPEIF_5_1_PACK_16_BIT,
++	.data_shift = IPIPEIF_BITS11_0,
++	.source1 = SRC1_PARALLEL_PORT,
++	.clk_div = {
++		.m = 1,	/* clock = sdram clock * (m/n) */
++		.n = 6
++	},
++	.dpc = {
++		.en = 0,
++	},
++	.dpcm = {
++		.en = 0,
++		.type = DPCM_8BIT_12BIT,
++		.pred = DPCM_SIMPLE_PRED
++	},
++	.pix_order = IPIPEIF_CBCR_Y,
++	.isif_port = {
++		.if_type = VPFE_RAW_BAYER,
++		.hdpol = VPFE_PINPOL_POSITIVE,
++		.vdpol =VPFE_PINPOL_POSITIVE 
++	},
++	.clip = 4095,
++	.align_sync = 0,
++	.rsz_start = 0,
++	.df_gain_en = 0
++};
++
++struct ipipe_params dm365_ipipe_defs = {
++	.ipipeif_param = {
++		.mode = ONE_SHOT,
++		.source = SDRAM_RAW,
++		.clock_select = SDRAM_CLK,
++		.glob_hor_size = WIDTH_I + 8,
++		.glob_ver_size = HEIGHT_I + 10,
++		.hnum = WIDTH_I,
++		.vnum = HEIGHT_I,
++		.adofs = WIDTH_I * 2,
++		.rsz = 16,	/* resize ratio 16/rsz */
++		.decimation = IPIPEIF_DECIMATION_OFF,
++		.avg_filter = AVG_OFF,
++		.gain = 0x200,	/* U10Q9 */
++	},
++	.ipipe_mode = ONE_SHOT,
++	.ipipe_dpaths_fmt = IPIPE_RAW2YUV,
++	.ipipe_colpat_olop = IPIPE_GREEN_BLUE,
++	.ipipe_colpat_olep = IPIPE_BLUE,
++	.ipipe_colpat_elop = IPIPE_RED,
++	.ipipe_colpat_elep = IPIPE_GREEN_RED,
++	.ipipe_vps = 0,
++	.ipipe_vsz = HEIGHT_I - 1,
++	.ipipe_hps = 0,
++	.ipipe_hsz = WIDTH_I - 1,
++	.rsz_common = {
++		.vps = 0,
++		.vsz = HEIGHT_I - 1,
++		.hps = 0,
++		.hsz = WIDTH_I - 1,
++		.src_img_fmt = RSZ_IMG_422,
++		.y_c = 0,
++		.raw_flip = 1,	/* flip preserve Raw format */
++		.source = IPIPE_DATA,
++		.passthrough = IPIPE_BYPASS_OFF,
++		.yuv_y_min = 0,
++		.yuv_y_max = 255,
++		.yuv_c_min = 0,
++		.yuv_c_max = 255,
++		.rsz_seq_crv = DISABLE,
++		.out_chr_pos = IPIPE_YUV422_CHR_POS_COSITE
++	},
++	.rsz_rsc_param = {
++		{
++			.mode = ONE_SHOT,
++			.h_flip = DISABLE,
++			.v_flip = DISABLE,
++			.cen = DISABLE,
++			.yen = DISABLE,
++			.i_vps = 0,
++			.i_hps = 0,
++			.o_vsz = HEIGHT_O - 1,
++			.o_hsz = WIDTH_O - 1,
++			.v_phs_y = 0,
++			.v_phs_c = 0,
++			.v_dif = 256,
++			.v_typ_y = RSZ_INTP_CUBIC,
++			.h_typ_c = RSZ_INTP_CUBIC,
++			.v_lpf_int_y = 0,
++			.v_lpf_int_c = 0,
++			.h_phs = 0,
++			.h_dif = 256,
++			.h_typ_y = RSZ_INTP_CUBIC,
++			.h_typ_c = RSZ_INTP_CUBIC,
++			.h_lpf_int_y = 0,
++			.h_lpf_int_c = 0,
++			.dscale_en = 0,
++			.h_dscale_ave_sz = IPIPE_DWN_SCALE_1_OVER_2,
++			.v_dscale_ave_sz = IPIPE_DWN_SCALE_1_OVER_2,
++			.f_div.en = 0
++		},
++		{
++			.mode = ONE_SHOT,
++			.h_flip = DISABLE,
++			.v_flip = DISABLE,
++			.cen = DISABLE,
++			.yen = DISABLE,
++			.i_vps = 0,
++			.i_hps = 0,
++			.o_vsz = HEIGHT_O - 1,
++			.o_hsz = WIDTH_O - 1,
++			.v_phs_y = 0,
++			.v_phs_c = 0,
++			.v_dif = 256,
++			.v_typ_y = RSZ_INTP_CUBIC,
++			.h_typ_c = RSZ_INTP_CUBIC,
++			.v_lpf_int_y = 0,
++			.v_lpf_int_c = 0,
++			.h_phs = 0,
++			.h_dif = 256,
++			.h_typ_y = RSZ_INTP_CUBIC,
++			.h_typ_c = RSZ_INTP_CUBIC,
++			.h_lpf_int_y = 0,
++			.h_lpf_int_c = 0,
++			.dscale_en = 0,
++			.h_dscale_ave_sz = IPIPE_DWN_SCALE_1_OVER_2,
++			.v_dscale_ave_sz = IPIPE_DWN_SCALE_1_OVER_2,
++			.f_div.en = 0
++		},
++	},
++	.rsz2rgb = {
++		{
++			.rgb_en = DISABLE
++		},
++		{
++			.rgb_en = DISABLE
++		}
++	},
++	.ext_mem_param = {
++		{
++			.rsz_sdr_oft_y = WIDTH_O << 1,
++			.rsz_sdr_ptr_s_y = 0,
++			.rsz_sdr_ptr_e_y = HEIGHT_O,
++			.rsz_sdr_oft_c = WIDTH_O,
++			.rsz_sdr_ptr_s_c = 0,
++			.rsz_sdr_ptr_e_c = HEIGHT_O >> 1,
++			.flip_ofst_y = 0,
++			.flip_ofst_c = 0,
++			.c_offset = 0,
++			.user_y_ofst = 0,
++			.user_c_ofst = 0
++		},
++		{
++			.rsz_sdr_oft_y = WIDTH_O << 1,
++			.rsz_sdr_ptr_s_y = 0,
++			.rsz_sdr_ptr_e_y = HEIGHT_O,
++			.rsz_sdr_oft_c = WIDTH_O,
++			.rsz_sdr_ptr_s_c = 0,
++			.rsz_sdr_ptr_e_c = HEIGHT_O,
++			.flip_ofst_y = 0,
++			.flip_ofst_c = 0,
++			.c_offset = 0,
++			.user_y_ofst = 0,
++			.user_c_ofst = 0
++		},
++	},
++	.rsz_en[0] = ENABLE,
++	.rsz_en[1] = DISABLE
++};
++
++struct prev_single_shot_config dm365_prev_ss_config_defs = {
++	.bypass = IPIPE_BYPASS_OFF,
++	.input = {
++		.image_width = WIDTH_I,
++		.image_height = HEIGHT_I,
++		.vst = 0,
++		.hst = 0,
++		.ppln = WIDTH_I + 8,
++		.lpfr = HEIGHT_I + 10,
++		.pred = DPCM_SIMPLE_PRED,
++		.clk_div = {1, 6},
++		.data_shift = IPIPEIF_BITS11_0,
++		.dec_en = 0,
++		.rsz = 16,	/* resize ratio 16/rsz */
++		.frame_div_mode_en = 0,
++		.avg_filter_en = AVG_OFF,
++		.dpc = {0, 0},
++		.gain = 512,
++		.clip = 4095,
++		.align_sync = 0,
++		.rsz_start = 0,
++		.pix_fmt = IPIPE_BAYER,
++		.colp_olop = IPIPE_GREEN_BLUE,
++		.colp_olep = IPIPE_BLUE,
++		.colp_elop = IPIPE_RED,
++		.colp_elep = IPIPE_GREEN_RED
++	},
++	.output = {
++		.pix_fmt = IPIPE_UYVY
++	}
++};
++
++struct prev_continuous_config dm365_prev_cont_config_defs = {
++	.bypass = IPIPE_BYPASS_OFF,
++	.input = {
++		.en_df_sub = 0,
++		.dec_en = 0,
++		.rsz = 16,
++		.avg_filter_en = AVG_OFF,
++		.gain = 512,
++		.clip = 4095,
++		.colp_olop = IPIPE_GREEN_BLUE,
++		.colp_olep = IPIPE_BLUE,
++		.colp_elop = IPIPE_RED,
++		.colp_elep = IPIPE_GREEN_RED
++	},
++};
++
++struct rsz_single_shot_config dm365_rsz_ss_config_defs = {
++	.input = {
++		.image_width = WIDTH_I,
++		.image_height = HEIGHT_I,
++		.vst = 0,
++		.hst = 0,
++		.ppln = WIDTH_I + 8,
++		.lpfr = HEIGHT_I + 10,
++		.clk_div = {1, 6},
++		.dec_en = 0,
++		.rsz = 16,	/* resize ratio 16/rsz */
++		.frame_div_mode_en = 0,
++		.avg_filter_en = AVG_OFF,
++		.align_sync = 0,
++		.rsz_start = 0,
++		.pix_fmt = IPIPE_UYVY
++	},
++	.output1 = {
++		.enable = 1,
++		.pix_fmt = IPIPE_UYVY,
++		.h_flip = 0,
++		.v_flip = 0,
++		.width = WIDTH_O,
++		.height = HEIGHT_O,
++		.vst_y = 0,
++		.vst_c = 0,
++		.v_typ_y = RSZ_INTP_CUBIC,
++		.v_typ_c = RSZ_INTP_CUBIC,
++		.v_lpf_int_y = 0,
++		.v_lpf_int_c = 0,
++		.h_typ_y = RSZ_INTP_CUBIC,
++		.h_typ_c = RSZ_INTP_CUBIC,
++		.h_lpf_int_y = 0,
++		.h_lpf_int_c = 0,
++		.en_down_scale = 0,
++		.h_dscale_ave_sz = IPIPE_DWN_SCALE_1_OVER_2,
++		.v_dscale_ave_sz = IPIPE_DWN_SCALE_1_OVER_2,
++		.user_y_ofst = 0,
++		.user_c_ofst = 0
++	},
++	.output2 = {
++		.enable = 1,
++		.pix_fmt = IPIPE_UYVY,
++		.h_flip = 0,
++		.v_flip = 0,
++		.width = WIDTH_O,
++		.height = HEIGHT_O,
++		.vst_y = 0,
++		.vst_c = 0,
++		.v_typ_y = RSZ_INTP_CUBIC,
++		.v_typ_c = RSZ_INTP_CUBIC,
++		.v_lpf_int_y = 0,
++		.v_lpf_int_c = 0,
++		.h_typ_y = RSZ_INTP_CUBIC,
++		.h_typ_c = RSZ_INTP_CUBIC,
++		.h_lpf_int_y = 0,
++		.h_lpf_int_c = 0,
++		.en_down_scale = 0,
++		.h_dscale_ave_sz = IPIPE_DWN_SCALE_1_OVER_2,
++		.v_dscale_ave_sz = IPIPE_DWN_SCALE_1_OVER_2,
++		.user_y_ofst = 0,
++		.user_c_ofst = 0
++	},
++	.chroma_sample_even = 0,
++	.yuv_y_min = 0,
++	.yuv_y_max = 255,
++	.yuv_c_min = 0,
++	.yuv_c_max = 255,
++	.out_chr_pos = IPIPE_YUV422_CHR_POS_COSITE,
++};
++
++struct rsz_continuous_config dm365_rsz_cont_config_defs = {
++	.output1 = {
++		.enable = 1,
++		.h_flip = 0,
++		.v_flip = 0,
++		.v_typ_y = RSZ_INTP_CUBIC,
++		.v_typ_c = RSZ_INTP_CUBIC,
++		.v_lpf_int_y = 0,
++		.v_lpf_int_c = 0,
++		.h_typ_y = RSZ_INTP_CUBIC,
++		.h_typ_c = RSZ_INTP_CUBIC,
++		.h_lpf_int_y = 0,
++		.h_lpf_int_c = 0,
++		.en_down_scale = 0,
++		.h_dscale_ave_sz = IPIPE_DWN_SCALE_1_OVER_2,
++		.v_dscale_ave_sz = IPIPE_DWN_SCALE_1_OVER_2,
++		.user_y_ofst = 0,
++		.user_c_ofst = 0
++	},
++	.output2 = {
++		.enable = 1,
++		.pix_fmt = IPIPE_UYVY,
++		.h_flip = 0,
++		.v_flip = 0,
++		.width = WIDTH_O,
++		.height = HEIGHT_O,
++		.vst_y = 0,
++		.vst_c = 0,
++		.v_typ_y = RSZ_INTP_CUBIC,
++		.v_typ_c = RSZ_INTP_CUBIC,
++		.v_lpf_int_y = 0,
++		.v_lpf_int_c = 0,
++		.h_typ_y = RSZ_INTP_CUBIC,
++		.h_typ_c = RSZ_INTP_CUBIC,
++		.h_lpf_int_y = 0,
++		.h_lpf_int_c = 0,
++		.en_down_scale = 0,
++		.h_dscale_ave_sz = IPIPE_DWN_SCALE_1_OVER_2,
++		.v_dscale_ave_sz = IPIPE_DWN_SCALE_1_OVER_2,
++		.user_y_ofst = 0,
++		.user_c_ofst = 0
++	},
++	.chroma_sample_even = 0,
++	.yuv_y_min = 0,
++	.yuv_y_max = 255,
++	.yuv_c_min = 0,
++	.yuv_c_max = 255,
++	.out_chr_pos = IPIPE_YUV422_CHR_POS_COSITE,
++};
+--- /dev/null
++++ b/drivers/media/video/davinci/davinci_osd.c
+@@ -0,0 +1,2434 @@
++/*
++ * TI DaVinci On-Screen Display Manager
++ *
++ * Andy Lowe (alowe@mvista.com), MontaVista Software
++ *
++ * 2007 (c) MontaVista Software, Inc. This file is licensed under
++ * the terms of the GNU General Public License version 2. This program
++ * is licensed "as is" without any warranty of any kind, whether express
++ * or implied.
++ */
++
++#include <linux/module.h>
++#include <linux/kernel.h>
++#include <linux/interrupt.h>
++#include <linux/platform_device.h>
++#include <linux/clk.h>
++#include <video/davinci_vpbe.h>
++#include <video/davinci_osd.h>
++#include <mach/io.h>
++#include <mach/cputype.h>
++#include <mach/hardware.h>
++#include <media/davinci/vpss.h>
++
++#include <asm/io.h>
++
++#define MODULE_NAME 		"davinci_osd"
++
++#define DM355_VPSSBL_REG_BASE	0x01C70800
++
++/* parameters that apply on a per-window (OSD or video) basis */
++struct davinci_window_state {
++	int is_allocated;
++	int is_enabled;
++	unsigned long fb_base_phys;
++	enum davinci_zoom_factor h_zoom;
++	enum davinci_zoom_factor v_zoom;
++	struct davinci_layer_config lconfig;
++};
++
++/* parameters that apply on a per-OSD-window basis */
++struct davinci_osdwin_state {
++	enum davinci_clut clut;
++	enum davinci_blending_factor blend;
++	int colorkey_blending;
++	unsigned colorkey;
++	int rec601_attenuation;
++	unsigned char palette_map[16];	/* index is pixel value */
++};
++
++/* hardware rectangular cursor parameters */
++struct davinci_cursor_state {
++	int is_enabled;
++	struct davinci_cursor_config config;
++};
++
++struct davinci_osd_state {
++	spinlock_t lock;
++	struct device *dev;
++	dma_addr_t osd_base_phys;
++	unsigned long osd_base;
++	unsigned long osd_size;
++
++	int irq;
++	struct davinci_disp_callback *callback;
++	int pingpong;		/* 1-->the isr will toggle the VID0 ping-pong buffer */
++	int interpolation_filter;
++	int field_inversion;
++	enum davinci_h_exp_ratio osd_h_exp;
++	enum davinci_v_exp_ratio osd_v_exp;
++	enum davinci_h_exp_ratio vid_h_exp;
++	enum davinci_v_exp_ratio vid_v_exp;
++	enum davinci_clut backg_clut;
++	unsigned backg_clut_index;
++	enum davinci_rom_clut rom_clut;
++	int is_blinking;	/* attribute window blinking enabled */
++	enum davinci_blink_interval blink;
++	enum davinci_pix_format yc_pixfmt;	/* YCbCrI or YCrCbI */
++	unsigned char clut_ram[256][3];	/* columns are Y, Cb, Cr */
++	struct davinci_cursor_state cursor;
++	struct davinci_window_state win[4];	/* OSD0, VID0, OSD1, VID1 */
++	struct davinci_osdwin_state osdwin[2];	/* OSD0, OSD1 */
++};
++
++static struct davinci_osd_state osd_state;
++static struct davinci_osd_state *osd = &osd_state;
++
++/* register access routines */
++static __inline__ u32 osd_read(u32 offset)
++{
++	return __raw_readl(osd->osd_base + offset);
++}
++
++static __inline__ u32 osd_write(u32 val, u32 offset)
++{
++	__raw_writel(val, osd->osd_base + offset);
++	return val;
++}
++
++static __inline__ u32 osd_set(u32 mask, u32 offset)
++{
++	u32 addr = osd->osd_base + offset;
++	u32 val = __raw_readl(addr) | mask;
++
++	__raw_writel(val, addr);
++	return val;
++}
++
++static __inline__ u32 osd_clear(u32 mask, u32 offset)
++{
++	u32 addr = osd->osd_base + offset;
++	u32 val = __raw_readl(addr) & ~mask;
++
++	__raw_writel(val, addr);
++	return val;
++}
++
++static __inline__ u32 osd_merge(u32 mask, u32 val, u32 offset)
++{
++	u32 addr = osd->osd_base + offset;
++	u32 new_val = (__raw_readl(addr) & ~mask) | (val & mask);
++
++	__raw_writel(new_val, addr);
++	return new_val;
++}
++
++void osd_write_left_margin(u32 val)
++{
++	__raw_writel(val, osd->osd_base + OSD_BASEPX);
++}
++EXPORT_SYMBOL(osd_write_left_margin);
++
++void osd_write_upper_margin(u32 val)
++{
++	__raw_writel(val, osd->osd_base + OSD_BASEPY);
++}
++EXPORT_SYMBOL(osd_write_upper_margin);
++
++u32 osd_read_left_margin(void)
++{
++	return __raw_readl(osd->osd_base + OSD_BASEPX);
++}
++EXPORT_SYMBOL(osd_read_left_margin);
++
++u32 osd_read_upper_margin(void)
++{
++	return __raw_readl(osd->osd_base + OSD_BASEPY);
++}
++EXPORT_SYMBOL(osd_read_upper_margin);
++	
++
++/* define some macros for layer and pixfmt classification */
++#define is_osd_win(layer) (((layer) == WIN_OSD0) || ((layer) == WIN_OSD1))
++#define is_vid_win(layer) (((layer) == WIN_VID0) || ((layer) == WIN_VID1))
++#define is_rgb_pixfmt(pixfmt) \
++	(((pixfmt) == PIXFMT_RGB565) || ((pixfmt) == PIXFMT_RGB888))
++#define is_yc_pixfmt(pixfmt) \
++	(((pixfmt) == PIXFMT_YCbCrI) || ((pixfmt) == PIXFMT_YCrCbI) || \
++	((pixfmt) == PIXFMT_NV12))
++#define MAX_WIN_SIZE OSD_VIDWIN0XP_V0X
++#define MAX_LINE_LENGTH (OSD_VIDWIN0OFST_V0LO << 5)
++
++/* interrupt service routine */
++static irqreturn_t davinci_disp_isr(int irq, void *arg)
++{
++	unsigned event = 0;
++	struct davinci_disp_callback *callback = osd->callback;
++	static unsigned last_event;
++#if 0
++	if (cpu_is_davinci_dm355()) {
++		if (!
++		    (__raw_readl(IO_ADDRESS(DM355_VPSSBL_REG_BASE + VPSSBL_INTSTAT)) &
++		     VPSSBL_INTSTAT_VENCINT)) {
++			return IRQ_NONE;
++		}
++		__raw_writel(VPSSBL_INTSTAT_VENCINT,
++			       IO_ADDRESS(DM355_VPSSBL_REG_BASE + VPSSBL_INTSTAT));
++	}
++#endif
++#if 0
++	if (cpu_is_davinci_dm365()) {
++		if (!
++		    (__raw_readl(IO_ADDRESS(DM365_ISP5_REG_BASE + ISP5_INTSTAT)) &
++		     ISP5_INTSTAT_VENCINT)) {
++			return IRQ_NONE;
++		}
++		__raw_writel(ISP5_INTSTAT_VENCINT,
++			       IO_ADDRESS(DM365_ISP5_REG_BASE + ISP5_INTSTAT));
++	}
++#endif
++	if (davinci_disp_is_second_field())
++		event |= DAVINCI_DISP_SECOND_FIELD;
++	else
++		event |= DAVINCI_DISP_FIRST_FIELD;
++
++	if (event == (last_event & ~DAVINCI_DISP_END_OF_FRAME)) {
++		/*
++		 * If the display is non-interlaced, then we need to flag the
++		 * end-of-frame event at every interrupt regardless of the
++		 * value of the FIDST bit.  We can conclude that the display is
++		 * non-interlaced if the value of the FIDST bit is unchanged
++		 * from the previous interrupt.
++		 */
++		event |= DAVINCI_DISP_END_OF_FRAME;
++	} else if (event == DAVINCI_DISP_SECOND_FIELD) {
++		/* end-of-frame for interlaced display */
++		event |= DAVINCI_DISP_END_OF_FRAME;
++	}
++	last_event = event;
++
++	if (osd->pingpong) {
++		/*
++		 * Toggle the ping-pong buffers for VID0.  This is part of the
++		 * workaround for field signal inversion Advisory 1.3.8 for
++		 * the DM6446.
++		 */
++		if (event & DAVINCI_DISP_SECOND_FIELD)
++			osd_set(OSD_MISCCTL_PPSW, OSD_MISCCTL);
++		else
++			osd_clear(OSD_MISCCTL_PPSW, OSD_MISCCTL);
++	}
++
++	while (callback) {
++		if (callback->mask & event)
++			callback->handler(event, callback->arg);
++		callback = callback->next;
++	}
++
++	return IRQ_HANDLED;
++}
++
++int davinci_disp_unregister_callback(struct davinci_disp_callback *callback)
++{
++	unsigned long flags;
++	struct davinci_disp_callback *prev;
++	int err = 0;
++
++	spin_lock_irqsave(&osd->lock, flags);
++
++	prev = osd->callback;
++	if (!prev)
++		err = -1;
++	else if (prev == callback)
++		osd->callback = callback->next;
++	else {
++		while (prev->next && (prev->next != callback))
++			prev = prev->next;
++		if (!prev->next)
++			err = -1;
++		else
++			prev->next = callback->next;
++	}
++
++	spin_unlock_irqrestore(&osd->lock, flags);
++
++	return err;
++}
++EXPORT_SYMBOL(davinci_disp_unregister_callback);
++
++int davinci_disp_register_callback(struct davinci_disp_callback *callback)
++{
++	unsigned long flags;
++	struct davinci_disp_callback *next;
++
++	spin_lock_irqsave(&osd->lock, flags);
++
++	next = osd->callback;
++	osd->callback = callback;
++	callback->next = next;
++
++	spin_unlock_irqrestore(&osd->lock, flags);
++
++	return 0;
++}
++EXPORT_SYMBOL(davinci_disp_register_callback);
++
++/*
++ * This routine implements a workaround for the field signal inversion silicon
++ * erratum described in Advisory 1.3.8 for the DM6446.  The fb_base_phys and
++ * lconfig parameters apply to the vid0 window.  This routine should be called
++ * whenever the vid0 layer configuration or start address is modified, or when
++ * the OSD field inversion setting is modified.
++ * Returns: 1 if the ping-pong buffers need to be toggled in the vsync isr, or
++ *          0 otherwise
++ */
++static int _davinci_disp_dm6446_vid0_pingpong(int field_inversion,
++					      unsigned long fb_base_phys,
++					      const struct davinci_layer_config
++					      *lconfig)
++{
++/* TODO */
++#if 0
++	if (!cpu_is_davinci_dm644x_pg1x())
++		return 0;
++
++
++	if (!field_inversion || !lconfig->interlaced) {
++		osd_write(fb_base_phys & ~0x1F, OSD_VIDWIN0ADR);
++		osd_write(fb_base_phys & ~0x1F, OSD_PPVWIN0ADR);
++		osd_merge(OSD_MISCCTL_PPSW | OSD_MISCCTL_PPRV, 0, OSD_MISCCTL);
++
++		return 0;
++	} else {
++		unsigned miscctl = OSD_MISCCTL_PPRV;
++
++		osd_write((fb_base_phys & ~0x1F) - lconfig->line_length,
++			  OSD_VIDWIN0ADR);
++		osd_write((fb_base_phys & ~0x1F) + lconfig->line_length,
++			  OSD_PPVWIN0ADR);
++
++		if (davinci_disp_is_second_field())
++			miscctl |= OSD_MISCCTL_PPSW;
++
++		osd_merge(OSD_MISCCTL_PPSW | OSD_MISCCTL_PPRV, miscctl,
++			  OSD_MISCCTL);
++
++		return 1;
++	}
++#endif
++	return 0;
++}
++
++int davinci_disp_get_field_inversion(void)
++{
++	return osd->field_inversion;
++}
++EXPORT_SYMBOL(davinci_disp_get_field_inversion);
++
++static void _davinci_disp_set_field_inversion(int enable)
++{
++	unsigned fsinv = 0;
++
++	if (enable)
++		fsinv = OSD_MODE_FSINV;
++
++	osd_merge(OSD_MODE_FSINV, fsinv, OSD_MODE);
++}
++
++void davinci_disp_set_field_inversion(int enable)
++{
++	unsigned long flags;
++
++	spin_lock_irqsave(&osd->lock, flags);
++
++	osd->field_inversion = (enable != 0);
++	_davinci_disp_set_field_inversion(enable);
++
++	osd->pingpong =
++	    _davinci_disp_dm6446_vid0_pingpong(osd->field_inversion,
++					       osd->win[WIN_VID0].fb_base_phys,
++					       &osd->win[WIN_VID0].lconfig);
++
++	spin_unlock_irqrestore(&osd->lock, flags);
++}
++EXPORT_SYMBOL(davinci_disp_set_field_inversion);
++
++void davinci_disp_get_background(enum davinci_clut *clut,
++				 unsigned char *clut_index)
++{
++	unsigned long flags;
++
++	spin_lock_irqsave(&osd->lock, flags);
++
++	*clut = osd->backg_clut;
++	*clut_index = osd->backg_clut_index;
++
++	spin_unlock_irqrestore(&osd->lock, flags);
++}
++EXPORT_SYMBOL(davinci_disp_get_background);
++
++static void _davinci_disp_set_background(enum davinci_clut clut,
++					 unsigned char clut_index)
++{
++	u32 mode = 0;
++
++	if (clut == RAM_CLUT)
++		mode |= OSD_MODE_BCLUT;
++	mode |= clut_index;
++	osd_merge(OSD_MODE_BCLUT | OSD_MODE_CABG, mode, OSD_MODE);
++}
++
++void davinci_disp_set_background(enum davinci_clut clut,
++				 unsigned char clut_index)
++{
++	unsigned long flags;
++
++	spin_lock_irqsave(&osd->lock, flags);
++
++	osd->backg_clut = clut;
++	osd->backg_clut_index = clut_index;
++	_davinci_disp_set_background(clut, clut_index);
++
++	spin_unlock_irqrestore(&osd->lock, flags);
++}
++EXPORT_SYMBOL(davinci_disp_set_background);
++
++int davinci_disp_get_interpolation_filter(void)
++{
++	return osd->interpolation_filter;
++}
++EXPORT_SYMBOL(davinci_disp_get_interpolation_filter);
++
++static void _davinci_disp_set_interpolation_filter(int filter)
++{
++	if (cpu_is_davinci_dm355() || cpu_is_davinci_dm365())
++		osd_clear(OSD_EXTMODE_EXPMDSEL, OSD_EXTMODE);
++	osd_merge(OSD_MODE_EF, filter ? OSD_MODE_EF : 0, OSD_MODE);
++}
++
++void davinci_disp_set_interpolation_filter(int filter)
++{
++	unsigned long flags;
++
++	spin_lock_irqsave(&osd->lock, flags);
++
++	osd->interpolation_filter = (filter != 0);
++	_davinci_disp_set_interpolation_filter(filter);
++
++	spin_unlock_irqrestore(&osd->lock, flags);
++}
++EXPORT_SYMBOL(davinci_disp_set_interpolation_filter);
++
++void davinci_disp_get_cursor_config(struct davinci_cursor_config *cursor)
++{
++	unsigned long flags;
++
++	spin_lock_irqsave(&osd->lock, flags);
++
++	*cursor = osd->cursor.config;
++
++	spin_unlock_irqrestore(&osd->lock, flags);
++}
++EXPORT_SYMBOL(davinci_disp_get_cursor_config);
++
++static void _davinci_disp_set_cursor_config(const struct davinci_cursor_config
++					    *cursor)
++{
++	unsigned rectcur = 0;
++
++	osd_write(cursor->xsize, OSD_CURXL);
++	osd_write(cursor->xpos, OSD_CURXP);
++
++	if (cursor->interlaced) {
++		osd_write(cursor->ypos >> 1, OSD_CURYP);
++		if (cpu_is_davinci_dm644x()) {
++			/* Must add 1 to ysize due to device erratum. */
++			osd_write((cursor->ysize >> 1) + 1, OSD_CURYL);
++		} else
++			osd_write(cursor->ysize >> 1, OSD_CURYL);
++	} else {
++		osd_write(cursor->ypos, OSD_CURYP);
++		if (cpu_is_davinci_dm644x()) {
++			/* Must add 1 to ysize due to device erratum. */
++			osd_write(cursor->ysize + 1, OSD_CURYL);
++		} else
++			osd_write(cursor->ysize, OSD_CURYL);
++	}
++
++	if (cursor->clut == RAM_CLUT)
++		rectcur |= OSD_RECTCUR_CLUTSR;
++	rectcur |= (cursor->clut_index << OSD_RECTCUR_RCAD_SHIFT);
++	rectcur |= (cursor->h_width << OSD_RECTCUR_RCHW_SHIFT);
++	rectcur |= (cursor->v_width << OSD_RECTCUR_RCVW_SHIFT);
++	osd_merge(OSD_RECTCUR_RCAD | OSD_RECTCUR_CLUTSR | OSD_RECTCUR_RCHW |
++		  OSD_RECTCUR_RCVW, rectcur, OSD_RECTCUR);
++}
++
++void davinci_disp_set_cursor_config(struct davinci_cursor_config *cursor)
++{
++	unsigned long flags;
++
++	spin_lock_irqsave(&osd->lock, flags);
++
++	cursor->xsize = min(cursor->xsize, (unsigned)OSD_CURXL_RCSW);
++	cursor->ysize = min(cursor->ysize, (unsigned)OSD_CURYL_RCSH);
++	cursor->xpos = min(cursor->xpos, (unsigned)OSD_CURXP_RCSX);
++	cursor->ypos = min(cursor->ypos, (unsigned)OSD_CURYP_RCSY);
++	cursor->interlaced = (cursor->interlaced != 0);
++	if (cursor->interlaced) {
++		cursor->ysize &= ~1;
++		cursor->ypos &= ~1;
++	}
++	cursor->h_width &= (OSD_RECTCUR_RCHW >> OSD_RECTCUR_RCHW_SHIFT);
++	cursor->v_width &= (OSD_RECTCUR_RCVW >> OSD_RECTCUR_RCVW_SHIFT);
++	cursor->clut = (cursor->clut == RAM_CLUT) ? RAM_CLUT : ROM_CLUT;
++
++	osd->cursor.config = *cursor;
++	_davinci_disp_set_cursor_config(cursor);
++
++	spin_unlock_irqrestore(&osd->lock, flags);
++}
++EXPORT_SYMBOL(davinci_disp_set_cursor_config);
++
++int davinci_disp_cursor_is_enabled(void)
++{
++	return osd->cursor.is_enabled;
++}
++EXPORT_SYMBOL(davinci_disp_cursor_is_enabled);
++
++static void _davinci_disp_cursor_disable(void)
++{
++	osd_clear(OSD_RECTCUR_RCACT, OSD_RECTCUR);
++}
++
++void davinci_disp_cursor_disable(void)
++{
++	unsigned long flags;
++
++	spin_lock_irqsave(&osd->lock, flags);
++
++	osd->cursor.is_enabled = 0;
++	_davinci_disp_cursor_disable();
++
++	spin_unlock_irqrestore(&osd->lock, flags);
++}
++EXPORT_SYMBOL(davinci_disp_cursor_disable);
++
++static void _davinci_disp_cursor_enable(void)
++{
++	osd_set(OSD_RECTCUR_RCACT, OSD_RECTCUR);
++}
++
++void davinci_disp_cursor_enable(void)
++{
++	unsigned long flags;
++
++	spin_lock_irqsave(&osd->lock, flags);
++
++	osd->cursor.is_enabled = 1;
++	_davinci_disp_cursor_enable();
++
++	spin_unlock_irqrestore(&osd->lock, flags);
++}
++EXPORT_SYMBOL(davinci_disp_cursor_enable);
++
++void davinci_disp_get_vid_expansion(enum davinci_h_exp_ratio *h_exp,
++				    enum davinci_v_exp_ratio *v_exp)
++{
++	unsigned long flags;
++
++	spin_lock_irqsave(&osd->lock, flags);
++
++	*h_exp = osd->vid_h_exp;
++	*v_exp = osd->vid_v_exp;
++
++	spin_unlock_irqrestore(&osd->lock, flags);
++}
++EXPORT_SYMBOL(davinci_disp_get_vid_expansion);
++
++static void _davinci_disp_set_vid_expansion(enum davinci_h_exp_ratio h_exp,
++					    enum davinci_v_exp_ratio v_exp)
++{
++	u32 mode = 0, extmode = 0;
++
++	switch (h_exp) {
++	case H_EXP_OFF:
++		break;
++	case H_EXP_9_OVER_8:
++		mode |= OSD_MODE_VHRSZ;
++		break;
++	case H_EXP_3_OVER_2:
++		extmode |= OSD_EXTMODE_VIDHRSZ15;
++		break;
++	}
++
++	switch (v_exp) {
++	case V_EXP_OFF:
++		break;
++	case V_EXP_6_OVER_5:
++		mode |= OSD_MODE_VVRSZ;
++		break;
++	}
++
++	if (cpu_is_davinci_dm355() || cpu_is_davinci_dm365())
++		osd_merge(OSD_EXTMODE_VIDHRSZ15, extmode, OSD_EXTMODE);
++	osd_merge(OSD_MODE_VHRSZ | OSD_MODE_VVRSZ, mode, OSD_MODE);
++}
++
++int davinci_disp_set_vid_expansion(enum davinci_h_exp_ratio h_exp,
++				   enum davinci_v_exp_ratio v_exp)
++{
++	unsigned long flags;
++
++	if (h_exp == H_EXP_3_OVER_2 && cpu_is_davinci_dm644x())
++		return -1;
++
++	spin_lock_irqsave(&osd->lock, flags);
++
++	osd->vid_h_exp = h_exp;
++	osd->vid_v_exp = v_exp;
++	_davinci_disp_set_vid_expansion(h_exp, v_exp);
++
++	spin_unlock_irqrestore(&osd->lock, flags);
++	return 0;
++}
++EXPORT_SYMBOL(davinci_disp_set_vid_expansion);
++
++void davinci_disp_get_osd_expansion(enum davinci_h_exp_ratio *h_exp,
++				    enum davinci_v_exp_ratio *v_exp)
++{
++	unsigned long flags;
++
++	spin_lock_irqsave(&osd->lock, flags);
++
++	*h_exp = osd->osd_h_exp;
++	*v_exp = osd->osd_v_exp;
++
++	spin_unlock_irqrestore(&osd->lock, flags);
++}
++EXPORT_SYMBOL(davinci_disp_get_osd_expansion);
++
++static void _davinci_disp_set_osd_expansion(enum davinci_h_exp_ratio h_exp,
++					    enum davinci_v_exp_ratio v_exp)
++{
++	u32 mode = 0, extmode = 0;
++
++	switch (h_exp) {
++	case H_EXP_OFF:
++		break;
++	case H_EXP_9_OVER_8:
++		mode |= OSD_MODE_OHRSZ;
++		break;
++	case H_EXP_3_OVER_2:
++		extmode |= OSD_EXTMODE_OSDHRSZ15;
++		break;
++	}
++
++	switch (v_exp) {
++	case V_EXP_OFF:
++		break;
++	case V_EXP_6_OVER_5:
++		mode |= OSD_MODE_OVRSZ;
++		break;
++	}
++
++	if (cpu_is_davinci_dm355() || cpu_is_davinci_dm365())
++		osd_merge(OSD_EXTMODE_OSDHRSZ15, extmode, OSD_EXTMODE);
++	osd_merge(OSD_MODE_OHRSZ | OSD_MODE_OVRSZ, mode, OSD_MODE);
++}
++
++int davinci_disp_set_osd_expansion(enum davinci_h_exp_ratio h_exp,
++				   enum davinci_v_exp_ratio v_exp)
++{
++	unsigned long flags;
++
++	if (h_exp == H_EXP_3_OVER_2 && cpu_is_davinci_dm644x())
++		return -1;
++
++	spin_lock_irqsave(&osd->lock, flags);
++
++	osd->osd_h_exp = h_exp;
++	osd->osd_v_exp = v_exp;
++	_davinci_disp_set_osd_expansion(h_exp, v_exp);
++
++	spin_unlock_irqrestore(&osd->lock, flags);
++	return 0;
++}
++EXPORT_SYMBOL(davinci_disp_set_osd_expansion);
++
++void davinci_disp_get_blink_attribute(int *enable,
++				      enum davinci_blink_interval *blink)
++{
++	unsigned long flags;
++
++	spin_lock_irqsave(&osd->lock, flags);
++
++	*enable = osd->is_blinking;
++	*blink = osd->blink;
++
++	spin_unlock_irqrestore(&osd->lock, flags);
++}
++EXPORT_SYMBOL(davinci_disp_get_blink_attribute);
++
++static void _davinci_disp_set_blink_attribute(int enable,
++					      enum davinci_blink_interval blink)
++{
++	u32 osdatrmd = 0;
++
++	if (enable) {
++		osdatrmd |= OSD_OSDATRMD_BLNK;
++		osdatrmd |= blink << OSD_OSDATRMD_BLNKINT_SHIFT;
++	}
++	/* caller must ensure that OSD1 is configured in attribute mode */
++	osd_merge(OSD_OSDATRMD_BLNKINT | OSD_OSDATRMD_BLNK, osdatrmd,
++		  OSD_OSDATRMD);
++}
++
++void davinci_disp_set_blink_attribute(int enable,
++				      enum davinci_blink_interval blink)
++{
++	unsigned long flags;
++
++	spin_lock_irqsave(&osd->lock, flags);
++
++	osd->is_blinking = (enable != 0);
++	osd->blink = blink;
++	if (osd->win[WIN_OSD1].lconfig.pixfmt == PIXFMT_OSD_ATTR)
++		_davinci_disp_set_blink_attribute(enable, blink);
++
++	spin_unlock_irqrestore(&osd->lock, flags);
++}
++EXPORT_SYMBOL(davinci_disp_set_blink_attribute);
++
++enum davinci_rom_clut davinci_disp_get_rom_clut(void)
++{
++	return osd->rom_clut;
++}
++EXPORT_SYMBOL(davinci_disp_get_rom_clut);
++
++static void _davinci_disp_set_rom_clut(enum davinci_rom_clut rom_clut)
++{
++	if (rom_clut == ROM_CLUT0)
++		osd_clear(OSD_MISCCTL_RSEL, OSD_MISCCTL);
++	else
++		osd_set(OSD_MISCCTL_RSEL, OSD_MISCCTL);
++}
++
++void davinci_disp_set_rom_clut(enum davinci_rom_clut rom_clut)
++{
++	unsigned long flags;
++
++	spin_lock_irqsave(&osd->lock, flags);
++
++	osd->rom_clut = rom_clut;
++	_davinci_disp_set_rom_clut(rom_clut);
++
++	spin_unlock_irqrestore(&osd->lock, flags);
++}
++EXPORT_SYMBOL(davinci_disp_set_rom_clut);
++
++static void _davinci_disp_set_clut_ycbcr(unsigned char clut_index,
++					 unsigned char y, unsigned char cb,
++					 unsigned char cr)
++{
++	/* wait until any previous writes to the CLUT RAM have completed */
++	while (osd_read(OSD_MISCCTL) & OSD_MISCCTL_CPBSY)
++		cpu_relax();
++
++	osd_write((y << OSD_CLUTRAMYCB_Y_SHIFT) | cb, OSD_CLUTRAMYCB);
++	osd_write((cr << OSD_CLUTRAMCR_CR_SHIFT) | clut_index, OSD_CLUTRAMCR);
++}
++
++void davinci_disp_set_clut_ycbcr(unsigned char clut_index, unsigned char y,
++				 unsigned char cb, unsigned char cr)
++{
++	unsigned long flags;
++
++	spin_lock_irqsave(&osd->lock, flags);
++
++	osd->clut_ram[clut_index][0] = y;
++	osd->clut_ram[clut_index][1] = cb;
++	osd->clut_ram[clut_index][2] = cr;
++	_davinci_disp_set_clut_ycbcr(clut_index, y, cb, cr);
++
++	spin_unlock_irqrestore(&osd->lock, flags);
++}
++EXPORT_SYMBOL(davinci_disp_set_clut_ycbcr);
++
++static void _davinci_disp_rgb_to_ycbcr(const unsigned char rgb[3],
++				       unsigned char ycbcr[3])
++{
++	int y, cb, cr;
++	int r = rgb[0];
++	int g = rgb[1];
++	int b = rgb[2];
++	/*
++	 * This conversion matrix corresponds to the conversion matrix used
++	 * by the OSD to convert RGB values to YCbCr values.  All coefficients
++	 * have been scaled by a factor of 2^22.
++	 */
++	static const int rgb_to_ycbcr[3][3] = {
++		{1250330, 2453618, 490352},
++		{-726093, -1424868, 2150957},
++		{2099836, -1750086, -349759}
++	};
++
++	y = rgb_to_ycbcr[0][0] * r + rgb_to_ycbcr[0][1] * g +
++	    rgb_to_ycbcr[0][2] * b;
++	cb = rgb_to_ycbcr[1][0] * r + rgb_to_ycbcr[1][1] * g +
++	    rgb_to_ycbcr[1][2] * b;
++	cr = rgb_to_ycbcr[2][0] * r + rgb_to_ycbcr[2][1] * g +
++	    rgb_to_ycbcr[2][2] * b;
++
++	/* round and scale */
++	y = ((y + (1 << 21)) >> 22);
++	cb = ((cb + (1 << 21)) >> 22) + 128;
++	cr = ((cr + (1 << 21)) >> 22) + 128;
++
++	/* clip */
++	y = (y < 0) ? 0 : y;
++	y = (y > 255) ? 255 : y;
++	cb = (cb < 0) ? 0 : cb;
++	cb = (cb > 255) ? 255 : cb;
++	cr = (cr < 0) ? 0 : cr;
++	cr = (cr > 255) ? 255 : cr;
++
++	ycbcr[0] = y;
++	ycbcr[1] = cb;
++	ycbcr[2] = cr;
++}
++
++void davinci_disp_set_clut_rgb(unsigned char clut_index, unsigned char r,
++			       unsigned char g, unsigned char b)
++{
++	unsigned char rgb[3], ycbcr[3];
++	unsigned long flags;
++
++	rgb[0] = r;
++	rgb[1] = g;
++	rgb[2] = b;
++	_davinci_disp_rgb_to_ycbcr(rgb, ycbcr);
++
++	spin_lock_irqsave(&osd->lock, flags);
++
++	osd->clut_ram[clut_index][0] = ycbcr[0];
++	osd->clut_ram[clut_index][1] = ycbcr[1];
++	osd->clut_ram[clut_index][2] = ycbcr[2];
++	_davinci_disp_set_clut_ycbcr(clut_index, ycbcr[0], ycbcr[1], ycbcr[2]);
++
++	spin_unlock_irqrestore(&osd->lock, flags);
++}
++EXPORT_SYMBOL(davinci_disp_set_clut_rgb);
++
++unsigned char davinci_disp_get_palette_map(enum davinci_osd_layer osdwin,
++					   unsigned char pixel_value)
++{
++	enum davinci_disp_layer layer =
++	    (osdwin == OSDWIN_OSD0) ? WIN_OSD0 : WIN_OSD1;
++	struct davinci_window_state *win = &osd->win[layer];
++	struct davinci_osdwin_state *osdwin_state = &osd->osdwin[osdwin];
++	unsigned char clut_index;
++	unsigned long flags;
++
++	spin_lock_irqsave(&osd->lock, flags);
++
++	switch (win->lconfig.pixfmt) {
++	case PIXFMT_1BPP:
++		clut_index = osdwin_state->palette_map[pixel_value & 0x1];
++		break;
++	case PIXFMT_2BPP:
++		clut_index = osdwin_state->palette_map[pixel_value & 0x3];
++		break;
++	case PIXFMT_4BPP:
++		clut_index = osdwin_state->palette_map[pixel_value & 0xf];
++		break;
++	default:
++		clut_index = 0;
++		break;
++	}
++
++	spin_unlock_irqrestore(&osd->lock, flags);
++
++	return clut_index;
++}
++EXPORT_SYMBOL(davinci_disp_get_palette_map);
++
++static void _davinci_disp_set_palette_map(enum davinci_osd_layer osdwin,
++					  unsigned char pixel_value,
++					  unsigned char clut_index,
++					  enum davinci_pix_format pixfmt)
++{
++	int bmp_reg, bmp_offset, bmp_mask, bmp_shift;
++	static const int map_1bpp[] = { 0, 15 };
++	static const int map_2bpp[] = { 0, 5, 10, 15 };
++
++	switch (pixfmt) {
++	case PIXFMT_1BPP:
++		bmp_reg = map_1bpp[pixel_value & 0x1];
++		break;
++	case PIXFMT_2BPP:
++		bmp_reg = map_2bpp[pixel_value & 0x3];
++		break;
++	case PIXFMT_4BPP:
++		bmp_reg = pixel_value & 0xf;
++		break;
++	default:
++		return;
++	}
++
++	switch (osdwin) {
++	case OSDWIN_OSD0:
++		bmp_offset = OSD_W0BMP01 + (bmp_reg >> 1) * sizeof(u32);
++		break;
++	case OSDWIN_OSD1:
++		bmp_offset = OSD_W1BMP01 + (bmp_reg >> 1) * sizeof(u32);
++		break;
++	default:
++		return;
++	}
++
++	if (bmp_reg & 1) {
++		bmp_shift = 8;
++		bmp_mask = 0xff << 8;
++	} else {
++		bmp_shift = 0;
++		bmp_mask = 0xff;
++	}
++
++	osd_merge(bmp_mask, clut_index << bmp_shift, bmp_offset);
++}
++
++void davinci_disp_set_palette_map(enum davinci_osd_layer osdwin,
++				  unsigned char pixel_value,
++				  unsigned char clut_index)
++{
++	enum davinci_disp_layer layer =
++	    (osdwin == OSDWIN_OSD0) ? WIN_OSD0 : WIN_OSD1;
++	struct davinci_window_state *win = &osd->win[layer];
++	struct davinci_osdwin_state *osdwin_state = &osd->osdwin[osdwin];
++	unsigned long flags;
++
++	spin_lock_irqsave(&osd->lock, flags);
++
++	switch (win->lconfig.pixfmt) {
++	case PIXFMT_1BPP:
++		osdwin_state->palette_map[pixel_value & 0x1] = clut_index;
++		break;
++	case PIXFMT_2BPP:
++		osdwin_state->palette_map[pixel_value & 0x3] = clut_index;
++		break;
++	case PIXFMT_4BPP:
++		osdwin_state->palette_map[pixel_value & 0xf] = clut_index;
++		break;
++	default:
++		spin_unlock_irqrestore(&osd->lock, flags);
++		return;
++	}
++
++	_davinci_disp_set_palette_map(osdwin, pixel_value, clut_index,
++				      win->lconfig.pixfmt);
++
++	spin_unlock_irqrestore(&osd->lock, flags);
++}
++EXPORT_SYMBOL(davinci_disp_set_palette_map);
++
++int davinci_disp_get_rec601_attenuation(enum davinci_osd_layer osdwin)
++{
++	struct davinci_osdwin_state *osdwin_state = &osd->osdwin[osdwin];
++
++	return osdwin_state->rec601_attenuation;
++}
++EXPORT_SYMBOL(davinci_disp_get_rec601_attenuation);
++
++static void _davinci_disp_set_rec601_attenuation(enum davinci_osd_layer osdwin,
++						 int enable)
++{
++	switch (osdwin) {
++	case OSDWIN_OSD0:
++		if (cpu_is_davinci_dm644x()) {
++			osd_merge(OSD_OSDWIN0MD_ATN0E,
++				  enable ? OSD_OSDWIN0MD_ATN0E : 0,
++				  OSD_OSDWIN0MD);
++		} else if (cpu_is_davinci_dm355() || cpu_is_davinci_dm365()) {
++			osd_merge(OSD_EXTMODE_ATNOSD0EN,
++				  enable ? OSD_EXTMODE_ATNOSD0EN : 0,
++				  OSD_EXTMODE);
++		}
++		break;
++	case OSDWIN_OSD1:
++		if (cpu_is_davinci_dm644x()) {
++			osd_merge(OSD_OSDWIN1MD_ATN1E,
++				  enable ? OSD_OSDWIN1MD_ATN1E : 0,
++				  OSD_OSDWIN1MD);
++		} else if (cpu_is_davinci_dm355() || cpu_is_davinci_dm365()) {
++			osd_merge(OSD_EXTMODE_ATNOSD1EN,
++				  enable ? OSD_EXTMODE_ATNOSD1EN : 0,
++				  OSD_EXTMODE);
++		}
++		break;
++	}
++}
++
++void davinci_disp_set_rec601_attenuation(enum davinci_osd_layer osdwin,
++					 int enable)
++{
++	enum davinci_disp_layer layer =
++	    (osdwin == OSDWIN_OSD0) ? WIN_OSD0 : WIN_OSD1;
++	struct davinci_window_state *win = &osd->win[layer];
++	struct davinci_osdwin_state *osdwin_state = &osd->osdwin[osdwin];
++	unsigned long flags;
++
++	spin_lock_irqsave(&osd->lock, flags);
++
++	osdwin_state->rec601_attenuation = (enable != 0);
++	if (win->lconfig.pixfmt != PIXFMT_OSD_ATTR)
++		_davinci_disp_set_rec601_attenuation(osdwin, enable);
++
++	spin_unlock_irqrestore(&osd->lock, flags);
++}
++EXPORT_SYMBOL(davinci_disp_set_rec601_attenuation);
++
++enum davinci_blending_factor davinci_disp_get_blending_factor(enum
++							      davinci_osd_layer
++							      osdwin)
++{
++	struct davinci_osdwin_state *osdwin_state = &osd->osdwin[osdwin];
++
++	return osdwin_state->blend;
++}
++EXPORT_SYMBOL(davinci_disp_get_blending_factor);
++
++static void _davinci_disp_set_blending_factor(enum davinci_osd_layer osdwin,
++					      enum davinci_blending_factor
++					      blend)
++{
++	switch (osdwin) {
++	case OSDWIN_OSD0:
++		osd_merge(OSD_OSDWIN0MD_BLND0,
++			  blend << OSD_OSDWIN0MD_BLND0_SHIFT, OSD_OSDWIN0MD);
++		break;
++	case OSDWIN_OSD1:
++		osd_merge(OSD_OSDWIN1MD_BLND1,
++			  blend << OSD_OSDWIN1MD_BLND1_SHIFT, OSD_OSDWIN1MD);
++		break;
++	}
++}
++
++void davinci_disp_set_blending_factor(enum davinci_osd_layer osdwin,
++				      enum davinci_blending_factor blend)
++{
++	enum davinci_disp_layer layer =
++	    (osdwin == OSDWIN_OSD0) ? WIN_OSD0 : WIN_OSD1;
++	struct davinci_window_state *win = &osd->win[layer];
++	struct davinci_osdwin_state *osdwin_state = &osd->osdwin[osdwin];
++	unsigned long flags;
++
++	spin_lock_irqsave(&osd->lock, flags);
++
++	osdwin_state->blend = blend;
++	if (win->lconfig.pixfmt != PIXFMT_OSD_ATTR)
++		_davinci_disp_set_blending_factor(osdwin, blend);
++
++	spin_unlock_irqrestore(&osd->lock, flags);
++}
++EXPORT_SYMBOL(davinci_disp_set_blending_factor);
++
++static void _davinci_disp_enable_rgb888_pixblend(enum davinci_osd_layer osdwin)
++{
++
++	osd_merge(OSD_MISCCTL_BLDSEL, 0, OSD_MISCCTL);
++	switch (osdwin) {
++	case OSDWIN_OSD0:
++		osd_merge(OSD_EXTMODE_OSD0BLDCHR,
++			  OSD_EXTMODE_OSD0BLDCHR, OSD_EXTMODE);
++		break;
++	case OSDWIN_OSD1:
++		osd_merge(OSD_EXTMODE_OSD1BLDCHR,
++			  OSD_EXTMODE_OSD1BLDCHR, OSD_EXTMODE);
++		break;
++	}
++}
++
++void davinci_disp_enable_rgb888_pixblend(enum davinci_osd_layer osdwin)
++{
++	enum davinci_disp_layer layer =
++	    (osdwin == OSDWIN_OSD0) ? WIN_OSD0 : WIN_OSD1;
++	struct davinci_window_state *win = &osd->win[layer];
++	unsigned long flags;
++
++	if (cpu_is_davinci_dm644x())
++		return;
++
++	spin_lock_irqsave(&osd->lock, flags);
++
++	if (win->lconfig.pixfmt == PIXFMT_RGB888)
++		_davinci_disp_enable_rgb888_pixblend(osdwin);
++
++	spin_unlock_irqrestore(&osd->lock, flags);
++}
++EXPORT_SYMBOL(davinci_disp_enable_rgb888_pixblend);
++
++static void _davinci_disp_disable_color_key(enum davinci_osd_layer osdwin)
++{
++	switch (osdwin) {
++	case OSDWIN_OSD0:
++		osd_clear(OSD_OSDWIN0MD_TE0, OSD_OSDWIN0MD);
++		break;
++	case OSDWIN_OSD1:
++		osd_clear(OSD_OSDWIN1MD_TE1, OSD_OSDWIN1MD);
++		break;
++	}
++}
++
++void davinci_disp_disable_color_key(enum davinci_osd_layer osdwin)
++{
++	enum davinci_disp_layer layer =
++	    (osdwin == OSDWIN_OSD0) ? WIN_OSD0 : WIN_OSD1;
++	struct davinci_window_state *win = &osd->win[layer];
++	struct davinci_osdwin_state *osdwin_state = &osd->osdwin[osdwin];
++	unsigned long flags;
++
++	spin_lock_irqsave(&osd->lock, flags);
++
++	osdwin_state->colorkey_blending = 0;
++	if (win->lconfig.pixfmt != PIXFMT_OSD_ATTR)
++		_davinci_disp_disable_color_key(osdwin);
++
++	spin_unlock_irqrestore(&osd->lock, flags);
++}
++EXPORT_SYMBOL(davinci_disp_disable_color_key);
++
++static void _davinci_disp_enable_color_key(enum davinci_osd_layer osdwin,
++					   unsigned colorkey,
++					   enum davinci_pix_format pixfmt)
++{
++	switch (pixfmt) {
++	case PIXFMT_1BPP:
++	case PIXFMT_2BPP:
++	case PIXFMT_4BPP:
++	case PIXFMT_8BPP:
++		if (cpu_is_davinci_dm355()) {
++			switch (osdwin) {
++			case OSDWIN_OSD0:
++				osd_merge(OSD_TRANSPBMPIDX_BMP0,
++					  colorkey <<
++					  OSD_TRANSPBMPIDX_BMP0_SHIFT,
++					  OSD_TRANSPBMPIDX);
++				break;
++			case OSDWIN_OSD1:
++				osd_merge(OSD_TRANSPBMPIDX_BMP1,
++					  colorkey <<
++					  OSD_TRANSPBMPIDX_BMP1_SHIFT,
++					  OSD_TRANSPBMPIDX);
++				break;
++			}
++		}
++		break;
++	case PIXFMT_RGB565:
++		if (cpu_is_davinci_dm644x()) {
++			osd_write(colorkey & OSD_TRANSPVAL_RGBTRANS,
++				  OSD_TRANSPVAL);
++		} else if (cpu_is_davinci_dm355()) {
++			osd_write(colorkey & OSD_TRANSPVALL_RGBL,
++				  OSD_TRANSPVALL);
++		}
++		break;
++	case PIXFMT_YCbCrI:
++	case PIXFMT_YCrCbI:
++		if (cpu_is_davinci_dm355())
++			osd_merge(OSD_TRANSPVALU_Y, colorkey, OSD_TRANSPVALU);
++		break;
++	case PIXFMT_RGB888:
++		if (cpu_is_davinci_dm355()) {
++			osd_write(colorkey & OSD_TRANSPVALL_RGBL,
++				  OSD_TRANSPVALL);
++			osd_merge(OSD_TRANSPVALU_RGBU, colorkey >> 16,
++				  OSD_TRANSPVALU);
++		}
++		break;
++	default:
++		break;
++	}
++
++	switch (osdwin) {
++	case OSDWIN_OSD0:
++		osd_set(OSD_OSDWIN0MD_TE0, OSD_OSDWIN0MD);
++		break;
++	case OSDWIN_OSD1:
++		osd_set(OSD_OSDWIN1MD_TE1, OSD_OSDWIN1MD);
++		break;
++	}
++}
++
++void davinci_disp_enable_color_key(enum davinci_osd_layer osdwin,
++				   unsigned colorkey)
++{
++	enum davinci_disp_layer layer =
++	    (osdwin == OSDWIN_OSD0) ? WIN_OSD0 : WIN_OSD1;
++	struct davinci_window_state *win = &osd->win[layer];
++	struct davinci_osdwin_state *osdwin_state = &osd->osdwin[osdwin];
++	unsigned long flags;
++
++	spin_lock_irqsave(&osd->lock, flags);
++
++	osdwin_state->colorkey_blending = 1;
++	osdwin_state->colorkey = colorkey;
++	if (win->lconfig.pixfmt != PIXFMT_OSD_ATTR) {
++		_davinci_disp_enable_color_key(osdwin, colorkey,
++					       win->lconfig.pixfmt);
++	}
++
++	spin_unlock_irqrestore(&osd->lock, flags);
++}
++EXPORT_SYMBOL(davinci_disp_enable_color_key);
++
++enum davinci_clut davinci_disp_get_osd_clut(enum davinci_osd_layer osdwin)
++{
++	struct davinci_osdwin_state *osdwin_state = &osd->osdwin[osdwin];
++
++	return osdwin_state->clut;
++}
++EXPORT_SYMBOL(davinci_disp_get_osd_clut);
++
++static void _davinci_disp_set_osd_clut(enum davinci_osd_layer osdwin,
++				       enum davinci_clut clut)
++{
++	u32 winmd = 0;
++
++	switch (osdwin) {
++	case OSDWIN_OSD0:
++		if (clut == RAM_CLUT)
++			winmd |= OSD_OSDWIN0MD_CLUTS0;
++		osd_merge(OSD_OSDWIN0MD_CLUTS0, winmd, OSD_OSDWIN0MD);
++		break;
++	case OSDWIN_OSD1:
++		if (clut == RAM_CLUT)
++			winmd |= OSD_OSDWIN1MD_CLUTS1;
++		osd_merge(OSD_OSDWIN1MD_CLUTS1, winmd, OSD_OSDWIN1MD);
++		break;
++	}
++}
++
++void davinci_disp_set_osd_clut(enum davinci_osd_layer osdwin,
++			       enum davinci_clut clut)
++{
++	enum davinci_disp_layer layer =
++	    (osdwin == OSDWIN_OSD0) ? WIN_OSD0 : WIN_OSD1;
++	struct davinci_window_state *win = &osd->win[layer];
++	struct davinci_osdwin_state *osdwin_state = &osd->osdwin[osdwin];
++	unsigned long flags;
++
++	spin_lock_irqsave(&osd->lock, flags);
++
++	osdwin_state->clut = clut;
++	if (win->lconfig.pixfmt != PIXFMT_OSD_ATTR)
++		_davinci_disp_set_osd_clut(osdwin, clut);
++
++	spin_unlock_irqrestore(&osd->lock, flags);
++}
++EXPORT_SYMBOL(davinci_disp_set_osd_clut);
++
++void davinci_disp_get_zoom(enum davinci_disp_layer layer,
++			   enum davinci_zoom_factor *h_zoom,
++			   enum davinci_zoom_factor *v_zoom)
++{
++	struct davinci_window_state *win = &osd->win[layer];
++	unsigned long flags;
++
++	spin_lock_irqsave(&osd->lock, flags);
++
++	*h_zoom = win->h_zoom;
++	*v_zoom = win->v_zoom;
++
++	spin_unlock_irqrestore(&osd->lock, flags);
++}
++EXPORT_SYMBOL(davinci_disp_get_zoom);
++
++static void _davinci_disp_set_zoom(enum davinci_disp_layer layer,
++				   enum davinci_zoom_factor h_zoom,
++				   enum davinci_zoom_factor v_zoom)
++{
++	u32 winmd = 0;
++
++	switch (layer) {
++	case WIN_OSD0:
++		winmd |= (h_zoom << OSD_OSDWIN0MD_OHZ0_SHIFT);
++		winmd |= (v_zoom << OSD_OSDWIN0MD_OVZ0_SHIFT);
++		osd_merge(OSD_OSDWIN0MD_OHZ0 | OSD_OSDWIN0MD_OVZ0, winmd,
++			  OSD_OSDWIN0MD);
++		break;
++	case WIN_VID0:
++		winmd |= (h_zoom << OSD_VIDWINMD_VHZ0_SHIFT);
++		winmd |= (v_zoom << OSD_VIDWINMD_VVZ0_SHIFT);
++		osd_merge(OSD_VIDWINMD_VHZ0 | OSD_VIDWINMD_VVZ0, winmd,
++			  OSD_VIDWINMD);
++		break;
++	case WIN_OSD1:
++		winmd |= (h_zoom << OSD_OSDWIN1MD_OHZ1_SHIFT);
++		winmd |= (v_zoom << OSD_OSDWIN1MD_OVZ1_SHIFT);
++		osd_merge(OSD_OSDWIN1MD_OHZ1 | OSD_OSDWIN1MD_OVZ1, winmd,
++			  OSD_OSDWIN1MD);
++		break;
++	case WIN_VID1:
++		winmd |= (h_zoom << OSD_VIDWINMD_VHZ1_SHIFT);
++		winmd |= (v_zoom << OSD_VIDWINMD_VVZ1_SHIFT);
++		osd_merge(OSD_VIDWINMD_VHZ1 | OSD_VIDWINMD_VVZ1, winmd,
++			  OSD_VIDWINMD);
++		break;
++	}
++}
++
++void davinci_disp_set_zoom(enum davinci_disp_layer layer,
++			   enum davinci_zoom_factor h_zoom,
++			   enum davinci_zoom_factor v_zoom)
++{
++	struct davinci_window_state *win = &osd->win[layer];
++	unsigned long flags;
++
++	spin_lock_irqsave(&osd->lock, flags);
++
++	win->h_zoom = h_zoom;
++	win->v_zoom = v_zoom;
++	_davinci_disp_set_zoom(layer, h_zoom, v_zoom);
++
++	spin_unlock_irqrestore(&osd->lock, flags);
++}
++EXPORT_SYMBOL(davinci_disp_set_zoom);
++
++int davinci_disp_layer_is_enabled(enum davinci_disp_layer layer)
++{
++	struct davinci_window_state *win = &osd->win[layer];
++	return win->is_enabled;
++}
++EXPORT_SYMBOL(davinci_disp_layer_is_enabled);
++
++static void _davinci_disp_disable_layer(enum
++					davinci_disp_layer layer)
++{
++	switch (layer) {
++	case WIN_OSD0:
++		osd_clear(OSD_OSDWIN0MD_OACT0, OSD_OSDWIN0MD);
++		break;
++	case WIN_VID0:
++		osd_clear(OSD_VIDWINMD_ACT0, OSD_VIDWINMD);
++		break;
++	case WIN_OSD1:
++		/* disable attribute mode as well as disabling the window */
++		osd_clear(OSD_OSDWIN1MD_OASW | OSD_OSDWIN1MD_OACT1,
++			  OSD_OSDWIN1MD);
++		break;
++	case WIN_VID1:
++		osd_clear(OSD_VIDWINMD_ACT1, OSD_VIDWINMD);
++		break;
++	}
++}
++
++void davinci_disp_disable_layer(enum davinci_disp_layer layer)
++{
++	struct davinci_window_state *win = &osd->win[layer];
++	unsigned long flags;
++
++	spin_lock_irqsave(&osd->lock, flags);
++
++	if (!win->is_enabled) {
++		spin_unlock_irqrestore(&osd->lock, flags);
++		return;
++	}
++	win->is_enabled = 0;
++
++	_davinci_disp_disable_layer(layer);
++
++	spin_unlock_irqrestore(&osd->lock, flags);
++}
++EXPORT_SYMBOL(davinci_disp_disable_layer);
++
++static void _davinci_disp_enable_attribute_mode(void)
++{
++	/* enable attribute mode for OSD1 */
++	osd_set(OSD_OSDWIN1MD_OASW, OSD_OSDWIN1MD);
++}
++
++static void _davinci_disp_enable_layer(enum
++				       davinci_disp_layer layer)
++{
++	switch (layer) {
++	case WIN_OSD0:
++		osd_set(OSD_OSDWIN0MD_OACT0, OSD_OSDWIN0MD);
++		break;
++	case WIN_VID0:
++		osd_set(OSD_VIDWINMD_ACT0, OSD_VIDWINMD);
++		break;
++	case WIN_OSD1:
++		/* enable OSD1 and disable attribute mode */
++		osd_merge(OSD_OSDWIN1MD_OASW | OSD_OSDWIN1MD_OACT1,
++			  OSD_OSDWIN1MD_OACT1, OSD_OSDWIN1MD);
++		break;
++	case WIN_VID1:
++		osd_set(OSD_VIDWINMD_ACT1, OSD_VIDWINMD);
++		break;
++	}
++}
++
++int davinci_disp_enable_layer(enum davinci_disp_layer layer,
++			      int otherwin)
++{
++	struct davinci_window_state *win = &osd->win[layer];
++	unsigned long flags;
++
++	spin_lock_irqsave(&osd->lock, flags);
++
++	/* use otherwin flag to know this is the other vid window
++	 * in YUV420 mode, if is, skip this check
++	 */
++	if (!otherwin && (!win->is_allocated ||
++			!win->fb_base_phys ||
++			!win->lconfig.line_length ||
++			!win->lconfig.xsize ||
++			!win->lconfig.ysize)) {
++		spin_unlock_irqrestore(&osd->lock, flags);
++		return -1;
++	}
++
++	if (win->is_enabled) {
++		spin_unlock_irqrestore(&osd->lock, flags);
++		return 0;
++	}
++	win->is_enabled = 1;
++
++	if (win->lconfig.pixfmt != PIXFMT_OSD_ATTR)
++		_davinci_disp_enable_layer(layer);
++	else {
++		_davinci_disp_enable_attribute_mode();
++		_davinci_disp_set_blink_attribute(osd->is_blinking, osd->blink);
++	}
++
++	spin_unlock_irqrestore(&osd->lock, flags);
++	return 0;
++}
++EXPORT_SYMBOL(davinci_disp_enable_layer);
++
++static void _davinci_disp_start_layer(enum davinci_disp_layer layer,
++					unsigned long fb_base_phys,
++					unsigned long cbcr_ofst)
++{
++	if (cpu_is_davinci_dm644x()) {
++		switch (layer) {
++		case WIN_OSD0:
++			osd_write(fb_base_phys & ~0x1F, OSD_OSDWIN0ADR);
++			break;
++		case WIN_VID0:
++			osd_write(fb_base_phys & ~0x1F, OSD_VIDWIN0ADR);
++			break;
++		case WIN_OSD1:
++			osd_write(fb_base_phys & ~0x1F, OSD_OSDWIN1ADR);
++			break;
++		case WIN_VID1:
++			osd_write(fb_base_phys & ~0x1F, OSD_VIDWIN1ADR);
++			break;
++		}
++	} else if (cpu_is_davinci_dm355()) {
++		unsigned long fb_offset_32 =
++		    (fb_base_phys - DAVINCI_DDR_BASE) >> 5;
++
++		switch (layer) {
++		case WIN_OSD0:
++			osd_merge(OSD_OSDWINADH_O0AH,
++				  fb_offset_32 >> (16 -
++						   OSD_OSDWINADH_O0AH_SHIFT),
++				  OSD_OSDWINADH);
++			osd_write(fb_offset_32 & OSD_OSDWIN0ADL_O0AL,
++				  OSD_OSDWIN0ADL);
++			break;
++		case WIN_VID0:
++			osd_merge(OSD_VIDWINADH_V0AH,
++				  fb_offset_32 >> (16 -
++						   OSD_VIDWINADH_V0AH_SHIFT),
++				  OSD_VIDWINADH);
++			osd_write(fb_offset_32 & OSD_VIDWIN0ADL_V0AL,
++				  OSD_VIDWIN0ADL);
++			break;
++		case WIN_OSD1:
++			osd_merge(OSD_OSDWINADH_O1AH,
++				  fb_offset_32 >> (16 -
++						   OSD_OSDWINADH_O1AH_SHIFT),
++				  OSD_OSDWINADH);
++			osd_write(fb_offset_32 & OSD_OSDWIN1ADL_O1AL,
++				  OSD_OSDWIN1ADL);
++			break;
++		case WIN_VID1:
++			osd_merge(OSD_VIDWINADH_V1AH,
++				  fb_offset_32 >> (16 -
++						   OSD_VIDWINADH_V1AH_SHIFT),
++				  OSD_VIDWINADH);
++			osd_write(fb_offset_32 & OSD_VIDWIN1ADL_V1AL,
++				  OSD_VIDWIN1ADL);
++			break;
++		}
++	} else if (cpu_is_davinci_dm365()) {
++		struct davinci_window_state *win = &osd->win[layer];
++		unsigned long fb_offset_32, cbcr_offset_32;
++
++		fb_offset_32 = fb_base_phys - DAVINCI_DDR_BASE;
++		if (cbcr_ofst)
++			cbcr_offset_32 = cbcr_ofst;
++		else
++			cbcr_offset_32 = win->lconfig.line_length *
++					 win->lconfig.ysize;
++		cbcr_offset_32 += fb_offset_32;
++		fb_offset_32 = fb_offset_32 >> 5;
++		cbcr_offset_32 = cbcr_offset_32 >> 5;
++		/*
++		 * DM365: start address is 27-bit long address b26 - b23 are
++		 * in offset register b12 - b9, and * bit 26 has to be '1'
++		 */
++		if (win->lconfig.pixfmt == PIXFMT_NV12) {
++			switch (layer) {
++			case WIN_VID0:
++			case WIN_VID1:
++				/* Y is in VID0 */
++				osd_merge(OSD_VIDWIN0OFST_V0AH,
++					 ((fb_offset_32 & 0x7800000) >>
++					 (23 - OSD_WINOFST_AH_SHIFT)) | 0x1000,
++					  OSD_VIDWIN0OFST);
++				osd_merge(OSD_VIDWINADH_V0AH,
++					  (fb_offset_32 & 0x7F0000) >>
++					  (16 - OSD_VIDWINADH_V0AH_SHIFT),
++					  OSD_VIDWINADH);
++				osd_write(fb_offset_32 & 0xFFFF,
++					  OSD_VIDWIN0ADL);
++				/* CbCr is in VID1 */
++				osd_merge(OSD_VIDWIN1OFST_V1AH,
++					 ((cbcr_offset_32 & 0x7800000) >>
++					 (23 - OSD_WINOFST_AH_SHIFT)) | 0x1000,
++					  OSD_VIDWIN1OFST);
++				osd_merge(OSD_VIDWINADH_V1AH,
++					  (cbcr_offset_32 & 0x7F0000) >>
++					  (16 - OSD_VIDWINADH_V1AH_SHIFT),
++					  OSD_VIDWINADH);
++				osd_write(cbcr_offset_32 & 0xFFFF,
++					  OSD_VIDWIN1ADL);
++				break;
++			default:
++				break;
++			}
++		}
++
++		switch (layer) {
++		case WIN_OSD0:
++			osd_merge(OSD_OSDWIN0OFST_O0AH,
++				 ((fb_offset_32 & 0x7800000) >>
++				 (23 - OSD_WINOFST_AH_SHIFT)) | 0x1000,
++				  OSD_OSDWIN0OFST);
++			osd_merge(OSD_OSDWINADH_O0AH,
++				 (fb_offset_32 & 0x7F0000) >>
++				 (16 - OSD_OSDWINADH_O0AH_SHIFT),
++				  OSD_OSDWINADH);
++			osd_write(fb_offset_32 & 0xFFFF, OSD_OSDWIN0ADL);
++			break;
++		case WIN_VID0:
++			if (win->lconfig.pixfmt != PIXFMT_NV12) {
++				osd_merge(OSD_VIDWIN0OFST_V0AH,
++					 ((fb_offset_32 & 0x7800000) >>
++					 (23 - OSD_WINOFST_AH_SHIFT)) | 0x1000,
++					  OSD_VIDWIN0OFST);
++				osd_merge(OSD_VIDWINADH_V0AH,
++					  (fb_offset_32 & 0x7F0000) >>
++					  (16 - OSD_VIDWINADH_V0AH_SHIFT),
++					  OSD_VIDWINADH);
++				osd_write(fb_offset_32 & 0xFFFF,
++					  OSD_VIDWIN0ADL);
++			}
++			break;
++		case WIN_OSD1:
++			osd_merge(OSD_OSDWIN1OFST_O1AH,
++				 ((fb_offset_32 & 0x7800000) >>
++				 (23 - OSD_WINOFST_AH_SHIFT)) | 0x1000,
++				  OSD_OSDWIN1OFST);
++			osd_merge(OSD_OSDWINADH_O1AH,
++				  (fb_offset_32 & 0x7F0000) >>
++				  (16 - OSD_OSDWINADH_O1AH_SHIFT),
++				  OSD_OSDWINADH);
++			osd_write(fb_offset_32 & 0xFFFF, OSD_OSDWIN1ADL);
++			break;
++		case WIN_VID1:
++			if (win->lconfig.pixfmt != PIXFMT_NV12) {
++				osd_merge(OSD_VIDWIN1OFST_V1AH,
++					 ((fb_offset_32 & 0x7800000) >>
++					 (23 - OSD_WINOFST_AH_SHIFT)) | 0x1000,
++					  OSD_VIDWIN1OFST);
++				osd_merge(OSD_VIDWINADH_V1AH,
++					  (fb_offset_32 & 0x7F0000) >>
++					  (16 - OSD_VIDWINADH_V1AH_SHIFT),
++					  OSD_VIDWINADH);
++				osd_write(fb_offset_32 & 0xFFFF,
++					  OSD_VIDWIN1ADL);
++			}
++			break;
++		}
++	}
++}
++
++void davinci_disp_start_layer(enum davinci_disp_layer layer,
++			      unsigned long fb_base_phys,
++			      unsigned long cbcr_ofst)
++{
++	struct davinci_window_state *win = &osd->win[layer];
++	unsigned long flags;
++
++	spin_lock_irqsave(&osd->lock, flags);
++
++	win->fb_base_phys = fb_base_phys & ~0x1F;
++	_davinci_disp_start_layer(layer, fb_base_phys, cbcr_ofst);
++
++	if (layer == WIN_VID0) {
++		osd->pingpong =
++		    _davinci_disp_dm6446_vid0_pingpong(osd->field_inversion,
++						       win->fb_base_phys,
++						       &win->lconfig);
++	}
++
++	spin_unlock_irqrestore(&osd->lock, flags);
++}
++EXPORT_SYMBOL(davinci_disp_start_layer);
++
++void davinci_disp_get_layer_config(enum davinci_disp_layer layer,
++				   struct davinci_layer_config *lconfig)
++{
++	struct davinci_window_state *win = &osd->win[layer];
++	unsigned long flags;
++
++	spin_lock_irqsave(&osd->lock, flags);
++
++	*lconfig = win->lconfig;
++
++	spin_unlock_irqrestore(&osd->lock, flags);
++}
++EXPORT_SYMBOL(davinci_disp_get_layer_config);
++
++void _davinci_disp_copy_layer_config(enum davinci_disp_layer to_layer,
++				     enum davinci_disp_layer from_layer)
++{
++	struct davinci_layer_config *tlconfig, *flconfig;
++
++	tlconfig = &(osd->win[to_layer].lconfig);
++	flconfig = &(osd->win[from_layer].lconfig);
++
++	memcpy(tlconfig, flconfig, sizeof(struct davinci_layer_config));
++}
++
++/*
++ * If the requested lconfig is completely rejected and the value of lconfig on
++ * exit is the current lconfig, then try_layer_config() returns 1.  Otherwise,
++ * try_layer_config() returns 0.  A return value of 0 does not necessarily mean
++ * that the value of lconfig on exit is identical to the value of lconfig on
++ * entry, but merely that it represents a change from the current lconfig.
++ */
++static int try_layer_config(enum davinci_disp_layer layer,
++			    struct davinci_layer_config *lconfig)
++{
++	struct davinci_window_state *win = &osd->win[layer];
++	int bad_config = 0;
++
++	/* verify that the pixel format is compatible with the layer */
++	switch (lconfig->pixfmt) {
++	case PIXFMT_1BPP:
++	case PIXFMT_2BPP:
++	case PIXFMT_4BPP:
++	case PIXFMT_8BPP:
++	case PIXFMT_RGB565:
++		bad_config = !is_osd_win(layer);
++		break;
++	case PIXFMT_YCbCrI:
++	case PIXFMT_YCrCbI:
++		if (cpu_is_davinci_dm644x())
++			bad_config = !is_vid_win(layer);
++		break;
++	case PIXFMT_RGB888:
++		if (cpu_is_davinci_dm644x())
++			bad_config = !is_vid_win(layer);
++		else if (cpu_is_davinci_dm355() || cpu_is_davinci_dm365())
++			bad_config = !is_osd_win(layer);
++		break;
++	case PIXFMT_NV12:
++		if (!cpu_is_davinci_dm365())
++			bad_config = 1;
++		else
++			bad_config = is_osd_win(layer);
++		break;
++	case PIXFMT_OSD_ATTR:
++		bad_config = (layer != WIN_OSD1);
++		break;
++	default:
++		bad_config = 1;
++		break;
++	}
++	if (bad_config) {
++		/*
++		 * The requested pixel format is incompatible with the layer, so
++		 * keep the current layer configuration.
++		 */
++		*lconfig = win->lconfig;
++		return bad_config;
++	}
++
++	/* DM6446: */
++	/* only one OSD window at a time can use RGB pixel formats */
++	if ((cpu_is_davinci_dm644x())
++		&& is_osd_win(layer) && is_rgb_pixfmt(lconfig->pixfmt)) {
++		enum davinci_pix_format pixfmt;
++
++		if (layer == WIN_OSD0)
++			pixfmt = osd->win[WIN_OSD1].lconfig.pixfmt;
++		else
++			pixfmt = osd->win[WIN_OSD0].lconfig.pixfmt;
++
++		if (is_rgb_pixfmt(pixfmt)) {
++			/*
++			 * The other OSD window is already configured for an
++			 * RGB, so keep the current layer configuration.
++			 */
++			*lconfig = win->lconfig;
++			return 1;
++		}
++	}
++
++	/* DM6446: only one video window at a time can use RGB888 */
++	if (cpu_is_davinci_dm644x() && is_vid_win(layer)
++	    && lconfig->pixfmt == PIXFMT_RGB888) {
++		enum davinci_pix_format pixfmt;
++
++		if (layer == WIN_VID0)
++			pixfmt = osd->win[WIN_VID1].lconfig.pixfmt;
++		else
++			pixfmt = osd->win[WIN_VID0].lconfig.pixfmt;
++
++		if (pixfmt == PIXFMT_RGB888) {
++			/*
++			 * The other video window is already configured for
++			 * RGB888, so keep the current layer configuration.
++			 */
++			*lconfig = win->lconfig;
++			return 1;
++		}
++	}
++
++	/* window dimensions must be non-zero */
++	if (!lconfig->line_length || !lconfig->xsize || !lconfig->ysize) {
++		*lconfig = win->lconfig;
++		return 1;
++	}
++
++	/* round line_length up to a multiple of 32 */
++	lconfig->line_length = ((lconfig->line_length + 31) / 32) * 32;
++	lconfig->line_length =
++	    min(lconfig->line_length, (unsigned)MAX_LINE_LENGTH);
++	lconfig->xsize = min(lconfig->xsize, (unsigned)MAX_WIN_SIZE);
++	lconfig->ysize = min(lconfig->ysize, (unsigned)MAX_WIN_SIZE);
++	lconfig->xpos = min(lconfig->xpos, (unsigned)MAX_WIN_SIZE);
++	lconfig->ypos = min(lconfig->ypos, (unsigned)MAX_WIN_SIZE);
++	lconfig->interlaced = (lconfig->interlaced != 0);
++	if (lconfig->interlaced) {
++		/* ysize and ypos must be even for interlaced displays */
++		lconfig->ysize &= ~1;
++		lconfig->ypos &= ~1;
++	}
++
++	return 0;
++}
++
++int davinci_disp_try_layer_config(enum davinci_disp_layer layer,
++				  struct davinci_layer_config *lconfig)
++{
++	int reject_config;
++	unsigned long flags;
++
++	spin_lock_irqsave(&osd->lock, flags);
++
++	reject_config = try_layer_config(layer, lconfig);
++
++	spin_unlock_irqrestore(&osd->lock, flags);
++
++	return reject_config;
++}
++EXPORT_SYMBOL(davinci_disp_try_layer_config);
++
++static void _davinci_disp_disable_vid_rgb888(void)
++{
++	/*
++	 * The DM6446 supports RGB888 pixel format in a single video window.
++	 * This routine disables RGB888 pixel format for both video windows.
++	 * The caller must ensure that neither video window is currently
++	 * configured for RGB888 pixel format.
++	 */
++	if (cpu_is_davinci_dm644x())
++		osd_clear(OSD_MISCCTL_RGBEN, OSD_MISCCTL);
++}
++
++static void _davinci_disp_enable_vid_rgb888(enum davinci_disp_layer layer)
++{
++	/*
++	 * The DM6446 supports RGB888 pixel format in a single video window.
++	 * This routine enables RGB888 pixel format for the specified video
++	 * window.  The caller must ensure that the other video window is not
++	 * currently configured for RGB888 pixel format, as this routine will
++	 * disable RGB888 pixel format for the other window.
++	 */
++	if (cpu_is_davinci_dm644x()) {
++		if (layer == WIN_VID0) {
++			osd_merge(OSD_MISCCTL_RGBEN | OSD_MISCCTL_RGBWIN,
++				  OSD_MISCCTL_RGBEN, OSD_MISCCTL);
++		} else if (layer == WIN_VID1) {
++			osd_merge(OSD_MISCCTL_RGBEN | OSD_MISCCTL_RGBWIN,
++				  OSD_MISCCTL_RGBEN | OSD_MISCCTL_RGBWIN,
++				  OSD_MISCCTL);
++		}
++	}
++}
++
++static void _davinci_disp_set_cbcr_order(enum davinci_pix_format pixfmt)
++{
++	/*
++	 * The caller must ensure that all windows using YC pixfmt use the same
++	 * Cb/Cr order.
++	 */
++	if (pixfmt == PIXFMT_YCbCrI)
++		osd_clear(OSD_MODE_CS, OSD_MODE);
++	else if (pixfmt == PIXFMT_YCrCbI)
++		osd_set(OSD_MODE_CS, OSD_MODE);
++}
++
++static void _davinci_disp_set_layer_config(enum davinci_disp_layer layer,
++					   const struct davinci_layer_config
++					   *lconfig)
++{
++	u32 winmd = 0, winmd_mask = 0, bmw = 0;
++
++	_davinci_disp_set_cbcr_order(lconfig->pixfmt);
++
++	switch (layer) {
++	case WIN_OSD0:
++		if (cpu_is_davinci_dm644x()) {
++			winmd_mask |= OSD_OSDWIN0MD_RGB0E;
++			if (lconfig->pixfmt == PIXFMT_RGB565)
++				winmd |= OSD_OSDWIN0MD_RGB0E;
++		} else if (cpu_is_davinci_dm355() || cpu_is_davinci_dm365()) {
++			winmd_mask |= OSD_OSDWIN0MD_BMP0MD;
++			switch (lconfig->pixfmt) {
++			case PIXFMT_RGB565:
++				winmd |= (1 << OSD_OSDWIN0MD_BMP0MD_SHIFT);
++				break;
++			case PIXFMT_RGB888:
++				winmd |= (2 << OSD_OSDWIN0MD_BMP0MD_SHIFT);
++				_davinci_disp_enable_rgb888_pixblend
++				    (OSDWIN_OSD0);
++				break;
++			case PIXFMT_YCbCrI:
++			case PIXFMT_YCrCbI:
++				winmd |= (3 << OSD_OSDWIN0MD_BMP0MD_SHIFT);
++				break;
++			default:
++				break;
++			}
++		}
++
++		winmd_mask |= OSD_OSDWIN0MD_BMW0 | OSD_OSDWIN0MD_OFF0;
++
++		switch (lconfig->pixfmt) {
++		case PIXFMT_1BPP:
++			bmw = 0;
++			break;
++		case PIXFMT_2BPP:
++			bmw = 1;
++			break;
++		case PIXFMT_4BPP:
++			bmw = 2;
++			break;
++		case PIXFMT_8BPP:
++			bmw = 3;
++			break;
++		default:
++			break;
++		}
++		winmd |= (bmw << OSD_OSDWIN0MD_BMW0_SHIFT);
++
++		if (lconfig->interlaced)
++			winmd |= OSD_OSDWIN0MD_OFF0;
++
++		osd_merge(winmd_mask, winmd, OSD_OSDWIN0MD);
++		osd_write(lconfig->line_length >> 5, OSD_OSDWIN0OFST);
++		osd_write(lconfig->xpos, OSD_OSDWIN0XP);
++		osd_write(lconfig->xsize, OSD_OSDWIN0XL);
++		if (lconfig->interlaced) {
++			osd_write(lconfig->ypos >> 1, OSD_OSDWIN0YP);
++			osd_write(lconfig->ysize >> 1, OSD_OSDWIN0YL);
++		} else {
++			osd_write(lconfig->ypos, OSD_OSDWIN0YP);
++			osd_write(lconfig->ysize, OSD_OSDWIN0YL);
++		}
++		break;
++	case WIN_VID0:
++		winmd_mask |= OSD_VIDWINMD_VFF0;
++		if (lconfig->interlaced)
++			winmd |= OSD_VIDWINMD_VFF0;
++
++		osd_merge(winmd_mask, winmd, OSD_VIDWINMD);
++		osd_write(lconfig->line_length >> 5, OSD_VIDWIN0OFST);
++		osd_write(lconfig->xpos, OSD_VIDWIN0XP);
++		osd_write(lconfig->xsize, OSD_VIDWIN0XL);
++		/*
++		 * For YUV420P format the register contents are
++		 * duplicated in both VID registers
++		 */
++		if (cpu_is_davinci_dm365()) {
++			if (lconfig->pixfmt == PIXFMT_NV12) {
++				/* other window also */
++				if (lconfig->interlaced) {
++					winmd_mask |= OSD_VIDWINMD_VFF1;
++					winmd |= OSD_VIDWINMD_VFF1;
++					osd_merge(winmd_mask, winmd,
++						  OSD_VIDWINMD);
++				}
++
++				osd_merge(OSD_MISCCTL_S420D, OSD_MISCCTL_S420D,
++					  OSD_MISCCTL);
++				osd_write(lconfig->line_length >> 5,
++					  OSD_VIDWIN1OFST);
++				osd_write(lconfig->xpos, OSD_VIDWIN1XP);
++				osd_write(lconfig->xsize, OSD_VIDWIN1XL);
++				/* if NV21 pixfmt and line length not 32B
++				 * aligned (e.g. NTSC), Need to set window
++				 * X pixel size to be 32B aligned as well
++				 */
++				if (lconfig->xsize % 32) {
++					osd_write(((lconfig->xsize + 31) & ~31),
++						  OSD_VIDWIN1XL);
++					osd_write(((lconfig->xsize + 31) & ~31),
++						  OSD_VIDWIN0XL);
++				}
++			} else
++				osd_merge(OSD_MISCCTL_S420D, ~OSD_MISCCTL_S420D,
++					  OSD_MISCCTL);
++		}
++		if (lconfig->interlaced) {
++			osd_write(lconfig->ypos >> 1, OSD_VIDWIN0YP);
++			osd_write(lconfig->ysize >> 1, OSD_VIDWIN0YL);
++			if (cpu_is_davinci_dm365()
++			    && lconfig->pixfmt == PIXFMT_NV12) {
++				osd_write(lconfig->ypos >> 1, OSD_VIDWIN1YP);
++				osd_write(lconfig->ysize >> 1, OSD_VIDWIN1YL);
++			}
++		} else {
++			osd_write(lconfig->ypos, OSD_VIDWIN0YP);
++			osd_write(lconfig->ysize, OSD_VIDWIN0YL);
++			if (cpu_is_davinci_dm365()
++			    && lconfig->pixfmt == PIXFMT_NV12) {
++				osd_write(lconfig->ypos, OSD_VIDWIN1YP);
++				osd_write(lconfig->ysize, OSD_VIDWIN1YL);
++			}
++		}
++		break;
++	case WIN_OSD1:
++		/*
++		 * The caller must ensure that OSD1 is disabled prior to
++		 * switching from a normal mode to attribute mode or from
++		 * attribute mode to a normal mode.
++		 */
++		if (lconfig->pixfmt == PIXFMT_OSD_ATTR) {
++			if (cpu_is_davinci_dm644x()) {
++				winmd_mask |=
++				    OSD_OSDWIN1MD_ATN1E | OSD_OSDWIN1MD_RGB1E |
++				    OSD_OSDWIN1MD_CLUTS1 | OSD_OSDWIN1MD_BLND1 |
++				    OSD_OSDWIN1MD_TE1;
++			} else {
++				winmd_mask |=
++				    OSD_OSDWIN1MD_BMP1MD | OSD_OSDWIN1MD_CLUTS1
++				    | OSD_OSDWIN1MD_BLND1 | OSD_OSDWIN1MD_TE1;
++			}
++		} else {
++			if (cpu_is_davinci_dm644x()) {
++				winmd_mask |= OSD_OSDWIN1MD_RGB1E;
++				if (lconfig->pixfmt == PIXFMT_RGB565)
++					winmd |= OSD_OSDWIN1MD_RGB1E;
++			} else if (cpu_is_davinci_dm355()
++				   || cpu_is_davinci_dm365()) {
++				winmd_mask |= OSD_OSDWIN1MD_BMP1MD;
++				switch (lconfig->pixfmt) {
++				case PIXFMT_RGB565:
++					winmd |=
++					    (1 << OSD_OSDWIN1MD_BMP1MD_SHIFT);
++					break;
++				case PIXFMT_RGB888:
++					winmd |=
++					    (2 << OSD_OSDWIN1MD_BMP1MD_SHIFT);
++					_davinci_disp_enable_rgb888_pixblend
++					    (OSDWIN_OSD1);
++					break;
++				case PIXFMT_YCbCrI:
++				case PIXFMT_YCrCbI:
++					winmd |=
++					    (3 << OSD_OSDWIN1MD_BMP1MD_SHIFT);
++					break;
++				default:
++					break;
++				}
++			}
++
++			winmd_mask |= OSD_OSDWIN1MD_BMW1;
++			switch (lconfig->pixfmt) {
++			case PIXFMT_1BPP:
++				bmw = 0;
++				break;
++			case PIXFMT_2BPP:
++				bmw = 1;
++				break;
++			case PIXFMT_4BPP:
++				bmw = 2;
++				break;
++			case PIXFMT_8BPP:
++				bmw = 3;
++				break;
++			default:
++				break;
++			}
++			winmd |= (bmw << OSD_OSDWIN1MD_BMW1_SHIFT);
++		}
++
++		winmd_mask |= OSD_OSDWIN1MD_OFF1;
++		if (lconfig->interlaced)
++			winmd |= OSD_OSDWIN1MD_OFF1;
++
++		osd_merge(winmd_mask, winmd, OSD_OSDWIN1MD);
++		osd_write(lconfig->line_length >> 5, OSD_OSDWIN1OFST);
++		osd_write(lconfig->xpos, OSD_OSDWIN1XP);
++		osd_write(lconfig->xsize, OSD_OSDWIN1XL);
++		if (lconfig->interlaced) {
++			osd_write(lconfig->ypos >> 1, OSD_OSDWIN1YP);
++			osd_write(lconfig->ysize >> 1, OSD_OSDWIN1YL);
++		} else {
++			osd_write(lconfig->ypos, OSD_OSDWIN1YP);
++			osd_write(lconfig->ysize, OSD_OSDWIN1YL);
++		}
++		break;
++	case WIN_VID1:
++		winmd_mask |= OSD_VIDWINMD_VFF1;
++		if (lconfig->interlaced)
++			winmd |= OSD_VIDWINMD_VFF1;
++
++		osd_merge(winmd_mask, winmd, OSD_VIDWINMD);
++		osd_write(lconfig->line_length >> 5, OSD_VIDWIN1OFST);
++		osd_write(lconfig->xpos, OSD_VIDWIN1XP);
++		osd_write(lconfig->xsize, OSD_VIDWIN1XL);
++		/*
++		 * For YUV420P format the register contents are
++		 * duplicated in both VID registers
++		 */
++		if (cpu_is_davinci_dm365()) {
++			if (lconfig->pixfmt == PIXFMT_NV12) {
++				/* other window also */
++				if (lconfig->interlaced) {
++					winmd_mask |= OSD_VIDWINMD_VFF0;
++					winmd |= OSD_VIDWINMD_VFF0;
++					osd_merge(winmd_mask, winmd,
++						  OSD_VIDWINMD);
++				}
++				osd_merge(OSD_MISCCTL_S420D, OSD_MISCCTL_S420D,
++					  OSD_MISCCTL);
++				osd_write(lconfig->line_length >> 5,
++					  OSD_VIDWIN0OFST);
++				osd_write(lconfig->xpos, OSD_VIDWIN0XP);
++				osd_write(lconfig->xsize, OSD_VIDWIN0XL);
++		} else
++			osd_merge(OSD_MISCCTL_S420D, ~OSD_MISCCTL_S420D,
++				  OSD_MISCCTL);
++		}
++
++		if (lconfig->interlaced) {
++			osd_write(lconfig->ypos >> 1, OSD_VIDWIN1YP);
++			osd_write(lconfig->ysize >> 1, OSD_VIDWIN1YL);
++			if (cpu_is_davinci_dm365()
++			    && lconfig->pixfmt == PIXFMT_NV12) {
++				osd_write(lconfig->ypos >> 1, OSD_VIDWIN0YP);
++				osd_write(lconfig->ysize >> 1, OSD_VIDWIN0YL);
++			}
++		} else {
++			osd_write(lconfig->ypos, OSD_VIDWIN1YP);
++			osd_write(lconfig->ysize, OSD_VIDWIN1YL);
++			if (cpu_is_davinci_dm365()
++			    && lconfig->pixfmt == PIXFMT_NV12) {
++				osd_write(lconfig->ypos, OSD_VIDWIN0YP);
++				osd_write(lconfig->ysize, OSD_VIDWIN0YL);
++			}
++		}
++		break;
++	}
++}
++
++int davinci_disp_set_layer_config(enum davinci_disp_layer layer,
++				  struct davinci_layer_config *lconfig)
++{
++	struct davinci_window_state *win = &osd->win[layer];
++	int reject_config;
++	unsigned long flags;
++
++	spin_lock_irqsave(&osd->lock, flags);
++
++	reject_config = try_layer_config(layer, lconfig);
++	if (reject_config) {
++		spin_unlock_irqrestore(&osd->lock, flags);
++		return reject_config;
++	}
++
++	/* update the current Cb/Cr order */
++	if (is_yc_pixfmt(lconfig->pixfmt))
++		osd->yc_pixfmt = lconfig->pixfmt;
++
++	/*
++	 * If we are switching OSD1 from normal mode to attribute mode or from
++	 * attribute mode to normal mode, then we must disable the window.
++	 */
++	if (layer == WIN_OSD1) {
++		if (((lconfig->pixfmt == PIXFMT_OSD_ATTR)
++		     && (win->lconfig.pixfmt != PIXFMT_OSD_ATTR))
++		    || ((lconfig->pixfmt != PIXFMT_OSD_ATTR)
++			&& (win->lconfig.pixfmt == PIXFMT_OSD_ATTR))) {
++			win->is_enabled = 0;
++			_davinci_disp_disable_layer(layer);
++		}
++	}
++
++	_davinci_disp_set_layer_config(layer, lconfig);
++
++	if (layer == WIN_OSD1) {
++		struct davinci_osdwin_state *osdwin_state =
++		    &osd->osdwin[OSDWIN_OSD1];
++
++		if ((lconfig->pixfmt != PIXFMT_OSD_ATTR)
++		    && (win->lconfig.pixfmt == PIXFMT_OSD_ATTR)) {
++			/*
++			 * We just switched OSD1 from attribute mode to normal
++			 * mode, so we must initialize the CLUT select, the
++			 * blend factor, transparency colorkey enable, and
++			 * attenuation enable (DM6446 only) bits in the
++			 * OSDWIN1MD register.
++			 */
++			_davinci_disp_set_osd_clut(OSDWIN_OSD1,
++						   osdwin_state->clut);
++			_davinci_disp_set_blending_factor(OSDWIN_OSD1,
++							  osdwin_state->blend);
++			if (osdwin_state->colorkey_blending) {
++				_davinci_disp_enable_color_key(OSDWIN_OSD1,
++							       osdwin_state->
++							       colorkey,
++							       lconfig->pixfmt);
++			} else
++				_davinci_disp_disable_color_key(OSDWIN_OSD1);
++			_davinci_disp_set_rec601_attenuation(OSDWIN_OSD1,
++							     osdwin_state->
++							     rec601_attenuation);
++		} else if ((lconfig->pixfmt == PIXFMT_OSD_ATTR)
++			   && (win->lconfig.pixfmt != PIXFMT_OSD_ATTR)) {
++			/*
++			 * We just switched OSD1 from normal mode to attribute
++			 * mode, so we must initialize the blink enable and
++			 * blink interval bits in the OSDATRMD register.
++			 */
++			_davinci_disp_set_blink_attribute(osd->is_blinking,
++							  osd->blink);
++		}
++	}
++
++	/*
++	 * If we just switched to a 1-, 2-, or 4-bits-per-pixel bitmap format
++	 * then configure a default palette map.
++	 */
++	if ((lconfig->pixfmt != win->lconfig.pixfmt)
++	    && ((lconfig->pixfmt == PIXFMT_1BPP)
++		|| (lconfig->pixfmt == PIXFMT_2BPP)
++		|| (lconfig->pixfmt == PIXFMT_4BPP))) {
++		enum davinci_osd_layer osdwin =
++		    ((layer == WIN_OSD0) ? OSDWIN_OSD0 : OSDWIN_OSD1);
++		struct davinci_osdwin_state *osdwin_state =
++		    &osd->osdwin[osdwin];
++		unsigned char clut_index;
++		unsigned char clut_entries = 0;
++
++		switch (lconfig->pixfmt) {
++		case PIXFMT_1BPP:
++			clut_entries = 2;
++			break;
++		case PIXFMT_2BPP:
++			clut_entries = 4;
++			break;
++		case PIXFMT_4BPP:
++			clut_entries = 16;
++			break;
++		default:
++			break;
++		}
++		/*
++		 * The default palette map maps the pixel value to the clut
++		 * index, i.e. pixel value 0 maps to clut entry 0, pixel value 1
++		 * maps to clut entry 1, etc.
++		 */
++		for (clut_index = 0; clut_index < 16; clut_index++) {
++			osdwin_state->palette_map[clut_index] = clut_index;
++			if (clut_index < clut_entries) {
++				_davinci_disp_set_palette_map(osdwin,
++							      clut_index,
++							      clut_index,
++							      lconfig->pixfmt);
++			}
++		}
++	}
++
++	win->lconfig = *lconfig;
++	/* DM6446: configure the RGB888 enable and window selection */
++	if (osd->win[WIN_VID0].lconfig.pixfmt == PIXFMT_RGB888)
++		_davinci_disp_enable_vid_rgb888(WIN_VID0);
++	else if (osd->win[WIN_VID1].lconfig.pixfmt == PIXFMT_RGB888)
++		_davinci_disp_enable_vid_rgb888(WIN_VID1);
++	else
++		_davinci_disp_disable_vid_rgb888();
++
++	if (layer == WIN_VID0) {
++		osd->pingpong =
++		    _davinci_disp_dm6446_vid0_pingpong(osd->field_inversion,
++						       win->fb_base_phys,
++						       &win->lconfig);
++	}
++
++	spin_unlock_irqrestore(&osd->lock, flags);
++
++	return 0;
++}
++EXPORT_SYMBOL(davinci_disp_set_layer_config);
++
++void davinci_disp_init_layer(enum davinci_disp_layer layer)
++{
++	struct davinci_window_state *win = &osd->win[layer];
++	enum davinci_osd_layer osdwin;
++	struct davinci_osdwin_state *osdwin_state;
++	unsigned long flags;
++
++	spin_lock_irqsave(&osd->lock, flags);
++
++	win->is_enabled = 0;
++	_davinci_disp_disable_layer(layer);
++
++	win->h_zoom = ZOOM_X1;
++	win->v_zoom = ZOOM_X1;
++	_davinci_disp_set_zoom(layer, win->h_zoom, win->v_zoom);
++
++	win->fb_base_phys = 0;
++	_davinci_disp_start_layer(layer, win->fb_base_phys, 0);
++
++	win->lconfig.line_length = 0;
++	win->lconfig.xsize = 0;
++	win->lconfig.ysize = 0;
++	win->lconfig.xpos = 0;
++	win->lconfig.ypos = 0;
++	win->lconfig.interlaced = 0;
++	switch (layer) {
++	case WIN_OSD0:
++	case WIN_OSD1:
++		osdwin = (layer == WIN_OSD0) ? OSDWIN_OSD0 : OSDWIN_OSD1;
++		osdwin_state = &osd->osdwin[osdwin];
++		/*
++		 * Other code relies on the fact that OSD windows default to a
++		 * bitmap pixel format when they are deallocated, so don't
++		 * change this default pixel format.
++		 */
++		win->lconfig.pixfmt = PIXFMT_8BPP;
++		_davinci_disp_set_layer_config(layer, &win->lconfig);
++		osdwin_state->clut = RAM_CLUT;
++		_davinci_disp_set_osd_clut(osdwin, osdwin_state->clut);
++		osdwin_state->colorkey_blending = 0;
++		_davinci_disp_disable_color_key(osdwin);
++		osdwin_state->blend = OSD_8_VID_0;
++		_davinci_disp_set_blending_factor(osdwin, osdwin_state->blend);
++		osdwin_state->rec601_attenuation = 0;
++		_davinci_disp_set_rec601_attenuation(osdwin,
++						     osdwin_state->
++						     rec601_attenuation);
++		if (osdwin == OSDWIN_OSD1) {
++			osd->is_blinking = 0;
++			osd->blink = BLINK_X1;
++		}
++		break;
++	case WIN_VID0:
++	case WIN_VID1:
++		win->lconfig.pixfmt = osd->yc_pixfmt;
++		_davinci_disp_set_layer_config(layer, &win->lconfig);
++		break;
++	}
++
++	spin_unlock_irqrestore(&osd->lock, flags);
++}
++EXPORT_SYMBOL(davinci_disp_init_layer);
++
++void davinci_disp_release_layer(enum davinci_disp_layer layer)
++{
++	struct davinci_window_state *win = &osd->win[layer];
++	unsigned long flags;
++
++	spin_lock_irqsave(&osd->lock, flags);
++
++	if (!win->is_allocated) {
++		spin_unlock_irqrestore(&osd->lock, flags);
++		return;
++	}
++
++	spin_unlock_irqrestore(&osd->lock, flags);
++	davinci_disp_init_layer(layer);
++	spin_lock_irqsave(&osd->lock, flags);
++
++	win->is_allocated = 0;
++
++	spin_unlock_irqrestore(&osd->lock, flags);
++}
++EXPORT_SYMBOL(davinci_disp_release_layer);
++
++int davinci_disp_request_layer(enum davinci_disp_layer layer)
++{
++	struct davinci_window_state *win = &osd->win[layer];
++	unsigned long flags;
++
++	spin_lock_irqsave(&osd->lock, flags);
++
++	if (win->is_allocated) {
++		spin_unlock_irqrestore(&osd->lock, flags);
++		return -1;
++	}
++	win->is_allocated = 1;
++
++	spin_unlock_irqrestore(&osd->lock, flags);
++	return 0;
++}
++EXPORT_SYMBOL(davinci_disp_request_layer);
++
++static void _davinci_disp_init(void)
++{
++	osd_write(0, OSD_MODE);
++	osd_write(0, OSD_VIDWINMD);
++	osd_write(0, OSD_OSDWIN0MD);
++	osd_write(0, OSD_OSDWIN1MD);
++	osd_write(0, OSD_RECTCUR);
++	osd_write(0, OSD_MISCCTL);
++	if (cpu_is_davinci_dm355()) {
++		osd_write(0, OSD_VBNDRY);
++		osd_write(0, OSD_EXTMODE);
++		osd_write(OSD_MISCCTL_DMANG, OSD_MISCCTL);
++	}
++}
++
++static int davinci_osd_probe(struct platform_device *pdev)
++{
++	struct resource *res;
++
++	osd->dev = &pdev->dev;
++
++	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
++	if (!res) {
++		dev_err(osd->dev, "Unable to get VENC interrupt");
++		return -ENOENT;
++	}
++	osd->irq = res->start;
++
++	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
++	if (!res) {
++		dev_err(osd->dev, "Unable to get OSD register address map\n");
++		return -ENODEV;
++	}
++	osd->osd_base_phys = res->start;
++	osd->osd_size = res->end - res->start + 1;
++	if (!request_mem_region(osd->osd_base_phys, osd->osd_size,
++				MODULE_NAME)) {
++		dev_err(osd->dev, "Unable to reserve OSD MMIO region\n");
++		return -ENODEV;
++	}
++	osd->osd_base = (unsigned long)ioremap_nocache(res->start,
++							osd->osd_size);
++	if (!osd->osd_base) {
++		dev_err(osd->dev, "Unable to map the OSD region\n");
++		goto release_osd1;
++	}
++
++	if (request_irq(osd->irq, davinci_disp_isr, IRQF_SHARED, MODULE_NAME,
++			osd)) {
++		dev_err(osd->dev,"Unable to request interrupt\n");
++		goto release_osd2;
++	}
++
++	_davinci_disp_init();
++
++	/* set default Cb/Cr order */
++	osd->yc_pixfmt = PIXFMT_YCbCrI;
++
++	if (cpu_is_davinci_dm355()) {
++		/*
++		 * ROM CLUT1 on the DM355 is similar (identical?) to ROM CLUT0
++		 * on the DM6446, so make ROM_CLUT1 the default on the DM355.
++		 */
++		osd->rom_clut = ROM_CLUT1;
++	}
++	_davinci_disp_set_field_inversion(osd->field_inversion);
++	_davinci_disp_set_rom_clut(osd->rom_clut);
++
++	davinci_disp_init_layer(WIN_OSD0);
++	davinci_disp_init_layer(WIN_VID0);
++	davinci_disp_init_layer(WIN_OSD1);
++	davinci_disp_init_layer(WIN_VID1);
++
++	return 0;
++
++release_osd2:
++	iounmap((void *)osd->osd_base);
++release_osd1:
++	release_mem_region(osd->osd_base_phys, osd->osd_size);
++
++	return -ENODEV;
++}
++
++static int davinci_osd_remove(struct platform_device *pdev)
++{
++	free_irq(osd->irq, osd);
++	if (osd->osd_base)
++		iounmap((void *)osd->osd_base);
++	release_mem_region(osd->osd_base_phys, osd->osd_size);
++
++	return 0;
++}
++
++static struct platform_driver davinci_osd_driver = {
++	.probe		= davinci_osd_probe,
++	.remove		= davinci_osd_remove,
++	.driver		= {
++		.name	= MODULE_NAME,
++		.owner	= THIS_MODULE,
++	},
++};
++
++int davinci_osd_init(void)
++{
++	spin_lock_init(&osd->lock);
++
++	/* Register the driver */
++	if (platform_driver_register(&davinci_osd_driver)) {
++		printk(KERN_ERR "Unable to register davinci osd driver\n");
++		return -ENODEV;
++	}
++
++	return 0;
++}
++
++static void davinci_osd_exit(void)
++{
++	platform_driver_unregister(&davinci_osd_driver);
++}
++
++subsys_initcall(davinci_osd_init);
++module_exit(davinci_osd_exit);
++
++MODULE_LICENSE("GPL");
++MODULE_DESCRIPTION("DaVinci OSD Manager Driver");
++MODULE_AUTHOR("Texas Instruments");
+--- /dev/null
++++ b/drivers/char/dm355_def_para.h
+@@ -0,0 +1,36 @@
++/*
++ * Copyright (C) 2008 Texas Instruments Inc
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
++ */
++/* extern variables */
++#include <media/davinci/dm355_ipipe.h>
++extern struct prev_prefilter dm355_pf_defaults;
++extern struct prev_dfc dm355_dfc_defaults;
++extern struct prev_nf dm355_nf_defaults;
++extern struct prev_wb dm355_wb_defaults;
++extern struct prev_rgb2rgb dm355_rgb2rgb_defaults;
++extern struct prev_gamma dm355_gamma_defaults;
++extern struct prev_rgb2yuv dm355_rgb2yuv_defaults;
++extern struct prev_rgb2yuv dm355_rgb2yuv_defaults;
++extern struct prev_lum_adj dm355_lum_adj_defaults;
++extern struct prev_yuv422_conv dm355_yuv422_conv_defaults;
++extern struct prev_yee dm355_yee_defaults;
++extern struct prev_fcs dm355_fcs_defaults;
++extern struct prev_single_shot_config dm355_prev_ss_config_defs;
++extern struct prev_continuous_config dm355_prev_cont_config_defs;
++extern struct rsz_single_shot_config dm355_rsz_ss_config_defs;
++extern struct rsz_continuous_config dm355_rsz_cont_config_defs;
++extern struct ipipe_params dm355_ipipe_defs;
+--- /dev/null
++++ b/include/media/davinci/imp_previewer.h
+@@ -0,0 +1,91 @@
++/*
++ * Copyright (C) 2008 Texas Instruments Inc
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
++ */
++
++/************************************************************************
++ * Description
++ * -----------
++ * Previewer device is used for accessing the image tuning capabilities
++ * of the hardware. The hardware channel has many modules, each with a set
++ * of parameters. The channel operates in 2 modes :-
++ *   1. continuous mode. In this mode, the modules are chained in the data
++ *      path from ISIF/CCDC and does image tuning on the fly. No IO
++ *      allowed in this mode.
++ *   2. Single shot mode. In this mode, modules are configured to tune the
++ *      image stored in SDRAM. Only one IO instance allowed.
++ *
++ * device name : davinci_previewer
++ ************************************************************************/
++
++#ifndef _IMP_PREVIEWER_H
++#define _IMP_PREVIEWER_H
++
++#include <linux/ioctl.h>
++#include <media/davinci/imp_common.h>
++
++/* Operation modes of previewer and resizer */
++#define PREV_MODE_SINGLE_SHOT	IMP_MODE_SINGLE_SHOT
++#define PREV_MODE_CONTINUOUS	IMP_MODE_CONTINUOUS
++#define PREV_MODE_INVALID	IMP_MODE_INVALID
++
++#define PREV_BUF_IN		0	/* input buffer */
++#define PREV_BUF_OUT1		1	/* output buffer */
++#define PREV_BUF_OUT2		2	/* output buffer */
++
++/* ioctls definition for previewer operations */
++#define PREV_IOC_BASE		'P'
++#define PREV_REQBUF		_IOWR(PREV_IOC_BASE, 1, struct imp_reqbufs)
++#define PREV_QUERYBUF		_IOWR(PREV_IOC_BASE, 2, struct imp_buffer)
++#define PREV_S_PARAM		_IOWR(PREV_IOC_BASE, 3,\
++					struct prev_module_param)
++#define PREV_G_PARAM		_IOWR(PREV_IOC_BASE, 4,\
++					struct prev_module_param)
++#define PREV_PREVIEW		_IOWR(PREV_IOC_BASE, 5, struct imp_convert)
++#define PREV_ENUM_CAP		_IOWR(PREV_IOC_BASE, 6, struct prev_cap)
++#define PREV_S_CONFIG		_IOWR(PREV_IOC_BASE, 7,\
++					struct prev_channel_config)
++#define PREV_G_CONFIG		_IOWR(PREV_IOC_BASE, 8,\
++					struct prev_channel_config)
++#define PREV_S_OPER_MODE	_IOW(PREV_IOC_BASE, 9, unsigned long)
++#define PREV_G_OPER_MODE	_IOR(PREV_IOC_BASE, 10, unsigned long)
++#define PREV_S_CONTROL		_IOWR(PREV_IOC_BASE, 11, struct prev_control)
++#define PREV_G_CONTROL		_IOWR(PREV_IOC_BASE, 12, struct prev_control)
++#define PREV_S_DARK_FRAME	_IOW(PREV_IOC_BASE, 13, struct prev_dark_frame)
++/* only for debug purpose */
++#define PREV_DUMP_HW_CONFIG	_IOW(PREV_IOC_BASE, 14, unsigned long)
++#define PREV_IOC_MAXNR		14
++
++#ifdef __KERNEL__
++
++struct prev_device {
++	/* mutex lock for this device */
++	struct mutex lock;
++	/* number of users of this channel */
++	int users;
++	/* Channel structure. Either shared or independent */
++	struct imp_logical_channel *chan;
++};
++
++struct prev_fh {
++	/* This is primary uses configured the previewer channel */
++	char primary_user;
++	/* channel associated with this file handle */
++	struct imp_logical_channel *chan;
++};
++
++#endif
++#endif
+--- /dev/null
++++ b/drivers/char/dm365_def_para.h
+@@ -0,0 +1,23 @@
++#include <media/davinci/dm365_ipipe.h>
++extern struct prev_lutdpc dm365_lutdpc_defaults;
++extern struct prev_otfdpc dm365_otfdpc_defaults;
++extern struct prev_nf dm365_nf_defaults;
++extern struct prev_gic dm365_gic_defaults;
++extern struct prev_wb dm365_wb_defaults;
++extern struct prev_cfa dm365_cfa_defaults;
++extern struct prev_rgb2rgb dm365_rgb2rgb_defaults;
++extern struct prev_gamma dm365_gamma_defaults;
++extern struct prev_3d_lut dm365_3d_lut_defaults;
++extern struct prev_lum_adj dm365_lum_adj_defaults;
++extern struct prev_rgb2yuv dm365_rgb2yuv_defaults;
++extern struct prev_yuv422_conv dm365_yuv422_conv_defaults;
++extern struct prev_gbce dm365_gbce_defaults;
++extern struct prev_yee dm365_yee_defaults;
++extern struct prev_car dm365_car_defaults;
++extern struct prev_cgs dm365_cgs_defaults;
++extern struct ipipe_params dm365_ipipe_defs;
++extern struct prev_single_shot_config dm365_prev_ss_config_defs;
++extern struct prev_continuous_config dm365_prev_cont_config_defs;
++extern struct rsz_single_shot_config dm365_rsz_ss_config_defs;
++extern struct rsz_continuous_config dm365_rsz_cont_config_defs;
++extern struct ipipeif_5_1 ipipeif_5_1_defaults;
+--- a/drivers/char/Makefile
++++ b/drivers/char/Makefile
+@@ -9,6 +9,11 @@ FONTMAPFILE = cp437.uni
+ 
+ obj-y	 += mem.o random.o tty_io.o n_tty.o tty_ioctl.o tty_ldisc.o tty_buffer.o tty_port.o
+ 
++davinci_vdce_driver-objs := davinci_vdce_hw.o davinci_vdce.o
++obj-$(CONFIG_VDCE) += davinci_vdce_driver.o
++
++obj-$(CONFIG_CIR) += cir.o
++
+ obj-$(CONFIG_LEGACY_PTYS)	+= pty.o
+ obj-$(CONFIG_UNIX98_PTYS)	+= pty.o
+ obj-y				+= misc.o
+@@ -105,6 +110,8 @@ obj-$(CONFIG_AGP)		+= agp/
+ obj-$(CONFIG_PCMCIA)		+= pcmcia/
+ obj-$(CONFIG_IPMI_HANDLER)	+= ipmi/
+ 
++obj-$(CONFIG_DM646x_PCI_TARGET_DRV) += dm646x_pci_targetdrv.o
++
+ obj-$(CONFIG_HANGCHECK_TIMER)	+= hangcheck-timer.o
+ obj-$(CONFIG_TCG_TPM)		+= tpm/
+ 
+@@ -112,6 +119,22 @@ obj-$(CONFIG_PS3_FLASH)		+= ps3flash.o
+ 
+ obj-$(CONFIG_JS_RTC)		+= js-rtc.o
+ js-rtc-y = rtc.o
++obj-$(CONFIG_ARCH_DAVINCI_DM644x)	+= dm6446_imp.o
++
++dm355_imp-objs			:= dm355_ipipe.o dm355_def_para.o \
++					dm355_ipipe_hw.o
++obj-$(CONFIG_DM355_IPIPE)	+= dm355_imp.o
++
++dm365_imp-objs			:= dm365_ipipe.o dm365_def_para.o \
++					dm365_ipipe_hw.o dm3xx_ipipe.o
++obj-$(CONFIG_DM365_IPIPE)	+= dm365_imp.o
++
++imp_prev_driver-objs		:= imp_previewer.o
++imp_rsz_driver-objs		:= imp_resizer.o
++obj-$(CONFIG_DM355_IPIPE)	+= imp_common.o
++obj-$(CONFIG_DM365_IPIPE)	+= imp_common.o
++obj-$(CONFIG_IMP_PREVIEWER)	+= imp_prev_driver.o
++obj-$(CONFIG_IMP_RESIZER)	+= imp_rsz_driver.o
+ 
+ # Files generated that shall be removed upon make clean
+ clean-files := consolemap_deftbl.c defkeymap.c
+--- a/drivers/mmc/core/sdio_ops.h
++++ b/drivers/mmc/core/sdio_ops.h
+@@ -17,6 +17,7 @@ int mmc_io_rw_direct(struct mmc_card *ca
+ 	unsigned addr, u8 in, u8* out);
+ int mmc_io_rw_extended(struct mmc_card *card, int write, unsigned fn,
+ 	unsigned addr, int incr_addr, u8 *buf, unsigned blocks, unsigned blksz);
++int mmc_reset_sdio(struct mmc_host *host);
+ 
+ #endif
+ 
+--- a/drivers/media/video/ths7303.c
++++ b/drivers/media/video/ths7303.c
+@@ -23,10 +23,13 @@
+ #include <linux/uaccess.h>
+ #include <linux/videodev2.h>
+ 
++#include <media/davinci/videohd.h>
+ #include <media/v4l2-device.h>
+ #include <media/v4l2-subdev.h>
+ #include <media/v4l2-chip-ident.h>
+ 
++#include "ths7303.h"
++
+ MODULE_DESCRIPTION("TI THS7303 video amplifier driver");
+ MODULE_AUTHOR("Chaithrika U S");
+ MODULE_LICENSE("GPL");
+@@ -35,36 +38,136 @@ static int debug;
+ module_param(debug, int, 0644);
+ MODULE_PARM_DESC(debug, "Debug level 0-1");
+ 
++#define THS7353_CHANNEL_1       (1)
++#define THS7353_CHANNEL_2       (2)
++#define THS7353_CHANNEL_3       (3)
++
++static struct i2c_client *ths7303_client = NULL;
++
++/* following function is used to set ths7303 */
++int ths7303_setval(enum ths7303_filter_mode mode)
++{
++	u8 val = 0, input_bias_luma = 2, input_bias_chroma = 2, temp;
++	int err = 0, disable = 0;
++
++	if (ths7303_client == NULL)
++		return 0;
++
++	switch (mode) {
++	case THS7303_FILTER_MODE_1080P:
++		val = (3 << 6);
++		val |= (3 << 3);
++		break;
++	case THS7303_FILTER_MODE_720P_1080I:
++		val = (2 << 6);
++		val |= (2 << 3);
++		break;
++	case THS7303_FILTER_MODE_480P_576P:
++		val = (1 << 6);
++		val |= (1 << 3);
++		break;
++	case THS7303_FILTER_MODE_480I_576I:
++		break;
++	default:
++		/* disable all channels */
++		disable = 1;
++	}
++	/* Setup channel 2 - Luma - Green */
++	temp = val;
++	if (!disable)
++		val |= input_bias_luma;
++	err = i2c_smbus_write_byte_data(ths7303_client, THS7353_CHANNEL_2, val);
++	if (err)
++		goto out;
++
++	/* setup two chroma channels */
++	if (!disable)
++		temp |= input_bias_chroma;
++
++	err = i2c_smbus_write_byte_data(ths7303_client, THS7353_CHANNEL_1, temp);
++	if (err)
++		goto out;
++
++	err = i2c_smbus_write_byte_data(ths7303_client, THS7353_CHANNEL_3, temp);
++
++	if (err)
++		goto out;
++	return 0;
++
++out:
++	return err;
++}
++EXPORT_SYMBOL(ths7303_setval);
++
+ /* following function is used to set ths7303 */
+-static int ths7303_setvalue(struct v4l2_subdev *sd, v4l2_std_id std)
++static int ths7303_setvalue(struct v4l2_subdev *sd,
++			    enum ths7303_filter_mode mode)
+ {
+-	int err = 0;
+-	u8 val;
++	u8 val = 0, input_bias_luma = 2, input_bias_chroma = 2, temp;
+ 	struct i2c_client *client;
++	int err = 0, disable = 0;
+ 
+ 	client = v4l2_get_subdevdata(sd);
+ 
+-	if (std & (V4L2_STD_ALL & ~V4L2_STD_SECAM)) {
+-		val = 0x02;
+-		v4l2_dbg(1, debug, sd, "setting value for SDTV format\n");
+-	} else {
+-		val = 0x00;
+-		v4l2_dbg(1, debug, sd, "disabling all channels\n");
++	switch (mode) {
++	case THS7303_FILTER_MODE_1080P:
++		val = (3 << 6);
++		val |= (3 << 3);
++		break;
++	case THS7303_FILTER_MODE_720P_1080I:
++		val = (2 << 6);
++		val |= (2 << 3);
++		break;
++	case THS7303_FILTER_MODE_480P_576P:
++		val = (1 << 6);
++		val |= (1 << 3);
++		break;
++	case THS7303_FILTER_MODE_480I_576I:
++		break;
++	default:
++		/* disable all channels */
++		disable = 1;
+ 	}
++	/* Setup channel 2 - Luma - Green */
++	temp = val;
++	if (!disable)
++		val |= input_bias_luma;
++	err = i2c_smbus_write_byte_data(client, THS7353_CHANNEL_2, val);
++	if (err)
++		goto out;
++
++	/* setup two chroma channels */
++	if (!disable)
++		temp |= input_bias_chroma;
+ 
+-	err |= i2c_smbus_write_byte_data(client, 0x01, val);
+-	err |= i2c_smbus_write_byte_data(client, 0x02, val);
+-	err |= i2c_smbus_write_byte_data(client, 0x03, val);
++	err = i2c_smbus_write_byte_data(client, THS7353_CHANNEL_1, temp);
++	if (err)
++		goto out;
++
++	err = i2c_smbus_write_byte_data(client, THS7353_CHANNEL_3, temp);
+ 
+ 	if (err)
+-		v4l2_err(sd, "write failed\n");
++		goto out;
++	return 0;
+ 
++out:
++	v4l2_err(sd, "ths7303 write failed\n");
+ 	return err;
+ }
+ 
+ static int ths7303_s_std_output(struct v4l2_subdev *sd, v4l2_std_id norm)
+ {
+-	return ths7303_setvalue(sd, norm);
++	if (norm & (V4L2_STD_ALL & ~V4L2_STD_SECAM))
++		return ths7303_setvalue(sd, THS7303_FILTER_MODE_480I_576I);
++	else if (norm & (V4L2_STD_525P_60 | V4L2_STD_625P_50))
++		return ths7303_setvalue(sd, THS7303_FILTER_MODE_480P_576P);
++	else if (norm & (V4L2_STD_720P_60 | V4L2_STD_720P_50 |
++				V4L2_STD_1080I_60 | V4L2_STD_1080I_50))
++		return ths7303_setvalue(sd, THS7303_FILTER_MODE_720P_1080I);
++	else if (norm & (V4L2_STD_1080P_60 | V4L2_STD_1080P_50))
++		return ths7303_setvalue(sd, THS7303_FILTER_MODE_1080P);
++	else
++		return -EINVAL;
+ }
+ 
+ static int ths7303_g_chip_ident(struct v4l2_subdev *sd,
+@@ -106,7 +209,9 @@ static int ths7303_probe(struct i2c_clie
+ 
+ 	v4l2_i2c_subdev_init(sd, client, &ths7303_ops);
+ 
+-	return ths7303_setvalue(sd, std_id);
++	ths7303_client = client;
++
++	return ths7303_s_std_output(sd, std_id);
+ }
+ 
+ static int ths7303_remove(struct i2c_client *client)
+--- a/drivers/media/video/davinci/vpfe_capture.c
++++ b/drivers/media/video/davinci/vpfe_capture.c
+@@ -59,10 +59,8 @@
+  *    TODO list
+  *		- Support multiple REQBUF after open
+  *		- Support for de-allocating buffers through REQBUF
+- *		- Support for Raw Bayer RGB capture
+  *		- Support for chaining Image Processor
+  *		- Support for static allocation of buffers
+- *		- Support for USERPTR IO
+  *		- Support for STREAMON before QBUF
+  *		- Support for control ioctls
+  */
+@@ -71,21 +69,43 @@
+ #include <linux/platform_device.h>
+ #include <linux/interrupt.h>
+ #include <linux/version.h>
+-#include <media/v4l2-common.h>
+ #include <linux/io.h>
++
++#include <media/v4l2-common.h>
++#include <media/davinci/videohd.h>
+ #include <media/davinci/vpfe_capture.h>
++#include <media/davinci/imp_hw_if.h>
++
++#include <mach/cputype.h>
++
+ #include "ccdc_hw_device.h"
+ 
++#define PAL_IMAGE_SIZE		(720 * 576 * 2)
++#define SECOND_IMAGE_SIZE_MAX	(640 * 480 * 2)
++
+ static int debug;
+ static u32 numbuffers = 3;
+-static u32 bufsize = (720 * 576 * 2);
++static u32 bufsize = PAL_IMAGE_SIZE + SECOND_IMAGE_SIZE_MAX;
++static int interface;
+ 
++module_param(interface, bool, S_IRUGO);
+ module_param(numbuffers, uint, S_IRUGO);
+ module_param(bufsize, uint, S_IRUGO);
+-module_param(debug, int, 0644);
++module_param(debug, bool, 0644);
+ 
++/**
++ * VPFE capture can be used for capturing video such as from TVP5146 or TVP7002
++ * and for capture raw bayer data from camera sensors such as MT9T031. At this
++ * point there is problem in co-existence of mt9t031 and tvp5146 due to i2c
++ * address collision. So set the variable below from bootargs to do either video
++ * capture or camera capture.
++ * interface = 0 - video capture (from TVP514x or such),
++ * interface = 1 - Camera capture (from MT9T031 or such)
++ * Re-visit this when we fix the co-existence issue
++ */
++MODULE_PARM_DESC(interface, "interface 0-1 (default:0)");
+ MODULE_PARM_DESC(numbuffers, "buffer count (default:3)");
+-MODULE_PARM_DESC(bufsize, "buffer size in bytes (default:720 x 576 x 2)");
++MODULE_PARM_DESC(bufsize, "buffer size in bytes, (default:1443840 bytes)");
+ MODULE_PARM_DESC(debug, "Debug level 0-1");
+ 
+ MODULE_DESCRIPTION("VPFE Video for Linux Capture Driver");
+@@ -100,6 +120,7 @@ struct vpfe_standard {
+ 	struct v4l2_fract pixelaspect;
+ 	/* 0 - progressive, 1 - interlaced */
+ 	int frame_format;
++	struct v4l2_fract fps;
+ };
+ 
+ /* ccdc configuration */
+@@ -108,9 +129,6 @@ struct ccdc_config {
+ 	int vpfe_probed;
+ 	/* name of ccdc device */
+ 	char name[32];
+-	/* for storing mem maps for CCDC */
+-	int ccdc_addr_size;
+-	void *__iomem ccdc_addr;
+ };
+ 
+ /* data structures */
+@@ -128,9 +146,20 @@ static DEFINE_MUTEX(ccdc_lock);
+ /* ccdc configuration */
+ static struct ccdc_config *ccdc_cfg;
+ 
++/*  hardware interface for image processing pipeline */
++static struct imp_hw_interface *imp_hw_if;
++
+ const struct vpfe_standard vpfe_standards[] = {
+-	{V4L2_STD_525_60, 720, 480, {11, 10}, 1},
+-	{V4L2_STD_625_50, 720, 576, {54, 59}, 1},
++	{V4L2_STD_525_60, 720, 480, {11, 10}, 1, {1001, 30000} },
++	{V4L2_STD_625_50, 720, 576, {54, 59}, 1, {1, 25} },
++	{V4L2_STD_525P_60, 720, 480, {11, 10}, 0, {1001, 30000} },
++	{V4L2_STD_625P_50, 720, 576, {54, 59}, 0, {1, 25} },
++	{V4L2_STD_720P_50, 1280, 720, {1, 1}, 0, {1, 50} },
++	{V4L2_STD_720P_60, 1280, 720, {1, 1}, 0, {1, 60} },
++	{V4L2_STD_1080I_50, 1920, 1080, {1, 1}, 1, {1, 50} },
++	{V4L2_STD_1080I_60, 1920, 1080, {1, 1}, 1, {1, 60} },
++	{V4L2_STD_1080P_50, 1920, 1080, {1, 1}, 0, {1, 50} },
++	{V4L2_STD_1080P_60, 1920, 1080, {1, 1}, 0, {1, 60} },
+ };
+ 
+ /* Used when raw Bayer image from ccdc is directly captured to SDRAM */
+@@ -143,6 +172,7 @@ static const struct vpfe_pixel_format vp
+ 			.pixelformat = V4L2_PIX_FMT_SBGGR8,
+ 		},
+ 		.bpp = 1,
++		.subdev_pix_fmt = V4L2_PIX_FMT_SGRBG10,
+ 	},
+ 	{
+ 		.fmtdesc = {
+@@ -152,6 +182,7 @@ static const struct vpfe_pixel_format vp
+ 			.pixelformat = V4L2_PIX_FMT_SBGGR16,
+ 		},
+ 		.bpp = 2,
++		.subdev_pix_fmt = V4L2_PIX_FMT_SGRBG10,
+ 	},
+ 	{
+ 		.fmtdesc = {
+@@ -161,6 +192,7 @@ static const struct vpfe_pixel_format vp
+ 			.pixelformat = V4L2_PIX_FMT_SGRBG10DPCM8,
+ 		},
+ 		.bpp = 1,
++		.subdev_pix_fmt = V4L2_PIX_FMT_SGRBG10,
+ 	},
+ 	{
+ 		.fmtdesc = {
+@@ -170,6 +202,7 @@ static const struct vpfe_pixel_format vp
+ 			.pixelformat = V4L2_PIX_FMT_UYVY,
+ 		},
+ 		.bpp = 2,
++		.subdev_pix_fmt = V4L2_PIX_FMT_UYVY,
+ 	},
+ 	{
+ 		.fmtdesc = {
+@@ -179,6 +212,7 @@ static const struct vpfe_pixel_format vp
+ 			.pixelformat = V4L2_PIX_FMT_YUYV,
+ 		},
+ 		.bpp = 2,
++		.subdev_pix_fmt = V4L2_PIX_FMT_UYVY,
+ 	},
+ 	{
+ 		.fmtdesc = {
+@@ -188,12 +222,15 @@ static const struct vpfe_pixel_format vp
+ 			.pixelformat = V4L2_PIX_FMT_NV12,
+ 		},
+ 		.bpp = 1,
++		.subdev_pix_fmt = V4L2_PIX_FMT_UYVY,
+ 	},
+ };
+ 
+-/*
+- * vpfe_lookup_pix_format()
+- * lookup an entry in the vpfe pix format table based on pix_format
++/**
++ * vpfe_lookup_pix_format() - lookup an entry in the vpfe pix format table
++ * @pix_format: v4l pix format
++ * This function lookup an entry in the vpfe pix format table based on
++ * pix_format
+  */
+ static const struct vpfe_pixel_format *vpfe_lookup_pix_format(u32 pix_format)
+ {
+@@ -230,7 +267,6 @@ int vpfe_register_ccdc_device(struct ccd
+ 	BUG_ON(!dev->hw_ops.set_image_window);
+ 	BUG_ON(!dev->hw_ops.get_image_window);
+ 	BUG_ON(!dev->hw_ops.get_line_length);
+-	BUG_ON(!dev->hw_ops.setfbaddr);
+ 	BUG_ON(!dev->hw_ops.getfid);
+ 
+ 	mutex_lock(&ccdc_lock);
+@@ -241,25 +277,23 @@ int vpfe_register_ccdc_device(struct ccd
+ 		 * walk through it during vpfe probe
+ 		 */
+ 		printk(KERN_ERR "vpfe capture not initialized\n");
+-		ret = -1;
++		ret = -EFAULT;
+ 		goto unlock;
+ 	}
+ 
+ 	if (strcmp(dev->name, ccdc_cfg->name)) {
+ 		/* ignore this ccdc */
+-		ret = -1;
++		ret = -EINVAL;
+ 		goto unlock;
+ 	}
+ 
+ 	if (ccdc_dev) {
+ 		printk(KERN_ERR "ccdc already registered\n");
+-		ret = -1;
++		ret = -EINVAL;
+ 		goto unlock;
+ 	}
+ 
+ 	ccdc_dev = dev;
+-	dev->hw_ops.set_ccdc_base(ccdc_cfg->ccdc_addr,
+-				  ccdc_cfg->ccdc_addr_size);
+ unlock:
+ 	mutex_unlock(&ccdc_lock);
+ 	return ret;
+@@ -293,6 +327,45 @@ void vpfe_unregister_ccdc_device(struct
+ EXPORT_SYMBOL(vpfe_unregister_ccdc_device);
+ 
+ /*
++ * vpfe_get_camera_frame_params()
++ * Get the image parameters such as max height and width, frame format
++ * etc and update the stdinfo accordingly. This is a work around to get
++ * the maximum width, height and frame format since camera driver doesn't
++ * support s_std.
++ */
++static int vpfe_get_camera_frame_params(struct vpfe_device *vpfe_dev)
++{
++	struct vpfe_subdev_info *sdinfo = vpfe_dev->current_subdev;
++	struct v4l2_format sd_fmt;
++	int ret;
++
++	/* TODO: Currently there is no support for setting timings
++	 * in sensor similar to S_STD. So get the limits of width and height
++	 * using try format. In future we should be able to set
++	 * timings for a specific resolution and fps. In that case
++	 * we know the limits for the specific timing and this code
++	 * would require change.
++	 */
++	memset(&sd_fmt, 0, sizeof(sd_fmt));
++	sd_fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
++	/* hard code it to match that of mt9t031 sensor */
++	sd_fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_SGRBG10;
++	/* use a value big enough */
++	sd_fmt.fmt.pix.width = 1 << 31;
++	sd_fmt.fmt.pix.height = 1 << 31;
++	ret = v4l2_device_call_until_err(&vpfe_dev->v4l2_dev,
++			sdinfo->grp_id, video, try_fmt, &sd_fmt);
++
++	if (!ret) {
++		vpfe_dev->std_info.active_pixels = sd_fmt.fmt.pix.width;
++		vpfe_dev->std_info.active_lines = sd_fmt.fmt.pix.height;
++		/* hard code the frame format to be progressive always.  */
++		vpfe_dev->std_info.frame_format = 0;
++	}
++	return ret;
++}
++
++/*
+  * vpfe_get_ccdc_image_format - Get image parameters based on CCDC settings
+  */
+ static int vpfe_get_ccdc_image_format(struct vpfe_device *vpfe_dev,
+@@ -302,9 +375,13 @@ static int vpfe_get_ccdc_image_format(st
+ 	enum ccdc_buftype buf_type;
+ 	enum ccdc_frmfmt frm_fmt;
+ 
++	vpfe_dev->crop.top = 0;
++	vpfe_dev->crop.left = 0;
+ 	memset(f, 0, sizeof(*f));
+ 	f->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+ 	ccdc_dev->hw_ops.get_image_window(&image_win);
++	vpfe_dev->crop.width = image_win.width;
++	vpfe_dev->crop.height = image_win.height;
+ 	f->fmt.pix.width = image_win.width;
+ 	f->fmt.pix.height = image_win.height;
+ 	f->fmt.pix.bytesperline = ccdc_dev->hw_ops.get_line_length();
+@@ -338,10 +415,20 @@ static int vpfe_get_ccdc_image_format(st
+ static int vpfe_config_ccdc_image_format(struct vpfe_device *vpfe_dev)
+ {
+ 	enum ccdc_frmfmt frm_fmt = CCDC_FRMFMT_INTERLACED;
++	u32 pix_fmt;
+ 	int ret = 0;
+ 
+-	if (ccdc_dev->hw_ops.set_pixel_format(
+-			vpfe_dev->fmt.fmt.pix.pixelformat) < 0) {
++	pix_fmt = vpfe_dev->fmt.fmt.pix.pixelformat;
++
++	/* At CCDC we need to set pix format based on source. */
++	if (vpfe_dev->imp_chained) {
++		if (vpfe_dev->current_subdev->is_camera)
++			pix_fmt = V4L2_PIX_FMT_SBGGR16;
++		else if (pix_fmt == V4L2_PIX_FMT_NV12)
++			pix_fmt = V4L2_PIX_FMT_UYVY;
++	}
++
++	if (ccdc_dev->hw_ops.set_pixel_format(pix_fmt) < 0) {
+ 		v4l2_err(&vpfe_dev->v4l2_dev,
+ 			"couldn't set pix format in ccdc\n");
+ 		return -EINVAL;
+@@ -380,14 +467,16 @@ static int vpfe_config_ccdc_image_format
+  * It then checks if sub device support g_fmt and then override the
+  * values based on that.Sets crop values to match with scan resolution
+  * starting at 0,0. It calls vpfe_config_ccdc_image_format() set the
+- * values in ccdc
++ * values in ccdc. Not called when sensor is the input source
+  */
+ static int vpfe_config_image_format(struct vpfe_device *vpfe_dev,
+ 				    const v4l2_std_id *std_id)
+ {
+ 	struct vpfe_subdev_info *sdinfo = vpfe_dev->current_subdev;
++	struct v4l2_format sd_fmt;
+ 	int i, ret = 0;
+ 
++	/* configure the ccdc based on standard */
+ 	for (i = 0; i < ARRAY_SIZE(vpfe_standards); i++) {
+ 		if (vpfe_standards[i].std_id & *std_id) {
+ 			vpfe_dev->std_info.active_pixels =
+@@ -396,6 +485,7 @@ static int vpfe_config_image_format(stru
+ 					vpfe_standards[i].height;
+ 			vpfe_dev->std_info.frame_format =
+ 					vpfe_standards[i].frame_format;
++			vpfe_dev->std_info.fps = vpfe_standards[i].fps;
+ 			vpfe_dev->std_index = i;
+ 			break;
+ 		}
+@@ -420,20 +510,20 @@ static int vpfe_config_image_format(stru
+ 		vpfe_dev->fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_UYVY;
+ 	} else {
+ 		vpfe_dev->fmt.fmt.pix.field = V4L2_FIELD_NONE;
+-		/* assume V4L2_PIX_FMT_SBGGR8 */
+-		vpfe_dev->fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_SBGGR8;
++		vpfe_dev->fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_UYVY;
+ 	}
+ 
++	sd_fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+ 	/* if sub device supports g_fmt, override the defaults */
+ 	ret = v4l2_device_call_until_err(&vpfe_dev->v4l2_dev,
+-			sdinfo->grp_id, video, g_fmt, &vpfe_dev->fmt);
++			sdinfo->grp_id, video, g_fmt, &sd_fmt);
+ 
+ 	if (ret && ret != -ENOIOCTLCMD) {
+ 		v4l2_err(&vpfe_dev->v4l2_dev,
+ 			"error in getting g_fmt from sub device\n");
+ 		return ret;
+ 	}
+-
++	vpfe_dev->fmt = sd_fmt;
+ 	/* Sets the values in CCDC */
+ 	ret = vpfe_config_ccdc_image_format(vpfe_dev);
+ 	if (ret)
+@@ -450,40 +540,129 @@ static int vpfe_config_image_format(stru
+ 	return ret;
+ }
+ 
++/**
++ * vpfe_set_format_in_sensor() - Set frame format in the sensor
++ * @vpfe_dev - vpfe device object
++ *
++ * Set the given frame format in the sensor. Assume the sensor
++ * supports V4L2_PIX_FMT_SGRBG10
++ */
++static int vpfe_set_format_in_sensor(struct vpfe_device *vpfe_dev,
++				     struct v4l2_format *fmt)
++{
++	struct vpfe_subdev_info *sdinfo = vpfe_dev->current_subdev;
++	struct v4l2_format sd_fmt;
++	int ret;
++
++	memset(&sd_fmt, 0, sizeof(sd_fmt));
++	sd_fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
++	sd_fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_SGRBG10;
++	sd_fmt.fmt.pix.width = fmt->fmt.pix.width;
++	sd_fmt.fmt.pix.height = fmt->fmt.pix.height;
++	ret = v4l2_device_call_until_err(&vpfe_dev->v4l2_dev,
++			sdinfo->grp_id, video, s_fmt, &sd_fmt);
++	return ret;
++}
++
+ static int vpfe_initialize_device(struct vpfe_device *vpfe_dev)
+ {
+ 	int ret = 0;
+ 
+ 	/* set first input of current subdevice as the current input */
+ 	vpfe_dev->current_input = 0;
++	/*
++	 * set default standard. For camera device, we cannot set standard.
++	 * So we set it to -1. Otherwise, first entry in the standard is the
++	 * is the default
++	 */
++	if (vpfe_dev->current_subdev->is_camera) {
++		vpfe_dev->std_index = -1;
++		/*
++		 * Configure the vpfe default format information based on ccdc
++		 * defaults
++		 */
++		ret = vpfe_get_ccdc_image_format(vpfe_dev, &vpfe_dev->fmt);
++		/* also set the current default format in the sensor */
++		if (ret)
++			goto out;
++
++		ret = vpfe_set_format_in_sensor(vpfe_dev, &vpfe_dev->fmt);
++		/* Get max width and height available for capture from camera */
++		if (ret)
++			goto out;
++
++		/**
++		 * Get the frame information from camera sensor such as maximum
++		 * width and height, frame format etc
++		 */
++		ret = vpfe_get_camera_frame_params(vpfe_dev);
+ 
+-	/* set default standard */
+-	vpfe_dev->std_index = 0;
+-
+-	/* Configure the default format information */
+-	ret = vpfe_config_image_format(vpfe_dev,
++	} else {
++		vpfe_dev->std_index = 0;
++		/* Configure the default format information */
++		ret = vpfe_config_image_format(vpfe_dev,
+ 				&vpfe_standards[vpfe_dev->std_index].std_id);
++	}
++
+ 	if (ret)
+-		return ret;
++		goto out;
+ 
+ 	/* now open the ccdc device to initialize it */
+ 	mutex_lock(&ccdc_lock);
+ 	if (NULL == ccdc_dev) {
+ 		v4l2_err(&vpfe_dev->v4l2_dev, "ccdc device not registered\n");
+ 		ret = -ENODEV;
+-		goto unlock;
++		goto unlock_out;
+ 	}
+ 
+ 	if (!try_module_get(ccdc_dev->owner)) {
+ 		v4l2_err(&vpfe_dev->v4l2_dev, "Couldn't lock ccdc module\n");
+ 		ret = -ENODEV;
+-		goto unlock;
++		goto unlock_out;
+ 	}
++
++	vpfe_dev->imp_chained = 0;
++	vpfe_dev->second_output = 0;
++	vpfe_dev->second_out_img_sz = 0;
++	vpfe_dev->rsz_present = 0;
++	vpfe_dev->out_from = VPFE_CCDC_OUT;
++	vpfe_dev->skip_frame_count = 1;
++	vpfe_dev->skip_frame_count_init = 1;
++
++	/* TODO - revisit for MC */
++	if (!(ISNULL(imp_hw_if)) &&
++		(imp_hw_if->get_preview_oper_mode() == IMP_MODE_CONTINUOUS)) {
++		if (imp_hw_if->get_previewer_config_state()
++			== STATE_CONFIGURED) {
++			v4l2_info(&vpfe_dev->v4l2_dev, "IPIPE Chained\n");
++			vpfe_dev->imp_chained = 1;
++			vpfe_dev->out_from = VPFE_IMP_PREV_OUT;
++			if (imp_hw_if->get_resizer_config_state()
++				== STATE_CONFIGURED) {
++				v4l2_info(&vpfe_dev->v4l2_dev,
++					 "Resizer present\n");
++				vpfe_dev->rsz_present = 1;
++				vpfe_dev->out_from = VPFE_IMP_RSZ_OUT;
++				if (imp_hw_if->get_output_state(1)) {
++					v4l2_info(&vpfe_dev->v4l2_dev,
++						  "second output present\n");
++					vpfe_dev->second_output = 1;
++					vpfe_dev->second_out_img_sz =
++						imp_hw_if->
++						get_line_length(1) *
++						imp_hw_if->
++						get_image_height(1);
++				}
++			}
++		}
++	}
++
+ 	ret = ccdc_dev->hw_ops.open(vpfe_dev->pdev);
+ 	if (!ret)
+ 		vpfe_dev->initialized = 1;
+-unlock:
++unlock_out:
+ 	mutex_unlock(&ccdc_lock);
++out:
+ 	return ret;
+ }
+ 
+@@ -541,6 +720,22 @@ static void vpfe_schedule_next_buffer(st
+ 	list_del(&vpfe_dev->next_frm->queue);
+ 	vpfe_dev->next_frm->state = VIDEOBUF_ACTIVE;
+ 	addr = videobuf_to_dma_contig(vpfe_dev->next_frm);
++	if (vpfe_dev->out_from == VPFE_CCDC_OUT)
++		ccdc_dev->hw_ops.setfbaddr(addr);
++	else {
++		imp_hw_if->update_outbuf1_address(NULL, addr);
++		if (vpfe_dev->second_output)
++			imp_hw_if->update_outbuf2_address(NULL,
++					addr + vpfe_dev->second_off);
++	}
++}
++
++static void vpfe_schedule_bottom_field(struct vpfe_device *vpfe_dev)
++{
++	unsigned long addr;
++
++	addr = videobuf_to_dma_contig(vpfe_dev->cur_frm);
++	addr += vpfe_dev->field_off;
+ 	ccdc_dev->hw_ops.setfbaddr(addr);
+ }
+ 
+@@ -561,10 +756,8 @@ static irqreturn_t vpfe_isr(int irq, voi
+ {
+ 	struct vpfe_device *vpfe_dev = dev_id;
+ 	enum v4l2_field field;
+-	unsigned long addr;
+ 	int fid;
+ 
+-	v4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "\nStarting vpfe_isr...\n");
+ 	field = vpfe_dev->fmt.fmt.pix.field;
+ 
+ 	/* if streaming not started, don't do anything */
+@@ -577,10 +770,21 @@ static irqreturn_t vpfe_isr(int irq, voi
+ 
+ 	if (field == V4L2_FIELD_NONE) {
+ 		/* handle progressive frame capture */
+-		v4l2_dbg(1, debug, &vpfe_dev->v4l2_dev,
+-			"frame format is progressive...\n");
+ 		if (vpfe_dev->cur_frm != vpfe_dev->next_frm)
+ 			vpfe_process_buffer_complete(vpfe_dev);
++
++		if (vpfe_dev->imp_chained) {
++			vpfe_dev->skip_frame_count--;
++			if (!vpfe_dev->skip_frame_count) {
++				vpfe_dev->skip_frame_count =
++					vpfe_dev->skip_frame_count_init;
++				if (imp_hw_if->enable_resize)
++					imp_hw_if->enable_resize(1);
++			} else {
++				if (imp_hw_if->enable_resize)
++					imp_hw_if->enable_resize(0);
++			}
++		}
+ 		return IRQ_HANDLED;
+ 	}
+ 
+@@ -589,8 +793,6 @@ static irqreturn_t vpfe_isr(int irq, voi
+ 
+ 	/* switch the software maintained field id */
+ 	vpfe_dev->field_id ^= 1;
+-	v4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "field id = %x:%x.\n",
+-		fid, vpfe_dev->field_id);
+ 	if (fid == vpfe_dev->field_id) {
+ 		/* we are in-sync here,continue */
+ 		if (fid == 0) {
+@@ -605,12 +807,10 @@ static irqreturn_t vpfe_isr(int irq, voi
+ 			 * interleavely or separately in memory, reconfigure
+ 			 * the CCDC memory address
+ 			 */
+-			if (field == V4L2_FIELD_SEQ_TB) {
+-				addr =
+-				  videobuf_to_dma_contig(vpfe_dev->cur_frm);
+-				addr += vpfe_dev->field_off;
+-				ccdc_dev->hw_ops.setfbaddr(addr);
+-			}
++			if ((vpfe_dev->out_from == VPFE_CCDC_OUT) &&
++			    (field == V4L2_FIELD_SEQ_TB))
++				vpfe_schedule_bottom_field(vpfe_dev);
++
+ 			return IRQ_HANDLED;
+ 		}
+ 		/*
+@@ -620,7 +820,8 @@ static irqreturn_t vpfe_isr(int irq, voi
+ 		 * current buffer
+ 		 */
+ 		spin_lock(&vpfe_dev->dma_queue_lock);
+-		if (!list_empty(&vpfe_dev->dma_queue) &&
++		if ((vpfe_dev->out_from == VPFE_CCDC_OUT) &&
++		    !list_empty(&vpfe_dev->dma_queue) &&
+ 		    vpfe_dev->cur_frm == vpfe_dev->next_frm)
+ 			vpfe_schedule_next_buffer(vpfe_dev);
+ 		spin_unlock(&vpfe_dev->dma_queue_lock);
+@@ -634,13 +835,11 @@ static irqreturn_t vpfe_isr(int irq, voi
+ 	return IRQ_HANDLED;
+ }
+ 
+-/* vdint1_isr - isr handler for VINT1 interrupt */
+-static irqreturn_t vdint1_isr(int irq, void *dev_id)
++/* vpfe_vdint1_isr - isr handler for VINT1 interrupt */
++static irqreturn_t vpfe_vdint1_isr(int irq, void *dev_id)
+ {
+ 	struct vpfe_device *vpfe_dev = dev_id;
+ 
+-	v4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "\nInside vdint1_isr...\n");
+-
+ 	/* if streaming not started, don't do anything */
+ 	if (!vpfe_dev->started)
+ 		return IRQ_HANDLED;
+@@ -654,35 +853,114 @@ static irqreturn_t vdint1_isr(int irq, v
+ 	return IRQ_HANDLED;
+ }
+ 
++static irqreturn_t vpfe_imp_dma_isr(int irq, void *dev_id)
++{
++	struct vpfe_device *vpfe_dev = dev_id;
++	int fid, schedule_capture = 0;
++	enum v4l2_field field;
++
++	v4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "\nvpfe_imp_dma_isr\n");
++
++	/* if streaming not started, don't do anything */
++	if (!vpfe_dev->started)
++		return IRQ_HANDLED;
++
++	field = vpfe_dev->fmt.fmt.pix.field;
++
++	if (field == V4L2_FIELD_NONE) {
++		if (!list_empty(&vpfe_dev->dma_queue) &&
++			vpfe_dev->cur_frm == vpfe_dev->next_frm)
++			schedule_capture = 1;
++	} else {
++		fid = ccdc_dev->hw_ops.getfid();
++
++		if (fid == vpfe_dev->field_id) {
++			/* we are in-sync here,continue */
++			if (fid == 1 && !list_empty(&vpfe_dev->dma_queue) &&
++			    vpfe_dev->cur_frm == vpfe_dev->next_frm)
++				schedule_capture = 1;
++		}
++	}
++	if (schedule_capture) {
++		spin_lock(&vpfe_dev->dma_queue_lock);
++		vpfe_schedule_next_buffer(vpfe_dev);
++		spin_unlock(&vpfe_dev->dma_queue_lock);
++	}
++	return IRQ_HANDLED;
++}
++
+ static void vpfe_detach_irq(struct vpfe_device *vpfe_dev)
+ {
+ 	enum ccdc_frmfmt frame_format;
+ 
+-	frame_format = ccdc_dev->hw_ops.get_frame_format();
+-	if (frame_format == CCDC_FRMFMT_PROGRESSIVE)
+-		free_irq(IRQ_VDINT1, vpfe_dev);
++	free_irq(vpfe_dev->ccdc_irq0, vpfe_dev);
++	if (vpfe_dev->out_from == VPFE_CCDC_OUT) {
++		frame_format = ccdc_dev->hw_ops.get_frame_format();
++		if (frame_format == CCDC_FRMFMT_PROGRESSIVE)
++			free_irq(vpfe_dev->ccdc_irq1, vpfe_dev);
++	} else
++		free_irq(vpfe_dev->imp_dma_irq, vpfe_dev);
+ }
+ 
+ static int vpfe_attach_irq(struct vpfe_device *vpfe_dev)
+ {
+ 	enum ccdc_frmfmt frame_format;
++	int ret;
++
++	ret = request_irq(vpfe_dev->ccdc_irq0, vpfe_isr, IRQF_DISABLED,
++			  "vpfe_capture0", vpfe_dev);
++	if (ret < 0) {
++		v4l2_err(&vpfe_dev->v4l2_dev,
++			"Error: requesting VINT0 interrupt\n");
++		return ret;
++	}
+ 
+-	frame_format = ccdc_dev->hw_ops.get_frame_format();
+-	if (frame_format == CCDC_FRMFMT_PROGRESSIVE) {
+-		return request_irq(vpfe_dev->ccdc_irq1, vdint1_isr,
+-				    IRQF_DISABLED, "vpfe_capture1",
+-				    vpfe_dev);
++	if (vpfe_dev->out_from == VPFE_CCDC_OUT) {
++		frame_format = ccdc_dev->hw_ops.get_frame_format();
++		if (frame_format == CCDC_FRMFMT_PROGRESSIVE) {
++			ret = request_irq(vpfe_dev->ccdc_irq1,
++						   vpfe_vdint1_isr,
++						   IRQF_DISABLED,
++						   "vpfe_capture1", vpfe_dev);
++			if (ret < 0) {
++				v4l2_err(&vpfe_dev->v4l2_dev,
++					"Error: requesting VINT1 interrupt\n");
++				free_irq(vpfe_dev->ccdc_irq0, vpfe_dev);
++			}
++		}
++	} else {
++		/* output from Previewer/Resizer */
++		struct irq_numbers irq_info;
++		if (vpfe_dev->rsz_present)
++			imp_hw_if->get_rsz_irq(&irq_info);
++		else
++			imp_hw_if->get_preview_irq(&irq_info);
++
++		vpfe_dev->imp_dma_irq = irq_info.sdram;
++		ret = request_irq(irq_info.sdram,
++				  vpfe_imp_dma_isr,
++				  IRQF_DISABLED,
++				  "Imp_Sdram_Irq",
++				  vpfe_dev);
++		if (ret < 0) {
++			v4l2_err(&vpfe_dev->v4l2_dev,
++				 "Error: requesting IMP"
++				 " IRQ interrupt\n");
++			free_irq(vpfe_dev->ccdc_irq0, vpfe_dev);
++		}
+ 	}
+ 	return 0;
+ }
+ 
+-/* vpfe_stop_ccdc_capture: stop streaming in ccdc/isif */
+-static void vpfe_stop_ccdc_capture(struct vpfe_device *vpfe_dev)
++/* vpfe_stop_capture: stop streaming in ccdc/isif */
++static void vpfe_stop_capture(struct vpfe_device *vpfe_dev)
+ {
+ 	vpfe_dev->started = 0;
+ 	ccdc_dev->hw_ops.enable(0);
+ 	if (ccdc_dev->hw_ops.enable_out_to_sdram)
+ 		ccdc_dev->hw_ops.enable_out_to_sdram(0);
++	if (vpfe_dev->imp_chained)
++		imp_hw_if->enable(0, NULL);
+ }
+ 
+ /*
+@@ -709,15 +987,21 @@ static int vpfe_release(struct file *fil
+ 							 video, s_stream, 0);
+ 			if (ret && (ret != -ENOIOCTLCMD))
+ 				v4l2_err(&vpfe_dev->v4l2_dev,
+-				"stream off failed in subdev\n");
+-			vpfe_stop_ccdc_capture(vpfe_dev);
++					 "stream off failed in subdev\n");
++			vpfe_stop_capture(vpfe_dev);
+ 			vpfe_detach_irq(vpfe_dev);
+ 			videobuf_streamoff(&vpfe_dev->buffer_queue);
+ 		}
+ 		vpfe_dev->io_usrs = 0;
+ 		vpfe_dev->numbuffers = config_params.numbuffers;
++
++		if (vpfe_dev->imp_chained) {
++			imp_hw_if->enable(0, NULL);
++			imp_hw_if->unlock_chain();
++		}
+ 	}
+ 
++
+ 	/* Decrement device usrs counter */
+ 	vpfe_dev->usrs--;
+ 	/* Close the priority */
+@@ -765,17 +1049,88 @@ static unsigned int vpfe_poll(struct fil
+ 	return 0;
+ }
+ 
++static long vpfe_param_handler(struct file *file, void *priv,
++		int cmd, void *param)
++{
++	struct vpfe_device *vpfe_dev = video_drvdata(file);
++	int ret = 0;
++
++	v4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_param_handler\n");
++
++	if (NULL == param) {
++		v4l2_dbg(1, debug, &vpfe_dev->v4l2_dev,
++			"Invalid user ptr\n");
++	}
++
++	if (vpfe_dev->started) {
++		/* only allowed if streaming is not started */
++		v4l2_err(&vpfe_dev->v4l2_dev, "device already started\n");
++		return -EBUSY;
++	}
++
++
++	switch (cmd) {
++	case VPFE_CMD_S_CCDC_RAW_PARAMS:
++		v4l2_warn(&vpfe_dev->v4l2_dev,
++			  "VPFE_CMD_S_CCDC_RAW_PARAMS: experimental ioctl\n");
++		ret = mutex_lock_interruptible(&vpfe_dev->lock);
++		if (ret)
++			return ret;
++		ret = ccdc_dev->hw_ops.set_params(param);
++		if (ret) {
++			v4l2_dbg(1, debug, &vpfe_dev->v4l2_dev,
++				"Error in setting parameters in CCDC\n");
++			goto unlock_out;
++		}
++
++		if (vpfe_get_ccdc_image_format(vpfe_dev, &vpfe_dev->fmt) < 0) {
++			v4l2_err(&vpfe_dev->v4l2_dev,
++				"Invalid image format at CCDC\n");
++			ret = -EINVAL;
++		}
++unlock_out:
++		mutex_unlock(&vpfe_dev->lock);
++		break;
++	case VPFE_CMD_G_CCDC_RAW_PARAMS:
++		v4l2_warn(&vpfe_dev->v4l2_dev,
++			  "VPFE_CMD_G_CCDC_RAW_PARAMS: experimental ioctl\n");
++		if (!ccdc_dev->hw_ops.get_params) {
++			ret = -EINVAL;
++			break;
++		}
++		ret = ccdc_dev->hw_ops.get_params(param);
++		if (ret) {
++			v4l2_dbg(1, debug, &vpfe_dev->v4l2_dev,
++				"Error in getting parameters from CCDC\n");
++		}
++		break;
++
++	default:
++		ret = -EINVAL;
++	}
++	return ret;
++}
++
++static long vpfe_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
++{
++	if (cmd == VPFE_CMD_S_CCDC_RAW_PARAMS ||
++	    cmd == VPFE_CMD_G_CCDC_RAW_PARAMS)
++		return vpfe_param_handler(file, file->private_data, cmd,
++					 (void *)arg);
++	return video_ioctl2(file, cmd, arg);
++}
++
+ /* vpfe capture driver file operations */
+ static const struct v4l2_file_operations vpfe_fops = {
+ 	.owner = THIS_MODULE,
+ 	.open = vpfe_open,
+ 	.release = vpfe_release,
+-	.unlocked_ioctl = video_ioctl2,
++	.unlocked_ioctl = vpfe_ioctl,
+ 	.mmap = vpfe_mmap,
+ 	.poll = vpfe_poll
+ };
+ 
+-/*
++/**
+  * vpfe_check_format()
+  * This function adjust the input pixel format as per hardware
+  * capabilities and update the same in pixfmt.
+@@ -814,12 +1169,24 @@ static const struct vpfe_pixel_format *
+ 	/* check if hw supports it */
+ 	temp = 0;
+ 	found = 0;
+-	while (ccdc_dev->hw_ops.enum_pix(&pix, temp) >= 0) {
+-		if (vpfe_pix_fmt->fmtdesc.pixelformat == pix) {
+-			found = 1;
+-			break;
++	if (vpfe_dev->out_from == VPFE_CCDC_OUT) {
++		while (ccdc_dev->hw_ops.enum_pix(&pix, temp) >= 0) {
++			if (vpfe_pix_fmt->fmtdesc.pixelformat == pix) {
++				found = 1;
++				break;
++			}
++			temp++;
++		}
++	} else {
++		if (imp_hw_if) {
++			while (imp_hw_if->enum_pix(&pix, temp) >= 0) {
++				if (vpfe_pix_fmt->fmtdesc.pixelformat == pix) {
++					found = 1;
++					break;
++				}
++				temp++;
++			}
+ 		}
+-		temp++;
+ 	}
+ 
+ 	if (!found) {
+@@ -873,6 +1240,12 @@ static const struct vpfe_pixel_format *
+ 
+ 	max_width = vpfe_dev->std_info.active_pixels;
+ 	max_height = vpfe_dev->std_info.active_lines;
++	if (vpfe_dev->imp_chained) {
++		/* check with imp hw for the limits */
++		max_width  = imp_hw_if->get_max_output_width(0);
++		max_height = imp_hw_if->get_max_output_height(0);
++	}
++
+ 	min_width /= vpfe_pix_fmt->bpp;
+ 
+ 	v4l2_info(&vpfe_dev->v4l2_dev, "width = %d, height = %d, bpp = %d\n",
+@@ -941,8 +1314,18 @@ static int vpfe_enum_fmt_vid_cap(struct
+ 
+ 	v4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_enum_fmt_vid_cap\n");
+ 
+-	if (ccdc_dev->hw_ops.enum_pix(&pix, fmt->index) < 0)
+-		return -EINVAL;
++	if (!vpfe_dev->imp_chained) {
++		if (ccdc_dev->hw_ops.enum_pix(&pix, fmt->index) < 0)
++			return -EINVAL;
++	} else {
++		/**
++		 * Based on resizer present or not or not, imp module will
++		 * enumerate pixel format available at previewer output
++		 * or resizer output based on interface type
++		 */
++		if (imp_hw_if->enum_pix(&pix, fmt->index) < 0)
++			return -EINVAL;
++	}
+ 
+ 	/* Fill in the information about format */
+ 	pix_fmt = vpfe_lookup_pix_format(pix);
+@@ -955,11 +1338,112 @@ static int vpfe_enum_fmt_vid_cap(struct
+ 	return -EINVAL;
+ }
+ 
++/**
++ * vpfe_config_imp_image_format - Setup image format in image processor
++ * @vpfe_dev: vpfe device object
++ *
++ * Configure the input and output pixel format, input crop area and output
++ * frame sizes in the image processor. This is called during S_INPUT, S_CROP
++ * and S_FMT ioctls.
++ */
++static int vpfe_config_imp_image_format(struct vpfe_device *vpfe_dev)
++{
++	struct vpfe_subdev_info *sdinfo =
++			vpfe_dev->current_subdev;
++	int ret = -EINVAL, bytesperline;
++	enum imp_pix_formats imp_pix;
++	struct imp_window imp_win;
++
++	/* first setup input and output pixel formats */
++	if (sdinfo->is_camera)
++		imp_pix = IMP_BAYER;
++	else
++		imp_pix = IMP_UYVY;
++
++	if (imp_hw_if->set_in_pixel_format(imp_pix) < 0) {
++		v4l2_err(&vpfe_dev->v4l2_dev,
++			"Couldn't set in pix format at IMP\n");
++		goto imp_exit;
++	}
++
++	if (vpfe_dev->fmt.fmt.pix.pixelformat == V4L2_PIX_FMT_SBGGR16)
++		imp_pix = IMP_BAYER;
++	else if (vpfe_dev->fmt.fmt.pix.pixelformat == V4L2_PIX_FMT_UYVY)
++		imp_pix = IMP_UYVY;
++	else if (vpfe_dev->fmt.fmt.pix.pixelformat == V4L2_PIX_FMT_NV12)
++		imp_pix = IMP_YUV420SP;
++	else {
++		v4l2_err(&vpfe_dev->v4l2_dev,
++			"pixel format not supported at IMP\n");
++		goto imp_exit;
++	}
++
++	if (imp_hw_if->set_out_pixel_format(imp_pix) < 0) {
++		v4l2_err(&vpfe_dev->v4l2_dev, "pixel format not supported"
++			 " at IMP\n");
++		goto imp_exit;
++	}
++
++	if (vpfe_dev->fmt.fmt.pix.field == V4L2_FIELD_INTERLACED) {
++		imp_hw_if->set_buftype(0);
++		imp_hw_if->set_frame_format(0);
++		ccdc_dev->hw_ops.set_frame_format(CCDC_FRMFMT_INTERLACED);
++	} else if (vpfe_dev->fmt.fmt.pix.field == V4L2_FIELD_NONE) {
++		imp_hw_if->set_frame_format(1);
++		ccdc_dev->hw_ops.set_frame_format(CCDC_FRMFMT_PROGRESSIVE);
++	} else {
++		v4l2_err(&vpfe_dev->v4l2_dev, "\n field error!");
++		goto imp_exit;
++	}
++
++	/**
++	 * Check if we have resizer. Otherwise don't allow crop size to
++	 * be different from image size
++	 */
++	imp_win.width = vpfe_dev->crop.width;
++	imp_win.height = vpfe_dev->crop.height;
++	imp_win.hst = vpfe_dev->crop.left;
++	/* vst start from 1 */
++	imp_win.vst = vpfe_dev->crop.top + 1;
++	if (imp_hw_if->set_input_win(&imp_win) < 0) {
++		v4l2_err(&vpfe_dev->v4l2_dev, "Error in setting crop window"
++			 " in IMP\n");
++		goto imp_exit;
++	}
++
++	/* Set output */
++	imp_win.width = vpfe_dev->fmt.fmt.pix.width;
++	imp_win.height = vpfe_dev->fmt.fmt.pix.height;
++	imp_win.hst = 0;
++	imp_win.vst = 0;
++	if (imp_hw_if->set_output_win(&imp_win) < 0) {
++		v4l2_err(&vpfe_dev->v4l2_dev, "Error in setting image window"
++			 " in IMP\n");
++		goto imp_exit;
++	}
++
++	bytesperline = imp_hw_if->get_line_length(0);
++	if (bytesperline !=
++		vpfe_dev->fmt.fmt.pix.bytesperline) {
++		v4l2_err(&vpfe_dev->v4l2_dev, "Mismatch between bytesperline"
++			"at IMP and vpfe\n");
++		goto imp_exit;
++	}
++
++	if (imp_hw_if->get_output_state(1))
++		vpfe_dev->second_out_img_sz = imp_hw_if->get_line_length(1) *
++					    imp_hw_if->get_image_height(1);
++	ret = 0;
++imp_exit:
++	return ret;
++}
++
+ static int vpfe_s_fmt_vid_cap(struct file *file, void *priv,
+ 				struct v4l2_format *fmt)
+ {
+ 	struct vpfe_device *vpfe_dev = video_drvdata(file);
+ 	const struct vpfe_pixel_format *pix_fmts;
++	struct vpfe_subdev_info *sdinfo;
+ 	int ret = 0;
+ 
+ 	v4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_s_fmt_vid_cap\n");
+@@ -981,11 +1465,53 @@ static int vpfe_s_fmt_vid_cap(struct fil
+ 	if (ret)
+ 		return ret;
+ 
+-	/* First detach any IRQ if currently attached */
+-	vpfe_detach_irq(vpfe_dev);
+-	vpfe_dev->fmt = *fmt;
+-	/* set image capture parameters in the ccdc */
+-	ret = vpfe_config_ccdc_image_format(vpfe_dev);
++	sdinfo = vpfe_dev->current_subdev;
++	if (sdinfo->is_camera) {
++		/**
++		 * TODO. Current implementation of camera sub device calculates
++		 * sensor timing values based on S_FMT. So we need to
++		 * explicitely call S_FMT first and make sure it succeeds before
++		 * setting capture parameters in ccdc. Assuming sensor supports
++		 * V4L2_PIX_FMT_SGRBG10
++		 */
++		ret = vpfe_set_format_in_sensor(vpfe_dev, fmt);
++		if (!ret) {
++			/**
++			 * Set Crop size to frame size. Application needs to call
++			 * S_CROP to change it after S_FMT
++			 */
++			vpfe_dev->crop.width = fmt->fmt.pix.width;
++			vpfe_dev->crop.height = fmt->fmt.pix.height;
++		} else
++			goto s_fmt_out;
++	}
++
++
++	if (!ret)
++		vpfe_dev->fmt = *fmt;
++
++	if (!vpfe_dev->imp_chained) {
++		if (!ret)
++			/* set image capture parameters in the ccdc if */
++			ret = vpfe_config_ccdc_image_format(vpfe_dev);
++	} else {
++		/**
++		 * currently S_FMT does scaling at the sensor and input to
++		 * to CCDC is this scaled output for camera capture. So SoC
++		 * resizer can be used to zoom/scale up a rectangle of input
++		 * frame inside the received frame boundary by setting S_CROP.
++		 * But for decoders like tvp7002, we set ccdc sizes based on
++		 * given standard and use image processor to scale it down or
++		 * up. So processing is different for both cases
++		 */
++		if (vpfe_dev->current_subdev->is_camera)
++			ret = vpfe_config_ccdc_image_format(vpfe_dev);
++
++		if (!ret)
++			ret = vpfe_config_imp_image_format(vpfe_dev);
++	}
++
++s_fmt_out:
+ 	mutex_unlock(&vpfe_dev->lock);
+ 	return ret;
+ }
+@@ -1043,9 +1569,10 @@ static int vpfe_get_app_input_index(stru
+ 
+ 	for (i = 0; i < cfg->num_subdevs; i++) {
+ 		sdinfo = &cfg->sub_devs[i];
+-		if (!strcmp(sdinfo->name, vpfe_dev->current_subdev->name)) {
++		if (!strcmp(sdinfo->module_name,
++		     vpfe_dev->current_subdev->module_name)) {
+ 			if (vpfe_dev->current_input >= sdinfo->num_inputs)
+-				return -1;
++				return -EINVAL;
+ 			*app_input_index = j + vpfe_dev->current_input;
+ 			return 0;
+ 		}
+@@ -1059,10 +1586,11 @@ static int vpfe_enum_input(struct file *
+ {
+ 	struct vpfe_device *vpfe_dev = video_drvdata(file);
+ 	struct vpfe_subdev_info *sdinfo;
+-	int subdev, index ;
++	int subdev, index, temp_index;
+ 
+ 	v4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_enum_input\n");
+ 
++	temp_index = inp->index;
+ 	if (vpfe_get_subdev_input_index(vpfe_dev,
+ 					&subdev,
+ 					&index,
+@@ -1073,6 +1601,7 @@ static int vpfe_enum_input(struct file *
+ 	}
+ 	sdinfo = &vpfe_dev->cfg->sub_devs[subdev];
+ 	memcpy(inp, &sdinfo->inputs[index], sizeof(struct v4l2_input));
++	inp->index = temp_index;
+ 	return 0;
+ }
+ 
+@@ -1085,15 +1614,13 @@ static int vpfe_g_input(struct file *fil
+ 	return vpfe_get_app_input_index(vpfe_dev, index);
+ }
+ 
+-
+ static int vpfe_s_input(struct file *file, void *priv, unsigned int index)
+ {
+ 	struct vpfe_device *vpfe_dev = video_drvdata(file);
++	int subdev_index, subdev_inp_index, ret;
+ 	struct vpfe_subdev_info *sdinfo;
+-	int subdev_index, inp_index;
+ 	struct vpfe_route *route;
+ 	u32 input = 0, output = 0;
+-	int ret = -EINVAL;
+ 
+ 	v4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_s_input\n");
+ 
+@@ -1113,40 +1640,80 @@ static int vpfe_s_input(struct file *fil
+ 
+ 	if (vpfe_get_subdev_input_index(vpfe_dev,
+ 					&subdev_index,
+-					&inp_index,
++					&subdev_inp_index,
+ 					index) < 0) {
+ 		v4l2_err(&vpfe_dev->v4l2_dev, "invalid input index\n");
++		ret = -EINVAL;
+ 		goto unlock_out;
+ 	}
+ 
+ 	sdinfo = &vpfe_dev->cfg->sub_devs[subdev_index];
+-	route = &sdinfo->routes[inp_index];
++
++	if (!sdinfo->registered) {
++		ret = -EINVAL;
++		goto unlock_out;
++	}
++
++	if (vpfe_dev->cfg->setup_input) {
++		if (vpfe_dev->cfg->setup_input(sdinfo->grp_id) < 0) {
++			ret = -EFAULT;
++			v4l2_dbg(1, debug, &vpfe_dev->v4l2_dev,
++				 "couldn't setup input for %s\n",
++				 sdinfo->module_name);
++			goto unlock_out;
++		}
++	}
++
++	route = &sdinfo->routes[subdev_inp_index];
+ 	if (route && sdinfo->can_route) {
+ 		input = route->input;
+ 		output = route->output;
+-	}
+-
+-	ret = v4l2_device_call_until_err(&vpfe_dev->v4l2_dev, sdinfo->grp_id,
+-					 video, s_routing, input, output, 0);
++		ret = v4l2_device_call_until_err(&vpfe_dev->v4l2_dev,
++						 sdinfo->grp_id, video,
++						 s_routing, input, output, 0);
+ 
+-	if (ret) {
+-		v4l2_err(&vpfe_dev->v4l2_dev,
+-			"vpfe_doioctl:error in setting input in decoder\n");
+-		ret = -EINVAL;
+-		goto unlock_out;
++		if (ret) {
++			v4l2_dbg(1, debug, &vpfe_dev->v4l2_dev,
++				"s_input:error in setting input in"
++				" decoder \n");
++			ret = -EINVAL;
++			goto unlock_out;
++		}
+ 	}
++
+ 	vpfe_dev->current_subdev = sdinfo;
+-	vpfe_dev->current_input = index;
+-	vpfe_dev->std_index = 0;
++	vpfe_dev->current_input = subdev_inp_index;
+ 
+ 	/* set the bus/interface parameter for the sub device in ccdc */
+ 	ret = ccdc_dev->hw_ops.set_hw_if_params(&sdinfo->ccdc_if_params);
+ 	if (ret)
+ 		goto unlock_out;
+ 
++	/* update the if parameters to imp hw interface */
++	if (imp_hw_if && imp_hw_if->set_hw_if_param)
++		ret = imp_hw_if->set_hw_if_param(&sdinfo->ccdc_if_params);
++	if (ret)
++		goto unlock_out;
++
+ 	/* set the default image parameters in the device */
+-	ret = vpfe_config_image_format(vpfe_dev,
++	if (vpfe_dev->current_subdev->is_camera) {
++		vpfe_dev->std_index = -1;
++		/* for camera, use ccdc default parameters */
++		ret = vpfe_get_ccdc_image_format(vpfe_dev, &vpfe_dev->fmt);
++		/* also set the current default format in the sensor */
++		if (ret)
++			goto unlock_out;
++
++		ret = vpfe_set_format_in_sensor(vpfe_dev, &vpfe_dev->fmt);
++	} else {
++		vpfe_dev->std_index = 0;
++		/*
++		 * For non-camera sub device, use standard to configure vpfe
++		 * default
++		 */
++		ret = vpfe_config_image_format(vpfe_dev,
+ 				&vpfe_standards[vpfe_dev->std_index].std_id);
++	}
+ unlock_out:
+ 	mutex_unlock(&vpfe_dev->lock);
+ 	return ret;
+@@ -1192,6 +1759,16 @@ static int vpfe_s_std(struct file *file,
+ 		goto unlock_out;
+ 	}
+ 
++	/* Set filter value in ths7353 for TVP7002 input path */
++	if (sdinfo->grp_id == VPFE_SUBDEV_TVP7002) {
++		ret = v4l2_device_call_until_err(&vpfe_dev->v4l2_dev, 1, video,
++						 s_std_output, *std_id);
++		if (ret < 0) {
++			v4l2_err(&vpfe_dev->v4l2_dev, "Failed to set filter for THS7353\n");
++			goto unlock_out;
++		}
++	}
++
+ 	ret = v4l2_device_call_until_err(&vpfe_dev->v4l2_dev, sdinfo->grp_id,
+ 					 core, s_std, *std_id);
+ 	if (ret < 0) {
+@@ -1211,9 +1788,15 @@ static int vpfe_g_std(struct file *file,
+ 
+ 	v4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_g_std\n");
+ 
++	if (vpfe_dev->std_index < 0 ||
++	    vpfe_dev->std_index >= ARRAY_SIZE(vpfe_standards)) {
++		v4l2_err(&vpfe_dev->v4l2_dev, "Standard not supported\n");
++		return -EINVAL;
++	}
+ 	*std_id = vpfe_standards[vpfe_dev->std_index].std_id;
+ 	return 0;
+ }
++
+ /*
+  *  Videobuf operations
+  */
+@@ -1225,10 +1808,25 @@ static int vpfe_videobuf_setup(struct vi
+ 	struct vpfe_device *vpfe_dev = fh->vpfe_dev;
+ 
+ 	v4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_buffer_setup\n");
+-	*size = config_params.device_bufsize;
++
++	/*
++	 * if we are using mmap, check the size of the allocated buffer is less
++	 * than or equal to the maximum specified in the driver. Assume here the
++	 * user has called S_FMT and sizeimage has been calculated.
++	 */
++	*size = vpfe_dev->fmt.fmt.pix.sizeimage;
++	if (vpfe_dev->second_output)
++		*size += vpfe_dev->second_out_img_sz;
++
++	if (vpfe_dev->memory == V4L2_MEMORY_MMAP) {
++		/* Limit maximum to what is configured */
++		if (*size > config_params.device_bufsize)
++			*size = config_params.device_bufsize;
++	}
+ 
+ 	if (*count < config_params.min_numbuffers)
+ 		*count = config_params.min_numbuffers;
++
+ 	v4l2_dbg(1, debug, &vpfe_dev->v4l2_dev,
+ 		"count=%d, size=%d\n", *count, *size);
+ 	return 0;
+@@ -1240,8 +1838,10 @@ static int vpfe_videobuf_prepare(struct
+ {
+ 	struct vpfe_fh *fh = vq->priv_data;
+ 	struct vpfe_device *vpfe_dev = fh->vpfe_dev;
++	unsigned long addr;
++	int ret;
+ 
+-	v4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_buffer_prepare\n");
++	v4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_videobuf_prepare\n");
+ 
+ 	/* If buffer is not initialized, initialize it */
+ 	if (VIDEOBUF_NEEDS_INIT == vb->state) {
+@@ -1249,8 +1849,19 @@ static int vpfe_videobuf_prepare(struct
+ 		vb->height = vpfe_dev->fmt.fmt.pix.height;
+ 		vb->size = vpfe_dev->fmt.fmt.pix.sizeimage;
+ 		vb->field = field;
++
++		ret = videobuf_iolock(vq, vb, NULL);
++		if (ret < 0)
++			return ret;
++
++		addr = videobuf_to_dma_contig(vb);
++		/* Make sure user addresses are aligned to 32 bytes */
++		if (!ALIGN(addr, 32))
++			return -EINVAL;
++
++		vb->state = VIDEOBUF_PREPARED;
+ 	}
+-	vb->state = VIDEOBUF_PREPARED;
++
+ 	return 0;
+ }
+ 
+@@ -1262,8 +1873,6 @@ static void vpfe_videobuf_queue(struct v
+ 	struct vpfe_device *vpfe_dev = fh->vpfe_dev;
+ 	unsigned long flags;
+ 
+-	v4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_buffer_queue\n");
+-
+ 	/* add the buffer to the DMA queue */
+ 	spin_lock_irqsave(&vpfe_dev->dma_queue_lock, flags);
+ 	list_add_tail(&vb->queue, &vpfe_dev->dma_queue);
+@@ -1278,18 +1887,11 @@ static void vpfe_videobuf_release(struct
+ {
+ 	struct vpfe_fh *fh = vq->priv_data;
+ 	struct vpfe_device *vpfe_dev = fh->vpfe_dev;
+-	unsigned long flags;
+ 
+ 	v4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_videobuf_release\n");
+ 
+-	/*
+-	 * We need to flush the buffer from the dma queue since
+-	 * they are de-allocated
+-	 */
+-	spin_lock_irqsave(&vpfe_dev->dma_queue_lock, flags);
+-	INIT_LIST_HEAD(&vpfe_dev->dma_queue);
+-	spin_unlock_irqrestore(&vpfe_dev->dma_queue_lock, flags);
+-	videobuf_dma_contig_free(vq, vb);
++	if (vpfe_dev->memory == V4L2_MEMORY_MMAP)
++		videobuf_dma_contig_free(vq, vb);
+ 	vb->state = VIDEOBUF_NEEDS_INIT;
+ }
+ 
+@@ -1318,13 +1920,6 @@ static int vpfe_reqbufs(struct file *fil
+ 		return -EINVAL;
+ 	}
+ 
+-	if (V4L2_MEMORY_USERPTR == req_buf->memory) {
+-		/* we don't support user ptr IO */
+-		v4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_reqbufs:"
+-			 " USERPTR IO not supported\n");
+-		return  -EINVAL;
+-	}
+-
+ 	ret = mutex_lock_interruptible(&vpfe_dev->lock);
+ 	if (ret)
+ 		return ret;
+@@ -1338,7 +1933,7 @@ static int vpfe_reqbufs(struct file *fil
+ 	vpfe_dev->memory = req_buf->memory;
+ 	videobuf_queue_dma_contig_init(&vpfe_dev->buffer_queue,
+ 				&vpfe_videobuf_qops,
+-				NULL,
++				vpfe_dev->pdev,
+ 				&vpfe_dev->irqlock,
+ 				req_buf->type,
+ 				vpfe_dev->fmt.fmt.pix.field,
+@@ -1349,6 +1944,8 @@ static int vpfe_reqbufs(struct file *fil
+ 	vpfe_dev->io_usrs = 1;
+ 	INIT_LIST_HEAD(&vpfe_dev->dma_queue);
+ 	ret = videobuf_reqbufs(&vpfe_dev->buffer_queue, req_buf);
++	if (!ret && vpfe_dev->imp_chained)
++		imp_hw_if->lock_chain();
+ unlock_out:
+ 	mutex_unlock(&vpfe_dev->lock);
+ 	return ret;
+@@ -1413,9 +2010,11 @@ static int vpfe_dqbuf(struct file *file,
+ 				      buf, file->f_flags & O_NONBLOCK);
+ }
+ 
+-/*
++/**
+  * vpfe_calculate_offsets : This function calculates buffers offset
+- * for top and bottom field
++ * @vpfe_dev - device object
++ *
++ * This function calculates field and second image offsets
+  */
+ static void vpfe_calculate_offsets(struct vpfe_device *vpfe_dev)
+ {
+@@ -1423,16 +2022,31 @@ static void vpfe_calculate_offsets(struc
+ 
+ 	v4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_calculate_offsets\n");
+ 
+-	ccdc_dev->hw_ops.get_image_window(&image_win);
+-	vpfe_dev->field_off = image_win.height * image_win.width;
++	vpfe_dev->field_off = 0;
++	vpfe_dev->second_off = 0;
++	if (!vpfe_dev->imp_chained) {
++		ccdc_dev->hw_ops.get_image_window(&image_win);
++		vpfe_dev->field_off = image_win.height * image_win.width;
++
++	} else {
++		if (vpfe_dev->second_output)
++			vpfe_dev->second_off = vpfe_dev->fmt.fmt.pix.sizeimage;
++	}
++	vpfe_dev->field_off = (vpfe_dev->field_off + 31) & ~0x1f;
++	/* Adjust the second offset to 32 byte boundary */
++	vpfe_dev->second_off = (vpfe_dev->second_off + 31) & ~0x1f;
+ }
+ 
+ /* vpfe_start_ccdc_capture: start streaming in ccdc/isif */
+-static void vpfe_start_ccdc_capture(struct vpfe_device *vpfe_dev)
++static void vpfe_start_capture(struct vpfe_device *vpfe_dev)
+ {
+-	ccdc_dev->hw_ops.enable(1);
+ 	if (ccdc_dev->hw_ops.enable_out_to_sdram)
+-		ccdc_dev->hw_ops.enable_out_to_sdram(1);
++		ccdc_dev->hw_ops.enable_out_to_sdram(!vpfe_dev->imp_chained);
++
++	if (vpfe_dev->imp_chained)
++		imp_hw_if->enable(1, NULL);
++
++	ccdc_dev->hw_ops.enable(1);
+ 	vpfe_dev->started = 1;
+ }
+ 
+@@ -1448,13 +2062,13 @@ static int vpfe_streamon(struct file *fi
+ 	struct vpfe_fh *fh = file->private_data;
+ 	struct vpfe_subdev_info *sdinfo;
+ 	unsigned long addr;
+-	int ret = 0;
++	int ret = -EINVAL;
+ 
+ 	v4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_streamon\n");
+ 
+ 	if (V4L2_BUF_TYPE_VIDEO_CAPTURE != buf_type) {
+ 		v4l2_err(&vpfe_dev->v4l2_dev, "Invalid buf type\n");
+-		return -EINVAL;
++		return ret;
+ 	}
+ 
+ 	/* If file handle is not allowed IO, return error */
+@@ -1469,7 +2083,7 @@ static int vpfe_streamon(struct file *fi
+ 
+ 	if (ret && (ret != -ENOIOCTLCMD)) {
+ 		v4l2_err(&vpfe_dev->v4l2_dev, "stream on failed in subdev\n");
+-		return -EINVAL;
++		return ret;
+ 	}
+ 
+ 	/* If buffer queue is empty, return error */
+@@ -1483,7 +2097,6 @@ static int vpfe_streamon(struct file *fi
+ 	if (ret)
+ 		return ret;
+ 
+-
+ 	ret = mutex_lock_interruptible(&vpfe_dev->lock);
+ 	if (ret)
+ 		goto streamoff;
+@@ -1508,14 +2121,47 @@ static int vpfe_streamon(struct file *fi
+ 		ret = -EFAULT;
+ 		goto unlock_out;
+ 	}
+-	if (ccdc_dev->hw_ops.configure() < 0) {
++
++	if (ccdc_dev->hw_ops.configure(vpfe_dev->imp_chained) < 0) {
+ 		v4l2_err(&vpfe_dev->v4l2_dev,
+ 			 "Error in configuring ccdc\n");
+-		ret = -EINVAL;
+ 		goto unlock_out;
+ 	}
+-	ccdc_dev->hw_ops.setfbaddr((unsigned long)(addr));
+-	vpfe_start_ccdc_capture(vpfe_dev);
++
++	if (!vpfe_dev->imp_chained) {
++		ccdc_dev->hw_ops.setfbaddr((unsigned long)(addr));
++		goto out;
++	}
++
++	/* Image processor chained in the path */
++	if (!cpu_is_davinci_dm365() &&
++	    !vpfe_dev->current_subdev->is_camera) {
++		v4l2_err(&vpfe_dev->v4l2_dev, "Doesn't support chaining\n");
++		goto unlock_out;
++	}
++	if (imp_hw_if->hw_setup(vpfe_dev->pdev, NULL) < 0) {
++		v4l2_err(&vpfe_dev->v4l2_dev,
++			"Error setting up IMP\n");
++		goto unlock_out;
++	}
++
++	if (imp_hw_if->update_outbuf1_address(NULL, addr) < 0) {
++		v4l2_err(&vpfe_dev->v4l2_dev,
++			"Error setting up address in IMP output1\n");
++		goto unlock_out;
++	}
++
++	if (vpfe_dev->second_output) {
++		if (imp_hw_if->update_outbuf2_address(NULL,
++				(addr + vpfe_dev->second_off)) < 0) {
++			v4l2_err(&vpfe_dev->v4l2_dev, "Error setting up"
++				 " address in IMP output2\n");
++			goto unlock_out;
++		}
++	}
++out:
++	ret = 0;
++	vpfe_start_capture(vpfe_dev);
+ 	mutex_unlock(&vpfe_dev->lock);
+ 	return ret;
+ unlock_out:
+@@ -1536,13 +2182,13 @@ static int vpfe_streamoff(struct file *f
+ 	v4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_streamoff\n");
+ 
+ 	if (V4L2_BUF_TYPE_VIDEO_CAPTURE != buf_type) {
+-		v4l2_err(&vpfe_dev->v4l2_dev, "Invalid buf type\n");
++		v4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "Invalid buf type\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	/* If io is allowed for this file handle, return error */
+ 	if (!fh->io_allowed) {
+-		v4l2_err(&vpfe_dev->v4l2_dev, "fh->io_allowed\n");
++		v4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "fh->io_allowed\n");
+ 		return -EACCES;
+ 	}
+ 
+@@ -1556,7 +2202,7 @@ static int vpfe_streamoff(struct file *f
+ 	if (ret)
+ 		return ret;
+ 
+-	vpfe_stop_ccdc_capture(vpfe_dev);
++	vpfe_stop_capture(vpfe_dev);
+ 	vpfe_detach_irq(vpfe_dev);
+ 
+ 	sdinfo = vpfe_dev->current_subdev;
+@@ -1570,23 +2216,77 @@ static int vpfe_streamoff(struct file *f
+ 	return ret;
+ }
+ 
++static int vpfe_queryctrl(struct file *file, void *priv,
++				struct v4l2_queryctrl *qc)
++{
++	struct vpfe_device *vpfe_dev = video_drvdata(file);
++	struct vpfe_subdev_info *sub_dev = vpfe_dev->current_subdev;
++
++	v4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_queryctrl\n");
++
++	/* pass it to sub device */
++	return v4l2_device_call_until_err(&vpfe_dev->v4l2_dev, sub_dev->grp_id,
++					  core, queryctrl, qc);
++}
++
++static int vpfe_g_ctrl(struct file *file, void *priv,
++			struct v4l2_control *ctrl)
++{
++	struct vpfe_device *vpfe_dev = video_drvdata(file);
++	struct vpfe_subdev_info *sub_dev = vpfe_dev->current_subdev;
++
++	v4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_g_ctrl\n");
++
++	return v4l2_device_call_until_err(&vpfe_dev->v4l2_dev, sub_dev->grp_id,
++					  core, g_ctrl, ctrl);
++}
++
++static int vpfe_s_ctrl(struct file *file, void *priv,
++			     struct v4l2_control *ctrl)
++{
++	struct vpfe_device *vpfe_dev = video_drvdata(file);
++	struct vpfe_subdev_info *sub_dev = vpfe_dev->current_subdev;
++
++	v4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_s_ctrl\n");
++
++	return v4l2_device_call_until_err(&vpfe_dev->v4l2_dev, sub_dev->grp_id,
++					  core, s_ctrl, ctrl);
++}
++
+ static int vpfe_cropcap(struct file *file, void *priv,
+ 			      struct v4l2_cropcap *crop)
+ {
+ 	struct vpfe_device *vpfe_dev = video_drvdata(file);
++	struct vpfe_subdev_info *sdinfo;
+ 
+ 	v4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_cropcap\n");
+ 
+-	if (vpfe_dev->std_index > ARRAY_SIZE(vpfe_standards))
+-		return -EINVAL;
+-
+ 	memset(crop, 0, sizeof(struct v4l2_cropcap));
+ 	crop->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+-	crop->bounds.width = crop->defrect.width =
+-		vpfe_standards[vpfe_dev->std_index].width;
+-	crop->bounds.height = crop->defrect.height =
+-		vpfe_standards[vpfe_dev->std_index].height;
+-	crop->pixelaspect = vpfe_standards[vpfe_dev->std_index].pixelaspect;
++	sdinfo = vpfe_dev->current_subdev;
++
++	if (!sdinfo->is_camera) {
++
++		if (vpfe_dev->std_index < 0 ||
++		    vpfe_dev->std_index >= ARRAY_SIZE(vpfe_standards))
++			return -EINVAL;
++
++		crop->bounds.width = vpfe_standards[vpfe_dev->std_index].width;
++		crop->defrect.width = crop->bounds.width;
++		crop->bounds.height =
++			vpfe_standards[vpfe_dev->std_index].height;
++		crop->defrect.height = crop->bounds.height;
++		crop->pixelaspect =
++			vpfe_standards[vpfe_dev->std_index].pixelaspect;
++	} else {
++		/* camera interface */
++		crop->bounds.width = vpfe_dev->std_info.active_pixels;
++		crop->defrect.width = crop->bounds.width;
++		crop->bounds.height = vpfe_dev->std_info.active_lines;
++		crop->defrect.height = crop->bounds.height;
++		crop->pixelaspect.numerator = 1;
++		crop->pixelaspect.denominator = 1;
++	}
+ 	return 0;
+ }
+ 
+@@ -1605,7 +2305,7 @@ static int vpfe_s_crop(struct file *file
+ 			     struct v4l2_crop *crop)
+ {
+ 	struct vpfe_device *vpfe_dev = video_drvdata(file);
+-	int ret = 0;
++	int ret = 0, max_height, max_width;
+ 
+ 	v4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_s_crop\n");
+ 
+@@ -1630,72 +2330,134 @@ static int vpfe_s_crop(struct file *file
+ 	/* adjust the width to 16 pixel boundry */
+ 	crop->c.width = ((crop->c.width + 15) & ~0xf);
+ 
+-	/* make sure parameters are valid */
+-	if ((crop->c.left + crop->c.width >
+-		vpfe_dev->std_info.active_pixels) ||
+-	    (crop->c.top + crop->c.height >
+-		vpfe_dev->std_info.active_lines)) {
+-		v4l2_err(&vpfe_dev->v4l2_dev, "Error in S_CROP params\n");
++	/**
++	 * When there is no image processor chained, then cropping
++	 * happens at the ccdc and image size is the cropped image
++	 * size. For Camera, maximum size is limited to frame size
++	 * configured at the sensor through S_FMT that happens at
++	 * either at device open() or when application calls S_FMT
++	 */
++	if (!vpfe_dev->current_subdev->is_camera) {
++		max_width = vpfe_dev->std_info.active_pixels;
++		max_height = vpfe_dev->std_info.active_lines;
++	} else {
++		max_width = vpfe_dev->fmt.fmt.pix.width;
++		max_height = vpfe_dev->fmt.fmt.pix.height;
++	}
++
++	if ((crop->c.left + crop->c.width > max_width) ||
++	    (crop->c.top + crop->c.height > max_height)) {
++		v4l2_err(&vpfe_dev->v4l2_dev, "Error in S_CROP"
++			 " params, max_width = %d, max_height = %d\n",
++			 max_width, max_height);
+ 		ret = -EINVAL;
+ 		goto unlock_out;
+ 	}
++
+ 	ccdc_dev->hw_ops.set_image_window(&crop->c);
+-	vpfe_dev->fmt.fmt.pix.width = crop->c.width;
+-	vpfe_dev->fmt.fmt.pix.height = crop->c.height;
+-	vpfe_dev->fmt.fmt.pix.bytesperline =
+-		ccdc_dev->hw_ops.get_line_length();
+-	vpfe_dev->fmt.fmt.pix.sizeimage =
+-		vpfe_dev->fmt.fmt.pix.bytesperline *
+-		vpfe_dev->fmt.fmt.pix.height;
++	if (!vpfe_dev->imp_chained) {
++		vpfe_dev->fmt.fmt.pix.width = crop->c.width;
++		vpfe_dev->fmt.fmt.pix.height = crop->c.height;
++		vpfe_dev->fmt.fmt.pix.bytesperline =
++			ccdc_dev->hw_ops.get_line_length();
++		vpfe_dev->fmt.fmt.pix.sizeimage =
++			vpfe_dev->fmt.fmt.pix.bytesperline *
++			vpfe_dev->fmt.fmt.pix.height;
++	} else {
++		struct imp_window imp_crop_win;
++
++		imp_crop_win.width = crop->c.width;
++		imp_crop_win.height = crop->c.height;
++		imp_crop_win.hst = crop->c.left;
++		/* vst starts from 1 */
++		imp_crop_win.vst = crop->c.top + 1;
++		if (imp_hw_if->set_input_win(&imp_crop_win) < 0) {
++			v4l2_err(&vpfe_dev->v4l2_dev, "Error in setting crop "
++				 "window in IMP\n");
++			ret = -EINVAL;
++			goto unlock_out;
++		}
++	}
+ 	vpfe_dev->crop = crop->c;
+ unlock_out:
+ 	mutex_unlock(&vpfe_dev->lock);
+ 	return ret;
+ }
+ 
+-
+-static long vpfe_param_handler(struct file *file, void *priv,
+-		int cmd, void *param)
++static int vpfe_s_parm(struct file *file, void *priv,
++		       struct v4l2_streamparm *parm)
+ {
++	struct v4l2_captureparm *capparam = &parm->parm.capture;
+ 	struct vpfe_device *vpfe_dev = video_drvdata(file);
+-	int ret = 0;
++	int ret = -EINVAL;
+ 
+-	v4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_param_handler\n");
++	/* TODO - Revisit it before submitting to upstream */
++	if (!cpu_is_davinci_dm365()) {
++		v4l2_dbg(1, debug, &vpfe_dev->v4l2_dev,
++			"Ioctl not supported on this platform\n");
++		goto out;
++	}
+ 
+ 	if (vpfe_dev->started) {
+-		/* only allowed if streaming is not started */
+-		v4l2_err(&vpfe_dev->v4l2_dev, "device already started\n");
+-		return -EBUSY;
++		v4l2_dbg(1, debug, &vpfe_dev->v4l2_dev,
++			"Steaming ON. Cannot change capture streaming params.");
++		goto out;
++	}
++
++	if (vpfe_dev->std_info.frame_format) {
++		v4l2_dbg(1, debug, &vpfe_dev->v4l2_dev,
++			"Supported only for progressive scan");
++		goto out;
++	}
++
++	if (!capparam->timeperframe.numerator ||
++	    !capparam->timeperframe.denominator) {
++		v4l2_dbg(1, debug, &vpfe_dev->v4l2_dev,
++			"invalid timeperframe");
++		goto out;
++	}
++
++	if (capparam->timeperframe.numerator !=
++	    vpfe_dev->std_info.fps.numerator ||
++	    capparam->timeperframe.denominator >
++	    vpfe_dev->std_info.fps.denominator) {
++		v4l2_dbg(1, debug, &vpfe_dev->v4l2_dev,
++			"Invalid capparam, timeperframe.numerator = %d,"
++			"timeperframe.denominator = %d,\n"
++			"vpfe std_info.numerator = %d,"
++			" std_info.denominator = %d",
++			capparam->timeperframe.numerator,
++			capparam->timeperframe.denominator,
++			vpfe_dev->std_info.fps.numerator,
++			vpfe_dev->std_info.fps.denominator);
++		goto out;
+ 	}
+ 
+ 	ret = mutex_lock_interruptible(&vpfe_dev->lock);
+ 	if (ret)
+-		return ret;
++		goto out;
+ 
+-	switch (cmd) {
+-	case VPFE_CMD_S_CCDC_RAW_PARAMS:
+-		v4l2_warn(&vpfe_dev->v4l2_dev,
+-			  "VPFE_CMD_S_CCDC_RAW_PARAMS: experimental ioctl\n");
+-		ret = ccdc_dev->hw_ops.set_params(param);
+-		if (ret) {
+-			v4l2_err(&vpfe_dev->v4l2_dev,
+-				"Error in setting parameters in CCDC\n");
+-			goto unlock_out;
+-		}
+-		if (vpfe_get_ccdc_image_format(vpfe_dev, &vpfe_dev->fmt) < 0) {
+-			v4l2_err(&vpfe_dev->v4l2_dev,
+-				"Invalid image format at CCDC\n");
+-			goto unlock_out;
+-		}
+-		break;
+-	default:
+-		ret = -EINVAL;
+-	}
+-unlock_out:
++	vpfe_dev->timeperframe = capparam->timeperframe;
++	vpfe_dev->skip_frame_count = vpfe_dev->std_info.fps.denominator/
++					capparam->timeperframe.denominator;
++	vpfe_dev->skip_frame_count_init = vpfe_dev->skip_frame_count;
+ 	mutex_unlock(&vpfe_dev->lock);
++	ret = 0;
++out:
+ 	return ret;
+ }
+ 
++static int vpfe_g_parm(struct file *file, void *priv,
++		       struct v4l2_streamparm *parm)
++{
++	struct v4l2_captureparm *capparam = &parm->parm.capture;
++	struct vpfe_device *vpfe_dev = video_drvdata(file);
++
++	memset(capparam, 0, sizeof(struct v4l2_captureparm));
++	capparam->capability = V4L2_CAP_TIMEPERFRAME;
++	capparam->timeperframe = vpfe_dev->timeperframe;
++	return 0;
++}
+ 
+ /* vpfe capture ioctl operations */
+ static const struct v4l2_ioctl_ops vpfe_ioctl_ops = {
+@@ -1716,10 +2478,14 @@ static const struct v4l2_ioctl_ops vpfe_
+ 	.vidioc_dqbuf		 = vpfe_dqbuf,
+ 	.vidioc_streamon	 = vpfe_streamon,
+ 	.vidioc_streamoff	 = vpfe_streamoff,
++	.vidioc_queryctrl	 = vpfe_queryctrl,
++	.vidioc_g_ctrl		 = vpfe_g_ctrl,
++	.vidioc_s_ctrl		 = vpfe_s_ctrl,
+ 	.vidioc_cropcap		 = vpfe_cropcap,
+ 	.vidioc_g_crop		 = vpfe_g_crop,
+ 	.vidioc_s_crop		 = vpfe_s_crop,
+-	.vidioc_default		 = vpfe_param_handler,
++	.vidioc_s_parm		 = vpfe_s_parm,
++	.vidioc_g_parm		 = vpfe_g_parm,
+ };
+ 
+ static struct vpfe_device *vpfe_initialize(void)
+@@ -1741,7 +2507,7 @@ static struct vpfe_device *vpfe_initiali
+ 	config_params.numbuffers = numbuffers;
+ 
+ 	if (numbuffers)
+-		config_params.device_bufsize = bufsize;
++		config_params.device_bufsize = ALIGN(bufsize, 4096);
+ 
+ 	/* Allocate memory for device objects */
+ 	vpfe_dev = kzalloc(sizeof(*vpfe_dev), GFP_KERNEL);
+@@ -1752,62 +2518,83 @@ static struct vpfe_device *vpfe_initiali
+ static void vpfe_disable_clock(struct vpfe_device *vpfe_dev)
+ {
+ 	struct vpfe_config *vpfe_cfg = vpfe_dev->cfg;
++	int i;
+ 
+-	clk_disable(vpfe_cfg->vpssclk);
+-	clk_put(vpfe_cfg->vpssclk);
+-	clk_disable(vpfe_cfg->slaveclk);
+-	clk_put(vpfe_cfg->slaveclk);
+-	v4l2_info(vpfe_dev->pdev->driver,
+-		 "vpfe vpss master & slave clocks disabled\n");
++	for (i = 0; i < vpfe_cfg->num_clocks; i++) {
++		clk_disable(vpfe_dev->clks[i]);
++		clk_put(vpfe_dev->clks[i]);
++	}
++	kfree(vpfe_dev->clks);
++	v4l2_info(vpfe_dev->pdev->driver, "vpfe capture clocks disabled\n");
+ }
+ 
++/**
++ * vpfe_enable_clock() - Enable clocks for vpfe capture driver
++ * @vpfe_dev - ptr to vpfe capture device
++ *
++ * Enables clocks defined in vpfe configuration. The function
++ * assumes that at least one clock is to be defined which is
++ * true as of now. re-visit this if this assumption is not true
++ */
+ static int vpfe_enable_clock(struct vpfe_device *vpfe_dev)
+ {
+ 	struct vpfe_config *vpfe_cfg = vpfe_dev->cfg;
+-	int ret = -ENOENT;
++	int ret = -EFAULT, i;
+ 
+-	vpfe_cfg->vpssclk = clk_get(vpfe_dev->pdev, "vpss_master");
+-	if (NULL == vpfe_cfg->vpssclk) {
+-		v4l2_err(vpfe_dev->pdev->driver, "No clock defined for"
+-			 "vpss_master\n");
+-		return ret;
+-	}
++	if (!vpfe_cfg->num_clocks)
++		return 0;
+ 
+-	if (clk_enable(vpfe_cfg->vpssclk)) {
+-		v4l2_err(vpfe_dev->pdev->driver,
+-			"vpfe vpss master clock not enabled\n");
+-		goto out;
+-	}
+-	v4l2_info(vpfe_dev->pdev->driver,
+-		 "vpfe vpss master clock enabled\n");
++	vpfe_dev->clks = kzalloc(vpfe_cfg->num_clocks *
++				   sizeof(struct clock *), GFP_KERNEL);
+ 
+-	vpfe_cfg->slaveclk = clk_get(vpfe_dev->pdev, "vpss_slave");
+-	if (NULL == vpfe_cfg->slaveclk) {
+-		v4l2_err(vpfe_dev->pdev->driver,
+-			"No clock defined for vpss slave\n");
+-		goto out;
++	if (NULL == vpfe_dev->clks) {
++		v4l2_err(vpfe_dev->pdev->driver, "Memory allocation failed\n");
++		return -ENOMEM;
+ 	}
+ 
+-	if (clk_enable(vpfe_cfg->slaveclk)) {
+-		v4l2_err(vpfe_dev->pdev->driver,
+-			 "vpfe vpss slave clock not enabled\n");
+-		goto out;
++	for (i = 0; i < vpfe_cfg->num_clocks; i++) {
++		if (NULL == vpfe_cfg->clocks[i]) {
++			v4l2_err(vpfe_dev->pdev->driver,
++				"clock %s is not defined in vpfe config\n",
++				vpfe_cfg->clocks[i]);
++			goto out;
++		}
++
++		vpfe_dev->clks[i] = clk_get(vpfe_dev->pdev,
++					      vpfe_cfg->clocks[i]);
++		if (NULL == vpfe_dev->clks[i]) {
++			v4l2_err(vpfe_dev->pdev->driver,
++				"Failed to get clock %s\n",
++				vpfe_cfg->clocks[i]);
++			goto out;
++		}
++
++		if (clk_enable(vpfe_dev->clks[i])) {
++			v4l2_err(vpfe_dev->pdev->driver,
++				"vpfe clock %s not enabled\n",
++				vpfe_cfg->clocks[i]);
++			goto out;
++		}
++
++		v4l2_info(vpfe_dev->pdev->driver, "vpss clock %s enabled",
++			  vpfe_cfg->clocks[i]);
+ 	}
+-	v4l2_info(vpfe_dev->pdev->driver, "vpfe vpss slave clock enabled\n");
+ 	return 0;
+ out:
+-	if (vpfe_cfg->vpssclk)
+-		clk_put(vpfe_cfg->vpssclk);
+-	if (vpfe_cfg->slaveclk)
+-		clk_put(vpfe_cfg->slaveclk);
+-
+-	return -1;
++	for (i = 0; i < vpfe_cfg->num_clocks; i++) {
++		if (vpfe_dev->clks[i])
++			clk_put(vpfe_dev->clks[i]);
++	}
++	kfree(vpfe_dev->clks);
++	return ret;
+ }
+ 
+-/*
+- * vpfe_probe : This function creates device entries by register
+- * itself to the V4L2 driver and initializes fields of each
+- * device objects
++/**
++ * vpfe_probe : vpfe probe function
++ * @pdev: platform device pointer
++ *
++ * This function creates device entries by register itself to the V4L2 driver
++ * and initializes fields of each device objects
+  */
+ static __init int vpfe_probe(struct platform_device *pdev)
+ {
+@@ -1852,6 +2639,13 @@ static __init int vpfe_probe(struct plat
+ 	if (ret)
+ 		goto probe_free_dev_mem;
+ 
++	/* Initialise the ipipe hw module if exists */
++	if (!cpu_is_davinci_dm644x()) {
++		imp_hw_if = imp_get_hw_if();
++		if (ISNULL(imp_hw_if))
++			return -1;
++	}
++
+ 	mutex_lock(&ccdc_lock);
+ 	/* Allocate memory for ccdc configuration */
+ 	ccdc_cfg = kmalloc(sizeof(struct ccdc_config), GFP_KERNEL);
+@@ -1883,46 +2677,13 @@ static __init int vpfe_probe(struct plat
+ 	}
+ 	vpfe_dev->ccdc_irq1 = res1->start;
+ 
+-	/* Get address base of CCDC */
+-	res1 = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+-	if (!res1) {
+-		v4l2_err(pdev->dev.driver,
+-			"Unable to get register address map\n");
+-		ret = -ENOENT;
+-		goto probe_disable_clock;
+-	}
+-
+-	ccdc_cfg->ccdc_addr_size = res1->end - res1->start + 1;
+-	if (!request_mem_region(res1->start, ccdc_cfg->ccdc_addr_size,
+-				pdev->dev.driver->name)) {
+-		v4l2_err(pdev->dev.driver,
+-			"Failed request_mem_region for ccdc base\n");
+-		ret = -ENXIO;
+-		goto probe_disable_clock;
+-	}
+-	ccdc_cfg->ccdc_addr = ioremap_nocache(res1->start,
+-					     ccdc_cfg->ccdc_addr_size);
+-	if (!ccdc_cfg->ccdc_addr) {
+-		v4l2_err(pdev->dev.driver, "Unable to ioremap ccdc addr\n");
+-		ret = -ENXIO;
+-		goto probe_out_release_mem1;
+-	}
+-
+-	ret = request_irq(vpfe_dev->ccdc_irq0, vpfe_isr, IRQF_DISABLED,
+-			  "vpfe_capture0", vpfe_dev);
+-
+-	if (0 != ret) {
+-		v4l2_err(pdev->dev.driver, "Unable to request interrupt\n");
+-		goto probe_out_unmap1;
+-	}
+-
+ 	/* Allocate memory for video device */
+ 	vfd = video_device_alloc();
+ 	if (NULL == vfd) {
+ 		ret = -ENOMEM;
+ 		v4l2_err(pdev->dev.driver,
+ 			"Unable to alloc video device\n");
+-		goto probe_out_release_irq;
++		goto probe_disable_clock;
+ 	}
+ 
+ 	/* Initialize field of video device */
+@@ -1931,7 +2692,7 @@ static __init int vpfe_probe(struct plat
+ 	vfd->ioctl_ops		= &vpfe_ioctl_ops;
+ 	vfd->minor		= -1;
+ 	vfd->tvnorms		= 0;
+-	vfd->current_norm	= V4L2_STD_PAL;
++	vfd->current_norm	= V4L2_STD_NTSC;
+ 	vfd->v4l2_dev 		= &vpfe_dev->v4l2_dev;
+ 	snprintf(vfd->name, sizeof(vfd->name),
+ 		 "%s_V%d.%d.%d",
+@@ -1994,34 +2755,65 @@ static __init int vpfe_probe(struct plat
+ 		struct v4l2_input *inps;
+ 
+ 		sdinfo = &vpfe_cfg->sub_devs[i];
+-
+-		/* Load up the subdevice */
+-		vpfe_dev->sd[i] =
+-			v4l2_i2c_new_subdev_board(&vpfe_dev->v4l2_dev,
+-						  i2c_adap,
+-						  sdinfo->name,
+-						  &sdinfo->board_info,
+-						  NULL);
+-		if (vpfe_dev->sd[i]) {
+-			v4l2_info(&vpfe_dev->v4l2_dev,
+-				  "v4l2 sub device %s registered\n",
+-				  sdinfo->name);
+-			vpfe_dev->sd[i]->grp_id = sdinfo->grp_id;
+-			/* update tvnorms from the sub devices */
+-			for (j = 0; j < sdinfo->num_inputs; j++) {
+-				inps = &sdinfo->inputs[j];
+-				vfd->tvnorms |= inps->std;
++		/**
++		 * register subdevices based on interface setting. Currently
++		 * tvp5146 and mt9t031 cannot co-exists due to i2c address
++		 * conflicts. So only one of them is registered. Re-visit this
++		 * once we have support for i2c switch handling in i2c driver
++		 * framework
++		 */
++		if (interface == sdinfo->is_camera) {
++			/* setup input path */
++			if (vpfe_cfg->setup_input) {
++				if (vpfe_cfg->setup_input(sdinfo->grp_id) < 0) {
++					ret = -EFAULT;
++					v4l2_info(&vpfe_dev->v4l2_dev, "could"
++						  " not setup input for %s\n",
++						  sdinfo->module_name);
++					goto probe_sd_out;
++				}
++			}
++			/* Load up the subdevice */
++			vpfe_dev->sd[i] =
++				v4l2_i2c_new_subdev_board(&vpfe_dev->v4l2_dev,
++							  i2c_adap,
++							  sdinfo->module_name,
++							  &sdinfo->board_info,
++							  NULL);
++			if (vpfe_dev->sd[i]) {
++				v4l2_info(&vpfe_dev->v4l2_dev,
++					  "v4l2 sub device %s registered\n",
++					  sdinfo->module_name);
++				vpfe_dev->sd[i]->grp_id = sdinfo->grp_id;
++				/* update tvnorms from the sub devices */
++				for (j = 0; j < sdinfo->num_inputs; j++) {
++					inps = &sdinfo->inputs[j];
++					vfd->tvnorms |= inps->std;
++				}
++				sdinfo->registered = 1;
++			} else {
++				v4l2_info(&vpfe_dev->v4l2_dev,
++					  "v4l2 sub device %s register fails\n",
++					  sdinfo->module_name);
+ 			}
+-		} else {
+-			v4l2_info(&vpfe_dev->v4l2_dev,
+-				  "v4l2 sub device %s register fails\n",
+-				  sdinfo->name);
+-			goto probe_sd_out;
+ 		}
+ 	}
+ 
+-	/* set first sub device as current one */
+-	vpfe_dev->current_subdev = &vpfe_cfg->sub_devs[0];
++	/* We need at least one sub device to do capture */
++	for (i = 0; i < num_subdevs; i++) {
++		sdinfo = &vpfe_cfg->sub_devs[i];
++		if (sdinfo->registered) {
++			/* set this as the current sub device */
++			vpfe_dev->current_subdev = &vpfe_cfg->sub_devs[i];
++			break;
++		}
++	}
++
++	/* if we don't have any sub device registered, return error */
++	if (i == num_subdevs) {
++		printk(KERN_NOTICE "No sub devices registered\n");
++		goto probe_sd_out;
++	}
+ 
+ 	/* We have at least one sub device to work with */
+ 	mutex_unlock(&ccdc_lock);
+@@ -2036,12 +2828,6 @@ probe_out_v4l2_unregister:
+ probe_out_video_release:
+ 	if (vpfe_dev->video_dev->minor == -1)
+ 		video_device_release(vpfe_dev->video_dev);
+-probe_out_release_irq:
+-	free_irq(vpfe_dev->ccdc_irq0, vpfe_dev);
+-probe_out_unmap1:
+-	iounmap(ccdc_cfg->ccdc_addr);
+-probe_out_release_mem1:
+-	release_mem_region(res1->start, res1->end - res1->start + 1);
+ probe_disable_clock:
+ 	vpfe_disable_clock(vpfe_dev);
+ 	mutex_unlock(&ccdc_lock);
+@@ -2057,19 +2843,12 @@ probe_free_dev_mem:
+ static int vpfe_remove(struct platform_device *pdev)
+ {
+ 	struct vpfe_device *vpfe_dev = platform_get_drvdata(pdev);
+-	struct resource *res;
+ 
+ 	v4l2_info(pdev->dev.driver, "vpfe_remove\n");
+ 
+-	free_irq(vpfe_dev->ccdc_irq0, vpfe_dev);
+ 	kfree(vpfe_dev->sd);
+ 	v4l2_device_unregister(&vpfe_dev->v4l2_dev);
+ 	video_unregister_device(vpfe_dev->video_dev);
+-	mutex_lock(&ccdc_lock);
+-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+-	release_mem_region(res->start, res->end - res->start + 1);
+-	iounmap(ccdc_cfg->ccdc_addr);
+-	mutex_unlock(&ccdc_lock);
+ 	vpfe_disable_clock(vpfe_dev);
+ 	kfree(vpfe_dev);
+ 	kfree(ccdc_cfg);
+@@ -2112,7 +2891,7 @@ static __init int vpfe_init(void)
+ 	return platform_driver_register(&vpfe_driver);
+ }
+ 
+-/*
++/**
+  * vpfe_cleanup : This function un-registers device driver
+  */
+ static void vpfe_cleanup(void)
+--- /dev/null
++++ b/include/video/davincifb.h
+@@ -0,0 +1,66 @@
++/*
++ * Copyright (C) 2009 MontaVista Software Inc.
++ * Copyright (C) 2006 Texas Instruments Inc
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option)any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
++ */
++
++#ifndef DAVINCIFB_H
++#define DAVINCIFB_H
++
++#include <video/davinci_osd.h>
++#include <linux/poll.h>
++#include <linux/wait.h>
++
++#define DAVINCIFB_NAME "davincifb"
++
++/* There are 4 framebuffer devices, one per window. */
++#define OSD0_FBNAME "dm_osd0_fb"
++#define OSD1_FBNAME "dm_osd1_fb"
++#define VID0_FBNAME "dm_vid0_fb"
++#define VID1_FBNAME "dm_vid1_fb"
++
++/*  Structure for each window */
++struct vpbe_dm_win_info {
++	struct fb_info *info;
++	struct vpbe_dm_info *dm;
++	enum davinci_disp_layer layer;
++	unsigned xpos;
++	unsigned ypos;
++	unsigned own_window; /* Does the framebuffer driver own this window? */
++	unsigned display_window;
++	unsigned sdram_address;
++	unsigned int pseudo_palette[16];
++};
++
++/*
++ * Structure for the driver holding information of windows,
++ *  memory base addresses etc.
++ */
++struct vpbe_dm_info {
++	struct vpbe_dm_win_info win[4];
++
++	wait_queue_head_t vsync_wait;
++	unsigned int vsync_cnt;
++	int timeout;
++	struct davinci_disp_callback vsync_callback;
++
++	unsigned char ram_clut[256][3];
++	enum davinci_pix_format yc_pixfmt;
++
++	struct fb_videomode mode;
++};
++
++#endif				/* ifndef DAVINCIFB__H */
+--- /dev/null
++++ b/drivers/media/video/ths7353.c
+@@ -0,0 +1,234 @@
++/*
++ * ths7353 - THS7353 Video Amplifier driver
++ *
++ * Copyright (C) 2009 Texas Instruments Incorporated - http://www.ti.com/
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License as
++ * published by the Free Software Foundation version 2.
++ *
++ * This program is distributed .as is. WITHOUT ANY WARRANTY of any
++ * kind, whether express or implied; without even the implied warranty
++ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ */
++
++#include <linux/kernel.h>
++#include <linux/init.h>
++#include <linux/ctype.h>
++#include <linux/i2c.h>
++#include <linux/device.h>
++#include <linux/delay.h>
++#include <linux/module.h>
++#include <linux/uaccess.h>
++#include <linux/videodev2.h>
++
++#include <media/v4l2-device.h>
++#include <media/v4l2-subdev.h>
++#include <media/v4l2-chip-ident.h>
++
++#include <media/davinci/videohd.h>
++
++MODULE_DESCRIPTION("TI THS7353 video amplifier driver");
++MODULE_AUTHOR("Muralidharan Karicheri");
++MODULE_LICENSE("GPL");
++
++static int debug;
++module_param(debug, int, 0644);
++MODULE_PARM_DESC(debug, "Debug level 0-1");
++
++#define THS7353_CHANNEL_1	1
++#define THS7353_CHANNEL_2	2
++#define THS7353_CHANNEL_3	3
++#define THS7353_DEF_LUMA_CHANNEL 2
++
++/* all supported modes */
++enum ths7353_filter_mode {
++	THS_FILTER_MODE_480I_576I,
++	THS_FILTER_MODE_480P_576P,
++	THS_FILTER_MODE_720P_1080I,
++	THS_FILTER_MODE_1080P
++};
++
++static int ths7353_luma_channel;
++
++/* following function is used to set ths7353 */
++static int ths7353_setvalue(struct v4l2_subdev *sd,
++			    enum ths7353_filter_mode mode)
++{
++	u8 val = 0, input_bias_luma = 5, input_bias_chroma = 4, temp;
++	struct i2c_client *client;
++	int err = 0, disable = 0;
++	int channel = 3;
++
++	client = v4l2_get_subdevdata(sd);
++
++	switch (mode) {
++	case THS_FILTER_MODE_1080P:
++		/* LPF - 5MHz */
++		val = (3 << 6);
++		/* LPF - bypass */
++		val |= (3 << 3);
++		break;
++	case THS_FILTER_MODE_720P_1080I:
++		/* LPF - 5MHz */
++		val = (2 << 6);
++		/* LPF - 35 MHz */
++		val |= (2 << 3);
++		break;
++	case THS_FILTER_MODE_480P_576P:
++		/* LPF - 2.5MHz */
++		val = (1 << 6);
++		/* LPF - 16 MHz */
++		val |= (1 << 3);
++		break;
++	case THS_FILTER_MODE_480I_576I:
++		/* LPF - 500 KHz, LPF - 9 MHz. Do nothing */
++		break;
++	default:
++		/* disable all channels */
++		disable = 1;
++	}
++
++	channel = ths7353_luma_channel;
++
++	/* Setup channel 2 - Luma - Green */
++	temp = val;
++	if (!disable)
++		val |= input_bias_luma;
++	err = i2c_smbus_write_byte_data(client, channel, val);
++	if (err)
++		goto out;
++
++	/* setup two chroma channels */
++	if (!disable)
++		temp |= input_bias_chroma;
++	channel++;
++	if (channel > THS7353_CHANNEL_3)
++		channel = THS7353_CHANNEL_1;
++	err = i2c_smbus_write_byte_data(client, channel, temp);
++	if (err)
++		goto out;
++
++	channel++;
++	if (channel > THS7353_CHANNEL_3)
++		channel = THS7353_CHANNEL_1;
++	err = i2c_smbus_write_byte_data(client, channel, temp);
++	if (err)
++		goto out;
++	return 0;
++
++out:
++	v4l2_err(sd, "ths7353 write failed\n");
++	return err;
++}
++
++static int ths7353_s_std_output(struct v4l2_subdev *sd, v4l2_std_id norm)
++{
++	if (norm & (V4L2_STD_ALL & ~V4L2_STD_SECAM))
++		return ths7353_setvalue(sd, THS_FILTER_MODE_480I_576I);
++	else if (norm & (V4L2_STD_525P_60 | V4L2_STD_625P_50))
++		return ths7353_setvalue(sd, THS_FILTER_MODE_480P_576P);
++	else if (norm & (V4L2_STD_720P_60 | V4L2_STD_720P_50 |
++		 V4L2_STD_1080I_60 | V4L2_STD_1080I_50))
++		return ths7353_setvalue(sd, THS_FILTER_MODE_720P_1080I);
++	else if (norm & (V4L2_STD_1080P_60 | V4L2_STD_1080P_50))
++		return ths7353_setvalue(sd, THS_FILTER_MODE_1080P);
++	else
++		return -EINVAL;
++}
++
++static int ths7353_g_chip_ident(struct v4l2_subdev *sd,
++				struct v4l2_dbg_chip_ident *chip)
++{
++	struct i2c_client *client = v4l2_get_subdevdata(sd);
++
++	return v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_THS7353, 0);
++}
++
++static const struct v4l2_subdev_video_ops ths7353_video_ops = {
++	.s_std_output	= ths7353_s_std_output,
++};
++
++static const struct v4l2_subdev_core_ops ths7353_core_ops = {
++	.g_chip_ident = ths7353_g_chip_ident,
++};
++
++static const struct v4l2_subdev_ops ths7353_ops = {
++	.core	= &ths7353_core_ops,
++	.video 	= &ths7353_video_ops,
++};
++
++static int ths7353_probe(struct i2c_client *client,
++			const struct i2c_device_id *id)
++{
++	struct v4l2_subdev *sd;
++
++	if (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))
++		return -ENODEV;
++
++	v4l_info(client, "chip found @ 0x%x (%s)\n",
++			client->addr << 1, client->adapter->name);
++
++	if (!client->dev.platform_data) {
++		v4l_warn(client, "No platform data!!\n");
++		ths7353_luma_channel = THS7353_DEF_LUMA_CHANNEL;
++	} else {
++		ths7353_luma_channel = (int)(client->dev.platform_data);
++		if ((ths7353_luma_channel < THS7353_CHANNEL_1) ||
++				(ths7353_luma_channel > THS7353_CHANNEL_3)) {
++			v4l_warn(client, "Wring Luma Channel!!\n");
++			ths7353_luma_channel = THS7353_DEF_LUMA_CHANNEL;
++		}
++	}
++
++	sd = kzalloc(sizeof(struct v4l2_subdev), GFP_KERNEL);
++	if (sd == NULL)
++		return -ENOMEM;
++
++	v4l2_i2c_subdev_init(sd, client, &ths7353_ops);
++
++	return ths7353_setvalue(sd, THS_FILTER_MODE_480I_576I);
++}
++
++static int ths7353_remove(struct i2c_client *client)
++{
++	struct v4l2_subdev *sd = i2c_get_clientdata(client);
++
++	v4l2_device_unregister_subdev(sd);
++	kfree(sd);
++
++	return 0;
++}
++
++static const struct i2c_device_id ths7353_id[] = {
++	{"ths7353", 0},
++	{},
++};
++
++MODULE_DEVICE_TABLE(i2c, ths7353_id);
++
++static struct i2c_driver ths7353_driver = {
++	.driver = {
++		.owner	= THIS_MODULE,
++		.name	= "ths7353",
++	},
++	.probe		= ths7353_probe,
++	.remove		= ths7353_remove,
++	.id_table	= ths7353_id,
++};
++
++static int __init ths7353_init(void)
++{
++	return i2c_add_driver(&ths7353_driver);
++}
++
++static void __exit ths7353_exit(void)
++{
++	i2c_del_driver(&ths7353_driver);
++}
++
++module_init(ths7353_init);
++module_exit(ths7353_exit);
++
+--- /dev/null
++++ b/include/media/davinci/dm365_ccdc.h
+@@ -0,0 +1,722 @@
++/*
++ * Copyright (C) 2008-2009 Texas Instruments Inc
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
++ *
++ * ccdc header file for DM365 ISIF
++ */
++
++#ifndef _DM365_CCDC_H
++#define _DM365_CCDC_H
++#include <media/davinci/ccdc_types.h>
++#include <media/davinci/vpfe_types.h>
++/**
++ * ccdc float type S8Q8/U8Q8
++ */
++struct ccdc_float_8 {
++	/* 8 bit integer part */
++	unsigned char integer;
++	/* 8 bit decimal part */
++	unsigned char decimal;
++};
++
++/**
++ * brief ccdc float type U16Q16/S16Q16
++ */
++struct ccdc_float_16 {
++	/* 16 bit integer part */
++	unsigned short integer;
++	/* 16 bit decimal part */
++	unsigned short decimal;
++};
++
++/*
++ * ccdc image(target) window parameters
++ */
++struct ccdc_cropwin {
++	/* horzontal offset of the top left corner in pixels */
++	unsigned int left;
++	/* vertical offset of the top left corner in pixels */
++	unsigned int top;
++	/* width in pixels of the rectangle */
++	unsigned int width;
++	/* height in lines of the rectangle */
++	unsigned int height;
++};
++
++/************************************************************************
++ *   Vertical Defect Correction parameters
++ ***********************************************************************/
++
++/**
++ * vertical defect correction methods
++ */
++enum ccdc_vdfc_corr_mode {
++	/* Defect level subtraction. Just fed through if saturating */
++	CCDC_VDFC_NORMAL,
++	/**
++	 * Defect level subtraction. Horizontal interpolation ((i-2)+(i+2))/2
++	 * if data saturating
++	 */
++	CCDC_VDFC_HORZ_INTERPOL_IF_SAT,
++	/* Horizontal interpolation (((i-2)+(i+2))/2) */
++	CCDC_VDFC_HORZ_INTERPOL
++};
++
++/**
++ * Max Size of the Vertical Defect Correction table
++ */
++#define CCDC_VDFC_TABLE_SIZE 8
++
++/**
++ * Values used for shifting up the vdfc defect level
++ */
++enum ccdc_vdfc_shift {
++	/* No Shift */
++	CCDC_VDFC_NO_SHIFT,
++	/* Shift by 1 bit */
++	CCDC_VDFC_SHIFT_1,
++	/* Shift by 2 bit */
++	CCDC_VDFC_SHIFT_2,
++	/* Shift by 3 bit */
++	CCDC_VDFC_SHIFT_3,
++	/* Shift by 4 bit */
++	CCDC_VDFC_SHIFT_4
++};
++
++/**
++ * Defect Correction (DFC) table entry
++ */
++struct ccdc_vdfc_entry {
++	/* vertical position of defect */
++	unsigned short pos_vert;
++	/* horizontal position of defect */
++	unsigned short pos_horz;
++	/**
++	 * Defect level of Vertical line defect position. This is subtracted
++	 * from the data at the defect position
++	 */
++	unsigned char level_at_pos;
++	/**
++	 * Defect level of the pixels upper than the vertical line defect.
++	 * This is subtracted from the data
++	 */
++	unsigned char level_up_pixels;
++	/**
++	 * Defect level of the pixels lower than the vertical line defect.
++	 * This is subtracted from the data
++	 */
++	unsigned char level_low_pixels;
++};
++
++/**
++ * Structure for Defect Correction (DFC) parameter
++ */
++struct ccdc_dfc {
++	/* enable vertical defect correction */
++	unsigned char en;
++	/* Correction methods */
++	enum ccdc_vdfc_corr_mode corr_mode;
++	/**
++	 * 0 - whole line corrected, 1 - not
++	 * pixels upper than the defect
++	 */
++	unsigned char corr_whole_line;
++	/**
++	 * defect level shift value. level_at_pos, level_upper_pos,
++	 * and level_lower_pos can be shifted up by this value
++	 */
++	enum ccdc_vdfc_shift def_level_shift;
++	/* defect saturation level */
++	unsigned short def_sat_level;
++	/* number of vertical defects. Max is CCDC_VDFC_TABLE_SIZE */
++	short num_vdefects;
++	/* VDFC table ptr */
++	struct ccdc_vdfc_entry table[CCDC_VDFC_TABLE_SIZE];
++};
++
++/************************************************************************
++*   Digital/Black clamp or DC Subtract parameters
++************************************************************************/
++/**
++ * Horizontal Black Clamp modes
++ */
++enum ccdc_horz_bc_mode {
++	/**
++	 * Horizontal clamp disabled. Only vertical clamp
++	 * value is subtracted
++	 */
++	CCDC_HORZ_BC_DISABLE,
++	/**
++	 * Horizontal clamp value is calculated and subtracted
++	 * from image data along with vertical clamp value
++	 */
++	CCDC_HORZ_BC_CLAMP_CALC_ENABLED,
++	/**
++	 * Horizontal clamp value calculated from previous image
++	 * is subtracted from image data along with vertical clamp
++	 * value. How the horizontal clamp value for the first image
++	 * is calculated in this case ???
++	 */
++	CCDC_HORZ_BC_CLAMP_NOT_UPDATED
++};
++
++/**
++ * Base window selection for Horizontal Black Clamp calculations
++ */
++enum ccdc_horz_bc_base_win_sel {
++	/* Select Most left window for bc calculation */
++	CCDC_SEL_MOST_LEFT_WIN,
++
++	/* Select Most right window for bc calculation */
++	CCDC_SEL_MOST_RIGHT_WIN,
++};
++
++/* Size of window in horizontal direction for horizontal bc */
++enum ccdc_horz_bc_sz_h {
++	CCDC_HORZ_BC_SZ_H_2PIXELS,
++	CCDC_HORZ_BC_SZ_H_4PIXELS,
++	CCDC_HORZ_BC_SZ_H_8PIXELS,
++	CCDC_HORZ_BC_SZ_H_16PIXELS
++};
++
++/* Size of window in vertcal direction for vertical bc */
++enum ccdc_horz_bc_sz_v {
++	CCDC_HORZ_BC_SZ_H_32PIXELS,
++	CCDC_HORZ_BC_SZ_H_64PIXELS,
++	CCDC_HORZ_BC_SZ_H_128PIXELS,
++	CCDC_HORZ_BC_SZ_H_256PIXELS
++};
++
++/**
++ * Structure for Horizontal Black Clamp config params
++ */
++struct ccdc_horz_bclamp {
++	/* horizontal clamp mode */
++	enum ccdc_horz_bc_mode mode;
++	/**
++	 * pixel value limit enable.
++	 *  0 - limit disabled
++	 *  1 - pixel value limited to 1023
++	 */
++	unsigned char clamp_pix_limit;
++	/**
++	 * Select most left or right window for clamp val
++	 * calculation
++	 */
++	enum ccdc_horz_bc_base_win_sel base_win_sel_calc;
++	/* Window count per color for calculation. range 1-32 */
++	unsigned char win_count_calc;
++	/* Window start position - horizontal for calculation. 0 - 8191 */
++	unsigned short win_start_h_calc;
++	/* Window start position - vertical for calculation 0 - 8191 */
++	unsigned short win_start_v_calc;
++	/* Width of the sample window in pixels for calculation */
++	enum ccdc_horz_bc_sz_h win_h_sz_calc;
++	/* Height of the sample window in pixels for calculation */
++	enum ccdc_horz_bc_sz_v win_v_sz_calc;
++};
++
++/**
++ * Black Clamp vertical reset values
++ */
++enum ccdc_vert_bc_reset_val_sel {
++	/* Reset value used is the clamp value calculated */
++	CCDC_VERT_BC_USE_HORZ_CLAMP_VAL,
++	/* Reset value used is reset_clamp_val configured */
++	CCDC_VERT_BC_USE_CONFIG_CLAMP_VAL,
++	/* No update, previous image value is used */
++	CCDC_VERT_BC_NO_UPDATE
++};
++
++enum ccdc_vert_bc_sz_h {
++	CCDC_VERT_BC_SZ_H_2PIXELS,
++	CCDC_VERT_BC_SZ_H_4PIXELS,
++	CCDC_VERT_BC_SZ_H_8PIXELS,
++	CCDC_VERT_BC_SZ_H_16PIXELS,
++	CCDC_VERT_BC_SZ_H_32PIXELS,
++	CCDC_VERT_BC_SZ_H_64PIXELS
++};
++
++/**
++ * Structure for Vetical Black Clamp configuration params
++ */
++struct ccdc_vert_bclamp {
++	/* Reset value selection for vertical clamp calculation */
++	enum ccdc_vert_bc_reset_val_sel reset_val_sel;
++	/* U12 value if reset_sel = CCDC_BC_VERT_USE_CONFIG_CLAMP_VAL */
++	unsigned short reset_clamp_val;
++	/**
++	 * U8Q8. Line average coefficient used in vertical clamp
++	 * calculation
++	 */
++	unsigned char line_ave_coef;
++	/* Width in pixels of the optical black region used for calculation. */
++	enum ccdc_vert_bc_sz_h ob_h_sz_calc;
++	/* Height of the optical black region for calculation */
++	unsigned short ob_v_sz_calc;
++	/* Optical black region start position - horizontal. 0 - 8191 */
++	unsigned short ob_start_h;
++	/* Optical black region start position - vertical 0 - 8191 */
++	unsigned short ob_start_v;
++};
++
++/**
++ * Structure for Black Clamp configuration params
++ */
++struct ccdc_black_clamp {
++	/**
++	 * this offset value is added irrespective of the clamp
++	 * enable status. S13
++	 */
++	unsigned short dc_offset;
++	/**
++	 * Enable black/digital clamp value to be subtracted
++	 * from the image data
++	 */
++	unsigned char en;
++	/**
++	 * black clamp mode. same/separate clamp for 4 colors
++	 * 0 - disable - same clamp value for all colors
++	 * 1 - clamp value calculated separately for all colors
++	 */
++	unsigned char bc_mode_color;
++	/* Vrtical start position for bc subtraction */
++	unsigned short vert_start_sub;
++	/* Black clamp for horizontal direction */
++	struct ccdc_horz_bclamp horz;
++	/* Black clamp for vertical direction */
++	struct ccdc_vert_bclamp vert;
++};
++
++/*************************************************************************
++** Color Space Convertion (CSC)
++*************************************************************************/
++/**
++ * Number of Coefficient values used for CSC
++ */
++#define CCDC_CSC_NUM_COEFF 16
++
++/*************************************************************************
++**  Color Space Conversion parameters
++*************************************************************************/
++/**
++ * Structure used for CSC config params
++ */
++struct ccdc_color_space_conv {
++	/* Enable color space conversion */
++	unsigned char en;
++	/**
++	 * csc coeffient table. S8Q5, M00 at index 0, M01 at index 1, and
++	 * so forth
++	 */
++	struct ccdc_float_8 coeff[CCDC_CSC_NUM_COEFF];
++};
++
++/**
++ * CCDC image data size
++ */
++enum ccdc_data_size {
++	/* 8 bits */
++	CCDC_8_BITS,
++	/* 9 bits */
++	CCDC_9_BITS,
++	/* 10 bits */
++	CCDC_10_BITS,
++	/* 11 bits */
++	CCDC_11_BITS,
++	/* 12 bits */
++	CCDC_12_BITS,
++	/* 13 bits */
++	CCDC_13_BITS,
++	/* 14 bits */
++	CCDC_14_BITS,
++	/* 15 bits */
++	CCDC_15_BITS,
++	/* 16 bits */
++	CCDC_16_BITS
++};
++
++/**
++ * CCDC image data shift to right
++ */
++enum ccdc_datasft {
++	/* No Shift */
++	CCDC_NO_SHIFT,
++	/* 1 bit Shift */
++	CCDC_1BIT_SHIFT,
++	/* 2 bit Shift */
++	CCDC_2BIT_SHIFT,
++	/* 3 bit Shift */
++	CCDC_3BIT_SHIFT,
++	/* 4 bit Shift */
++	CCDC_4BIT_SHIFT,
++	/* 5 bit Shift */
++	CCDC_5BIT_SHIFT,
++	/* 6 bit Shift */
++	CCDC_6BIT_SHIFT
++};
++
++/**
++ * MSB of image data connected to sensor port
++ */
++enum ccdc_data_msb {
++	/* MSB b15 */
++	CCDC_BIT_MSB_15,
++	/* MSB b14 */
++	CCDC_BIT_MSB_14,
++	/* MSB b13 */
++	CCDC_BIT_MSB_13,
++	/* MSB b12 */
++	CCDC_BIT_MSB_12,
++	/* MSB b11 */
++	CCDC_BIT_MSB_11,
++	/* MSB b10 */
++	CCDC_BIT_MSB_10,
++	/* MSB b9 */
++	CCDC_BIT_MSB_9,
++	/* MSB b8 */
++	CCDC_BIT_MSB_8,
++	/* MSB b7 */
++	CCDC_BIT_MSB_7
++};
++
++/*************************************************************************
++**  Black  Compensation parameters
++*************************************************************************/
++/**
++ * Structure used for Black Compensation
++ */
++struct ccdc_black_comp {
++	/* Comp for Red */
++	char r_comp;
++	/* Comp for Gr */
++	char gr_comp;
++	/* Comp for Blue */
++	char b_comp;
++	/* Comp for Gb */
++	char gb_comp;
++};
++
++/*************************************************************************
++**  Gain parameters
++*************************************************************************/
++/**
++ * Structure for Gain parameters
++ */
++struct ccdc_gain {
++	/* Gain for Red or ye */
++	struct ccdc_float_16 r_ye;
++	/* Gain for Gr or cy */
++	struct ccdc_float_16 gr_cy;
++	/* Gain for Gb or g */
++	struct ccdc_float_16 gb_g;
++	/* Gain for Blue or mg */
++	struct ccdc_float_16 b_mg;
++};
++
++/**
++ * Predicator types for DPCM compression
++ */
++enum ccdc_dpcm_predictor {
++	/* Choose Predictor1 for DPCM compression */
++	CCDC_DPCM_PRED1,
++	/* Choose Predictor2 for DPCM compression */
++	CCDC_DPCM_PRED2
++};
++
++#define CCDC_LINEAR_TAB_SIZE 192
++/*************************************************************************
++**  Linearization parameters
++*************************************************************************/
++/**
++ * Structure for Sensor data linearization
++ */
++struct ccdc_linearize {
++	/* Enable or Disable linearization of data */
++	unsigned char en;
++	/* Shift value applied */
++	enum ccdc_datasft corr_shft;
++	/* scale factor applied U11Q10 */
++	struct ccdc_float_16 scale_fact;
++	/* Size of the linear table */
++	unsigned short table[CCDC_LINEAR_TAB_SIZE];
++};
++
++enum ccdc_cfa_pattern {
++	CCDC_CFA_PAT_MOSAIC,
++	CCDC_CFA_PAT_STRIPE
++};
++
++enum ccdc_colpats {
++	CCDC_RED,
++	CCDC_GREEN_RED,
++	CCDC_GREEN_BLUE,
++	CCDC_BLUE
++};
++
++struct ccdc_col_pat {
++	enum ccdc_colpats olop;
++	enum ccdc_colpats olep;
++	enum ccdc_colpats elop;
++	enum ccdc_colpats elep;
++};
++
++/*************************************************************************
++**  CCDC Raw configuration parameters
++*************************************************************************/
++enum ccdc_fmt_mode {
++	CCDC_SPLIT,
++	CCDC_COMBINE
++};
++
++enum ccdc_lnum {
++	CCDC_1LINE,
++	CCDC_2LINES,
++	CCDC_3LINES,
++	CCDC_4LINES
++};
++
++enum ccdc_line {
++	CCDC_1STLINE,
++	CCDC_2NDLINE,
++	CCDC_3RDLINE,
++	CCDC_4THLINE
++};
++
++struct ccdc_fmtplen {
++	/**
++	 * number of program entries for SET0, range 1 - 16
++	 * when fmtmode is CCDC_SPLIT, 1 - 8 when fmtmode is
++	 * CCDC_COMBINE
++	 */
++	unsigned short plen0;
++	/**
++	 * number of program entries for SET1, range 1 - 16
++	 * when fmtmode is CCDC_SPLIT, 1 - 8 when fmtmode is
++	 * CCDC_COMBINE
++	 */
++	unsigned short plen1;
++	/**
++	 * number of program entries for SET2, range 1 - 16
++	 * when fmtmode is CCDC_SPLIT, 1 - 8 when fmtmode is
++	 * CCDC_COMBINE
++	 */
++	unsigned short plen2;
++	/**
++	 * number of program entries for SET3, range 1 - 16
++	 * when fmtmode is CCDC_SPLIT, 1 - 8 when fmtmode is
++	 * CCDC_COMBINE
++	 */
++	unsigned short plen3;
++};
++
++struct ccdc_fmt_cfg {
++	/* Split or combine or line alternate */
++	enum ccdc_fmt_mode fmtmode;
++	/* enable or disable line alternating mode */
++	unsigned char ln_alter_en;
++	/* Split/combine line number */
++	enum ccdc_lnum lnum;
++	/* Address increment Range 1 - 16 */
++	unsigned int addrinc;
++};
++
++struct ccdc_fmt_addr_ptr {
++	/* Initial address */
++	unsigned int init_addr;
++	/* output line number */
++	enum ccdc_line out_line;
++};
++
++struct ccdc_fmtpgm_ap {
++	/* program address pointer */
++	unsigned char pgm_aptr;
++	/* program address increment or decrement */
++	unsigned char pgmupdt;
++};
++
++struct ccdc_data_formatter {
++	/* Enable/Disable data formatter */
++	unsigned char en;
++	/* data formatter configuration */
++	struct ccdc_fmt_cfg cfg;
++	/* Formatter program entries length */
++	struct ccdc_fmtplen plen;
++	/* first pixel in a line fed to formatter */
++	unsigned short fmtrlen;
++	/* HD interval for output line. Only valid when split line */
++	unsigned short fmthcnt;
++	/* formatter address pointers */
++	struct ccdc_fmt_addr_ptr fmtaddr_ptr[16];
++	/* program enable/disable */
++	unsigned char pgm_en[32];
++	/* program address pointers */
++	struct ccdc_fmtpgm_ap fmtpgm_ap[32];
++};
++
++struct ccdc_df_csc {
++	/* Color Space Conversion confguration, 0 - csc, 1 - df */
++	unsigned int df_or_csc;
++	/* csc configuration valid if df_or_csc is 0 */
++	struct ccdc_color_space_conv csc;
++	/* data formatter configuration valid if df_or_csc is 1 */
++	struct ccdc_data_formatter df;
++	/* start pixel in a line at the input */
++	unsigned int start_pix;
++	/* number of pixels in input line */
++	unsigned int num_pixels;
++	/* start line at the input */
++	unsigned int start_line;
++	/* number of lines at the input */
++	unsigned int num_lines;
++};
++
++struct ccdc_gain_offsets_adj {
++	/* Gain adjustment per color */
++	struct ccdc_gain gain;
++	/* Offset adjustment */
++	unsigned short offset;
++	/* Enable or Disable Gain adjustment for SDRAM data */
++	unsigned char gain_sdram_en;
++	/* Enable or Disable Gain adjustment for IPIPE data */
++	unsigned char gain_ipipe_en;
++	/* Enable or Disable Gain adjustment for H3A data */
++	unsigned char gain_h3a_en;
++	/* Enable or Disable Gain adjustment for SDRAM data */
++	unsigned char offset_sdram_en;
++	/* Enable or Disable Gain adjustment for IPIPE data */
++	unsigned char offset_ipipe_en;
++	/* Enable or Disable Gain adjustment for H3A data */
++	unsigned char offset_h3a_en;
++};
++
++struct ccdc_cul {
++	/* Horizontal Cull pattern for odd lines */
++	unsigned char hcpat_odd;
++	/* Horizontal Cull pattern for even lines */
++	unsigned char hcpat_even;
++	/* Vertical Cull pattern */
++	unsigned char vcpat;
++	/* Enable or disable lpf. Apply when cull is enabled */
++	unsigned char en_lpf;
++};
++
++enum ccdc_compress_alg {
++	CCDC_ALAW,
++	CCDC_DPCM,
++	CCDC_NO_COMPRESSION
++};
++
++struct ccdc_compress {
++	/* Enable or diable A-Law or DPCM compression. */
++	enum ccdc_compress_alg alg;
++	/* Predictor for DPCM compression */
++	enum ccdc_dpcm_predictor pred;
++};
++
++/* all the stuff in this struct will be provided by userland */
++struct ccdc_config_params_raw {
++	/* Linearization parameters for image sensor data input */
++	struct ccdc_linearize linearize;
++	/* Data formatter or CSC */
++	struct ccdc_df_csc df_csc;
++	/* Defect Pixel Correction (DFC) confguration */
++	struct ccdc_dfc dfc;
++	/* Black/Digital Clamp configuration */
++	struct ccdc_black_clamp bclamp;
++	/* Gain, offset adjustments */
++	struct ccdc_gain_offsets_adj gain_offset;
++	/* Culling */
++	struct ccdc_cul culling;
++	/* A-Law and DPCM compression options */
++	struct ccdc_compress compress;
++	/* horizontal offset for Gain/LSC/DFC */
++	unsigned short horz_offset;
++	/* vertical offset for Gain/LSC/DFC */
++	unsigned short vert_offset;
++	/* color pattern for field 0 */
++	struct ccdc_col_pat col_pat_field0;
++	/* color pattern for field 1 */
++	struct ccdc_col_pat col_pat_field1;
++	/* data size from 8 to 16 bits */
++	enum ccdc_data_size data_size;
++	/* Data shift applied before storing to SDRAM */
++	enum ccdc_datasft data_shift;
++	/* enable input test pattern generation */
++	unsigned char test_pat_gen;
++};
++
++#ifdef __KERNEL__
++struct ccdc_ycbcr_config {
++	/* ccdc pixel format */
++	enum ccdc_pixfmt pix_fmt;
++	/* ccdc frame format */
++	enum ccdc_frmfmt frm_fmt;
++	/* CCDC crop window */
++	struct v4l2_rect win;
++	/* field polarity */
++	enum vpfe_pin_pol fid_pol;
++	/* interface VD polarity */
++	enum vpfe_pin_pol vd_pol;
++	/* interface HD polarity */
++	enum vpfe_pin_pol hd_pol;
++	/* ccdc pix order. Only used for ycbcr capture */
++	enum ccdc_pixorder pix_order;
++	/* ccdc buffer type. Only used for ycbcr capture */
++	enum ccdc_buftype buf_type;
++};
++
++struct ccdc_params_raw {
++	/* ccdc pixel format */
++	enum ccdc_pixfmt pix_fmt;
++	/* ccdc frame format */
++	enum ccdc_frmfmt frm_fmt;
++	/* video window */
++	struct v4l2_rect win;
++	/* field polarity */
++	enum vpfe_pin_pol fid_pol;
++	/* interface VD polarity */
++	enum vpfe_pin_pol vd_pol;
++	/* interface HD polarity */
++	enum vpfe_pin_pol hd_pol;
++	/* buffer type. Applicable for interlaced mode */
++	enum ccdc_buftype buf_type;
++	/* Gain values */
++	struct ccdc_gain gain;
++	/* cfa pattern */
++	enum ccdc_cfa_pattern cfa_pat;
++	/* Data MSB position */
++	enum ccdc_data_msb data_msb;
++	/* Enable horizontal flip */
++	unsigned char horz_flip_en;
++	/* Enable image invert vertically */
++	unsigned char image_invert_en;
++
++	/*all the userland defined stuff*/
++	struct ccdc_config_params_raw config_params;
++};
++
++enum ccdc_data_pack {
++	CCDC_PACK_16BIT,
++	CCDC_PACK_12BIT,
++	CCDC_PACK_8BIT
++};
++
++#define CCDC_WIN_NTSC				{0, 0, 720, 480}
++#define CCDC_WIN_VGA				{0, 0, 640, 480}
++#define ISP5_CCDCMUX				0x20
++#endif
++#endif
+--- a/include/media/davinci/dm644x_ccdc.h
++++ b/include/media/davinci/dm644x_ccdc.h
+@@ -131,7 +131,7 @@ struct ccdc_config_params_raw {
+ #define NUM_EXTRALINES		8
+ 
+ /* settings for commonly used video formats */
+-#define CCDC_WIN_PAL     {0, 0, 720, 576}
++#define CCDC_WIN_NTSC     {0, 0, 720, 480}
+ /* ntsc square pixel */
+ #define CCDC_WIN_VGA	{0, 0, (640 + NUM_EXTRAPIXELS), (480 + NUM_EXTRALINES)}
+ 
+--- /dev/null
++++ b/drivers/char/dm646x_pci_targetdrv.h
+@@ -0,0 +1,206 @@
++/*
++ * dm646x_pci_targetdrv.h
++ *  Description:
++ *  DM6467 PCI Target driver header file.
++ *
++ *
++ * Copyright (C) 2009, Texas Instruments, Incorporated
++ *
++ *  This program is free software; you can distribute it and/or modify it
++ *  under the terms of the GNU General Public License (Version 2) as
++ *  published by the Free Software Foundation.
++ *
++ *  This program is distributed in the hope it will be useful, but WITHOUT
++ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
++ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
++ *  for more details.
++ *
++ *  You should have received a copy of the GNU General Public License along
++ *  with this program; if not, write to the Free Software Foundation, Inc.,
++ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
++ */
++
++
++#ifndef __PCIDRV_H__
++#define __PCIDRV_H__
++
++#include <linux/types.h>
++
++/** ============================================================================
++ *  @const  DM646X_PCI_MODFILE
++ *
++ *  @desc   Name of the device node created
++ *  ============================================================================
++ */
++#define DM646X_PCI_MODFILE	    ("dm646xpci")
++
++#ifdef __KERNEL__
++
++/** ============================================================================
++ *  @const  PCI_BASE_ADDRESS
++ *
++ *  @desc   Base address of PCI memory space.
++ *  ============================================================================
++ */
++#define CHIP_DM6467
++
++#define PCI_MEMORY_SPACE_BASE_ADDR  (0x30000000)
++
++/** ============================================================================
++ *  @const  PCI_TI_VENDOR
++ *
++ *  @desc   TI Vendor ID.
++ *  ============================================================================
++ */
++#define PCI_TI_VENDOR               (0x104c)
++/** ============================================================================
++ *  @const  PCI_TI_DEVICE
++ *
++ *  @desc   PCI Device ID.
++ *  ============================================================================
++ */
++#define PCI_TI_DEVICE               (0xB002)
++
++/** ============================================================================
++ *  @const   DM6467PCI_MMRREG_BASE
++ *
++ *  @desc    Base address of all register bank
++ *  ============================================================================
++ */
++#define DM6467PCI_MMRREG_BASE       (0x01C00000)
++
++/** ============================================================================
++ *  @const   DM6467PCI_PCIREG_BASE
++ *
++ *  @desc    Base address of PCI backend registers.
++ *  ============================================================================
++ */
++#define DM6467PCI_PCIREG_BASE		(0x01C1A000)
++
++/** ============================================================================
++ *  @const   DM6467PCI_DEVREG_BASE
++ *
++ *  @desc    Base address of Device config registers.
++ *  ============================================================================
++ */
++#define DM6467PCI_DEVREG_BASE		(0x01C40000)
++
++/** ============================================================================
++ *  @const   DM6467PCI_SOFTINT0_MASK
++ *
++ *  @desc    Mask for generating soft int0 (DSP->GPP)
++ *  ============================================================================
++ */
++#define DM6467PCI_SOFTINT0_MASK		(0x01000000)
++
++/** ============================================================================
++ *  @const   DM6467PCI_SOFTINT1_MASK
++ *
++ *  @desc    Mask for generating soft int1 (GPP->DSP)
++ *  ============================================================================
++ */
++#define DM6467PCI_SOFTINT1_MASK		(0x02000000)
++
++/** ============================================================================
++ *  @const   DM6467PCI_SOFTINT1_MASK
++ *
++ *  @desc    Mask for generating soft int1 (GPP->DSP)
++ *  ============================================================================
++ */
++#define DM6467PCI_SOFTINT2_MASK		(0x04000000)
++
++/** ============================================================================
++ *  @const   DM6467PCI_SOFTINT1_MASK
++ *
++ *  @desc    Mask for generating soft int1 (GPP->DSP)
++ *  ============================================================================
++ */
++#define DM6467PCI_SOFTINT3_MASK		(0x08000000)
++
++/** ============================================================================
++ *  @const   DM6467PCI_INTSTATUS_MASK
++ *
++ *  @desc    Bitmask for Interrupt status (DSP->GPP)
++ *  ============================================================================
++ */
++#define DM6467PCI_INTSTATUS_MASK	(0x00080000)
++
++/** ============================================================================
++ *  @const   DM6467PCI_PCIADLEN
++ *
++ *  @desc    Length each segment of addressable PCI Space..
++ *  ============================================================================
++ */
++#define DM6467PCI_PCIADLEN          (0x00800000)
++
++/** ============================================================================
++ *  @const   DM6467PCI_PCIADWRBITMASK
++ *
++ *  @desc    Mask indicating writeable bits in PCI Address Window registers.
++ *  ============================================================================
++ */
++#define DM6467PCI_PCIADWRBITMASK    (0xFF800000)
++
++/** ============================================================================
++ *  @const   DM6467PCI_PAGEWRBITMASK
++ *
++ *  @desc    Mask indicating writeable bits in PCI Base Address Mask Register5.
++ *  ============================================================================
++ */
++#define DM6467PCI_PAGEWRBITMASK     (0xFF800000)
++
++
++/*
++ *  Device Register Offsets
++ */
++#define BOOTSTAT			0x10
++
++/*
++ *  PCI Register Offsets
++ */
++#define PCISTATSET                      0x010
++#define PCISTATCLR                      0x014
++#define PCIHINTSET                      0x020
++#define PCIHINTCLR                      0x024
++#define PCIBINTSET                      0x030
++#define PCIBINTCLR                      0x034
++#define PCIVENDEVMIR                    0x100
++#define PCICSRMIR                       0x104
++#define PCICLREVMIR                     0x108
++#define PCICLINEMIR                     0x10C
++#define PCIBARMSK(n)                    (0x110 + (4*n))     /* 6 Registers */
++#define PCISUBIDMIR                     0x12C
++#define PCICPBPTRMIR                    0x134
++#define PCILGINTMIR                     0x13C
++#define PCISLVCNTL                      0x180
++#define PCIBARTRL(n)                    (0x1C0 + (4*n))     /* 6 Registers */
++#define PCIBARMIR(n)                    (0x1E0 + (4*n))     /* 6 Registers */
++#define PCIMCFGDAT                      0x300
++#define PCIMCFGADR                      0x304
++#define PCIMCFGCMD                      0x308
++#define PCIMSTCFG                       0x310
++#define PCIADDSUB(n)                    (0x314 + (4*n))     /* 32 Registers */
++#define PCIVENDEVPRG                    0x394
++#define PCICLREVPRG                     0x39C
++#define PCISUBIDPRG                     0x3A0
++#define PCIMAXLGPRG                     0x3A4
++#define PCICFGDONE                      0x3AC
++
++#endif  /*  __KERNEL__  */
++
++/* Arguments received by the remap BAR IOCTL */
++struct DM646x_Remap_Bar_Args {
++	u32 bar_number;
++	u32 new_window;
++};
++
++/* IOCTLs defined for the application as well as driver */
++#define DM646X_PCI_RUN_TCM_IMG  _IO('P', 1)
++#define DM646X_PCI_GEN_INTRPT   _IO('P', 2)
++#define DM646X_PCI_EDMA_XFER    _IOW('P', 3, unsigned int)
++#define DM646X_PCI_REMAP_BAR    _IOW('P', 4, unsigned int)
++#define DM646X_PCI_BOOT_IMAGE   _IOW('P', 5, unsigned int)
++
++#endif	/* __PCIDRV_H__ */
++
++
+--- /dev/null
++++ b/drivers/media/video/davinci/dm365_ccdc.c
+@@ -0,0 +1,1536 @@
++/*
++ * Copyright (C) 2008-2009 Texas Instruments Inc
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
++ *
++ * This is the isif hardware module for DM365.
++ * TODO: 1) Raw bayer parameter settings and bayer capture
++ *	 2) Add support for control ioctl
++ *	 3) Add support for linearization
++ *	 4) Test VPFE_CMD_S_CCDC_RAW_RARAMS ioctl
++ */
++#include <linux/delay.h>
++#include <linux/platform_device.h>
++#include <linux/uaccess.h>
++#include <linux/io.h>
++#include <linux/videodev2.h>
++#include <mach/mux.h>
++#include <media/davinci/dm365_ccdc.h>
++#include <media/davinci/vpss.h>
++#include "dm365_ccdc_regs.h"
++#include "ccdc_hw_device.h"
++
++static struct device *dev;
++
++/* Defauts for module configuation paramaters */
++static struct ccdc_config_params_raw ccdc_config_defaults = {
++	.linearize = {
++		.en = 0,
++		.corr_shft = CCDC_NO_SHIFT,
++		.scale_fact = {1, 0},
++	},
++	.df_csc = {
++		.df_or_csc = 0,
++		.csc = {
++			.en = 0
++		},
++	},
++	.dfc = {
++		.en = 0
++	},
++	.bclamp = {
++		.en = 0
++	},
++	.gain_offset = {
++		.gain = {
++			.r_ye = {1, 0},
++			.gr_cy = {1, 0},
++			.gb_g = {1, 0},
++			.b_mg = {1, 0},
++		},
++	},
++	.culling = {
++		.hcpat_odd = 0xff,
++		.hcpat_even = 0xff,
++		.vcpat = 0xff
++	},
++	.compress = {
++		.alg = CCDC_ALAW,
++	},
++};
++
++/* ISIF operation configuration */
++struct ccdc_oper_config {
++	enum vpfe_hw_if_type if_type;
++	struct ccdc_ycbcr_config ycbcr;
++	struct ccdc_params_raw bayer;
++	enum ccdc_data_pack data_pack;
++	void *__iomem base_addr;
++	void *__iomem linear_tbl0_addr;
++	void *__iomem linear_tbl1_addr;
++};
++
++static struct ccdc_oper_config ccdc_cfg = {
++	.ycbcr = {
++		.pix_fmt = CCDC_PIXFMT_YCBCR_8BIT,
++		.frm_fmt = CCDC_FRMFMT_INTERLACED,
++		.win = CCDC_WIN_NTSC,
++		.fid_pol = VPFE_PINPOL_POSITIVE,
++		.vd_pol = VPFE_PINPOL_POSITIVE,
++		.hd_pol = VPFE_PINPOL_POSITIVE,
++		.pix_order = CCDC_PIXORDER_CBYCRY,
++		.buf_type = CCDC_BUFTYPE_FLD_INTERLEAVED,
++	},
++	.bayer = {
++		.pix_fmt = CCDC_PIXFMT_RAW,
++		.frm_fmt = CCDC_FRMFMT_PROGRESSIVE,
++		.win = CCDC_WIN_VGA,
++		.fid_pol = VPFE_PINPOL_POSITIVE,
++		.vd_pol = VPFE_PINPOL_POSITIVE,
++		.hd_pol = VPFE_PINPOL_POSITIVE,
++		.gain = {
++			.r_ye = {1, 0},
++			.gr_cy = {1, 0},
++			.gb_g = {1, 0},
++			.b_mg = {1, 0},
++		},
++		.cfa_pat = CCDC_CFA_PAT_MOSAIC,
++		.data_msb = CCDC_BIT_MSB_11,
++		.config_params = {
++			.data_size = CCDC_12_BITS,
++			.data_shift = CCDC_NO_SHIFT,
++			.col_pat_field0 = {
++				.olop = CCDC_GREEN_BLUE,
++				.olep = CCDC_BLUE,
++				.elop = CCDC_RED,
++				.elep = CCDC_GREEN_RED,
++			},
++			.col_pat_field1 = {
++				.olop = CCDC_GREEN_BLUE,
++				.olep = CCDC_BLUE,
++				.elop = CCDC_RED,
++				.elep = CCDC_GREEN_RED,
++			},
++			.test_pat_gen = 0,
++		},
++	},
++	.data_pack = CCDC_DATA_PACK8,
++};
++
++/* Raw Bayer formats */
++static u32 ccdc_raw_bayer_pix_formats[] =
++		{V4L2_PIX_FMT_SBGGR8, V4L2_PIX_FMT_SBGGR16};
++
++/* Raw YUV formats */
++static u32 ccdc_raw_yuv_pix_formats[] =
++		{V4L2_PIX_FMT_UYVY, V4L2_PIX_FMT_YUYV};
++
++/* register access routines */
++static inline u32 regr(u32 offset)
++{
++	return __raw_readl(ccdc_cfg.base_addr + offset);
++}
++
++static inline void regw(u32 val, u32 offset)
++{
++	__raw_writel(val, ccdc_cfg.base_addr + offset);
++}
++
++static inline u32 ccdc_merge(u32 mask, u32 val, u32 offset)
++{
++	u32 new_val = (regr(offset) & ~mask) | (val & mask);
++
++	regw(new_val, offset);
++	return new_val;
++}
++
++static inline void regw_lin_tbl(u32 val, u32 offset, int i)
++{
++	if (!i)
++		__raw_writel(val, ccdc_cfg.linear_tbl0_addr + offset);
++	else
++		__raw_writel(val, ccdc_cfg.linear_tbl1_addr + offset);
++}
++
++static void ccdc_disable_all_modules(void)
++{
++	/* disable BC */
++	regw(0, CLAMPCFG);
++	/* disable vdfc */
++	regw(0, DFCCTL);
++	/* disable CSC */
++	regw(0, CSCCTL);
++	/* disable linearization */
++	regw(0, LINCFG0);
++	/* disable other modules here as they are supported */
++}
++
++static void ccdc_enable(int en)
++{
++	if (!en) {
++		/* Before disable isif, disable all ISIF modules */
++		ccdc_disable_all_modules();
++		/**
++		 * wait for next VD. Assume lowest scan rate is 12 Hz. So
++		 * 100 msec delay is good enough
++		 */
++	}
++	msleep(100);
++	ccdc_merge(CCDC_SYNCEN_VDHDEN_MASK, en, SYNCEN);
++}
++
++static void ccdc_enable_output_to_sdram(int en)
++{
++	ccdc_merge(CCDC_SYNCEN_WEN_MASK, en << CCDC_SYNCEN_WEN_SHIFT, SYNCEN);
++}
++
++static void ccdc_config_culling(struct ccdc_cul *cul)
++{
++	u32 val;
++
++	/* Horizontal pattern */
++	val = (cul->hcpat_even) << CULL_PAT_EVEN_LINE_SHIFT;
++	val |= cul->hcpat_odd;
++	regw(val, CULH);
++
++	/* vertical pattern */
++	regw(cul->vcpat, CULV);
++
++	/* LPF */
++	ccdc_merge((CCDC_LPF_MASK << CCDC_LPF_SHIFT),
++		   (cul->en_lpf << CCDC_LPF_SHIFT), MODESET);
++}
++
++static void ccdc_config_gain_offset(void)
++{
++	struct ccdc_gain_offsets_adj *gain_off_ptr =
++		&ccdc_cfg.bayer.config_params.gain_offset;
++	u32 val;
++
++	val = ((gain_off_ptr->gain_sdram_en & 1) << GAIN_SDRAM_EN_SHIFT) |
++	((gain_off_ptr->gain_ipipe_en & 1) << GAIN_IPIPE_EN_SHIFT) |
++	((gain_off_ptr->gain_h3a_en & 1) << GAIN_H3A_EN_SHIFT) |
++	((gain_off_ptr->offset_sdram_en & 1) << OFST_SDRAM_EN_SHIFT) |
++	((gain_off_ptr->offset_ipipe_en & 1) << OFST_IPIPE_EN_SHIFT) |
++	((gain_off_ptr->offset_h3a_en & 1) << OFST_H3A_EN_SHIFT);
++
++	ccdc_merge(GAIN_OFFSET_EN_MASK, val, CGAMMAWD);
++
++	val = ((gain_off_ptr->gain.r_ye.integer	& GAIN_INTEGER_MASK)
++		<< GAIN_INTEGER_SHIFT);
++	val |= (ccdc_cfg.bayer.
++		config_params.gain_offset.gain.r_ye.decimal &
++		GAIN_DECIMAL_MASK);
++	regw(val, CRGAIN);
++
++	val = ((gain_off_ptr->gain.gr_cy
++		.integer & GAIN_INTEGER_MASK) << GAIN_INTEGER_SHIFT);
++	val |= (gain_off_ptr->gain.gr_cy
++		.decimal & GAIN_DECIMAL_MASK);
++	regw(val, CGRGAIN);
++
++	val = ((gain_off_ptr->gain.gb_g
++		.integer & GAIN_INTEGER_MASK) << GAIN_INTEGER_SHIFT);
++	val |= (gain_off_ptr->gain.gb_g
++		.decimal & GAIN_DECIMAL_MASK);
++	regw(val, CGBGAIN);
++
++	val = ((gain_off_ptr->gain.b_mg
++		.integer & GAIN_INTEGER_MASK) << GAIN_INTEGER_SHIFT);
++	val |= (gain_off_ptr->gain.b_mg
++		.decimal & GAIN_DECIMAL_MASK);
++	regw(val, CBGAIN);
++
++	regw((gain_off_ptr->offset &
++		OFFSET_MASK), COFSTA);
++}
++
++static void ccdc_restore_defaults(void)
++{
++	enum vpss_ccdc_source_sel source = VPSS_CCDCIN;
++	int i;
++
++	memcpy(&ccdc_cfg.bayer.config_params, &ccdc_config_defaults,
++		sizeof(struct ccdc_config_params_raw));
++
++	dev_dbg(dev, "\nstarting ccdc_restore_defaults...");
++	/* Enable clock to ISIF, IPIPEIF and BL */
++	vpss_enable_clock(VPSS_CCDC_CLOCK, 1);
++	vpss_enable_clock(VPSS_IPIPEIF_CLOCK, 1);
++	vpss_enable_clock(VPSS_BL_CLOCK, 1);
++
++	/* set all registers to default value */
++	for (i = 0; i <= 0x1f8; i += 4)
++		regw(0, i);
++
++	/* no culling support */
++	regw(0xffff, CULH);
++	regw(0xff, CULV);
++
++	/* Set default offset and gain */
++	ccdc_config_gain_offset();
++
++	vpss_select_ccdc_source(source);
++
++	dev_dbg(dev, "\nEnd of ccdc_restore_defaults...");
++}
++
++static int ccdc_open(struct device *device)
++{
++	dev = device;
++	ccdc_restore_defaults();
++	return 0;
++}
++
++/* This function will configure the window size to be capture in CCDC reg */
++static void ccdc_setwin(struct v4l2_rect *image_win,
++			enum ccdc_frmfmt frm_fmt, int ppc, int mode)
++{
++	int horz_start, horz_nr_pixels;
++	int vert_start, vert_nr_lines;
++	int mid_img = 0;
++
++	dev_dbg(dev, "\nStarting ccdc_setwin...");
++	/**
++	 * ppc - per pixel count. indicates how many pixels per cell
++	 * output to SDRAM. example, for ycbcr, it is one y and one c, so 2.
++	 * raw capture this is 1
++	 */
++	horz_start = image_win->left << (ppc - 1);
++	horz_nr_pixels = ((image_win->width) << (ppc - 1)) - 1;
++
++	/* Writing the horizontal info into the registers */
++	regw(horz_start & START_PX_HOR_MASK, SPH);
++	regw(horz_nr_pixels & NUM_PX_HOR_MASK, LNH);
++	vert_start = image_win->top;
++
++	if (frm_fmt == CCDC_FRMFMT_INTERLACED) {
++		vert_nr_lines = (image_win->height >> 1) - 1;
++		vert_start >>= 1;
++		/* To account for VD since line 0 doesn't have any data */
++		vert_start += 1;
++	} else {
++		/* To account for VD since line 0 doesn't have any data */
++		vert_start += 1;
++		vert_nr_lines = image_win->height - 1;
++		/* configure VDINT0 and VDINT1 */
++		mid_img = vert_start + (image_win->height / 2);
++		regw(mid_img, VDINT1);
++	}
++
++	if (!mode)
++		regw(0, VDINT0);
++	else
++		regw(vert_nr_lines, VDINT0);
++	regw(vert_start & START_VER_ONE_MASK, SLV0);
++	regw(vert_start & START_VER_TWO_MASK, SLV1);
++	regw(vert_nr_lines & NUM_LINES_VER, LNV);
++}
++
++static void ccdc_config_bclamp(struct ccdc_black_clamp *bc)
++{
++	u32 val;
++
++	/**
++	 * DC Offset is always added to image data irrespective of bc enable
++	 * status
++	 */
++	val = bc->dc_offset & CCDC_BC_DCOFFSET_MASK;
++	regw(val, CLDCOFST);
++
++	if (bc->en) {
++		val = (bc->bc_mode_color & CCDC_BC_MODE_COLOR_MASK) <<
++			CCDC_BC_MODE_COLOR_SHIFT;
++
++		/* Enable BC and horizontal clamp caculation paramaters */
++		val = val | 1 | ((bc->horz.mode & CCDC_HORZ_BC_MODE_MASK) <<
++		CCDC_HORZ_BC_MODE_SHIFT);
++
++		regw(val, CLAMPCFG);
++
++		if (bc->horz.mode != CCDC_HORZ_BC_DISABLE) {
++			/**
++			 * Window count for calculation
++			 * Base window selection
++			 * pixel limit
++			 * Horizontal size of window
++			 * vertical size of the window
++			 * Horizontal start position of the window
++			 * Vertical start position of the window
++			 */
++			val = (bc->horz.win_count_calc &
++				CCDC_HORZ_BC_WIN_COUNT_MASK) |
++				((bc->horz.base_win_sel_calc & 1)
++				<< CCDC_HORZ_BC_WIN_SEL_SHIFT) |
++				((bc->horz.clamp_pix_limit & 1)
++				<< CCDC_HORZ_BC_PIX_LIMIT_SHIFT) |
++				((bc->horz.win_h_sz_calc &
++				CCDC_HORZ_BC_WIN_H_SIZE_MASK)
++				<< CCDC_HORZ_BC_WIN_H_SIZE_SHIFT) |
++				((bc->horz.win_v_sz_calc &
++				CCDC_HORZ_BC_WIN_V_SIZE_MASK)
++				<< CCDC_HORZ_BC_WIN_V_SIZE_SHIFT);
++
++			regw(val, CLHWIN0);
++
++			val = (bc->horz.win_start_h_calc &
++				CCDC_HORZ_BC_WIN_START_H_MASK);
++			regw(val, CLHWIN1);
++
++			val =
++			    (bc->horz.
++			     win_start_v_calc & CCDC_HORZ_BC_WIN_START_V_MASK);
++			regw(val, CLHWIN2);
++		}
++
++		/* vertical clamp caculation paramaters */
++
++		/* OB H Valid */
++		val = (bc->vert.ob_h_sz_calc & CCDC_VERT_BC_OB_H_SZ_MASK);
++
++		/* Reset clamp value sel for previous line */
++		val |= ((bc->vert.reset_val_sel &
++			CCDC_VERT_BC_RST_VAL_SEL_MASK)
++			<< CCDC_VERT_BC_RST_VAL_SEL_SHIFT);
++
++		/* Line average coefficient */
++		val |= (bc->vert.line_ave_coef <<
++			CCDC_VERT_BC_LINE_AVE_COEF_SHIFT);
++		regw(val, CLVWIN0);
++
++		/* Configured reset value */
++		if (bc->vert.reset_val_sel ==
++		    CCDC_VERT_BC_USE_CONFIG_CLAMP_VAL) {
++			val =
++			    (bc->vert.
++			     reset_clamp_val & CCDC_VERT_BC_RST_VAL_MASK);
++			regw(val, CLVRV);
++		}
++
++		/* Optical Black horizontal start position */
++		val = (bc->vert.ob_start_h & CCDC_VERT_BC_OB_START_HORZ_MASK);
++		regw(val, CLVWIN1);
++
++		/* Optical Black vertical start position */
++		val = (bc->vert.ob_start_v & CCDC_VERT_BC_OB_START_VERT_MASK);
++		regw(val, CLVWIN2);
++
++		val = (bc->vert.ob_v_sz_calc & CCDC_VERT_BC_OB_VERT_SZ_MASK);
++		regw(val, CLVWIN3);
++
++		/* Vertical start position for BC subtraction */
++		val = (bc->vert_start_sub & CCDC_BC_VERT_START_SUB_V_MASK);
++		regw(val, CLSV);
++	}
++}
++
++static void ccdc_config_linearization(struct ccdc_linearize *linearize)
++{
++	u32 val, i;
++	if (!linearize->en) {
++		regw(0, LINCFG0);
++		return;
++	}
++
++	/* shift value for correction */
++	val = (linearize->corr_shft & CCDC_LIN_CORRSFT_MASK)
++	    << CCDC_LIN_CORRSFT_SHIFT;
++	/* enable */
++	val |= 1;
++	regw(val, LINCFG0);
++
++	/* Scale factor */
++	val = (linearize->scale_fact.integer & 1)
++	    << CCDC_LIN_SCALE_FACT_INTEG_SHIFT;
++	val |= (linearize->scale_fact.decimal &
++				CCDC_LIN_SCALE_FACT_DECIMAL_MASK);
++	regw(val, LINCFG1);
++
++	for (i = 0; i < CCDC_LINEAR_TAB_SIZE; i++) {
++		val = linearize->table[i] & CCDC_LIN_ENTRY_MASK;
++		if (i%2)
++			regw_lin_tbl(val, ((i >> 1) << 2), 1);
++		else
++			regw_lin_tbl(val, ((i >> 1) << 2), 0);
++	}
++}
++
++static void ccdc_config_dfc(struct ccdc_dfc *vdfc)
++{
++#define DFC_WRITE_WAIT_COUNT	1000
++	u32 val, count = DFC_WRITE_WAIT_COUNT;
++	int i;
++
++	if (!vdfc->en)
++		return;
++
++	/* Correction mode */
++	val = ((vdfc->corr_mode & CCDC_VDFC_CORR_MOD_MASK)
++		<< CCDC_VDFC_CORR_MOD_SHIFT);
++
++	/* Correct whole line or partial */
++	if (vdfc->corr_whole_line)
++		val |= 1 << CCDC_VDFC_CORR_WHOLE_LN_SHIFT;
++
++	/* level shift value */
++	val |= (vdfc->def_level_shift & CCDC_VDFC_LEVEL_SHFT_MASK) <<
++		CCDC_VDFC_LEVEL_SHFT_SHIFT;
++
++	regw(val, DFCCTL);
++
++	/* Defect saturation level */
++	val = vdfc->def_sat_level & CCDC_VDFC_SAT_LEVEL_MASK;
++	regw(val, VDFSATLV);
++
++	regw(vdfc->table[0].pos_vert & CCDC_VDFC_POS_MASK, DFCMEM0);
++	regw(vdfc->table[0].pos_horz & CCDC_VDFC_POS_MASK, DFCMEM1);
++	if (vdfc->corr_mode == CCDC_VDFC_NORMAL ||
++	    vdfc->corr_mode == CCDC_VDFC_HORZ_INTERPOL_IF_SAT) {
++		regw(vdfc->table[0].level_at_pos, DFCMEM2);
++		regw(vdfc->table[0].level_up_pixels, DFCMEM3);
++		regw(vdfc->table[0].level_low_pixels, DFCMEM4);
++	}
++
++	val = regr(DFCMEMCTL);
++	/* set DFCMARST and set DFCMWR */
++	val |= 1 << CCDC_DFCMEMCTL_DFCMARST_SHIFT;
++	val |= 1;
++	regw(val, DFCMEMCTL);
++
++	while (count && (regr(DFCMEMCTL) & 0x01))
++		count--;
++
++	val = regr(DFCMEMCTL);
++	if (!count) {
++		dev_dbg(dev, "defect table write timeout !!!\n");
++		return;
++	}
++
++	for (i = 1; i < vdfc->num_vdefects; i++) {
++		regw(vdfc->table[i].pos_vert & CCDC_VDFC_POS_MASK,
++			   DFCMEM0);
++		regw(vdfc->table[i].pos_horz & CCDC_VDFC_POS_MASK,
++			   DFCMEM1);
++		if (vdfc->corr_mode == CCDC_VDFC_NORMAL ||
++		    vdfc->corr_mode == CCDC_VDFC_HORZ_INTERPOL_IF_SAT) {
++			regw(vdfc->table[i].level_at_pos, DFCMEM2);
++			regw(vdfc->table[i].level_up_pixels, DFCMEM3);
++			regw(vdfc->table[i].level_low_pixels, DFCMEM4);
++		}
++		val = regr(DFCMEMCTL);
++		/* clear DFCMARST and set DFCMWR */
++		val &= ~(1 << CCDC_DFCMEMCTL_DFCMARST_SHIFT);
++		val |= 1;
++		regw(val, DFCMEMCTL);
++
++		count = DFC_WRITE_WAIT_COUNT;
++		while (count && (regr(DFCMEMCTL) & 0x01))
++			count--;
++
++		val = regr(DFCMEMCTL);
++		if (!count) {
++			dev_err(dev, "defect table write timeout !!!\n");
++			return;
++		}
++	}
++	if (vdfc->num_vdefects < CCDC_VDFC_TABLE_SIZE) {
++		/* Extra cycle needed */
++		regw(0, DFCMEM0);
++		regw(0x1FFF, DFCMEM1);
++		val = 1;
++		regw(val, DFCMEMCTL);
++	}
++
++	/* enable VDFC */
++	ccdc_merge((1 << CCDC_VDFC_EN_SHIFT), (1 << CCDC_VDFC_EN_SHIFT),
++		   DFCCTL);
++
++	ccdc_merge((1 << CCDC_VDFC_EN_SHIFT), (0 << CCDC_VDFC_EN_SHIFT),
++		   DFCCTL);
++
++	regw(0x6, DFCMEMCTL);
++	for (i = 0 ; i < vdfc->num_vdefects; i++) {
++		count = DFC_WRITE_WAIT_COUNT;
++		while (count && (regr(DFCMEMCTL) & 0x2))
++			count--;
++
++		val = regr(DFCMEMCTL);
++		if (!count) {
++			dev_err(dev, "defect table write timeout !!!\n");
++			return;
++		}
++
++		val = regr(DFCMEM0) | regr(DFCMEM1) | regr(DFCMEM2) |
++			regr(DFCMEM3) | regr(DFCMEM4);
++		regw(0x2, DFCMEMCTL);
++	}
++}
++
++static void ccdc_config_csc(struct ccdc_df_csc *df_csc)
++{
++	u32 val1 = 0, val2 = 0, i;
++
++	if (!df_csc->csc.en) {
++		regw(0, CSCCTL);
++		return;
++	}
++	for (i = 0; i < CCDC_CSC_NUM_COEFF; i++) {
++		if ((i % 2) == 0) {
++			/* CSCM - LSB */
++			val1 =
++				((df_csc->csc.coeff[i].integer &
++				CCDC_CSC_COEF_INTEG_MASK)
++				<< CCDC_CSC_COEF_INTEG_SHIFT) |
++				((df_csc->csc.coeff[i].decimal &
++				CCDC_CSC_COEF_DECIMAL_MASK));
++		} else {
++
++			/* CSCM - MSB */
++			val2 =
++				((df_csc->csc.coeff[i].integer &
++				CCDC_CSC_COEF_INTEG_MASK)
++				<< CCDC_CSC_COEF_INTEG_SHIFT) |
++				((df_csc->csc.coeff[i].decimal &
++				CCDC_CSC_COEF_DECIMAL_MASK));
++			val2 <<= CCDC_CSCM_MSB_SHIFT;
++			val2 |= val1;
++			regw(val2, (CSCM0 + ((i-1) << 1)));
++		}
++	}
++
++	/* program the active area */
++	regw(df_csc->start_pix & CCDC_DF_CSC_SPH_MASK, FMTSPH);
++	/**
++	 * one extra pixel as required for CSC. Actually number of
++	 * pixel - 1 should be configured in this register. So we
++	 * need to subtract 1 before writing to FMTSPH, but we will
++	 * not do this since csc requires one extra pixel
++	 */
++	regw((df_csc->num_pixels) & CCDC_DF_CSC_SPH_MASK, FMTLNH);
++	regw(df_csc->start_line & CCDC_DF_CSC_SPH_MASK, FMTSLV);
++	/**
++	 * one extra line as required for CSC. See reason documented for
++	 * num_pixels
++	 */
++	regw((df_csc->num_lines) & CCDC_DF_CSC_SPH_MASK, FMTLNV);
++
++	/* Enable CSC */
++	regw(1, CSCCTL);
++}
++
++static int ccdc_config_raw(int mode)
++{
++	struct ccdc_params_raw *params = &ccdc_cfg.bayer;
++	struct ccdc_config_params_raw *module_params =
++		&ccdc_cfg.bayer.config_params;
++	struct vpss_pg_frame_size frame_size;
++	struct vpss_sync_pol sync;
++	u32 val;
++
++	dev_dbg(dev, "\nStarting ccdc_config_raw..\n");
++
++	/* Configure CCDCFG register */
++
++	/**
++	 * Set CCD Not to swap input since input is RAW data
++	 * Set FID detection function to Latch at V-Sync
++	 * Set WENLOG - ccdc valid area
++	 * Set TRGSEL
++	 * Set EXTRG
++	 * Packed to 8 or 16 bits
++	 */
++
++	val = CCDC_YCINSWP_RAW | CCDC_CCDCFG_FIDMD_LATCH_VSYNC |
++		CCDC_CCDCFG_WENLOG_AND | CCDC_CCDCFG_TRGSEL_WEN |
++		CCDC_CCDCFG_EXTRG_DISABLE | (ccdc_cfg.data_pack &
++		CCDC_DATA_PACK_MASK);
++
++	dev_dbg(dev, "Writing 0x%x to ...CCDCFG \n", val);
++	regw(val, CCDCFG);
++
++	/**
++	 * Configure the vertical sync polarity(MODESET.VDPOL)
++	 * Configure the horizontal sync polarity (MODESET.HDPOL)
++	 * Configure frame id polarity (MODESET.FLDPOL)
++	 * Configure data polarity
++	 * Configure External WEN Selection
++	 * Configure frame format(progressive or interlace)
++	 * Configure pixel format (Input mode)
++	 * Configure the data shift
++	 */
++
++	val = CCDC_VDHDOUT_INPUT |
++		((params->vd_pol & CCDC_VD_POL_MASK) << CCDC_VD_POL_SHIFT) |
++		((params->hd_pol & CCDC_HD_POL_MASK) << CCDC_HD_POL_SHIFT) |
++		((params->fid_pol & CCDC_FID_POL_MASK) << CCDC_FID_POL_SHIFT) |
++		((CCDC_DATAPOL_NORMAL & CCDC_DATAPOL_MASK)
++			<< CCDC_DATAPOL_SHIFT) |
++		((CCDC_EXWEN_DISABLE & CCDC_EXWEN_MASK) << CCDC_EXWEN_SHIFT) |
++		((params->frm_fmt & CCDC_FRM_FMT_MASK) << CCDC_FRM_FMT_SHIFT) |
++		((params->pix_fmt & CCDC_INPUT_MASK) << CCDC_INPUT_SHIFT) |
++		((params->config_params.data_shift & CCDC_DATASFT_MASK)
++			<< CCDC_DATASFT_SHIFT);
++
++	regw(val, MODESET);
++	dev_dbg(dev, "Writing 0x%x to MODESET...\n", val);
++
++	/**
++	 * Configure GAMMAWD register
++	 * CFA pattern setting
++	 */
++	val = (params->cfa_pat & CCDC_GAMMAWD_CFA_MASK) <<
++		CCDC_GAMMAWD_CFA_SHIFT;
++
++	/* Gamma msb */
++	if (module_params->compress.alg == CCDC_ALAW)
++		val = val | CCDC_ALAW_ENABLE;
++
++	val = val | ((params->data_msb & CCDC_ALAW_GAMA_WD_MASK) <<
++			CCDC_ALAW_GAMA_WD_SHIFT);
++
++	regw(val, CGAMMAWD);
++
++	/* Configure DPCM compression settings */
++	if (module_params->compress.alg == CCDC_DPCM) {
++		val =  1 << CCDC_DPCM_EN_SHIFT;
++		val |= (module_params->compress.pred &
++			CCDC_DPCM_PREDICTOR_MASK) << CCDC_DPCM_PREDICTOR_SHIFT;
++	}
++
++	regw(val, MISC);
++	/* Configure Gain & Offset */
++
++	ccdc_config_gain_offset();
++
++	/* Configure Color pattern */
++	val = (params->config_params.col_pat_field0.olop) |
++	(params->config_params.col_pat_field0.olep << 2) |
++	(params->config_params.col_pat_field0.elop << 4) |
++	(params->config_params.col_pat_field0.elep << 6) |
++	(params->config_params.col_pat_field1.olop << 8) |
++	(params->config_params.col_pat_field1.olep << 10) |
++	(params->config_params.col_pat_field1.elop << 12) |
++	(params->config_params.col_pat_field1.elep << 14);
++	regw(val, CCOLP);
++	dev_dbg(dev, "Writing %x to CCOLP ...\n", val);
++
++	/* Configure HSIZE register  */
++	val =
++	    (params->
++	     horz_flip_en & CCDC_HSIZE_FLIP_MASK) << CCDC_HSIZE_FLIP_SHIFT;
++
++	/* calculate line offset in 32 bytes based on pack value */
++	if (ccdc_cfg.data_pack == CCDC_PACK_8BIT)
++		val |= (((params->win.width + 31) >> 5) & CCDC_LINEOFST_MASK);
++	else if (ccdc_cfg.data_pack == CCDC_PACK_12BIT)
++		val |= ((((params->win.width +
++			   (params->win.width >> 2)) +
++			  31) >> 5) & CCDC_LINEOFST_MASK);
++	else
++		val |=
++		    ((((params->win.width * 2) +
++		       31) >> 5) & CCDC_LINEOFST_MASK);
++	regw(val, HSIZE);
++
++	/* Configure SDOFST register  */
++	if (params->frm_fmt == CCDC_FRMFMT_INTERLACED) {
++		if (params->image_invert_en) {
++			/* For interlace inverse mode */
++			regw(0x4B6D, SDOFST);
++			dev_dbg(dev, "Writing 0x4B6D to SDOFST...\n");
++		} else {
++			/* For interlace non inverse mode */
++			regw(0x0B6D, SDOFST);
++			dev_dbg(dev, "Writing 0x0B6D to SDOFST...\n");
++		}
++	} else if (params->frm_fmt == CCDC_FRMFMT_PROGRESSIVE) {
++		if (params->image_invert_en) {
++			/* For progessive inverse mode */
++			regw(0x4000, SDOFST);
++			dev_dbg(dev, "Writing 0x4000 to SDOFST...\n");
++		} else {
++			/* For progessive non inverse mode */
++			regw(0x0000, SDOFST);
++			dev_dbg(dev, "Writing 0x0000 to SDOFST...\n");
++		}
++	}
++
++	/* Configure video window */
++	ccdc_setwin(&params->win, params->frm_fmt, 1, mode);
++
++	/* Configure Black Clamp */
++	ccdc_config_bclamp(&module_params->bclamp);
++
++	/* Configure Vertical Defection Pixel Correction */
++	ccdc_config_dfc(&module_params->dfc);
++
++	if (!module_params->df_csc.df_or_csc)
++		/* Configure Color Space Conversion */
++		ccdc_config_csc(&module_params->df_csc);
++
++	ccdc_config_linearization(&module_params->linearize);
++
++	/* Configure Culling */
++	ccdc_config_culling(&module_params->culling);
++
++	/* Configure Horizontal and vertical offsets(DFC,LSC,Gain) */
++	val = module_params->horz_offset & CCDC_DATA_H_OFFSET_MASK;
++	regw(val, DATAHOFST);
++
++	val = module_params->vert_offset & CCDC_DATA_V_OFFSET_MASK;
++	regw(val, DATAVOFST);
++
++	/* Setup test pattern if enabled */
++	if (params->config_params.test_pat_gen) {
++		/* Use the HD/VD pol settings from user */
++		sync.ccdpg_hdpol = params->hd_pol & CCDC_HD_POL_MASK;
++		sync.ccdpg_vdpol = params->vd_pol & CCDC_VD_POL_MASK;
++
++		vpss_set_sync_pol(sync);
++
++		frame_size.hlpfr = ccdc_cfg.bayer.win.width;
++		frame_size.pplen = ccdc_cfg.bayer.win.height;
++		vpss_set_pg_frame_size(frame_size);
++		vpss_select_ccdc_source(VPSS_PGLPBK);
++	}
++
++	dev_dbg(dev, "\nEnd of ccdc_config_ycbcr...\n");
++	return 0;
++}
++
++static int ccdc_validate_df_csc_params(struct ccdc_df_csc *df_csc)
++{
++	struct ccdc_color_space_conv *csc;
++	int i, csc_df_en = 0;
++	int err = -EINVAL;
++
++	if (!df_csc->df_or_csc) {
++		/* csc configuration */
++		csc = &df_csc->csc;
++		if (csc->en) {
++			csc_df_en = 1;
++			for (i = 0; i < CCDC_CSC_NUM_COEFF; i++) {
++				if (csc->coeff[i].integer >
++					CCDC_CSC_COEF_INTEG_MASK ||
++				    csc->coeff[i].decimal >
++					CCDC_CSC_COEF_DECIMAL_MASK) {
++					dev_dbg(dev,
++					       "invalid csc coefficients \n");
++					return err;
++				}
++			}
++		}
++	}
++
++	if (df_csc->start_pix > CCDC_DF_CSC_SPH_MASK) {
++		dev_dbg(dev, "invalid df_csc start pix value \n");
++		return err;
++	}
++	if (df_csc->num_pixels > CCDC_DF_NUMPIX) {
++		dev_dbg(dev, "invalid df_csc num pixels value \n");
++		return err;
++	}
++	if (df_csc->start_line > CCDC_DF_CSC_LNH_MASK) {
++		dev_dbg(dev, "invalid df_csc start_line value \n");
++		return err;
++	}
++	if (df_csc->num_lines > CCDC_DF_NUMLINES) {
++		dev_dbg(dev, "invalid df_csc num_lines value \n");
++		return err;
++	}
++	return 0;
++}
++
++static int ccdc_validate_dfc_params(struct ccdc_dfc *dfc)
++{
++	int err = -EINVAL;
++	int i;
++
++	if (dfc->en) {
++		if (dfc->corr_whole_line > 1) {
++			dev_dbg(dev, "invalid corr_whole_line value \n");
++			return err;
++		}
++
++		if (dfc->def_level_shift > 4) {
++			dev_dbg(dev, "invalid def_level_shift value \n");
++			return err;
++		}
++
++		if (dfc->def_sat_level > 4095) {
++			dev_dbg(dev, "invalid def_sat_level value \n");
++			return err;
++		}
++		if ((!dfc->num_vdefects) || (dfc->num_vdefects > 8)) {
++			dev_dbg(dev, "invalid num_vdefects value \n");
++			return err;
++		}
++		for (i = 0; i < CCDC_VDFC_TABLE_SIZE; i++) {
++			if (dfc->table[i].pos_vert > 0x1fff) {
++				dev_dbg(dev, "invalid pos_vert value \n");
++				return err;
++			}
++			if (dfc->table[i].pos_horz > 0x1fff) {
++				dev_dbg(dev, "invalid pos_horz value \n");
++				return err;
++			}
++		}
++	}
++	return 0;
++}
++
++static int ccdc_validate_bclamp_params(struct ccdc_black_clamp *bclamp)
++{
++	int err = -EINVAL;
++
++	if (bclamp->dc_offset > 0x1fff) {
++		dev_dbg(dev, "invalid bclamp dc_offset value \n");
++		return err;
++	}
++
++	if (bclamp->en) {
++		if (bclamp->horz.clamp_pix_limit > 1) {
++			dev_dbg(dev,
++			       "invalid bclamp horz clamp_pix_limit value \n");
++			return err;
++		}
++
++		if (bclamp->horz.win_count_calc < 1 ||
++		    bclamp->horz.win_count_calc > 32) {
++			dev_dbg(dev,
++			       "invalid bclamp horz win_count_calc value \n");
++			return err;
++		}
++
++		if (bclamp->horz.win_start_h_calc > 0x1fff) {
++			dev_dbg(dev,
++			       "invalid bclamp win_start_v_calc value \n");
++			return err;
++		}
++
++		if (bclamp->horz.win_start_v_calc > 0x1fff) {
++			dev_dbg(dev,
++			       "invalid bclamp win_start_v_calc value \n");
++			return err;
++		}
++
++		if (bclamp->vert.reset_clamp_val > 0xfff) {
++			dev_dbg(dev,
++			       "invalid bclamp reset_clamp_val value \n");
++			return err;
++		}
++
++		if (bclamp->vert.ob_v_sz_calc > 0x1fff) {
++			dev_dbg(dev, "invalid bclamp ob_v_sz_calc value \n");
++			return err;
++		}
++
++		if (bclamp->vert.ob_start_h > 0x1fff) {
++			dev_dbg(dev, "invalid bclamp ob_start_h value \n");
++			return err;
++		}
++
++		if (bclamp->vert.ob_start_v > 0x1fff) {
++			dev_dbg(dev, "invalid bclamp ob_start_h value \n");
++			return err;
++		}
++	}
++	return 0;
++}
++
++static int ccdc_validate_gain_ofst_params(struct ccdc_gain_offsets_adj
++					  *gain_offset)
++{
++	int err = -EINVAL;
++
++	if (gain_offset->gain_sdram_en ||
++	    gain_offset->gain_ipipe_en ||
++	    gain_offset->gain_h3a_en) {
++		if ((gain_offset->gain.r_ye.integer > 7) ||
++		    (gain_offset->gain.r_ye.decimal > 0x1ff)) {
++			dev_dbg(dev, "invalid  gain r_ye\n");
++			return err;
++		}
++		if ((gain_offset->gain.gr_cy.integer > 7) ||
++		    (gain_offset->gain.gr_cy.decimal > 0x1ff)) {
++			dev_dbg(dev, "invalid  gain gr_cy\n");
++			return err;
++		}
++		if ((gain_offset->gain.gb_g.integer > 7) ||
++		    (gain_offset->gain.gb_g.decimal > 0x1ff)) {
++			dev_dbg(dev, "invalid  gain gb_g\n");
++			return err;
++		}
++		if ((gain_offset->gain.b_mg.integer > 7) ||
++		    (gain_offset->gain.b_mg.decimal > 0x1ff)) {
++			dev_dbg(dev, "invalid  gain b_mg\n");
++			return err;
++		}
++	}
++	if (gain_offset->offset_sdram_en ||
++	    gain_offset->offset_ipipe_en ||
++	    gain_offset->offset_h3a_en) {
++		if (gain_offset->offset > 0xfff) {
++			dev_dbg(dev, "invalid  gain b_mg\n");
++			return err;
++		}
++	}
++
++	return 0;
++}
++
++static int
++validate_ccdc_config_params_raw(struct ccdc_config_params_raw *params)
++{
++	int err;
++
++	err = ccdc_validate_df_csc_params(&params->df_csc);
++	if (err)
++		goto exit;
++	err = ccdc_validate_dfc_params(&params->dfc);
++	if (err)
++		goto exit;
++	err = ccdc_validate_bclamp_params(&params->bclamp);
++	if (err)
++		goto exit;
++	err = ccdc_validate_gain_ofst_params(&params->gain_offset);
++exit:
++	return err;
++}
++
++static int ccdc_set_buftype(enum ccdc_buftype buf_type)
++{
++	if (ccdc_cfg.if_type == VPFE_RAW_BAYER)
++		ccdc_cfg.bayer.buf_type = buf_type;
++	else
++		ccdc_cfg.ycbcr.buf_type = buf_type;
++
++	return 0;
++
++}
++static enum ccdc_buftype ccdc_get_buftype(void)
++{
++	if (ccdc_cfg.if_type == VPFE_RAW_BAYER)
++		return ccdc_cfg.bayer.buf_type;
++
++	return ccdc_cfg.ycbcr.buf_type;
++}
++
++static int ccdc_enum_pix(u32 *pix, int i)
++{
++	int ret = -EINVAL;
++
++	if (ccdc_cfg.if_type == VPFE_RAW_BAYER) {
++		if (i < ARRAY_SIZE(ccdc_raw_bayer_pix_formats)) {
++			*pix = ccdc_raw_bayer_pix_formats[i];
++			ret = 0;
++		}
++	} else {
++		if (i < ARRAY_SIZE(ccdc_raw_yuv_pix_formats)) {
++			*pix = ccdc_raw_yuv_pix_formats[i];
++			ret = 0;
++		}
++	}
++
++	return ret;
++}
++
++static int ccdc_set_pixel_format(unsigned int pixfmt)
++{
++	if (ccdc_cfg.if_type == VPFE_RAW_BAYER) {
++		if (pixfmt == V4L2_PIX_FMT_SBGGR8) {
++			if ((ccdc_cfg.bayer.config_params.compress.alg !=
++					CCDC_ALAW) &&
++			    (ccdc_cfg.bayer.config_params.compress.alg !=
++					CCDC_DPCM)) {
++				dev_dbg(dev, "Either configure A-Law or"
++						"DPCM\n");
++				return -EINVAL;
++			}
++			ccdc_cfg.data_pack = CCDC_PACK_8BIT;
++		} else if (pixfmt == V4L2_PIX_FMT_SBGGR16) {
++			ccdc_cfg.bayer.config_params.compress.alg =
++					CCDC_NO_COMPRESSION;
++			ccdc_cfg.data_pack = CCDC_PACK_16BIT;
++		} else
++			return -EINVAL;
++		ccdc_cfg.bayer.pix_fmt = CCDC_PIXFMT_RAW;
++	} else {
++		if (pixfmt == V4L2_PIX_FMT_YUYV)
++			ccdc_cfg.ycbcr.pix_order = CCDC_PIXORDER_YCBYCR;
++		else if (pixfmt == V4L2_PIX_FMT_UYVY)
++			ccdc_cfg.ycbcr.pix_order = CCDC_PIXORDER_CBYCRY;
++		else
++			return -EINVAL;
++		ccdc_cfg.data_pack = CCDC_PACK_8BIT;
++	}
++	return 0;
++}
++
++static u32 ccdc_get_pixel_format(void)
++{
++	u32 pixfmt;
++
++	if (ccdc_cfg.if_type == VPFE_RAW_BAYER)
++		if (ccdc_cfg.bayer.config_params.compress.alg
++			== CCDC_ALAW
++			|| ccdc_cfg.bayer.config_params.compress.alg
++			== CCDC_DPCM)
++				pixfmt = V4L2_PIX_FMT_SBGGR8;
++		else
++			pixfmt = V4L2_PIX_FMT_SBGGR16;
++	else {
++		if (ccdc_cfg.ycbcr.pix_order == CCDC_PIXORDER_YCBYCR)
++			pixfmt = V4L2_PIX_FMT_YUYV;
++		else
++			pixfmt = V4L2_PIX_FMT_UYVY;
++	}
++	return pixfmt;
++}
++
++static int ccdc_set_image_window(struct v4l2_rect *win)
++{
++	if (ccdc_cfg.if_type == VPFE_RAW_BAYER) {
++		ccdc_cfg.bayer.win.top = win->top;
++		ccdc_cfg.bayer.win.left = win->left;
++		ccdc_cfg.bayer.win.width = win->width;
++		ccdc_cfg.bayer.win.height = win->height;
++	} else {
++		ccdc_cfg.ycbcr.win.top = win->top;
++		ccdc_cfg.ycbcr.win.left = win->left;
++		ccdc_cfg.ycbcr.win.width = win->width;
++		ccdc_cfg.ycbcr.win.height = win->height;
++	}
++	return 0;
++}
++
++static void ccdc_get_image_window(struct v4l2_rect *win)
++{
++	if (ccdc_cfg.if_type == VPFE_RAW_BAYER)
++		*win = ccdc_cfg.bayer.win;
++	else
++		*win = ccdc_cfg.ycbcr.win;
++}
++
++static unsigned int ccdc_get_line_length(void)
++{
++	unsigned int len;
++
++	if (ccdc_cfg.if_type == VPFE_RAW_BAYER) {
++		if (ccdc_cfg.data_pack == CCDC_PACK_8BIT)
++			len = ((ccdc_cfg.bayer.win.width));
++		else if (ccdc_cfg.data_pack == CCDC_PACK_12BIT)
++			len = (((ccdc_cfg.bayer.win.width * 2) +
++				 (ccdc_cfg.bayer.win.width >> 2)));
++		else
++			len = (((ccdc_cfg.bayer.win.width * 2)));
++	} else
++		len = (((ccdc_cfg.ycbcr.win.width * 2)));
++
++	return ALIGN(len, 32);
++}
++
++static int ccdc_set_frame_format(enum ccdc_frmfmt frm_fmt)
++{
++	if (ccdc_cfg.if_type == VPFE_RAW_BAYER)
++		ccdc_cfg.bayer.frm_fmt = frm_fmt;
++	else
++		ccdc_cfg.ycbcr.frm_fmt = frm_fmt;
++
++	return 0;
++}
++static enum ccdc_frmfmt ccdc_get_frame_format(void)
++{
++	if (ccdc_cfg.if_type == VPFE_RAW_BAYER)
++		return ccdc_cfg.bayer.frm_fmt;
++	else
++		return ccdc_cfg.ycbcr.frm_fmt;
++}
++
++static int ccdc_getfid(void)
++{
++	return (regr(MODESET) >> 15) & 0x1;
++}
++
++/* misc operations */
++static void ccdc_setfbaddr(unsigned long addr)
++{
++	regw((addr >> 21) & 0x07ff, CADU);
++	regw((addr >> 5) & 0x0ffff, CADL);
++}
++
++static int ccdc_set_hw_if_params(struct vpfe_hw_if_param *params)
++{
++	ccdc_cfg.if_type = params->if_type;
++
++	switch (params->if_type) {
++	case VPFE_BT656:
++	case VPFE_BT656_10BIT:
++	case VPFE_YCBCR_SYNC_8:
++		ccdc_cfg.ycbcr.pix_fmt = CCDC_PIXFMT_YCBCR_8BIT;
++		ccdc_cfg.ycbcr.pix_order = CCDC_PIXORDER_CBYCRY;
++		break;
++	case VPFE_BT1120:
++	case VPFE_YCBCR_SYNC_16:
++		ccdc_cfg.ycbcr.pix_fmt = CCDC_PIXFMT_YCBCR_16BIT;
++		ccdc_cfg.ycbcr.pix_order = CCDC_PIXORDER_CBYCRY;
++		break;
++	case VPFE_RAW_BAYER:
++		ccdc_cfg.bayer.pix_fmt = CCDC_PIXFMT_RAW;
++		break;
++	default:
++		dev_dbg(dev, "Invalid interface type\n");
++		return -EINVAL;
++	}
++
++	return 0;
++}
++
++/* Parameter operations */
++static int ccdc_get_params(void __user *params)
++{
++	/* only raw module parameters can be set through the IOCTL */
++	if (ccdc_cfg.if_type != VPFE_RAW_BAYER)
++		return -EINVAL;
++
++	if (copy_to_user(params,
++			&ccdc_cfg.bayer.config_params,
++			sizeof(ccdc_cfg.bayer.config_params))) {
++		dev_dbg(dev, "ccdc_get_params: error in copying ccdc params\n");
++		return -EFAULT;
++	}
++	return 0;
++}
++
++/* Parameter operations */
++static int ccdc_set_params(void __user *params)
++{
++	struct ccdc_config_params_raw *ccdc_raw_params;
++	int ret = -EINVAL;
++
++	/* only raw module parameters can be set through the IOCTL */
++	if (ccdc_cfg.if_type != VPFE_RAW_BAYER)
++		return ret;
++
++	ccdc_raw_params = kzalloc(sizeof(*ccdc_raw_params), GFP_KERNEL);
++
++	if (NULL == ccdc_raw_params)
++		return -ENOMEM;
++
++	ret = copy_from_user(ccdc_raw_params,
++			     params, sizeof(*ccdc_raw_params));
++	if (ret) {
++		dev_dbg(dev, "ccdc_set_params: error in copying ccdc"
++			"params, %d\n", ret);
++		ret = -EFAULT;
++		goto free_out;
++	}
++
++	if (!validate_ccdc_config_params_raw(ccdc_raw_params)) {
++		memcpy(&ccdc_cfg.bayer.config_params,
++			ccdc_raw_params,
++			sizeof(*ccdc_raw_params));
++		ret = 0;
++	} else
++		ret = -EINVAL;
++free_out:
++	kfree(ccdc_raw_params);
++	return ret;
++}
++
++/* This function will configure CCDC for YCbCr parameters. */
++static int ccdc_config_ycbcr(int mode)
++{
++	struct ccdc_ycbcr_config *params = &ccdc_cfg.ycbcr;
++	struct vpss_pg_frame_size frame_size;
++	u32 modeset = 0, ccdcfg = 0;
++	struct vpss_sync_pol sync;
++
++	/**
++	 * first reset the CCDC
++	 * all registers have default values after reset
++	 * This is important since we assume default values to be set in
++	 * a lot of registers that we didn't touch
++	 */
++	dev_dbg(dev, "\nStarting ccdc_config_ycbcr...");
++
++	/* configure pixel format or input mode */
++	modeset = modeset | ((params->pix_fmt & CCDC_INPUT_MASK)
++		<< CCDC_INPUT_SHIFT) |
++	((params->frm_fmt & CCDC_FRM_FMT_MASK) << CCDC_FRM_FMT_SHIFT) |
++	(((params->fid_pol & CCDC_FID_POL_MASK) << CCDC_FID_POL_SHIFT))	|
++	(((params->hd_pol & CCDC_HD_POL_MASK) << CCDC_HD_POL_SHIFT)) |
++	(((params->vd_pol & CCDC_VD_POL_MASK) << CCDC_VD_POL_SHIFT));
++
++	/* pack the data to 8-bit CCDCCFG */
++	switch (ccdc_cfg.if_type) {
++	case VPFE_BT656:
++		if (params->pix_fmt != CCDC_PIXFMT_YCBCR_8BIT) {
++			dev_dbg(dev, "Invalid pix_fmt(input mode)\n");
++			return -1;
++		}
++		modeset |=
++			((VPFE_PINPOL_NEGATIVE & CCDC_VD_POL_MASK)
++			<< CCDC_VD_POL_SHIFT);
++		regw(3, REC656IF);
++		ccdcfg = ccdcfg | CCDC_DATA_PACK8 | CCDC_YCINSWP_YCBCR;
++		break;
++	case VPFE_BT656_10BIT:
++		if (params->pix_fmt != CCDC_PIXFMT_YCBCR_8BIT) {
++			dev_dbg(dev, "Invalid pix_fmt(input mode)\n");
++			return -1;
++		}
++		/* setup BT.656, embedded sync  */
++		regw(3, REC656IF);
++		/* enable 10 bit mode in ccdcfg */
++		ccdcfg = ccdcfg | CCDC_DATA_PACK8 | CCDC_YCINSWP_YCBCR |
++			CCDC_BW656_ENABLE;
++		break;
++	case VPFE_BT1120:
++		if (params->pix_fmt != CCDC_PIXFMT_YCBCR_16BIT) {
++			dev_dbg(dev, "Invalid pix_fmt(input mode)\n");
++			return -EINVAL;
++		}
++		regw(3, REC656IF);
++		break;
++
++	case VPFE_YCBCR_SYNC_8:
++		ccdcfg |= CCDC_DATA_PACK8;
++		ccdcfg |= CCDC_YCINSWP_YCBCR;
++		if (params->pix_fmt != CCDC_PIXFMT_YCBCR_8BIT) {
++			dev_dbg(dev, "Invalid pix_fmt(input mode)\n");
++			return -EINVAL;
++		}
++		break;
++	case VPFE_YCBCR_SYNC_16:
++		if (params->pix_fmt != CCDC_PIXFMT_YCBCR_16BIT) {
++			dev_dbg(dev, "Invalid pix_fmt(input mode)\n");
++			return -EINVAL;
++		}
++		break;
++	default:
++		/* should never come here */
++		dev_dbg(dev, "Invalid interface type\n");
++		return -EINVAL;
++	}
++
++	regw(modeset, MODESET);
++
++	/* Set up pix order */
++	ccdcfg |= (params->pix_order & CCDC_PIX_ORDER_MASK) <<
++		CCDC_PIX_ORDER_SHIFT;
++
++	regw(ccdcfg, CCDCFG);
++
++	/* configure video window */
++	if ((ccdc_cfg.if_type == VPFE_BT1120) ||
++	    (ccdc_cfg.if_type == VPFE_YCBCR_SYNC_16))
++		ccdc_setwin(&params->win, params->frm_fmt, 1, mode);
++	else
++		ccdc_setwin(&params->win, params->frm_fmt, 2, mode);
++
++	/**
++	 * configure the horizontal line offset
++	 * this is done by rounding up width to a multiple of 16 pixels
++	 * and multiply by two to account for y:cb:cr 4:2:2 data
++	 */
++	regw(((((params->win.width * 2) + 31) & 0xffffffe0) >> 5), HSIZE);
++
++	/* configure the memory line offset */
++	if ((params->frm_fmt == CCDC_FRMFMT_INTERLACED) &&
++	    (params->buf_type == CCDC_BUFTYPE_FLD_INTERLEAVED)) {
++		/* two fields are interleaved in memory */
++		regw(0x00000249, SDOFST);
++	}
++
++	/* Setup test pattern if enabled */
++	if (ccdc_cfg.bayer.config_params.test_pat_gen) {
++		sync.ccdpg_hdpol = (params->hd_pol & CCDC_HD_POL_MASK);
++		sync.ccdpg_vdpol = (params->vd_pol & CCDC_VD_POL_MASK);
++		vpss_set_sync_pol(sync);
++		vpss_set_pg_frame_size(frame_size);
++	}
++
++	return 0;
++}
++
++static int ccdc_configure(int mode)
++{
++	if (ccdc_cfg.if_type == VPFE_RAW_BAYER)
++		return ccdc_config_raw(mode);
++	else
++		ccdc_config_ycbcr(mode);
++
++	return 0;
++}
++
++static int ccdc_close(struct device *device)
++{
++	/* copy defaults to module params */
++	memcpy(&ccdc_cfg.bayer.config_params,
++	       &ccdc_config_defaults,
++	       sizeof(struct ccdc_config_params_raw));
++
++	return 0;
++}
++
++static struct ccdc_hw_device ccdc_hw_dev = {
++	.name = "DM365 ISIF",
++	.owner = THIS_MODULE,
++	.hw_ops = {
++		.open = ccdc_open,
++		.close = ccdc_close,
++		.enable = ccdc_enable,
++		.enable_out_to_sdram = ccdc_enable_output_to_sdram,
++		.set_hw_if_params = ccdc_set_hw_if_params,
++		.set_params = ccdc_set_params,
++		.get_params = ccdc_get_params,
++		.configure = ccdc_configure,
++		.set_buftype = ccdc_set_buftype,
++		.get_buftype = ccdc_get_buftype,
++		.enum_pix = ccdc_enum_pix,
++		.set_pixel_format = ccdc_set_pixel_format,
++		.get_pixel_format = ccdc_get_pixel_format,
++		.set_frame_format = ccdc_set_frame_format,
++		.get_frame_format = ccdc_get_frame_format,
++		.set_image_window = ccdc_set_image_window,
++		.get_image_window = ccdc_get_image_window,
++		.get_line_length = ccdc_get_line_length,
++		.setfbaddr = ccdc_setfbaddr,
++		.getfid = ccdc_getfid,
++	},
++};
++
++static int __init dm365_ccdc_probe(struct platform_device *pdev)
++{
++	static resource_size_t  res_len;
++	struct resource	*res;
++	void *__iomem addr;
++	int status = 0, i;
++
++	/**
++	 * first try to register with vpfe. If not correct platform, then we
++	 * don't have to iomap
++	 */
++	status = vpfe_register_ccdc_device(&ccdc_hw_dev);
++	if (status < 0)
++		return status;
++
++	i = 0;
++	/* Get the ISIF base address, linearization table0 and table1 addr. */
++	while (i < 3) {
++		res = platform_get_resource(pdev, IORESOURCE_MEM, i);
++		if (!res) {
++			status = -ENOENT;
++			goto fail_nobase_res;
++		}
++		res_len = res->end - res->start + 1;
++		res = request_mem_region(res->start, res_len, res->name);
++		if (!res) {
++			status = -EBUSY;
++			goto fail_nobase_res;
++		}
++		addr = ioremap_nocache(res->start, res_len);
++		if (!addr) {
++			status = -EBUSY;
++			goto fail_base_iomap;
++		}
++		switch (i) {
++		case 0:
++			/* ISIF base address */
++			ccdc_cfg.base_addr = addr;
++			break;
++		case 1:
++			/* ISIF linear tbl0 address */
++			ccdc_cfg.linear_tbl0_addr = addr;
++			break;
++		default:
++			/* ISIF linear tbl0 address */
++			ccdc_cfg.linear_tbl1_addr = addr;
++			break;
++		}
++		i++;
++	}
++
++	davinci_cfg_reg(DM365_VIN_CAM_WEN);
++	davinci_cfg_reg(DM365_VIN_CAM_VD);
++	davinci_cfg_reg(DM365_VIN_CAM_HD);
++	davinci_cfg_reg(DM365_VIN_YIN4_7_EN);
++	davinci_cfg_reg(DM365_VIN_YIN0_3_EN);
++
++	printk(KERN_NOTICE "%s is registered with vpfe.\n",
++		ccdc_hw_dev.name);
++	return 0;
++fail_base_iomap:
++	release_mem_region(res->start, res_len);
++	i--;
++fail_nobase_res:
++	if (ccdc_cfg.base_addr)
++		iounmap(ccdc_cfg.base_addr);
++	if (ccdc_cfg.linear_tbl0_addr)
++		iounmap(ccdc_cfg.linear_tbl0_addr);
++
++	while (i >= 0) {
++		res = platform_get_resource(pdev, IORESOURCE_MEM, i);
++		release_mem_region(res->start, res_len);
++		i--;
++	}
++	vpfe_unregister_ccdc_device(&ccdc_hw_dev);
++	return status;
++}
++
++static int dm365_ccdc_remove(struct platform_device *pdev)
++{
++	struct resource	*res;
++	int i = 0;
++
++	iounmap(ccdc_cfg.base_addr);
++	iounmap(ccdc_cfg.linear_tbl0_addr);
++	iounmap(ccdc_cfg.linear_tbl1_addr);
++	while (i < 3) {
++		res = platform_get_resource(pdev, IORESOURCE_MEM, i);
++		if (res)
++			release_mem_region(res->start,
++					   res->end - res->start + 1);
++		i++;
++	}
++	vpfe_unregister_ccdc_device(&ccdc_hw_dev);
++	return 0;
++}
++
++static struct platform_driver dm365_ccdc_driver = {
++	.driver = {
++		.name	= "dm365_isif",
++		.owner = THIS_MODULE,
++	},
++	.remove = __devexit_p(dm365_ccdc_remove),
++	.probe = dm365_ccdc_probe,
++};
++
++static int dm365_ccdc_init(void)
++{
++	return platform_driver_register(&dm365_ccdc_driver);
++}
++
++
++static void dm365_ccdc_exit(void)
++{
++	platform_driver_unregister(&dm365_ccdc_driver);
++}
++
++module_init(dm365_ccdc_init);
++module_exit(dm365_ccdc_exit);
++
++MODULE_LICENSE("GPL");
+--- a/arch/arm/mach-davinci/clock.c
++++ b/arch/arm/mach-davinci/clock.c
+@@ -19,6 +19,7 @@
+ #include <linux/mutex.h>
+ #include <linux/platform_device.h>
+ #include <linux/io.h>
++#include <linux/delay.h>
+ 
+ #include <mach/hardware.h>
+ 
+@@ -99,20 +100,76 @@ long clk_round_rate(struct clk *clk, uns
+ 	if (clk == NULL || IS_ERR(clk))
+ 		return -EINVAL;
+ 
++	if (clk->round_rate)
++		return clk->round_rate(clk, rate);
++
+ 	return clk->rate;
+ }
+ EXPORT_SYMBOL(clk_round_rate);
+ 
++/* Propagate rate to children */
++static void propagate_rate(struct clk *root)
++{
++	struct clk *clk;
++
++	list_for_each_entry(clk, &root->children, childnode) {
++		if (clk->recalc)
++			clk->rate = clk->recalc(clk);
++		propagate_rate(clk);
++	}
++}
++
+ int clk_set_rate(struct clk *clk, unsigned long rate)
+ {
++	unsigned long flags;
++	int ret = -EINVAL;
++
+ 	if (clk == NULL || IS_ERR(clk))
+-		return -EINVAL;
++		return ret;
++/* NOTE: We need to relook into this as CDCE clock set rate
++ * calls i2c_smbus_write which inturn sleeps
++ * As sleep is not allowed in atomic context, this
++ * creates a kernel crash. Needs to be reworked after
++ * Sekhar's patch is accepted
++ */
+ 
+-	/* changing the clk rate is not supported */
+-	return -EINVAL;
++/* spin_lock_irqsave(&clockfw_lock, flags); */
++	if (clk->set_rate)
++		ret = clk->set_rate(clk, rate);
++	if (ret == 0) {
++		if (clk->recalc)
++			clk->rate = clk->recalc(clk);
++		propagate_rate(clk);
++	}
++/* spin_unlock_irqrestore(&clockfw_lock, flags); */
++
++	return ret;
+ }
+ EXPORT_SYMBOL(clk_set_rate);
+ 
++int clk_set_parent(struct clk *clk, struct clk *parent)
++{
++	unsigned long flags;
++
++	if (clk == NULL || IS_ERR(clk))
++		return -EINVAL;
++
++	mutex_lock(&clocks_mutex);
++	clk->parent = parent;
++	list_del_init(&clk->childnode);
++	list_add(&clk->childnode, &clk->parent->children);
++	mutex_unlock(&clocks_mutex);
++
++	spin_lock_irqsave(&clockfw_lock, flags);
++	if (clk->recalc)
++		clk->rate = clk->recalc(clk);
++	propagate_rate(clk);
++	spin_unlock_irqrestore(&clockfw_lock, flags);
++
++	return 0;
++}
++EXPORT_SYMBOL(clk_set_parent);
++
+ int clk_register(struct clk *clk)
+ {
+ 	if (clk == NULL || IS_ERR(clk))
+@@ -123,16 +180,24 @@ int clk_register(struct clk *clk)
+ 			clk->name, clk->parent->name))
+ 		return -EINVAL;
+ 
++	INIT_LIST_HEAD(&clk->children);
++
+ 	mutex_lock(&clocks_mutex);
+ 	list_add_tail(&clk->node, &clocks);
++	if (clk->parent)
++		list_add_tail(&clk->childnode, &clk->parent->children);
+ 	mutex_unlock(&clocks_mutex);
+ 
+ 	/* If rate is already set, use it */
+ 	if (clk->rate)
+ 		return 0;
+ 
++	/* Else, see if there is a way to calculate it */
++	if (clk->recalc)
++		clk->rate = clk->recalc(clk);
++
+ 	/* Otherwise, default to parent rate */
+-	if (clk->parent)
++	else if (clk->parent)
+ 		clk->rate = clk->parent->rate;
+ 
+ 	return 0;
+@@ -146,6 +211,7 @@ void clk_unregister(struct clk *clk)
+ 
+ 	mutex_lock(&clocks_mutex);
+ 	list_del(&clk->node);
++	list_del(&clk->childnode);
+ 	mutex_unlock(&clocks_mutex);
+ }
+ EXPORT_SYMBOL(clk_unregister);
+@@ -179,50 +245,62 @@ static int __init clk_disable_unused(voi
+ late_initcall(clk_disable_unused);
+ #endif
+ 
+-static void clk_sysclk_recalc(struct clk *clk)
++static unsigned long clk_sysclk_recalc(struct clk *clk)
+ {
+ 	u32 v, plldiv;
+ 	struct pll_data *pll;
++	unsigned long rate = clk->rate;
+ 
+ 	/* If this is the PLL base clock, no more calculations needed */
+ 	if (clk->pll_data)
+-		return;
++		return rate;
+ 
+ 	if (WARN_ON(!clk->parent))
+-		return;
++		return rate;
+ 
+-	clk->rate = clk->parent->rate;
++	rate = clk->parent->rate;
+ 
+ 	/* Otherwise, the parent must be a PLL */
+ 	if (WARN_ON(!clk->parent->pll_data))
+-		return;
++		return rate;
+ 
+ 	pll = clk->parent->pll_data;
+ 
+ 	/* If pre-PLL, source clock is before the multiplier and divider(s) */
+ 	if (clk->flags & PRE_PLL)
+-		clk->rate = pll->input_rate;
++		rate = pll->input_rate;
+ 
+ 	if (!clk->div_reg)
+-		return;
++		return rate;
+ 
+ 	v = __raw_readl(pll->base + clk->div_reg);
+ 	if (v & PLLDIV_EN) {
+ 		plldiv = (v & PLLDIV_RATIO_MASK) + 1;
+ 		if (plldiv)
+-			clk->rate /= plldiv;
++			rate /= plldiv;
+ 	}
++
++	return rate;
+ }
+ 
+-static void __init clk_pll_init(struct clk *clk)
++static unsigned long clk_leafclk_recalc(struct clk *clk)
++{
++	if (WARN_ON(!clk->parent))
++		return clk->rate;
++
++	return clk->parent->rate;
++}
++
++static unsigned long clk_pllclk_recalc(struct clk *clk)
+ {
+ 	u32 ctrl, mult = 1, prediv = 1, postdiv = 1;
+ 	u8 bypass;
+ 	struct pll_data *pll = clk->pll_data;
++	unsigned long rate = clk->rate;
+ 
+ 	pll->base = IO_ADDRESS(pll->phys_base);
+ 	ctrl = __raw_readl(pll->base + PLLCTL);
+-	clk->rate = pll->input_rate = clk->parent->rate;
++	rate = pll->input_rate = clk->parent->rate;
+ 
+ 	if (ctrl & PLLCTL_PLLEN) {
+ 		bypass = 0;
+@@ -255,9 +333,9 @@ static void __init clk_pll_init(struct c
+ 	}
+ 
+ 	if (!bypass) {
+-		clk->rate /= prediv;
+-		clk->rate *= mult;
+-		clk->rate /= postdiv;
++		rate /= prediv;
++		rate *= mult;
++		rate /= postdiv;
+ 	}
+ 
+ 	pr_debug("PLL%d: input = %lu MHz [ ",
+@@ -270,9 +348,91 @@ static void __init clk_pll_init(struct c
+ 		pr_debug("* %d ", mult);
+ 	if (postdiv > 1)
+ 		pr_debug("/ %d ", postdiv);
+-	pr_debug("] --> %lu MHz output.\n", clk->rate / 1000000);
++	pr_debug("] --> %lu MHz output.\n", rate / 1000000);
++
++	return rate;
+ }
+ 
++/**
++ * davinci_set_pllrate - set the output rate of a given PLL.
++ *
++ * Note: Currently tested to work with OMAP-L138 only.
++ *
++ * @pll: pll whose rate needs to be changed.
++ * @prediv: The pre divider value. Passing 0 disables the pre-divider.
++ * @pllm: The multiplier value. Passing 0 leads to multiply-by-one.
++ * @postdiv: The post divider value. Passing 0 disables the post-divider.
++ */
++int davinci_set_pllrate(struct pll_data *pll, unsigned int prediv,
++					unsigned int mult, unsigned int postdiv)
++{
++	u32 ctrl;
++	unsigned int locktime;
++
++	if (pll->base == NULL)
++		return -EINVAL;
++
++	/*
++	 *  PLL lock time required per OMAP-L138 datasheet is
++	 * (2000 * prediv)/sqrt(pllm) OSCIN cycles. We approximate sqrt(pllm)
++	 * as 4 and OSCIN cycle as 25 MHz.
++	 */
++	if (prediv) {
++		locktime = ((2000 * prediv) / 100);
++		prediv = (prediv - 1) | PLLDIV_EN;
++	} else {
++		locktime = 20;
++	}
++	if (postdiv)
++		postdiv = (postdiv - 1) | PLLDIV_EN;
++	if (mult)
++		mult = mult - 1;
++
++	ctrl = __raw_readl(pll->base + PLLCTL);
++
++	/* Switch the PLL to bypass mode */
++	ctrl &= ~(PLLCTL_PLLENSRC | PLLCTL_PLLEN);
++	__raw_writel(ctrl, pll->base + PLLCTL);
++
++	/*
++	 * Wait for 4 OSCIN/CLKIN cycles to ensure that the PLLC has switched
++	 * to bypass mode. Delay of 1us ensures we are good for all > 4MHz
++	 * OSCIN/CLKIN inputs. Typically the input is ~25MHz.
++	 */
++	udelay(1);
++
++	/* Reset and enable PLL */
++	ctrl &= ~(PLLCTL_PLLRST | PLLCTL_PLLDIS);
++	__raw_writel(ctrl, pll->base + PLLCTL);
++
++	if (pll->flags & PLL_HAS_PREDIV)
++		__raw_writel(prediv, pll->base + PREDIV);
++
++	__raw_writel(mult, pll->base + PLLM);
++
++	if (pll->flags & PLL_HAS_POSTDIV)
++		__raw_writel(postdiv, pll->base + POSTDIV);
++
++	/*
++	 * Wait for PLL to reset properly, OMAP-L138 datasheet says
++	 * 'min' time = 125ns
++	 */
++	udelay(1);
++
++	/* Bring PLL out of reset */
++	ctrl |= PLLCTL_PLLRST;
++	__raw_writel(ctrl, pll->base + PLLCTL);
++
++	udelay(locktime);
++
++	/* Remove PLL from bypass mode */
++	ctrl |= PLLCTL_PLLEN;
++	__raw_writel(ctrl, pll->base + PLLCTL);
++
++	return 0;
++}
++EXPORT_SYMBOL(davinci_set_pllrate);
++
+ int __init davinci_clk_init(struct davinci_clk *clocks)
+   {
+ 	struct davinci_clk *c;
+@@ -281,12 +441,23 @@ int __init davinci_clk_init(struct davin
+ 	for (c = clocks; c->lk.clk; c++) {
+ 		clk = c->lk.clk;
+ 
+-		if (clk->pll_data)
+-			clk_pll_init(clk);
++		if (!clk->recalc) {
++
++			/* Check if clock is a PLL */
++			if (clk->pll_data)
++				clk->recalc = clk_pllclk_recalc;
++
++			/* Else, if it is a PLL-derived clock */
++			else if (clk->flags & CLK_PLL)
++				clk->recalc = clk_sysclk_recalc;
++
++			/* Otherwise, it is a leaf clock (PSC clock) */
++			else if (clk->parent)
++				clk->recalc = clk_leafclk_recalc;
++		}
+ 
+-		/* Calculate rates for PLL-derived clocks */
+-		else if (clk->flags & CLK_PLL)
+-			clk_sysclk_recalc(clk);
++		if (clk->recalc)
++			clk->rate = clk->recalc(clk);
+ 
+ 		if (clk->lpsc)
+ 			clk->flags |= CLK_PSC;
+@@ -352,9 +523,8 @@ dump_clock(struct seq_file *s, unsigned
+ 	/* REVISIT show device associations too */
+ 
+ 	/* cost is now small, but not linear... */
+-	list_for_each_entry(clk, &clocks, node) {
+-		if (clk->parent == parent)
+-			dump_clock(s, nest + NEST_DELTA, clk);
++	list_for_each_entry(clk, &parent->children, childnode) {
++		dump_clock(s, nest + NEST_DELTA, clk);
+ 	}
+ }
+ 
+--- /dev/null
++++ b/drivers/spi/davinci_spi.h
+@@ -0,0 +1,179 @@
++/*
++ * Copyright (C) 2009 Texas Instruments.
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
++ */
++
++#ifndef __DAVINCI_SPI_H
++#define __DAVINCI_SPI_H
++
++#define SPI_MAX_CHIPSELECT	2
++
++#define CS_DEFAULT	0xFF
++#define SCS0_SELECT	0x01
++#define SCS1_SELECT	0x02
++#define SCS2_SELECT	0x04
++#define SCS3_SELECT	0x08
++#define SCS4_SELECT	0x10
++#define SCS5_SELECT	0x20
++#define SCS6_SELECT	0x40
++#define SCS7_SELECT	0x80
++
++#define SPIFMT_PHASE_MASK	BIT(16)
++#define SPIFMT_POLARITY_MASK	BIT(17)
++#define SPIFMT_DISTIMER_MASK	BIT(18)
++#define SPIFMT_SHIFTDIR_MASK	BIT(20)
++#define SPIFMT_WAITENA_MASK	BIT(21)
++#define SPIFMT_PARITYENA_MASK	BIT(22)
++#define SPIFMT_ODD_PARITY_MASK	BIT(23)
++#define SPIFMT_WDELAY_MASK	0x3f000000u
++#define SPIFMT_WDELAY_SHIFT	24
++#define SPIFMT_CHARLEN_MASK	0x0000001Fu
++
++/* SPIGCR1 */
++#define SPIGCR1_SPIENA_MASK	0x01000000u
++
++/* SPIPC0 */
++#define SPIPC0_DIFUN_MASK	BIT(11)		/* MISO */
++#define SPIPC0_DOFUN_MASK	BIT(10)		/* MOSI */
++#define SPIPC0_CLKFUN_MASK	BIT(9)		/* CLK */
++#define SPIPC0_SPIENA_MASK	BIT(8)		/* nREADY */
++#define SPIPC0_EN1FUN_MASK	BIT(1)
++#define SPIPC0_EN0FUN_MASK	BIT(0)
++
++#define SPIINT_MASKALL		0x0101035F
++#define SPI_INTLVL_1		0x000001FFu
++#define SPI_INTLVL_0		0x00000000u
++
++/* SPIDAT1 */
++#define SPIDAT1_CSHOLD_MASK	BIT(28)
++#define SPIDAT1_CSHOLD_SHIFT	28
++#define SPIDAT1_CSNR_MASK	(BIT(17 | BIT(16))
++#define SPIDAT1_CSNR_SHIFT	16
++#define SPIDAT1_DFSEL_MASK	(BIT(24 | BIT(25))
++#define SPIGCR1_CLKMOD_MASK	BIT(1)
++#define SPIGCR1_MASTER_MASK     BIT(0)
++#define SPIGCR1_LOOPBACK_MASK	BIT(16)
++
++/* SPIBUF */
++#define SPIBUF_TXFULL_MASK	BIT(29)
++#define SPIBUF_RXEMPTY_MASK	BIT(31)
++
++/* Error Masks */
++#define SPIFLG_DLEN_ERR_MASK		BIT(0)
++#define SPIFLG_TIMEOUT_MASK		BIT(1)
++#define SPIFLG_PARERR_MASK		BIT(2)
++#define SPIFLG_DESYNC_MASK		BIT(3)
++#define SPIFLG_BITERR_MASK		BIT(4)
++#define SPIFLG_OVRRUN_MASK		BIT(6)
++#define SPIFLG_RX_INTR_MASK		BIT(8)
++#define SPIFLG_TX_INTR_MASK		BIT(9)
++#define SPIFLG_BUF_INIT_ACTIVE_MASK	BIT(24)
++#define SPIFLG_MASK			(SPIFLG_DLEN_ERR_MASK \
++				| SPIFLG_TIMEOUT_MASK | SPIFLG_PARERR_MASK \
++				| SPIFLG_DESYNC_MASK | SPIFLG_BITERR_MASK \
++				| SPIFLG_OVRRUN_MASK | SPIFLG_RX_INTR_MASK \
++				| SPIFLG_TX_INTR_MASK \
++				| SPIFLG_BUF_INIT_ACTIVE_MASK)
++
++#define SPIINT_DLEN_ERR_INTR	BIT(0)
++#define SPIINT_TIMEOUT_INTR	BIT(1)
++#define SPIINT_PARERR_INTR	BIT(2)
++#define SPIINT_DESYNC_INTR	BIT(3)
++#define SPIINT_BITERR_INTR	BIT(4)
++#define SPIINT_OVRRUN_INTR	BIT(6)
++#define SPIINT_RX_INTR		BIT(8)
++#define SPIINT_TX_INTR		BIT(9)
++#define SPIINT_DMA_REQ_EN	BIT(16)
++#define SPIINT_ENABLE_HIGHZ	BIT(24)
++
++#define SPI_T2CDELAY_SHIFT	16
++#define SPI_C2TDELAY_SHIFT	24
++
++/* SPI Controller registers */
++#define SPIGCR0		0x00
++#define SPIGCR1		0x04
++#define SPIINT		0x08
++#define SPILVL		0x0c
++#define SPIFLG		0x10
++#define SPIPC0		0x14
++#define SPIPC1		0x18
++#define SPIPC2		0x1c
++#define SPIPC3		0x20
++#define SPIPC4		0x24
++#define SPIPC5		0x28
++#define SPIPC6		0x2c
++#define SPIPC7		0x30
++#define SPIPC8		0x34
++#define SPIDAT0		0x38
++#define SPIDAT1		0x3c
++#define SPIBUF		0x40
++#define SPIEMU		0x44
++#define SPIDELAY	0x48
++#define SPIDEF		0x4c
++#define SPIFMT0		0x50
++#define SPIFMT1		0x54
++#define SPIFMT2		0x58
++#define SPIFMT3		0x5c
++#define TGINTVEC0	0x60
++#define TGINTVEC1	0x64
++
++struct davinci_spi_slave {
++	u32	cmd_to_write;
++	u32	clk_ctrl_to_write;
++	u32	bytes_per_word;
++	u8	active_cs;
++};
++
++#define SPI_BUFSIZ	(SMP_CACHE_BYTES + 1)
++
++/* We have 2 DMA channels per CS, one for RX and one for TX */
++struct davinci_spi_dma {
++	int			dma_tx_channel;
++	int			dma_rx_channel;
++	int			dma_tx_sync_dev;
++	int			dma_rx_sync_dev;
++	enum dma_event_q	eventq;
++
++	struct completion	dma_tx_completion;
++	struct completion	dma_rx_completion;
++};
++
++/* SPI Controller driver's private data. */
++struct davinci_spi {
++	struct spi_bitbang	bitbang;
++	struct clk		*clk;
++
++	u8			version;
++	resource_size_t		pbase;
++	void __iomem		*base;
++	size_t			region_size;
++	u32			irq;
++	struct completion	done;
++
++	const void		*tx;
++	void			*rx;
++	u8			*tmp_buf;
++	int			count;
++	struct davinci_spi_dma	*dma_channels;
++	struct			davinci_spi_platform_data *pdata;
++
++	void			(*get_rx)(u32 rx_data, struct davinci_spi *);
++	u32			(*get_tx)(struct davinci_spi *);
++
++	struct davinci_spi_slave slave[SPI_MAX_CHIPSELECT];
++};
++
++#endif /* __DAVINCI_SPI_H */
+--- /dev/null
++++ b/drivers/media/video/ths8200.c
+@@ -0,0 +1,493 @@
++/*
++ * ths8200 - THS8200 Video Encoder Driver
++ *
++ * The encoder hardware does not support SECAM.
++ *
++ * Copyright (C) 2009 Texas Instruments Incorporated - http://www.ti.com/
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License as
++ * published by the Free Software Foundation version 2.
++ *
++ * This program is distributed .as is. WITHOUT ANY WARRANTY of any
++ * kind, whether express or implied; without even the implied warranty
++ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ */
++
++#include <linux/kernel.h>
++#include <linux/init.h>
++#include <linux/ctype.h>
++#include <linux/i2c.h>
++#include <linux/device.h>
++#include <linux/delay.h>
++#include <linux/module.h>
++#include <linux/videodev2.h>
++#include <linux/uaccess.h>
++#include <linux/version.h>
++
++#include <media/davinci/videohd.h>
++#include <media/ths8200.h>
++#include <media/v4l2-device.h>
++#include <media/v4l2-chip-ident.h>
++
++#include "ths8200_regs.h"
++
++MODULE_DESCRIPTION("THS8200 video encoder driver");
++MODULE_LICENSE("GPL");
++
++static int debug;
++module_param(debug, int, 0644);
++MODULE_PARM_DESC(debug, "Debug level 0-1");
++
++
++struct ths8200_state {
++	struct v4l2_subdev sd;
++	u32 output;
++	v4l2_std_id std;
++};
++
++enum ths8200_modes {
++	THS8200_1080P_60 = 0,
++	THS8200_1080I_60,
++	THS8200_720P_60,
++	THS8200_HDTV,
++	THS8200_480I_60,
++	THS8200_480P_60,
++	THS8200_VESA_MASTER,
++	THS8200_VESA_SLAVE,
++	THS8200_576I_60,
++	THS8200_SDTV
++};
++
++enum ths8200_input_intf {
++	THS8200_INTF_30BIT = 0,
++	THS8200_INTF_16BIT_RGB,
++	THS8200_INTF_15BIT_RGB,
++	THS8200_INTF_20BIT_YUV422,
++	THS8200_INTF_10BIT_YUV422
++};
++
++struct ths8200_mode_info {
++	v4l2_std_id std;
++	u32 input_intf;
++	enum ths8200_modes mode;
++	u32 frame_size;
++	u32 field_size;
++	u32 pixels_per_line;
++	u32 hs_in_delay;
++	u32 negative_hsync_width;
++	u32 positive_hsync_width;
++	u32 hfront_porch;
++	u32 hback_porch;
++	u32 vfront_porch;
++	u32 pulse_duration;
++	u32 full_line_pulse_duration;
++	u32 vback_porch;
++	u32 dtg_spec_k1;
++	u32 vs_in_delay;
++};
++
++static inline struct ths8200_state *to_state(struct v4l2_subdev *sd)
++{
++	return container_of(sd, struct ths8200_state, sd);
++}
++
++static inline int ths8200_read(struct v4l2_subdev *sd, u8 reg)
++{
++	struct i2c_client *client = v4l2_get_subdevdata(sd);
++
++	return i2c_smbus_read_byte_data(client, reg);
++}
++
++static inline int ths8200_write(struct v4l2_subdev *sd, u8 reg, u8 value)
++{
++	struct i2c_client *client = v4l2_get_subdevdata(sd);
++
++	return i2c_smbus_write_byte_data(client, reg, value);
++}
++
++static const struct ths8200_mode_info mode_info[] = {
++	/* 1080P Mode */
++	{V4L2_STD_1080P_60, THS8200_INTF_20BIT_YUV422, THS8200_1080P_60,
++		1125, 2047, 2200, 0x80,
++		44, 44, 132, 88, 192, 0x00, 0x00, 88, 0x00, 0x03},
++	/* SD Modes */
++	{V4L2_STD_525_60, THS8200_INTF_10BIT_YUV422, THS8200_480I_60,
++		525, 263, 858, 0x44,
++		0x3E, 0x1E, 0x79, 0x14, 0x00, 0x16B, 0x31B, 0x11, 0x0A, 0x00},
++	{V4L2_STD_625_50, THS8200_INTF_10BIT_YUV422, THS8200_576I_60,
++		525, 312, 864, 0x40,
++		0x3E, 0x20, 0x83, 0x58, 0xC0, 0x170, 0x31B, 0x0D, 0x0A, 0x02},
++	/* 720P Mode */
++	{V4L2_STD_720P_60, THS8200_INTF_20BIT_YUV422, THS8200_720P_60,
++		750, 2047, 1650, 0xA0,
++		0x2C, 0x2C, 0x84, 0x58, 0xC0, 0x00, 0x00, 0x58, 0x00, 0x05},
++	{V4L2_STD_720P_50, THS8200_INTF_20BIT_YUV422, THS8200_720P_60,
++		750, 2047, 1980, 0x1F0,
++		0x2C, 0x2C, 0x84, 0x58, 0xC0, 0x00, 0x00, 0x58, 0x00, 0x20},
++	/* 1080I Mode */
++	{V4L2_STD_1080I_60, THS8200_INTF_20BIT_YUV422, THS8200_1080I_60,
++		1125, 563, 2200, 0x8C,
++		44, 44, 132, 88, 192, 0x00, 0x00, 88, 0x00, 0x03},
++	{V4L2_STD_1080I_50, THS8200_INTF_20BIT_YUV422, THS8200_1080I_60,
++		1125, 563, 2640, 0x240,
++		44, 44, 132, 88, 192, 0x00, 0x00, 88, 0x00, 0x01},
++	/* ED Modes */
++	{V4L2_STD_525P_60, THS8200_INTF_20BIT_YUV422, THS8200_480P_60,
++		525, 0x7FF, 0x35A, 0x40,
++		0x3D, 0x20, 0x7A, 0x10, 0xC0, 0x190, 0x31B, 0x10, 0x00, 0x00}
++};
++
++
++#define ths8200_rset(a, b) ths8200_write(sd, a, b)
++static int ths8200_setstd(struct v4l2_subdev *sd, v4l2_std_id std)
++{
++	int num_std;
++	int err = -EINVAL;
++	int i = 0, value;
++
++	num_std = sizeof(mode_info) / sizeof(struct ths8200_mode_info);
++	for (i = 0; i < num_std; i++) {
++		if (std & mode_info[i].std) {
++			err = 0;
++
++			ths8200_write(sd, THS8200_CHIP_CTL, 0x01);
++
++			value = ths8200_read(sd, THS8200_DATA_CNTL);
++			value &= (~THS8200_DATA_CNTL_INTF_MASK);
++			value |=  mode_info[i].input_intf;
++			err |= ths8200_write(sd, THS8200_DATA_CNTL, value);
++
++			value = ths8200_read(sd, THS8200_DTG1_MODE);
++			value &= ~(THS8200_DTG1_MODE_MASK);
++			value |= mode_info[i].mode;
++			err |= ths8200_write(sd, THS8200_DTG1_MODE, value);
++
++			/* Set the pixels per line */
++			value = mode_info[i].pixels_per_line &
++				THS8200_DTG1_TOT_PIXELS_LSB_MASK;
++			err |= ths8200_write(sd,
++					THS8200_DTG1_TOT_PIXELS_LSB, value);
++			value = (mode_info[i].pixels_per_line >> 8) &
++				THS8200_DTG1_TOT_PIXELS_MSB_MASK;
++			err |= ths8200_write(sd,
++					THS8200_DTG1_TOT_PIXELS_MSB, value);
++
++			value = mode_info[i].pixels_per_line / 2;
++			err |= ths8200_write(sd, THS8200_DTG1_SPEC_G_LSB,
++					value & THS8200_DTG1_SPEC_G_LSB_MASK);
++			value = (value >> 8) & THS8200_DTG1_SPEC_G_MSB_MASK;
++			err |= ths8200_write(sd, THS8200_DTG1_SPEC_G_MSB,
++					value);
++
++			/* Set the frame size */
++			value = mode_info[i].frame_size &
++				THS8200_DTG1_FRAME_SZ_LSB_MASK;
++			err |= ths8200_write(sd,
++					THS8200_DTG1_FRAME_SZ_LSB, value);
++
++			value = ths8200_read(sd,
++					THS8200_DTG1_FRAME_FIELD_SZ_MSB);
++			value &= ~(THS8200_DTG1_FRAME_SZ_MSB_MASK);
++			value |= ((mode_info[i].frame_size >> 8) <<
++					THS8200_DTG1_FRAME_SZ_MSB_SHIFT) &
++				THS8200_DTG1_FRAME_SZ_MSB_MASK;
++			err |= ths8200_write(sd,
++					THS8200_DTG1_FRAME_FIELD_SZ_MSB,
++					value);
++
++			/* Set the field Size */
++			value = mode_info[i].field_size &
++				THS8200_DTG1_FIELD_SZ_LSB_MASK;
++			err |= ths8200_write(sd,
++					THS8200_DTG1_FIELD_SZ_LSB, value);
++
++			value = ths8200_read(sd,
++					THS8200_DTG1_FRAME_FIELD_SZ_MSB);
++			value &= ~(THS8200_DTG1_FIELD_SZ_MSB_MASK);
++			value |= ((mode_info[i].frame_size >> 8) <<
++					THS8200_DTG1_FIELD_SZ_MSB_SHIFT) &
++				THS8200_DTG1_FIELD_SZ_MSB_MASK;
++			err |= ths8200_write(sd,
++					THS8200_DTG1_FRAME_FIELD_SZ_MSB, value);
++
++			value = mode_info[i].hs_in_delay &
++				THS8200_DTG2_HS_IN_DLY_LSB_MASK;
++			err |= ths8200_write(sd, THS8200_DTG2_HS_IN_DLY_LSB,
++					value);
++			value = (mode_info[i].hs_in_delay >> 8) &
++				THS8200_DTG2_HS_IN_DLY_MSB_MASK;
++			err |= ths8200_write(sd, THS8200_DTG2_HS_IN_DLY_MSB,
++					value);
++
++			err |= ths8200_write(sd, THS8200_DTG1_SPEC_A,
++					mode_info[i].negative_hsync_width);
++			err |= ths8200_write(sd, THS8200_DTG1_SPEC_C,
++					mode_info[i].positive_hsync_width);
++
++			err |= ths8200_write(sd, THS8200_DTG1_SPEC_D_LSB,
++					(mode_info[i].hfront_porch &
++					 THS8200_DTG1_SPEC_D_LSB_MASK));
++			value = ths8200_read(sd, THS8200_DTG1_SPEC_DEH_MSB);
++			value &= 0x7F;
++			value |= ((mode_info[i].hfront_porch & 0x100) >> 1);
++
++			err |= ths8200_write(sd, THS8200_DTG1_SPEC_DEH_MSB,
++					value);
++
++			err |= ths8200_write(sd, THS8200_DTG1_SPEC_B,
++					mode_info[i].hback_porch);
++
++			err |= ths8200_write(sd, THS8200_DTG1_SPEC_E_LSB,
++					(mode_info[i].vfront_porch &
++					 THS8200_DTG1_SPEC_E_LSB_MASK));
++			value = ths8200_read(sd, THS8200_DTG1_SPEC_DEH_MSB);
++			value &= 0xBF;
++			value |= ((mode_info[i].vfront_porch & 0x100) >> 2);
++			err |= ths8200_write(sd, THS8200_DTG1_SPEC_DEH_MSB,
++					value);
++
++			err |= ths8200_write(sd, THS8200_DTG1_SPEC_H_LSB,
++					(mode_info[i].pulse_duration &
++					 THS8200_DTG1_SPEC_H_LSB_MASK));
++			value = ths8200_read(sd, THS8200_DTG1_SPEC_DEH_MSB);
++			value &= 0xFC;
++			value |= ((mode_info[i].pulse_duration >> 8) &
++					THS8200_DTG1_SPEC_DEH_MSB_MASK);
++			err |= ths8200_write(sd, THS8200_DTG1_SPEC_DEH_MSB,
++					value);
++
++			err |= ths8200_write(sd, THS8200_DTG1_SPEC_I_LSB,
++				(mode_info[i].full_line_pulse_duration &
++					 THS8200_DTG1_SPEC_I_LSB_MASK));
++			value = ths8200_read(sd, THS8200_DTG1_SPEC_I_MSB);
++			value &= 0xF0;
++			value |= ((mode_info[i].full_line_pulse_duration >>
++					8) &
++					THS8200_DTG1_SPEC_I_MSB_MASK);
++			err |= ths8200_write(sd, THS8200_DTG1_SPEC_I_MSB,
++					value);
++
++			err |= ths8200_write(sd, THS8200_DTG1_SPEC_K_LSB,
++					(mode_info[i].vback_porch &
++					 THS8200_DTG1_SPEC_K_LSB_MASK));
++			value = ths8200_read(sd, THS8200_DTG1_SPEC_K_MSB);
++			value &= 0xF8;
++			value |= ((mode_info[i].vback_porch >> 8) &
++					THS8200_DTG1_SPEC_K_MSB_MASK);
++			err |= ths8200_write(sd, THS8200_DTG1_SPEC_K_MSB,
++					value);
++
++			err |= ths8200_write(sd, THS8200_DTG1_SPEC_K1,
++					mode_info[i].dtg_spec_k1);
++
++			err |= ths8200_write(sd, THS8200_DTG2_VS_IN_DLY_LSB,
++					(mode_info[i].vs_in_delay &
++					 THS8200_DTG2_VS_IN_DLY_LSB_MASK));
++			err |= ths8200_write(sd, THS8200_DTG2_VS_IN_DLY_MSB,
++					((mode_info[i].vs_in_delay >> 8) &
++                                         THS8200_DTG2_VS_IN_DLY_MSB_MASK));
++			ths8200_write(sd, THS8200_CHIP_CTL, 0x00);
++			mdelay(10);
++			ths8200_write(sd, THS8200_CHIP_CTL, 0x01);
++
++			break;
++		}
++	}
++
++	if (i == num_std)
++		v4l2_err(sd, "Std not supported\n");
++	if (err != 0)
++		v4l2_err(sd, "Error setting std, write failed\n");
++
++	return err;
++}
++
++static int ths8200_setoutput(struct v4l2_subdev *sd, u32 output_type)
++{
++	return 0;
++}
++
++static int ths8200_log_status(struct v4l2_subdev *sd)
++{
++	struct ths8200_state *state = to_state(sd);
++
++	v4l2_info(sd, "Standard: %llx\n", (unsigned long long)state->std);
++	v4l2_info(sd, "Output: %s\n", (state->output == 0) ? "Composite" :
++			((state->output == 1) ? "Component" : "S-Video"));
++	return 0;
++}
++
++static int ths8200_queryctrl(struct v4l2_subdev *sd, struct v4l2_queryctrl *qc)
++{
++	return 0;
++}
++
++static int ths8200_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
++{
++	return 0;
++}
++
++static int ths8200_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
++{
++	return 0;
++}
++
++static int ths8200_g_chip_ident(struct v4l2_subdev *sd,
++				 struct v4l2_dbg_chip_ident *chip)
++{
++	struct i2c_client *client = v4l2_get_subdevdata(sd);
++
++	return v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_THS8200, 0);
++}
++
++static const struct v4l2_subdev_core_ops ths8200_core_ops = {
++	.log_status	= ths8200_log_status,
++	.g_chip_ident	= ths8200_g_chip_ident,
++	.g_ctrl		= ths8200_g_ctrl,
++	.s_ctrl		= ths8200_s_ctrl,
++	.queryctrl	= ths8200_queryctrl,
++	.s_std 		= ths8200_setstd,
++};
++
++static int ths8200_s_std_output(struct v4l2_subdev *sd, v4l2_std_id std)
++{
++	struct ths8200_state *state = to_state(sd);
++	int err = 0;
++
++	if (state->std == std)
++		return 0;
++
++	err = ths8200_setstd(sd, std);
++	if (!err)
++		state->std = std;
++
++	return err;
++}
++
++static int ths8200_s_routing(struct v4l2_subdev *sd,
++		u32 input, u32 output, u32 config)
++{
++	struct ths8200_state *state = to_state(sd);
++	int err = 0;
++
++	if (state->output == output)
++		return 0;
++
++	err = ths8200_setoutput(sd, output);
++	if (!err)
++		state->output = output;
++
++	return err;
++}
++
++static const struct v4l2_subdev_video_ops ths8200_video_ops = {
++	.s_std_output	= ths8200_s_std_output,
++	.s_routing	= ths8200_s_routing,
++};
++
++static const struct v4l2_subdev_ops ths8200_ops = {
++	.core	= &ths8200_core_ops,
++	.video	= &ths8200_video_ops,
++};
++
++static int ths8200_initialize(struct v4l2_subdev *sd)
++{
++	struct ths8200_state *state = to_state(sd);
++	int err = 0;
++	u8 value;
++
++	ths8200_write(sd, THS8200_CHIP_CTL, 0x01);
++
++	/* Initialize THS8200 registers */
++	value = ths8200_read(sd, THS8200_DTG1_MODE);
++	value |= THS8200_DTG1_MODE_DTG_ON_MASK;
++	err = ths8200_write(sd, THS8200_DTG1_MODE, value);
++
++	value = ths8200_read(sd, THS8200_DTG2_CNTL);
++	value |= THS8200_DTG2_CNTL_IGNORE_FID_MASK |
++		THS8200_DTG2_CNTL_EMD_TIMING_MASK;
++	value &= (~THS8200_DTG2_CNTL_RGB_MODE_MASK);
++	err |= ths8200_write(sd, THS8200_DTG2_CNTL, value);
++
++	value = ths8200_read(sd, THS8200_CSC_OFFS3);
++	value |= (THS8200_CSC_OFFS3_CSC_BYPASS_MASK |
++			THS8200_CSC_OFFS3_UNDER_OVERFLOW_MASK);
++	err |= ths8200_write(sd, THS8200_CSC_OFFS3, value);
++
++	err |= ths8200_write(sd, THS8200_CHIP_CTL, 0x00);
++	mdelay(10);
++	err |= ths8200_write(sd, THS8200_CHIP_CTL, 0x01);
++
++	err = ths8200_setstd(sd, state->std);
++	if (err < 0) {
++		v4l2_err(sd, "Error setting std during init\n");
++		return -EINVAL;
++	}
++
++	return err;
++}
++
++static int ths8200_probe(struct i2c_client *client,
++			 const struct i2c_device_id *id)
++{
++	struct ths8200_state *state;
++
++	if (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))
++		return -ENODEV;
++
++	v4l_info(client, "chip found @ 0x%x (%s)\n",
++			client->addr << 1, client->adapter->name);
++
++	state = kzalloc(sizeof(struct ths8200_state), GFP_KERNEL);
++	if (state == NULL)
++		return -ENOMEM;
++
++
++	state->output = THS8200_COMPONENT_ID;
++	state->std = V4L2_STD_1080P_60;
++
++	v4l2_i2c_subdev_init(&state->sd, client, &ths8200_ops);
++	return ths8200_initialize(&state->sd);
++}
++
++static int ths8200_remove(struct i2c_client *client)
++{
++	struct v4l2_subdev *sd = i2c_get_clientdata(client);
++
++	v4l2_device_unregister_subdev(sd);
++	kfree(to_state(sd));
++
++	return 0;
++}
++
++static const struct i2c_device_id ths8200_id[] = {
++	{"ths8200", 0},
++	{},
++};
++
++MODULE_DEVICE_TABLE(i2c, ths8200_id);
++
++static struct i2c_driver ths8200_driver = {
++	.driver = {
++		.owner	= THIS_MODULE,
++		.name	= "ths8200",
++	},
++	.probe		= ths8200_probe,
++	.remove		= ths8200_remove,
++	.id_table	= ths8200_id,
++};
++
++static __init int init_ths8200(void)
++{
++	return i2c_add_driver(&ths8200_driver);
++}
++
++static __exit void exit_ths8200(void)
++{
++	i2c_del_driver(&ths8200_driver);
++}
++
++module_init(init_ths8200);
++module_exit(exit_ths8200);
+--- /dev/null
++++ b/drivers/media/video/ths7303.h
+@@ -0,0 +1,25 @@
++/*
++ * ths7303- THS7303 Video Amplifier driver
++ *
++ * Copyright (C) 2009 Texas Instruments Incorporated - http://www.ti.com/
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License as
++ * published by the Free Software Foundation version 2.
++ *
++ * This program is distributed .as is. WITHOUT ANY WARRANTY of any
++ * kind, whether express or implied; without even the implied warranty
++ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ */
++
++/* all supported modes */
++enum ths7303_filter_mode {
++	THS7303_FILTER_MODE_480I_576I,
++	THS7303_FILTER_MODE_480P_576P,
++	THS7303_FILTER_MODE_720P_1080I,
++	THS7303_FILTER_MODE_1080P
++};
++
++int ths7303_setval(enum ths7303_filter_mode mode);
++
+--- a/arch/arm/mach-davinci/include/mach/timex.h
++++ b/arch/arm/mach-davinci/include/mach/timex.h
+@@ -11,7 +11,7 @@
+ #ifndef __ASM_ARCH_TIMEX_H
+ #define __ASM_ARCH_TIMEX_H
+ 
+-/* The source frequency for the timers is the 27MHz clock */
+-#define CLOCK_TICK_RATE 27000000
++/* The deafult source frequency for the timers is the 27MHz clock */
++#define CLOCK_TICK_RATE CONFIG_OSC_CLK_FREQ
+ 
+ #endif /* __ASM_ARCH_TIMEX_H__ */
+--- a/drivers/video/Makefile
++++ b/drivers/video/Makefile
+@@ -139,6 +139,7 @@ obj-$(CONFIG_FB_BF54X_LQ043)	  += bf54x-
+ obj-$(CONFIG_FB_BFIN_T350MCQB)	  += bfin-t350mcqb-fb.o
+ obj-$(CONFIG_FB_MX3)		  += mx3fb.o
+ obj-$(CONFIG_FB_DA8XX)		  += da8xx-fb.o
++obj-$(CONFIG_FB_DAVINCI)	  += davincifb.o
+ 
+ # the test framebuffer is last
+ obj-$(CONFIG_FB_VIRTUAL)          += vfb.o
+--- a/drivers/i2c/busses/i2c-davinci.c
++++ b/drivers/i2c/busses/i2c-davinci.c
+@@ -112,6 +112,7 @@ struct davinci_i2c_dev {
+ 	u8			*buf;
+ 	size_t			buf_len;
+ 	int			irq;
++	int			stop;
+ 	u8			terminate;
+ 	struct i2c_adapter	adapter;
+ };
+@@ -249,9 +250,6 @@ i2c_davinci_xfer_msg(struct i2c_adapter
+ 	u16 w;
+ 	int r;
+ 
+-	if (msg->len == 0)
+-		return -EINVAL;
+-
+ 	if (!pdata)
+ 		pdata = &davinci_i2c_platform_data_default;
+ 	/* Introduce a delay, required for some boards (e.g Davinci EVM) */
+@@ -263,6 +261,7 @@ i2c_davinci_xfer_msg(struct i2c_adapter
+ 
+ 	dev->buf = msg->buf;
+ 	dev->buf_len = msg->len;
++	dev->stop = stop;
+ 
+ 	davinci_i2c_write_reg(dev, DAVINCI_I2C_CNT_REG, dev->buf_len);
+ 
+@@ -280,6 +279,10 @@ i2c_davinci_xfer_msg(struct i2c_adapter
+ 		flag |= DAVINCI_I2C_MDR_TRX;
+ 	if (stop)
+ 		flag |= DAVINCI_I2C_MDR_STP;
++	if (msg->len == 0) {
++		flag |= DAVINCI_I2C_MDR_RM;
++		flag &= ~DAVINCI_I2C_MDR_STP;
++	}
+ 
+ 	/* Enable receive or transmit interrupts */
+ 	w = davinci_i2c_read_reg(dev, DAVINCI_I2C_IMR_REG);
+@@ -290,6 +293,16 @@ i2c_davinci_xfer_msg(struct i2c_adapter
+ 	davinci_i2c_write_reg(dev, DAVINCI_I2C_IMR_REG, w);
+ 
+ 	dev->terminate = 0;
++
++	/* First byte should be set here, not after interrupt,
++	 * because transmit-data-ready interrupt can come before
++	 * NACK-interrupt during sending of previous message and
++	 * ICDXR may have wrong data */
++	if ((!(msg->flags & I2C_M_RD)) && dev->buf_len) {
++		davinci_i2c_write_reg(dev, DAVINCI_I2C_DXR_REG, *dev->buf++);
++		dev->buf_len--;
++	}
++
+ 	/* write the data into mode register */
+ 	davinci_i2c_write_reg(dev, DAVINCI_I2C_MDR_REG, flag);
+ 
+@@ -371,7 +384,7 @@ i2c_davinci_xfer(struct i2c_adapter *ada
+ 
+ static u32 i2c_davinci_func(struct i2c_adapter *adap)
+ {
+-	return I2C_FUNC_I2C | (I2C_FUNC_SMBUS_EMUL & ~I2C_FUNC_SMBUS_QUICK);
++	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;
+ }
+ 
+ static void terminate_read(struct davinci_i2c_dev *dev)
+@@ -430,6 +443,14 @@ static irqreturn_t i2c_davinci_isr(int t
+ 		case DAVINCI_I2C_IVR_ARDY:
+ 			davinci_i2c_write_reg(dev,
+ 				DAVINCI_I2C_STR_REG, DAVINCI_I2C_STR_ARDY);
++			if (((dev->buf_len == 0) && (dev->stop != 0)) ||
++			    (dev->cmd_err & DAVINCI_I2C_STR_NACK)) {
++				w = davinci_i2c_read_reg(dev,
++							 DAVINCI_I2C_MDR_REG);
++				MOD_REG_BIT(w, DAVINCI_I2C_MDR_STP, 1);
++				davinci_i2c_write_reg(dev,
++						      DAVINCI_I2C_MDR_REG, w);
++			}
+ 			complete(&dev->cmd_complete);
+ 			break;
+ 
+--- /dev/null
++++ b/include/media/davinci/videohd.h
+@@ -0,0 +1,33 @@
++/*
++ * videohd.h - Defines temporary HD standards for video drivers
++ *
++ * Copyright (C) 2009 Texas Instruments Incorporated - http://www.ti.com/
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License as
++ * published by the Free Software Foundation version 2.
++ *
++ * This program is distributed .as is. WITHOUT ANY WARRANTY of any
++ * kind, whether express or implied; without even the implied warranty
++ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * This header file will hold all Digital TV video HD/ED standards until same is
++ * supported by v4l2 sub system. Moving this to this file will help avoid
++ * unnecessary merge issues. Once the support is available, we could discard
++ * this file
++ */
++#ifndef __VIDEOHD_H
++#define __VIDEOHD_H
++
++/* Digital TV standards */
++#define V4L2_STD_525P_60        ((v4l2_std_id)(0x0001000000000000ULL))
++#define V4L2_STD_625P_50        ((v4l2_std_id)(0x0002000000000000ULL))
++#define V4L2_STD_720P_60        ((v4l2_std_id)(0x0004000000000000ULL))
++#define V4L2_STD_720P_50        ((v4l2_std_id)(0x0008000000000000ULL))
++#define V4L2_STD_1080I_60       ((v4l2_std_id)(0x0010000000000000ULL))
++#define V4L2_STD_1080I_50       ((v4l2_std_id)(0x0020000000000000ULL))
++#define V4L2_STD_1080P_60       ((v4l2_std_id)(0x0040000000000000ULL))
++#define V4L2_STD_1080P_50       ((v4l2_std_id)(0x0080000000000000ULL))
++
++#endif
+--- /dev/null
++++ b/arch/arm/configs/davinci_dm355_defconfig
+@@ -0,0 +1,1857 @@
++#
++# Automatically generated make config: don't edit
++# Linux kernel version: 2.6.32-rc2-davinci1
++# Fri Oct 30 16:52:22 2009
++#
++CONFIG_ARM=y
++CONFIG_SYS_SUPPORTS_APM_EMULATION=y
++CONFIG_GENERIC_GPIO=y
++CONFIG_GENERIC_TIME=y
++CONFIG_GENERIC_CLOCKEVENTS=y
++CONFIG_GENERIC_HARDIRQS=y
++CONFIG_STACKTRACE_SUPPORT=y
++CONFIG_HAVE_LATENCYTOP_SUPPORT=y
++CONFIG_LOCKDEP_SUPPORT=y
++CONFIG_TRACE_IRQFLAGS_SUPPORT=y
++CONFIG_HARDIRQS_SW_RESEND=y
++CONFIG_GENERIC_IRQ_PROBE=y
++CONFIG_RWSEM_GENERIC_SPINLOCK=y
++CONFIG_GENERIC_HWEIGHT=y
++CONFIG_GENERIC_CALIBRATE_DELAY=y
++CONFIG_ZONE_DMA=y
++CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
++CONFIG_VECTORS_BASE=0xffff0000
++CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
++CONFIG_CONSTRUCTORS=y
++
++#
++# General setup
++#
++CONFIG_EXPERIMENTAL=y
++CONFIG_BROKEN_ON_SMP=y
++CONFIG_LOCK_KERNEL=y
++CONFIG_INIT_ENV_ARG_LIMIT=32
++CONFIG_LOCALVERSION=""
++CONFIG_LOCALVERSION_AUTO=y
++# CONFIG_SWAP is not set
++CONFIG_SYSVIPC=y
++CONFIG_SYSVIPC_SYSCTL=y
++CONFIG_POSIX_MQUEUE=y
++CONFIG_POSIX_MQUEUE_SYSCTL=y
++# CONFIG_BSD_PROCESS_ACCT is not set
++# CONFIG_TASKSTATS is not set
++# CONFIG_AUDIT is not set
++
++#
++# RCU Subsystem
++#
++CONFIG_TREE_RCU=y
++# CONFIG_TREE_PREEMPT_RCU is not set
++# CONFIG_RCU_TRACE is not set
++CONFIG_RCU_FANOUT=32
++# CONFIG_RCU_FANOUT_EXACT is not set
++# CONFIG_TREE_RCU_TRACE is not set
++CONFIG_IKCONFIG=y
++CONFIG_IKCONFIG_PROC=y
++CONFIG_LOG_BUF_SHIFT=14
++CONFIG_GROUP_SCHED=y
++CONFIG_FAIR_GROUP_SCHED=y
++# CONFIG_RT_GROUP_SCHED is not set
++CONFIG_USER_SCHED=y
++# CONFIG_CGROUP_SCHED is not set
++# CONFIG_CGROUPS is not set
++# CONFIG_SYSFS_DEPRECATED_V2 is not set
++# CONFIG_RELAY is not set
++# CONFIG_NAMESPACES is not set
++CONFIG_BLK_DEV_INITRD=y
++CONFIG_INITRAMFS_SOURCE=""
++CONFIG_RD_GZIP=y
++# CONFIG_RD_BZIP2 is not set
++# CONFIG_RD_LZMA is not set
++CONFIG_CC_OPTIMIZE_FOR_SIZE=y
++CONFIG_SYSCTL=y
++CONFIG_ANON_INODES=y
++CONFIG_EMBEDDED=y
++CONFIG_UID16=y
++CONFIG_SYSCTL_SYSCALL=y
++CONFIG_KALLSYMS=y
++# CONFIG_KALLSYMS_ALL is not set
++# CONFIG_KALLSYMS_EXTRA_PASS is not set
++CONFIG_HOTPLUG=y
++CONFIG_PRINTK=y
++CONFIG_BUG=y
++CONFIG_ELF_CORE=y
++CONFIG_BASE_FULL=y
++CONFIG_FUTEX=y
++CONFIG_EPOLL=y
++CONFIG_SIGNALFD=y
++CONFIG_TIMERFD=y
++CONFIG_EVENTFD=y
++CONFIG_SHMEM=y
++CONFIG_AIO=y
++
++#
++# Kernel Performance Events And Counters
++#
++CONFIG_VM_EVENT_COUNTERS=y
++CONFIG_SLUB_DEBUG=y
++CONFIG_COMPAT_BRK=y
++# CONFIG_SLAB is not set
++CONFIG_SLUB=y
++# CONFIG_SLOB is not set
++# CONFIG_PROFILING is not set
++CONFIG_HAVE_OPROFILE=y
++# CONFIG_KPROBES is not set
++CONFIG_HAVE_KPROBES=y
++CONFIG_HAVE_KRETPROBES=y
++CONFIG_HAVE_CLK=y
++
++#
++# GCOV-based kernel profiling
++#
++# CONFIG_GCOV_KERNEL is not set
++# CONFIG_SLOW_WORK is not set
++CONFIG_HAVE_GENERIC_DMA_COHERENT=y
++CONFIG_SLABINFO=y
++CONFIG_RT_MUTEXES=y
++CONFIG_BASE_SMALL=0
++CONFIG_MODULES=y
++# CONFIG_MODULE_FORCE_LOAD is not set
++CONFIG_MODULE_UNLOAD=y
++CONFIG_MODULE_FORCE_UNLOAD=y
++CONFIG_MODVERSIONS=y
++# CONFIG_MODULE_SRCVERSION_ALL is not set
++CONFIG_BLOCK=y
++CONFIG_LBDAF=y
++# CONFIG_BLK_DEV_BSG is not set
++# CONFIG_BLK_DEV_INTEGRITY is not set
++
++#
++# IO Schedulers
++#
++CONFIG_IOSCHED_NOOP=y
++CONFIG_IOSCHED_AS=y
++# CONFIG_IOSCHED_DEADLINE is not set
++# CONFIG_IOSCHED_CFQ is not set
++CONFIG_DEFAULT_AS=y
++# CONFIG_DEFAULT_DEADLINE is not set
++# CONFIG_DEFAULT_CFQ is not set
++# CONFIG_DEFAULT_NOOP is not set
++CONFIG_DEFAULT_IOSCHED="anticipatory"
++# CONFIG_FREEZER is not set
++
++#
++# System Type
++#
++CONFIG_MMU=y
++# CONFIG_ARCH_AAEC2000 is not set
++# CONFIG_ARCH_INTEGRATOR is not set
++# CONFIG_ARCH_REALVIEW is not set
++# CONFIG_ARCH_VERSATILE is not set
++# CONFIG_ARCH_AT91 is not set
++# CONFIG_ARCH_CLPS711X is not set
++# CONFIG_ARCH_GEMINI is not set
++# CONFIG_ARCH_EBSA110 is not set
++# CONFIG_ARCH_EP93XX is not set
++# CONFIG_ARCH_FOOTBRIDGE is not set
++# CONFIG_ARCH_MXC is not set
++# CONFIG_ARCH_STMP3XXX is not set
++# CONFIG_ARCH_NETX is not set
++# CONFIG_ARCH_H720X is not set
++# CONFIG_ARCH_NOMADIK is not set
++# CONFIG_ARCH_IOP13XX is not set
++# CONFIG_ARCH_IOP32X is not set
++# CONFIG_ARCH_IOP33X is not set
++# CONFIG_ARCH_IXP23XX is not set
++# CONFIG_ARCH_IXP2000 is not set
++# CONFIG_ARCH_IXP4XX is not set
++# CONFIG_ARCH_L7200 is not set
++# CONFIG_ARCH_KIRKWOOD is not set
++# CONFIG_ARCH_LOKI is not set
++# CONFIG_ARCH_MV78XX0 is not set
++# CONFIG_ARCH_ORION5X is not set
++# CONFIG_ARCH_MMP is not set
++# CONFIG_ARCH_KS8695 is not set
++# CONFIG_ARCH_NS9XXX is not set
++# CONFIG_ARCH_W90X900 is not set
++# CONFIG_ARCH_PNX4008 is not set
++# CONFIG_ARCH_PXA is not set
++# CONFIG_ARCH_MSM is not set
++# CONFIG_ARCH_RPC is not set
++# CONFIG_ARCH_SA1100 is not set
++# CONFIG_ARCH_S3C2410 is not set
++# CONFIG_ARCH_S3C64XX is not set
++# CONFIG_ARCH_S5PC1XX is not set
++# CONFIG_ARCH_SHARK is not set
++# CONFIG_ARCH_LH7A40X is not set
++# CONFIG_ARCH_U300 is not set
++CONFIG_ARCH_DAVINCI=y
++# CONFIG_ARCH_OMAP is not set
++# CONFIG_ARCH_BCMRING is not set
++CONFIG_AINTC=y
++CONFIG_ARCH_DAVINCI_DMx=y
++
++#
++# TI DaVinci Implementations
++#
++
++#
++# DaVinci Core Type
++#
++# CONFIG_ARCH_DAVINCI_DM644x is not set
++CONFIG_ARCH_DAVINCI_DM355=y
++# CONFIG_ARCH_DAVINCI_DM646x is not set
++# CONFIG_ARCH_DAVINCI_DA830 is not set
++# CONFIG_ARCH_DAVINCI_DA850 is not set
++# CONFIG_ARCH_DAVINCI_DM365 is not set
++
++#
++# DaVinci Board Type
++#
++CONFIG_MACH_DAVINCI_DM355_EVM=y
++# CONFIG_MACH_DM355_LEOPARD is not set
++CONFIG_DAVINCI_MUX=y
++# CONFIG_DAVINCI_MUX_DEBUG is not set
++# CONFIG_DAVINCI_MUX_WARNINGS is not set
++CONFIG_DAVINCI_RESET_CLOCKS=y
++CONFIG_OSC_CLK_FREQ=27000000
++
++#
++# Processor Type
++#
++CONFIG_CPU_32=y
++CONFIG_CPU_ARM926T=y
++CONFIG_CPU_32v5=y
++CONFIG_CPU_ABRT_EV5TJ=y
++CONFIG_CPU_PABRT_NOIFAR=y
++CONFIG_CPU_CACHE_VIVT=y
++CONFIG_CPU_COPY_V4WB=y
++CONFIG_CPU_TLB_V4WBI=y
++CONFIG_CPU_CP15=y
++CONFIG_CPU_CP15_MMU=y
++
++#
++# Processor Features
++#
++CONFIG_ARM_THUMB=y
++# CONFIG_CPU_ICACHE_DISABLE is not set
++# CONFIG_CPU_DCACHE_DISABLE is not set
++# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
++# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
++CONFIG_ARM_L1_CACHE_SHIFT=5
++CONFIG_COMMON_CLKDEV=y
++CONFIG_FORCE_MAX_ZONEORDER=13
++
++#
++# Bus support
++#
++# CONFIG_PCI_SYSCALL is not set
++# CONFIG_ARCH_SUPPORTS_MSI is not set
++# CONFIG_PCCARD is not set
++
++#
++# Kernel Features
++#
++CONFIG_TICK_ONESHOT=y
++CONFIG_NO_HZ=y
++CONFIG_HIGH_RES_TIMERS=y
++CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
++CONFIG_VMSPLIT_3G=y
++# CONFIG_VMSPLIT_2G is not set
++# CONFIG_VMSPLIT_1G is not set
++CONFIG_PAGE_OFFSET=0xC0000000
++# CONFIG_PREEMPT_NONE is not set
++# CONFIG_PREEMPT_VOLUNTARY is not set
++CONFIG_PREEMPT=y
++CONFIG_HZ=100
++CONFIG_AEABI=y
++# CONFIG_OABI_COMPAT is not set
++# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
++# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
++# CONFIG_HIGHMEM is not set
++CONFIG_SELECT_MEMORY_MODEL=y
++CONFIG_FLATMEM_MANUAL=y
++# CONFIG_DISCONTIGMEM_MANUAL is not set
++# CONFIG_SPARSEMEM_MANUAL is not set
++CONFIG_FLATMEM=y
++CONFIG_FLAT_NODE_MEM_MAP=y
++CONFIG_PAGEFLAGS_EXTENDED=y
++CONFIG_SPLIT_PTLOCK_CPUS=4096
++# CONFIG_PHYS_ADDR_T_64BIT is not set
++CONFIG_ZONE_DMA_FLAG=1
++CONFIG_BOUNCE=y
++CONFIG_VIRT_TO_BUS=y
++CONFIG_HAVE_MLOCK=y
++CONFIG_HAVE_MLOCKED_PAGE_BIT=y
++# CONFIG_KSM is not set
++CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
++CONFIG_LEDS=y
++# CONFIG_LEDS_CPU is not set
++CONFIG_ALIGNMENT_TRAP=y
++# CONFIG_UACCESS_WITH_MEMCPY is not set
++
++#
++# Boot options
++#
++CONFIG_ZBOOT_ROM_TEXT=0x0
++CONFIG_ZBOOT_ROM_BSS=0x0
++CONFIG_CMDLINE=""
++# CONFIG_XIP_KERNEL is not set
++# CONFIG_KEXEC is not set
++
++#
++# CPU Power Management
++#
++# CONFIG_CPU_IDLE is not set
++
++#
++# Floating point emulation
++#
++
++#
++# At least one emulation must be selected
++#
++# CONFIG_VFP is not set
++
++#
++# Userspace binary formats
++#
++CONFIG_BINFMT_ELF=y
++# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
++CONFIG_HAVE_AOUT=y
++# CONFIG_BINFMT_AOUT is not set
++# CONFIG_BINFMT_MISC is not set
++
++#
++# Power management options
++#
++# CONFIG_PM is not set
++CONFIG_ARCH_SUSPEND_POSSIBLE=y
++CONFIG_NET=y
++
++#
++# Networking options
++#
++CONFIG_PACKET=y
++# CONFIG_PACKET_MMAP is not set
++CONFIG_UNIX=y
++CONFIG_XFRM=y
++# CONFIG_XFRM_USER is not set
++# CONFIG_XFRM_SUB_POLICY is not set
++# CONFIG_XFRM_MIGRATE is not set
++# CONFIG_XFRM_STATISTICS is not set
++# CONFIG_NET_KEY is not set
++CONFIG_INET=y
++# CONFIG_IP_MULTICAST is not set
++# CONFIG_IP_ADVANCED_ROUTER is not set
++CONFIG_IP_FIB_HASH=y
++CONFIG_IP_PNP=y
++CONFIG_IP_PNP_DHCP=y
++# CONFIG_IP_PNP_BOOTP is not set
++# CONFIG_IP_PNP_RARP is not set
++# CONFIG_NET_IPIP is not set
++# CONFIG_NET_IPGRE is not set
++# CONFIG_ARPD is not set
++# CONFIG_SYN_COOKIES is not set
++# CONFIG_INET_AH is not set
++# CONFIG_INET_ESP is not set
++# CONFIG_INET_IPCOMP is not set
++# CONFIG_INET_XFRM_TUNNEL is not set
++CONFIG_INET_TUNNEL=m
++CONFIG_INET_XFRM_MODE_TRANSPORT=y
++CONFIG_INET_XFRM_MODE_TUNNEL=y
++CONFIG_INET_XFRM_MODE_BEET=y
++# CONFIG_INET_LRO is not set
++CONFIG_INET_DIAG=y
++CONFIG_INET_TCP_DIAG=y
++# CONFIG_TCP_CONG_ADVANCED is not set
++CONFIG_TCP_CONG_CUBIC=y
++CONFIG_DEFAULT_TCP_CONG="cubic"
++# CONFIG_TCP_MD5SIG is not set
++CONFIG_IPV6=m
++# CONFIG_IPV6_PRIVACY is not set
++# CONFIG_IPV6_ROUTER_PREF is not set
++# CONFIG_IPV6_OPTIMISTIC_DAD is not set
++# CONFIG_INET6_AH is not set
++# CONFIG_INET6_ESP is not set
++# CONFIG_INET6_IPCOMP is not set
++# CONFIG_IPV6_MIP6 is not set
++# CONFIG_INET6_XFRM_TUNNEL is not set
++# CONFIG_INET6_TUNNEL is not set
++CONFIG_INET6_XFRM_MODE_TRANSPORT=m
++CONFIG_INET6_XFRM_MODE_TUNNEL=m
++CONFIG_INET6_XFRM_MODE_BEET=m
++# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
++CONFIG_IPV6_SIT=m
++CONFIG_IPV6_NDISC_NODETYPE=y
++# CONFIG_IPV6_TUNNEL is not set
++# CONFIG_IPV6_MULTIPLE_TABLES is not set
++# CONFIG_IPV6_MROUTE is not set
++# CONFIG_NETWORK_SECMARK is not set
++CONFIG_NETFILTER=y
++# CONFIG_NETFILTER_DEBUG is not set
++CONFIG_NETFILTER_ADVANCED=y
++
++#
++# Core Netfilter Configuration
++#
++# CONFIG_NETFILTER_NETLINK_QUEUE is not set
++# CONFIG_NETFILTER_NETLINK_LOG is not set
++# CONFIG_NF_CONNTRACK is not set
++# CONFIG_NETFILTER_XTABLES is not set
++# CONFIG_IP_VS is not set
++
++#
++# IP: Netfilter Configuration
++#
++# CONFIG_NF_DEFRAG_IPV4 is not set
++# CONFIG_IP_NF_QUEUE is not set
++# CONFIG_IP_NF_IPTABLES is not set
++# CONFIG_IP_NF_ARPTABLES is not set
++
++#
++# IPv6: Netfilter Configuration
++#
++# CONFIG_IP6_NF_QUEUE is not set
++# CONFIG_IP6_NF_IPTABLES is not set
++# CONFIG_IP_DCCP is not set
++# CONFIG_IP_SCTP is not set
++# CONFIG_RDS is not set
++# CONFIG_TIPC is not set
++# CONFIG_ATM is not set
++# CONFIG_BRIDGE is not set
++# CONFIG_NET_DSA is not set
++# CONFIG_VLAN_8021Q is not set
++# CONFIG_DECNET is not set
++# CONFIG_LLC2 is not set
++# CONFIG_IPX is not set
++# CONFIG_ATALK is not set
++# CONFIG_X25 is not set
++# CONFIG_LAPB is not set
++# CONFIG_ECONET is not set
++# CONFIG_WAN_ROUTER is not set
++# CONFIG_PHONET is not set
++# CONFIG_IEEE802154 is not set
++# CONFIG_NET_SCHED is not set
++# CONFIG_DCB is not set
++
++#
++# Network testing
++#
++# CONFIG_NET_PKTGEN is not set
++# CONFIG_HAMRADIO is not set
++# CONFIG_CAN is not set
++# CONFIG_IRDA is not set
++# CONFIG_BT is not set
++# CONFIG_AF_RXRPC is not set
++CONFIG_WIRELESS=y
++CONFIG_CFG80211=y
++# CONFIG_NL80211_TESTMODE is not set
++# CONFIG_CFG80211_DEVELOPER_WARNINGS is not set
++# CONFIG_CFG80211_REG_DEBUG is not set
++CONFIG_CFG80211_DEFAULT_PS=y
++CONFIG_CFG80211_DEFAULT_PS_VALUE=1
++# CONFIG_CFG80211_DEBUGFS is not set
++CONFIG_WIRELESS_OLD_REGULATORY=y
++CONFIG_WIRELESS_EXT=y
++CONFIG_WIRELESS_EXT_SYSFS=y
++CONFIG_LIB80211=y
++# CONFIG_LIB80211_DEBUG is not set
++# CONFIG_MAC80211 is not set
++# CONFIG_WIMAX is not set
++# CONFIG_RFKILL is not set
++# CONFIG_NET_9P is not set
++
++#
++# Device Drivers
++#
++
++#
++# Generic Driver Options
++#
++CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
++# CONFIG_DEVTMPFS is not set
++CONFIG_STANDALONE=y
++CONFIG_PREVENT_FIRMWARE_BUILD=y
++CONFIG_FW_LOADER=y
++CONFIG_FIRMWARE_IN_KERNEL=y
++CONFIG_EXTRA_FIRMWARE=""
++# CONFIG_DEBUG_DRIVER is not set
++# CONFIG_DEBUG_DEVRES is not set
++# CONFIG_SYS_HYPERVISOR is not set
++# CONFIG_CONNECTOR is not set
++CONFIG_MTD=y
++# CONFIG_MTD_DEBUG is not set
++CONFIG_MTD_TESTS=m
++# CONFIG_MTD_CONCAT is not set
++CONFIG_MTD_PARTITIONS=y
++# CONFIG_MTD_REDBOOT_PARTS is not set
++CONFIG_MTD_CMDLINE_PARTS=y
++# CONFIG_MTD_AFS_PARTS is not set
++# CONFIG_MTD_AR7_PARTS is not set
++
++#
++# User Modules And Translation Layers
++#
++CONFIG_MTD_CHAR=y
++CONFIG_MTD_BLKDEVS=y
++CONFIG_MTD_BLOCK=y
++# CONFIG_FTL is not set
++# CONFIG_NFTL is not set
++# CONFIG_INFTL is not set
++# CONFIG_RFD_FTL is not set
++# CONFIG_SSFDC is not set
++# CONFIG_MTD_OOPS is not set
++
++#
++# RAM/ROM/Flash chip drivers
++#
++# CONFIG_MTD_CFI is not set
++# CONFIG_MTD_JEDECPROBE is not set
++CONFIG_MTD_MAP_BANK_WIDTH_1=y
++CONFIG_MTD_MAP_BANK_WIDTH_2=y
++CONFIG_MTD_MAP_BANK_WIDTH_4=y
++# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
++# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
++# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
++CONFIG_MTD_CFI_I1=y
++CONFIG_MTD_CFI_I2=y
++# CONFIG_MTD_CFI_I4 is not set
++# CONFIG_MTD_CFI_I8 is not set
++# CONFIG_MTD_RAM is not set
++# CONFIG_MTD_ROM is not set
++# CONFIG_MTD_ABSENT is not set
++
++#
++# Mapping drivers for chip access
++#
++# CONFIG_MTD_COMPLEX_MAPPINGS is not set
++# CONFIG_MTD_PLATRAM is not set
++
++#
++# Self-contained MTD device drivers
++#
++# CONFIG_MTD_DATAFLASH is not set
++# CONFIG_MTD_M25P80 is not set
++# CONFIG_MTD_SST25L is not set
++# CONFIG_MTD_SLRAM is not set
++# CONFIG_MTD_PHRAM is not set
++# CONFIG_MTD_MTDRAM is not set
++# CONFIG_MTD_BLOCK2MTD is not set
++
++#
++# Disk-On-Chip Device Drivers
++#
++# CONFIG_MTD_DOC2000 is not set
++# CONFIG_MTD_DOC2001 is not set
++# CONFIG_MTD_DOC2001PLUS is not set
++CONFIG_MTD_NAND=y
++# CONFIG_MTD_NAND_VERIFY_WRITE is not set
++# CONFIG_MTD_NAND_ECC_SMC is not set
++# CONFIG_MTD_NAND_MUSEUM_IDS is not set
++# CONFIG_MTD_NAND_GPIO is not set
++CONFIG_MTD_NAND_IDS=y
++# CONFIG_MTD_NAND_DISKONCHIP is not set
++# CONFIG_MTD_NAND_NANDSIM is not set
++# CONFIG_MTD_NAND_PLATFORM is not set
++# CONFIG_MTD_ALAUDA is not set
++CONFIG_MTD_NAND_DAVINCI=y
++# CONFIG_MTD_ONENAND is not set
++
++#
++# LPDDR flash memory drivers
++#
++# CONFIG_MTD_LPDDR is not set
++
++#
++# UBI - Unsorted block images
++#
++# CONFIG_MTD_UBI is not set
++# CONFIG_PARPORT is not set
++CONFIG_BLK_DEV=y
++# CONFIG_BLK_DEV_COW_COMMON is not set
++CONFIG_BLK_DEV_LOOP=m
++# CONFIG_BLK_DEV_CRYPTOLOOP is not set
++# CONFIG_BLK_DEV_NBD is not set
++# CONFIG_BLK_DEV_UB is not set
++CONFIG_BLK_DEV_RAM=y
++CONFIG_BLK_DEV_RAM_COUNT=1
++CONFIG_BLK_DEV_RAM_SIZE=32768
++# CONFIG_BLK_DEV_XIP is not set
++# CONFIG_CDROM_PKTCDVD is not set
++# CONFIG_ATA_OVER_ETH is not set
++# CONFIG_MG_DISK is not set
++CONFIG_MISC_DEVICES=y
++# CONFIG_ICS932S401 is not set
++# CONFIG_ENCLOSURE_SERVICES is not set
++# CONFIG_ISL29003 is not set
++# CONFIG_C2PORT is not set
++
++#
++# EEPROM support
++#
++# CONFIG_EEPROM_AT24 is not set
++CONFIG_EEPROM_AT25=y
++# CONFIG_EEPROM_LEGACY is not set
++# CONFIG_EEPROM_MAX6875 is not set
++# CONFIG_EEPROM_93CX6 is not set
++CONFIG_HAVE_IDE=y
++# CONFIG_IDE is not set
++
++#
++# SCSI device support
++#
++# CONFIG_RAID_ATTRS is not set
++CONFIG_SCSI=y
++CONFIG_SCSI_DMA=y
++# CONFIG_SCSI_TGT is not set
++# CONFIG_SCSI_NETLINK is not set
++CONFIG_SCSI_PROC_FS=y
++
++#
++# SCSI support type (disk, tape, CD-ROM)
++#
++CONFIG_BLK_DEV_SD=y
++# CONFIG_CHR_DEV_ST is not set
++# CONFIG_CHR_DEV_OSST is not set
++# CONFIG_BLK_DEV_SR is not set
++# CONFIG_CHR_DEV_SG is not set
++# CONFIG_CHR_DEV_SCH is not set
++# CONFIG_SCSI_MULTI_LUN is not set
++# CONFIG_SCSI_CONSTANTS is not set
++# CONFIG_SCSI_LOGGING is not set
++# CONFIG_SCSI_SCAN_ASYNC is not set
++CONFIG_SCSI_WAIT_SCAN=m
++
++#
++# SCSI Transports
++#
++# CONFIG_SCSI_SPI_ATTRS is not set
++# CONFIG_SCSI_FC_ATTRS is not set
++# CONFIG_SCSI_ISCSI_ATTRS is not set
++# CONFIG_SCSI_SAS_LIBSAS is not set
++# CONFIG_SCSI_SRP_ATTRS is not set
++CONFIG_SCSI_LOWLEVEL=y
++# CONFIG_ISCSI_TCP is not set
++# CONFIG_LIBFC is not set
++# CONFIG_LIBFCOE is not set
++# CONFIG_SCSI_DEBUG is not set
++# CONFIG_SCSI_DH is not set
++# CONFIG_SCSI_OSD_INITIATOR is not set
++# CONFIG_ATA is not set
++# CONFIG_MD is not set
++CONFIG_NETDEVICES=y
++# CONFIG_DUMMY is not set
++# CONFIG_BONDING is not set
++# CONFIG_MACVLAN is not set
++# CONFIG_EQUALIZER is not set
++CONFIG_TUN=m
++# CONFIG_VETH is not set
++CONFIG_PHYLIB=y
++
++#
++# MII PHY device drivers
++#
++# CONFIG_MARVELL_PHY is not set
++# CONFIG_DAVICOM_PHY is not set
++# CONFIG_QSEMI_PHY is not set
++CONFIG_LXT_PHY=y
++# CONFIG_CICADA_PHY is not set
++# CONFIG_VITESSE_PHY is not set
++# CONFIG_SMSC_PHY is not set
++# CONFIG_BROADCOM_PHY is not set
++# CONFIG_ICPLUS_PHY is not set
++# CONFIG_REALTEK_PHY is not set
++# CONFIG_NATIONAL_PHY is not set
++# CONFIG_STE10XP is not set
++CONFIG_LSI_ET1011C_PHY=y
++# CONFIG_FIXED_PHY is not set
++# CONFIG_MDIO_BITBANG is not set
++CONFIG_NET_ETHERNET=y
++CONFIG_MII=y
++# CONFIG_AX88796 is not set
++# CONFIG_SMC91X is not set
++# CONFIG_TI_DAVINCI_EMAC is not set
++CONFIG_DM9000=y
++CONFIG_DM9000_DEBUGLEVEL=4
++# CONFIG_DM9000_FORCE_SIMPLE_PHY_POLL is not set
++# CONFIG_ENC28J60 is not set
++# CONFIG_ETHOC is not set
++# CONFIG_SMC911X is not set
++# CONFIG_SMSC911X is not set
++# CONFIG_DNET is not set
++# CONFIG_IBM_NEW_EMAC_ZMII is not set
++# CONFIG_IBM_NEW_EMAC_RGMII is not set
++# CONFIG_IBM_NEW_EMAC_TAH is not set
++# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
++# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
++# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
++# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
++# CONFIG_B44 is not set
++# CONFIG_KS8842 is not set
++# CONFIG_KS8851 is not set
++# CONFIG_NETDEV_1000 is not set
++# CONFIG_NETDEV_10000 is not set
++CONFIG_WLAN=y
++# CONFIG_WLAN_PRE80211 is not set
++CONFIG_WLAN_80211=y
++CONFIG_LIBERTAS=m
++# CONFIG_LIBERTAS_USB is not set
++CONFIG_LIBERTAS_SDIO=m
++# CONFIG_LIBERTAS_SPI is not set
++CONFIG_LIBERTAS_DEBUG=y
++# CONFIG_USB_ZD1201 is not set
++# CONFIG_USB_NET_RNDIS_WLAN is not set
++# CONFIG_ATH_COMMON is not set
++# CONFIG_HOSTAP is not set
++# CONFIG_IWM is not set
++
++#
++# Enable WiMAX (Networking options) to see the WiMAX drivers
++#
++
++#
++# USB Network Adapters
++#
++# CONFIG_USB_CATC is not set
++# CONFIG_USB_KAWETH is not set
++# CONFIG_USB_PEGASUS is not set
++# CONFIG_USB_RTL8150 is not set
++# CONFIG_USB_USBNET is not set
++# CONFIG_WAN is not set
++CONFIG_PPP=m
++# CONFIG_PPP_MULTILINK is not set
++# CONFIG_PPP_FILTER is not set
++CONFIG_PPP_ASYNC=m
++CONFIG_PPP_SYNC_TTY=m
++CONFIG_PPP_DEFLATE=m
++# CONFIG_PPP_BSDCOMP is not set
++# CONFIG_PPP_MPPE is not set
++# CONFIG_PPPOE is not set
++# CONFIG_PPPOL2TP is not set
++# CONFIG_SLIP is not set
++CONFIG_SLHC=m
++CONFIG_NETCONSOLE=y
++# CONFIG_NETCONSOLE_DYNAMIC is not set
++CONFIG_NETPOLL=y
++CONFIG_NETPOLL_TRAP=y
++CONFIG_NET_POLL_CONTROLLER=y
++# CONFIG_ISDN is not set
++# CONFIG_PHONE is not set
++
++#
++# Input device support
++#
++CONFIG_INPUT=y
++# CONFIG_INPUT_FF_MEMLESS is not set
++# CONFIG_INPUT_POLLDEV is not set
++
++#
++# Userland interfaces
++#
++# CONFIG_INPUT_MOUSEDEV is not set
++# CONFIG_INPUT_JOYDEV is not set
++CONFIG_INPUT_EVDEV=y
++CONFIG_INPUT_EVBUG=y
++
++#
++# Input Device Drivers
++#
++# CONFIG_INPUT_KEYBOARD is not set
++# CONFIG_INPUT_MOUSE is not set
++# CONFIG_INPUT_JOYSTICK is not set
++# CONFIG_INPUT_TABLET is not set
++# CONFIG_INPUT_TOUCHSCREEN is not set
++# CONFIG_INPUT_MISC is not set
++
++#
++# Hardware I/O ports
++#
++CONFIG_SERIO=y
++CONFIG_SERIO_SERPORT=y
++CONFIG_SERIO_LIBPS2=y
++# CONFIG_SERIO_RAW is not set
++# CONFIG_GAMEPORT is not set
++
++#
++# Character devices
++#
++CONFIG_VT=y
++CONFIG_CONSOLE_TRANSLATIONS=y
++# CONFIG_VT_CONSOLE is not set
++CONFIG_HW_CONSOLE=y
++# CONFIG_VT_HW_CONSOLE_BINDING is not set
++CONFIG_DEVKMEM=y
++# CONFIG_SERIAL_NONSTANDARD is not set
++
++#
++# Serial drivers
++#
++CONFIG_SERIAL_8250=y
++CONFIG_SERIAL_8250_CONSOLE=y
++CONFIG_SERIAL_8250_NR_UARTS=3
++CONFIG_SERIAL_8250_RUNTIME_UARTS=3
++# CONFIG_SERIAL_8250_EXTENDED is not set
++
++#
++# Non-8250 serial port support
++#
++# CONFIG_SERIAL_MAX3100 is not set
++CONFIG_SERIAL_CORE=y
++CONFIG_SERIAL_CORE_CONSOLE=y
++CONFIG_UNIX98_PTYS=y
++# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
++CONFIG_LEGACY_PTYS=y
++CONFIG_LEGACY_PTY_COUNT=256
++# CONFIG_IPMI_HANDLER is not set
++# CONFIG_HW_RANDOM is not set
++# CONFIG_R3964 is not set
++# CONFIG_RAW_DRIVER is not set
++# CONFIG_TCG_TPM is not set
++CONFIG_DM355_IPIPE=y
++CONFIG_IMP_PREVIEWER=y
++CONFIG_IMP_RESIZER=y
++# CONFIG_IMP_DEBUG is not set
++CONFIG_I2C=y
++CONFIG_I2C_BOARDINFO=y
++CONFIG_I2C_COMPAT=y
++CONFIG_I2C_CHARDEV=y
++CONFIG_I2C_HELPER_AUTO=y
++
++#
++# I2C Hardware Bus support
++#
++
++#
++# I2C system bus drivers (mostly embedded / system-on-chip)
++#
++CONFIG_I2C_DAVINCI=y
++# CONFIG_I2C_DESIGNWARE is not set
++# CONFIG_I2C_GPIO is not set
++# CONFIG_I2C_OCORES is not set
++# CONFIG_I2C_SIMTEC is not set
++
++#
++# External I2C/SMBus adapter drivers
++#
++# CONFIG_I2C_PARPORT_LIGHT is not set
++# CONFIG_I2C_TAOS_EVM is not set
++# CONFIG_I2C_TINY_USB is not set
++
++#
++# Other I2C/SMBus bus drivers
++#
++# CONFIG_I2C_PCA_PLATFORM is not set
++# CONFIG_I2C_STUB is not set
++
++#
++# Miscellaneous I2C Chip support
++#
++# CONFIG_DS1682 is not set
++# CONFIG_SENSORS_TSL2550 is not set
++# CONFIG_I2C_DEBUG_CORE is not set
++# CONFIG_I2C_DEBUG_ALGO is not set
++# CONFIG_I2C_DEBUG_BUS is not set
++# CONFIG_I2C_DEBUG_CHIP is not set
++CONFIG_SPI=y
++# CONFIG_SPI_DEBUG is not set
++CONFIG_SPI_MASTER=y
++
++#
++# SPI Master Controller Drivers
++#
++CONFIG_SPI_DAVINCI=y
++CONFIG_SPI_BITBANG=y
++# CONFIG_SPI_GPIO is not set
++
++#
++# SPI Protocol Masters
++#
++# CONFIG_SPI_SPIDEV is not set
++# CONFIG_SPI_TLE62X0 is not set
++
++#
++# PPS support
++#
++# CONFIG_PPS is not set
++CONFIG_ARCH_REQUIRE_GPIOLIB=y
++CONFIG_GPIOLIB=y
++# CONFIG_DEBUG_GPIO is not set
++# CONFIG_GPIO_SYSFS is not set
++
++#
++# Memory mapped GPIO expanders:
++#
++
++#
++# I2C GPIO expanders:
++#
++# CONFIG_GPIO_MAX732X is not set
++# CONFIG_GPIO_PCA953X is not set
++CONFIG_GPIO_PCF857X=y
++
++#
++# PCI GPIO expanders:
++#
++
++#
++# SPI GPIO expanders:
++#
++# CONFIG_GPIO_MAX7301 is not set
++# CONFIG_GPIO_MCP23S08 is not set
++# CONFIG_GPIO_MC33880 is not set
++
++#
++# AC97 GPIO expanders:
++#
++# CONFIG_W1 is not set
++# CONFIG_POWER_SUPPLY is not set
++CONFIG_HWMON=y
++# CONFIG_HWMON_VID is not set
++# CONFIG_HWMON_DEBUG_CHIP is not set
++
++#
++# Native drivers
++#
++# CONFIG_SENSORS_AD7414 is not set
++# CONFIG_SENSORS_AD7418 is not set
++# CONFIG_SENSORS_ADCXX is not set
++# CONFIG_SENSORS_ADM1021 is not set
++# CONFIG_SENSORS_ADM1025 is not set
++# CONFIG_SENSORS_ADM1026 is not set
++# CONFIG_SENSORS_ADM1029 is not set
++# CONFIG_SENSORS_ADM1031 is not set
++# CONFIG_SENSORS_ADM9240 is not set
++# CONFIG_SENSORS_ADT7462 is not set
++# CONFIG_SENSORS_ADT7470 is not set
++# CONFIG_SENSORS_ADT7473 is not set
++# CONFIG_SENSORS_ADT7475 is not set
++# CONFIG_SENSORS_ATXP1 is not set
++# CONFIG_SENSORS_DS1621 is not set
++# CONFIG_SENSORS_F71805F is not set
++# CONFIG_SENSORS_F71882FG is not set
++# CONFIG_SENSORS_F75375S is not set
++# CONFIG_SENSORS_G760A is not set
++# CONFIG_SENSORS_GL518SM is not set
++# CONFIG_SENSORS_GL520SM is not set
++# CONFIG_SENSORS_IT87 is not set
++# CONFIG_SENSORS_LM63 is not set
++# CONFIG_SENSORS_LM70 is not set
++# CONFIG_SENSORS_LM75 is not set
++# CONFIG_SENSORS_LM77 is not set
++# CONFIG_SENSORS_LM78 is not set
++# CONFIG_SENSORS_LM80 is not set
++# CONFIG_SENSORS_LM83 is not set
++# CONFIG_SENSORS_LM85 is not set
++# CONFIG_SENSORS_LM87 is not set
++# CONFIG_SENSORS_LM90 is not set
++# CONFIG_SENSORS_LM92 is not set
++# CONFIG_SENSORS_LM93 is not set
++# CONFIG_SENSORS_LTC4215 is not set
++# CONFIG_SENSORS_LTC4245 is not set
++# CONFIG_SENSORS_LM95241 is not set
++# CONFIG_SENSORS_MAX1111 is not set
++# CONFIG_SENSORS_MAX1619 is not set
++# CONFIG_SENSORS_MAX6650 is not set
++# CONFIG_SENSORS_PC87360 is not set
++# CONFIG_SENSORS_PC87427 is not set
++# CONFIG_SENSORS_PCF8591 is not set
++# CONFIG_SENSORS_SHT15 is not set
++# CONFIG_SENSORS_DME1737 is not set
++# CONFIG_SENSORS_SMSC47M1 is not set
++# CONFIG_SENSORS_SMSC47M192 is not set
++# CONFIG_SENSORS_SMSC47B397 is not set
++# CONFIG_SENSORS_ADS7828 is not set
++# CONFIG_SENSORS_THMC50 is not set
++# CONFIG_SENSORS_TMP401 is not set
++# CONFIG_SENSORS_TMP421 is not set
++# CONFIG_SENSORS_VT1211 is not set
++# CONFIG_SENSORS_W83781D is not set
++# CONFIG_SENSORS_W83791D is not set
++# CONFIG_SENSORS_W83792D is not set
++# CONFIG_SENSORS_W83793 is not set
++# CONFIG_SENSORS_W83L785TS is not set
++# CONFIG_SENSORS_W83L786NG is not set
++# CONFIG_SENSORS_W83627HF is not set
++# CONFIG_SENSORS_W83627EHF is not set
++# CONFIG_SENSORS_LIS3_SPI is not set
++# CONFIG_THERMAL is not set
++CONFIG_WATCHDOG=y
++# CONFIG_WATCHDOG_NOWAYOUT is not set
++
++#
++# Watchdog Device Drivers
++#
++# CONFIG_SOFT_WATCHDOG is not set
++CONFIG_DAVINCI_WATCHDOG=y
++
++#
++# USB-based Watchdog Cards
++#
++# CONFIG_USBPCWATCHDOG is not set
++CONFIG_SSB_POSSIBLE=y
++
++#
++# Sonics Silicon Backplane
++#
++# CONFIG_SSB is not set
++
++#
++# Multifunction device drivers
++#
++# CONFIG_MFD_CORE is not set
++# CONFIG_MFD_SM501 is not set
++# CONFIG_MFD_ASIC3 is not set
++CONFIG_MFD_DM355EVM_MSP=y
++# CONFIG_HTC_EGPIO is not set
++# CONFIG_HTC_PASIC3 is not set
++# CONFIG_TPS65010 is not set
++# CONFIG_TWL4030_CORE is not set
++# CONFIG_MFD_TMIO is not set
++# CONFIG_MFD_T7L66XB is not set
++# CONFIG_MFD_TC6387XB is not set
++# CONFIG_MFD_TC6393XB is not set
++# CONFIG_PMIC_DA903X is not set
++# CONFIG_MFD_WM8400 is not set
++# CONFIG_MFD_WM831X is not set
++# CONFIG_MFD_WM8350_I2C is not set
++# CONFIG_MFD_PCF50633 is not set
++# CONFIG_MFD_MC13783 is not set
++# CONFIG_AB3100_CORE is not set
++# CONFIG_EZX_PCAP is not set
++# CONFIG_REGULATOR is not set
++CONFIG_MEDIA_SUPPORT=y
++
++#
++# Multimedia core support
++#
++CONFIG_VIDEO_DEV=y
++CONFIG_VIDEO_V4L2_COMMON=y
++# CONFIG_VIDEO_ALLOW_V4L1 is not set
++# CONFIG_VIDEO_V4L1_COMPAT is not set
++# CONFIG_DVB_CORE is not set
++CONFIG_VIDEO_MEDIA=y
++
++#
++# Multimedia drivers
++#
++# CONFIG_MEDIA_ATTACH is not set
++CONFIG_MEDIA_TUNER=y
++# CONFIG_MEDIA_TUNER_CUSTOMISE is not set
++CONFIG_MEDIA_TUNER_SIMPLE=y
++CONFIG_MEDIA_TUNER_TDA8290=y
++CONFIG_MEDIA_TUNER_TDA9887=y
++CONFIG_MEDIA_TUNER_TEA5761=y
++CONFIG_MEDIA_TUNER_TEA5767=y
++CONFIG_MEDIA_TUNER_MT20XX=y
++CONFIG_MEDIA_TUNER_XC2028=y
++CONFIG_MEDIA_TUNER_XC5000=y
++CONFIG_MEDIA_TUNER_MC44S803=y
++CONFIG_VIDEO_V4L2=y
++CONFIG_VIDEOBUF_GEN=y
++CONFIG_VIDEOBUF_VMALLOC=y
++CONFIG_VIDEOBUF_DMA_CONTIG=y
++CONFIG_VIDEO_CAPTURE_DRIVERS=y
++# CONFIG_VIDEO_ADV_DEBUG is not set
++# CONFIG_VIDEO_FIXED_MINOR_RANGES is not set
++# CONFIG_VIDEO_HELPER_CHIPS_AUTO is not set
++
++#
++# Encoders/decoders and other helper chips
++#
++
++#
++# Audio decoders
++#
++# CONFIG_VIDEO_TVAUDIO is not set
++# CONFIG_VIDEO_TDA7432 is not set
++# CONFIG_VIDEO_TDA9840 is not set
++# CONFIG_VIDEO_TDA9875 is not set
++# CONFIG_VIDEO_TEA6415C is not set
++# CONFIG_VIDEO_TEA6420 is not set
++# CONFIG_VIDEO_MSP3400 is not set
++# CONFIG_VIDEO_CS5345 is not set
++# CONFIG_VIDEO_CS53L32A is not set
++# CONFIG_VIDEO_M52790 is not set
++# CONFIG_VIDEO_TLV320AIC23B is not set
++# CONFIG_VIDEO_WM8775 is not set
++# CONFIG_VIDEO_WM8739 is not set
++# CONFIG_VIDEO_VP27SMPX is not set
++
++#
++# RDS decoders
++#
++# CONFIG_VIDEO_SAA6588 is not set
++
++#
++# Video decoders
++#
++# CONFIG_VIDEO_ADV7180 is not set
++# CONFIG_VIDEO_BT819 is not set
++# CONFIG_VIDEO_BT856 is not set
++# CONFIG_VIDEO_BT866 is not set
++# CONFIG_VIDEO_KS0127 is not set
++# CONFIG_VIDEO_OV7670 is not set
++# CONFIG_VIDEO_MT9V011 is not set
++# CONFIG_VIDEO_TCM825X is not set
++# CONFIG_VIDEO_SAA7110 is not set
++# CONFIG_VIDEO_SAA711X is not set
++# CONFIG_VIDEO_SAA717X is not set
++CONFIG_VIDEO_TVP514X=y
++# CONFIG_VIDEO_TVP5150 is not set
++# CONFIG_VIDEO_TVP7002 is not set
++# CONFIG_VIDEO_VPX3220 is not set
++
++#
++# Video and audio decoders
++#
++# CONFIG_VIDEO_CX25840 is not set
++
++#
++# MPEG video encoders
++#
++# CONFIG_VIDEO_CX2341X is not set
++
++#
++# Video encoders
++#
++# CONFIG_VIDEO_SAA7127 is not set
++# CONFIG_VIDEO_SAA7185 is not set
++# CONFIG_VIDEO_ADV7170 is not set
++# CONFIG_VIDEO_ADV7175 is not set
++# CONFIG_VIDEO_THS7303 is not set
++# CONFIG_VIDEO_THS7353 is not set
++# CONFIG_VIDEO_ADV7343 is not set
++# CONFIG_VIDEO_THS8200 is not set
++
++#
++# Video improvement chips
++#
++# CONFIG_VIDEO_UPD64031A is not set
++# CONFIG_VIDEO_UPD64083 is not set
++CONFIG_VIDEO_DAVINCI_DISPLAY=y
++CONFIG_DAVINCI_ENC_MNGR=y
++CONFIG_ENC_MNGR_MAX_CHANNELS=1
++CONFIG_DAVINCI_OSD=y
++CONFIG_DAVINCI_VPBE_ENCODER=y
++CONFIG_DAVINCI_LOGICPD_ENCODER=y
++# CONFIG_DAVINCI_AVNET_ENCODER is not set
++# CONFIG_VIDEO_VIVI is not set
++CONFIG_VIDEO_VPSS_SYSTEM=y
++CONFIG_VIDEO_VPFE_CAPTURE=y
++CONFIG_VIDEO_DM355_CCDC=y
++CONFIG_VIDEO_DM355_AF=y
++CONFIG_VIDEO_DM355_AEW=y
++# CONFIG_VIDEO_SAA5246A is not set
++# CONFIG_VIDEO_SAA5249 is not set
++# CONFIG_SOC_CAMERA is not set
++CONFIG_SOC_CAMERA_MT9T031=y
++# CONFIG_V4L_USB_DRIVERS is not set
++# CONFIG_RADIO_ADAPTERS is not set
++# CONFIG_DAB is not set
++
++#
++# Graphics support
++#
++# CONFIG_VGASTATE is not set
++CONFIG_VIDEO_OUTPUT_CONTROL=y
++CONFIG_FB=y
++# CONFIG_FIRMWARE_EDID is not set
++# CONFIG_FB_DDC is not set
++# CONFIG_FB_BOOT_VESA_SUPPORT is not set
++CONFIG_FB_CFB_FILLRECT=y
++CONFIG_FB_CFB_COPYAREA=y
++CONFIG_FB_CFB_IMAGEBLIT=y
++# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
++# CONFIG_FB_SYS_FILLRECT is not set
++# CONFIG_FB_SYS_COPYAREA is not set
++# CONFIG_FB_SYS_IMAGEBLIT is not set
++# CONFIG_FB_FOREIGN_ENDIAN is not set
++# CONFIG_FB_SYS_FOPS is not set
++# CONFIG_FB_SVGALIB is not set
++# CONFIG_FB_MACMODES is not set
++# CONFIG_FB_BACKLIGHT is not set
++# CONFIG_FB_MODE_HELPERS is not set
++# CONFIG_FB_TILEBLITTING is not set
++
++#
++# Frame buffer hardware drivers
++#
++# CONFIG_FB_S1D13XXX is not set
++CONFIG_FB_DAVINCI=y
++# CONFIG_FB_VIRTUAL is not set
++# CONFIG_FB_METRONOME is not set
++# CONFIG_FB_MB862XX is not set
++# CONFIG_FB_BROADSHEET is not set
++# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
++
++#
++# Display device support
++#
++# CONFIG_DISPLAY_SUPPORT is not set
++
++#
++# Console display driver support
++#
++# CONFIG_VGA_CONSOLE is not set
++CONFIG_DUMMY_CONSOLE=y
++# CONFIG_FRAMEBUFFER_CONSOLE is not set
++CONFIG_LOGO=y
++CONFIG_LOGO_LINUX_MONO=y
++CONFIG_LOGO_LINUX_VGA16=y
++CONFIG_LOGO_LINUX_CLUT224=y
++CONFIG_SOUND=y
++# CONFIG_SOUND_OSS_CORE is not set
++CONFIG_SND=y
++CONFIG_SND_TIMER=y
++CONFIG_SND_PCM=y
++CONFIG_SND_JACK=y
++# CONFIG_SND_SEQUENCER is not set
++# CONFIG_SND_MIXER_OSS is not set
++# CONFIG_SND_PCM_OSS is not set
++# CONFIG_SND_HRTIMER is not set
++# CONFIG_SND_DYNAMIC_MINORS is not set
++CONFIG_SND_SUPPORT_OLD_API=y
++CONFIG_SND_VERBOSE_PROCFS=y
++# CONFIG_SND_VERBOSE_PRINTK is not set
++# CONFIG_SND_DEBUG is not set
++# CONFIG_SND_RAWMIDI_SEQ is not set
++# CONFIG_SND_OPL3_LIB_SEQ is not set
++# CONFIG_SND_OPL4_LIB_SEQ is not set
++# CONFIG_SND_SBAWE_SEQ is not set
++# CONFIG_SND_EMU10K1_SEQ is not set
++CONFIG_SND_DRIVERS=y
++# CONFIG_SND_DUMMY is not set
++# CONFIG_SND_MTPAV is not set
++# CONFIG_SND_SERIAL_U16550 is not set
++# CONFIG_SND_MPU401 is not set
++CONFIG_SND_ARM=y
++CONFIG_SND_SPI=y
++# CONFIG_SND_USB is not set
++CONFIG_SND_SOC=y
++CONFIG_SND_DAVINCI_SOC=y
++CONFIG_SND_DAVINCI_SOC_I2S=y
++CONFIG_SND_DAVINCI_SOC_EVM=y
++CONFIG_SND_SOC_I2C_AND_SPI=y
++# CONFIG_SND_SOC_ALL_CODECS is not set
++CONFIG_SND_SOC_TLV320AIC3X=y
++# CONFIG_SOUND_PRIME is not set
++CONFIG_HID_SUPPORT=y
++CONFIG_HID=y
++# CONFIG_HIDRAW is not set
++
++#
++# USB Input Devices
++#
++CONFIG_USB_HID=y
++# CONFIG_HID_PID is not set
++# CONFIG_USB_HIDDEV is not set
++
++#
++# Special HID drivers
++#
++CONFIG_HID_A4TECH=m
++CONFIG_HID_APPLE=m
++CONFIG_HID_BELKIN=m
++CONFIG_HID_CHERRY=m
++CONFIG_HID_CHICONY=m
++CONFIG_HID_CYPRESS=m
++# CONFIG_HID_DRAGONRISE is not set
++CONFIG_HID_EZKEY=m
++# CONFIG_HID_KYE is not set
++CONFIG_HID_GYRATION=m
++# CONFIG_HID_TWINHAN is not set
++# CONFIG_HID_KENSINGTON is not set
++CONFIG_HID_LOGITECH=y
++# CONFIG_LOGITECH_FF is not set
++# CONFIG_LOGIRUMBLEPAD2_FF is not set
++CONFIG_HID_MICROSOFT=y
++CONFIG_HID_MONTEREY=m
++# CONFIG_HID_NTRIG is not set
++CONFIG_HID_PANTHERLORD=m
++# CONFIG_PANTHERLORD_FF is not set
++CONFIG_HID_PETALYNX=m
++CONFIG_HID_SAMSUNG=m
++CONFIG_HID_SONY=m
++CONFIG_HID_SUNPLUS=m
++# CONFIG_HID_GREENASIA is not set
++# CONFIG_HID_SMARTJOYPLUS is not set
++# CONFIG_HID_TOPSEED is not set
++# CONFIG_HID_THRUSTMASTER is not set
++# CONFIG_HID_ZEROPLUS is not set
++CONFIG_USB_SUPPORT=y
++CONFIG_USB_ARCH_HAS_HCD=y
++# CONFIG_USB_ARCH_HAS_OHCI is not set
++# CONFIG_USB_ARCH_HAS_EHCI is not set
++CONFIG_USB=y
++# CONFIG_USB_DEBUG is not set
++# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
++
++#
++# Miscellaneous USB options
++#
++CONFIG_USB_DEVICEFS=y
++CONFIG_USB_DEVICE_CLASS=y
++# CONFIG_USB_DYNAMIC_MINORS is not set
++# CONFIG_USB_OTG is not set
++# CONFIG_USB_OTG_WHITELIST is not set
++# CONFIG_USB_OTG_BLACKLIST_HUB is not set
++# CONFIG_USB_MON is not set
++# CONFIG_USB_WUSB is not set
++# CONFIG_USB_WUSB_CBAF is not set
++
++#
++# USB Host Controller Drivers
++#
++# CONFIG_USB_C67X00_HCD is not set
++# CONFIG_USB_OXU210HP_HCD is not set
++# CONFIG_USB_ISP116X_HCD is not set
++# CONFIG_USB_ISP1760_HCD is not set
++# CONFIG_USB_ISP1362_HCD is not set
++# CONFIG_USB_SL811_HCD is not set
++# CONFIG_USB_R8A66597_HCD is not set
++# CONFIG_USB_HWA_HCD is not set
++CONFIG_USB_MUSB_HDRC=y
++CONFIG_USB_MUSB_SOC=y
++
++#
++# DaVinci 35x, 36x, 644x USB support
++#
++CONFIG_USB_MUSB_HOST=y
++# CONFIG_USB_MUSB_PERIPHERAL is not set
++# CONFIG_USB_MUSB_OTG is not set
++# CONFIG_MUSB_SCHEDULE_INTR_EP is not set
++CONFIG_USB_MUSB_HDRC_HCD=y
++# CONFIG_MUSB_PIO_ONLY is not set
++# CONFIG_USB_INVENTRA_DMA is not set
++CONFIG_USB_TI_CPPI_DMA=y
++# CONFIG_USB_MUSB_DEBUG is not set
++
++#
++# USB Device Class drivers
++#
++# CONFIG_USB_ACM is not set
++# CONFIG_USB_PRINTER is not set
++# CONFIG_USB_WDM is not set
++# CONFIG_USB_TMC is not set
++
++#
++# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
++#
++
++#
++# also be needed; see USB_STORAGE Help for more info
++#
++CONFIG_USB_STORAGE=y
++# CONFIG_USB_STORAGE_DEBUG is not set
++# CONFIG_USB_STORAGE_DATAFAB is not set
++# CONFIG_USB_STORAGE_FREECOM is not set
++# CONFIG_USB_STORAGE_ISD200 is not set
++# CONFIG_USB_STORAGE_USBAT is not set
++# CONFIG_USB_STORAGE_SDDR09 is not set
++# CONFIG_USB_STORAGE_SDDR55 is not set
++# CONFIG_USB_STORAGE_JUMPSHOT is not set
++# CONFIG_USB_STORAGE_ALAUDA is not set
++# CONFIG_USB_STORAGE_ONETOUCH is not set
++# CONFIG_USB_STORAGE_KARMA is not set
++# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
++# CONFIG_USB_LIBUSUAL is not set
++
++#
++# USB Imaging devices
++#
++# CONFIG_USB_MDC800 is not set
++# CONFIG_USB_MICROTEK is not set
++
++#
++# USB port drivers
++#
++# CONFIG_USB_SERIAL is not set
++
++#
++# USB Miscellaneous drivers
++#
++# CONFIG_USB_EMI62 is not set
++# CONFIG_USB_EMI26 is not set
++# CONFIG_USB_ADUTUX is not set
++# CONFIG_USB_SEVSEG is not set
++# CONFIG_USB_RIO500 is not set
++# CONFIG_USB_LEGOTOWER is not set
++# CONFIG_USB_LCD is not set
++# CONFIG_USB_BERRY_CHARGE is not set
++# CONFIG_USB_LED is not set
++# CONFIG_USB_CYPRESS_CY7C63 is not set
++# CONFIG_USB_CYTHERM is not set
++# CONFIG_USB_IDMOUSE is not set
++# CONFIG_USB_FTDI_ELAN is not set
++# CONFIG_USB_APPLEDISPLAY is not set
++# CONFIG_USB_SISUSBVGA is not set
++# CONFIG_USB_LD is not set
++# CONFIG_USB_TRANCEVIBRATOR is not set
++# CONFIG_USB_IOWARRIOR is not set
++CONFIG_USB_TEST=y
++# CONFIG_USB_ISIGHTFW is not set
++# CONFIG_USB_VST is not set
++# CONFIG_USB_GADGET is not set
++
++#
++# OTG and related infrastructure
++#
++CONFIG_USB_OTG_UTILS=y
++# CONFIG_USB_GPIO_VBUS is not set
++CONFIG_NOP_USB_XCEIV=y
++CONFIG_MMC=y
++# CONFIG_MMC_DEBUG is not set
++# CONFIG_MMC_UNSAFE_RESUME is not set
++
++#
++# MMC/SD/SDIO Card Drivers
++#
++CONFIG_MMC_BLOCK=y
++# CONFIG_MMC_BLOCK_BOUNCE is not set
++CONFIG_SDIO_UART=y
++# CONFIG_MMC_TEST is not set
++
++#
++# MMC/SD/SDIO Host Controller Drivers
++#
++# CONFIG_MMC_SDHCI is not set
++# CONFIG_MMC_AT91 is not set
++# CONFIG_MMC_ATMELMCI is not set
++CONFIG_MMC_DAVINCI=y
++# CONFIG_MMC_SPI is not set
++# CONFIG_MEMSTICK is not set
++CONFIG_NEW_LEDS=y
++CONFIG_LEDS_CLASS=m
++
++#
++# LED drivers
++#
++# CONFIG_LEDS_PCA9532 is not set
++CONFIG_LEDS_GPIO=m
++CONFIG_LEDS_GPIO_PLATFORM=y
++# CONFIG_LEDS_LP3944 is not set
++# CONFIG_LEDS_PCA955X is not set
++# CONFIG_LEDS_DAC124S085 is not set
++# CONFIG_LEDS_BD2802 is not set
++
++#
++# LED Triggers
++#
++CONFIG_LEDS_TRIGGERS=y
++CONFIG_LEDS_TRIGGER_TIMER=m
++CONFIG_LEDS_TRIGGER_HEARTBEAT=m
++# CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
++# CONFIG_LEDS_TRIGGER_GPIO is not set
++# CONFIG_LEDS_TRIGGER_DEFAULT_ON is not set
++
++#
++# iptables trigger is under Netfilter config (LED target)
++#
++# CONFIG_ACCESSIBILITY is not set
++CONFIG_RTC_LIB=y
++# CONFIG_RTC_CLASS is not set
++# CONFIG_DMADEVICES is not set
++# CONFIG_AUXDISPLAY is not set
++# CONFIG_UIO is not set
++
++#
++# TI VLYNQ
++#
++# CONFIG_STAGING is not set
++
++#
++# File systems
++#
++CONFIG_EXT2_FS=y
++# CONFIG_EXT2_FS_XATTR is not set
++# CONFIG_EXT2_FS_XIP is not set
++CONFIG_EXT3_FS=y
++# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
++CONFIG_EXT3_FS_XATTR=y
++# CONFIG_EXT3_FS_POSIX_ACL is not set
++# CONFIG_EXT3_FS_SECURITY is not set
++# CONFIG_EXT4_FS is not set
++CONFIG_JBD=y
++# CONFIG_JBD_DEBUG is not set
++CONFIG_FS_MBCACHE=y
++# CONFIG_REISERFS_FS is not set
++# CONFIG_JFS_FS is not set
++# CONFIG_FS_POSIX_ACL is not set
++CONFIG_XFS_FS=m
++# CONFIG_XFS_QUOTA is not set
++# CONFIG_XFS_POSIX_ACL is not set
++# CONFIG_XFS_RT is not set
++# CONFIG_XFS_DEBUG is not set
++# CONFIG_GFS2_FS is not set
++# CONFIG_OCFS2_FS is not set
++# CONFIG_BTRFS_FS is not set
++# CONFIG_NILFS2_FS is not set
++CONFIG_FILE_LOCKING=y
++CONFIG_FSNOTIFY=y
++CONFIG_DNOTIFY=y
++CONFIG_INOTIFY=y
++CONFIG_INOTIFY_USER=y
++# CONFIG_QUOTA is not set
++# CONFIG_AUTOFS_FS is not set
++CONFIG_AUTOFS4_FS=m
++# CONFIG_FUSE_FS is not set
++
++#
++# Caches
++#
++# CONFIG_FSCACHE is not set
++
++#
++# CD-ROM/DVD Filesystems
++#
++# CONFIG_ISO9660_FS is not set
++# CONFIG_UDF_FS is not set
++
++#
++# DOS/FAT/NT Filesystems
++#
++CONFIG_FAT_FS=y
++CONFIG_MSDOS_FS=y
++CONFIG_VFAT_FS=y
++CONFIG_FAT_DEFAULT_CODEPAGE=437
++CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
++# CONFIG_NTFS_FS is not set
++
++#
++# Pseudo filesystems
++#
++CONFIG_PROC_FS=y
++CONFIG_PROC_SYSCTL=y
++CONFIG_PROC_PAGE_MONITOR=y
++CONFIG_SYSFS=y
++CONFIG_TMPFS=y
++# CONFIG_TMPFS_POSIX_ACL is not set
++# CONFIG_HUGETLB_PAGE is not set
++# CONFIG_CONFIGFS_FS is not set
++CONFIG_MISC_FILESYSTEMS=y
++# CONFIG_ADFS_FS is not set
++# CONFIG_AFFS_FS is not set
++# CONFIG_HFS_FS is not set
++# CONFIG_HFSPLUS_FS is not set
++# CONFIG_BEFS_FS is not set
++# CONFIG_BFS_FS is not set
++# CONFIG_EFS_FS is not set
++CONFIG_JFFS2_FS=y
++CONFIG_JFFS2_FS_DEBUG=0
++CONFIG_JFFS2_FS_WRITEBUFFER=y
++# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
++# CONFIG_JFFS2_SUMMARY is not set
++# CONFIG_JFFS2_FS_XATTR is not set
++# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
++CONFIG_JFFS2_ZLIB=y
++# CONFIG_JFFS2_LZO is not set
++CONFIG_JFFS2_RTIME=y
++# CONFIG_JFFS2_RUBIN is not set
++CONFIG_CRAMFS=y
++# CONFIG_SQUASHFS is not set
++# CONFIG_VXFS_FS is not set
++CONFIG_MINIX_FS=m
++# CONFIG_OMFS_FS is not set
++# CONFIG_HPFS_FS is not set
++# CONFIG_QNX4FS_FS is not set
++# CONFIG_ROMFS_FS is not set
++# CONFIG_SYSV_FS is not set
++# CONFIG_UFS_FS is not set
++CONFIG_NETWORK_FILESYSTEMS=y
++CONFIG_NFS_FS=y
++CONFIG_NFS_V3=y
++# CONFIG_NFS_V3_ACL is not set
++# CONFIG_NFS_V4 is not set
++CONFIG_ROOT_NFS=y
++CONFIG_NFSD=m
++CONFIG_NFSD_V3=y
++# CONFIG_NFSD_V3_ACL is not set
++# CONFIG_NFSD_V4 is not set
++CONFIG_LOCKD=y
++CONFIG_LOCKD_V4=y
++CONFIG_EXPORTFS=m
++CONFIG_NFS_COMMON=y
++CONFIG_SUNRPC=y
++# CONFIG_RPCSEC_GSS_KRB5 is not set
++# CONFIG_RPCSEC_GSS_SPKM3 is not set
++CONFIG_SMB_FS=m
++# CONFIG_SMB_NLS_DEFAULT is not set
++# CONFIG_CIFS is not set
++# CONFIG_NCP_FS is not set
++# CONFIG_CODA_FS is not set
++# CONFIG_AFS_FS is not set
++
++#
++# Partition Types
++#
++CONFIG_PARTITION_ADVANCED=y
++# CONFIG_ACORN_PARTITION is not set
++# CONFIG_OSF_PARTITION is not set
++# CONFIG_AMIGA_PARTITION is not set
++# CONFIG_ATARI_PARTITION is not set
++# CONFIG_MAC_PARTITION is not set
++CONFIG_MSDOS_PARTITION=y
++# CONFIG_BSD_DISKLABEL is not set
++# CONFIG_MINIX_SUBPARTITION is not set
++# CONFIG_SOLARIS_X86_PARTITION is not set
++# CONFIG_UNIXWARE_DISKLABEL is not set
++# CONFIG_LDM_PARTITION is not set
++# CONFIG_SGI_PARTITION is not set
++# CONFIG_ULTRIX_PARTITION is not set
++# CONFIG_SUN_PARTITION is not set
++# CONFIG_KARMA_PARTITION is not set
++# CONFIG_EFI_PARTITION is not set
++# CONFIG_SYSV68_PARTITION is not set
++CONFIG_NLS=y
++CONFIG_NLS_DEFAULT="iso8859-1"
++CONFIG_NLS_CODEPAGE_437=y
++# CONFIG_NLS_CODEPAGE_737 is not set
++# CONFIG_NLS_CODEPAGE_775 is not set
++# CONFIG_NLS_CODEPAGE_850 is not set
++# CONFIG_NLS_CODEPAGE_852 is not set
++# CONFIG_NLS_CODEPAGE_855 is not set
++# CONFIG_NLS_CODEPAGE_857 is not set
++# CONFIG_NLS_CODEPAGE_860 is not set
++# CONFIG_NLS_CODEPAGE_861 is not set
++# CONFIG_NLS_CODEPAGE_862 is not set
++# CONFIG_NLS_CODEPAGE_863 is not set
++# CONFIG_NLS_CODEPAGE_864 is not set
++# CONFIG_NLS_CODEPAGE_865 is not set
++# CONFIG_NLS_CODEPAGE_866 is not set
++# CONFIG_NLS_CODEPAGE_869 is not set
++# CONFIG_NLS_CODEPAGE_936 is not set
++# CONFIG_NLS_CODEPAGE_950 is not set
++# CONFIG_NLS_CODEPAGE_932 is not set
++# CONFIG_NLS_CODEPAGE_949 is not set
++# CONFIG_NLS_CODEPAGE_874 is not set
++# CONFIG_NLS_ISO8859_8 is not set
++# CONFIG_NLS_CODEPAGE_1250 is not set
++# CONFIG_NLS_CODEPAGE_1251 is not set
++CONFIG_NLS_ASCII=m
++CONFIG_NLS_ISO8859_1=y
++# CONFIG_NLS_ISO8859_2 is not set
++# CONFIG_NLS_ISO8859_3 is not set
++# CONFIG_NLS_ISO8859_4 is not set
++# CONFIG_NLS_ISO8859_5 is not set
++# CONFIG_NLS_ISO8859_6 is not set
++# CONFIG_NLS_ISO8859_7 is not set
++# CONFIG_NLS_ISO8859_9 is not set
++# CONFIG_NLS_ISO8859_13 is not set
++# CONFIG_NLS_ISO8859_14 is not set
++# CONFIG_NLS_ISO8859_15 is not set
++# CONFIG_NLS_KOI8_R is not set
++# CONFIG_NLS_KOI8_U is not set
++CONFIG_NLS_UTF8=m
++# CONFIG_DLM is not set
++
++#
++# Kernel hacking
++#
++# CONFIG_PRINTK_TIME is not set
++CONFIG_ENABLE_WARN_DEPRECATED=y
++CONFIG_ENABLE_MUST_CHECK=y
++CONFIG_FRAME_WARN=1024
++# CONFIG_MAGIC_SYSRQ is not set
++# CONFIG_STRIP_ASM_SYMS is not set
++# CONFIG_UNUSED_SYMBOLS is not set
++CONFIG_DEBUG_FS=y
++# CONFIG_HEADERS_CHECK is not set
++CONFIG_DEBUG_KERNEL=y
++# CONFIG_DEBUG_SHIRQ is not set
++CONFIG_DETECT_SOFTLOCKUP=y
++# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
++CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
++CONFIG_DETECT_HUNG_TASK=y
++# CONFIG_BOOTPARAM_HUNG_TASK_PANIC is not set
++CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=0
++CONFIG_SCHED_DEBUG=y
++# CONFIG_SCHEDSTATS is not set
++CONFIG_TIMER_STATS=y
++# CONFIG_DEBUG_OBJECTS is not set
++# CONFIG_SLUB_DEBUG_ON is not set
++# CONFIG_SLUB_STATS is not set
++# CONFIG_DEBUG_KMEMLEAK is not set
++CONFIG_DEBUG_PREEMPT=y
++CONFIG_DEBUG_RT_MUTEXES=y
++CONFIG_DEBUG_PI_LIST=y
++# CONFIG_RT_MUTEX_TESTER is not set
++# CONFIG_DEBUG_SPINLOCK is not set
++CONFIG_DEBUG_MUTEXES=y
++# CONFIG_DEBUG_LOCK_ALLOC is not set
++# CONFIG_PROVE_LOCKING is not set
++# CONFIG_LOCK_STAT is not set
++# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
++# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
++# CONFIG_DEBUG_KOBJECT is not set
++CONFIG_DEBUG_BUGVERBOSE=y
++# CONFIG_DEBUG_INFO is not set
++# CONFIG_DEBUG_VM is not set
++# CONFIG_DEBUG_WRITECOUNT is not set
++# CONFIG_DEBUG_MEMORY_INIT is not set
++# CONFIG_DEBUG_LIST is not set
++# CONFIG_DEBUG_SG is not set
++# CONFIG_DEBUG_NOTIFIERS is not set
++# CONFIG_DEBUG_CREDENTIALS is not set
++CONFIG_FRAME_POINTER=y
++# CONFIG_BOOT_PRINTK_DELAY is not set
++# CONFIG_RCU_TORTURE_TEST is not set
++# CONFIG_RCU_CPU_STALL_DETECTOR is not set
++# CONFIG_BACKTRACE_SELF_TEST is not set
++# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
++# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
++# CONFIG_FAULT_INJECTION is not set
++# CONFIG_LATENCYTOP is not set
++# CONFIG_SYSCTL_SYSCALL_CHECK is not set
++# CONFIG_PAGE_POISONING is not set
++CONFIG_HAVE_FUNCTION_TRACER=y
++CONFIG_TRACING_SUPPORT=y
++CONFIG_FTRACE=y
++# CONFIG_FUNCTION_TRACER is not set
++# CONFIG_IRQSOFF_TRACER is not set
++# CONFIG_PREEMPT_TRACER is not set
++# CONFIG_SCHED_TRACER is not set
++# CONFIG_ENABLE_DEFAULT_TRACERS is not set
++# CONFIG_BOOT_TRACER is not set
++CONFIG_BRANCH_PROFILE_NONE=y
++# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
++# CONFIG_PROFILE_ALL_BRANCHES is not set
++# CONFIG_STACK_TRACER is not set
++# CONFIG_KMEMTRACE is not set
++# CONFIG_WORKQUEUE_TRACER is not set
++# CONFIG_BLK_DEV_IO_TRACE is not set
++# CONFIG_DYNAMIC_DEBUG is not set
++# CONFIG_SAMPLES is not set
++CONFIG_HAVE_ARCH_KGDB=y
++# CONFIG_KGDB is not set
++# CONFIG_ARM_UNWIND is not set
++CONFIG_DEBUG_USER=y
++CONFIG_DEBUG_ERRORS=y
++# CONFIG_DEBUG_STACK_USAGE is not set
++# CONFIG_DEBUG_LL is not set
++
++#
++# Security options
++#
++# CONFIG_KEYS is not set
++# CONFIG_SECURITY is not set
++# CONFIG_SECURITYFS is not set
++# CONFIG_SECURITY_FILE_CAPABILITIES is not set
++CONFIG_CRYPTO=y
++
++#
++# Crypto core or helper
++#
++CONFIG_CRYPTO_ALGAPI=y
++CONFIG_CRYPTO_ALGAPI2=y
++CONFIG_CRYPTO_AEAD2=y
++CONFIG_CRYPTO_BLKCIPHER=y
++CONFIG_CRYPTO_BLKCIPHER2=y
++CONFIG_CRYPTO_HASH2=y
++CONFIG_CRYPTO_RNG2=y
++CONFIG_CRYPTO_PCOMP=y
++CONFIG_CRYPTO_MANAGER=y
++CONFIG_CRYPTO_MANAGER2=y
++# CONFIG_CRYPTO_GF128MUL is not set
++# CONFIG_CRYPTO_NULL is not set
++CONFIG_CRYPTO_WORKQUEUE=y
++# CONFIG_CRYPTO_CRYPTD is not set
++# CONFIG_CRYPTO_AUTHENC is not set
++# CONFIG_CRYPTO_TEST is not set
++
++#
++# Authenticated Encryption with Associated Data
++#
++# CONFIG_CRYPTO_CCM is not set
++# CONFIG_CRYPTO_GCM is not set
++# CONFIG_CRYPTO_SEQIV is not set
++
++#
++# Block modes
++#
++# CONFIG_CRYPTO_CBC is not set
++# CONFIG_CRYPTO_CTR is not set
++# CONFIG_CRYPTO_CTS is not set
++CONFIG_CRYPTO_ECB=y
++# CONFIG_CRYPTO_LRW is not set
++# CONFIG_CRYPTO_PCBC is not set
++# CONFIG_CRYPTO_XTS is not set
++
++#
++# Hash modes
++#
++# CONFIG_CRYPTO_HMAC is not set
++# CONFIG_CRYPTO_XCBC is not set
++# CONFIG_CRYPTO_VMAC is not set
++
++#
++# Digest
++#
++# CONFIG_CRYPTO_CRC32C is not set
++# CONFIG_CRYPTO_GHASH is not set
++# CONFIG_CRYPTO_MD4 is not set
++# CONFIG_CRYPTO_MD5 is not set
++# CONFIG_CRYPTO_MICHAEL_MIC is not set
++# CONFIG_CRYPTO_RMD128 is not set
++# CONFIG_CRYPTO_RMD160 is not set
++# CONFIG_CRYPTO_RMD256 is not set
++# CONFIG_CRYPTO_RMD320 is not set
++# CONFIG_CRYPTO_SHA1 is not set
++# CONFIG_CRYPTO_SHA256 is not set
++# CONFIG_CRYPTO_SHA512 is not set
++# CONFIG_CRYPTO_TGR192 is not set
++# CONFIG_CRYPTO_WP512 is not set
++
++#
++# Ciphers
++#
++CONFIG_CRYPTO_AES=y
++# CONFIG_CRYPTO_ANUBIS is not set
++CONFIG_CRYPTO_ARC4=y
++# CONFIG_CRYPTO_BLOWFISH is not set
++# CONFIG_CRYPTO_CAMELLIA is not set
++# CONFIG_CRYPTO_CAST5 is not set
++# CONFIG_CRYPTO_CAST6 is not set
++# CONFIG_CRYPTO_DES is not set
++# CONFIG_CRYPTO_FCRYPT is not set
++# CONFIG_CRYPTO_KHAZAD is not set
++# CONFIG_CRYPTO_SALSA20 is not set
++# CONFIG_CRYPTO_SEED is not set
++# CONFIG_CRYPTO_SERPENT is not set
++# CONFIG_CRYPTO_TEA is not set
++# CONFIG_CRYPTO_TWOFISH is not set
++
++#
++# Compression
++#
++# CONFIG_CRYPTO_DEFLATE is not set
++# CONFIG_CRYPTO_ZLIB is not set
++# CONFIG_CRYPTO_LZO is not set
++
++#
++# Random Number Generation
++#
++# CONFIG_CRYPTO_ANSI_CPRNG is not set
++# CONFIG_CRYPTO_HW is not set
++# CONFIG_BINARY_PRINTF is not set
++
++#
++# Library routines
++#
++CONFIG_BITREVERSE=y
++CONFIG_GENERIC_FIND_LAST_BIT=y
++CONFIG_CRC_CCITT=m
++# CONFIG_CRC16 is not set
++CONFIG_CRC_T10DIF=m
++# CONFIG_CRC_ITU_T is not set
++CONFIG_CRC32=y
++# CONFIG_CRC7 is not set
++# CONFIG_LIBCRC32C is not set
++CONFIG_ZLIB_INFLATE=y
++CONFIG_ZLIB_DEFLATE=y
++CONFIG_DECOMPRESS_GZIP=y
++CONFIG_GENERIC_ALLOCATOR=y
++CONFIG_HAS_IOMEM=y
++CONFIG_HAS_IOPORT=y
++CONFIG_HAS_DMA=y
++CONFIG_NLATTR=y
+--- /dev/null
++++ b/drivers/media/video/tvp7002.c
+@@ -0,0 +1,1488 @@
++/*
++ * Copyright (C) 2007-2009 Texas Instruments Inc
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
++ */
++#include <linux/i2c.h>
++#include <linux/delay.h>
++#include <linux/videodev2.h>
++
++#include <media/v4l2-device.h>
++#include <media/v4l2-chip-ident.h>
++#include <media/davinci/videohd.h>
++#include <media/tvp7002.h>
++
++/* Module Name */
++#define TVP7002_MODULE_NAME		"tvp7002"
++
++/* Private macros for TVP */
++#define I2C_RETRY_COUNT                 (5)
++#define LOCK_RETRY_COUNT                (5)
++#define LOCK_RETRY_DELAY                (200)
++
++static int tvp7002_set_format_params(struct v4l2_subdev *sd,
++				struct tvp7002_format_params *tvpformats);
++static int tvp7002_setstd(struct v4l2_subdev *sd, v4l2_std_id id);
++
++/* Debug functions */
++static int debug;
++module_param(debug, bool, 0644);
++MODULE_PARM_DESC(debug, "Debug level (0-1)");
++
++struct tvp7002_std_info {
++	unsigned long width;
++	unsigned long height;
++	struct v4l2_standard standard;
++};
++
++struct i2c_reg_value {
++	u8 reg;
++	u32 val;
++};
++
++struct tvp7002_decoder {
++	struct v4l2_subdev sd;
++	const struct tvp7002_platform_data *pdata;
++
++	int ver;
++	int streaming;
++
++	struct v4l2_pix_format pix;
++	int num_fmts;
++	const struct v4l2_fmtdesc *fmt_list;
++
++	int current_std;
++	/*
++	int num_stds;
++	struct tvp7002_std_info *std_list;
++	*/
++	/* Input and Output Routing parameters */
++	u32 input;
++	u32 output;
++};
++
++#if 0
++/* Register default values (according to tvp7002 datasheet) */
++static const struct i2c_reg_value tvp7002_init_default[] = {
++	/* 0x00: read only */
++	{ TVP7002_HPLL_FDBK_DIV_MSBS, 0x67 },
++	{ TVP7002_HPLL_FDBK_DIV_LSBS, 0x20 },
++	{ TVP7002_HPLL_CRTL, 0xa8 },
++	{ TVP7002_HPLL_PHASE_SEL, 0x80 },
++	{ TVP7002_CLAMP_START, 0x32 },
++	{ TVP7002_CLAMP_W, 0x20 },
++	{ TVP7002_HSYNC_OUT_W, 0x20 },
++	{ TVP7002_B_FINE_GAIN, 0x00 },
++	{ TVP7002_G_FINE_GAIN, 0x00 },
++	{ TVP7002_R_FINE_GAIN, 0x00 },
++	{ TVP7002_B_FINE_OFF_MSBS, 0x80 },
++	{ TVP7002_G_FINE_OFF_MSBS, 0x80 },
++	{ TVP7002_R_FINE_OFF_MSBS, 0x80 },
++	{ TVP7002_SYNC_CTL_1, 0x5b },
++	{ TVP7002_HPLL_AND_CLAMP_CTL, 0x2e },
++	{ TVP7002_SYNC_ON_G_THRS, 0x5d },
++	{ TVP7002_SYNC_SEPARATOR_THRS, 0x20 },
++	{ TVP7002_HPLL_PRE_COAST, 0x00 },
++	{ TVP7002_HPLL_POST_COAST, 0x00 },
++	/* 0x14: read only */
++	{ TVP7002_OUT_FORMATTER, 0x00 },
++	{ TVP7002_MISC_CTL_1, 0x11 },
++	{ TVP7002_MISC_CTL_2, 0x03 },
++	{ TVP7002_MISC_CTL_3, 0x00 },
++	{ TVP7002_IN_MUX_SEL_1, 0x00 },
++	{ TVP7002_IN_MUX_SEL_2, 0xc2 },
++	{ TVP7002_B_AND_G_COARSE_GAIN, 0x77 },
++	{ TVP7002_R_COARSE_GAIN, 0x07 },
++	{ TVP7002_COARSE_CLAMP_CTL, 0x00 },
++	{ TVP7002_FINE_OFF_LSBS, 0x00 },
++	{ TVP7002_B_COARSE_OFF, 0x10 },
++	{ TVP7002_G_COARSE_OFF, 0x10 },
++	{ TVP7002_R_COARSE_OFF, 0x10 },
++	{ TVP7002_HSOUT_OUT_START, 0x0d	},
++	{ TVP7002_MISC_CTL_4, 0x0d },
++	/* 0x23: read only */
++	/* 0x24: read only */
++	/* 0x25: read only */
++	{ TVP7002_AUTO_LVL_CTL_ENABLE, 0x80 },
++	/* 0x27: read only */
++	{ TVP7002_AUTO_LVL_CTL_FILTER, 0x53 },
++	{ TVP7002_FINE_CLAMP_CTL, 0x07 },
++	{ TVP7002_PWR_CTL, 0x00 },
++	{ TVP7002_ADC_SETUP, 0x50 },
++	{ TVP7002_COARSE_CLAMP_CTL, 0x00 },
++	{ TVP7002_SOG_CLAMP, 0x80 },
++	{ TVP7002_RGB_COARSE_CLAMP_CTL, 0x8c },
++	{ TVP7002_SOG_COARSE_CLAMP_CTL, 0x04 },
++	{ TVP7002_ALC_PLACEMENT, 0x5a },
++	{ TVP7002_MVIS_STRIPPER_W, 0x03 },
++	{ TVP7002_VSYNC_ALGN, 0x10 },
++	{ TVP7002_SYNC_BYPASS, 0x00 },
++	/* 0x37: read only */
++	/* 0x38: read only */
++	/* 0x39: read only */
++	/* 0x3a: read only */
++	/* 0x3b: read only */
++	/* 0x3c: read only */
++	{ TVP7002_L_LENGTH_TOL, 0x03 },
++	{ TVP7002_VIDEO_BWTH_CTL, 0x00 },
++	{ TVP7002_AVID_START_PIXEL_LSBS, 0x01 },
++	{ TVP7002_AVID_START_PIXEL_MSBS, 0x2c },
++	{ TVP7002_AVID_STOP_PIXEL_LSBS, 0x06 },
++	{ TVP7002_AVID_STOP_PIXEL_MSBS, 0x2c },
++	{ TVP7002_VBLK_F_0_START_L_OFF, 0x05 },
++	{ TVP7002_VBLK_F_1_START_L_OFF, 0x05 },
++	{ TVP7002_VBLK_F_0_DURATION, 0x1e },
++	{ TVP7002_VBLK_F_1_DURATION, 0x1e },
++	{ TVP7002_FBIT_F_0_START_L_OFF, 0x00 },
++	{ TVP7002_FBIT_F_1_START_L_OFF, 0x00 },
++	{ TVP7002_YUV_Y_G_COEF_LSBS, 0xe3 },
++	{ TVP7002_YUV_Y_G_COEF_MSBS, 0x16 },
++	{ TVP7002_YUV_Y_B_COEF_LSBS, 0x4f },
++	{ TVP7002_YUV_Y_B_COEF_MSBS, 0x02 },
++	{ TVP7002_YUV_Y_R_COEF_LSBS, 0xce },
++	{ TVP7002_YUV_Y_R_COEF_MSBS, 0x06 },
++	{ TVP7002_YUV_U_G_COEF_LSBS, 0xab },
++	{ TVP7002_YUV_U_G_COEF_MSBS, 0xf3 },
++	{ TVP7002_YUV_U_B_COEF_LSBS, 0x00 },
++	{ TVP7002_YUV_U_B_COEF_MSBS, 0x10 },
++	{ TVP7002_YUV_U_R_COEF_LSBS, 0x55 },
++	{ TVP7002_YUV_U_R_COEF_MSBS, 0xfc },
++	{ TVP7002_YUV_V_G_COEF_LSBS, 0x78 },
++	{ TVP7002_YUV_V_G_COEF_MSBS, 0xf1 },
++	{ TVP7002_YUV_V_B_COEF_LSBS, 0x88 },
++	{ TVP7002_YUV_V_B_COEF_MSBS, 0xfe },
++	{ TVP7002_YUV_V_R_COEF_LSBS, 0x00 },
++	{ TVP7002_YUV_V_R_COEF_MSBS, 0x10 },
++	{ 0x5c, 0x00 }	/* end of registers */
++};
++#endif
++
++static const struct v4l2_fmtdesc tvp7002_fmt_list[] = {
++	{
++	 .index = 0,
++	 .type = V4L2_BUF_TYPE_VIDEO_CAPTURE,
++	 .flags = 0,
++	 .description = "8-bit UYVY 4:2:2 Format",
++	 .pixelformat = V4L2_PIX_FMT_UYVY,
++	},
++};
++
++static struct v4l2_standard tvp7002_standards[TVP7002_MAX_NO_STANDARDS] = {
++	{
++		.index = 0,
++		.id = V4L2_STD_720P_60,
++		.name = "720P-60",
++		.frameperiod = {1, 60},
++		.framelines = 720
++	},
++	{
++		.index = 1,
++		.id = V4L2_STD_1080I_60,
++		.name = "1080I-30",
++		.frameperiod = {1, 30},
++		.framelines = 1080
++	},
++	{
++		.index = 2,
++		.id = V4L2_STD_1080I_50,
++		.name = "1080I-25",
++		.frameperiod = {1, 25},
++		.framelines = 1080
++	},
++	{
++		.index = 3,
++		.id = V4L2_STD_720P_50,
++		.name = "720P-50",
++		.frameperiod = {1, 50},
++		.framelines = 720
++	},
++	{
++		.index = 4,
++		.id = V4L2_STD_1080P_60,
++		.name = "1080P-60",
++		.frameperiod = {1, 60},
++		.framelines = 1080
++	},
++	{
++		.index = 5,
++		.id = V4L2_STD_525P_60,
++		.name = "480P-60",
++		.frameperiod = {1, 60},
++		.framelines = 525
++	},
++	{
++		.index = 6,
++		.id = V4L2_STD_625P_50,
++		.name = "576P-50",
++		.frameperiod = {1, 50},
++		.framelines = 625
++	},
++};
++
++static struct tvp7002_format_params
++	tvp7002_formats[TVP7002_MAX_NO_STANDARDS] = {
++	{
++		.hpll_divider_msb = FEEDBACK_DIVIDER_MSB_720p,
++		.hpll_divider_lsb = FEEDBACK_DIVIDER_LSB_720p,
++		.hpll_vco_control = VCO_CONTROL_720p,
++		.hpll_cp_current = CP_CURRENT_720p,
++		.hpll_phase_select = PHASE_SELECT_720p,
++		.hpll_post_divider = POST_DIVIDER_720p,
++		.hpll_control = HPLL_CONTROL_720p,
++		.avid_start_msb = AVID_START_PIXEL_MSB_720p,
++		.avid_start_lsb = AVID_START_PIXEL_LSB_720p,
++		.avid_stop_lsb = AVID_STOP_PIXEL_LSB_720p,
++		.avid_stop_msb = AVID_STOP_PIXEL_MSB_720p,
++		.vblk_start_f0_line_offset = VBLK_F0_START_LINE_OFFSET_720p,
++		.vblk_start_f1_line_offset = VBLK_F1_START_LINE_OFFSET_720p,
++		.vblk_f0_duration = VBLK_F0_DURATION_720p,
++		.vblk_f1_duration = VBLK_F1_DURATION_720p,
++		.alc_placement = TVP7002_HD_ALC_PLACEMENT,
++		.clamp_start = TVP7002_HD_CLAMP_START,
++		.clamp_width = TVP7002_HD_CLAMP_WIDTH,
++		.hpll_pre_coast = TVP7002_HD_PRE_COAST,
++		.hpll_post_coast = TVP7002_HD_POST_COAST,
++		.reserved = RESERVED_720p
++	},
++	{
++		.hpll_divider_msb = FEEDBACK_DIVIDER_MSB_1080i,
++		.hpll_divider_lsb = FEEDBACK_DIVIDER_LSB_1080i,
++		.hpll_vco_control = VCO_CONTROL_1080i,
++		.hpll_cp_current = CP_CURRENT_1080i,
++		.hpll_phase_select = PHASE_SELECT_1080i,
++		.hpll_post_divider = POST_DIVIDER_1080i,
++		.hpll_control = HPLL_CONTROL_1080i,
++		.avid_start_msb = AVID_START_PIXEL_MSB_1080i,
++		.avid_start_lsb = AVID_START_PIXEL_LSB_1080i,
++		.avid_stop_lsb = AVID_STOP_PIXEL_LSB_1080i,
++		.avid_stop_msb = AVID_STOP_PIXEL_MSB_1080i,
++		.vblk_start_f0_line_offset = VBLK_F0_START_LINE_OFFSET_1080i,
++		.vblk_start_f1_line_offset = VBLK_F1_START_LINE_OFFSET_1080i,
++		.vblk_f0_duration = VBLK_F0_DURATION_1080i,
++		.vblk_f1_duration = VBLK_F1_DURATION_1080i,
++		.alc_placement = TVP7002_HD_ALC_PLACEMENT,
++		.clamp_start = TVP7002_HD_CLAMP_START,
++		.clamp_width = TVP7002_HD_CLAMP_WIDTH,
++		.hpll_pre_coast = TVP7002_HD_PRE_COAST,
++		.hpll_post_coast = TVP7002_HD_POST_COAST,
++		.reserved = RESERVED_1080i
++	},
++	{
++		.hpll_divider_msb = FEEDBACK_DIVIDER_MSB_1080i_50,
++		.hpll_divider_lsb = FEEDBACK_DIVIDER_LSB_1080i_50,
++		.hpll_vco_control = VCO_CONTROL_1080i_50,
++		.hpll_cp_current = CP_CURRENT_1080i_50,
++		.hpll_phase_select = PHASE_SELECT_1080i_50,
++		.hpll_post_divider = POST_DIVIDER_1080i_50,
++		.hpll_control = HPLL_CONTROL_1080i_50,
++		.avid_start_msb = AVID_START_PIXEL_MSB_1080i_50,
++		.avid_start_lsb = AVID_START_PIXEL_LSB_1080i_50,
++		.avid_stop_lsb = AVID_STOP_PIXEL_LSB_1080i_50,
++		.avid_stop_msb = AVID_STOP_PIXEL_MSB_1080i_50,
++		.vblk_start_f0_line_offset = VBLK_F0_START_LINE_OFFSET_1080i_50,
++		.vblk_start_f1_line_offset = VBLK_F1_START_LINE_OFFSET_1080i_50,
++		.vblk_f0_duration = VBLK_F0_DURATION_1080i_50,
++		.vblk_f1_duration = VBLK_F1_DURATION_1080i_50,
++		.alc_placement = TVP7002_HD_ALC_PLACEMENT,
++		.clamp_start = TVP7002_HD_CLAMP_START,
++		.clamp_width = TVP7002_HD_CLAMP_WIDTH,
++		.hpll_pre_coast = TVP7002_HD_PRE_COAST,
++		.hpll_post_coast = TVP7002_HD_POST_COAST,
++		.reserved = RESERVED_1080i_50
++	},
++	{
++		.hpll_divider_msb = FEEDBACK_DIVIDER_MSB_720p_50,
++		.hpll_divider_lsb = FEEDBACK_DIVIDER_LSB_720p_50,
++		.hpll_vco_control = VCO_CONTROL_720p_50,
++		.hpll_cp_current = CP_CURRENT_720p_50,
++		.hpll_phase_select = PHASE_SELECT_720p_50,
++		.hpll_post_divider = POST_DIVIDER_720p_50,
++		.hpll_control = HPLL_CONTROL_720p_50,
++		.avid_start_msb = AVID_START_PIXEL_MSB_720p_50,
++		.avid_start_lsb = AVID_START_PIXEL_LSB_720p_50,
++		.avid_stop_lsb = AVID_STOP_PIXEL_LSB_720p_50,
++		.avid_stop_msb = AVID_STOP_PIXEL_MSB_720p_50,
++		.vblk_start_f0_line_offset = VBLK_F0_START_LINE_OFFSET_720p_50,
++		.vblk_start_f1_line_offset = VBLK_F1_START_LINE_OFFSET_720p_50,
++		.vblk_f0_duration = VBLK_F0_DURATION_720p_50,
++		.vblk_f1_duration = VBLK_F1_DURATION_720p_50,
++		.alc_placement = TVP7002_HD_ALC_PLACEMENT,
++		.clamp_start = TVP7002_HD_CLAMP_START,
++		.clamp_width = TVP7002_HD_CLAMP_WIDTH,
++		.hpll_pre_coast = TVP7002_HD_PRE_COAST,
++		.hpll_post_coast = TVP7002_HD_POST_COAST,
++		.reserved = RESERVED_720p
++	},
++	{
++		.hpll_divider_msb = FEEDBACK_DIVIDER_MSB_1080p,
++		.hpll_divider_lsb = FEEDBACK_DIVIDER_LSB_1080p,
++		.hpll_vco_control = VCO_CONTROL_1080p,
++		.hpll_cp_current = CP_CURRENT_1080p,
++		.hpll_phase_select = PHASE_SELECT_1080p,
++		.hpll_post_divider = POST_DIVIDER_1080p,
++		.hpll_control = HPLL_CONTROL_1080p,
++		.avid_start_msb = AVID_START_PIXEL_MSB_1080p,
++		.avid_start_lsb = AVID_START_PIXEL_LSB_1080p,
++		.avid_stop_lsb = AVID_STOP_PIXEL_LSB_1080p,
++		.avid_stop_msb = AVID_STOP_PIXEL_MSB_1080p,
++		.vblk_start_f0_line_offset = VBLK_F0_START_LINE_OFFSET_1080p,
++		.vblk_start_f1_line_offset = VBLK_F1_START_LINE_OFFSET_1080p,
++		.vblk_f0_duration = VBLK_F0_DURATION_1080p,
++		.vblk_f1_duration = VBLK_F1_DURATION_1080p,
++		.alc_placement = TVP7002_HD_ALC_PLACEMENT,
++		.clamp_start = TVP7002_HD_CLAMP_START,
++		.clamp_width = TVP7002_HD_CLAMP_WIDTH,
++		.hpll_pre_coast = TVP7002_HD_PRE_COAST,
++		.hpll_post_coast = TVP7002_HD_POST_COAST,
++		.reserved = RESERVED_720p
++	},
++	{
++		.hpll_divider_msb = FEEDBACK_DIVIDER_MSB_480P,
++		.hpll_divider_lsb = FEEDBACK_DIVIDER_LSB_480P,
++		.hpll_vco_control = VCO_CONTROL_480P,
++		.hpll_cp_current = CP_CURRENT_480P,
++		.hpll_phase_select = PHASE_SELECT_480P,
++		.hpll_post_divider = POST_DIVIDER_480P,
++		.hpll_control = HPLL_CONTROL_480P,
++		.avid_start_msb = AVID_START_PIXEL_MSB_480P,
++		.avid_start_lsb = AVID_START_PIXEL_LSB_480P,
++		.avid_stop_lsb = AVID_STOP_PIXEL_LSB_480P,
++		.avid_stop_msb = AVID_STOP_PIXEL_MSB_480P,
++		.vblk_start_f0_line_offset = VBLK_F0_START_LINE_OFFSET_480P,
++		.vblk_start_f1_line_offset = VBLK_F1_START_LINE_OFFSET_480P,
++		.vblk_f0_duration = VBLK_F0_DURATION_480P,
++		.vblk_f1_duration = VBLK_F1_DURATION_480P,
++		.alc_placement = TVP7002_ED_ALC_PLACEMENT,
++		.clamp_start = TVP7002_ED_CLAMP_START,
++		.clamp_width = TVP7002_ED_CLAMP_WIDTH,
++		.hpll_pre_coast = TVP7002_ED_PRE_COAST,
++		.hpll_post_coast = TVP7002_ED_POST_COAST,
++		.reserved = RESERVED_1080i_50
++	},
++	{
++		.hpll_divider_msb = FEEDBACK_DIVIDER_MSB_576P,
++		.hpll_divider_lsb = FEEDBACK_DIVIDER_LSB_576P,
++		.hpll_vco_control = VCO_CONTROL_576P,
++		.hpll_cp_current = CP_CURRENT_576P,
++		.hpll_phase_select = PHASE_SELECT_576P,
++		.hpll_post_divider = POST_DIVIDER_576P,
++		.hpll_control = HPLL_CONTROL_576P,
++		.avid_start_msb = AVID_START_PIXEL_MSB_576P,
++		.avid_start_lsb = AVID_START_PIXEL_LSB_576P,
++		.avid_stop_lsb = AVID_STOP_PIXEL_LSB_576P,
++		.avid_stop_msb = AVID_STOP_PIXEL_MSB_576P,
++		.vblk_start_f0_line_offset = VBLK_F0_START_LINE_OFFSET_576P,
++		.vblk_start_f1_line_offset = VBLK_F1_START_LINE_OFFSET_576P,
++		.vblk_f0_duration = VBLK_F0_DURATION_576P,
++		.vblk_f1_duration = VBLK_F1_DURATION_576P,
++		.alc_placement = TVP7002_ED_ALC_PLACEMENT,
++		.clamp_start = TVP7002_ED_CLAMP_START,
++		.clamp_width = TVP7002_ED_CLAMP_WIDTH,
++		.hpll_pre_coast = TVP7002_ED_PRE_COAST,
++		.hpll_post_coast = TVP7002_ED_POST_COAST,
++		.reserved = RESERVED_1080i_50
++	},
++};
++
++static struct tvp7002_config tvp7002_configuration[TVP7002_NUM_CHANNELS] = {
++	{
++		.no_of_inputs = TVP7002_MAX_NO_INPUTS,
++		.input[0] = {
++			.input_type = TVP7002_HD_INPUT,
++			.input_info = {
++				.index = 0,
++				.name = "COMPONENT",
++				.type = V4L2_INPUT_TYPE_CAMERA,
++				.std = V4L2_STD_TVP7002_ALL
++			},
++			.no_of_standard = TVP7002_MAX_NO_STANDARDS,
++			.standard = (struct v4l2_standard *)&tvp7002_standards,
++			.def_std = V4L2_STD_720P_60,
++			.format =
++			   (struct tvp7002_format_params *)&tvp7002_formats,
++			.no_of_controls = TVP7002_MAX_NO_CONTROLS,
++			.controls = NULL
++		},
++		.def_params = {V4L2_STD_720P_60, 0,
++				{1, 0xa, 0x6}, {0, 0, 0, 7, 7, 7},
++				{0x80, 0x80, 0x80, 0, 0, 0, 0x10, 0x10, 0x10} }
++	 }
++};
++
++#if 0
++static struct param_ops params_ops = {
++	.setparams = tvp7002_setparams,
++	.getparams = tvp7002_getparams
++};
++static struct control_ops controls_ops = {
++	.count = TVP7002_MAX_NO_CONTROLS,
++	.queryctrl = tvp7002_querycontrol,
++	.setcontrol = tvp7002_setcontrol,
++	.getcontrol = tvp7002_getcontrol
++};
++static struct input_ops inputs_ops = {
++	.count = TVP7002_MAX_NO_INPUTS,
++	.enuminput = tvp7002_enuminput,
++	.setinput = tvp7002_setinput,
++	.getinput = tvp7002_getinput
++};
++static struct standard_ops standards_ops = {
++	.count = TVP7002_MAX_NO_STANDARDS,
++	.enumstd = tvp7002_enumstd,
++	.setstd = tvp7002_setstd,
++	.getstd = tvp7002_getstd,
++	.querystd = tvp7002_querystd,
++};
++#endif
++
++static inline struct tvp7002_decoder *to_decoder(struct v4l2_subdev *sd)
++{
++	return container_of(sd, struct tvp7002_decoder, sd);
++}
++
++static int tvp7002_read_reg(struct v4l2_subdev *sd, u8 reg)
++{
++	int err, retry = 0;
++	struct i2c_client *client = v4l2_get_subdevdata(sd);
++
++read_again:
++
++	err = i2c_smbus_read_byte_data(client, reg);
++	if (err == -1) {
++		if (retry <= I2C_RETRY_COUNT) {
++			v4l2_warn(sd, "Read: retry ... %d\n", retry);
++			retry++;
++			msleep_interruptible(10);
++			goto read_again;
++		}
++	}
++
++	return err;
++}
++
++#if 0
++static void dump_reg(struct v4l2_subdev *sd, u8 reg)
++{
++	u32 val;
++
++	val = tvp7002_read_reg(sd, reg);
++	v4l2_info(sd, "Reg(0x%.2X): 0x%.2X\n", reg, val);
++}
++#endif
++
++static int tvp7002_write_reg(struct v4l2_subdev *sd, u8 reg, u8 val)
++{
++	int err, retry = 0;
++	struct i2c_client *client = v4l2_get_subdevdata(sd);
++
++write_again:
++
++	err = i2c_smbus_write_byte_data(client, reg, val);
++	if (err) {
++		if (retry <= I2C_RETRY_COUNT) {
++			v4l2_warn(sd, "Write: retry ... %d\n", retry);
++			retry++;
++			msleep_interruptible(10);
++			goto write_again;
++		}
++	}
++
++	return err;
++}
++
++#if 0
++static int tvp7002_write_regs(struct v4l2_subdev *sd,
++			      const struct tvp7002_reg reglist[])
++{
++	int err;
++	const struct tvp7002_reg *next = reglist;
++
++	for (; next->token != TOK_TERM; next++) {
++		if (next->token == TOK_DELAY) {
++			msleep(next->val);
++			continue;
++		}
++
++		if (next->token == TOK_SKIP)
++			continue;
++
++		err = tvp7002_write_reg(sd, next->reg, (u8) next->val);
++		if (err) {
++			v4l2_err(sd, "Write failed. Err[%d]\n", err);
++			return err;
++		}
++	}
++	return 0;
++}
++#endif
++
++/* tvp7002_initialize :
++ * This function will set the video format standard
++ */
++static int tvp7002_initialize(struct v4l2_subdev *sd)
++{
++	int err = 0;
++	v4l2_std_id std;
++
++	/* Reset the chip */
++	err |= tvp7002_write_reg(sd, TVP7002_POWER_CONTROL,
++				     0xff);
++	msleep(20);
++
++	err |= tvp7002_write_reg(sd, TVP7002_POWER_CONTROL,
++				     0x00);
++
++	msleep(20);
++	err |= tvp7002_write_reg(sd, TVP7002_HPLL_DIVIDER_MSB,
++				     TVP7002_HPLL_MSB_DEFAULT);
++	err |= tvp7002_write_reg(sd, TVP7002_HPLL_DIVIDER_LSB,
++				     TVP7002_HPLL_LSB_DEFAULT);
++	err |= tvp7002_write_reg(sd, TVP7002_HPLL_CONTROL,
++				     TVP7002_HPLL_CONTROL_DEFAULT);
++	err |= tvp7002_write_reg(sd, TVP7002_HPLL_PHASE_SELECT,
++				     TVP7002_HPLL_PHASE_SEL_DEFAULT);
++	err |= tvp7002_write_reg(sd, TVP7002_CLAMP_START,
++				     TVP7002_CLAMP_START_DEFAULT);
++	err |= tvp7002_write_reg(sd, TVP7002_CLAMP_WIDTH,
++				     TVP7002_CLAMP_WIDTH_DEFAULT);
++	err |= tvp7002_write_reg(sd, TVP7002_HSYNC_OUTPUT_WIDTH,
++				     TVP7002_HSYNC_OUTWIDTH_DEFAULT);
++	err |= tvp7002_write_reg(sd, TVP7002_SYNC_CONTROL_1,
++				     TVP7002_SYNC_CONTROL1_DEFAULT);
++	err |= tvp7002_write_reg(sd, TVP7002_HPLL_CLAMP_CONTROL,
++				     TVP7002_HPLL_CLAMP_CTRL_DEFAULT);
++	err |= tvp7002_write_reg(sd, TVP7002_SYNC_ON_GREEN_THLD,
++				     TVP7002_SYNC_GREEN_THLD_DEFAULT);
++	err |=
++	    tvp7002_write_reg(sd, TVP7002_SYNC_SEPARATER_THLD,
++				  TVP7002_SYNC_SEP_THLD_DEFAULT);
++	err |=
++	    tvp7002_write_reg(sd, TVP7002_HPLL_PRE_COAST,
++				  TVP7002_HPLL_PRE_COAST_DEFAULT);
++	err |=
++	    tvp7002_write_reg(sd, TVP7002_HPLL_POST_COAST,
++				  TVP7002_HPLL_POST_COAST_DEFAULT);
++	err |=
++	    tvp7002_write_reg(sd, TVP7002_OUTPUT_FORMATTER,
++				  TVP7002_OUTPUT_FORMATTER_DEFAULT);
++	err |=
++	    tvp7002_write_reg(sd, TVP7002_MISC_CONTROL_1,
++				  TVP7002_MISC_CONTROL1_DEFAULT);
++	err |=
++	    tvp7002_write_reg(sd, TVP7002_MISC_CONTROL_3,
++				  TVP7002_MISC_CONTROL3_DEFAULT);
++	err |=
++	    tvp7002_write_reg(sd, TVP7002_MISC_CONTROL_2,
++				  TVP7002_MISC_CONTROL2_DEFAULT);
++	err |=
++	    tvp7002_write_reg(sd, TVP7002_INPUT_MUX_SELECT_1,
++				  TVP7002_INPUT_MUX_SELECT1_DEFAULT);
++	err |=
++	    tvp7002_write_reg(sd, TVP7002_INPUT_MUX_SELECT_2,
++				  TVP7002_INPUT_MUX_SELECT2_DEFAULT);
++	err |= tvp7002_write_reg(sd, TVP7002_HSOUT_OUTPUT_START,
++				     TVP7002_HSOUT_OUTPUT_START_DEFAULT);
++	err |= tvp7002_write_reg(sd, TVP7002_MISC_CONTROL_4,
++				     TVP7002_MISC_CONTROL4_DEFAULT);
++	err |= tvp7002_write_reg(sd, TVP7002_ALC_ENABLE,
++				     TVP7002_ALC_ENABLE_DEFAULT);
++	err |= tvp7002_write_reg(sd, TVP7002_ALC_FILTER,
++				     TVP7002_ALC_FILTER_DEFAULT);
++	err |= tvp7002_write_reg(sd, TVP7002_FINE_CLAMP_CONTROL,
++				     TVP7002_FINE_CLAMP_CONTROL_DEFAULT);
++	err |= tvp7002_write_reg(sd, TVP7002_ADC_SETUP,
++				     TVP7002_ADC_SETUP_DEFAULT);
++	err |= tvp7002_write_reg(sd,
++				     TVP7002_COARSE_CLAMP_CONTROL,
++				     TVP7002_COARSE_CLAMP_CONTROL_DEFAULT);
++	err |= tvp7002_write_reg(sd, TVP7002_SOG_CLAMP,
++				     TVP7002_SOG_CLAMP_DEFAULT);
++	err |= tvp7002_write_reg(sd, TVP7002_ALC_PLACEMENT,
++				     TVP7002_ALC_PLACEMENT_DEFAULT);
++	err |=
++	    tvp7002_write_reg(sd,
++				  TVP7002_VIDEO_BANDWIDTH_CONTROL,
++				  TVP7002_VIDEO_BANDWIDTH_CONTROL_DEFAULT);
++	err |=
++	    tvp7002_write_reg(sd, TVP7002_AVID_START_PIXEL_HIGH,
++				  TVP7002_AVID_START_PIXEL_DEFAULT);
++
++	if (err < 0) {
++		err = -EINVAL;
++		return err;
++	} else {
++		std = tvp7002_configuration[0].input[0].def_std;
++		err |= tvp7002_setstd(sd, std);
++
++		if (err < 0) {
++			err = -EINVAL;
++			return err;
++		}
++	}
++	v4l2_dbg(1, debug, sd, "End of tvp7002_init.\n");
++	return err;
++}
++
++#if 0
++/* tvp7002_setcontrol : Function to set the control parameter
++ */
++static int tvp7002_setcontrol(struct v4l2_control *ctrl, void *dec)
++{
++	int err = 0;
++	int ch_id;
++	if (NULL == dec) {
++		printk(KERN_ERR "NULL Pointer\n");
++		return -EINVAL;
++	}
++	v4l2_dbg(1, debug, sd,
++		"TVP7002 supports no control parameter to be set..\n");
++	err = -EINVAL;
++	return err;
++}
++
++/* tvp7002_getcontrol :
++ * Function to get the control parameter
++ */
++static int tvp7002_getcontrol(struct v4l2_control *ctrl, void *dec)
++{
++	int err = 0;
++	int ch_id;
++	if (NULL == dec) {
++		printk(KERN_ERR "NULL Pointer\n");
++		return -EINVAL;
++	}
++	ch_id = ((struct decoder_device *)dec)->channel_id;
++	v4l2_dbg(1, debug, sd,
++		"TVP7002 supports no control parameters..\n");
++	err = -EINVAL;
++	return err;
++}
++
++/* tvp7002_querycontrol :
++ * Function to query control parameter
++ */
++static int tvp7002_querycontrol(struct v4l2_queryctrl *ctrl, void *dec)
++{
++	int err = 0;
++	int ch_id;
++	if (NULL == dec) {
++		printk(KERN_ERR "NULL Pointer\n");
++		return -EINVAL;
++	}
++	ch_id = ((struct decoder_device *)dec)->channel_id;
++	v4l2_dbg(1, debug, sd,
++		"TVP7002 has no control parameters to return..\n");
++	err = -EINVAL;
++	return err;
++}
++
++/* following function is used to set THS7353 */
++static int ths7353_setvalue(void)
++{
++	int err = 0;
++	u8 val[2];
++	u16 ths7353_i2c_addr = 0x5C >> 1;
++	val[1] = 0x95;
++
++	val[0] = 0x01;
++	val[1] = 0x94;
++	err = davinci_i2c_write(2, val, ths7353_i2c_addr);
++	val[0] = 0x02;
++	val[1] = 0x95;
++	err |= davinci_i2c_write(2, val, ths7353_i2c_addr);
++	val[0] = 0x03;
++	val[1] = 0x94;
++	err |= davinci_i2c_write(2, val, ths7353_i2c_addr);
++	if (err) {
++		printk(KERN_ERR "error in configuring THS7353\n");
++	}
++	return err;
++}
++#endif
++
++/* tvp7002_setstd :
++ * Function to set the video standard
++ */
++static int tvp7002_setstd(struct v4l2_subdev *sd, v4l2_std_id id)
++{
++	int err = 0;
++	struct tvp7002_format_params *tvp7002formats;
++	int i = 0;
++	struct v4l2_standard *standard;
++
++	v4l2_dbg(1, debug, sd, "Start of tvp7002_setstd...\n");
++
++	for (i = 0; i < tvp7002_configuration[0].input[0].
++			no_of_standard; i++) {
++		standard = &tvp7002_configuration[0].input[0].standard[i];
++		if (standard->id & id)
++			break;
++	}
++	if (i == tvp7002_configuration[0].input[0].no_of_standard) {
++		v4l2_err(sd, "Invalid id...\n");
++		return -EINVAL;
++	}
++
++	tvp7002formats =
++		&tvp7002_configuration[0].input[0].format[i];
++
++	err = tvp7002_set_format_params(sd, tvp7002formats);
++	if (err < 0) {
++		v4l2_err(sd, "Set standard failed\n");
++		return err;
++	}
++
++	/* Lock the structure variable and assign std to the member
++	   variable */
++	/*tvp7002_channel_info[ch_id].params.std = *id;*/
++
++	v4l2_dbg(1, debug, sd, "End of tvp7002 set standard...\n");
++	return err;
++}
++
++#if 0
++/* tvp7002_getstd :
++ * Function to get the video standard
++ */
++static int tvp7002_getstd(v4l2_std_id * id, void *dec)
++{
++	int err = 0;
++	int ch_id;
++	if (NULL == dec) {
++		printk(KERN_ERR "NULL Pointer\n");
++		return -EINVAL;
++	}
++	ch_id = ((struct decoder_device *)dec)->channel_id;
++	v4l2_dbg(1, debug, sd, "Starting getstd function.\n");
++	if (id == NULL) {
++		v4l2_err(sd, "NULL Pointer.\n");
++		return -EINVAL;
++	}
++
++	/* Read the video standard */
++	*id = tvp7002_channel_info[ch_id].params.std;
++	v4l2_dbg(1, debug, sd, "End of getstd function.\n");
++	return err;
++}
++#endif
++
++static void tvp7002_dump_register(struct v4l2_subdev *sd)
++{
++	int i = 0;
++	u8 val;
++
++	for (i = 0; i <= 0x5B; i++) {
++		val = tvp7002_read_reg(sd, i);
++		printk(KERN_NOTICE "reg %x, val = %x\n", i, val);
++	}
++}
++
++/* tvp7002_querystd :
++ * Function to return standard detected by decoder
++ */
++static int tvp7002_querystd(struct v4l2_subdev *sd, v4l2_std_id *id)
++{
++	int err = 0;
++	int val, val1, val_t;
++
++	v4l2_dbg(1, debug, sd, "Starting querystd function...\n");
++	if (id == NULL) {
++		v4l2_err(sd, "NULL Pointer.\n");
++		return -EINVAL;
++	}
++
++	tvp7002_initialize(sd);
++
++	mdelay(100);
++	/* Query the standards */
++	val = tvp7002_read_reg(sd, TVP7002_LINES_PER_FRAME_STATUS_LOW);
++	if (val < 0) {
++		v4l2_err(sd,
++			"I2C read fails...Lines per frame low\n");
++		return val;
++	}
++	val1 = val;
++	val = tvp7002_read_reg(sd, TVP7002_LINES_PER_FRAME_STATUS_HIGH);
++	if (val < 0) {
++		v4l2_err(sd,
++			"I2C read fails...Lines per frame high\n");
++		return val;
++	}
++	val1 |= (val << LINES_PER_FRAME_MSB_SHIFT) & LINES_PER_FRAME_MSB_MASK;
++	val = (val & VIDEO_DETECTION_MASK) >> VIDEO_DETECTION_SHIFT;
++
++	val_t = tvp7002_read_reg(sd, TVP7002_CLOCK_PER_LINE_STATUS_LSB);
++
++	tvp7002_dump_register(sd);
++	v4l2_dbg(1, debug, sd,
++		   "TVP2002 - clocks per line detected = %d\n", val_t);
++	if ((INTERLACED_VIDEO == val)
++	    && (TVP7002_LINES_1080_60 == val1) &&
++		(val_t >= TVP7002_CPL_1080_60_LOWER &&
++		val_t <= TVP7002_CPL_1080_60_UPPER))
++		*id = V4L2_STD_1080I_60;
++	else if ((INTERLACED_VIDEO == val)
++		&& (TVP7002_LINES_1080_50 == val1) &&
++		    (val_t >= TVP7002_CPL_1080_50_LOWER &&
++		    val_t <= TVP7002_CPL_1080_50_UPPER))
++		*id = V4L2_STD_1080I_50;
++	else if ((PROGRESSIVE_VIDEO == val)
++		   && (TVP7002_LINES_720 == val1) &&
++		   (val_t >= TVP7002_CPL_720P_50_LOWER &&
++		   val_t <= TVP7002_CPL_720P_50_UPPER))
++		*id = V4L2_STD_720P_50;
++	else if ((PROGRESSIVE_VIDEO == val)
++		   && (TVP7002_LINES_720 == val1) &&
++		   (val_t >= TVP7002_CPL_720P_60_LOWER &&
++		   val_t <= TVP7002_CPL_720P_60_UPPER))
++		*id = V4L2_STD_720P_60;
++	else if ((PROGRESSIVE_VIDEO == val) &&
++		 (TVP7002_LINES_1080_60 == val1) &&
++		 (val_t >= TVP7002_CPL_1080P_60_LOWER &&
++		  val_t <= TVP7002_CPL_1080P_60_UPPER))
++		*id = V4L2_STD_1080P_60;
++	else if ((PROGRESSIVE_VIDEO == val)
++		   && (525 == val1))
++		*id = V4L2_STD_525P_60;
++	else if ((PROGRESSIVE_VIDEO == val)
++		   && (625 == val1))
++		*id = V4L2_STD_625P_50;
++	else {
++		v4l2_err(sd,
++			"querystd, erorxxx, val = %x, val1 = %x\n", val, val1);
++		return -EINVAL;
++	}
++
++	/*tvp7002_channel_info[ch_id].params.std = *id;*/
++	err = tvp7002_setstd(sd, *id);
++	v4l2_dbg(1, debug, sd, "End of querystd function.\n");
++	return err;
++}
++
++#if 0
++/* tvp7002_enumstd : Function to enumerate standards supported
++ */
++static int tvp7002_enumstd(struct v4l2_standard *std, void *dec)
++{
++	int index, index1;
++	int err = 0;
++	int ch_id;
++	int input_idx, sumstd = 0;
++	if (NULL == dec) {
++		printk(KERN_ERR "NULL Pointer\n");
++		return -EINVAL;
++	}
++	ch_id = ((struct decoder_device *)dec)->channel_id;
++	if (std == NULL) {
++		v4l2_err(sd, "NULL Pointer.\n");
++		return -EINVAL;
++	}
++	index = std->index;
++	index1 = index;
++	/* Check for valid value of index */
++	for (input_idx = 0;
++	     input_idx < tvp7002_configuration[0].no_of_inputs;
++	     input_idx++) {
++		sumstd += tvp7002_configuration[0].input[input_idx]
++		    .no_of_standard;
++		if (index < sumstd) {
++			sumstd -= tvp7002_configuration[0]
++			    .input[input_idx].no_of_standard;
++			break;
++		}
++	}
++	if (input_idx == tvp7002_configuration[0].no_of_inputs)
++		return -EINVAL;
++	index -= sumstd;
++
++	memset(std, 0, sizeof(*std));
++
++	memcpy(std, &tvp7002_configuration[0].input[input_idx].
++	       standard[index], sizeof(struct v4l2_standard));
++	std->index = index1;
++	return err;
++}
++
++/* tvp7002_setinput :
++ * Function to set the input
++ */
++static int tvp7002_setinput(int *index, void *dec)
++{
++	int err = 0;
++	int ch_id;
++	if (NULL == dec) {
++		printk(KERN_ERR "NULL Pointer\n");
++		return -EINVAL;
++	}
++	ch_id = ((struct decoder_device *)dec)->channel_id;
++	v4l2_dbg(1, debug, sd, "Start of set input function.\n");
++
++	/* check for null pointer */
++	if (index == NULL) {
++		v4l2_err(sd, "NULL Pointer.\n");
++		return -EINVAL;
++	}
++	if ((*index >= tvp7002_configuration[0].no_of_inputs)
++	    || (*index < 0)) {
++		return -EINVAL;
++	}
++	if (*index == 0) {	/* HD */
++		tvp7002_channel_info[ch_id].params.inputidx = *index;
++	} else {
++		v4l2_err(sd, "Invalid index.\n");
++		return -EINVAL;
++	}
++	v4l2_dbg(1, debug, sd, "End of set input function.\n");
++	return err;
++}
++
++/* tvp7002_getinput : Function to get the input
++ */
++static int tvp7002_getinput(int *index, void *dec)
++{
++	int err = 0;
++	int ch_id;
++	v4l2_std_id id;
++	if (NULL == dec) {
++		printk(KERN_ERR "NULL Pointer\n");
++		return -EINVAL;
++	}
++	ch_id = ((struct decoder_device *)dec)->channel_id;
++	v4l2_dbg(1, debug, sd, "Start of get input function.\n");
++
++	/* check for null pointer */
++	if (index == NULL) {
++		v4l2_err(sd, "NULL Pointer.\n");
++		return -EINVAL;
++	}
++	err |= tvp7002_querystd(&id, dec);
++	if (err < 0) {
++		return err;
++	}
++	*index = 0;
++	*index = tvp7002_channel_info[ch_id].params.inputidx;
++	v4l2_dbg(1, debug, sd, "End of get input function.\n");
++	return err;
++}
++
++/* tvp7002_enuminput :
++ * Function to enumerate the input
++ */
++static int tvp7002_enuminput(struct v4l2_input *input, void *dec)
++{
++	int err = 0;
++	int index = 0;
++	int ch_id;
++	if (NULL == dec) {
++		printk(KERN_ERR "NULL Pointer.\n");
++		return -EINVAL;
++	}
++	ch_id = ((struct decoder_device *)dec)->channel_id;
++
++	/* check for null pointer */
++	if (input == NULL) {
++		v4l2_err(sd, "NULL Pointer.\n");
++		return -EINVAL;
++	}
++
++	/* Only one input is available */
++	if (input->index >= tvp7002_configuration[0].no_of_inputs) {
++		return -EINVAL;
++	}
++	index = input->index;
++	memset(input, 0, sizeof(*input));
++	input->index = index;
++	memcpy(input,
++	       &tvp7002_configuration[0].input[index].input_info,
++	       sizeof(struct v4l2_input));
++	return err;
++}
++#endif
++
++/* tvp7002_set_format_params :
++ * Function to set the format parameters
++ */
++static int tvp7002_set_format_params(struct v4l2_subdev *sd,
++				struct tvp7002_format_params *tvpformats)
++{
++	int err = 0;
++	unsigned char val;
++	
++	v4l2_dbg(1, debug, sd,
++		"Tvp7002 set format params started...\n");
++	if (tvpformats == NULL) {
++		v4l2_err(sd, "NULL Pointer.\n");
++		return -EINVAL;
++	}
++
++	/* Write the HPLL related registers */
++	err = tvp7002_write_reg(sd, TVP7002_HPLL_DIVIDER_MSB,
++				    tvpformats->hpll_divider_msb);
++	if (err < 0) {
++		v4l2_err(sd,
++			"I2C write fails...Divider MSB\n");
++		return err;
++	}
++
++	val = ((tvpformats->
++		hpll_divider_lsb & HPLL_DIVIDER_LSB_MASK) <<
++	       HPLL_DIVIDER_LSB_SHIFT);
++	err =
++	    tvp7002_write_reg(sd, TVP7002_HPLL_DIVIDER_LSB, val);
++	if (err < 0) {
++		v4l2_err(sd,
++			"I2C write fails...Divider LSB.\n");
++		return err;
++	}
++	err = tvp7002_write_reg(sd, TVP7002_HPLL_CONTROL,
++				    tvpformats->hpll_control);
++	err = tvp7002_write_reg(sd, TVP7002_AVID_START_PIXEL_LOW,
++				    tvpformats->avid_start_lsb);
++	err = tvp7002_write_reg(sd, TVP7002_AVID_START_PIXEL_HIGH,
++				    tvpformats->avid_start_msb);
++	err = tvp7002_write_reg(sd, TVP7002_AVID_STOP_PIXEL_LOW,
++				    tvpformats->avid_stop_lsb);
++	err =
++	    tvp7002_write_reg(sd, TVP7002_AVID_STOP_PIXEL_HIGH,
++				  tvpformats->avid_stop_msb);
++	err =
++	    tvp7002_write_reg(sd, TVP7002_VBLK_FIELD0_START_OFFSET,
++				  tvpformats->vblk_start_f0_line_offset);
++	err =
++	    tvp7002_write_reg(sd, TVP7002_VBLK_FIELD1_START_OFFSET,
++				  tvpformats->vblk_start_f1_line_offset);
++	err =
++	    tvp7002_write_reg(sd, TVP7002_VBLK_FIELD0_DURATION,
++				  tvpformats->vblk_f0_duration);
++	err = tvp7002_write_reg(sd, TVP7002_VBLK_FIELD1_DURATION,
++				    tvpformats->vblk_f1_duration);
++
++	err = tvp7002_write_reg(sd, TVP7002_ALC_PLACEMENT,
++				    tvpformats->alc_placement);
++	err = tvp7002_write_reg(sd, TVP7002_CLAMP_START,
++				    tvpformats->clamp_start);
++	err = tvp7002_write_reg(sd, TVP7002_CLAMP_WIDTH,
++				    tvpformats->clamp_width);
++	err = tvp7002_write_reg(sd, TVP7002_HPLL_PRE_COAST,
++				    tvpformats->hpll_pre_coast);
++	err = tvp7002_write_reg(sd, TVP7002_HPLL_POST_COAST,
++				    tvpformats->hpll_post_coast);
++
++	v4l2_dbg(1, debug, sd,
++		"End of tvp7002 set format params...\n");
++	return err;
++}
++
++static int
++tvp7002_g_fmt_cap(struct v4l2_subdev *sd, struct v4l2_format *f)
++{
++	struct tvp7002_decoder *decoder = to_decoder(sd);
++
++	if (f == NULL)
++		return -EINVAL;
++
++	if (f->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
++		/* only capture is supported */
++		return -EINVAL;
++
++	f->fmt.pix = decoder->pix;
++
++	v4l2_dbg(1, debug, sd, "Current FMT: bytesperline - %d"
++			"Width - %d, Height - %d",
++			decoder->pix.bytesperline,
++			decoder->pix.width, decoder->pix.height);
++	return 0;
++}
++
++#if 0
++/* tvp7002_setparams : This function will set parameters for tvp7002
++ */
++static int tvp7002_setparams(void *params, void *dec)
++{
++	int err = 0;
++	unsigned char val;
++	int ch_id;
++	struct i2c_client *ch_client;
++	struct tvp7002_params tvp7002params;
++
++	if (NULL == dec) {
++		printk(KERN_ERR "NULL Pointer\n");
++		return -EINVAL;
++	}
++	if (copy_from_user(&tvp7002params, (struct tvp7002_params *) params,
++			   sizeof(tvp7002params))) {
++		return -EFAULT;
++	}
++	ch_id = ((struct decoder_device *)dec)->channel_id;
++	err |= tvp7002_set_input_mux(ch_id);
++	if (err) {
++		printk(KERN_ERR "Failed to set mux bit.\n");
++		return -EINVAL;
++	}
++
++	ch_client = sd,client;
++	v4l2_dbg(1, debug, sd,
++		"Start of tvp7002 set params function.\n");
++
++	/* check for null pointer */
++	err |= tvp7002_setinput(&(tvp7002params.inputidx), dec);
++	if (err < 0) {
++		v4l2_dbg(1, debug, sd,
++			"Set format parameters failed.\n");
++		return err;
++	}
++	err |= tvp7002_setstd(&(tvp7002params.std), dec);
++	if (err < 0) {
++		v4l2_dbg(1, debug, sd,
++			"Set format parameters failed.\n");
++		return err;
++	}
++
++	/* set video format related parameters */
++	err = tvp7002_set_format_params(sd, &tvp7002params.format);
++	if (err < 0) {
++		v4l2_dbg(1, debug, sd,
++			"Set format parameters failed.\n");
++		return err;
++	}
++
++	/* Write the gain information */
++	err = tvp7002_write_reg(ch_client, TVP7002_BLUE_FINE_GAIN,
++				    tvp7002params.gain.blue_fine_gain);
++	if (err < 0) {
++		v4l2_err(sd, "I2C write fails...\n");
++		return err;
++	}
++	err = tvp7002_write_reg(ch_client, TVP7002_GREEN_FINE_GAIN,
++				    tvp7002params.gain.green_fine_gain);
++	if (err < 0) {
++		v4l2_err(sd, "I2C write fails...\n");
++		return err;
++	}
++	err = tvp7002_write_reg(ch_client, TVP7002_RED_FINE_GAIN,
++				    tvp7002params.gain.red_fine_gain);
++	if (err < 0) {
++		v4l2_err(sd, "I2C write fails...\n");
++		return err;
++	}
++
++	/* Write coarse gain information */
++	val = 0;
++	val = tvp7002params.gain.blue_coarse_gain & BLUE_COARSE_GAIN_MASK;
++	tvp7002params.gain.blue_coarse_gain = val;
++
++	val |= ((tvp7002params.gain.green_coarse_gain &
++		 GREEN_COARSE_GAIN_MASK) << GREEN_COARSE_GAIN_SHIFT);
++	tvp7002params.gain.green_coarse_gain =
++	    tvp7002params.gain.green_coarse_gain & GREEN_COARSE_GAIN_MASK;
++
++	err = tvp7002_write_reg(ch_client,
++				    TVP7002_BLUE_GREEN_COARSE_GAIN, val);
++	if (err < 0) {
++		v4l2_err(sd, "I2C write fails...\n");
++		return err;
++	}
++
++	val = tvp7002params.gain.red_coarse_gain & RED_COARSE_GAIN_MASK;
++	tvp7002params.gain.red_coarse_gain = val;
++	err = tvp7002_write_reg(ch_client, TVP7002_RED_COARSE_GAIN, val);
++	if (err < 0) {
++		v4l2_err(sd, "I2C write fails...\n");
++		return err;
++	}
++
++	/*Write the offset value in register */
++	err = tvp7002_write_reg(ch_client,
++				    TVP7002_BLUE_FINE_OFFSETMSB,
++				    tvp7002params.offset.blue_fine_offset);
++	if (err < 0) {
++		v4l2_err(sd, "I2C write fails...\n");
++		return err;
++	}
++	err = tvp7002_write_reg(ch_client,
++				    TVP7002_GREEN_FINE_OFFSETMSB,
++				    tvp7002params.offset.green_fine_offset);
++	if (err < 0) {
++		v4l2_err(sd, "I2C write fails...\n");
++		return err;
++	}
++	err = tvp7002_write_reg(ch_client, TVP7002_RED_FINE_OFFSETMSB,
++				    tvp7002params.offset.red_fine_offset);
++	if (err < 0) {
++		v4l2_err(sd, "I2C write fails...\n");
++		return err;
++	}
++	val = 0;
++	val = tvp7002params.offset.blue_fine_offset_lsb & FINE_OFFSET_LSB_MASK;
++	tvp7002params.offset.blue_fine_offset_lsb = val;
++
++	val |= ((tvp7002params.
++		 offset.green_fine_offset_lsb & FINE_OFFSET_LSB_MASK) <<
++		FINE_OFFSET_LSB_SHIFT_GREEN);
++	tvp7002params.offset.green_fine_offset_lsb =
++	    (tvp7002params.offset.green_fine_offset_lsb & FINE_OFFSET_LSB_MASK);
++
++	val |= ((tvp7002params.
++		 offset.red_fine_offset_lsb & FINE_OFFSET_LSB_MASK) <<
++		FINE_OFFSET_LSB_SHIFT_RED);
++	tvp7002params.offset.red_fine_offset_lsb =
++	    (tvp7002params.offset.red_fine_offset_lsb & FINE_OFFSET_LSB_MASK);
++
++	err = tvp7002_write_reg(ch_client, TVP7002_FINE_OFFSET_LSBS, val);
++	if (err < 0) {
++		v4l2_err(sd, "I2C write fails...\n");
++		return err;
++	}
++	val = tvp7002params.offset.blue_coarse_offset & COARSE_OFFSET_MASK;
++	tvp7002params.offset.blue_coarse_offset = val;
++
++	err = tvp7002_write_reg(ch_client, TVP7002_BLUE_COARSE_OFFSET, val);
++	if (err < 0) {
++		v4l2_err(sd, "I2C write fails...\n");
++		return err;
++	}
++	val = tvp7002params.offset.green_coarse_offset & COARSE_OFFSET_MASK;
++	tvp7002params.offset.green_coarse_offset = val;
++
++	err =
++	    tvp7002_write_reg(ch_client, TVP7002_GREEN_COARSE_OFFSET, val);
++	if (err < 0) {
++		v4l2_err(sd, "I2C write fails...\n");
++		return err;
++	}
++	val = tvp7002params.offset.red_coarse_offset & COARSE_OFFSET_MASK;
++	tvp7002params.offset.red_coarse_offset = val;
++
++	err = tvp7002_write_reg(ch_client, TVP7002_RED_COARSE_OFFSET, val);
++	if (err < 0) {
++		v4l2_err(sd, "I2C write fails...\n");
++		return err;
++	}
++	if (tvp7002params.alc.alc_enable) {
++		err =
++		    tvp7002_write_reg(ch_client, TVP7002_ALC_ENABLE, 0x80);
++	} else {
++		err =
++		    tvp7002_write_reg(ch_client, TVP7002_ALC_ENABLE, 0x00);
++	}
++	val = (tvp7002params.alc.vcoeff << TVP7002_ALC_VCOEFF_SHIFT) |
++	    (tvp7002params.alc.hcoeff);
++	err = tvp7002_write_reg(ch_client, TVP7002_ALC_FILTER, val);
++	if (err < 0)
++		return err;
++
++	tvp7002_channel_info[ch_id].params = tvp7002params;
++	v4l2_dbg(1, debug, sd, "End of configTVP7002...\n");
++	return err;
++}
++
++/* tvp7002_getparams : This function will get parameters for tvp7002
++ */
++static int tvp7002_getparams(void *params, void *dec)
++{
++	int ch_id;
++	int err = 0;
++	struct tvp7002_params *tvp7002params = (struct tvp7002_params *) params;
++	if (NULL == dec) {
++		printk(KERN_ERR "NULL Pointer\n");
++		return -EINVAL;
++	}
++	ch_id = ((struct decoder_device *)dec)->channel_id;
++	v4l2_dbg(1, debug, sd, "Starting tvp7002_getparams\n");
++
++	/* check for null pointer */
++	if (tvp7002params == NULL) {
++		v4l2_err(sd, "Null pointer\n");
++		return -EINVAL;
++	}
++	if (copy_to_user(tvp7002params, &(tvp7002_channel_info[ch_id].params),
++			 sizeof(*tvp7002params))) {
++		return -EFAULT;
++	}
++
++	v4l2_dbg(1, debug, sd, "End of getparams TVP7002...\n");
++	return err;
++}
++#endif
++
++static int tvp7002_s_stream(struct v4l2_subdev *sd, int enable)
++{
++	int err = 0;
++	struct tvp7002_decoder *decoder = to_decoder(sd);
++
++	if (decoder->streaming == enable)
++		return 0;
++
++	switch (enable) {
++	case 0:
++	{
++		err = tvp7002_write_reg(sd, TVP7002_MISC_CONTROL_2, 0x1);
++		if (err) {
++			v4l2_err(sd, "Unable to turn off decoder\n");
++			return err;
++		}
++		decoder->streaming = enable;
++		break;
++	}
++	case 1:
++	{
++		/* Power Up Sequence */
++		err = tvp7002_write_reg(sd, TVP7002_MISC_CONTROL_2, 0x0);
++		if (err) {
++			v4l2_err(sd, "Unable to turn off decoder\n");
++			return err;
++		}
++		decoder->streaming = enable;
++		break;
++	}
++	default:
++		err = -ENODEV;
++		break;
++	}
++
++	return err;
++}
++
++static const struct v4l2_subdev_core_ops tvp7002_core_ops = {
++	.s_std = tvp7002_setstd,
++};
++
++static const struct v4l2_subdev_video_ops tvp7002_video_ops = {
++	.querystd = tvp7002_querystd,
++	.g_fmt = tvp7002_g_fmt_cap,
++	.s_stream = tvp7002_s_stream,
++};
++
++static const struct v4l2_subdev_ops tvp7002_ops = {
++	.core = &tvp7002_core_ops,
++	.video = &tvp7002_video_ops,
++};
++
++static struct tvp7002_decoder tvp7002_dev = {
++	.streaming = 0,
++
++	.fmt_list = tvp7002_fmt_list,
++	.num_fmts = ARRAY_SIZE(tvp7002_fmt_list),
++
++	.pix = {
++		/* Default to NTSC 8-bit YUV 422 */
++		.width = HD_720_NUM_ACTIVE_PIXELS,
++		.height = HD_720_NUM_ACTIVE_LINES,
++		.pixelformat = V4L2_PIX_FMT_UYVY,
++		.field = V4L2_FIELD_NONE,
++		.bytesperline = HD_720_NUM_ACTIVE_PIXELS * 2,
++		.sizeimage =
++		HD_720_NUM_ACTIVE_PIXELS * 2 * HD_720_NUM_ACTIVE_LINES,
++		.colorspace = V4L2_COLORSPACE_SMPTE170M,
++		},
++
++	.current_std = 0,
++	/*
++	.std_list = tvp7002_std_list,
++	.num_stds = ARRAY_SIZE(tvp7002_std_list),
++	*/
++};
++
++static int 
++tvp7002_probe(struct i2c_client *client, const struct i2c_device_id *id)
++{
++	struct tvp7002_decoder *decoder;
++	struct v4l2_subdev *sd;
++	/*int polarity;*/
++	int err;
++
++	/* Check if the adapter supports the needed features */
++	if (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))
++		return -EIO;
++
++	if (!client->dev.platform_data) {
++		v4l2_err(client, "No platform data!!\n");
++		return -ENODEV;
++	}
++
++	decoder = kzalloc(sizeof(*decoder), GFP_KERNEL);
++	if (!decoder)
++		return -ENOMEM;
++
++	/* Initialize the tvp7002_decoder with default configuration */
++	*decoder = tvp7002_dev;
++
++	/* Copy board specific information here */
++	decoder->pdata = client->dev.platform_data;
++
++	/* TODO: need to take the values from the platform data */
++	/*decoder->pdata->clk_polarity
++	decoder->pdata->hs_polarity
++	decoder->pdata->vs_polarity
++	decoder->pdata->fid_polarity*/
++
++	/* Set default standard to auto */
++	/*decoder->tvp7002_regs[REG_VIDEO_STD].val =
++		VIDEO_STD_AUTO_SWITCH_BIT;*/
++
++	/* Register with V4L2 layer as slave device */
++	sd = &decoder->sd;
++	v4l2_i2c_subdev_init(sd, client, &tvp7002_ops);
++
++	err = tvp7002_initialize(sd);
++	if (err < 0)
++		return err;
++
++	v4l2_info(sd, "%s decoder driver registered !!\n", sd->name);
++
++	return 0;
++}
++
++static int tvp7002_remove(struct i2c_client *client)
++{
++	struct v4l2_subdev *sd = i2c_get_clientdata(client);
++	struct tvp7002_decoder *decoder = to_decoder(sd);
++
++	v4l2_device_unregister_subdev(sd);
++	kfree(decoder);
++	return 0;
++}
++
++/* I2C Device ID table */
++static const struct i2c_device_id tvp7002_id[] = {
++	{ "tvp7002", 0 },
++	{ }
++};
++MODULE_DEVICE_TABLE(i2c, tvp7002_id);
++
++/* I2C driver data */
++static struct i2c_driver tvp7002_driver = {
++	.driver = {
++		.owner = THIS_MODULE,
++		.name = "tvp7002",
++	},
++	.probe = tvp7002_probe,
++	.remove = tvp7002_remove,
++	.id_table = tvp7002_id,
++};
++
++static int __init tvp7002_init(void)
++{
++	return i2c_add_driver(&tvp7002_driver);
++}
++
++static void __exit tvp7002_exit(void)
++{
++	i2c_del_driver(&tvp7002_driver);
++}
++
++module_init(tvp7002_init);
++module_exit(tvp7002_exit);
++MODULE_LICENSE("GPL");
+--- /dev/null
++++ b/drivers/char/dm355_def_para.c
+@@ -0,0 +1,361 @@
++/*
++ *
++ * Copyright (C) 2008 Texas Instruments Inc
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
++ *
++ **************************************************************************/
++#include <media/davinci/dm355_ipipe.h>
++/* Defaults for pre-filter */
++struct prev_prefilter dm355_pf_defaults = {
++	.en = 0,
++	.en_adapt_prefilter = 1,
++	.en_adapt_dotred = 0,
++	.aver_meth_gs1 = PREV_PF_AVG4PIX,
++	.aver_meth_gs2 = PREV_PF_AVG4PIX,
++	.pre_gain = 128,
++	.pre_shf = 9,
++	.pre_thr_g = 500,
++	.pre_thr_b = 4096,
++	.pre_thr_1 = 800
++};
++
++/* Defaults for dfc */
++struct prev_dfc dm355_dfc_defaults = {
++	.en = 0,
++	.vert_copy_method = IPIPE_DFC_COPY_FROM_TOP,
++	.dfc_size = 0
++};
++
++/* Defaults for 2D - nf */
++struct prev_nf dm355_nf_defaults = {
++	.en = 0,
++	.gr_sample_meth = IPIPE_NF_BOX,
++	.shft_val = 0,
++	.spread_val = 0
++};
++
++/* Defaults for white balance */
++struct prev_wb dm355_wb_defaults = {
++	.dgn = {2, 0},		/* 512 */
++	.gain_r = {2, 0x10},
++	.gain_gr = {1, 0x70},
++	.gain_gb = {1, 0x70},
++	.gain_b = {2, 0x30}
++};
++
++/* Defaults for rgb2rgb */
++struct prev_rgb2rgb dm355_rgb2rgb_defaults = {
++	.coef_rr = {1, 0xa1},	/* 256 */
++	.coef_gr = {0xf, 0x8a},
++	.coef_br = {0xf, 0xd5},
++	.coef_rg = {0xf, 0xa1},
++	.coef_gg = {1, 0xc4},	/* 256 */
++	.coef_bg = {0xf, 0x9b},
++	.coef_rb = {0xf, 0xbd},
++	.coef_gb = {0xf, 0xb1},
++	.coef_bb = {1, 0x92},	/* 256 */
++	.out_ofst_r = 0,
++	.out_ofst_g = 0,
++	.out_ofst_b = 0
++};
++
++/* Defaults for gamma correction */
++struct prev_gamma dm355_gamma_defaults = {
++	.bypass_r = 1,
++	.bypass_b = 1,
++	.bypass_g = 1,
++	.tbl_sel = IPIPE_GAMMA_TBL_ROM
++};
++
++/* Defaults for rgb2yuv conversion */
++struct prev_rgb2yuv dm355_rgb2yuv_defaults = {
++	.coef_ry = {0, 0x4d},
++	.coef_gy = {0, 0x96},
++	.coef_by = {0, 0x1d},
++	.coef_rcb = {3, 0xD4},	/* 981 */
++	.coef_gcb = {3, 0xAC},	/* 939 */
++	.coef_bcb = {0, 0x80},
++	.coef_rcr = {0, 0x80},
++	.coef_gcr = {3, 0x95},	/* 917 */
++	.coef_bcr = {3, 0xEB},	/* 1003 */
++	.out_ofst_y = 0,
++	.out_ofst_cb = 0x80,
++	.out_ofst_cr = 0x80
++};
++
++/* Defaults for lumina adjustments */
++struct prev_lum_adj dm355_lum_adj_defaults = {
++	.brightness = 16,
++	.contast = 16
++};
++
++/* Defaults for yuv 422 conversion */
++struct prev_yuv422_conv dm355_yuv422_conv_defaults = {
++	.lum_min = 0,
++	.lum_max = 255,
++	.chrom_min = 0,
++	.chrom_max = 255,
++	.en_chrom_lpf = 0,
++	.chrom_pos = IPIPE_YUV422_CHR_POS_CENTRE
++};
++
++/* Defaults for yuv 422 conversion */
++struct prev_yee dm355_yee_defaults = {
++	.en = 0,
++	.en_emf = 0,
++	.hpf_shft = 4,
++	.hpf_coef_00 = 48,
++	.hpf_coef_01 = 12,
++	.hpf_coef_02 = 1014,
++	.hpf_coef_10 = 12,
++	.hpf_coef_11 = 0,
++	.hpf_coef_12 = 1018,
++	.hpf_coef_20 = 1014,
++	.hpf_coef_21 = 1018,
++	.hpf_coef_22 = 1022
++};
++
++/* Defaults for yuv 422 conversion */
++struct prev_fcs dm355_fcs_defaults = {
++	.en = 0,
++	.type = IPIPE_FCS_Y,
++	.hpf_shft_y = 0,
++	.gain_shft_c = 7,
++	.thr = 235,
++	.sgn = 0,
++	.lth = 0
++};
++
++#define  WIDTH_I 640
++#define  HEIGHT_I 480
++#define  WIDTH_O 640
++#define  HEIGHT_O 480
++
++struct ipipe_params dm355_ipipe_defs = {
++	.ipipeif_param = {
++		.data_shift = IPIPEIF_BITS9_0,
++		.clock_select = SDRAM_CLK,
++		.ialaw = ALAW_OFF,
++		.pack_mode = SIXTEEN_BIT,
++		.avg_filter = AVG_OFF,
++		.clk_div = IPIPEIF_DIVIDE_SIXTH,
++		.source = SDRAM_RAW,
++		.decimation = IPIPEIF_DECIMATION_OFF,
++		.mode = ONE_SHOT,
++		.glob_hor_size = WIDTH_I + 8,
++		.glob_ver_size = HEIGHT_I + 10,
++		.hnum = WIDTH_I,
++		.vnum = HEIGHT_I,
++		.adofs = WIDTH_I * 2,
++		/* resize ratio 16/rsz */
++		.rsz = 16,
++		/* U10Q9 */
++		.gain = 0x200,
++	},
++	.ipipe_mode = ONE_SHOT,
++	.ipipe_dpaths_fmt = IPIPE_RAW2YUV,
++	.ipipe_dpaths_bypass = IPIPE_BYPASS_OFF,
++	.ipipe_colpat_olop = IPIPE_GREEN_BLUE,
++	.ipipe_colpat_olep = IPIPE_BLUE,
++	.ipipe_colpat_elop = IPIPE_RED,
++	.ipipe_colpat_elep = IPIPE_GREEN_RED,
++	.ipipe_vst = 0,
++	.ipipe_vsz = HEIGHT_I - 1,
++	.ipipe_hst = 0,
++	.ipipe_hsz = WIDTH_I - 1,
++	.rsz_seq_seq = DISABLE,
++	.rsz_seq_tmm = DISABLE,
++	/* output confined mode (normal mode) */
++	.rsz_seq_hrv = DISABLE,
++	.rsz_seq_vrv = DISABLE,
++	.rsz_seq_crv = DISABLE,
++	.rsz_aal = DISABLE,
++	.rsz_rsc_param = {
++		{
++			.rsz_mode = ONE_SHOT,
++			.rsz_i_vst = 0,
++			.rsz_i_vsz = 0,
++			.rsz_i_hst = 0,
++			.rsz_o_vsz = HEIGHT_O - 1,
++			.rsz_o_hsz = WIDTH_O - 1,
++			.rsz_o_hst = 0,
++			.rsz_v_phs = 0,
++			.rsz_v_dif = 243,
++			.rsz_h_phs = 0,
++			.rsz_h_dif = 243,
++			.rsz_h_typ = RSZ_H_INTP_CUBIC,
++			.rsz_h_lse_sel = RSZ_H_LPF_LSE_INTERN,
++			.rsz_h_lpf = 0
++		},
++		{
++			ONE_SHOT,
++			0,
++			0,
++			0,
++			239,
++			319,
++			0,
++			0,
++			256,
++			0,
++			256,
++			RSZ_H_INTP_CUBIC,
++			RSZ_H_LPF_LSE_INTERN,
++			0
++		}
++	},
++	.rsz2rgb = {
++		{
++			.rsz_rgb_en = DISABLE,
++		},
++		{
++			DISABLE,
++		}
++	},
++	.ext_mem_param = {
++		{
++			.rsz_sdr_bad_h = 0,
++			.rsz_sdr_bad_l = 0,
++			.rsz_sdr_sad_h = 0,
++			.rsz_sdr_sad_l = 0,
++			.rsz_sdr_oft = WIDTH_O * 2,
++			.rsz_sdr_ptr_s = 0,
++			.rsz_sdr_ptr_e = WIDTH_O
++		},
++		{
++			0,
++			0,
++			0,
++			0,
++			WIDTH_O * 2,
++			0,
++			8191
++		}
++	},
++	.rsz_en[0] = ENABLE,
++	.rsz_en[1] = DISABLE
++};
++
++struct prev_single_shot_config dm355_prev_ss_config_defs = {
++	.bypass = IPIPE_BYPASS_OFF,
++	.input = {
++		.image_width = WIDTH_I,
++		.image_height = HEIGHT_I,
++		.vst = 0,
++		.hst = 0,
++		.ppln = WIDTH_I + 8,
++		.lpfr = HEIGHT_I + 10,
++		.clk_div = IPIPEIF_DIVIDE_SIXTH,
++		.data_shift = IPIPEIF_BITS9_0,
++		.dec_en = 0,
++		/* resize ratio 16/rsz */
++		.rsz = 16,
++		.avg_filter_en = AVG_OFF,
++		.gain = 0x200,
++		.pix_fmt = IPIPE_BAYER,
++		.colp_olop = IPIPE_GREEN_BLUE,
++		.colp_olep = IPIPE_BLUE,
++		.colp_elop = IPIPE_RED,
++		.colp_elep = IPIPE_GREEN_RED
++	},
++	.output = {
++		.pix_fmt = IPIPE_UYVY
++	}
++};
++
++struct prev_continuous_config dm355_prev_cont_config_defs = {
++	.bypass = IPIPE_BYPASS_OFF,
++	.input = {
++		.en_df_sub = 0,
++		.dec_en = 0,
++		.rsz = 16,
++		.avg_filter_en = AVG_OFF,
++		.gain = 0x200,
++		.colp_olop = IPIPE_GREEN_BLUE,
++		.colp_olep = IPIPE_BLUE,
++		.colp_elop = IPIPE_RED,
++		.colp_elep = IPIPE_GREEN_RED
++	}
++};
++
++struct rsz_single_shot_config dm355_rsz_ss_config_defs = {
++	.input = {
++		.image_width = WIDTH_I,
++		.image_height = HEIGHT_I,
++		.vst = 0,
++		.hst = 0,
++		.ppln = WIDTH_I + 8,
++		.lpfr = HEIGHT_I + 10,
++		.clk_div = IPIPEIF_DIVIDE_SIXTH,
++		.dec_en = 0,
++		/* resize ratio 16/rsz */
++		.rsz = 16,
++		.avg_filter_en = AVG_OFF,
++		.pix_fmt = IPIPE_UYVY
++	},
++	.output1 = {
++		.enable = 1,
++		.pix_fmt = IPIPE_UYVY,
++		.width = WIDTH_O,
++		.height = HEIGHT_O,
++		.vst = 0,
++		.hst = 0,
++		.h_intp_type = RSZ_H_INTP_CUBIC,
++		.h_lpf_lse_sel = RSZ_H_LPF_LSE_INTERN,
++		.lpf_user_val = 0
++	},
++	.output1 = {
++		.enable = 1,
++		.pix_fmt = IPIPE_UYVY,
++		.width = WIDTH_O,
++		.height = HEIGHT_O,
++		.vst = 0,
++		.hst = 0,
++		.h_intp_type = RSZ_H_INTP_CUBIC,
++		.h_lpf_lse_sel = RSZ_H_LPF_LSE_INTERN,
++		.lpf_user_val = 0
++	},
++	.en_flip_vert = 0,
++	.en_flip_horz = 0,
++	.chroma_sample_even = 0,
++	.en_vaaf = 0
++};
++
++struct rsz_continuous_config dm355_rsz_cont_config_defs = {
++	.input = {
++		.dec_en = 0,
++		/* resize ratio 16/rsz */
++		.rsz = 16,
++		.avg_filter_en = AVG_OFF,
++		.gain = 0x200
++	},
++	.en_output1 = 1,
++	.output2 = {
++		.enable = 0,
++		.pix_fmt = IPIPE_UYVY,
++		.width = WIDTH_O,
++		.height = HEIGHT_O,
++		.vst = 0,
++		.hst = 0,
++		.h_intp_type = RSZ_H_INTP_CUBIC,
++		.h_lpf_lse_sel = RSZ_H_LPF_LSE_INTERN,
++		.lpf_user_val = 0
++	},
++	.en_flip_vert = 0,
++	.en_flip_horz = 0,
++	.chroma_sample_even = 0,
++	.en_vaaf = 0
++};
+--- /dev/null
++++ b/drivers/input/misc/dm365evm_keys.c
+@@ -0,0 +1,323 @@
++/*
++ * dm365evm_keys.c - support IR remote on DM365 EVM board
++ *
++ * Copyright (c) 2009 by David Brownell
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License
++ * as published by the Free Software Foundation; either version
++ * 2 of the License, or (at your option) any later version.
++ */
++#include <linux/kernel.h>
++#include <linux/init.h>
++#include <linux/input.h>
++#include <linux/i2c.h>
++#include <linux/interrupt.h>
++#include <linux/gpio.h>
++
++
++/*
++ * The MSP430 firmware on the DM365 EVM monitors an IR receptor used for
++ * the remote control.  When any key is pressed, or its autorepeat kicks
++ * in, an event is sent.  This driver read those events from the small
++ * event queue and reports them.
++ *
++ * Compared to the DM355 EVM:  the MSP firmware does *only* IR.  So this
++ * driver is simpler, and doesn't even need to use the MFD model.
++ *
++ * Note that physically there can only be one of these devices.
++ *
++ * This driver was tested with firmware revision 0xA1 (beta board).
++ */
++struct dm365evm_keys {
++	struct input_dev	*input;
++	struct i2c_client	*i2c;
++};
++
++#define DM365EVM_MSP_FIRMREV		0
++#define DM365EVM_MSP_INPUT_LOW		1
++#define DM365EVM_MSP_INPUT_HIGH		2
++#define DM365EVM_MSP_INPUT_COUNT	3
++#define DM365EVM_MSP_0x43		4
++
++#define MSP430_GPIO			0
++
++/* These initial keycodes can be remapped by dm365evm_setkeycode(). */
++static struct {
++	u16	event;
++	u16	keycode;
++} dm365evm_keys[] = {
++
++	/*
++	 * IR buttons ... codes assigned to match the universal remote
++	 * provided with the EVM (Philips PM4S) using DVD code 0020.
++	 *
++	 * These event codes match firmware documentation, but other
++	 * remote controls could easily send more RC5-encoded events.
++	 * The PM4S manual was used in several cases to help select
++	 * a keycode reflecting the intended usage.
++	 *
++	 * RC5 codes are 14 bits, with two start bits (0x3 prefix)
++	 * and a toggle bit (masked out below).
++	 */
++	{ 0x300c, KEY_POWER, },		/* NOTE: docs omit this */
++	{ 0x3000, KEY_NUMERIC_0, },
++	{ 0x3001, KEY_NUMERIC_1, },
++	{ 0x3002, KEY_NUMERIC_2, },
++	{ 0x3003, KEY_NUMERIC_3, },
++	{ 0x3004, KEY_NUMERIC_4, },
++	{ 0x3005, KEY_NUMERIC_5, },
++	{ 0x3006, KEY_NUMERIC_6, },
++	{ 0x3007, KEY_NUMERIC_7, },
++	{ 0x3008, KEY_NUMERIC_8, },
++	{ 0x3009, KEY_NUMERIC_9, },
++	{ 0x3022, KEY_ENTER, },
++	{ 0x30ec, KEY_MODE, },		/* "tv/vcr/..." */
++	{ 0x300f, KEY_SELECT, },	/* "info" */
++	{ 0x3020, KEY_CHANNELUP, },	/* "up" */
++	{ 0x302e, KEY_MENU, },		/* "in/out" */
++	{ 0x3011, KEY_VOLUMEDOWN, },	/* "left" */
++	{ 0x300d, KEY_MUTE, },		/* "ok" */
++	{ 0x3010, KEY_VOLUMEUP, },	/* "right" */
++	{ 0x301e, KEY_SUBTITLE, },	/* "cc" */
++	{ 0x3021, KEY_CHANNELDOWN, },	/* "down" */
++	{ 0x3022, KEY_PREVIOUS, },
++	{ 0x3026, KEY_SLEEP, },
++	{ 0x3172, KEY_REWIND, },
++	{ 0x3175, KEY_PLAY, },
++	{ 0x3174, KEY_FASTFORWARD, },
++	{ 0x3177, KEY_RECORD, },
++	{ 0x3176, KEY_STOP, },
++	{ 0x3169, KEY_PAUSE, },
++
++	/* NOTE:  SW22, a pushbutton next to the IR sensor, is also
++	 * wired to the MSP430 but is currently ignored; some other
++	 * I/O pins are likewise wired but ignored.
++	 */
++};
++
++static irqreturn_t dm365evm_keys_irq(int irq, void *_keys)
++{
++	struct dm365evm_keys	*keys = _keys;
++
++	/* For simplicity we ignore INPUT_COUNT and just read
++	 * events until the GPIO stops signaling data ready.
++	 */
++	while (gpio_get_value(MSP430_GPIO) == 0) {
++		static u16	last_event;
++		u16		event;
++		int		keycode;
++		int		i;
++
++		/* Read low, then high bytes; reading the high byte
++		 * removes an entry from the input buffer.
++		 */
++		event = i2c_smbus_read_word_data(keys->i2c,
++					DM365EVM_MSP_INPUT_LOW);
++		if (event < 0) {
++			dev_dbg(&keys->i2c->dev, "input err %d\n", event);
++			break;
++		}
++		event = event;
++
++		/* Press and release a button:  two events, same code.
++		 * Press and hold (autorepeat), then release: N events
++		 * (N > 2), same code.  For RC5 buttons the toggle bits
++		 * distinguish (for example) "1-autorepeat" from "1 1";
++		 * but PCB buttons don't support that bit.
++		 *
++		 * So we must synthesize release events.  We do that by
++		 * mapping events to a press/release event pair; then
++		 * to avoid adding extra events, skip the second event
++		 * of each pair.
++		 */
++		if (event == last_event) {
++			last_event = 0;
++			continue;
++		}
++		last_event = event;
++
++		/* ignore the RC5 toggle bit */
++		event &= ~0x0800;
++
++		/* find the key, or leave it as unknown */
++		keycode = KEY_UNKNOWN;
++		for (i = 0; i < ARRAY_SIZE(dm365evm_keys); i++) {
++			if (dm365evm_keys[i].event != event)
++				continue;
++			keycode = dm365evm_keys[i].keycode;
++			break;
++		}
++		dev_dbg(&keys->i2c->dev,
++			"input event 0x%04x--> keycode %d\n",
++			event, keycode);
++
++		/* report press + release */
++		input_report_key(keys->input, keycode, 1);
++		input_sync(keys->input);
++		input_report_key(keys->input, keycode, 0);
++		input_sync(keys->input);
++	}
++	return IRQ_HANDLED;
++}
++
++/*
++ * Since we talk to the MSP using I2C, we need to delegate all real
++ * IRQ handling work to some task context.  We'll use an IRQ thread.
++ */
++static irqreturn_t dm365evm_keys_hardirq(int irq, void *_keys)
++{
++	return IRQ_WAKE_THREAD;
++}
++
++static int dm365evm_setkeycode(struct input_dev *dev, int index, int keycode)
++{
++	u16		old_keycode;
++	unsigned	i;
++
++	if (((unsigned)index) >= ARRAY_SIZE(dm365evm_keys))
++		return -EINVAL;
++
++	old_keycode = dm365evm_keys[index].keycode;
++	dm365evm_keys[index].keycode = keycode;
++	set_bit(keycode, dev->keybit);
++
++	for (i = 0; i < ARRAY_SIZE(dm365evm_keys); i++) {
++		if (dm365evm_keys[index].keycode == old_keycode)
++			goto done;
++	}
++	clear_bit(old_keycode, dev->keybit);
++done:
++	return 0;
++}
++
++static int dm365evm_getkeycode(struct input_dev *dev, int index, int *keycode)
++{
++	if (((unsigned)index) >= ARRAY_SIZE(dm365evm_keys))
++		return -EINVAL;
++
++	return dm365evm_keys[index].keycode;
++}
++
++/*----------------------------------------------------------------------*/
++
++static int __devinit
++dm365evm_keys_probe(struct i2c_client *i2c, const struct i2c_device_id *id)
++{
++	struct dm365evm_keys	*keys;
++	struct input_dev	*input;
++	int			status;
++	int			i;
++
++	status = gpio_request(MSP430_GPIO, id->name);
++	if (status < 0)
++		return status;
++
++	status = gpio_direction_input(MSP430_GPIO);
++	if (status < 0) {
++		gpio_free(MSP430_GPIO);
++		return status;
++	}
++
++	/* allocate instance struct and input dev */
++	keys = kzalloc(sizeof *keys, GFP_KERNEL);
++	input = input_allocate_device();
++	if (!keys || !input) {
++		status = -ENOMEM;
++		goto fail1;
++	}
++
++	keys->i2c = i2c;
++	keys->input = input;
++
++	input_set_drvdata(input, keys);
++
++	input->name = "DM365 EVM Controls";
++	input->phys = "dm365evm/input0";
++	input->dev.parent = &i2c->dev;
++
++	input->id.bustype = BUS_I2C;
++	input->id.product = 0x0365;
++	input->id.version = i2c_smbus_read_byte_data(i2c,
++					DM365EVM_MSP_FIRMREV);
++
++	input->evbit[0] = BIT(EV_KEY);
++	for (i = 0; i < ARRAY_SIZE(dm365evm_keys); i++)
++		__set_bit(dm365evm_keys[i].keycode, input->keybit);
++
++	input->setkeycode = dm365evm_setkeycode;
++	input->getkeycode = dm365evm_getkeycode;
++
++	/* FIXME:  flush the event queue */
++
++	status = request_threaded_irq(gpio_to_irq(MSP430_GPIO),
++			dm365evm_keys_hardirq, dm365evm_keys_irq,
++			IRQF_TRIGGER_FALLING,
++			id->name, keys);
++	if (status < 0)
++		goto fail1;
++
++	/* register */
++	status = input_register_device(input);
++	if (status < 0)
++		goto fail2;
++
++	i2c_set_clientdata(i2c, keys);
++
++	return 0;
++
++fail2:
++	free_irq(gpio_to_irq(MSP430_GPIO), keys);
++fail1:
++	input_free_device(input);
++	kfree(keys);
++	gpio_free(MSP430_GPIO);
++	dev_err(&i2c->dev, "can't register, err %d\n", status);
++
++	return status;
++}
++
++static int __devexit dm365evm_keys_remove(struct i2c_client *i2c)
++{
++	struct dm365evm_keys	*keys = i2c_get_clientdata(i2c);
++
++	free_irq(gpio_to_irq(MSP430_GPIO), keys);
++	input_unregister_device(keys->input);
++	kfree(keys);
++
++	gpio_free(MSP430_GPIO);
++
++	return 0;
++}
++
++/* REVISIT:  add suspend/resume when DaVinci supports it.  The IRQ should
++ * be able to wake up the system.  When device_may_wakeup(&i2c->dev), call
++ * enable_irq_wake() on suspend, and disable_irq_wake() on resume.
++ */
++
++static const struct i2c_device_id ids[] = {
++	{ .name = "dm365evm_keys", },
++	{ },
++};
++MODULE_DEVICE_TABLE(i2c, ids);
++
++static struct i2c_driver dm365evm_keys_driver = {
++	.driver.name	= "dm365evm_keys",
++	.id_table	= ids,
++	.probe		= dm365evm_keys_probe,
++	.remove		= __devexit_p(dm365evm_keys_remove),
++};
++
++static int __init dm365evm_keys_init(void)
++{
++	return i2c_add_driver(&dm365evm_keys_driver);
++}
++module_init(dm365evm_keys_init);
++
++static void __exit dm365evm_keys_exit(void)
++{
++	i2c_del_driver(&dm365evm_keys_driver);
++}
++module_exit(dm365evm_keys_exit);
++
++MODULE_LICENSE("GPL");
+--- /dev/null
++++ b/arch/arm/mach-davinci/pci.h
+@@ -0,0 +1,74 @@
++/*
++ * pci.h
++ *  Description:
++ *  PCI module specific types/configurations and definitions.
++ *
++ * Copyright (C) 2009 Texas Instruments Incorporated - http://www.ti.com/
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License as
++ * published by the Free Software Foundation version 2.
++ *
++ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
++ * kind, whether express or implied; without even the implied warranty
++ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ */
++#ifndef __ARCH_PCI_H
++#define __ARCH_PCI_H
++
++#include <mach/pci.h>
++
++/*
++ * Configuration options
++ */
++
++/* Could be updated with optimum PCILGINTMIR values */
++#define CFG_PCIM_MAX_LAT		0xF
++#define CFG_PCIM_MIN_GRANT		0xF
++
++#define CFG_PCI_INTSET_MASK		((0x3 << 1) | (0x3 << 5))
++#define CFG_PCI_INTCLR_MASK		(CFG_PCI_INTSET_MASK)
++
++#define PCI_MAX_SLOTS			(21)        /* Only checked for bus=0 as
++							IDSEL can be provided
++							only within AD[31:11] */
++
++#define CFG_PCIM_WINDOW_SZ	(0x00800000)        /* Master window size */
++#define CFG_PCIM_WINDOW_CNT	(32)                /* Number of windows */
++#define CFG_PCIM_MEM_START	(PCIBIOS_MIN_MEM)   /* PCI master memory map
++							base NOTE: We are using
++							1:1 mapping, i.e.,
++							0x30000000 from DMSoC
++							side is translated as
++							0x30000000 on PCI Bus */
++#define CFG_PCIM_MEM_END	(CFG_PCIM_MEM_START                    \
++					+ (CFG_PCIM_WINDOW_SZ          \
++						* CFG_PCIM_WINDOW_CNT) \
++					- 1)	/* PCI master memory map size */
++
++
++/* The default value below can be substituted with proper timeout value which
++ * taking into account various PCI system parameters (buses, devices/slots,
++ * average latency to gain PCI bus access etc) to have sufficiant time till the
++ * master completes previous transaction.
++ */
++#define CFG_PCI_READY_WAITCNT	0xffff
++
++/*
++ * Provide the virtual address of PCI Backend register at specified offset. Uses
++ * SoC specific PCI register base for address calculation.
++ */
++#define PCI_REGV(reg)           (IO_ADDRESS(PCICTL_REG_BASE) + reg)
++
++struct pcihost_bar_cfg {
++    u32 bar_window_phys;
++    u32 bar_window_size;
++};
++
++/* Forward declarations */
++extern int __init ti_pci_setup(int nr, struct pci_sys_data *);
++extern struct  pci_bus * __init ti_pci_scan(int nr, struct pci_sys_data *);
++extern struct pcihost_bar_cfg bar_cfg[6];
++
++#endif /* !__ARCH_PCI_H */
+--- /dev/null
++++ b/drivers/media/video/davinci/dm365_ccdc_regs.h
+@@ -0,0 +1,293 @@
++#ifndef _DM365_CCDC_REGS_H
++#define _DM365_CCDC_REGS_H
++
++/* ISIF registers relative offsets */
++#define SYNCEN					0x00
++#define MODESET					0x04
++#define HDW					0x08
++#define VDW					0x0c
++#define PPLN					0x10
++#define LPFR					0x14
++#define SPH					0x18
++#define LNH					0x1c
++#define SLV0					0x20
++#define SLV1					0x24
++#define LNV					0x28
++#define CULH					0x2c
++#define CULV					0x30
++#define HSIZE					0x34
++#define SDOFST					0x38
++#define CADU					0x3c
++#define CADL					0x40
++#define LINCFG0					0x44
++#define LINCFG1					0x48
++#define CCOLP					0x4c
++#define CRGAIN 					0x50
++#define CGRGAIN					0x54
++#define CGBGAIN					0x58
++#define CBGAIN					0x5c
++#define COFSTA					0x60
++#define FLSHCFG0				0x64
++#define FLSHCFG1				0x68
++#define FLSHCFG2				0x6c
++#define VDINT0					0x70
++#define VDINT1					0x74
++#define VDINT2					0x78
++#define MISC 					0x7c
++#define CGAMMAWD				0x80
++#define REC656IF				0x84
++#define CCDCFG					0x88
++/*****************************************************
++* Defect Correction registers
++*****************************************************/
++#define DFCCTL					0x8c
++#define VDFSATLV				0x90
++#define DFCMEMCTL				0x94
++#define DFCMEM0					0x98
++#define DFCMEM1					0x9c
++#define DFCMEM2					0xa0
++#define DFCMEM3					0xa4
++#define DFCMEM4					0xa8
++/****************************************************
++* Black Clamp registers
++****************************************************/
++#define CLAMPCFG				0xac
++#define CLDCOFST				0xb0
++#define CLSV					0xb4
++#define CLHWIN0					0xb8
++#define CLHWIN1					0xbc
++#define CLHWIN2					0xc0
++#define CLVRV					0xc4
++#define CLVWIN0					0xc8
++#define CLVWIN1					0xcc
++#define CLVWIN2					0xd0
++#define CLVWIN3					0xd4
++/****************************************************
++* Lense Shading Correction
++****************************************************/
++#define DATAHOFST				0xd8
++#define DATAVOFST				0xdc
++#define LSCHVAL					0xe0
++#define LSCVVAL					0xe4
++#define TWODLSCCFG				0xe8
++#define TWODLSCOFST				0xec
++#define TWODLSCINI				0xf0
++#define TWODLSCGRBU				0xf4
++#define TWODLSCGRBL				0xf8
++#define TWODLSCGROF				0xfc
++#define TWODLSCORBU				0x100
++#define TWODLSCORBL				0x104
++#define TWODLSCOROF				0x108
++#define TWODLSCIRQEN				0x10c
++#define TWODLSCIRQST				0x110
++/****************************************************
++* Data formatter
++****************************************************/
++#define FMTCFG					0x114
++#define FMTPLEN					0x118
++#define FMTSPH					0x11c
++#define FMTLNH					0x120
++#define FMTSLV					0x124
++#define FMTLNV					0x128
++#define FMTRLEN					0x12c
++#define FMTHCNT					0x130
++#define FMTAPTR_BASE				0x134
++/* Below macro for addresses FMTAPTR0 - FMTAPTR15 */
++#define FMTAPTR(i)			(FMTAPTR_BASE + (i * 4))
++#define FMTPGMVF0				0x174
++#define FMTPGMVF1				0x178
++#define FMTPGMAPU0				0x17c
++#define FMTPGMAPU1				0x180
++#define FMTPGMAPS0				0x184
++#define FMTPGMAPS1				0x188
++#define FMTPGMAPS2				0x18c
++#define FMTPGMAPS3				0x190
++#define FMTPGMAPS4				0x194
++#define FMTPGMAPS5				0x198
++#define FMTPGMAPS6				0x19c
++#define FMTPGMAPS7				0x1a0
++/************************************************
++* Color Space Converter
++************************************************/
++#define CSCCTL					0x1a4
++#define CSCM0					0x1a8
++#define CSCM1					0x1ac
++#define CSCM2					0x1b0
++#define CSCM3					0x1b4
++#define CSCM4					0x1b8
++#define CSCM5					0x1bc
++#define CSCM6					0x1c0
++#define CSCM7					0x1c4
++#define OBWIN0					0x1c8
++#define OBWIN1					0x1cc
++#define OBWIN2					0x1d0
++#define OBWIN3					0x1d4
++#define OBVAL0					0x1d8
++#define OBVAL1					0x1dc
++#define OBVAL2					0x1e0
++#define OBVAL3					0x1e4
++#define OBVAL4					0x1e8
++#define OBVAL5					0x1ec
++#define OBVAL6					0x1f0
++#define OBVAL7					0x1f4
++#define CLKCTL					0x1f8
++
++#define CCDC_LINEAR_LUT0_ADDR			0x1C7C000
++#define CCDC_LINEAR_LUT1_ADDR			0x1C7C400
++
++/* Masks & Shifts below */
++#define START_PX_HOR_MASK			(0x7FFF)
++#define NUM_PX_HOR_MASK				(0x7FFF)
++#define START_VER_ONE_MASK			(0x7FFF)
++#define START_VER_TWO_MASK			(0x7FFF)
++#define NUM_LINES_VER				(0x7FFF)
++
++/* gain - offset masks */
++#define GAIN_INTEGER_MASK			(0x7)
++#define GAIN_INTEGER_SHIFT			(0x9)
++#define GAIN_DECIMAL_MASK			(0x1FF)
++#define OFFSET_MASK			  	(0xFFF)
++#define GAIN_SDRAM_EN_SHIFT			(12)
++#define GAIN_IPIPE_EN_SHIFT			(13)
++#define GAIN_H3A_EN_SHIFT			(14)
++#define OFST_SDRAM_EN_SHIFT			(8)
++#define OFST_IPIPE_EN_SHIFT			(9)
++#define OFST_H3A_EN_SHIFT			(10)
++#define GAIN_OFFSET_EN_MASK			(0x7700)
++
++/* Culling */
++#define CULL_PAT_EVEN_LINE_SHIFT		(8)
++
++/* CCDCFG register */
++#define CCDC_YCINSWP_RAW			(0x00 << 4)
++#define CCDC_YCINSWP_YCBCR			(0x01 << 4)
++#define CCDC_CCDCFG_FIDMD_LATCH_VSYNC		(0x00 << 6)
++#define CCDC_CCDCFG_WENLOG_AND			(0x00 << 8)
++#define CCDC_CCDCFG_TRGSEL_WEN			(0x00 << 9)
++#define CCDC_CCDCFG_EXTRG_DISABLE		(0x00 << 10)
++#define CCDC_LATCH_ON_VSYNC_DISABLE		(0x01 << 15)
++#define CCDC_LATCH_ON_VSYNC_ENABLE		(0x00 << 15)
++#define CCDC_DATA_PACK_MASK			(0x03)
++#define CCDC_DATA_PACK16			(0x0)
++#define CCDC_DATA_PACK12			(0x1)
++#define CCDC_DATA_PACK8				(0x2)
++#define CCDC_PIX_ORDER_SHIFT			(11)
++#define CCDC_PIX_ORDER_MASK			(0x01)
++#define CCDC_BW656_ENABLE			(0x01 << 5)
++
++/* MODESET registers */
++#define CCDC_VDHDOUT_INPUT			(0x00 << 0)
++#define CCDC_INPUT_MASK				(0x03)
++#define CCDC_INPUT_SHIFT			(12)
++#define CCDC_RAW_INPUT_MODE			(0x00)
++#define CCDC_FID_POL_MASK			(0x01)
++#define CCDC_FID_POL_SHIFT			(4)
++#define CCDC_HD_POL_MASK			(0x01)
++#define CCDC_HD_POL_SHIFT			(3)
++#define CCDC_VD_POL_MASK			(0x01)
++#define CCDC_VD_POL_SHIFT			(2)
++#define CCDC_DATAPOL_NORMAL			(0x00)
++#define CCDC_DATAPOL_MASK			(0x01)
++#define CCDC_DATAPOL_SHIFT			(6)
++#define CCDC_EXWEN_DISABLE 			(0x00)
++#define CCDC_EXWEN_MASK				(0x01)
++#define CCDC_EXWEN_SHIFT			(5)
++#define CCDC_FRM_FMT_MASK			(0x01)
++#define CCDC_FRM_FMT_SHIFT			(7)
++#define CCDC_DATASFT_MASK			(0x07)
++#define CCDC_DATASFT_SHIFT			(8)
++#define CCDC_LPF_SHIFT				(14)
++#define CCDC_LPF_MASK				(0x1)
++
++/* GAMMAWD registers */
++#define CCDC_ALAW_GAMA_WD_MASK			(0xF)
++#define CCDC_ALAW_GAMA_WD_SHIFT			(1)
++#define CCDC_ALAW_ENABLE			(0x01)
++#define CCDC_GAMMAWD_CFA_MASK			(0x01)
++#define CCDC_GAMMAWD_CFA_SHIFT			(5)
++
++/* HSIZE registers */
++#define CCDC_HSIZE_FLIP_MASK			(0x01)
++#define CCDC_HSIZE_FLIP_SHIFT			(12)
++#define CCDC_LINEOFST_MASK			(0xFFF)
++
++/* MISC registers */
++#define CCDC_DPCM_EN_SHIFT			(12)
++#define CCDC_DPCM_EN_MASK			(1)
++#define CCDC_DPCM_PREDICTOR_SHIFT		(13)
++#define CCDC_DPCM_PREDICTOR_MASK 		(1)
++
++/* Black clamp related */
++#define CCDC_BC_DCOFFSET_MASK			(0x1FFF)
++#define CCDC_BC_MODE_COLOR_MASK			(1)
++#define CCDC_BC_MODE_COLOR_SHIFT		(4)
++#define CCDC_HORZ_BC_MODE_MASK			(3)
++#define CCDC_HORZ_BC_MODE_SHIFT			(1)
++#define CCDC_HORZ_BC_WIN_COUNT_MASK		(0x1F)
++#define CCDC_HORZ_BC_WIN_SEL_SHIFT		(5)
++#define CCDC_HORZ_BC_PIX_LIMIT_SHIFT		(6)
++#define CCDC_HORZ_BC_WIN_H_SIZE_MASK		(3)
++#define CCDC_HORZ_BC_WIN_H_SIZE_SHIFT		(8)
++#define CCDC_HORZ_BC_WIN_V_SIZE_MASK		(3)
++#define CCDC_HORZ_BC_WIN_V_SIZE_SHIFT		(12)
++#define CCDC_HORZ_BC_WIN_START_H_MASK		(0x1FFF)
++#define CCDC_HORZ_BC_WIN_START_V_MASK		(0x1FFF)
++#define CCDC_VERT_BC_OB_H_SZ_MASK		(7)
++#define CCDC_VERT_BC_RST_VAL_SEL_MASK		(3)
++#define	CCDC_VERT_BC_RST_VAL_SEL_SHIFT		(4)
++#define CCDC_VERT_BC_LINE_AVE_COEF_SHIFT	(8)
++#define	CCDC_VERT_BC_OB_START_HORZ_MASK		(0x1FFF)
++#define CCDC_VERT_BC_OB_START_VERT_MASK		(0x1FFF)
++#define CCDC_VERT_BC_OB_VERT_SZ_MASK		(0x1FFF)
++#define CCDC_VERT_BC_RST_VAL_MASK		(0xFFF)
++#define CCDC_BC_VERT_START_SUB_V_MASK		(0x1FFF)
++
++/* VDFC registers */
++#define CCDC_VDFC_EN_SHIFT			(4)
++#define CCDC_VDFC_CORR_MOD_MASK			(3)
++#define CCDC_VDFC_CORR_MOD_SHIFT		(5)
++#define CCDC_VDFC_CORR_WHOLE_LN_SHIFT		(7)
++#define CCDC_VDFC_LEVEL_SHFT_MASK		(7)
++#define CCDC_VDFC_LEVEL_SHFT_SHIFT		(8)
++#define CCDC_VDFC_SAT_LEVEL_MASK		(0xFFF)
++#define CCDC_VDFC_POS_MASK			(0x1FFF)
++#define CCDC_DFCMEMCTL_DFCMARST_SHIFT		(2)
++
++/* CSC registers */
++#define CCDC_CSC_COEF_INTEG_MASK		(7)
++#define CCDC_CSC_COEF_DECIMAL_MASK		(0x1f)
++#define CCDC_CSC_COEF_INTEG_SHIFT		(5)
++#define CCDC_CSCM_MSB_SHIFT			(8)
++#define CCDC_DF_CSC_SPH_MASK			(0x1FFF)
++#define CCDC_DF_CSC_LNH_MASK			(0x1FFF)
++#define CCDC_DF_CSC_SLV_MASK			(0x1FFF)
++#define CCDC_DF_CSC_LNV_MASK			(0x1FFF)
++#define CCDC_DF_NUMLINES			(0x7FFF)
++#define CCDC_DF_NUMPIX				(0x1FFF)
++
++/* Offsets for LSC/DFC/Gain */
++#define CCDC_DATA_H_OFFSET_MASK			(0x1FFF)
++#define CCDC_DATA_V_OFFSET_MASK			(0x1FFF)
++
++/* Linearization */
++#define CCDC_LIN_CORRSFT_MASK			(7)
++#define CCDC_LIN_CORRSFT_SHIFT			(4)
++#define CCDC_LIN_SCALE_FACT_INTEG_SHIFT		(10)
++#define CCDC_LIN_SCALE_FACT_DECIMAL_MASK	(0x3FF)
++#define CCDC_LIN_ENTRY_MASK			(0x3FF)
++
++#define CCDC_DF_FMTRLEN_MASK			(0x1FFF)
++#define CCDC_DF_FMTHCNT_MASK			(0x1FFF)
++
++/* Pattern registers */
++#define CCDC_PG_EN				(1 << 3)
++#define CCDC_SEL_PG_SRC				(3 << 4)
++#define CCDC_PG_VD_POL_SHIFT			(0)
++#define CCDC_PG_HD_POL_SHIFT			(1)
++
++/*random other junk*/
++#define CCDC_SYNCEN_VDHDEN_MASK			(1 << 0)
++#define CCDC_SYNCEN_WEN_MASK			(1 << 1)
++#define CCDC_SYNCEN_WEN_SHIFT			1
++
++#endif
+--- /dev/null
++++ b/drivers/media/video/davinci/dm365_a3_hw.c
+@@ -0,0 +1,416 @@
++/* *
++ * Copyright (C) 2009 Texas Instruments Inc
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
++ */
++#include <media/davinci/dm365_af.h>
++#include <media/davinci/dm365_aew.h>
++#include <media/davinci/dm365_a3_hw.h>
++
++/* 3A hardware module configuration */
++struct a3_config {
++	/* lock for write protection */
++	struct mutex lock;
++	/* base address */
++	void __iomem *base;
++};
++
++/* H3A module configuration */
++static struct a3_config a3_cfg;
++
++/* register access routines */
++static inline u32 regr(unsigned int offset)
++{
++	return __raw_readl(a3_cfg.base + offset);
++}
++
++static inline u32 regw(u32 val, unsigned int offset)
++{
++	__raw_writel(val, (a3_cfg.base + offset));
++	return val;
++}
++
++/* Function to set register */
++int af_register_setup(struct device *dev, struct af_device *af_dev)
++{
++	unsigned int utemp = 0;
++	unsigned int address = 0;
++	int index;
++
++	/* Lock resource since this register is written by
++	 * both the AF and AEW drivers
++	 */
++	mutex_lock(&a3_cfg.lock);
++	/* Configure Hardware Registers */
++	/* Set PCR Register */
++	utemp = regr(AFPCR);	/* Read PCR Register */
++
++	/*Set Accumulator Mode */
++	utemp &= ~FVMODE;
++	if (af_dev->config->mode == ACCUMULATOR_PEAK)
++		utemp |= FVMODE;
++	/* Set A-law */
++	utemp &= ~AF_ALAW_EN;
++	if (af_dev->config->alaw_enable == H3A_AF_ENABLE)
++		utemp |= AF_ALAW_EN;
++
++	/* Set HFV only or HFV and VFV */
++	utemp &= ~AF_VF_EN;
++	if (af_dev->config->fv_sel == AF_HFV_AND_VFV)
++		utemp |= AF_VF_EN;
++	/* Set RGB Position */
++	utemp &= ~RGBPOS;
++	utemp |= (af_dev->config->rgb_pos) << AF_RGBPOS_SHIFT;
++
++	utemp &= ~AF_MED_EN;
++	/*HMF Configurations */
++	if (af_dev->config->hmf_config.enable == H3A_AF_ENABLE) {
++		/* Enable HMF */
++		utemp |= AF_MED_EN;
++
++		/* Set Median Threshold */
++		utemp &= ~MED_TH;
++		utemp |=
++		    (((af_dev->config->hmf_config.threshold)
++			<< AF_MED_TH_SHIFT) & MED_TH);
++	}
++	/* Set PCR Register */
++	regw(utemp , AFPCR);
++	mutex_unlock(&a3_cfg.lock);
++
++	/* Configure AFPAX1 */
++	/*Paxel parameter configuration */
++	/*Set Width in AFPAX1 Register */
++	utemp = (SET_VAL(af_dev->config->paxel_config.width)) <<
++		AF_PAXW_SHIFT;
++
++	/* Set height in AFPAX1 */
++	utemp &= ~PAXH;
++	utemp |= (SET_VAL(af_dev->config->paxel_config.height));
++
++	regw(utemp , AFPAX1);
++
++	/* Configure AFPAX2 Register */
++	/* Set Column Increment in AFPAX2 Register */
++	utemp = 0;
++	utemp &= ~AFINCH;
++	utemp |=
++	    (SET_VAL(af_dev->config->paxel_config.column_incr)) <<
++	    AF_COLUMN_INCR_SHIFT;
++
++	/* Set Line Increment in AFPAX2 Register */
++	utemp &= ~AFINCV;
++	utemp |=
++	    (SET_VAL(af_dev->config->paxel_config.line_incr)) <<
++	    AF_LINE_INCR_SHIFT;
++
++	/* Set Vertical Count */
++	utemp &= ~PAXVC;
++	utemp |= (af_dev->config->paxel_config.vt_cnt - 1) << AF_VT_COUNT_SHIFT;
++	/* Set Horizontal Count */
++	utemp &= ~PAXHC;
++	utemp |= (af_dev->config->paxel_config.hz_cnt - 1);
++	regw(utemp, AFPAX2);
++
++	/* Configure PAXSTART Register */
++	/*Configure Horizontal Start */
++	utemp = 0;
++	utemp &= ~PAXSH;
++	utemp |=
++	    (af_dev->config->paxel_config.hz_start) << AF_HZ_START_SHIFT;
++	/* Configure Vertical Start */
++	utemp &= ~PAXSV;
++	utemp |= af_dev->config->paxel_config.vt_start;
++	regw(utemp , AFPAXSTART);
++
++	/*SetIIRSH Register */
++	regw(af_dev->config->iir_config.hz_start_pos, AFIIRSH);
++
++	/* Set IIR Filter0 Coefficients */
++	address = AFCOEF010;
++	for (index = 0; index < AF_NUMBER_OF_HFV_COEF; index += 2) {
++		utemp = af_dev->config->iir_config.coeff_set0[index] &
++			COEF_MASK0;
++		if (index < AF_NUMBER_OF_HFV_COEF-1) {
++			utemp |=
++			(((af_dev->config->iir_config.coeff_set0[index + 1]) <<
++			AF_COEF_SHIFT) & COEF_MASK1);
++		}
++		regw(utemp, address);
++		dev_dbg(dev, "\n COEF0 %x", regr(address));
++		address = address + AF_OFFSET;
++	}
++
++	/* Set IIR Filter1 Coefficients */
++	address = AFCOEF110;
++	for (index = 0; index < AF_NUMBER_OF_HFV_COEF; index += 2) {
++		utemp = af_dev->config->iir_config.coeff_set1[index] &
++			COEF_MASK0;
++		if (index < AF_NUMBER_OF_HFV_COEF-1) {
++			utemp |=
++			(((af_dev->config->iir_config.coeff_set1[index + 1]) <<
++			AF_COEF_SHIFT) & COEF_MASK1);
++		}
++		regw(utemp, address);
++		dev_dbg(dev, "\n COEF0 %x", regr(address));
++		address = address + AF_OFFSET;
++	}
++
++	/* HFV thresholds for FIR 1 & 2 */
++	utemp = af_dev->config->fir_config.hfv_thr1 & HFV_THR0_MASK;
++	utemp |= ((af_dev->config->fir_config.hfv_thr2 << HFV_THR2_SHIFT) &
++			HFV_THR2_MASK);
++	regw(utemp, AF_HFV_THR);
++
++	/* VFV coefficients and thresholds */
++	utemp = af_dev->config->fir_config.coeff_1[0] & VFV_COEF_MASK0;
++	utemp |= ((af_dev->config->fir_config.coeff_1[1] << 8) &
++			VFV_COEF_MASK1);
++	utemp |= ((af_dev->config->fir_config.coeff_1[2] << 16) &
++			VFV_COEF_MASK2);
++	utemp |= ((af_dev->config->fir_config.coeff_1[3] << 24) &
++			VFV_COEF_MASK3);
++	regw(utemp, AF_VFV_CFG1);
++
++	utemp = af_dev->config->fir_config.coeff_1[4] & VFV_COEF_MASK0;
++	utemp |= ((af_dev->config->fir_config.vfv_thr1 << VFV_THR_SHIFT) &
++			VFV_THR_MASK);
++	regw(utemp, AF_VFV_CFG2);
++
++	/* VFV coefficients and thresholds */
++	utemp = af_dev->config->fir_config.coeff_2[0] & VFV_COEF_MASK0;
++	utemp |= ((af_dev->config->fir_config.coeff_2[1] << 8) &
++			VFV_COEF_MASK1);
++	utemp |= ((af_dev->config->fir_config.coeff_2[2] << 16) &
++			VFV_COEF_MASK2);
++	utemp |= ((af_dev->config->fir_config.coeff_2[3] << 24) &
++			VFV_COEF_MASK3);
++	regw(utemp, AF_VFV_CFG3);
++
++	utemp = af_dev->config->fir_config.coeff_2[4] & VFV_COEF_MASK0;
++	utemp |= ((af_dev->config->fir_config.vfv_thr2 << VFV_THR_SHIFT) &
++			VFV_THR_MASK);
++	regw(utemp, AF_VFV_CFG4);
++	/* Set AFBUFST to Current buffer Physical Address */
++	regw((unsigned int)(virt_to_phys(af_dev->buff_curr)), AFBUFST);
++
++	return 0;
++}
++EXPORT_SYMBOL(af_register_setup);
++
++inline u32 af_get_hw_state(void)
++{
++	return (regr(AFPCR) & AF_BUSYAF) >> AF_BUSYAF_SHIFT;
++}
++EXPORT_SYMBOL(af_get_hw_state);
++
++inline u32 aew_get_hw_state(void)
++{
++	return (regr(AEWPCR) & AEW_BUSYAEWB) >> AEW_BUSYAEW_SHIFT;
++}
++EXPORT_SYMBOL(aew_get_hw_state);
++
++inline u32 af_get_enable(void)
++{
++	return regr(AFPCR) & AF_EN;
++}
++EXPORT_SYMBOL(af_get_enable);
++
++inline u32 aew_get_enable(void)
++{
++	return (regr(AEWPCR) & AEW_EN) >> AEW_EN_SHIFT;
++}
++EXPORT_SYMBOL(aew_get_enable);
++
++/* Function to Enable/Disable AF Engine */
++inline void af_engine_setup(struct device *dev, int enable)
++{
++	unsigned int pcr;
++
++	mutex_lock(&a3_cfg.lock);
++	pcr = regr(AFPCR);
++	dev_dbg(dev, "\nEngine Setup value before PCR : %x", pcr);
++
++	/* Set AF_EN bit in PCR Register */
++	if (enable)
++		pcr |= AF_EN;
++	else
++		pcr &= ~AF_EN;
++
++	regw(pcr, AFPCR);
++	mutex_unlock(&a3_cfg.lock);
++
++	dev_dbg(dev, "\n Engine Setup value after PCR : %x", pcr);
++}
++EXPORT_SYMBOL(af_engine_setup);
++
++/* Function to set address */
++inline void af_set_address(struct device *dev, unsigned long address)
++{
++	regw((address & ~0x3F), AFBUFST);
++}
++EXPORT_SYMBOL(af_set_address);
++
++/* Function to set hardware configuration registers */
++int aew_register_setup(struct device *dev, struct aew_device *aew_dev)
++{
++	unsigned utemp;
++
++	mutex_lock(&a3_cfg.lock);
++	/* Set up the registers */
++	utemp = regr(AEWPCR);
++
++	/* Enable A Law */
++	if (aew_dev->config->alaw_enable == H3A_AEW_ENABLE)
++		utemp |= AEW_ALAW_EN;
++	else
++		utemp &= ~AEW_ALAW_EN;
++
++	utemp &= ~AEW_MED_EN;
++	/*HMF Configurations */
++	if (aew_dev->config->hmf_config.enable == H3A_AEW_ENABLE) {
++		/* Enable HMF */
++		utemp |= AEW_MED_EN;
++		/* Set Median Threshold */
++		utemp &= ~MED_TH;
++		utemp |=
++		    (((aew_dev->config->hmf_config.threshold) <<
++			AF_MED_TH_SHIFT) & MED_TH);
++	}
++
++	/*Configure Saturation limit */
++	utemp &= ~AVE2LMT;
++	utemp |= aew_dev->config->saturation_limit << AEW_AVE2LMT_SHIFT;
++	regw(utemp, AEWPCR);
++	mutex_unlock(&a3_cfg.lock);
++
++	/*Window parameter configuration */
++	/* Configure Window Width in AEWWIN1 register */
++	utemp =
++	    ((SET_VAL(aew_dev->config->window_config.height)) <<
++	     AEW_WINH_SHIFT);
++
++	/* Configure Window height  in AEWWIN1 register */
++	utemp |=
++	    ((SET_VAL(aew_dev->config->window_config.width)) <<
++	     AEW_WINW_SHIFT);
++
++	/* Configure Window vertical count  in AEWWIN2 register */
++	utemp |=
++	    ((aew_dev->config->window_config).vt_cnt - 1) << AEW_VT_COUNT_SHIFT;
++
++	/* Configure Window horizontal count  in AEWWIN1 register */
++	utemp |= ((aew_dev->config->window_config).hz_cnt - 1);
++
++	/* Configure Window vertical start  in AEWWIN1 register */
++	regw(utemp, AEWWIN1);
++
++	/*Window Start parameter configuration */
++
++	utemp =
++	    (aew_dev->config->window_config).vt_start << AEW_VT_START_SHIFT;
++
++	/* Configure Window horizontal start  in AEWWIN2 register */
++	utemp &= ~WINSH;
++	utemp |= (aew_dev->config->window_config).hz_start;
++	regw(utemp, AEWINSTART);
++
++	/*Window Line Increment configuration */
++	/*Configure vertical line increment in AEWSUBWIN */
++	utemp =
++	    (SET_VAL(aew_dev->config->window_config.
++			 vt_line_incr) << AEW_LINE_INCR_SHIFT);
++
++	/* Configuring Horizontal Line increment in AEWSUBWIN */
++	utemp &= ~AEWINCH;
++	utemp |= (SET_VAL(aew_dev->config->window_config.hz_line_incr));
++
++	regw(utemp, AEWSUBWIN);
++
++	/* Black Window Configuration */
++	/* Configure vertical start and height in AEWWINBLK */
++	utemp =
++	    (aew_dev->config->blackwindow_config).
++	    vt_start << AEW_BLKWIN_VT_START_SHIFT;
++
++	/* Configure height in Black window */
++	utemp &= ~BLKWINH;
++	utemp |= (SET_VAL(aew_dev->config->blackwindow_config.height));
++	regw(utemp, AEWINBLK);
++
++	/* AE/AWB engine configuration */
++	utemp = aew_dev->config->sum_shift & AEW_SUMSHFT_MASK;
++	utemp |= (((aew_dev->config->out_format) << AEFMT_SHFT) & AEFMT_MASK);
++	regw(utemp, AEW_CFG);
++
++	/* Set AFBUFST to Current buffer Physical Address */
++	regw((unsigned int)(virt_to_phys(aew_dev->buff_curr)), AEWBUFST);
++
++	return 0;
++}
++EXPORT_SYMBOL(aew_register_setup);
++
++/* Function to enable/ disable AEW Engine */
++inline void aew_engine_setup(struct device *dev, int value)
++{
++	unsigned int pcr;
++
++	dev_dbg(dev, "\nAEW_REG(PCR) Before Setting %x", regr(AEWPCR));
++
++	mutex_lock(&a3_cfg.lock);
++	/* Read Pcr Register */
++	pcr = regr(AEWPCR);
++	pcr &= ~AEW_EN;
++	pcr |= (value << AEW_EN_SHIFT);
++
++	/*Set AF_EN bit in PCR Register */
++	regw(pcr, AEWPCR);
++	mutex_unlock(&a3_cfg.lock);
++
++	dev_dbg(dev, "\nAfter Setting %d : PCR VALUE %x", value,
++		regr(AEWPCR));
++
++}
++EXPORT_SYMBOL(aew_engine_setup);
++
++/* Function used to set adddress */
++inline void aew_set_address(struct device *dev, unsigned long address)
++{
++	regw((address & ~0x3F), AEWBUFST);
++}
++EXPORT_SYMBOL(aew_set_address);
++
++static int  dm365_afew_hw_init(void)
++{
++	printk(KERN_NOTICE "dm365_afew_hw_init\n");
++	mutex_init(&a3_cfg.lock);
++	a3_cfg.base = ioremap(DM365_A3_HW_ADDR, DM365_A3_HW_ADDR_SIZE);
++	if (!a3_cfg.base) {
++		printk(KERN_ERR "Unable to ioremap 3A registers\n");
++		return -EINVAL;
++	}
++	regw(0, LINE_START);
++	return 0;
++}
++
++static void dm365_afew_hw_exit(void)
++{
++	printk(KERN_NOTICE "dm365_afew_hw_exit\n");
++	iounmap(a3_cfg.base);
++}
++subsys_initcall(dm365_afew_hw_init);
++module_exit(dm365_afew_hw_exit);
++MODULE_LICENSE("GPL");
++
+--- a/arch/arm/mach-davinci/dma.c
++++ b/arch/arm/mach-davinci/dma.c
+@@ -215,6 +215,18 @@ static inline void edma_parm_or(unsigned
+ 	edma_or(ctlr, EDMA_PARM + offset + (param_no << 5), or);
+ }
+ 
++static inline void set_bits(int offset, int len, unsigned long *p)
++{
++	for (; len > 0; len--)
++		set_bit(offset + (len - 1), p);
++}
++
++static inline void clear_bits(int offset, int len, unsigned long *p)
++{
++	for (; len > 0; len--)
++		clear_bit(offset + (len -1), p);
++}
++
+ /*****************************************************************************/
+ 
+ /* actual number of DMA channels and slots on this silicon */
+@@ -235,11 +247,11 @@ struct edma {
+ 	 */
+ 	DECLARE_BITMAP(edma_inuse, EDMA_MAX_PARAMENTRY);
+ 
+-	/* The edma_noevent bit for each channel is clear unless
+-	 * it doesn't trigger DMA events on this platform.  It uses a
+-	 * bit of SOC-specific initialization code.
++	/* The edma_unused bit for each channel is clear unless
++	 * it is not being used on this platform. It uses a bit
++	 * of SOC-specific initialization code.
+ 	 */
+-	DECLARE_BITMAP(edma_noevent, EDMA_MAX_DMACH);
++	DECLARE_BITMAP(edma_unused, EDMA_MAX_DMACH);
+ 
+ 	unsigned	irq_res_start;
+ 	unsigned	irq_res_end;
+@@ -252,6 +264,7 @@ struct edma {
+ };
+ 
+ static struct edma *edma_info[EDMA_MAX_CC];
++static char arch_num_cc;
+ 
+ /* dummy param set used to (re)initialize parameter RAM slots */
+ static const struct edmacc_param dummy_paramset = {
+@@ -509,47 +522,82 @@ static irqreturn_t dma_tc1err_handler(in
+ 	return IRQ_HANDLED;
+ }
+ 
+-static int reserve_contiguous_params(int ctlr, unsigned int id,
+-				     unsigned int num_params,
+-				     unsigned int start_param)
++static int reserve_contiguous_slots(int ctlr, unsigned int id,
++				     unsigned int num_slots,
++				     unsigned int start_slot)
+ {
+ 	int i, j;
+-	unsigned int count = num_params;
++	unsigned int count = num_slots;
++	int stop_slot = start_slot;
++	DECLARE_BITMAP(tmp_inuse, EDMA_MAX_PARAMENTRY);
+ 
+-	for (i = start_param; i < edma_info[ctlr]->num_slots; ++i) {
++	for (i = start_slot; i < edma_info[ctlr]->num_slots; ++i) {
+ 		j = EDMA_CHAN_SLOT(i);
+-		if (!test_and_set_bit(j, edma_info[ctlr]->edma_inuse))
++		if (!test_and_set_bit(j, edma_info[ctlr]->edma_inuse)) {
++			/* Record our current beginning slot */
++			if (count == num_slots)
++				stop_slot = i;
++
+ 			count--;
++			set_bit(j, tmp_inuse);
++
+ 			if (count == 0)
+ 				break;
+-		else if (id == EDMA_CONT_PARAMS_FIXED_EXACT)
+-			break;
+-		else
+-			count = num_params;
++		} else {
++			clear_bit(j, tmp_inuse);
++
++			if (id == EDMA_CONT_PARAMS_FIXED_EXACT) {
++				stop_slot = i;
++				break;
++			} else
++				count = num_slots;
++		}
+ 	}
+ 
+ 	/*
+ 	 * We have to clear any bits that we set
+-	 * if we run out parameter RAMs, i.e we do find a set
+-	 * of contiguous parameter RAMs but do not find the exact number
+-	 * requested as we may reach the total number of parameter RAMs
++	 * if we run out parameter RAM slots, i.e we do find a set
++	 * of contiguous parameter RAM slots but do not find the exact number
++	 * requested as we may reach the total number of parameter RAM slots
+ 	 */
+-	if (count) {
+-		for (j = i - num_params + count + 1; j <= i ; ++j)
++	if (i == edma_info[ctlr]->num_slots)
++		stop_slot = i;
++
++	for (j = start_slot; j < stop_slot; j++)
++		if (test_bit(j, tmp_inuse))
+ 			clear_bit(j, edma_info[ctlr]->edma_inuse);
+ 
++	if (count)
+ 		return -EBUSY;
+-	}
+ 
+-	for (j = i - num_params + 1; j <= i; ++j)
++	for (j = i - num_slots + 1; j <= i; ++j)
+ 		memcpy_toio(edmacc_regs_base[ctlr] + PARM_OFFSET(j),
+ 			&dummy_paramset, PARM_SIZE);
+ 
+-	return EDMA_CTLR_CHAN(ctlr, i - num_params + 1);
++	return EDMA_CTLR_CHAN(ctlr, i - num_slots + 1);
++}
++
++static int prepare_unused_channel_list(struct device *dev, void *data)
++{
++	struct platform_device *pdev = to_platform_device(dev);
++	int i, ctlr;
++
++	for (i = 0; i < pdev->num_resources; i++) {
++		if ((pdev->resource[i].flags & IORESOURCE_DMA) &&
++				(int)pdev->resource[i].start >= 0) {
++			ctlr = EDMA_CTLR(pdev->resource[i].start);
++			clear_bit(EDMA_CHAN_SLOT(pdev->resource[i].start),
++					edma_info[ctlr]->edma_unused);
++		}
++	}
++
++	return 0;
+ }
+ 
+ /*-----------------------------------------------------------------------*/
+ 
++static bool unused_chan_list_done;
++
+ /* Resource alloc/free:  dma channels, parameter RAM slots */
+ 
+ /**
+@@ -587,7 +635,22 @@ int edma_alloc_channel(int channel,
+ 		void *data,
+ 		enum dma_event_q eventq_no)
+ {
+-	unsigned i, done, ctlr = 0;
++	unsigned i, done = 0, ctlr = 0;
++	int ret = 0;
++
++	if (!unused_chan_list_done) {
++		/*
++		 * Scan all the platform devices to find out the EDMA channels
++		 * used and clear them in the unused list, making the rest
++		 * available for ARM usage.
++		 */
++		ret = bus_for_each_dev(&platform_bus_type, NULL, NULL,
++				prepare_unused_channel_list);
++		if (ret < 0)
++			return ret;
++
++		unused_chan_list_done = true;
++	}
+ 
+ 	if (channel >= 0) {
+ 		ctlr = EDMA_CTLR(channel);
+@@ -595,15 +658,15 @@ int edma_alloc_channel(int channel,
+ 	}
+ 
+ 	if (channel < 0) {
+-		for (i = 0; i < EDMA_MAX_CC; i++) {
++		for (i = 0; i < arch_num_cc; i++) {
+ 			channel = 0;
+ 			for (;;) {
+ 				channel = find_next_bit(edma_info[i]->
+-						edma_noevent,
++						edma_unused,
+ 						edma_info[i]->num_channels,
+ 						channel);
+ 				if (channel == edma_info[i]->num_channels)
+-					return -ENOMEM;
++					break;
+ 				if (!test_and_set_bit(channel,
+ 						edma_info[i]->edma_inuse)) {
+ 					done = 1;
+@@ -615,6 +678,8 @@ int edma_alloc_channel(int channel,
+ 			if (done)
+ 				break;
+ 		}
++		if (!done)
++			return -ENOMEM;
+ 	} else if (channel >= edma_info[ctlr]->num_channels) {
+ 		return -EINVAL;
+ 	} else if (test_and_set_bit(channel, edma_info[ctlr]->edma_inuse)) {
+@@ -635,7 +700,7 @@ int edma_alloc_channel(int channel,
+ 
+ 	map_dmach_queue(ctlr, channel, eventq_no);
+ 
+-	return channel;
++	return EDMA_CTLR_CHAN(ctlr, channel);
+ }
+ EXPORT_SYMBOL(edma_alloc_channel);
+ 
+@@ -743,26 +808,27 @@ EXPORT_SYMBOL(edma_free_slot);
+ /**
+  * edma_alloc_cont_slots- alloc contiguous parameter RAM slots
+  * The API will return the starting point of a set of
+- * contiguous PARAM's that have been requested
++ * contiguous parameter RAM slots that have been requested
+  *
+  * @id: can only be EDMA_CONT_PARAMS_ANY or EDMA_CONT_PARAMS_FIXED_EXACT
+  * or EDMA_CONT_PARAMS_FIXED_NOT_EXACT
+- * @count: number of contiguous Paramter RAM's
+- * @param  - the start value of Parameter RAM that should be passed if id
++ * @count: number of contiguous Paramter RAM slots
++ * @slot  - the start value of Parameter RAM slot that should be passed if id
+  * is EDMA_CONT_PARAMS_FIXED_EXACT or EDMA_CONT_PARAMS_FIXED_NOT_EXACT
+  *
+  * If id is EDMA_CONT_PARAMS_ANY then the API starts looking for a set of
+- * contiguous Parameter RAMs from parameter RAM 64 in the case of DaVinci SOCs
+- * and 32 in the case of Primus
++ * contiguous Parameter RAM slots from parameter RAM 64 in the case of
++ * DaVinci SOCs and 32 in the case of DA8xx SOCs.
+  *
+  * If id is EDMA_CONT_PARAMS_FIXED_EXACT then the API starts looking for a
+- * set of contiguous parameter RAMs from the "param" that is passed as an
++ * set of contiguous parameter RAM slots from the "slot" that is passed as an
+  * argument to the API.
+  *
+  * If id is EDMA_CONT_PARAMS_FIXED_NOT_EXACT then the API initially tries
+- * starts looking for a set of contiguous parameter RAMs from the "param"
++ * starts looking for a set of contiguous parameter RAMs from the "slot"
+  * that is passed as an argument to the API. On failure the API will try to
+- * find a set of contiguous Parameter RAMs in the remaining Parameter RAMs
++ * find a set of contiguous Parameter RAM slots from the remaining Parameter
++ * RAM slots
+  */
+ int edma_alloc_cont_slots(unsigned ctlr, unsigned int id, int slot, int count)
+ {
+@@ -771,12 +837,13 @@ int edma_alloc_cont_slots(unsigned ctlr,
+ 	 * the number of channels and lesser than the total number
+ 	 * of slots
+ 	 */
+-	if (slot < edma_info[ctlr]->num_channels ||
+-		slot >= edma_info[ctlr]->num_slots)
++	if ((id != EDMA_CONT_PARAMS_ANY) &&
++		(slot < edma_info[ctlr]->num_channels ||
++		slot >= edma_info[ctlr]->num_slots))
+ 		return -EINVAL;
+ 
+ 	/*
+-	 * The number of parameter RAMs requested cannot be less than 1
++	 * The number of parameter RAM slots requested cannot be less than 1
+ 	 * and cannot be more than the number of slots minus the number of
+ 	 * channels
+ 	 */
+@@ -786,11 +853,11 @@ int edma_alloc_cont_slots(unsigned ctlr,
+ 
+ 	switch (id) {
+ 	case EDMA_CONT_PARAMS_ANY:
+-		return reserve_contiguous_params(ctlr, id, count,
++		return reserve_contiguous_slots(ctlr, id, count,
+ 						 edma_info[ctlr]->num_channels);
+ 	case EDMA_CONT_PARAMS_FIXED_EXACT:
+ 	case EDMA_CONT_PARAMS_FIXED_NOT_EXACT:
+-		return reserve_contiguous_params(ctlr, id, count, slot);
++		return reserve_contiguous_slots(ctlr, id, count, slot);
+ 	default:
+ 		return -EINVAL;
+ 	}
+@@ -799,21 +866,21 @@ int edma_alloc_cont_slots(unsigned ctlr,
+ EXPORT_SYMBOL(edma_alloc_cont_slots);
+ 
+ /**
+- * edma_free_cont_slots - deallocate DMA parameter RAMs
+- * @slot: first parameter RAM of a set of parameter RAMs to be freed
+- * @count: the number of contiguous parameter RAMs to be freed
++ * edma_free_cont_slots - deallocate DMA parameter RAM slots
++ * @slot: first parameter RAM of a set of parameter RAM slots to be freed
++ * @count: the number of contiguous parameter RAM slots to be freed
+  *
+  * This deallocates the parameter RAM slots allocated by
+  * edma_alloc_cont_slots.
+  * Callers/applications need to keep track of sets of contiguous
+- * parameter RAMs that have been allocated using the edma_alloc_cont_slots
++ * parameter RAM slots that have been allocated using the edma_alloc_cont_slots
+  * API.
+  * Callers are responsible for ensuring the slots are inactive, and will
+  * not be activated.
+  */
+ int edma_free_cont_slots(unsigned slot, int count)
+ {
+-	unsigned ctlr;
++	unsigned ctlr, slot_to_free;
+ 	int i;
+ 
+ 	ctlr = EDMA_CTLR(slot);
+@@ -826,11 +893,11 @@ int edma_free_cont_slots(unsigned slot,
+ 
+ 	for (i = slot; i < slot + count; ++i) {
+ 		ctlr = EDMA_CTLR(i);
+-		slot = EDMA_CHAN_SLOT(i);
++		slot_to_free = EDMA_CHAN_SLOT(i);
+ 
+-		memcpy_toio(edmacc_regs_base[ctlr] + PARM_OFFSET(slot),
++		memcpy_toio(edmacc_regs_base[ctlr] + PARM_OFFSET(slot_to_free),
+ 			&dummy_paramset, PARM_SIZE);
+-		clear_bit(slot, edma_info[ctlr]->edma_inuse);
++		clear_bit(slot_to_free, edma_info[ctlr]->edma_inuse);
+ 	}
+ 
+ 	return 0;
+@@ -1210,7 +1277,7 @@ int edma_start(unsigned channel)
+ 		unsigned int mask = (1 << (channel & 0x1f));
+ 
+ 		/* EDMA channels without event association */
+-		if (test_bit(channel, edma_info[ctlr]->edma_noevent)) {
++		if (test_bit(channel, edma_info[ctlr]->edma_unused)) {
+ 			pr_debug("EDMA: ESR%d %08x\n", j,
+ 				edma_shadow0_read_array(ctlr, SH_ESR, j));
+ 			edma_shadow0_write_array(ctlr, SH_ESR, j, mask);
+@@ -1333,9 +1400,10 @@ static int __init edma_probe(struct plat
+ 	struct edma_soc_info	*info = pdev->dev.platform_data;
+ 	const s8		(*queue_priority_mapping)[2];
+ 	const s8		(*queue_tc_mapping)[2];
+-	int			i, j, found = 0;
++	int			i, j, off, ln, found = 0;
+ 	int			status = -1;
+-	const s8		*noevent;
++	const s8		(*rsv_chans)[2];
++	const s16		(*rsv_slots)[2];
+ 	int			irq[EDMA_MAX_CC] = {0, 0};
+ 	int			err_irq[EDMA_MAX_CC] = {0, 0};
+ 	struct resource		*r[EDMA_MAX_CC] = {NULL};
+@@ -1398,10 +1466,28 @@ static int __init edma_probe(struct plat
+ 			memcpy_toio(edmacc_regs_base[j] + PARM_OFFSET(i),
+ 					&dummy_paramset, PARM_SIZE);
+ 
+-		noevent = info[j].noevent;
+-		if (noevent) {
+-			while (*noevent != -1)
+-				set_bit(*noevent++, edma_info[j]->edma_noevent);
++		/* Mark all channels as unused */
++		memset(edma_info[j]->edma_unused, 0xff,
++			sizeof(edma_info[j]->edma_unused));
++
++		/* Clear the reserved channels in unused list */
++		rsv_chans = info[j].rsv_chans;
++		if (rsv_chans) {
++			for (i = 0; rsv_chans[i][0] != -1; i++) {
++				off = rsv_chans[i][0];
++				ln = rsv_chans[i][1];
++				clear_bits(off, ln, edma_info[j]->edma_unused);
++			}
++		}
++
++		/* Set the reserved channels/slots in inuse list */
++		rsv_slots = info[j].rsv_slots;
++		if (rsv_slots) {
++			for (i = 0; rsv_slots[i][0] != -1; i++) {
++				off = rsv_slots[i][0];
++				ln = rsv_slots[i][1];
++				set_bits(off, ln, edma_info[j]->edma_inuse);
++			}
+ 		}
+ 
+ 		sprintf(irq_name, "edma%d", j);
+@@ -1458,6 +1544,7 @@ static int __init edma_probe(struct plat
+ 			edma_write_array2(j, EDMA_DRAE, i, 1, 0x0);
+ 			edma_write_array(j, EDMA_QRAE, i, 0x0);
+ 		}
++		arch_num_cc++;
+ 	}
+ 
+ 	if (tc_errs_handled) {
+--- /dev/null
++++ b/include/media/davinci/imp_common.h
+@@ -0,0 +1,348 @@
++/*
++ * Copyright (C) 2008 Texas Instruments Inc
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
++ *
++ * imp_common.h file
++ **************************************************************************/
++#ifndef _IMP_COMMON_H
++#define _IMP_COMMON_H
++
++#define IMP_MODE_CONTINUOUS	0
++#define	IMP_MODE_SINGLE_SHOT	1
++#define IMP_MODE_INVALID	2
++#define IMP_MAX_NAME_SIZE	40
++
++/* input buffer */
++#define IMP_BUF_IN		0
++/* output buffer */
++#define IMP_BUF_OUT1		1
++/* output buffer */
++#define IMP_BUF_OUT2		2
++
++
++/* structure for request buffer */
++struct imp_reqbufs {
++	/* type of frame buffer */
++	int buf_type;
++	/* size of the frame buffer to be allocated */
++	int size;
++	/* number of frame buffer to be allocated */
++	int count;
++};
++
++/* structure buffer */
++struct imp_buffer {
++	/* index number, 0 -> N-1 */
++	int index;
++	/* buffer type, input or output */
++	int buf_type;
++	/* address of the buffer used in the mmap() system call */
++	int offset;
++	/* size of the buffer */
++	int size;
++};
++
++struct imp_convert {
++	struct imp_buffer in_buff;
++	struct imp_buffer out_buff1;
++	struct imp_buffer out_buff2;
++};
++
++enum imp_data_paths {
++	IMP_RAW2RAW = 1,
++	IMP_RAW2YUV = 2,
++	IMP_YUV2YUV = 4
++};
++
++enum imp_pix_formats {
++	IMP_BAYER_8BIT_PACK,
++	IMP_BAYER_8BIT_PACK_ALAW,
++	IMP_BAYER_8BIT_PACK_DPCM,
++	IMP_BAYER_12BIT_PACK,
++	IMP_BAYER, /* 16 bit */
++	IMP_UYVY,
++	IMP_YUYV,
++	IMP_RGB565,
++	IMP_RGB888,
++	IMP_YUV420SP,
++	IMP_420SP_Y,
++	IMP_420SP_C,
++};
++
++struct imp_window {
++	/* horizontal size */
++	unsigned int width;
++	/* vertical size */
++	unsigned int height;
++	/* horizontal start position */
++	unsigned int hst;
++	/* vertical start position */
++	unsigned int vst;
++};
++
++/* structure used by application to query the modules
++ * available in the image processorr for preview the input
++ * image. Used for PREV_QUERY_CAP IOCTL
++ */
++struct prev_cap {
++	/* application use this to iterate over the available
++	 * modules. stop when -EINVAL return code is returned by
++	 * the driver
++	 */
++	unsigned short index;
++	/* Version of the preview module */
++	char version[IMP_MAX_NAME_SIZE];
++	/* Module IDs as defined above */
++	unsigned short module_id;
++	/* control operation allowed in continuous mode ?
++	 * 1 - allowed, 0 - not allowed
++	 */
++	char control;
++	/* path on which the module is sitting */
++	enum imp_data_paths path;
++	char module_name[IMP_MAX_NAME_SIZE];
++};
++
++/* struct to configure preview modules for which structures
++ * are defined above. Used by PREV_SET_PARAM or PREV_GET_PARAM IOCTLs.
++ */
++struct prev_module_param {
++	/* Version of the preview module */
++	char version[IMP_MAX_NAME_SIZE];
++	/* Length of the module config structure */
++	unsigned short len;
++	/* Module IDs as defined above */
++	unsigned short module_id;
++	/* Ptr to module config parameter. If SET command and is NULL
++	 * module is reset to power on reset values
++	 */
++	void *param;
++};
++
++/* Structure for configuring the previewer driver.
++ * Used in PREV_SET_CONFIG/PREV_GET_CONFIG IOCTLs
++ */
++struct prev_channel_config {
++	/* 1 - single shot, 0 - continuous */
++	unsigned int oper_mode;
++	/* Length of the user configuration */
++	unsigned short len;
++	/* Ptr to either preview_single_shot_config or
++	 * preview_continuous_config depending on oper_mode
++	 */
++	void *config;
++};
++
++struct prev_control {
++	/* Version of the preview module */
++	char version[IMP_MAX_NAME_SIZE];
++	/* Length of the module config structure */
++	unsigned short len;
++	/* Module IDs as defined above */
++	unsigned short module_id;
++	/* Ptr to module config parameter. If SET command and is NULL
++	 * module is reset to power on reset values
++	 */
++	void *param;
++};
++
++/* Structure for RSZ_SET_CONFIG and RSZ_GET_CONFIG IOCTLs */
++struct rsz_channel_config {
++	/* 1 - single shot, 0 - continuous */
++	unsigned int oper_mode;
++	/* Chain this resizer at the previewer output */
++	unsigned char chain;
++	/* Length of the user configuration */
++	unsigned short len;
++	/* ptr to either rsz_single_shot_config or rsz_continuous_config
++	 * depending on oper_mode
++	 */
++	void *config;
++};
++
++/* RSZ_RECONFIG IOCTL. Used for re-configuring resizer
++ * before doing RSZ_RESIZE. This is a IOCTL to do fast reconfiguration
++ * of resizer. This assumes that corresponding resizer is already enabled
++ * through SET_CONFIG. This is used when the input image to be resized
++ * is either Y or C plane of a YUV 420 image. Typically, when channel is
++ * first configured, it is set up to resize Y plane. Then if application
++ * needs to resize C plane, this ioctl is called to switch the channel
++ * to resize C plane.
++ */
++struct rsz_reconfig {
++	enum imp_pix_formats pix_format;
++};
++
++/* Structure for setting dark frame in the IPIPE interface.
++ * Used in the PREV_SET_DARK_FRAME IOCTL
++ * Application captures a dark frame from CCDC with camera shutter
++ * closed and then call this ioctl to set this frame in ipipe interface.
++ * IPIPE operates in continuous mode for dark frame subtraction.
++ */
++struct prev_dark_frame {
++	/* address of the buffer used in the mmap system call.
++	   This buffer has user captured dark frame
++	*/
++	int offset;
++	/* size of the buffer */
++	int size;
++	/* width of the dark frame. Should match with current
++	 * input capture area at CCDC driver
++	 */
++	int width;
++	/* height of the dark frame. Should match with current
++	 * input capture area at the ccdc driver
++	 */
++	int height;
++};
++
++#ifdef __KERNEL__
++#include <linux/completion.h>
++#include <linux/interrupt.h>
++#include <linux/device.h>
++#include <linux/mutex.h>
++#define MAX_CHANNELS		2
++#define	MAX_BUFFERS		6
++#define	MAX_PRIORITY		5
++#define	MIN_PRIORITY		0
++#define	DEFAULT_PRIORITY	3
++#define ENABLED			1
++#define DISABLED		0
++#define CHANNEL_BUSY		1
++#define CHANNEL_FREE		0
++#define ISNULL(val) ((val == NULL) ? 1:0)
++
++/* driver configured by application */
++#define STATE_CONFIGURED	1
++/* driver not configured by application */
++#define STATE_NOT_CONFIGURED	0
++
++enum imp_log_chan_t {
++	IMP_PREVIEWER,
++	IMP_RESIZER,
++	IMP_HISTOGRAM,
++	IMP_BOXCAR
++};
++
++struct irq_numbers {
++	int sdram;
++	int update;
++};
++
++/* IMP channel structure */
++struct imp_logical_channel {
++	/* channel type */
++	enum imp_log_chan_t type;
++	/* operation mode */
++	unsigned int mode;
++	/* If this channel is chained with another channel, this is set */
++	char chained;
++	/* Set if there is a primary user of this channel */
++	char primary_user;
++	/* channel configuration for this logial channel */
++	void *config;
++	/* Size of the user configuration block */
++	int user_config_size;
++	/* Saves the user configuration */
++	void *user_config;
++	/* configure State of the channel */
++	unsigned int config_state;
++	/* number of input buffers */
++	unsigned char in_numbufs;
++	/* number of output buffers1 */
++	unsigned char out_numbuf1s;
++	/* number of output buffers1 */
++	unsigned char out_numbuf2s;
++	/* input buffers */
++	struct imp_buffer *in_bufs[MAX_BUFFERS];
++	/* output buffer1s */
++	struct imp_buffer *out_buf1s[MAX_BUFFERS];
++	/* output buffer2s. Used only by resizes */
++	struct imp_buffer *out_buf2s[MAX_BUFFERS];
++	/* stores priority of the application */
++	int priority;
++	/* channel processing completion */
++	struct completion channel_sem;
++	/* channel protection lock */
++	struct mutex lock;
++};
++
++/* Where hardware channel is shared, this is used for serialisation */
++struct imp_serializer {
++	/* channel config array for serialization */
++	struct imp_logical_channel *channel_config[MAX_CHANNELS];
++	/* number of elements in the array */
++	int array_count;
++	/* Semaphore for above config array */
++	struct mutex array_sem;
++	/* Completion semaphore when hw channel is common
++	 * Use device specific completion semaphore when request is serialized
++	 */
++	struct completion sem_isr;
++};
++
++/* function prototypes */
++int imp_common_free_buffers(struct device *dev,
++			struct imp_logical_channel *channel);
++
++int imp_common_mmap(struct file *filp,
++			struct vm_area_struct *vma,
++			struct imp_logical_channel *channel);
++
++int imp_common_query_buffer(struct device *dev,
++		struct imp_logical_channel *channel,
++		struct imp_buffer *buffer);
++
++int imp_common_start_preview(struct device *dev,
++		struct imp_logical_channel *chan,
++		struct imp_convert *convert);
++
++int imp_common_request_buffer(struct device *dev,
++		struct imp_logical_channel *channel,
++		struct imp_reqbufs *reqbufs);
++
++struct prev_module_if *imp_get_module_interface(struct device *dev,
++		unsigned short module_id);
++
++int imp_set_preview_config(struct device *dev,
++				struct imp_logical_channel *channel,
++				struct prev_channel_config *config);
++
++int imp_get_preview_config(struct device *dev,
++				struct imp_logical_channel *channel,
++				struct prev_channel_config *config);
++
++int imp_init_serializer(void);
++
++
++int imp_set_resizer_config(struct device *dev,
++				struct imp_logical_channel *channel,
++				struct rsz_channel_config *chan_config);
++
++int imp_common_start_resize(struct device *dev,
++		struct imp_logical_channel *chan,
++		struct imp_convert *convert);
++
++int imp_get_resize_config(struct device *dev,
++				struct imp_logical_channel *channel,
++				struct rsz_channel_config *chan_config);
++
++int imp_common_reconfig_resizer(struct device *dev,
++			struct rsz_reconfig *reconfig,
++			struct imp_logical_channel *chan);
++
++#endif
++#endif
+--- a/drivers/video/Kconfig
++++ b/drivers/video/Kconfig
+@@ -1970,6 +1970,21 @@ config FB_IBM_GXT4500
+ 	  Say Y here to enable support for the IBM GXT4500P display
+ 	  adaptor, found on some IBM System P (pSeries) machines.
+ 
++config FB_DAVINCI
++	bool "Davinci Framebuffer support"
++	depends on FB && ARCH_DAVINCI
++	select FB_CFB_FILLRECT
++	select FB_CFB_COPYAREA
++	select FB_CFB_IMAGEBLIT
++	help
++	  This is the frame buffer device driver for the DaVinci video
++	  hardware found on the TI DaVinci EVM.	 If
++	  unsure, say N.
++
++config FB_VIRTUAL
++	tristate "Virtual Frame Buffer support (ONLY FOR TESTING!)"
++	depends on FB
++
+ config FB_PS3
+ 	tristate "PS3 GPU framebuffer driver"
+ 	depends on FB && PS3_PS3AV
+--- a/drivers/media/video/tvp514x.c
++++ b/drivers/media/video/tvp514x.c
+@@ -523,10 +523,18 @@ static int tvp514x_querystd(struct v4l2_
+ 	enum tvp514x_std current_std;
+ 	enum tvp514x_input input_sel;
+ 	u8 sync_lock_status, lock_mask;
++	int err;
+ 
+ 	if (std_id == NULL)
+ 		return -EINVAL;
+ 
++	err = tvp514x_write_reg(sd, REG_VIDEO_STD,
++			VIDEO_STD_AUTO_SWITCH_BIT);
++	if (err < 0)
++		return err;
++
++	msleep(LOCK_RETRY_DELAY);
++
+ 	/* get the current standard */
+ 	current_std = tvp514x_get_current_std(sd);
+ 	if (current_std == STD_INVALID)
+@@ -643,6 +651,15 @@ static int tvp514x_s_routing(struct v4l2
+ 		/* Index out of bound */
+ 		return -EINVAL;
+ 
++	/* Since this api is goint to detect the input, it is required
++	   to set the standard in the auto switch mode */
++	err = tvp514x_write_reg(sd, REG_VIDEO_STD,
++			VIDEO_STD_AUTO_SWITCH_BIT);
++	if (err < 0)
++		return err;
++
++	msleep(LOCK_RETRY_DELAY);
++
+ 	input_sel = input;
+ 	output_sel = output;
+ 
+--- /dev/null
++++ b/drivers/media/video/davinci/logicpd_encoder.c
+@@ -0,0 +1,413 @@
++/*
++ * Copyright (C) 2007 Texas Instruments Inc
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
++ */
++/* logicpd_encoder.c. This is just a place holder for hardcoding all supported
++   modes timing. LogicPD timing signals are programmed by the encoder manager
++   based on this data.
++ */
++
++/* Kernel Specific header files */
++
++#include <linux/kernel.h>
++#include <linux/autoconf.h>
++#include <linux/init.h>
++#include <linux/ctype.h>
++#include <linux/delay.h>
++#include <media/davinci/vid_encoder_if.h>
++#include <media/davinci/logicpd_encoder.h>
++
++/* Function prototypes */
++static int logicpd_encoder_initialize(struct vid_encoder_device *enc, int flag);
++static int logicpd_encoder_deinitialize(struct vid_encoder_device *enc);
++
++static int logicpd_encoder_setmode(struct vid_enc_mode_info *mode_info,
++				   struct vid_encoder_device *enc);
++static int logicpd_encoder_getmode(struct vid_enc_mode_info *mode_info,
++				   struct vid_encoder_device *enc);
++
++static int logicpd_encoder_setoutput(char *output,
++				     struct vid_encoder_device *enc);
++static int logicpd_encoder_getoutput(char *output,
++				     struct vid_encoder_device *enc);
++
++static int logicpd_encoder_enumoutput(int index,
++				      char *output,
++				      struct vid_encoder_device *enc);
++
++static struct logicpd_encoder_config logicpd_encoder_configuration = {
++	.no_of_outputs = LOGICPD_ENCODER_MAX_NO_OUTPUTS,
++	.output[0] = {
++		      .output_name = VID_ENC_OUTPUT_LCD,
++		      .no_of_standard = LOGICPD_ENCODER_GRAPHICS_NUM_STD,
++		      .standards[0] = {
++				       .name = VID_ENC_STD_640x480,
++				       .std = 1,
++				       .if_type = VID_ENC_IF_PRGB,
++				       .interlaced = 0,
++				       .xres = 640,
++				       .yres = 480,
++				       .fps = {60, 1},
++				       .left_margin = 85,
++				       .right_margin = 70,
++				       .upper_margin = 32,
++				       .lower_margin = 11,
++				       .hsync_len = 9,
++				       .vsync_len = 9,
++				       .flags = 0},	/* hsync -ve, vsync -ve */
++		      .standards[1] = {
++				       .name = VID_ENC_STD_640x400,
++				       .std = 1,
++				       .if_type = VID_ENC_IF_PRGB,
++				       .interlaced = 0,
++				       .xres = 640,
++				       .yres = 400,
++				       .fps = {60, 1},
++				       .left_margin = 85,
++				       .right_margin = 70,
++				       .upper_margin = 72,
++				       .lower_margin = 51,
++				       .hsync_len = 9,
++				       .vsync_len = 9,
++				       .flags = 2},	/* hsync -ve, vsync +ve */
++		      .standards[2] = {
++				       .name = VID_ENC_STD_640x350,
++				       .std = 1,
++				       .if_type = VID_ENC_IF_PRGB,
++				       .interlaced = 0,
++				       .xres = 640,
++				       .yres = 350,
++				       .fps = {60, 1},
++				       .left_margin = 85,
++				       .right_margin = 70,
++				       .upper_margin = 97,
++				       .lower_margin = 76,
++				       .hsync_len = 9,
++				       .vsync_len = 9,
++				       .flags = 1},	/* hsync +ve, vsync -ve */
++		      .standards[3] = {	/* This is programmed by the user application. We just save
++					   the received timing information */
++				       .name = VID_ENC_STD_NON_STANDARD,
++				       .std = 0,
++				       .if_type = VID_ENC_IF_PRGB,
++				       .interlaced = 0,
++				       .xres = 0,
++				       .yres = 0,
++				       .fps = {0, 0},
++				       .left_margin = 0,
++				       .right_margin = 0,
++				       .upper_margin = 0,
++				       .lower_margin = 0,
++				       .hsync_len = 0,
++				       .vsync_len = 0,
++				       .flags = 0},
++		      },
++};
++
++static struct logicpd_encoder_channel logicpd_encoder_channel_info = {
++	.params.outindex = 0,
++	.params.mode = VID_ENC_STD_640x480,
++	.enc_device = NULL
++};
++
++static struct vid_enc_output_ops outputs_ops = {
++	.count = LOGICPD_ENCODER_MAX_NO_OUTPUTS,
++	.enumoutput = logicpd_encoder_enumoutput,
++	.setoutput = logicpd_encoder_setoutput,
++	.getoutput = logicpd_encoder_getoutput
++};
++
++static struct vid_enc_mode_ops modes_ops = {
++	.setmode = logicpd_encoder_setmode,
++	.getmode = logicpd_encoder_getmode,
++};
++
++static struct vid_encoder_device logicpd_encoder_dev = {
++	.name = "LOGICPD_ENCODER",
++	.capabilities = 0,
++	.initialize = logicpd_encoder_initialize,
++	.mode_ops = &modes_ops,
++	.ctrl_ops = NULL,
++	.output_ops = &outputs_ops,
++	.params_ops = NULL,
++	.misc_ops = NULL,
++	.deinitialize = logicpd_encoder_deinitialize,
++};
++
++/* This function is called by the encoder manager to initialize logicpd encoder driver.
++ */
++static int logicpd_encoder_initialize(struct vid_encoder_device *enc, int flag)
++{
++	int err = 0, outindex;
++	char *std, *output;
++	if (NULL == enc) {
++		printk(KERN_ERR "enc:NULL Pointer\n");
++		return -EINVAL;
++	}
++	logicpd_encoder_channel_info.enc_device = (struct encoder_device *)enc;
++
++	/* call set standard */
++	std = logicpd_encoder_channel_info.params.mode;
++	outindex = logicpd_encoder_channel_info.params.outindex;
++	output = logicpd_encoder_configuration.output[outindex].output_name;
++	err |= logicpd_encoder_setoutput(output, enc);
++	if (err < 0) {
++		err = -EINVAL;
++		printk(KERN_ERR "Error occured in setoutput\n");
++		logicpd_encoder_deinitialize(enc);
++		return err;
++	}
++	printk(KERN_DEBUG "LogicPD Encoder initialized\n");
++	return err;
++}
++
++/* Function to de-initialize the encoder */
++static int logicpd_encoder_deinitialize(struct vid_encoder_device *enc)
++{
++	if (NULL == enc) {
++		printk(KERN_ERR "NULL Pointer\n");
++		return -EINVAL;
++	}
++	logicpd_encoder_channel_info.enc_device = NULL;
++	printk(KERN_DEBUG "LogicPD Encoder de-initialized\n");
++	return 0;
++}
++
++/* Following function is used to set the mode*/
++static int logicpd_encoder_setmode(struct vid_enc_mode_info *mode_info,
++				   struct vid_encoder_device *enc)
++{
++	int err = 0, outindex, i;
++	char *mode;
++	struct vid_enc_mode_info *my_mode_info = NULL;
++
++	if ((NULL == enc) || (NULL == mode_info)) {
++		printk(KERN_ERR "NULL Pointer\n");
++		return -EINVAL;
++	}
++
++	if (NULL == (mode = mode_info->name)) {
++		printk(KERN_ERR "NULL Pointer\n");
++		return -EINVAL;
++	}
++	printk(KERN_DEBUG "Start of logicpd_encoder_setmode..\n");
++	outindex = logicpd_encoder_channel_info.params.outindex;
++
++	if (mode_info->std) {
++		char *mymode = NULL;
++		/* This is a standard mode */
++		for (i = 0;
++		     i <
++		     logicpd_encoder_configuration.output[outindex].
++		     no_of_standard; i++) {
++			if (!strcmp
++			    (logicpd_encoder_configuration.output[outindex].
++			     standards[i].name, mode)) {
++				mymode =
++				    logicpd_encoder_configuration.
++				    output[outindex].standards[i].name;
++				break;
++			}
++		}
++		if ((i ==
++		     logicpd_encoder_configuration.output[outindex].
++		     no_of_standard) || (NULL == mymode)) {
++			printk(KERN_ERR "Invalid id...\n");
++			return -EINVAL;
++		}
++		/* Store the standard in global object of logicpd_encoder */
++		logicpd_encoder_channel_info.params.mode = mymode;
++		return 0;
++	} else {
++		/* Non- Standard mode. Check if we support it. If so
++		   save the timing info and return */
++		for (i = 0; i < LOGICPD_ENCODER_GRAPHICS_NUM_STD; i++) {
++			if (!strcmp
++			    (logicpd_encoder_configuration.output[outindex].
++			     standards[i].name, VID_ENC_STD_NON_STANDARD)) {
++				my_mode_info =
++				    &logicpd_encoder_configuration.
++				    output[outindex].standards[i];
++				break;
++			}
++		}
++		if (my_mode_info) {
++			/* We support. So save timing info and return success
++			   interface type is same as what is currently is active
++			 */
++			my_mode_info->interlaced = mode_info->interlaced;
++			my_mode_info->xres = mode_info->xres;
++			my_mode_info->yres = mode_info->yres;
++			my_mode_info->fps = mode_info->fps;
++			my_mode_info->left_margin = mode_info->left_margin;
++			my_mode_info->right_margin = mode_info->right_margin;
++			my_mode_info->upper_margin = mode_info->upper_margin;
++			my_mode_info->lower_margin = mode_info->lower_margin;
++			my_mode_info->hsync_len = mode_info->hsync_len;
++			my_mode_info->vsync_len = mode_info->vsync_len;
++			my_mode_info->flags = mode_info->flags;
++			/* If we need to configure something in the encoder module, we need to
++			   do this here */
++			return 0;
++		}
++		printk(KERN_ERR "Mode not supported..\n");
++		return -EINVAL;
++	}
++	printk(KERN_DEBUG "</logicpd_encoder_setmode>\n");
++	return err;
++}
++
++/* Following function is used to get currently selected mode.*/
++static int logicpd_encoder_getmode(struct vid_enc_mode_info *mode_info,
++				   struct vid_encoder_device *enc)
++{
++	int err = 0, i, outindex;
++	if ((NULL == enc) || (NULL == mode_info)) {
++		printk(KERN_ERR "NULL Pointer\n");
++		return -EINVAL;
++	}
++	printk(KERN_DEBUG "<logicpd_encoder_getmode>\n");
++	outindex = logicpd_encoder_channel_info.params.outindex;
++	for (i = 0; i < LOGICPD_ENCODER_GRAPHICS_NUM_STD; i++) {
++		if (!strcmp(logicpd_encoder_channel_info.params.mode,
++			    logicpd_encoder_configuration.output[outindex].
++			    standards[i].name)) {
++			memcpy(mode_info,
++			       &logicpd_encoder_configuration.output[outindex].
++			       standards[i], sizeof(struct vid_enc_mode_info));
++			break;
++		}
++	}
++	if (i == LOGICPD_ENCODER_GRAPHICS_NUM_STD) {
++		printk(KERN_ERR "Wiered. No mode info\n");
++		return -EINVAL;
++	}
++	printk(KERN_DEBUG "</logicpd_encoder_getmode>\n");
++	return err;
++}
++
++/* For LogicPD, we have only one output, called LCD, we
++   always set this to this at init
++*/
++static int logicpd_encoder_setoutput(char *output,
++				     struct vid_encoder_device *enc)
++{
++	int err = 0;
++	struct vid_enc_mode_info *my_mode_info;
++	printk(KERN_DEBUG "<logicpd_encoder_setoutput>\n");
++	if (NULL == enc) {
++		printk(KERN_ERR "enc:NULL Pointer\n");
++		return -EINVAL;
++	}
++
++	/* check for null pointer */
++	if (output == NULL) {
++		printk(KERN_ERR "output: NULL Pointer.\n");
++		return -EINVAL;
++	}
++
++	/* Just check if the default output match with this output name */
++	if (strcmp(logicpd_encoder_configuration.output[0].output_name, output)) {
++		printk(KERN_ERR "no matching output found.\n");
++		return -EINVAL;
++	}
++	logicpd_encoder_channel_info.params.mode
++	    = logicpd_encoder_configuration.output[0].standards[0].name;
++
++	my_mode_info = &logicpd_encoder_configuration.output[0].standards[0];
++	err |= logicpd_encoder_setmode(my_mode_info, enc);
++	if (err < 0) {
++		printk(KERN_ERR "Error in setting default mode\n");
++		return err;
++	}
++	printk(KERN_DEBUG "</logicpd_encoder_setoutput>\n");
++	return err;
++}
++
++/* Following function is used to get output name of current output.*/
++static int logicpd_encoder_getoutput(char *output,
++				     struct vid_encoder_device *enc)
++{
++	int err = 0, index, len;
++	if (NULL == enc) {
++		printk(KERN_ERR "enc:NULL Pointer\n");
++		return -EINVAL;
++	}
++	printk(KERN_DEBUG "<logicpd_encoder_getoutput>\n");
++	/* check for null pointer */
++	if (output == NULL) {
++		printk(KERN_ERR "output:NULL Pointer.\n");
++		return -EINVAL;
++	}
++	index = logicpd_encoder_channel_info.params.outindex;
++	len = strlen(logicpd_encoder_configuration.output[index].output_name);
++	if (len > (VID_ENC_NAME_MAX_CHARS - 1))
++		len = VID_ENC_NAME_MAX_CHARS - 1;
++	strncpy(output, logicpd_encoder_configuration.output[index].output_name,
++		len);
++	output[len] = '\0';
++	printk(KERN_DEBUG "</logicpd_encoder_getoutput>\n");
++	return err;
++}
++
++/* Following function is used to enumerate outputs supported by the driver.
++   It fills in information in the output. */
++static int logicpd_encoder_enumoutput(int index, char *output,
++				      struct vid_encoder_device *enc)
++{
++	int err = 0;
++
++	printk(KERN_DEBUG "<logicpd_encoder_enumoutput>\n");
++	if (NULL == enc) {
++		printk(KERN_ERR "enc:NULL Pointer.\n");
++		return -EINVAL;
++	}
++	/* check for null pointer */
++	if (output == NULL) {
++		printk(KERN_ERR "output:NULL Pointer.\n");
++		return -EINVAL;
++	}
++	/* Only one output is available */
++	if (index >= logicpd_encoder_configuration.no_of_outputs) {
++		return -EINVAL;
++	}
++	strncpy(output,
++		logicpd_encoder_configuration.output[index].output_name,
++		VID_ENC_NAME_MAX_CHARS);
++	printk(KERN_DEBUG "</logicpd_encoder_enumoutput>\n");
++	return err;
++}
++
++/* This function used to initialize the LogicPD encoder driver */
++static int logicpd_encoder_init(void)
++{
++	int err = 0;
++
++	err = vid_enc_register_encoder(&logicpd_encoder_dev);
++	printk(KERN_NOTICE "LogicPD encoder initialized\n");
++	return err;
++}
++
++/* Function used to cleanup LogicPD encoder driver */
++static void logicpd_encoder_cleanup(void)
++{
++	vid_enc_unregister_encoder(&logicpd_encoder_dev);
++}
++
++subsys_initcall_sync(logicpd_encoder_init);
++module_exit(logicpd_encoder_cleanup);
++
++MODULE_LICENSE("GPL");
+--- a/arch/arm/mach-davinci/dm355.c
++++ b/arch/arm/mach-davinci/dm355.c
+@@ -31,6 +31,9 @@
+ #include <mach/serial.h>
+ #include <mach/common.h>
+ #include <mach/asp.h>
++#include <mach/spi.h>
++#include <video/davinci_osd.h>
++#include <video/davinci_vpbe.h>
+ 
+ #include "clock.h"
+ #include "mux.h"
+@@ -112,6 +115,7 @@ static struct clk vpss_dac_clk = {
+ 	.name = "vpss_dac",
+ 	.parent = &pll1_sysclk3,
+ 	.lpsc = DM355_LPSC_VPSS_DAC,
++	.flags = ALWAYS_ENABLED,
+ };
+ 
+ static struct clk vpss_master_clk = {
+@@ -365,9 +369,9 @@ static struct davinci_clk dm355_clks[] =
+ 	CLK("davinci-asp.1", NULL, &asp1_clk),
+ 	CLK("davinci_mmc.0", NULL, &mmcsd0_clk),
+ 	CLK("davinci_mmc.1", NULL, &mmcsd1_clk),
+-	CLK(NULL, "spi0", &spi0_clk),
+-	CLK(NULL, "spi1", &spi1_clk),
+-	CLK(NULL, "spi2", &spi2_clk),
++	CLK("spi_davinci.0", NULL, &spi0_clk),
++	CLK("spi_davinci.1", NULL, &spi1_clk),
++	CLK("spi_davinci.2", NULL, &spi2_clk),
+ 	CLK(NULL, "gpio", &gpio_clk),
+ 	CLK(NULL, "aemif", &aemif_clk),
+ 	CLK(NULL, "pwm0", &pwm0_clk),
+@@ -394,16 +398,33 @@ static struct resource dm355_spi0_resour
+ 		.flags = IORESOURCE_MEM,
+ 	},
+ 	{
+-		.start = IRQ_DM355_SPINT0_1,
++		.start = IRQ_DM355_SPINT0_0,
+ 		.flags = IORESOURCE_IRQ,
+ 	},
+-	/* Not yet used, so not included:
+-	 * IORESOURCE_IRQ:
+-	 *  - IRQ_DM355_SPINT0_0
+-	 * IORESOURCE_DMA:
+-	 *  - DAVINCI_DMA_SPI_SPIX
+-	 *  - DAVINCI_DMA_SPI_SPIR
+-	 */
++	{
++		.start = 17,
++		.flags = IORESOURCE_DMA | IORESOURCE_DMA_RX_CHAN,
++	},
++	{
++		.start = 16,
++		.flags = IORESOURCE_DMA | IORESOURCE_DMA_TX_CHAN,
++	},
++	{
++		.start = EVENTQ_1,
++		.flags = IORESOURCE_DMA | IORESOURCE_DMA_EVENT_Q,
++	},
++};
++
++static struct davinci_spi_platform_data dm355_spi0_pdata = {
++	.version 	= SPI_VERSION_1,
++	.num_chipselect = 2,
++	.clk_internal	= 1,
++	.cs_hold	= 1,
++	.intr_level	= 0,
++	.poll_mode	= 1,	/* 0 -> interrupt mode 1-> polling mode */
++	.use_dma	= 1,	/* when 1, value in poll_mode is ignored */
++	.c2tdelay	= 0,
++	.t2cdelay	= 0,
+ };
+ 
+ static struct platform_device dm355_spi0_device = {
+@@ -412,6 +433,7 @@ static struct platform_device dm355_spi0
+ 	.dev = {
+ 		.dma_mask = &dm355_spi0_dma_mask,
+ 		.coherent_dma_mask = DMA_BIT_MASK(32),
++		.platform_data = &dm355_spi0_pdata,
+ 	},
+ 	.num_resources = ARRAY_SIZE(dm355_spi0_resources),
+ 	.resource = dm355_spi0_resources,
+@@ -566,13 +588,6 @@ static u8 dm355_default_priorities[DAVIN
+ 
+ /*----------------------------------------------------------------------*/
+ 
+-static const s8 dma_chan_dm355_no_event[] = {
+-	12, 13, 24, 56, 57,
+-	58, 59, 60, 61, 62,
+-	63,
+-	-1
+-};
+-
+ static const s8
+ queue_tc_mapping[][2] = {
+ 	/* {event queue no, TC no} */
+@@ -596,7 +611,6 @@ static struct edma_soc_info dm355_edma_i
+ 		.n_slot			= 128,
+ 		.n_tc			= 2,
+ 		.n_cc			= 1,
+-		.noevent		= dma_chan_dm355_no_event,
+ 		.queue_tc_mapping	= queue_tc_mapping,
+ 		.queue_priority_mapping	= queue_priority_mapping,
+ 	},
+@@ -703,6 +717,10 @@ static struct resource vpfe_resources[]
+ 		.end            = IRQ_VDINT1,
+ 		.flags          = IORESOURCE_IRQ,
+ 	},
++};
++
++static u64 vpfe_capture_dma_mask = DMA_BIT_MASK(32);
++static struct resource dm355_ccdc_resource[] = {
+ 	/* CCDC Base address */
+ 	{
+ 		.flags          = IORESOURCE_MEM,
+@@ -710,8 +728,17 @@ static struct resource vpfe_resources[]
+ 		.end            = 0x01c70600 + 0x1ff,
+ 	},
+ };
++static struct platform_device dm355_ccdc_dev = {
++	.name           = "dm355_ccdc",
++	.id             = -1,
++	.num_resources  = ARRAY_SIZE(dm355_ccdc_resource),
++	.resource       = dm355_ccdc_resource,
++	.dev = {
++		.dma_mask               = &vpfe_capture_dma_mask,
++		.coherent_dma_mask      = DMA_BIT_MASK(32),
++	},
++};
+ 
+-static u64 vpfe_capture_dma_mask = DMA_BIT_MASK(32);
+ static struct platform_device vpfe_capture_dev = {
+ 	.name		= CAPTURE_DRV_NAME,
+ 	.id		= -1,
+@@ -728,7 +755,85 @@ void dm355_set_vpfe_config(struct vpfe_c
+ 	vpfe_capture_dev.dev.platform_data = cfg;
+ }
+ 
+-/*----------------------------------------------------------------------*/
++/* IPIPEIF device configuration */
++static u64 dm355_ipipeif_dma_mask = DMA_BIT_MASK(32);
++static struct resource dm355_ipipeif_resources[] = {
++	{
++		.start          = 0x01C70100,
++		.end            = 0x01C70100 + 0x60,
++		.flags          = IORESOURCE_MEM,
++	},
++};
++
++static struct platform_device dm355_ipipeif_dev = {
++	.name		= "dm3xx_ipipeif",
++	.id		= -1,
++	.num_resources	= ARRAY_SIZE(dm355_ipipeif_resources),
++	.resource	= dm355_ipipeif_resources,
++	.dev = {
++		.dma_mask		= &dm355_ipipeif_dma_mask,
++		.coherent_dma_mask	= DMA_BIT_MASK(32),
++	},
++};
++
++static u64 dm355_osd_dma_mask = DMA_BIT_MASK(32);
++
++static struct davinci_osd_platform_data dm355_osd_pdata = {
++	.type = DM355,
++};
++
++static struct resource dm355_osd_resources[] = {
++	{
++		.start          = IRQ_VENCINT,
++		.end            = IRQ_VENCINT,
++		.flags          = IORESOURCE_IRQ,
++	},
++	{
++		.start          = DM355_OSD_REG_BASE,
++		.end            = DM355_OSD_REG_BASE + 0x180,
++		.flags          = IORESOURCE_MEM,
++	},
++};
++
++static struct platform_device dm355_osd_dev = {
++	.name		= "davinci_osd",
++	.id		= -1,
++	.num_resources	= ARRAY_SIZE(dm355_osd_resources),
++	.resource	= dm355_osd_resources,
++	.dev = {
++		.dma_mask		= &dm355_osd_dma_mask,
++		.coherent_dma_mask	= DMA_BIT_MASK(32),
++		.platform_data		= &dm355_osd_pdata,
++	},
++};
++
++static u64 dm355_venc_dma_mask = DMA_BIT_MASK(32);
++
++
++static struct davinci_venc_platform_data dm355_venc_pdata = {
++	.soc = DM35x,
++};
++
++
++static struct resource dm355_venc_resources[] = {
++	{
++		.start          = DM355_VENC_REG_BASE,
++		.end            = DM355_VENC_REG_BASE + 0x180,
++		.flags          = IORESOURCE_MEM,
++	},
++};
++
++static struct platform_device dm355_venc_dev = {
++	.name		= "davinci_venc",
++	.id		= -1,
++	.num_resources	= ARRAY_SIZE(dm355_venc_resources),
++	.resource	= dm355_venc_resources,
++	.dev = {
++		.dma_mask		= &dm355_venc_dma_mask,
++		.coherent_dma_mask	= DMA_BIT_MASK(32),
++		.platform_data		= &dm355_venc_pdata,
++	},
++};
+ 
+ static struct map_desc dm355_io_desc[] = {
+ 	{
+@@ -862,19 +967,16 @@ static int __init dm355_init_devices(voi
+ 	davinci_cfg_reg(DM355_INT_EDMA_CC);
+ 	platform_device_register(&dm355_edma_device);
+ 	platform_device_register(&dm355_vpss_device);
+-	/*
+-	 * setup Mux configuration for vpfe input and register
+-	 * vpfe capture platform device
+-	 */
+-	davinci_cfg_reg(DM355_VIN_PCLK);
+-	davinci_cfg_reg(DM355_VIN_CAM_WEN);
+-	davinci_cfg_reg(DM355_VIN_CAM_VD);
+-	davinci_cfg_reg(DM355_VIN_CAM_HD);
+-	davinci_cfg_reg(DM355_VIN_YIN_EN);
+-	davinci_cfg_reg(DM355_VIN_CINL_EN);
+-	davinci_cfg_reg(DM355_VIN_CINH_EN);
++	platform_device_register(&dm355_ipipeif_dev);
++	platform_device_register(&dm355_ccdc_dev);
+ 	platform_device_register(&vpfe_capture_dev);
+ 
++	/* Register OSD device */
++	platform_device_register(&dm355_osd_dev);
++
++	/* Register VENC device */
++	platform_device_register(&dm355_venc_dev);
++
+ 	return 0;
+ }
+ postcore_initcall(dm355_init_devices);
+--- /dev/null
++++ b/drivers/char/imp_resizer.c
+@@ -0,0 +1,614 @@
++/* *
++ * Copyright (C) 2008-2009 Texas Instruments Inc
++ *
++ * This program is free software you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option)any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not,write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
++ */
++//#include <linux/config.h>
++#include <linux/module.h>
++#include <linux/init.h>
++#include <linux/kernel.h>
++#include <linux/slab.h>
++#include <linux/fs.h>
++#include <linux/errno.h>
++#include <linux/types.h>
++#include <linux/cdev.h>
++#include <linux/fb.h>
++#include <linux/dma-mapping.h>
++#include <linux/interrupt.h>
++#include <linux/uaccess.h>
++#include <linux/irq.h>
++#include <linux/io.h>
++#include <linux/err.h>
++#include <linux/platform_device.h>
++
++#include <media/davinci/imp_hw_if.h>
++#include <media/davinci/imp_resizer.h>
++
++#include <mach/cputype.h>
++
++#define	DRIVER_NAME	"DaVinciResizer"
++
++/*device structure shared across all instances*/
++struct rsz_device rsz_dev;
++
++/* For registeration of	charatcer device*/
++static struct cdev c_dev;
++/* device structure	to make	entry in device*/
++static dev_t dev;
++/* for holding device entry*/
++struct device *rsz_device;
++
++/* instance of the imp interface */
++static struct imp_hw_interface *imp_hw_if;
++/*
++=====================rsz_open===========================
++This function creates a channels.
++*/
++static int rsz_open(struct inode *inode, struct file *filp)
++{
++	struct imp_logical_channel *rsz_conf_chan;
++	int i, mode, ret;
++
++	if (filp->f_flags & O_NONBLOCK) {
++		dev_err
++		    (rsz_device,
++		     "rsz_open: device cannot be opened in non-blocked mode\n");
++		return -EBUSY;
++	}
++
++	mode = imp_hw_if->get_resize_oper_mode();
++
++	ret = mutex_lock_interruptible(&rsz_dev.lock);
++	if (ret)
++		return ret;
++	if ((mode == IMP_MODE_CONTINUOUS) ||
++	    ((mode == IMP_MODE_SINGLE_SHOT) && (!imp_hw_if->serialize()))) {
++		if (rsz_dev.users != 0) {
++			dev_err(rsz_device,
++				"\n mode doesn't allow multiple instances\n");
++			mutex_unlock(&rsz_dev.lock);
++			return -EBUSY;
++		}
++	}
++
++	/* if usage counter is greater than maximum supported channels
++	   return error */
++	if (rsz_dev.users >= MAX_CHANNELS) {
++		dev_err(rsz_device,
++			"\n modules usage count is greater than supported ");
++		mutex_unlock(&rsz_dev.lock);
++		return -EBUSY;
++	}
++
++	rsz_dev.users++;
++	mutex_unlock(&rsz_dev.lock);
++	/* allocate     memory for a new configuration */
++	rsz_conf_chan = kmalloc(sizeof(struct imp_logical_channel), GFP_KERNEL);
++
++	if (rsz_conf_chan == NULL) {
++		dev_err(rsz_device,
++			"\n cannot allocate memory ro channel config");
++		return -ENOMEM;
++	}
++
++	rsz_conf_chan->config_state = STATE_NOT_CONFIGURED;
++	rsz_conf_chan->mode = IMP_MODE_INVALID;
++	rsz_conf_chan->primary_user = 0;
++	rsz_conf_chan->chained = 0;
++	rsz_conf_chan->config = NULL;
++	rsz_conf_chan->user_config = NULL;
++	rsz_conf_chan->user_config_size = 0;
++
++	/* Set priority to lowest for that configuration channel */
++	rsz_conf_chan->priority = MIN_PRIORITY;
++
++	/* Set the channel type to resize */
++	rsz_conf_chan->type = IMP_RESIZER;
++
++	for (i = 0; i < MAX_BUFFERS; i++) {
++		rsz_conf_chan->in_bufs[i] = NULL;
++		rsz_conf_chan->out_buf1s[i] = NULL;
++		rsz_conf_chan->out_buf2s[i] = NULL;
++	}
++	rsz_conf_chan->in_numbufs = 0;
++	rsz_conf_chan->out_numbuf1s = 0;
++	rsz_conf_chan->out_numbuf2s = 0;
++
++	dev_dbg(rsz_device, "Initializing	of channel done	\n");
++
++	/* Initializing of application mutex */
++	init_completion(&(rsz_conf_chan->channel_sem));
++	rsz_conf_chan->channel_sem.done = 0;
++	mutex_init(&(rsz_conf_chan->lock));
++	/* taking the configuartion     structure in private data */
++	filp->private_data = rsz_conf_chan;
++
++
++	return 0;
++
++}
++
++/*
++=====================rsz_release===========================
++ The Function	is used	to release the number of resources occupied
++ by the channel
++*/
++static int rsz_release(struct inode *inode, struct file *filp)
++{
++	struct imp_logical_channel *rsz_conf_chan =
++	    (struct imp_logical_channel *)filp->private_data;
++
++
++	/* Lock the channel */
++	mutex_lock(&(rsz_conf_chan->lock));
++
++	/* It will free all the input and output buffers */
++	imp_common_free_buffers(rsz_device, rsz_conf_chan);
++
++	if (rsz_conf_chan->config_state == STATE_CONFIGURED) {
++		if (!rsz_conf_chan->chained) {
++			imp_hw_if->dealloc_config_block(rsz_device,
++							rsz_conf_chan->config);
++		}
++		kfree(rsz_conf_chan->user_config);
++	}
++	mutex_unlock(&(rsz_conf_chan->lock));
++	mutex_lock(&rsz_dev.lock);
++	rsz_dev.users--;
++	kfree(filp->private_data);
++	filp->private_data = NULL;
++	mutex_unlock(&rsz_dev.lock);
++	return 0;
++}				/*  End     of function     resizer_release */
++
++/*
++=====================rsz_mmap===========================
++Function to map device memory into user	space
++ */
++static int rsz_mmap(struct file *filp, struct vm_area_struct *vma)
++{
++	struct imp_logical_channel *chan =
++	    (struct imp_logical_channel *)filp->private_data;
++	return (imp_common_mmap(filp, vma, chan));
++}				/*     End     of Function     resizer_mmap */
++
++/*
++=====================rsz_ioctl===========================
++This function	will process IOCTL commands sent by
++the application	and
++control the device IO operations.
++*/
++static int rsz_doioctl(struct inode *inode, struct file *file,
++		       unsigned int cmd, unsigned long arg)
++{
++	int ret = 0, prio;
++	unsigned mode, user_mode;
++	/*get the configuratin of this channel from
++	   private_date member of file */
++	struct imp_logical_channel *rsz_conf_chan =
++	    (struct imp_logical_channel *)file->private_data;
++
++	if (ISNULL(rsz_conf_chan)) {
++		dev_err(rsz_device, "channel ptr is null\n");
++		return -EFAULT;
++	}
++
++	if (ISNULL((void *)arg)) {
++		dev_err(rsz_device, "arg ptr is null\n");
++		return -EFAULT;
++	}
++
++	mode = imp_hw_if->get_resize_oper_mode();
++	switch (cmd) {
++	case RSZ_QUERYBUF:
++	case RSZ_REQBUF:
++	case RSZ_RESIZE:
++	case RSZ_RECONFIG:
++		{
++			if (mode == IMP_MODE_CONTINUOUS)
++				return -EACCES;
++		}
++		break;
++	}
++
++	switch (cmd) {
++	case RSZ_S_OPER_MODE:
++		{
++			dev_dbg(rsz_device, "RSZ_S_OPER_MODE:\n");
++			user_mode = *((unsigned long *)arg);
++			if (rsz_conf_chan->mode != IMP_MODE_INVALID) {
++				dev_err(rsz_device,
++					"Mode set for this channel already\n");
++				ret = -EINVAL;
++				goto ERROR;
++			}
++
++			if (user_mode >= IMP_MODE_INVALID) {
++				dev_err(rsz_device, "Invalid mode\n");
++				ret = -EINVAL;
++				goto ERROR;
++			}
++
++			if (user_mode != mode) {
++				dev_err(rsz_device,
++					"Operation mode doesn't match"
++					" with current hw mode\n");
++				ret = -EINVAL;
++				goto ERROR;
++			}
++
++			ret = mutex_lock_interruptible(&(rsz_conf_chan->lock));
++			if (!ret) {
++				rsz_conf_chan->mode = mode;
++				mutex_unlock(&(rsz_conf_chan->lock));
++			}
++			dev_dbg(rsz_device,
++				"RSZ_S_OPER_MODE: Operation mode set to %d",
++				user_mode);
++		}
++		break;
++		/* if case is to query for buffer address */
++	case RSZ_G_OPER_MODE:
++		{
++			dev_dbg(rsz_device, "RSZ_G_OPER_MODE:\n");
++			*((unsigned long *)arg) = rsz_conf_chan->mode;
++			dev_dbg(rsz_device,
++				"RSZ_G_OPER_MODE: mode = %d",
++				rsz_conf_chan->mode);
++		}
++		break;
++
++	case RSZ_S_CONFIG:
++		{
++			dev_dbg(rsz_device, "RSZ_S_CONFIG:\n");
++			ret = mutex_lock_interruptible(&(rsz_conf_chan->lock));
++			if (!ret) {
++				ret = imp_set_resizer_config(rsz_device,
++						     rsz_conf_chan,
++						     (struct rsz_channel_config
++						      *)arg);
++				mutex_unlock(&(rsz_conf_chan->lock));
++			}
++		}
++		break;
++
++	case RSZ_G_CONFIG:
++		{
++			struct rsz_channel_config *user_config =
++			    (struct rsz_channel_config *)arg;
++
++			dev_err(rsz_device, "RSZ_G_CONFIG:%d:%d:%d\n",
++				user_config->oper_mode, user_config->chain,
++				user_config->len);
++			if (ISNULL(user_config->config)) {
++				ret = -EINVAL;
++				dev_err(rsz_device,
++					"error in PREV_GET_CONFIG\n");
++				goto ERROR;
++			}
++			ret =
++			    imp_get_resize_config(rsz_device, rsz_conf_chan,
++						  user_config);
++		}
++		break;
++
++	case RSZ_QUERYBUF:
++		{
++			dev_dbg(rsz_device, "RSZ_QUERYBUF:\n");
++			ret = mutex_lock_interruptible(&(rsz_conf_chan->lock));
++			if (!ret) {
++				ret = imp_common_query_buffer(rsz_device,
++						      rsz_conf_chan,
++						      (struct imp_buffer *)arg);
++				mutex_unlock(&(rsz_conf_chan->lock));
++			}
++		}
++		break;
++
++		/* if case is to request buffers */
++	case RSZ_REQBUF:
++		{
++			dev_dbg(rsz_device, "RSZ_REQBUF:\n");
++			ret = mutex_lock_interruptible(&(rsz_conf_chan->lock));
++			if (!ret) {
++				ret = imp_common_request_buffer(rsz_device,
++							rsz_conf_chan,
++							(struct imp_reqbufs *)
++							arg);
++				mutex_unlock(&(rsz_conf_chan->lock));
++			}
++		}
++		break;
++		/* if the case is to do resize */
++	case RSZ_S_PRIORITY:
++		{
++			prio = *((unsigned long *)arg);
++
++			dev_dbg(rsz_device, "RSZ_S_PRIORITY: priority = %d\n",
++				prio);
++			/* Check the prioroty range and assign the priority */
++			if (prio > MAX_PRIORITY || prio < MIN_PRIORITY) {
++				ret = -EINVAL;
++				goto ERROR;
++			} else {
++				ret = mutex_lock_interruptible(
++					&(rsz_conf_chan->lock));
++				if (!ret) {
++					rsz_conf_chan->priority = prio;
++					mutex_unlock(&(rsz_conf_chan->lock));
++				}
++			}
++			dev_dbg(rsz_device, "\n resizer_Priority:end");
++		}
++		break;
++		/* This ioctl is used to get the priority of
++		   the current logic channel */
++	case RSZ_G_PRIORITY:
++		{
++			dev_dbg(rsz_device, "RSZ_S_PRIORITY: \n");
++			/* Get the priority     from the channel */
++			*((unsigned long *)arg) = rsz_conf_chan->priority;
++		}
++		break;
++
++	case RSZ_RESIZE:
++		{
++			dev_dbg(rsz_device, "RSZ_RESIZE: \n");
++			ret = mutex_lock_interruptible(&(rsz_conf_chan->lock));
++			if (!ret) {
++				ret = imp_common_start_resize(rsz_device,
++						      rsz_conf_chan,
++						      (struct imp_convert *)
++						      arg);
++				mutex_unlock(&(rsz_conf_chan->lock));
++			}
++		}
++		break;
++
++	case RSZ_RECONFIG:
++		{
++			dev_dbg(rsz_device, "RSZ_RECONFIG: \n");
++			ret = mutex_lock_interruptible(&(rsz_conf_chan->lock));
++			if (!ret) {
++				ret = imp_common_reconfig_resizer(rsz_device,
++						(struct rsz_reconfig *)arg,
++						 rsz_conf_chan);
++				mutex_unlock(&(rsz_conf_chan->lock));
++			}
++		}
++		break;
++
++#ifdef CONFIG_IMP_DEBUG
++	case RSZ_DUMP_HW_CONFIG:
++		{
++			dev_dbg(rsz_device, "RSZ_DUMP_HW_CONFIG: \n");
++			ret = mutex_lock_interruptible(&(rsz_conf_chan->lock));
++			if (!ret) {
++				if (imp_hw_if->dump_hw_config)
++					imp_hw_if->dump_hw_config();
++				mutex_unlock(&(rsz_conf_chan->lock));
++			}
++		}
++		break;
++#endif
++	default:
++		dev_dbg(rsz_device, "resizer_ioctl: Invalid Command Value");
++		ret = -EINVAL;
++	}
++
++ERROR:
++	return ret;
++}				/*End of function IOCTL */
++
++static int rsz_ioctl(struct inode *inode, struct file *file,
++		     unsigned int cmd, unsigned long arg)
++{
++	int ret;
++	char sbuf[128];
++	void *mbuf = NULL;
++	void *parg = NULL;
++
++	dev_dbg(rsz_device, "Start of resizer ioctl\n");
++
++	/*  Copy arguments into temp kernel buffer  */
++	switch (_IOC_DIR(cmd)) {
++	case _IOC_NONE:
++		parg = NULL;
++		break;
++	case _IOC_READ:
++	case _IOC_WRITE:
++	case (_IOC_WRITE | _IOC_READ):
++		if (_IOC_SIZE(cmd) <= sizeof(sbuf))
++			parg = sbuf;
++		else {
++			/* too big to allocate from stack */
++			mbuf = kmalloc(_IOC_SIZE(cmd), GFP_KERNEL);
++			if (ISNULL(mbuf))
++				return -ENOMEM;
++			parg = mbuf;
++		}
++
++		ret = -EFAULT;
++		if (_IOC_DIR(cmd) & _IOC_WRITE)
++			if (copy_from_user(parg, (void __user *)arg,
++					   _IOC_SIZE(cmd)))
++				goto out;
++		break;
++	}
++
++	/* call driver */
++	ret = rsz_doioctl(inode, file, cmd, (unsigned long)parg);
++	if (ret == -ENOIOCTLCMD)
++		ret = -EINVAL;
++
++	/*  Copy results into user buffer  */
++	switch (_IOC_DIR(cmd)) {
++	case _IOC_READ:
++	case (_IOC_WRITE | _IOC_READ):
++		if (copy_to_user((void __user *)arg, parg, _IOC_SIZE(cmd)))
++			ret = -EFAULT;
++		break;
++	}
++out:
++	kfree(mbuf);
++
++	dev_dbg(rsz_device, "End of previewer ioctl\n");
++	return ret;
++}
++
++static struct file_operations rsz_fops = {
++	.owner = THIS_MODULE,
++	.open = rsz_open,
++	.release = rsz_release,
++	.mmap = rsz_mmap,
++	.ioctl = rsz_ioctl,
++};
++
++static void resizer_platform_release(struct device *device)
++{
++	/* This is called when the reference count goes to zero */
++}
++
++static __init int resizer_probe(struct device *device)
++{
++	rsz_device = device;
++	return 0;
++}
++static int resizer_remove(struct device *device)
++{
++	return 0;
++}
++static struct class *rsz_class;
++
++static struct platform_device resizer_device = {
++	.name = "davinci_resizer",
++	.id = 2,
++	.dev = {
++		.release = resizer_platform_release,
++	}
++};
++
++static struct device_driver resizer_driver = {
++	.name = "davinci_resizer",
++	.bus = &platform_bus_type,
++	.probe = resizer_probe,
++	.remove = resizer_remove,
++};
++
++/*
++=====================rsz_init===========================
++function to	register resizer character driver
++*/
++static __init int rsz_init(void)
++{
++
++	int result;
++
++	/* Register     the     driver in the kernel */
++
++	result = alloc_chrdev_region(&dev, 0, 1, DRIVER_NAME);
++	if (result < 0) {
++		printk(KERN_ERR
++		       "DaVinciresizer: could not register character device");
++		return -ENODEV;
++	}
++	/* Initialize of character device */
++	cdev_init(&c_dev, &rsz_fops);
++	c_dev.owner = THIS_MODULE;
++	c_dev.ops = &rsz_fops;
++
++	/* addding character device */
++	result = cdev_add(&c_dev, dev, 1);
++
++	if (result) {
++		printk(KERN_ERR
++		       "DaVinciresizer:Error %d adding"
++			" Davinciresizer ..error no:",
++		       result);
++		unregister_chrdev_region(dev, 1);
++		return result;
++	}
++
++	/* registeration of     character device */
++	register_chrdev(MAJOR(dev), DRIVER_NAME, &rsz_fops);
++
++	/* register driver as a platform driver */
++	if (driver_register(&resizer_driver) != 0) {
++		unregister_chrdev_region(dev, 1);
++		cdev_del(&c_dev);
++		return -EINVAL;
++	}
++
++	/* Register the drive as a platform device */
++	if (platform_device_register(&resizer_device) != 0) {
++		driver_unregister(&resizer_driver);
++		unregister_chrdev_region(dev, 1);
++		unregister_chrdev(MAJOR(dev), DRIVER_NAME);
++		cdev_del(&c_dev);
++		return -EINVAL;
++	}
++
++	rsz_class = class_create(THIS_MODULE, "davinci_resizer");
++
++	if (!rsz_class) {
++
++		platform_device_unregister(&resizer_device);
++		cdev_del(&c_dev);
++		unregister_chrdev(MAJOR(dev), DRIVER_NAME);
++
++		return -EIO;
++	}
++
++	device_create(rsz_class, NULL, dev, NULL, "davinci_resizer");
++
++	rsz_dev.users = 0;
++
++	mutex_init(&rsz_dev.lock);
++	/* Initialize the serializer */
++	imp_init_serializer();
++	imp_hw_if = imp_get_hw_if();
++	printk(KERN_NOTICE "davinci_resizer initialized\n");
++	return 0;
++}				/* End   of function  resizer_init */
++
++/*
++=====================rsz_cleanup===========================
++Function	is called by the kernel. It	unregister the device.
++*/
++void __exit rsz_cleanup(void)
++{
++
++	unregister_chrdev_region(dev, 1);
++
++	device_destroy(rsz_class, dev);
++
++	class_destroy(rsz_class);
++
++	driver_unregister(&resizer_driver);
++
++	/* remove platform device */
++	platform_device_unregister(&resizer_device);
++
++	cdev_del(&c_dev);
++
++	/* unregistering the driver     from the kernel */
++	unregister_chrdev(MAJOR(dev), DRIVER_NAME);
++
++}				/* End  of function   resizer_cleanup */
++
++module_init(rsz_init);
++module_exit(rsz_cleanup);
++
++MODULE_LICENSE("GPL");
+--- a/arch/arm/mach-davinci/clock.h
++++ b/arch/arm/mach-davinci/clock.h
+@@ -22,6 +22,10 @@
+ /* PLL/Reset register offsets */
+ #define PLLCTL          0x100
+ #define PLLCTL_PLLEN    BIT(0)
++#define PLLCTL_PLLPWRDN	BIT(1)
++#define PLLCTL_PLLRST	BIT(3)
++#define PLLCTL_PLLDIS	BIT(4)
++#define PLLCTL_PLLENSRC	BIT(5)
+ #define PLLCTL_CLKMODE  BIT(8)
+ 
+ #define PLLM		0x110
+@@ -65,15 +69,20 @@ struct clk {
+ 	const char		*name;
+ 	unsigned long		rate;
+ 	u8			usecount;
+-	u8			flags;
+ 	u8			lpsc;
+ 	u8			psc_ctlr;
++	u32			flags;
+ 	struct clk              *parent;
++	struct list_head	children; 	/* list of children */
++	struct list_head	childnode;	/* parent's child list node */
+ 	struct pll_data         *pll_data;
+ 	u32                     div_reg;
++	unsigned long (*recalc) (struct clk *);
++	int (*set_rate) (struct clk *clk, unsigned long rate);
++	int (*round_rate) (struct clk *clk, unsigned long rate);
+ };
+ 
+-/* Clock flags */
++/* Clock flags: SoC-specific flags start at BIT(16) */
+ #define ALWAYS_ENABLED		BIT(1)
+ #define CLK_PSC                 BIT(2)
+ #define PSC_DSP                 BIT(3) /* PSC uses DSP domain, not ARM */
+@@ -94,6 +103,8 @@ struct davinci_clk {
+ 	}
+ 
+ int davinci_clk_init(struct davinci_clk *clocks);
++int davinci_set_pllrate(struct pll_data *pll, unsigned int prediv,
++				unsigned int mult, unsigned int postdiv);
+ 
+ extern struct platform_device davinci_wdt_device;
+ 
+--- a/sound/soc/davinci/davinci-sffsdr.c
++++ b/sound/soc/davinci/davinci-sffsdr.c
+@@ -29,7 +29,7 @@
+ #include <asm/plat-sffsdr/sffsdr-fpga.h>
+ #endif
+ 
+-#include <mach/mcbsp.h>
++#include <mach/asp.h>
+ #include <mach/edma.h>
+ 
+ #include "../codecs/pcm3008.h"
+@@ -63,8 +63,13 @@ static int sffsdr_hw_params(struct snd_p
+ 	}
+ #endif
+ 
+-	/* set cpu DAI configuration */
+-	ret = snd_soc_dai_set_fmt(cpu_dai, AUDIO_FORMAT);
++	/* Set cpu DAI configuration:
++	 * CLKX and CLKR are the inputs for the Sample Rate Generator.
++	 * FSX and FSR are outputs, driven by the sample Rate Generator. */
++	ret = snd_soc_dai_set_fmt(cpu_dai,
++				  SND_SOC_DAIFMT_RIGHT_J |
++				  SND_SOC_DAIFMT_CBM_CFS |
++				  SND_SOC_DAIFMT_IB_NF);
+ 	if (ret < 0)
+ 		return ret;
+ 
+@@ -115,15 +120,15 @@ static struct snd_soc_device sffsdr_snd_
+ 
+ static struct resource sffsdr_snd_resources[] = {
+ 	{
+-		.start = DAVINCI_MCBSP_BASE,
+-		.end = DAVINCI_MCBSP_BASE + SZ_8K - 1,
++		.start = DAVINCI_ASP0_BASE,
++		.end = DAVINCI_ASP0_BASE + SZ_8K - 1,
+ 		.flags = IORESOURCE_MEM,
+ 	},
+ };
+ 
+ static struct evm_snd_platform_data sffsdr_snd_data = {
+-	.tx_dma_ch	= DAVINCI_DMA_MCBSP_TX,
+-	.rx_dma_ch	= DAVINCI_DMA_MCBSP_RX,
++	.tx_dma_ch	= DAVINCI_DMA_ASP0_TX,
++	.rx_dma_ch	= DAVINCI_DMA_ASP0_RX,
+ };
+ 
+ static struct platform_device *sffsdr_snd_device;
+--- /dev/null
++++ b/drivers/mmc/host/davinci_mmc.c
+@@ -0,0 +1,1409 @@
++/*
++ * davinci_mmc.c - TI DaVinci MMC/SD/SDIO driver
++ *
++ * Copyright (C) 2006 Texas Instruments.
++ *       Original author: Purushotam Kumar
++ * Copyright (C) 2009 David Brownell
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
++ */
++
++#include <linux/module.h>
++#include <linux/ioport.h>
++#include <linux/platform_device.h>
++#include <linux/clk.h>
++#include <linux/err.h>
++#include <linux/mmc/host.h>
++#include <linux/io.h>
++#include <linux/irq.h>
++#include <linux/delay.h>
++#include <linux/dma-mapping.h>
++#include <linux/mmc/mmc.h>
++#include <linux/mmc/card.h>
++
++#include <mach/mmc.h>
++#include <mach/edma.h>
++
++/*
++ * Register Definitions
++ */
++#define DAVINCI_MMCCTL       0x00 /* Control Register                  */
++#define DAVINCI_MMCCLK       0x04 /* Memory Clock Control Register     */
++#define DAVINCI_MMCST0       0x08 /* Status Register 0                 */
++#define DAVINCI_MMCST1       0x0C /* Status Register 1                 */
++#define DAVINCI_MMCIM        0x10 /* Interrupt Mask Register           */
++#define DAVINCI_MMCTOR       0x14 /* Response Time-Out Register        */
++#define DAVINCI_MMCTOD       0x18 /* Data Read Time-Out Register       */
++#define DAVINCI_MMCBLEN      0x1C /* Block Length Register             */
++#define DAVINCI_MMCNBLK      0x20 /* Number of Blocks Register         */
++#define DAVINCI_MMCNBLC      0x24 /* Number of Blocks Counter Register */
++#define DAVINCI_MMCDRR       0x28 /* Data Receive Register             */
++#define DAVINCI_MMCDXR       0x2C /* Data Transmit Register            */
++#define DAVINCI_MMCCMD       0x30 /* Command Register                  */
++#define DAVINCI_MMCARGHL     0x34 /* Argument Register                 */
++#define DAVINCI_MMCRSP01     0x38 /* Response Register 0 and 1         */
++#define DAVINCI_MMCRSP23     0x3C /* Response Register 0 and 1         */
++#define DAVINCI_MMCRSP45     0x40 /* Response Register 0 and 1         */
++#define DAVINCI_MMCRSP67     0x44 /* Response Register 0 and 1         */
++#define DAVINCI_MMCDRSP      0x48 /* Data Response Register            */
++#define DAVINCI_MMCETOK      0x4C
++#define DAVINCI_MMCCIDX      0x50 /* Command Index Register            */
++#define DAVINCI_MMCCKC       0x54
++#define DAVINCI_MMCTORC      0x58
++#define DAVINCI_MMCTODC      0x5C
++#define DAVINCI_MMCBLNC      0x60
++#define DAVINCI_SDIOCTL      0x64
++#define DAVINCI_SDIOST0      0x68
++#define DAVINCI_SDIOIEN      0x6C
++#define DAVINCI_SDIOIST      0x70
++#define DAVINCI_MMCFIFOCTL   0x74 /* FIFO Control Register             */
++
++/* DAVINCI_MMCCTL definitions */
++#define MMCCTL_DATRST         (1 << 0)
++#define MMCCTL_CMDRST         (1 << 1)
++#define MMCCTL_WIDTH_4_BIT    (1 << 2)
++#define MMCCTL_DATEG_DISABLED (0 << 6)
++#define MMCCTL_DATEG_RISING   (1 << 6)
++#define MMCCTL_DATEG_FALLING  (2 << 6)
++#define MMCCTL_DATEG_BOTH     (3 << 6)
++#define MMCCTL_PERMDR_LE      (0 << 9)
++#define MMCCTL_PERMDR_BE      (1 << 9)
++#define MMCCTL_PERMDX_LE      (0 << 10)
++#define MMCCTL_PERMDX_BE      (1 << 10)
++
++/* DAVINCI_MMCCLK definitions */
++#define MMCCLK_CLKEN          (1 << 8)
++#define MMCCLK_CLKRT_MASK     (0xFF << 0)
++
++/* IRQ bit definitions, for DAVINCI_MMCST0 and DAVINCI_MMCIM */
++#define MMCST0_DATDNE         BIT(0)	/* data done */
++#define MMCST0_BSYDNE         BIT(1)	/* busy done */
++#define MMCST0_RSPDNE         BIT(2)	/* command done */
++#define MMCST0_TOUTRD         BIT(3)	/* data read timeout */
++#define MMCST0_TOUTRS         BIT(4)	/* command response timeout */
++#define MMCST0_CRCWR          BIT(5)	/* data write CRC error */
++#define MMCST0_CRCRD          BIT(6)	/* data read CRC error */
++#define MMCST0_CRCRS          BIT(7)	/* command response CRC error */
++#define MMCST0_DXRDY          BIT(9)	/* data transmit ready (fifo empty) */
++#define MMCST0_DRRDY          BIT(10)	/* data receive ready (data in fifo)*/
++#define MMCST0_DATED          BIT(11)	/* DAT3 edge detect */
++#define MMCST0_TRNDNE         BIT(12)	/* transfer done */
++
++#define MMCST0_ERR_MASK         (0x00F8)
++
++/* DAVINCI_MMCST1 definitions */
++#define MMCST1_BUSY           (1 << 0)
++
++/* DAVINCI_MMCCMD definitions */
++#define MMCCMD_CMD_MASK       (0x3F << 0)
++#define MMCCMD_PPLEN          (1 << 7)
++#define MMCCMD_BSYEXP         (1 << 8)
++#define MMCCMD_RSPFMT_MASK    (3 << 9)
++#define MMCCMD_RSPFMT_NONE    (0 << 9)
++#define MMCCMD_RSPFMT_R1456   (1 << 9)
++#define MMCCMD_RSPFMT_R2      (2 << 9)
++#define MMCCMD_RSPFMT_R3      (3 << 9)
++#define MMCCMD_DTRW           (1 << 11)
++#define MMCCMD_STRMTP         (1 << 12)
++#define MMCCMD_WDATX          (1 << 13)
++#define MMCCMD_INITCK         (1 << 14)
++#define MMCCMD_DCLR           (1 << 15)
++#define MMCCMD_DMATRIG        (1 << 16)
++
++/* DAVINCI_MMCFIFOCTL definitions */
++#define MMCFIFOCTL_FIFORST    (1 << 0)
++#define MMCFIFOCTL_FIFODIR_WR (1 << 1)
++#define MMCFIFOCTL_FIFODIR_RD (0 << 1)
++#define MMCFIFOCTL_FIFOLEV    (1 << 2) /* 0 = 128 bits, 1 = 256 bits */
++#define MMCFIFOCTL_ACCWD_4    (0 << 3) /* access width of 4 bytes    */
++#define MMCFIFOCTL_ACCWD_3    (1 << 3) /* access width of 3 bytes    */
++#define MMCFIFOCTL_ACCWD_2    (2 << 3) /* access width of 2 bytes    */
++#define MMCFIFOCTL_ACCWD_1    (3 << 3) /* access width of 1 byte     */
++
++
++/* MMCSD Init clock in Hz in opendrain mode */
++#define MMCSD_INIT_CLOCK		200000
++
++/* DAVINCI_SDIOCTL definitions */
++#define SDIOCTL_RDWTRQ_SET	  BIT(0)
++#define SDIOCTL_RDWTCR_SET	  BIT(1)
++
++/* DAVINCI_SDIOST0 definitions */
++#define SDIOST0_DAT1_HI		  BIT(0)
++#define SDIOST0_INTPRD		  BIT(1)
++#define SDIOST0_RDWTST		  BIT(2)
++
++/* DAVINCI_SDIOIEN definitions */
++#define SDIOIEN_IOINTEN		  BIT(0)
++#define SDIOIEN_RWSEN		  BIT(1)
++
++/* DAVINCI_SDIOIST definitions */
++#define SDIOIST_IOINT		  BIT(0)
++#define SDIOIST_RWS			  BIT(1)
++
++/*
++ * One scatterlist dma "segment" is at most MAX_CCNT rw_threshold units,
++ * and we handle up to NR_SG segments.  MMC_BLOCK_BOUNCE kicks in only
++ * for drivers with max_hw_segs == 1, making the segments bigger (64KB)
++ * than the page or two that's otherwise typical.  NR_SG == 16 gives at
++ * least the same throughput boost, using EDMA transfer linkage instead
++ * of spending CPU time copying pages.
++ */
++#define MAX_CCNT	((1 << 16) - 1)
++
++#define NR_SG		16
++
++#define DM355_SDIO_IRQ(deviceId)             \
++    (((deviceId) == 0) ? "sdio0" : "sdio1")
++
++static unsigned rw_threshold = 32;
++module_param(rw_threshold, uint, S_IRUGO);
++MODULE_PARM_DESC(rw_threshold,
++		"Read/Write threshold. Default = 32");
++
++static unsigned __initdata use_dma = 1;
++module_param(use_dma, uint, 0);
++MODULE_PARM_DESC(use_dma, "Whether to use DMA or not. Default = 1");
++
++struct mmc_davinci_host {
++	struct mmc_command *cmd;
++	struct mmc_data *data;
++	struct mmc_host *mmc;
++	struct clk *clk;
++	unsigned int mmc_input_clk;
++	void __iomem *base;
++	struct resource *mem_res;
++	int mmc_irq, sdio_irq;
++	unsigned char bus_mode;
++
++#define DAVINCI_MMC_DATADIR_NONE	0
++#define DAVINCI_MMC_DATADIR_READ	1
++#define DAVINCI_MMC_DATADIR_WRITE	2
++	unsigned char data_dir;
++
++	/* buffer is used during PIO of one scatterlist segment, and
++	 * is updated along with buffer_bytes_left.  bytes_left applies
++	 * to all N blocks of the PIO transfer.
++	 */
++	u8 *buffer;
++	u32 buffer_bytes_left;
++	u32 bytes_left;
++
++	u32 rxdma, txdma;
++	bool use_dma;
++	bool do_dma;
++	u32 sdio_int;
++
++	/* Scatterlist DMA uses one or more parameter RAM entries:
++	 * the main one (associated with rxdma or txdma) plus zero or
++	 * more links.  The entries for a given transfer differ only
++	 * by memory buffer (address, length) and link field.
++	 */
++	struct edmacc_param	tx_template;
++	struct edmacc_param	rx_template;
++	unsigned		n_link;
++	u32			links[NR_SG - 1];
++
++	/* For PIO we walk scatterlists one segment at a time. */
++	unsigned int		sg_len;
++	struct scatterlist *sg;
++
++	/* Version of the MMC/SD controller */
++	u8 version;
++	/* for ns in one cycle calculation */
++	unsigned ns_in_one_cycle;
++};
++
++
++/* PIO only */
++static void mmc_davinci_sg_to_buf(struct mmc_davinci_host *host)
++{
++	host->buffer_bytes_left = sg_dma_len(host->sg);
++	host->buffer = sg_virt(host->sg);
++	if (host->buffer_bytes_left > host->bytes_left)
++		host->buffer_bytes_left = host->bytes_left;
++}
++
++static void davinci_fifo_data_trans(struct mmc_davinci_host *host,
++					unsigned int n)
++{
++	u8 *p;
++	unsigned int i;
++
++	if (host->buffer_bytes_left == 0) {
++		host->sg = sg_next(host->data->sg);
++		mmc_davinci_sg_to_buf(host);
++	}
++
++	p = host->buffer;
++	if (n > host->buffer_bytes_left)
++		n = host->buffer_bytes_left;
++	host->buffer_bytes_left -= n;
++	host->bytes_left -= n;
++
++	/* NOTE:  we never transfer more than rw_threshold bytes
++	 * to/from the fifo here; there's no I/O overlap.
++	 * This also assumes that access width( i.e. ACCWD) is 4 bytes
++	 */
++	if (host->data_dir == DAVINCI_MMC_DATADIR_WRITE) {
++		for (i = 0; i < (n >> 2); i++) {
++			writel(*((u32 *)p), host->base + DAVINCI_MMCDXR);
++			p = p + 4;
++		}
++		if (n & 3) {
++			iowrite8_rep(host->base + DAVINCI_MMCDXR, p, (n & 3));
++			p = p + (n & 3);
++		}
++	} else {
++		for (i = 0; i < (n >> 2); i++) {
++			*((u32 *)p) = readl(host->base + DAVINCI_MMCDRR);
++			p  = p + 4;
++		}
++		if (n & 3) {
++			ioread8_rep(host->base + DAVINCI_MMCDRR, p, (n & 3));
++			p = p + (n & 3);
++		}
++	}
++	host->buffer = p;
++}
++
++static void mmc_davinci_start_command(struct mmc_davinci_host *host,
++		struct mmc_command *cmd)
++{
++	u32 cmd_reg = 0;
++	u32 im_val;
++
++	dev_dbg(mmc_dev(host->mmc), "CMD%d, arg 0x%08x%s\n",
++		cmd->opcode, cmd->arg,
++		({ char *s;
++		switch (mmc_resp_type(cmd)) {
++		case MMC_RSP_R1:
++			s = ", R1/R5/R6/R7 response";
++			break;
++		case MMC_RSP_R1B:
++			s = ", R1b response";
++			break;
++		case MMC_RSP_R2:
++			s = ", R2 response";
++			break;
++		case MMC_RSP_R3:
++			s = ", R3/R4 response";
++			break;
++		default:
++			s = ", (R? response)";
++			break;
++		}; s; }));
++	host->cmd = cmd;
++
++	switch (mmc_resp_type(cmd)) {
++	case MMC_RSP_R1B:
++		/* There's some spec confusion about when R1B is
++		 * allowed, but if the card doesn't issue a BUSY
++		 * then it's harmless for us to allow it.
++		 */
++		cmd_reg |= MMCCMD_BSYEXP;
++		/* FALLTHROUGH */
++	case MMC_RSP_R1:		/* 48 bits, CRC */
++		cmd_reg |= MMCCMD_RSPFMT_R1456;
++		break;
++	case MMC_RSP_R2:		/* 136 bits, CRC */
++		cmd_reg |= MMCCMD_RSPFMT_R2;
++		break;
++	case MMC_RSP_R3:		/* 48 bits, no CRC */
++		cmd_reg |= MMCCMD_RSPFMT_R3;
++		break;
++	default:
++		cmd_reg |= MMCCMD_RSPFMT_NONE;
++		dev_dbg(mmc_dev(host->mmc), "unknown resp_type %04x\n",
++			mmc_resp_type(cmd));
++		break;
++	}
++
++	/* Set command index */
++	cmd_reg |= cmd->opcode;
++
++	/* Enable EDMA transfer triggers */
++	if (host->do_dma)
++		cmd_reg |= MMCCMD_DMATRIG;
++
++	if (host->version == MMC_CTLR_VERSION_2 && host->data != NULL &&
++			host->data_dir == DAVINCI_MMC_DATADIR_READ)
++		cmd_reg |= MMCCMD_DMATRIG;
++
++	/* Setting whether command involves data transfer or not */
++	if (cmd->data)
++		cmd_reg |= MMCCMD_WDATX;
++
++	/* Setting whether stream or block transfer */
++	if (cmd->flags & MMC_DATA_STREAM)
++		cmd_reg |= MMCCMD_STRMTP;
++
++	/* Setting whether data read or write */
++	if (host->data_dir == DAVINCI_MMC_DATADIR_WRITE)
++		cmd_reg |= MMCCMD_DTRW;
++
++	if (host->bus_mode == MMC_BUSMODE_PUSHPULL)
++		cmd_reg |= MMCCMD_PPLEN;
++
++	/* set Command timeout */
++	writel(0x1FFF, host->base + DAVINCI_MMCTOR);
++
++	/* Enable interrupt (calculate here, defer until FIFO is stuffed). */
++	im_val =  MMCST0_RSPDNE | MMCST0_CRCRS | MMCST0_TOUTRS;
++	if (host->data_dir == DAVINCI_MMC_DATADIR_WRITE) {
++		im_val |= MMCST0_DATDNE | MMCST0_CRCWR;
++
++		if (!host->do_dma)
++			im_val |= MMCST0_DXRDY;
++	} else if (host->data_dir == DAVINCI_MMC_DATADIR_READ) {
++		im_val |= MMCST0_DATDNE | MMCST0_CRCRD | MMCST0_TOUTRD;
++
++		if (!host->do_dma)
++			im_val |= MMCST0_DRRDY;
++	}
++
++	/*
++	 * Before non-DMA WRITE commands the controller needs priming:
++	 * FIFO should be populated with 32 bytes i.e. whatever is the FIFO size
++	 */
++	if (!host->do_dma && (host->data_dir == DAVINCI_MMC_DATADIR_WRITE))
++		davinci_fifo_data_trans(host, rw_threshold);
++
++	writel(cmd->arg, host->base + DAVINCI_MMCARGHL);
++	writel(cmd_reg,  host->base + DAVINCI_MMCCMD);
++	writel(im_val, host->base + DAVINCI_MMCIM);
++}
++
++/*----------------------------------------------------------------------*/
++
++/* DMA infrastructure */
++
++static void davinci_abort_dma(struct mmc_davinci_host *host)
++{
++	int sync_dev;
++
++	if (host->data_dir == DAVINCI_MMC_DATADIR_READ)
++		sync_dev = host->rxdma;
++	else
++		sync_dev = host->txdma;
++
++	edma_stop(sync_dev);
++	edma_clean_channel(sync_dev);
++}
++
++static void
++mmc_davinci_xfer_done(struct mmc_davinci_host *host, struct mmc_data *data);
++
++static void mmc_davinci_dma_cb(unsigned channel, u16 ch_status, void *data)
++{
++	if (DMA_COMPLETE != ch_status) {
++		struct mmc_davinci_host *host = data;
++
++		if (!(host->data)) {
++			dev_warn(mmc_dev(host->mmc),
++				"DMA Event Miss / NULL Transfr\n");
++			edma_stop(host->txdma);
++			edma_clean_channel(host->txdma);
++			edma_stop(host->rxdma);
++			edma_clean_channel(host->rxdma);
++			return;
++		}
++
++		/* Currently means:  DMA Event Missed, or "null" transfer
++		 * request was seen.  In the future, TC errors (like bad
++		 * addresses) might be presented too.
++		 */
++		dev_warn(mmc_dev(host->mmc), "DMA %s error\n",
++			(host->data->flags & MMC_DATA_WRITE)
++				? "write" : "read");
++		host->data->error = -EIO;
++		mmc_davinci_xfer_done(host, host->data);
++	}
++}
++
++/* Set up tx or rx template, to be modified and updated later */
++static void __init mmc_davinci_dma_setup(struct mmc_davinci_host *host,
++		bool tx, struct edmacc_param *template)
++{
++	unsigned	sync_dev;
++	const u16	acnt = 4;
++	const u16	bcnt = rw_threshold >> 2;
++	const u16	ccnt = 0;
++	u32		src_port = 0;
++	u32		dst_port = 0;
++	s16		src_bidx, dst_bidx;
++	s16		src_cidx, dst_cidx;
++
++	/*
++	 * A-B Sync transfer:  each DMA request is for one "frame" of
++	 * rw_threshold bytes, broken into "acnt"-size chunks repeated
++	 * "bcnt" times.  Each segment needs "ccnt" such frames; since
++	 * we tell the block layer our mmc->max_seg_size limit, we can
++	 * trust (later) that it's within bounds.
++	 *
++	 * The FIFOs are read/written in 4-byte chunks (acnt == 4) and
++	 * EDMA will optimize memory operations to use larger bursts.
++	 */
++	if (tx) {
++		sync_dev = host->txdma;
++
++		/* src_prt, ccnt, and link to be set up later */
++		src_bidx = acnt;
++		src_cidx = acnt * bcnt;
++
++		dst_port = host->mem_res->start + DAVINCI_MMCDXR;
++		dst_bidx = 0;
++		dst_cidx = 0;
++	} else {
++		sync_dev = host->rxdma;
++
++		src_port = host->mem_res->start + DAVINCI_MMCDRR;
++		src_bidx = 0;
++		src_cidx = 0;
++
++		/* dst_prt, ccnt, and link to be set up later */
++		dst_bidx = acnt;
++		dst_cidx = acnt * bcnt;
++	}
++
++	/*
++	 * We can't use FIFO mode for the FIFOs because MMC FIFO addresses
++	 * are not 256-bit (32-byte) aligned.  So we use INCR, and the W8BIT
++	 * parameter is ignored.
++	 */
++	edma_set_src(sync_dev, src_port, INCR, W8BIT);
++	edma_set_dest(sync_dev, dst_port, INCR, W8BIT);
++
++	edma_set_src_index(sync_dev, src_bidx, src_cidx);
++	edma_set_dest_index(sync_dev, dst_bidx, dst_cidx);
++
++	edma_set_transfer_params(sync_dev, acnt, bcnt, ccnt, 8, ABSYNC);
++
++	edma_read_slot(sync_dev, template);
++
++	/* don't bother with irqs or chaining */
++	template->opt |= EDMA_CHAN_SLOT(sync_dev) << 12;
++}
++
++static void mmc_davinci_send_dma_request(struct mmc_davinci_host *host,
++		struct mmc_data *data)
++{
++	struct edmacc_param	*template;
++	int			channel, slot;
++	unsigned		link;
++	struct scatterlist	*sg;
++	unsigned		sg_len;
++	unsigned		bytes_left = host->bytes_left;
++	const unsigned		shift = ffs(rw_threshold) - 1;;
++
++	if (host->data_dir == DAVINCI_MMC_DATADIR_WRITE) {
++		template = &host->tx_template;
++		channel = host->txdma;
++	} else {
++		template = &host->rx_template;
++		channel = host->rxdma;
++	}
++
++	/* We know sg_len and ccnt will never be out of range because
++	 * we told the mmc layer which in turn tells the block layer
++	 * to ensure that it only hands us one scatterlist segment
++	 * per EDMA PARAM entry.  Update the PARAM
++	 * entries needed for each segment of this scatterlist.
++	 */
++	for (slot = channel, link = 0, sg = data->sg, sg_len = host->sg_len;
++			sg_len-- != 0 && bytes_left;
++			sg = sg_next(sg), slot = host->links[link++]) {
++		u32		buf = sg_dma_address(sg);
++		unsigned	count = sg_dma_len(sg);
++
++		template->link_bcntrld = sg_len
++				? (EDMA_CHAN_SLOT(host->links[link]) << 5)
++				: 0xffff;
++
++		if (count > bytes_left)
++			count = bytes_left;
++		bytes_left -= count;
++
++		if (host->data_dir == DAVINCI_MMC_DATADIR_WRITE)
++			template->src = buf;
++		else
++			template->dst = buf;
++		template->ccnt = count >> shift;
++
++		edma_write_slot(slot, template);
++	}
++
++	if (host->version == MMC_CTLR_VERSION_2)
++		edma_clear_event(channel);
++
++	edma_start(channel);
++}
++
++static int mmc_davinci_start_dma_transfer(struct mmc_davinci_host *host,
++		struct mmc_data *data)
++{
++	int i;
++	int mask = rw_threshold - 1;
++
++	host->sg_len = dma_map_sg(mmc_dev(host->mmc), data->sg, data->sg_len,
++				((data->flags & MMC_DATA_WRITE)
++				? DMA_TO_DEVICE
++				: DMA_FROM_DEVICE));
++
++	/* no individual DMA segment should need a partial FIFO */
++	for (i = 0; i < host->sg_len; i++) {
++		if (sg_dma_len(data->sg + i) & mask) {
++			dma_unmap_sg(mmc_dev(host->mmc),
++					data->sg, data->sg_len,
++					(data->flags & MMC_DATA_WRITE)
++					? DMA_TO_DEVICE
++					: DMA_FROM_DEVICE);
++			return -1;
++		}
++	}
++
++	host->do_dma = 1;
++	mmc_davinci_send_dma_request(host, data);
++
++	return 0;
++}
++
++static void __init_or_module
++davinci_release_dma_channels(struct mmc_davinci_host *host)
++{
++	unsigned	i;
++
++	if (!host->use_dma)
++		return;
++
++	for (i = 0; i < host->n_link; i++)
++		edma_free_slot(host->links[i]);
++
++	edma_free_channel(host->txdma);
++	edma_free_channel(host->rxdma);
++}
++
++static int __init davinci_acquire_dma_channels(struct mmc_davinci_host *host)
++{
++	int r, i;
++
++	/* Acquire master DMA write channel */
++	r = edma_alloc_channel(host->txdma, mmc_davinci_dma_cb, host,
++			EVENTQ_DEFAULT);
++	if (r < 0) {
++		dev_warn(mmc_dev(host->mmc), "alloc %s channel err %d\n",
++				"tx", r);
++		return r;
++	}
++	mmc_davinci_dma_setup(host, true, &host->tx_template);
++
++	/* Acquire master DMA read channel */
++	r = edma_alloc_channel(host->rxdma, mmc_davinci_dma_cb, host,
++			EVENTQ_DEFAULT);
++	if (r < 0) {
++		dev_warn(mmc_dev(host->mmc), "alloc %s channel err %d\n",
++				"rx", r);
++		goto free_master_write;
++	}
++	mmc_davinci_dma_setup(host, false, &host->rx_template);
++
++	/* Allocate parameter RAM slots, which will later be bound to a
++	 * channel as needed to handle a scatterlist.
++	 */
++	for (i = 0; i < ARRAY_SIZE(host->links); i++) {
++		r = edma_alloc_slot(EDMA_CTLR(host->txdma), EDMA_SLOT_ANY);
++		if (r < 0) {
++			dev_dbg(mmc_dev(host->mmc), "dma PaRAM alloc --> %d\n",
++				r);
++			break;
++		}
++		host->links[i] = r;
++	}
++	host->n_link = i;
++
++	return 0;
++
++free_master_write:
++	edma_free_channel(host->txdma);
++
++	return r;
++}
++
++/*----------------------------------------------------------------------*/
++
++static void
++mmc_davinci_prepare_data(struct mmc_davinci_host *host, struct mmc_request *req)
++{
++	int fifo_lev = (rw_threshold == 32) ? MMCFIFOCTL_FIFOLEV : 0;
++	int timeout;
++	struct mmc_data *data = req->data;
++
++	if (host->version == MMC_CTLR_VERSION_2)
++		fifo_lev = (rw_threshold == 64) ? MMCFIFOCTL_FIFOLEV : 0;
++
++	host->data = data;
++	if (data == NULL) {
++		host->data_dir = DAVINCI_MMC_DATADIR_NONE;
++		writel(0, host->base + DAVINCI_MMCBLEN);
++		writel(0, host->base + DAVINCI_MMCNBLK);
++		return;
++	}
++
++	dev_dbg(mmc_dev(host->mmc), "%s %s, %d blocks of %d bytes\n",
++		(data->flags & MMC_DATA_STREAM) ? "stream" : "block",
++		(data->flags & MMC_DATA_WRITE) ? "write" : "read",
++		data->blocks, data->blksz);
++	dev_dbg(mmc_dev(host->mmc), "  DTO %d cycles + %d ns\n",
++		data->timeout_clks, data->timeout_ns);
++	timeout = data->timeout_clks +
++		(data->timeout_ns / host->ns_in_one_cycle);
++	if (timeout > 0xffff)
++		timeout = 0xffff;
++
++	writel(timeout, host->base + DAVINCI_MMCTOD);
++	writel(data->blocks, host->base + DAVINCI_MMCNBLK);
++	writel(data->blksz, host->base + DAVINCI_MMCBLEN);
++
++	/* Configure the FIFO */
++	switch (data->flags & MMC_DATA_WRITE) {
++	case MMC_DATA_WRITE:
++		host->data_dir = DAVINCI_MMC_DATADIR_WRITE;
++		writel(fifo_lev | MMCFIFOCTL_FIFODIR_WR | MMCFIFOCTL_FIFORST,
++			host->base + DAVINCI_MMCFIFOCTL);
++		writel(fifo_lev | MMCFIFOCTL_FIFODIR_WR,
++			host->base + DAVINCI_MMCFIFOCTL);
++		break;
++
++	default:
++		host->data_dir = DAVINCI_MMC_DATADIR_READ;
++		writel(fifo_lev | MMCFIFOCTL_FIFODIR_RD | MMCFIFOCTL_FIFORST,
++			host->base + DAVINCI_MMCFIFOCTL);
++		writel(fifo_lev | MMCFIFOCTL_FIFODIR_RD,
++			host->base + DAVINCI_MMCFIFOCTL);
++		break;
++	}
++
++	host->buffer = NULL;
++	host->bytes_left = data->blocks * data->blksz;
++
++	if (host->mmc->card) {
++		if (mmc_card_sdio(host->mmc->card)) {
++			if ((data->blksz == 64)) {
++				mdelay(5);
++			}
++		}
++	}
++
++	/* For now we try to use DMA whenever we won't need partial FIFO
++	 * reads or writes, either for the whole transfer (as tested here)
++	 * or for any individual scatterlist segment (tested when we call
++	 * start_dma_transfer).
++	 *
++	 * While we *could* change that, unusual block sizes are rarely
++	 * used.  The occasional fallback to PIO should't hurt.
++	 */
++	if (host->use_dma && (host->bytes_left & (rw_threshold - 1)) == 0
++			&& mmc_davinci_start_dma_transfer(host, data) == 0) {
++		/* zero this to ensure we take no PIO paths */
++		host->bytes_left = 0;
++	} else {
++		/* Revert to CPU Copy */
++		host->sg_len = data->sg_len;
++		host->sg = host->data->sg;
++		mmc_davinci_sg_to_buf(host);
++	}
++}
++
++static void mmc_davinci_request(struct mmc_host *mmc, struct mmc_request *req)
++{
++	struct mmc_davinci_host *host = mmc_priv(mmc);
++	unsigned long timeout = jiffies + msecs_to_jiffies(900);
++	u32 mmcst1 = 0;
++
++	/* Card may still be sending BUSY after a previous operation,
++	 * typically some kind of write.  If so, we can't proceed yet.
++	 */
++	while (time_before(jiffies, timeout)) {
++		mmcst1  = readl(host->base + DAVINCI_MMCST1);
++		if (!(mmcst1 & MMCST1_BUSY))
++			break;
++		cpu_relax();
++	}
++	if (mmcst1 & MMCST1_BUSY) {
++		dev_err(mmc_dev(host->mmc), "still BUSY? bad ... \n");
++		req->cmd->error = -ETIMEDOUT;
++		mmc_request_done(mmc, req);
++		return;
++	}
++
++	host->do_dma = 0;
++	mmc_davinci_prepare_data(host, req);
++	mmc_davinci_start_command(host, req->cmd);
++}
++
++static unsigned int calculate_freq_for_card(struct mmc_davinci_host *host,
++	unsigned int mmc_req_freq)
++{
++	unsigned int mmc_freq = 0, mmc_pclk = 0, mmc_push_pull_divisor = 0;
++
++	mmc_pclk = host->mmc_input_clk;
++	if (mmc_req_freq && mmc_pclk > (2 * mmc_req_freq))
++		mmc_push_pull_divisor = ((unsigned int)mmc_pclk
++				/ (2 * mmc_req_freq)) - 1;
++	else
++		mmc_push_pull_divisor = 0;
++
++	mmc_freq = (unsigned int)mmc_pclk
++		/ (2 * (mmc_push_pull_divisor + 1));
++
++	if (mmc_freq > mmc_req_freq)
++		mmc_push_pull_divisor = mmc_push_pull_divisor + 1;
++	/* Convert ns to clock cycles */
++	if (mmc_req_freq <= 400000)
++		host->ns_in_one_cycle = (1000000) / (((mmc_pclk
++				/ (2 * (mmc_push_pull_divisor + 1)))/1000));
++	else
++		host->ns_in_one_cycle = (1000000) / (((mmc_pclk
++				/ (2 * (mmc_push_pull_divisor + 1)))/1000000));
++
++	return mmc_push_pull_divisor;
++}
++
++static void mmc_davinci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
++{
++	unsigned int open_drain_freq = 0, mmc_pclk = 0;
++	unsigned int mmc_push_pull_freq = 0;
++	struct mmc_davinci_host *host = mmc_priv(mmc);
++
++	mmc_pclk = host->mmc_input_clk;
++	dev_dbg(mmc_dev(host->mmc),
++		"clock %dHz busmode %d powermode %d Vdd %04x\n",
++		ios->clock, ios->bus_mode, ios->power_mode,
++		ios->vdd);
++	if (ios->bus_width == MMC_BUS_WIDTH_4) {
++		dev_dbg(mmc_dev(host->mmc), "Enabling 4 bit mode\n");
++		writel(readl(host->base + DAVINCI_MMCCTL) | MMCCTL_WIDTH_4_BIT,
++			host->base + DAVINCI_MMCCTL);
++	} else {
++		dev_dbg(mmc_dev(host->mmc), "Disabling 4 bit mode\n");
++		writel(readl(host->base + DAVINCI_MMCCTL) & ~MMCCTL_WIDTH_4_BIT,
++			host->base + DAVINCI_MMCCTL);
++	}
++
++	if (ios->bus_mode == MMC_BUSMODE_OPENDRAIN) {
++		u32 temp;
++
++		/* Ignoring the init clock value passed for fixing the inter
++		 * operability with different cards.
++		 */
++		open_drain_freq = ((unsigned int)mmc_pclk
++				/ (2 * MMCSD_INIT_CLOCK)) - 1;
++
++		if (open_drain_freq > 0xFF)
++			open_drain_freq = 0xFF;
++
++		temp = readl(host->base + DAVINCI_MMCCLK) & ~MMCCLK_CLKRT_MASK;
++		temp |= open_drain_freq;
++		writel(temp, host->base + DAVINCI_MMCCLK);
++
++		/* Convert ns to clock cycles */
++		host->ns_in_one_cycle = (1000000) / (MMCSD_INIT_CLOCK/1000);
++	} else {
++		u32 temp;
++		mmc_push_pull_freq = calculate_freq_for_card(host, ios->clock);
++
++		if (mmc_push_pull_freq > 0xFF)
++			mmc_push_pull_freq = 0xFF;
++
++		temp = readl(host->base + DAVINCI_MMCCLK) & ~MMCCLK_CLKEN;
++		writel(temp, host->base + DAVINCI_MMCCLK);
++
++		udelay(10);
++
++		temp = readl(host->base + DAVINCI_MMCCLK) & ~MMCCLK_CLKRT_MASK;
++		temp |= mmc_push_pull_freq;
++		writel(temp, host->base + DAVINCI_MMCCLK);
++
++		writel(temp | MMCCLK_CLKEN, host->base + DAVINCI_MMCCLK);
++
++		udelay(10);
++	}
++
++	host->bus_mode = ios->bus_mode;
++	if (ios->power_mode == MMC_POWER_UP) {
++		unsigned long timeout = jiffies + msecs_to_jiffies(50);
++		bool lose = true;
++
++		/* Send clock cycles, poll completion */
++		writel(0, host->base + DAVINCI_MMCARGHL);
++		writel(MMCCMD_INITCK, host->base + DAVINCI_MMCCMD);
++		while (time_before(jiffies, timeout)) {
++			u32 tmp = readl(host->base + DAVINCI_MMCST0);
++
++			if (tmp & MMCST0_RSPDNE) {
++				lose = false;
++				break;
++			}
++			cpu_relax();
++		}
++		if (lose)
++			dev_warn(mmc_dev(host->mmc), "powerup timeout\n");
++	}
++
++	/* FIXME on power OFF, reset things ... */
++}
++
++static void
++mmc_davinci_xfer_done(struct mmc_davinci_host *host, struct mmc_data *data)
++{
++	davinci_abort_dma(host);
++
++	if (host->mmc->caps & MMC_CAP_SDIO_IRQ) {
++		if (host->sdio_int && (!((readl(host->base + DAVINCI_SDIOST0))
++					& SDIOST0_DAT1_HI))) {
++			writel(SDIOIST_IOINT, host->base + DAVINCI_SDIOIST);
++			mmc_signal_sdio_irq(host->mmc);
++		}
++	}
++	host->data_dir = DAVINCI_MMC_DATADIR_NONE;
++
++	if (host->do_dma) {
++		dma_unmap_sg(mmc_dev(host->mmc), data->sg, data->sg_len,
++			     (data->flags & MMC_DATA_WRITE)
++			     ? DMA_TO_DEVICE
++			     : DMA_FROM_DEVICE);
++		host->do_dma = false;
++	}
++
++	host->data = NULL;
++	host->data_dir = DAVINCI_MMC_DATADIR_NONE;
++
++	if (!data->stop || (host->cmd && host->cmd->error)) {
++		mmc_request_done(host->mmc, data->mrq);
++		writel(0, host->base + DAVINCI_MMCIM);
++	} else
++		mmc_davinci_start_command(host, data->stop);
++}
++
++static void mmc_davinci_cmd_done(struct mmc_davinci_host *host,
++				 struct mmc_command *cmd)
++{
++	host->cmd = NULL;
++
++	if (cmd->flags & MMC_RSP_PRESENT) {
++		if (cmd->flags & MMC_RSP_136) {
++			/* response type 2 */
++			cmd->resp[3] = readl(host->base + DAVINCI_MMCRSP01);
++			cmd->resp[2] = readl(host->base + DAVINCI_MMCRSP23);
++			cmd->resp[1] = readl(host->base + DAVINCI_MMCRSP45);
++			cmd->resp[0] = readl(host->base + DAVINCI_MMCRSP67);
++		} else {
++			/* response types 1, 1b, 3, 4, 5, 6 */
++			cmd->resp[0] = readl(host->base + DAVINCI_MMCRSP67);
++		}
++	}
++
++	if (host->data == NULL || cmd->error) {
++		if (cmd->error == -ETIMEDOUT)
++			cmd->mrq->cmd->retries = 0;
++		mmc_request_done(host->mmc, cmd->mrq);
++		writel(0, host->base + DAVINCI_MMCIM);
++	}
++}
++
++static void
++davinci_abort_data(struct mmc_davinci_host *host, struct mmc_data *data)
++{
++	u32 temp;
++
++	/* reset command and data state machines */
++	temp = readl(host->base + DAVINCI_MMCCTL);
++	writel(temp | MMCCTL_CMDRST | MMCCTL_DATRST,
++		host->base + DAVINCI_MMCCTL);
++
++	temp &= ~(MMCCTL_CMDRST | MMCCTL_DATRST);
++	udelay(10);
++	writel(temp, host->base + DAVINCI_MMCCTL);
++}
++
++static irqreturn_t mmc_davinci_sdio_irq(int irq, void *dev_id)
++{
++	struct mmc_davinci_host *host = (struct mmc_davinci_host *)dev_id;
++	unsigned int status;
++
++	status = readl(host->base + DAVINCI_SDIOIST);
++	if (status & SDIOIST_IOINT) {
++		dev_dbg(mmc_dev(host->mmc),
++				"SDIO interrupt status %x\n", status);
++		writel(status | SDIOIST_IOINT,
++				host->base + DAVINCI_SDIOIST);
++		mmc_signal_sdio_irq(host->mmc);
++	}
++	return IRQ_HANDLED;
++}
++
++static irqreturn_t mmc_davinci_irq(int irq, void *dev_id)
++{
++	struct mmc_davinci_host *host = (struct mmc_davinci_host *)dev_id;
++	unsigned int status, qstatus;
++	int end_command = 0;
++	int end_transfer = 0;
++	struct mmc_data *data = host->data;
++
++	if (host->cmd == NULL && host->data == NULL) {
++		status = readl(host->base + DAVINCI_MMCST0);
++		dev_dbg(mmc_dev(host->mmc),
++			"Spurious interrupt 0x%04x\n", status);
++		/* Disable the interrupt from mmcsd */
++		writel(0, host->base + DAVINCI_MMCIM);
++		return IRQ_NONE;
++	}
++
++	status = readl(host->base + DAVINCI_MMCST0);
++	qstatus = status;
++
++	if (qstatus & MMCST0_ERR_MASK) {
++		if (qstatus & MMCST0_TOUTRD) {
++			/* Read data timeout */
++			data->error = -ETIMEDOUT;
++			end_transfer = 1;
++
++			dev_err(mmc_dev(host->mmc),
++					"read data timeout, status %x\n",
++					qstatus);
++
++			davinci_abort_data(host, data);
++			goto end_data;
++		}
++
++		if (qstatus & (MMCST0_CRCWR | MMCST0_CRCRD)) {
++			/* Data CRC error */
++			data->error = -EILSEQ;
++			end_transfer = 1;
++
++			/* NOTE:  this controller uses CRCWR to report both CRC
++			 * errors and timeouts (on writes).  MMCDRSP values are
++			 * only weakly documented, but 0x9f was clearly a
++			 * timeout case and the two three-bit patterns in
++			 * various SD specs (101, 010) aren't part of it ...
++			 */
++			if (qstatus & MMCST0_CRCWR) {
++				u32 temp = readb(host->base + DAVINCI_MMCDRSP);
++
++				if (temp == 0x9f)
++					data->error = -ETIMEDOUT;
++			}
++			dev_err(mmc_dev(host->mmc), "data %s %s error\n",
++				(qstatus & MMCST0_CRCWR) ? "write" :
++				"read",	(data->error == -ETIMEDOUT) ?
++				"timeout" : "CRC");
++
++			davinci_abort_data(host, data);
++			goto end_data;
++		}
++
++		if (qstatus & MMCST0_TOUTRS) {
++			/* Command timeout */
++			if (host->cmd) {
++				dev_dbg(mmc_dev(host->mmc),
++						"CMD%d timeout, status %x\n",
++						host->cmd->opcode, qstatus);
++				host->cmd->error = -ETIMEDOUT;
++				if (data) {
++					end_transfer = 1;
++					davinci_abort_data(host, data);
++				} else
++					end_command = 1;
++			}
++			goto end_cmd;
++		}
++
++		if (qstatus & MMCST0_CRCRS) {
++			/* Command CRC error */
++			dev_err(mmc_dev(host->mmc), "Command CRC error\n");
++			if (host->cmd) {
++				host->cmd->error = -EILSEQ;
++				end_command = 1;
++			}
++			goto end_cmd;
++		}
++	}
++
++	/* handle FIFO first when using PIO for data.
++	 * bytes_left will decrease to zero as I/O progress and status will
++	 * read zero over iteration because this controller status
++	 * register(MMCST0) reports any status only once and it is cleared
++	 * by read. So, it is not unbouned loop even in the case of
++	 * non-dma.
++	 */
++	while (host->bytes_left && (status & (MMCST0_DXRDY | MMCST0_DRRDY))) {
++		davinci_fifo_data_trans(host, rw_threshold);
++		status = readl(host->base + DAVINCI_MMCST0);
++		if (!status)
++			break;
++		qstatus |= status;
++	}
++
++	if (qstatus & MMCST0_RSPDNE) {
++		/* End of command phase */
++		end_command = (int) host->cmd;
++	}
++
++	if (qstatus & MMCST0_DATDNE) {
++		/* All blocks sent/received, and CRC checks passed */
++		if (data != NULL) {
++			if ((host->do_dma == 0) && (host->bytes_left > 0)) {
++				/* if datasize < rw_threshold
++				 * no RX ints are generated
++				 */
++				davinci_fifo_data_trans(host, host->bytes_left);
++			}
++			end_transfer = 1;
++			data->bytes_xfered = data->blocks * data->blksz;
++		} else {
++			dev_err(mmc_dev(host->mmc),
++					"DATDNE with no host->data\n");
++		}
++	}
++
++end_cmd:
++	if (end_command)
++		mmc_davinci_cmd_done(host, host->cmd);
++end_data:
++	if (end_transfer)
++		mmc_davinci_xfer_done(host, data);
++	return IRQ_HANDLED;
++}
++
++static int mmc_davinci_get_cd(struct mmc_host *mmc)
++{
++	struct platform_device *pdev = to_platform_device(mmc->parent);
++	struct davinci_mmc_config *config = pdev->dev.platform_data;
++
++	if (!config || !config->get_cd)
++		return -ENOSYS;
++	return config->get_cd(pdev->id);
++}
++
++static int mmc_davinci_get_ro(struct mmc_host *mmc)
++{
++	struct platform_device *pdev = to_platform_device(mmc->parent);
++	struct davinci_mmc_config *config = pdev->dev.platform_data;
++
++	if (!config || !config->get_ro)
++		return -ENOSYS;
++	return config->get_ro(pdev->id);
++}
++
++static void mmc_davinci_enable_sdio_irq(struct mmc_host *mmc, int enable)
++{
++	struct mmc_davinci_host *host = mmc_priv(mmc);
++
++	if (enable) {
++		if (!((readl(host->base + DAVINCI_SDIOST0))
++			    & SDIOST0_DAT1_HI)) {
++			writel(SDIOIST_IOINT,
++					host->base + DAVINCI_SDIOIST);
++			mmc_signal_sdio_irq(host->mmc);
++		} else {
++			host->sdio_int = 1;
++			writel(readl(host->base + DAVINCI_SDIOIEN) |
++				SDIOIEN_IOINTEN, host->base + DAVINCI_SDIOIEN);
++		}
++	} else {
++		host->sdio_int = 0;
++		writel(readl(host->base + DAVINCI_SDIOIEN) & ~SDIOIEN_IOINTEN,
++				host->base + DAVINCI_SDIOIEN);
++	}
++
++}
++static struct mmc_host_ops mmc_davinci_ops = {
++	.request	= mmc_davinci_request,
++	.set_ios	= mmc_davinci_set_ios,
++	.get_cd		= mmc_davinci_get_cd,
++	.get_ro		= mmc_davinci_get_ro,
++	.enable_sdio_irq	= mmc_davinci_enable_sdio_irq,
++};
++
++/*----------------------------------------------------------------------*/
++
++static void __init init_mmcsd_host(struct mmc_davinci_host *host)
++{
++	/* DAT line portion is diabled and in reset state */
++	writel(readl(host->base + DAVINCI_MMCCTL) | MMCCTL_DATRST,
++		host->base + DAVINCI_MMCCTL);
++
++	/* CMD line portion is diabled and in reset state */
++	writel(readl(host->base + DAVINCI_MMCCTL) | MMCCTL_CMDRST,
++		host->base + DAVINCI_MMCCTL);
++
++	udelay(10);
++
++	writel(0, host->base + DAVINCI_MMCCLK);
++	writel(MMCCLK_CLKEN, host->base + DAVINCI_MMCCLK);
++
++	writel(0x1FFF, host->base + DAVINCI_MMCTOR);
++	writel(0xFFFF, host->base + DAVINCI_MMCTOD);
++
++	writel(readl(host->base + DAVINCI_MMCCTL) & ~MMCCTL_DATRST,
++		host->base + DAVINCI_MMCCTL);
++	writel(readl(host->base + DAVINCI_MMCCTL) & ~MMCCTL_CMDRST,
++		host->base + DAVINCI_MMCCTL);
++
++	udelay(10);
++}
++
++static int __init davinci_mmcsd_probe(struct platform_device *pdev)
++{
++	struct davinci_mmc_config *pdata = pdev->dev.platform_data;
++	struct mmc_davinci_host *host = NULL;
++	struct mmc_host *mmc = NULL;
++	struct resource *r, *mem = NULL;
++	int ret = 0;
++	size_t mem_size;
++
++	/* REVISIT:  when we're fully converted, fail if pdata is NULL */
++
++	ret = -ENODEV;
++	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
++	if (!r)
++		goto out;
++
++	ret = -EBUSY;
++	mem_size = resource_size(r);
++	mem = request_mem_region(r->start, mem_size, pdev->name);
++	if (!mem)
++		goto out;
++
++	ret = -ENOMEM;
++	mmc = mmc_alloc_host(sizeof(struct mmc_davinci_host), &pdev->dev);
++	if (!mmc)
++		goto out;
++
++	host = mmc_priv(mmc);
++	host->mmc = mmc;	/* Important */
++
++	r = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
++	if (!r)
++		goto out;
++	host->mmc_irq = r->start;
++
++	r = platform_get_resource(pdev, IORESOURCE_IRQ, 1);
++	if (!r)
++		goto out;
++	host->sdio_irq = r->start;
++
++	r = platform_get_resource(pdev, IORESOURCE_DMA, 0);
++	if (!r)
++		goto out;
++	host->rxdma = r->start;
++
++	r = platform_get_resource(pdev, IORESOURCE_DMA, 1);
++	if (!r)
++		goto out;
++	host->txdma = r->start;
++
++	host->mem_res = mem;
++	host->base = ioremap(mem->start, mem_size);
++	if (!host->base)
++		goto out;
++
++	ret = -ENXIO;
++	host->clk = clk_get(&pdev->dev, "MMCSDCLK");
++	if (IS_ERR(host->clk)) {
++		ret = PTR_ERR(host->clk);
++		goto out;
++	}
++	clk_enable(host->clk);
++	host->mmc_input_clk = clk_get_rate(host->clk);
++
++	init_mmcsd_host(host);
++
++	host->use_dma = use_dma;
++
++	if (host->use_dma && davinci_acquire_dma_channels(host) != 0)
++		host->use_dma = 0;
++
++	/* REVISIT:  someday, support IRQ-driven card detection.  */
++	mmc->caps |= MMC_CAP_NEEDS_POLL;
++
++	if (!pdata || pdata->wires == 4 || pdata->wires == 0)
++		mmc->caps |= MMC_CAP_4_BIT_DATA;
++
++	host->version = pdata->version;
++
++	mmc->ops = &mmc_davinci_ops;
++	mmc->f_min = 312500;
++	mmc->f_max = 25000000;
++	if (pdata && pdata->max_freq)
++		mmc->f_max = pdata->max_freq;
++	if (pdata && pdata->caps)
++		mmc->caps |= pdata->caps;
++	mmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34;
++
++	/* With no iommu coalescing pages, each phys_seg is a hw_seg.
++	 * Each hw_seg uses one EDMA parameter RAM slot, always one
++	 * channel and then usually some linked slots.
++	 */
++	mmc->max_hw_segs	= 1 + host->n_link;
++	mmc->max_phys_segs	= mmc->max_hw_segs;
++
++	/* EDMA limit per hw segment (one or two MBytes) */
++	mmc->max_seg_size	= MAX_CCNT * rw_threshold;
++
++	/* MMC/SD controller limits for multiblock requests */
++	mmc->max_blk_size	= 4095;  /* BLEN is 12 bits */
++	mmc->max_blk_count	= 65535; /* NBLK is 16 bits */
++	mmc->max_req_size	= mmc->max_blk_size * mmc->max_blk_count;
++
++	dev_dbg(mmc_dev(host->mmc), "max_phys_segs=%d\n", mmc->max_phys_segs);
++	dev_dbg(mmc_dev(host->mmc), "max_hw_segs=%d\n", mmc->max_hw_segs);
++	dev_dbg(mmc_dev(host->mmc), "max_blk_size=%d\n", mmc->max_blk_size);
++	dev_dbg(mmc_dev(host->mmc), "max_req_size=%d\n", mmc->max_req_size);
++	dev_dbg(mmc_dev(host->mmc), "max_seg_size=%d\n", mmc->max_seg_size);
++
++	platform_set_drvdata(pdev, host);
++
++	ret = mmc_add_host(mmc);
++	if (ret < 0)
++		goto out;
++
++	ret = request_irq(host->mmc_irq, mmc_davinci_irq, 0,
++		mmc_hostname(mmc), host);
++	if (ret)
++		goto out;
++
++	if (host->sdio_irq > 0) {
++		ret = request_irq(host->sdio_irq,
++				mmc_davinci_sdio_irq, 0,
++				DM355_SDIO_IRQ(pdev->id), host);
++		if (ret == 0) {
++			mmc->caps |= MMC_CAP_SDIO_IRQ;
++			host->sdio_int = 0;
++		} else
++			goto out;
++	}
++
++	rename_region(mem, mmc_hostname(mmc));
++
++	dev_info(mmc_dev(host->mmc), "Using %s, %d-bit mode\n",
++		host->use_dma ? "DMA" : "PIO",
++		(mmc->caps & MMC_CAP_4_BIT_DATA) ? 4 : 1);
++
++	return 0;
++
++out:
++	if (host) {
++		davinci_release_dma_channels(host);
++
++		if (host->clk) {
++			clk_disable(host->clk);
++			clk_put(host->clk);
++		}
++
++		if (host->base)
++			iounmap(host->base);
++	}
++
++	if (mmc)
++		mmc_free_host(mmc);
++
++	if (mem)
++		release_resource(mem);
++
++	dev_dbg(&pdev->dev, "probe err %d\n", ret);
++
++	return ret;
++}
++
++static int __exit davinci_mmcsd_remove(struct platform_device *pdev)
++{
++	struct mmc_davinci_host *host = platform_get_drvdata(pdev);
++
++	platform_set_drvdata(pdev, NULL);
++	if (host) {
++
++		writel((readl(host->base + DAVINCI_MMCCLK) & ~MMCCLK_CLKEN),
++				host->base + DAVINCI_MMCCLK);
++
++		mmc_remove_host(host->mmc);
++
++		free_irq(host->mmc_irq, host);
++
++		if (host->mmc->caps & MMC_CAP_SDIO_IRQ)
++			free_irq(host->sdio_irq, host);
++
++		if (host->use_dma)
++			davinci_release_dma_channels(host);
++
++		clk_disable(host->clk);
++		clk_put(host->clk);
++
++		iounmap(host->base);
++
++		release_resource(host->mem_res);
++
++		mmc_free_host(host->mmc);
++	}
++
++	return 0;
++}
++
++#ifdef CONFIG_PM
++static int davinci_mmcsd_suspend(struct platform_device *pdev, pm_message_t msg)
++{
++	struct mmc_davinci_host *host = platform_get_drvdata(pdev);
++
++	return mmc_suspend_host(host->mmc, msg);
++}
++
++static int davinci_mmcsd_resume(struct platform_device *pdev)
++{
++	struct mmc_davinci_host *host = platform_get_drvdata(pdev);
++
++	return mmc_resume_host(host->mmc);
++}
++#else
++#define davinci_mmcsd_suspend	NULL
++#define davinci_mmcsd_resume	NULL
++#endif
++
++static struct platform_driver davinci_mmcsd_driver = {
++	.driver		= {
++		.name	= "davinci_mmc",
++		.owner	= THIS_MODULE,
++	},
++	.remove		= __exit_p(davinci_mmcsd_remove),
++	.suspend	= davinci_mmcsd_suspend,
++	.resume		= davinci_mmcsd_resume,
++};
++
++static int __init davinci_mmcsd_init(void)
++{
++	return platform_driver_probe(&davinci_mmcsd_driver,
++				     davinci_mmcsd_probe);
++}
++module_init(davinci_mmcsd_init);
++
++static void __exit davinci_mmcsd_exit(void)
++{
++	platform_driver_unregister(&davinci_mmcsd_driver);
++}
++module_exit(davinci_mmcsd_exit);
++
++MODULE_AUTHOR("Texas Instruments India");
++MODULE_LICENSE("GPL");
++MODULE_DESCRIPTION("MMC/SD driver for Davinci MMC controller");
++
+--- /dev/null
++++ b/arch/arm/mach-davinci/include/mach/cir_hw.h
+@@ -0,0 +1,111 @@
++/*
++ * cir.h - Header file for the driver for Consumer Infrared (CIR)
++	   (on Davinci-HD EVM)
++ *
++ * Copyright (C) 2007  Texas Instruments, India
++ * Author: Suresh Rajashekara <suresh.r@ti.com>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License along
++ * with this program; if not, write to the Free Software Foundation, Inc.,
++ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
++ *
++ */
++
++#ifndef __CIRHW_H__
++#define __CIRHW_H__
++
++#ifdef __KERNEL__
++#include <linux/module.h>
++#include <linux/init.h>
++#include <linux/device.h>
++#include <linux/wait.h>
++#include <linux/completion.h>
++#include <linux/interrupt.h>
++#include <linux/err.h>
++
++#include <asm/delay.h>
++#include <asm/io.h>
++
++#include "irqs.h"
++#include "memory.h"
++#include "edma.h"
++#include "irqs.h"
++#include "clock.h"
++
++
++#include <asm/atomic.h>
++#include <asm/uaccess.h>
++
++#endif /* __KERNEL__ */
++
++#ifdef __KERNEL__
++#define CIR_BASE  DM644X_UART2_BASE /* UART 2 */
++
++/* CIR Register Mapping */
++#define RHR          (0x00)
++#define THR          (0x00)
++#define IER          (0x04)
++#define IIR          (0x08)
++#define FCR          (0x08)
++#define LCR          (0x0C)
++#define MCR          (0x10)
++#define LSR          (0x14)
++#define MSR          (0x18)
++#define TCR          (0x18)
++#define TLR          (0x1C)
++#define SPR          (0x1C)
++#define MDR1         (0x20)
++#define MDR2         (0x24)
++#define SFLSR        (0x28)
++#define TXFLL        (0x28)
++#define RESUME       (0x2C)
++#define TXFLH        (0x2C)
++#define SFREGL       (0x30)
++#define RXFLL        (0x30)
++#define SFREGH       (0x34)
++#define RXFLH        (0x34)
++#define BLR          (0x38)
++#define ACREG        (0x3C)
++#define SCR          (0x40)
++#define SSR          (0x44)
++#define EBLR         (0x48)
++#define MVR          (0x50)
++#define SYSC         (0x54)
++#define SYSS         (0x58)
++#define WER          (0x5C)
++#define CFPS         (0x60)
++
++/* ------------------------------------------------------------------------ *
++ *  Control Registers for: UART Registers minus Base Address ()           *
++ *  These Registers are available with "LCR[bit 7] = 1"                     *
++ * ------------------------------------------------------------------------ */
++#define USE_LCR_80              (0x100)
++#define DLL                     (USE_LCR_80 + 0x0)
++#define DLH                     (USE_LCR_80 + 0x4)
++#define UASR                    (USE_LCR_80 + 0x38)
++
++/* ------------------------------------------------------------------------  *
++ *  Control Registers for: UART Registers minus Base Address ()            *
++ *  These Registers are available with "LCR = 0xBF"                          *
++ *  ------------------------------------------------------------------------ */
++#define USE_LCR_BF              (0x200)
++#define EFR                     (USE_LCR_BF + 0x8)
++#define XON1                    (USE_LCR_BF + 0x10)
++#define XON2                    (USE_LCR_BF + 0x14)
++#define XOFF1                   (USE_LCR_BF + 0x18)
++#define XOFF2                   (USE_LCR_BF + 0x1c)
++
++#define BIT(n)       (1<<n)
++#endif /* __KERNEL__ */
++
++#endif /* _CIR_H__ */
+--- a/arch/arm/mach-davinci/include/mach/dm365.h
++++ b/arch/arm/mach-davinci/include/mach/dm365.h
+@@ -15,7 +15,10 @@
+ 
+ #include <linux/platform_device.h>
+ #include <mach/hardware.h>
++#include <media/davinci/vpfe_capture.h>
+ #include <mach/emac.h>
++#include <mach/asp.h>
++#include <mach/keyscan.h>
+ 
+ #define DM365_EMAC_BASE			(0x01D07000)
+ #define DM365_EMAC_CNTRL_OFFSET		(0x0000)
+@@ -24,6 +27,19 @@
+ #define DM365_EMAC_MDIO_OFFSET		(0x4000)
+ #define DM365_EMAC_CNTRL_RAM_SIZE	(0x2000)
+ 
++#define DM365_RTC_BASE			(0x01C69000)
++
++/* Base of key scan register bank */
++#define DM365_KEYSCAN_BASE		(0x01C69400)
++
+ void __init dm365_init(void);
++void __init dm365_init_asp(struct snd_platform_data *pdata);
++void __init dm365_init_rtc(void);
++void __init dm365_init_ks(struct davinci_ks_platform_data *pdata);
++void dm365_set_vpfe_config(struct vpfe_config *cfg);
++
++struct spi_board_info;
++void dm365_init_spi0(unsigned chipselect_mask,
++		struct spi_board_info *info, unsigned len);
+ 
+ #endif /* __ASM_ARCH_DM365_H */
+--- a/drivers/media/video/adv7343.c
++++ b/drivers/media/video/adv7343.c
+@@ -28,7 +28,7 @@
+ #include <media/adv7343.h>
+ #include <media/v4l2-device.h>
+ #include <media/v4l2-chip-ident.h>
+-
++#include <media/davinci/videohd.h>
+ #include "adv7343_regs.h"
+ 
+ MODULE_DESCRIPTION("ADV7343 video encoder driver");
+@@ -40,12 +40,6 @@ MODULE_PARM_DESC(debug, "Debug level 0-1
+ 
+ struct adv7343_state {
+ 	struct v4l2_subdev sd;
+-	u8 reg00;
+-	u8 reg01;
+-	u8 reg02;
+-	u8 reg35;
+-	u8 reg80;
+-	u8 reg82;
+ 	int bright;
+ 	int hue;
+ 	int gain;
+@@ -65,6 +59,13 @@ static inline int adv7343_write(struct v
+ 	return i2c_smbus_write_byte_data(client, reg, value);
+ }
+ 
++static inline int adv7343_read(struct v4l2_subdev *sd, u8 reg)
++{
++	struct i2c_client *client = v4l2_get_subdevdata(sd);
++
++	return i2c_smbus_read_byte_data(client, reg);
++}
++
+ static const u8 adv7343_init_reg_val[] = {
+ 	ADV7343_SOFT_RESET, ADV7343_SOFT_RESET_DEFAULT,
+ 	ADV7343_POWER_MODE_REG, ADV7343_POWER_MODE_REG_DEFAULT,
+@@ -96,29 +97,98 @@ static const u8 adv7343_init_reg_val[] =
+  * FSC(reg) =  FSC (HZ) * --------
+  *			  27000000
+  */
+-static const struct adv7343_std_info stdinfo[] = {
+-	{
++struct adv7343_std_info adv7343_composite_std_info[ADV7343_COMPOSITE_NUM_STD] =
++{
++	{ ADV7343_SD_MODE_REG1, SD_INPUT_MODE, (~(SD_STD_MASK)),
+ 		/* FSC(Hz) = 3,579,545.45 Hz */
+-		SD_STD_NTSC, 569408542, V4L2_STD_NTSC,
+-	}, {
++		SD_STD_NTSC, 569408542, V4L2_STD_NTSC},
++	{ ADV7343_SD_MODE_REG1, SD_INPUT_MODE, (~(SD_STD_MASK)),
++		/* FSC(Hz) = 4,433,618.75 Hz */
++		SD_STD_PAL_BDGHI, 705268427, V4L2_STD_PAL},
++	{ ADV7343_SD_MODE_REG1, SD_INPUT_MODE, (~(SD_STD_MASK)),
+ 		/* FSC(Hz) = 3,575,611.00 Hz */
+-		SD_STD_PAL_M, 568782678, V4L2_STD_PAL_M,
+-	}, {
++		SD_STD_PAL_M, 568782678, V4L2_STD_PAL_M},
++	{ ADV7343_SD_MODE_REG1, SD_INPUT_MODE, (~(SD_STD_MASK)),
+ 		/* FSC(Hz) = 3,582,056.00 */
+-		SD_STD_PAL_N, 569807903, V4L2_STD_PAL_Nc,
+-	}, {
+-		/* FSC(Hz) = 4,433,618.75 Hz */
+-		SD_STD_PAL_N, 705268427, V4L2_STD_PAL_N,
+-	}, {
++		SD_STD_PAL_N, 569807903, V4L2_STD_PAL_Nc},
++	{ ADV7343_SD_MODE_REG1, SD_INPUT_MODE, (~(SD_STD_MASK)),
+ 		/* FSC(Hz) = 4,433,618.75 Hz */
+-		SD_STD_PAL_BDGHI, 705268427, V4L2_STD_PAL,
+-	}, {
++		SD_STD_PAL_N, 705268427, V4L2_STD_PAL_N},
++	{ ADV7343_SD_MODE_REG1, SD_INPUT_MODE, (~(SD_STD_MASK)),
+ 		/* FSC(Hz) = 4,433,618.75 Hz */
+-		SD_STD_NTSC, 705268427, V4L2_STD_NTSC_443,
+-	}, {
++		SD_STD_NTSC, 705268427, V4L2_STD_NTSC_443},
++	{ ADV7343_SD_MODE_REG1, SD_INPUT_MODE, (~(SD_STD_MASK)),
+ 		/* FSC(Hz) = 4,433,618.75 Hz */
+-		SD_STD_PAL_M, 705268427, V4L2_STD_PAL_60,
+-	},
++		SD_STD_PAL_M, 705268427, V4L2_STD_PAL_60}
++};
++
++
++struct adv7343_std_info adv7343_component_std_info[ADV7343_COMPONENT_NUM_STD] =
++{
++	{ ADV7343_HD_MODE_REG1, HD_720P_INPUT_MODE,
++		(~(STD_MODE_MASK << STD_MODE_SHIFT)),
++		(STD_MODE_720P << STD_MODE_SHIFT),
++		569408542, V4L2_STD_720P_60},
++#if 0
++	{ ADV7343_HD_MODE_REG1, HD_720P_INPUT_MODE,
++		(~(STD_MODE_MASK << STD_MODE_SHIFT)),
++		(STD_MODE_720P_25 << STD_MODE_SHIFT),
++		569408542, V4L2_STD_720P_25},
++	{ ADV7343_HD_MODE_REG1, HD_720P_INPUT_MODE,
++		(~(STD_MODE_MASK << STD_MODE_SHIFT)),
++		(STD_MODE_720P_30 << STD_MODE_SHIFT),
++		569408542, V4L2_STD_720P_30},
++#endif
++	{ ADV7343_HD_MODE_REG1, HD_720P_INPUT_MODE,
++		(~(STD_MODE_MASK << STD_MODE_SHIFT)),
++		(STD_MODE_720P_50 << STD_MODE_SHIFT),
++		569408542, V4L2_STD_720P_50},
++	{ ADV7343_HD_MODE_REG1, HD_1080I_INPUT_MODE,
++		(~(STD_MODE_MASK << STD_MODE_SHIFT)),
++		(STD_MODE_1080I << STD_MODE_SHIFT),
++		569408542, V4L2_STD_1080I_60},
++	{ ADV7343_HD_MODE_REG1, HD_1080I_INPUT_MODE,
++		(~(STD_MODE_MASK << STD_MODE_SHIFT)),
++		(STD_MODE_1080I_25fps << STD_MODE_SHIFT),
++		569408542, V4L2_STD_1080I_50},
++	{ ADV7343_HD_MODE_REG1, HD_720P_INPUT_MODE,
++		(~(STD_MODE_MASK << STD_MODE_SHIFT)),
++		(STD_MODE_525P << STD_MODE_SHIFT),
++		569408542, V4L2_STD_525P_60},
++	{ ADV7343_HD_MODE_REG1, HD_720P_INPUT_MODE,
++		(~(STD_MODE_MASK << STD_MODE_SHIFT)),
++		(STD_MODE_625P << STD_MODE_SHIFT),
++		569408542, V4L2_STD_625P_50},
++	{ ADV7343_SD_MODE_REG1, SD_INPUT_MODE, (~(SD_STD_MASK)),
++		SD_STD_NTSC, 569408542, V4L2_STD_525_60},
++	{ ADV7343_SD_MODE_REG1, SD_INPUT_MODE, (~(SD_STD_MASK)),
++		SD_STD_PAL_BDGHI, 569408542, V4L2_STD_625_50},
++#if 0
++	{ ADV7343_HD_MODE_REG1, HD_1080I_INPUT_MODE,
++		(~(STD_MODE_MASK << STD_MODE_SHIFT)),
++		(STD_MODE_1080P_24 << STD_MODE_SHIFT),
++		569408542, V4L2_STD_1080P_24},
++	{ ADV7343_HD_MODE_REG1, HD_1080I_INPUT_MODE,
++		(~(STD_MODE_MASK << STD_MODE_SHIFT)),
++		(STD_MODE_1080P_25 << STD_MODE_SHIFT),
++		569408542, V4L2_STD_1080P_25},
++	{ ADV7343_HD_MODE_REG1, HD_1080I_INPUT_MODE,
++		(~(STD_MODE_MASK << STD_MODE_SHIFT)),
++		(STD_MODE_1080P_30 << STD_MODE_SHIFT),
++		569408542, V4L2_STD_1080P_30}
++#endif
++};
++
++struct adv7343_output_info output_info[] = {
++	{ADV7343_COMPOSITE_ID, ADV7343_COMPOSITE_NUM_STD,
++		ADV7343_COMPOSITE_POWER_VALUE,
++		adv7343_composite_std_info},
++	{ADV7343_COMPONENT_ID, ADV7343_COMPONENT_NUM_STD,
++		ADV7343_COMPONENT_POWER_VALUE,
++		adv7343_component_std_info},
++	{ADV7343_SVIDEO_ID, ADV7343_SVIDEO_NUM_STD,
++		ADV7343_SVIDEO_POWER_VALUE,
++		adv7343_composite_std_info}
+ };
+ 
+ static int adv7343_setstd(struct v4l2_subdev *sd, v4l2_std_id std)
+@@ -127,14 +197,15 @@ static int adv7343_setstd(struct v4l2_su
+ 	struct adv7343_std_info *std_info;
+ 	int output_idx, num_std;
+ 	char *fsc_ptr;
+-	u8 reg, val;
+-	int err = 0;
++	u8 reg;
++	int err = 0, val;
+ 	int i = 0;
+ 
+ 	output_idx = state->output;
+ 
+-	std_info = (struct adv7343_std_info *)stdinfo;
+-	num_std = ARRAY_SIZE(stdinfo);
++	std_info =
++		(struct adv7343_std_info *)(output_info[output_idx].std_info);
++	num_std = output_info[output_idx].num_std;
+ 
+ 	for (i = 0; i < num_std; i++) {
+ 		if (std_info[i].stdid & std)
+@@ -144,28 +215,32 @@ static int adv7343_setstd(struct v4l2_su
+ 	if (i == num_std) {
+ 		v4l2_dbg(1, debug, sd,
+ 				"Invalid std or std is not supported: %llx\n",
+-						(unsigned long long)std);
++				(unsigned long long)std);
+ 		return -EINVAL;
+ 	}
+ 
+ 	/* Set the standard */
+-	val = state->reg80 & (~(SD_STD_MASK));
++	val = adv7343_read(sd, std_info[i].set_std_reg);
++	if (val < 0)
++		goto setstd_exit;
++
++	val = val & std_info[i].standard_val2;
+ 	val |= std_info[i].standard_val3;
+-	err = adv7343_write(sd, ADV7343_SD_MODE_REG1, val);
++	err = adv7343_write(sd, std_info[i].set_std_reg, val);
+ 	if (err < 0)
+ 		goto setstd_exit;
+ 
+-	state->reg80 = val;
+-
+ 	/* Configure the input mode register */
+-	val = state->reg01 & (~((u8) INPUT_MODE_MASK));
+-	val |= SD_INPUT_MODE;
++	val = adv7343_read(sd, ADV7343_MODE_SELECT_REG);
++	if (val < 0)
++		goto setstd_exit;
++
++	val = val & (~((u8) INPUT_MODE_MASK));
++	val |= std_info[i].outputmode_val;
+ 	err = adv7343_write(sd, ADV7343_MODE_SELECT_REG, val);
+ 	if (err < 0)
+ 		goto setstd_exit;
+ 
+-	state->reg01 = val;
+-
+ 	/* Program the sub carrier frequency registers */
+ 	fsc_ptr = (unsigned char *)&std_info[i].fsc_val;
+ 	reg = ADV7343_FSC_REG0;
+@@ -175,9 +250,11 @@ static int adv7343_setstd(struct v4l2_su
+ 			goto setstd_exit;
+ 	}
+ 
+-	val = state->reg80;
+-
+ 	/* Filter settings */
++	val = adv7343_read(sd, ADV7343_SD_MODE_REG1);
++	if (val < 0)
++		goto setstd_exit;
++
+ 	if (std & (V4L2_STD_NTSC | V4L2_STD_NTSC_443))
+ 		val &= 0x03;
+ 	else if (std & ~V4L2_STD_SECAM)
+@@ -187,8 +264,8 @@ static int adv7343_setstd(struct v4l2_su
+ 	if (err < 0)
+ 		goto setstd_exit;
+ 
+-	state->reg80 = val;
+-
++	state->std = std;
++	return 0;
+ setstd_exit:
+ 	if (err != 0)
+ 		v4l2_err(sd, "Error setting std, write failed\n");
+@@ -199,7 +276,7 @@ setstd_exit:
+ static int adv7343_setoutput(struct v4l2_subdev *sd, u32 output_type)
+ {
+ 	struct adv7343_state *state = to_state(sd);
+-	unsigned char val;
++	int i, val;
+ 	int err = 0;
+ 
+ 	if (output_type > ADV7343_SVIDEO_ID) {
+@@ -210,45 +287,55 @@ static int adv7343_setoutput(struct v4l2
+ 	}
+ 
+ 	/* Enable Appropriate DAC */
+-	val = state->reg00 & 0x03;
+ 
+-	if (output_type == ADV7343_COMPOSITE_ID)
+-		val |= ADV7343_COMPOSITE_POWER_VALUE;
+-	else if (output_type == ADV7343_COMPONENT_ID)
+-		val |= ADV7343_COMPONENT_POWER_VALUE;
+-	else
+-		val |= ADV7343_SVIDEO_POWER_VALUE;
++	/* Enable PLL and disable sleep mode */
++	val = 0x02;
++	for (i = 0; i < ARRAY_SIZE(output_info); i++) {
++		if (output_type == output_info[i].output_type) {
++			val |= output_info[i].dac_enable;
++			break;
++		}
++	}
++	if (i == ARRAY_SIZE(output_info)) {
++		v4l2_dbg(1, debug, sd,
++			"Invalid output type or output type not supported:%d\n",
++			output_type);
++		return -EINVAL;
++	}
+ 
+ 	err = adv7343_write(sd, ADV7343_POWER_MODE_REG, val);
+ 	if (err < 0)
+ 		goto setoutput_exit;
+ 
+-	state->reg00 = val;
+-
+ 	/* Enable YUV output */
+-	val = state->reg02 | YUV_OUTPUT_SELECT;
++	val = adv7343_read(sd, ADV7343_MODE_REG0);
++	if (val < 0)
++		goto setoutput_exit;
++	val = val | YUV_OUTPUT_SELECT;
+ 	err = adv7343_write(sd, ADV7343_MODE_REG0, val);
+ 	if (err < 0)
+ 		goto setoutput_exit;
+ 
+-	state->reg02 = val;
+-
+ 	/* configure SD DAC Output 2 and SD DAC Output 1 bit to zero */
+-	val = state->reg82 & (SD_DAC_1_DI & SD_DAC_2_DI);
++	val = adv7343_read(sd, ADV7343_SD_MODE_REG2);
++	if (val < 0)
++		goto setoutput_exit;
++	val &= (SD_DAC_1_DI & SD_DAC_2_DI);
+ 	err = adv7343_write(sd, ADV7343_SD_MODE_REG2, val);
+ 	if (err < 0)
+ 		goto setoutput_exit;
+ 
+-	state->reg82 = val;
+-
+ 	/* configure ED/HD Color DAC Swap and ED/HD RGB Input Enable bit to
+ 	 * zero */
+-	val = state->reg35 & (HD_RGB_INPUT_DI & HD_DAC_SWAP_DI);
++	val = adv7343_read(sd, ADV7343_HD_MODE_REG6);
++	if (val < 0)
++		goto setoutput_exit;
++	val &= (HD_RGB_INPUT_DI & HD_DAC_SWAP_DI);
+ 	err = adv7343_write(sd, ADV7343_HD_MODE_REG6, val);
+ 	if (err < 0)
+ 		goto setoutput_exit;
+ 
+-	state->reg35 = val;
++	state->output = i;
+ 
+ setoutput_exit:
+ 	if (err != 0)
+@@ -478,13 +565,6 @@ static int adv7343_probe(struct i2c_clie
+ 	if (state == NULL)
+ 		return -ENOMEM;
+ 
+-	state->reg00	= 0x80;
+-	state->reg01	= 0x00;
+-	state->reg02	= 0x20;
+-	state->reg35	= 0x00;
+-	state->reg80	= ADV7343_SD_MODE_REG1_DEFAULT;
+-	state->reg82	= ADV7343_SD_MODE_REG2_DEFAULT;
+-
+ 	state->output = ADV7343_COMPOSITE_ID;
+ 	state->std = V4L2_STD_NTSC;
+ 
Index: trunk/target/linux/davinci/Makefile
===================================================================
--- trunk/target/linux/davinci/Makefile	(revision 0)
+++ trunk/target/linux/davinci/Makefile	(revision 0)
@@ -0,0 +1,28 @@
+# 
+# Copyright (C) 2006-2008 OpenWrt.org
+#
+# This is free software, licensed under the GNU General Public License v2.
+# See /LICENSE for more information.
+#
+include $(TOPDIR)/rules.mk
+
+ARCH:=arm
+BOARD:=davinci
+BOARDNAME:=TI Davinci
+FEATURES:=squashfs jffs2 audio gpio
+CFLAGS:=-Os -pipe -march=armv5t -mtune=arm10tdmi -funit-at-a-time
+LINUX_VERSION:=2.6.32.33
+
+include $(INCLUDE_DIR)/target.mk
+
+define Target/Description
+	Build images for TI Davinci DM6446 Systems
+endef
+KERNELNAME:="uImage"
+
+define Kernel/Configure
+	$(call Kernel/Configure/Default)
+endef
+
+
+$(eval $(call BuildTarget))
Index: trunk/target/linux/cns3xxx/config-smp
===================================================================
--- trunk/target/linux/cns3xxx/config-smp	(revision 0)
+++ trunk/target/linux/cns3xxx/config-smp	(revision 0)
@@ -0,0 +1,201 @@
+CONFIG_ALIGNMENT_TRAP=y
+CONFIG_ARCH_CNS3XXX=y
+# CONFIG_ARCH_EXYNOS4 is not set
+CONFIG_ARCH_HAS_CPU_IDLE_WAIT=y
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+# CONFIG_ARCH_USES_GETTIMEOFFSET is not set
+# CONFIG_ARCH_VT8500 is not set
+CONFIG_ARCH_WANT_OPTIONAL_GPIOLIB=y
+CONFIG_ARM=y
+CONFIG_ARM_GIC=y
+CONFIG_ARM_L1_CACHE_SHIFT=5
+CONFIG_ARM_THUMB=y
+CONFIG_ATA=y
+# CONFIG_ATA_SFF is not set
+CONFIG_ATA_VERBOSE_ERROR=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=2
+CONFIG_BLK_DEV_RAM_SIZE=16384
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CACHE_L2X0 is not set
+CONFIG_CNS3XXX_ETH=y
+CONFIG_CPU_32v6=y
+CONFIG_CPU_32v6K=y
+CONFIG_CPU_ABRT_EV6=y
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+CONFIG_CPU_CACHE_V6=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_HAS_PMU=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+CONFIG_CPU_PABRT_V6=y
+CONFIG_CPU_RMAP=y
+CONFIG_CPU_TLB_V6=y
+CONFIG_CPU_V6K=y
+CONFIG_DEBUG_BUGVERBOSE=y
+# CONFIG_DEBUG_USER is not set
+CONFIG_DECOMPRESS_GZIP=y
+# CONFIG_DWC_DEBUG is not set
+# CONFIG_DWC_DEVICE_ONLY is not set
+# CONFIG_DWC_HOST_ONLY is not set
+CONFIG_DWC_OTG_MODE=y
+CONFIG_EEPROM_AT24=y
+CONFIG_FIQ=y
+CONFIG_FRAME_POINTER=y
+# CONFIG_FSNOTIFY is not set
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_GENERIC_FIND_LAST_BIT=y
+CONFIG_GENERIC_GPIO=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_GPIOLIB=y
+CONFIG_GPIO_PCA953X=y
+CONFIG_GPIO_PCA953X_IRQ=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_HAS_DMA=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAVE_AOUT=y
+CONFIG_HAVE_ARCH_KGDB=y
+CONFIG_HAVE_ARM_SCU=y
+CONFIG_HAVE_ARM_TWD=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_HAVE_GENERIC_HARDIRQS=y
+CONFIG_HAVE_IDE=y
+CONFIG_HAVE_IRQ_WORK=y
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_HAVE_OPROFILE=y
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_SPARSE_IRQ=y
+CONFIG_HWMON=y
+# CONFIG_HWMON_DEBUG_CHIP is not set
+CONFIG_HW_RANDOM=m
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_CNS3XXX=y
+# CONFIG_I2C_PXA_PCI is not set
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_LZMA is not set
+CONFIG_KTIME_SCALAR=y
+CONFIG_LEDS_GPIO=y
+# CONFIG_LEDS_TRIGGER_NETDEV is not set
+CONFIG_LOCAL_TIMERS=y
+CONFIG_M25PXX_USE_FAST_READ=y
+CONFIG_MACH_CNS3420VB=y
+CONFIG_MACH_GW2388=y
+CONFIG_MIGHT_HAVE_PCI=y
+CONFIG_MMC=y
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_CNS3XXX=y
+# CONFIG_MMC_SDHCI_PCI is not set
+CONFIG_MMC_SDHCI_PLTFM=y
+# CONFIG_MMC_TIFM_SD is not set
+CONFIG_MPCORE_WATCHDOG=y
+CONFIG_MTD_M25P80=y
+CONFIG_MTD_PHYSMAP=y
+CONFIG_MUTEX_SPIN_ON_OWNER=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_NLS=y
+CONFIG_NR_CPUS=2
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_PAGE_OFFSET=0x80000000
+CONFIG_PCI=y
+CONFIG_PCI_DOMAINS=y
+CONFIG_PERF_USE_VMALLOC=y
+CONFIG_PHYLIB=y
+# CONFIG_PREEMPT_RCU is not set
+# CONFIG_QUOTACTL is not set
+CONFIG_RAID_ATTRS=y
+CONFIG_RD_GZIP=y
+# CONFIG_RD_LZMA is not set
+CONFIG_RFS_ACCEL=y
+CONFIG_RPS=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_DS1672=y
+CONFIG_SATA_AHCI=y
+CONFIG_SATA_AHCI_CNS3XXX=y
+CONFIG_SATA_AHCI_PLATFORM=y
+CONFIG_SCSI=y
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SDIO_UART is not set
+CONFIG_SENSORS_AD7418=y
+CONFIG_SENSORS_GSP=y
+CONFIG_SERIAL_8250_NR_UARTS=20
+CONFIG_SERIAL_8250_PCI=y
+CONFIG_SERIAL_8250_RUNTIME_UARTS=20
+CONFIG_SMP=y
+CONFIG_SMP_ON_UP=y
+CONFIG_SPI=y
+CONFIG_SPI_BITBANG=y
+CONFIG_SPI_CNS3XXX=y
+# CONFIG_SPI_GPIO is not set
+CONFIG_SPI_MASTER=y
+# CONFIG_STAGING is not set
+CONFIG_STOP_MACHINE=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+# CONFIG_TINY_RCU is not set
+CONFIG_TREE_RCU=y
+CONFIG_UID16=y
+CONFIG_USB=y
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+# CONFIG_USB_CDC_COMPOSITE is not set
+CONFIG_USB_CNS3XXX_EHCI=y
+CONFIG_USB_CNS3XXX_OHCI=y
+CONFIG_USB_DEBUG=y
+CONFIG_USB_DWC_OTG=y
+CONFIG_USB_EHCI_HCD=y
+# CONFIG_USB_ETH is not set
+# CONFIG_USB_FILE_STORAGE is not set
+# CONFIG_USB_FUNCTIONFS is not set
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGETFS is not set
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+# CONFIG_USB_GADGET_DEBUG_FS is not set
+# CONFIG_USB_GADGET_DUALSPEED is not set
+# CONFIG_USB_MIDI_GADGET is not set
+CONFIG_USB_GADGET_SELECTED=y
+CONFIG_USB_GADGET_VBUS_DRAW=2
+# CONFIG_USB_G_DBGP is not set
+# CONFIG_USB_G_HID is not set
+# CONFIG_USB_G_NCM is not set
+# CONFIG_USB_G_PRINTER is not set
+# CONFIG_USB_G_SERIAL is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_MMIO is not set
+CONFIG_USB_OHCI_HCD=y
+CONFIG_USB_SUPPORT=y
+# CONFIG_USB_UHCI_HCD is not set
+# CONFIG_USB_ZERO is not set
+CONFIG_USE_GENERIC_SMP_HELPERS=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_VFP=y
+CONFIG_VMSPLIT_2G=y
+# CONFIG_VMSPLIT_3G is not set
+CONFIG_WATCHDOG_NOWAYOUT=y
+CONFIG_XPS=y
+CONFIG_XZ_DEC=y
+CONFIG_ZBOOT_ROM_BSS=0
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_ZONE_DMA_FLAG=0
Index: trunk/target/linux/cns3xxx/config-default
===================================================================
--- trunk/target/linux/cns3xxx/config-default	(revision 27590)
+++ trunk/target/linux/cns3xxx/config-default	(working copy)
@@ -18,11 +18,12 @@
 CONFIG_ATA_VERBOSE_ERROR=y
 CONFIG_BLK_DEV_RAM=y
 CONFIG_BLK_DEV_RAM_COUNT=2
-CONFIG_BLK_DEV_RAM_SIZE=32768
+CONFIG_BLK_DEV_RAM_SIZE=16384
 CONFIG_BLK_DEV_SD=y
-CONFIG_CACHE_L2X0=y
+# CONFIG_CACHE_L2X0 is not set
 CONFIG_CNS3XXX_ETH=y
 CONFIG_CPU_32v6=y
+CONFIG_CPU_32v6K=y
 CONFIG_CPU_ABRT_EV6=y
 # CONFIG_CPU_BPREDICT_DISABLE is not set
 CONFIG_CPU_CACHE_V6=y
@@ -34,22 +35,22 @@
 CONFIG_CPU_HAS_PMU=y
 # CONFIG_CPU_ICACHE_DISABLE is not set
 CONFIG_CPU_PABRT_V6=y
+CONFIG_CPU_RMAP=y
 CONFIG_CPU_TLB_V6=y
-CONFIG_CPU_USE_DOMAINS=y
-CONFIG_CPU_V6=y
+CONFIG_CPU_V6K=y
 CONFIG_DEBUG_BUGVERBOSE=y
 # CONFIG_DEBUG_USER is not set
 CONFIG_DECOMPRESS_GZIP=y
-CONFIG_DMA_CACHE_RWFO=y
 # CONFIG_DWC_DEBUG is not set
 # CONFIG_DWC_DEVICE_ONLY is not set
 # CONFIG_DWC_HOST_ONLY is not set
 CONFIG_DWC_OTG_MODE=y
 CONFIG_EEPROM_AT24=y
+CONFIG_FIQ=y
 CONFIG_FRAME_POINTER=y
 # CONFIG_FSNOTIFY is not set
-CONFIG_GENERIC_ATOMIC64=y
 CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
 CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
 CONFIG_GENERIC_FIND_LAST_BIT=y
 CONFIG_GENERIC_GPIO=y
@@ -64,6 +65,8 @@
 CONFIG_HAS_IOPORT=y
 CONFIG_HAVE_AOUT=y
 CONFIG_HAVE_ARCH_KGDB=y
+CONFIG_HAVE_ARM_SCU=y
+CONFIG_HAVE_ARM_TWD=y
 CONFIG_HAVE_C_RECORDMCOUNT=y
 CONFIG_HAVE_DMA_API_DEBUG=y
 CONFIG_HAVE_DYNAMIC_FTRACE=y
@@ -77,7 +80,6 @@
 CONFIG_HAVE_KERNEL_GZIP=y
 CONFIG_HAVE_KERNEL_LZMA=y
 CONFIG_HAVE_KERNEL_LZO=y
-CONFIG_HAVE_LATENCYTOP_SUPPORT=y
 CONFIG_HAVE_MEMBLOCK=y
 CONFIG_HAVE_OPROFILE=y
 CONFIG_HAVE_PERF_EVENTS=y
@@ -113,25 +115,23 @@
 CONFIG_MPCORE_WATCHDOG=y
 CONFIG_MTD_M25P80=y
 CONFIG_MTD_PHYSMAP=y
+CONFIG_MUTEX_SPIN_ON_OWNER=y
 CONFIG_NEED_DMA_MAP_STATE=y
-CONFIG_NEED_PER_CPU_KM=y
 CONFIG_NLS=y
 CONFIG_NR_CPUS=2
-CONFIG_OUTER_CACHE=y
-CONFIG_OUTER_CACHE_SYNC=y
 CONFIG_PAGEFLAGS_EXTENDED=y
-CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_PAGE_OFFSET=0x80000000
 CONFIG_PCI=y
 CONFIG_PCI_DOMAINS=y
 CONFIG_PERF_USE_VMALLOC=y
 CONFIG_PHYLIB=y
-CONFIG_PL310_ERRATA_588369=y
-CONFIG_PL310_ERRATA_727915=y
 # CONFIG_PREEMPT_RCU is not set
 # CONFIG_QUOTACTL is not set
 CONFIG_RAID_ATTRS=y
 CONFIG_RD_GZIP=y
 # CONFIG_RD_LZMA is not set
+CONFIG_RFS_ACCEL=y
+CONFIG_RPS=y
 CONFIG_RTC_CLASS=y
 CONFIG_RTC_DRV_DS1672=y
 CONFIG_SATA_AHCI=y
@@ -142,8 +142,9 @@
 # CONFIG_SDIO_UART is not set
 CONFIG_SENSORS_AD7418=y
 CONFIG_SENSORS_GSP=y
-CONFIG_SERIAL_8250_NR_UARTS=3
-CONFIG_SERIAL_8250_RUNTIME_UARTS=3
+CONFIG_SERIAL_8250_NR_UARTS=20
+CONFIG_SERIAL_8250_PCI=y
+CONFIG_SERIAL_8250_RUNTIME_UARTS=20
 CONFIG_SMP=y
 CONFIG_SMP_ON_UP=y
 CONFIG_SPI=y
@@ -152,7 +153,10 @@
 # CONFIG_SPI_GPIO is not set
 CONFIG_SPI_MASTER=y
 # CONFIG_STAGING is not set
+CONFIG_STOP_MACHINE=y
 CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+# CONFIG_TINY_RCU is not set
+CONFIG_TREE_RCU=y
 CONFIG_UID16=y
 CONFIG_USB=y
 CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
@@ -170,6 +174,7 @@
 # CONFIG_USB_GADGET_DEBUG_FILES is not set
 # CONFIG_USB_GADGET_DEBUG_FS is not set
 # CONFIG_USB_GADGET_DUALSPEED is not set
+# CONFIG_USB_MIDI_GADGET is not set
 CONFIG_USB_GADGET_SELECTED=y
 CONFIG_USB_GADGET_VBUS_DRAW=2
 # CONFIG_USB_G_DBGP is not set
@@ -183,9 +188,13 @@
 CONFIG_USB_SUPPORT=y
 # CONFIG_USB_UHCI_HCD is not set
 # CONFIG_USB_ZERO is not set
+CONFIG_USE_GENERIC_SMP_HELPERS=y
 CONFIG_VECTORS_BASE=0xffff0000
 CONFIG_VFP=y
+CONFIG_VMSPLIT_2G=y
+# CONFIG_VMSPLIT_3G is not set
 CONFIG_WATCHDOG_NOWAYOUT=y
+CONFIG_XPS=y
 CONFIG_XZ_DEC=y
 CONFIG_ZBOOT_ROM_BSS=0
 CONFIG_ZBOOT_ROM_TEXT=0
Index: trunk/target/linux/cns3xxx/patches/301-fiq_cache_maint.patch
===================================================================
--- trunk/target/linux/cns3xxx/patches/301-fiq_cache_maint.patch	(revision 0)
+++ trunk/target/linux/cns3xxx/patches/301-fiq_cache_maint.patch	(revision 0)
@@ -0,0 +1,468 @@
+--- a/arch/arm/include/asm/cacheflush.h
++++ b/arch/arm/include/asm/cacheflush.h
+@@ -17,6 +17,10 @@
+ #include <asm/cachetype.h>
+ #include <asm/outercache.h>
+ 
++#ifdef CONFIG_SMP
++#include <asm/smp.h>
++#endif
++
+ #define CACHE_COLOUR(vaddr)	((vaddr & (SHMLBA - 1)) >> PAGE_SHIFT)
+ 
+ /*
+@@ -125,6 +129,15 @@ extern struct cpu_cache_fns cpu_cache;
+ #define __cpuc_coherent_user_range	cpu_cache.coherent_user_range
+ #define __cpuc_flush_dcache_area	cpu_cache.flush_kern_dcache_area
+ 
++
++#ifdef CONFIG_SMP1
++
++#define dmac_map_area smp_dma_map_area
++#define dmac_unmap_area smp_dma_unmap_area
++#define dmac_flush_range smp_dma_flush_range
++
++#else
++
+ /*
+  * These are private to the dma-mapping API.  Do not use directly.
+  * Their sole purpose is to ensure that data held in the cache
+@@ -135,6 +148,8 @@ extern struct cpu_cache_fns cpu_cache;
+ #define dmac_unmap_area			cpu_cache.dma_unmap_area
+ #define dmac_flush_range		cpu_cache.dma_flush_range
+ 
++#endif
++
+ #else
+ 
+ extern void __cpuc_flush_icache_all(void);
+--- a/arch/arm/mach-cns3xxx/Makefile
++++ b/arch/arm/mach-cns3xxx/Makefile
+@@ -2,6 +2,6 @@ obj-$(CONFIG_ARCH_CNS3XXX)		+= core.o pm
+ obj-$(CONFIG_PCI)			+= pcie.o
+ obj-$(CONFIG_MACH_CNS3420VB)		+= cns3420vb.o
+ obj-$(CONFIG_MACH_GW2388)		+= laguna.o
+-obj-$(CONFIG_SMP)			+= platsmp.o headsmp.o
++obj-$(CONFIG_SMP)			+= platsmp.o headsmp.o cns3xxx_fiq.o
+ obj-$(CONFIG_HOTPLUG_CPU)		+= hotplug.o
+ obj-$(CONFIG_LOCAL_TIMERS)		+= localtimer.o
+--- /dev/null
++++ b/arch/arm/mach-cns3xxx/cns3xxx_fiq.S
+@@ -0,0 +1,97 @@
++/*
++ *  linux/arch/arm/lib/floppydma.S
++ *
++ *  Copyright (C) 1995, 1996 Russell King
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ */
++#include <linux/linkage.h>
++#include <asm/assembler.h>
++#include <asm/asm-offsets.h>
++
++#define D_CACHE_LINE_SIZE 32
++
++	.text
++
++/*
++ * R8  - DMA Start Address
++ * R9  - DMA Length
++ * R10 - DMA Direction
++ * R11 - DMA type
++ * R12 - fiq_buffer Address
++ * R13 - DMA type Address
++*/
++
++	.global	cns3xxx_fiq_end
++ENTRY(cns3xxx_fiq_start)
++	mov r8, #0
++	str r8, [r13]
++
++	ldr r9, [r12]
++	ldr r8, [r9]
++	add r8, r8, #1
++	str r8, [r9]
++
++	ldmib r12, {r8, r9, r10}
++	and r11, r10, #0x3000000
++	and r10, r10, #0xff
++
++	teq r11, #0x1000000
++	beq cns3xxx_dma_map_area
++	teq r11, #0x2000000
++	beq cns3xxx_dma_unmap_area
++	b cns3xxx_dma_flush_range
++
++cns3xxx_fiq_exit:
++	mov r8, #0
++	str r8, [r12, #12]
++	mcr p15, 0, r8, c7, c10, 4    @ drain write buffer
++	subs pc, lr, #4
++
++cns3xxx_dma_map_area:
++	add r9, r9, r8
++	teq r10, #DMA_FROM_DEVICE
++	beq cns3xxx_dma_inv_range
++	b cns3xxx_dma_clean_range
++
++cns3xxx_dma_unmap_area:
++	add r9, r9, r8
++	teq r10, #DMA_TO_DEVICE
++	bne cns3xxx_dma_inv_range
++	b cns3xxx_fiq_exit
++
++cns3xxx_dma_flush_range:
++	bic r8, r8, #D_CACHE_LINE_SIZE - 1
++1:
++	mcr p15, 0, r8, c7, c14, 1   @ clean & invalidate D line
++	add r8, r8, #D_CACHE_LINE_SIZE
++	cmp r8, r9
++	blo 1b
++	b cns3xxx_fiq_exit
++
++cns3xxx_dma_clean_range:
++	bic r8, r8, #D_CACHE_LINE_SIZE - 1
++1:
++	mcr p15, 0, r8, c7, c10, 1    @ clean D line
++	add r8, r8, #D_CACHE_LINE_SIZE
++	cmp r8, r9
++	blo 1b
++	b cns3xxx_fiq_exit
++
++cns3xxx_dma_inv_range:
++	tst r8, #D_CACHE_LINE_SIZE - 1
++	bic r8, r8, #D_CACHE_LINE_SIZE - 1
++	mcrne p15, 0, r8, c7, c10, 1    @ clean D line
++	tst r9, #D_CACHE_LINE_SIZE - 1
++	bic r9, r9, #D_CACHE_LINE_SIZE - 1
++	mcrne p15, 0, r9, c7, c14, 1    @ clean & invalidate D line
++1:
++	mcr p15, 0, r8, c7, c6, 1   @ invalidate D line
++	add r8, r8, #D_CACHE_LINE_SIZE
++	cmp r8, r9
++	blo 1b
++	b cns3xxx_fiq_exit
++
++cns3xxx_fiq_end:
+--- a/arch/arm/mach-cns3xxx/include/mach/cns3xxx.h
++++ b/arch/arm/mach-cns3xxx/include/mach/cns3xxx.h
+@@ -294,6 +294,7 @@
+ #define MISC_PCIE_INT_MASK(x)			MISC_MEM_MAP(0x978 + (x) * 0x100)
+ #define MISC_PCIE_INT_STATUS(x)			MISC_MEM_MAP(0x97C + (x) * 0x100)
+ 
++#define MISC_FIQ_CPU(x)				MISC_MEM_MAP(0xA58 - (x) * 0x4)
+ /*
+  * Power management and clock control
+  */
+--- a/arch/arm/mach-cns3xxx/include/mach/smp.h
++++ b/arch/arm/mach-cns3xxx/include/mach/smp.h
+@@ -10,4 +10,9 @@ static inline void smp_cross_call(const
+ {
+ 	gic_raise_softirq(mask, ipi);
+ }
++
++extern void smp_dma_map_area(const void *, size_t, int);
++extern void smp_dma_unmap_area(const void *, size_t, int);
++extern void smp_dma_flush_range(const void *, const void *);
++
+ #endif
+--- a/arch/arm/mach-cns3xxx/platsmp.c
++++ b/arch/arm/mach-cns3xxx/platsmp.c
+@@ -25,9 +25,27 @@
+ #include <mach/hardware.h>
+ #include <mach/cns3xxx.h>
+ 
++#include <asm/fiq.h>
++
+ #include "core.h"
+ 
++static struct fiq_handler fh = {
++	.name = "cns3xxx-fiq"
++};
++
++static unsigned int fiq_buffer[8];
++
++#define FIQ_ENABLED         0x80000000
++#define FIQ_GENERATE				0x00010000
++#define CNS3XXX_MAP_AREA    0x01000000
++#define CNS3XXX_UNMAP_AREA  0x02000000
++#define CNS3XXX_FLUSH_RANGE 0x03000000
++
+ extern void cns3xxx_secondary_startup(void);
++extern unsigned char cns3xxx_fiq_start, cns3xxx_fiq_end;
++extern unsigned int fiq_number[2];
++extern struct cpu_cache_fns cpu_cache;
++struct cpu_cache_fns cpu_cache_save;
+ 
+ /*
+  * control for which core is the next to come out of the secondary
+@@ -35,6 +53,44 @@ extern void cns3xxx_secondary_startup(vo
+  */
+ volatile int __cpuinitdata pen_release = -1;
+ 
++static void __init cns3xxx_set_fiq_regs(void)
++{
++	struct pt_regs FIQ_regs;
++	unsigned int cpu = smp_processor_id();
++
++	if (cpu) {
++		FIQ_regs.ARM_ip = (unsigned int)&fiq_buffer[4];
++		FIQ_regs.ARM_sp = (unsigned int)MISC_FIQ_CPU(0);
++	} else {
++		FIQ_regs.ARM_ip = (unsigned int)&fiq_buffer[0];
++		FIQ_regs.ARM_sp = (unsigned int)MISC_FIQ_CPU(1);
++	}
++	set_fiq_regs(&FIQ_regs);
++}
++
++static void __init cns3xxx_init_fiq(void)
++{
++	void *fiqhandler_start;
++	unsigned int fiqhandler_length;
++	int ret;
++
++	fiqhandler_start = &cns3xxx_fiq_start;
++	fiqhandler_length = &cns3xxx_fiq_end - &cns3xxx_fiq_start;
++
++	ret = claim_fiq(&fh);
++
++	if (ret) {
++		return;
++	}
++
++	set_fiq_handler(fiqhandler_start, fiqhandler_length);
++	fiq_buffer[0] = (unsigned int)&fiq_number[0];
++	fiq_buffer[3] = 0;
++	fiq_buffer[4] = (unsigned int)&fiq_number[1];
++	fiq_buffer[7] = 0;
++}
++
++
+ /*
+  * Write pen_release in a way that is guaranteed to be visible to all
+  * observers, irrespective of whether they're taking part in coherency
+@@ -65,12 +121,24 @@ void __cpuinit platform_secondary_init(u
+ 	gic_secondary_init(0);
+ 
+ 	/*
++	 * Setup Secondary Core FIQ regs
++	 */
++	cns3xxx_set_fiq_regs();
++
++	/*
+ 	 * let the primary processor know we're out of the
+ 	 * pen, then head off into the C entry point
+ 	 */
+ 	write_pen_release(-1);
+ 
+ 	/*
++	 * Fixup DMA Operations
++	 *
++	 */
++	cpu_cache.dma_map_area = (void *)smp_dma_map_area;
++	cpu_cache.dma_unmap_area = (void *)smp_dma_unmap_area;
++	cpu_cache.dma_flush_range = (void *)smp_dma_flush_range;
++	/*
+ 	 * Synchronise with the boot thread.
+ 	 */
+ 	spin_lock(&boot_lock);
+@@ -165,4 +233,112 @@ void __init platform_smp_prepare_cpus(un
+ 	 */
+ 	__raw_writel(virt_to_phys(cns3xxx_secondary_startup),
+ 			(void __iomem *)(0xFFF07000 + 0x0600));
++
++	/*
++	 * Setup FIQ's for main cpu
++	 */
++	cns3xxx_init_fiq();
++	cns3xxx_set_fiq_regs();
++	memcpy((void *)&cpu_cache_save, (void *)&cpu_cache, sizeof(struct cpu_cache_fns));
++}
++
++
++static inline unsigned long cns3xxx_cpu_id(void)
++{
++	unsigned long cpu;
++
++	asm volatile(
++		" mrc p15, 0, %0, c0, c0, 5  @ cns3xxx_cpu_id\n"
++		: "=r" (cpu) : : "memory", "cc");
++	return (cpu & 0xf);
++}
++
++void smp_dma_map_area(const void *addr, size_t size, int dir)
++{
++	unsigned int cpu;
++	unsigned long flags;
++	raw_local_irq_save(flags);
++	cpu = cns3xxx_cpu_id();
++	if (cpu) {
++		fiq_buffer[1] = (unsigned int)addr;
++		fiq_buffer[2] = size;
++		fiq_buffer[3] = dir | CNS3XXX_MAP_AREA | FIQ_ENABLED;
++		smp_mb();
++		__raw_writel(FIQ_GENERATE, MISC_FIQ_CPU(1));
++
++		cpu_cache_save.dma_map_area(addr, size, dir);
++		while ((fiq_buffer[3]) & FIQ_ENABLED) { barrier(); }
++	} else {
++
++		fiq_buffer[5] = (unsigned int)addr;
++		fiq_buffer[6] = size;
++		fiq_buffer[7] = dir | CNS3XXX_MAP_AREA | FIQ_ENABLED;
++		smp_mb();
++		__raw_writel(FIQ_GENERATE, MISC_FIQ_CPU(0));
++
++		cpu_cache_save.dma_map_area(addr, size, dir);
++		while ((fiq_buffer[7]) & FIQ_ENABLED) { barrier(); }
++	}
++	raw_local_irq_restore(flags);
++}
++
++void smp_dma_unmap_area(const void *addr, size_t size, int dir)
++{
++	unsigned int cpu;
++	unsigned long flags;
++
++	raw_local_irq_save(flags);
++	cpu = cns3xxx_cpu_id();
++	if (cpu) {
++
++		fiq_buffer[1] = (unsigned int)addr;
++		fiq_buffer[2] = size;
++		fiq_buffer[3] = dir | CNS3XXX_UNMAP_AREA | FIQ_ENABLED;
++		smp_mb();
++		__raw_writel(FIQ_GENERATE, MISC_FIQ_CPU(1));
++
++		cpu_cache_save.dma_unmap_area(addr, size, dir);
++		while ((fiq_buffer[3]) & FIQ_ENABLED) { barrier(); }
++	} else {
++
++		fiq_buffer[5] = (unsigned int)addr;
++		fiq_buffer[6] = size;
++		fiq_buffer[7] = dir | CNS3XXX_UNMAP_AREA | FIQ_ENABLED;
++		smp_mb();
++		__raw_writel(FIQ_GENERATE, MISC_FIQ_CPU(0));
++
++		cpu_cache_save.dma_unmap_area(addr, size, dir);
++		while ((fiq_buffer[7]) & FIQ_ENABLED) { barrier(); }
++	}
++	raw_local_irq_restore(flags);
++}
++
++void smp_dma_flush_range(const void *start, const void *end)
++{
++	unsigned int cpu;
++	unsigned long flags;
++	raw_local_irq_save(flags);
++	cpu = cns3xxx_cpu_id();
++	if (cpu) {
++
++		fiq_buffer[1] = (unsigned int)start;
++		fiq_buffer[2] = (unsigned int)end;
++		fiq_buffer[3] = CNS3XXX_FLUSH_RANGE | FIQ_ENABLED;
++		smp_mb();
++		__raw_writel(FIQ_GENERATE, MISC_FIQ_CPU(1));
++
++		cpu_cache_save.dma_flush_range(start, end);
++		while ((fiq_buffer[3]) & FIQ_ENABLED) { barrier(); }
++	} else {
++
++		fiq_buffer[5] = (unsigned int)start;
++		fiq_buffer[6] = (unsigned int)end;
++		fiq_buffer[7] = CNS3XXX_FLUSH_RANGE | FIQ_ENABLED;
++		smp_mb();
++		__raw_writel(FIQ_GENERATE, MISC_FIQ_CPU(0));
++
++		cpu_cache_save.dma_flush_range(start, end);
++		while ((fiq_buffer[7]) & FIQ_ENABLED) { barrier(); }
++	}
++	raw_local_irq_restore(flags);
+ }
+--- a/arch/arm/mm/Kconfig
++++ b/arch/arm/mm/Kconfig
+@@ -775,7 +775,7 @@ config NEEDS_SYSCALL_FOR_CMPXCHG
+ 
+ config DMA_CACHE_RWFO
+ 	bool "Enable read/write for ownership DMA cache maintenance"
+-	depends on CPU_V6K && SMP
++	depends on CPU_V6K && SMP && !ARCH_CNS3XXX
+ 	default y
+ 	help
+ 	  The Snoop Control Unit on ARM11MPCore does not detect the
+--- a/arch/arm/Kconfig
++++ b/arch/arm/Kconfig
+@@ -318,6 +318,7 @@ config ARCH_CNS3XXX
+ 	select ARM_GIC
+ 	select MIGHT_HAVE_PCI
+ 	select PCI_DOMAINS if PCI
++	select FIQ
+ 	help
+ 	  Support for Cavium Networks CNS3XXX platform.
+ 
+--- a/arch/arm/mach-cns3xxx/include/mach/irqs.h
++++ b/arch/arm/mach-cns3xxx/include/mach/irqs.h
+@@ -14,6 +14,7 @@
+ #define IRQ_LOCALTIMER		29
+ #define IRQ_LOCALWDOG		30
+ #define IRQ_TC11MP_GIC_START	32
++#define FIQ_START 0
+ 
+ #include <mach/cns3xxx.h>
+ 
+--- a/arch/arm/kernel/fiq.c
++++ b/arch/arm/kernel/fiq.c
+@@ -49,6 +49,8 @@
+ 
+ static unsigned long no_fiq_insn;
+ 
++unsigned int fiq_number[2] = {0, 0};
++
+ /* Default reacquire function
+  * - we always relinquish FIQ control
+  * - we always reacquire FIQ control
+@@ -70,9 +72,12 @@ static struct fiq_handler *current_fiq =
+ 
+ int show_fiq_list(struct seq_file *p, int prec)
+ {
+-	if (current_fiq != &default_owner)
+-		seq_printf(p, "%*s:              %s\n", prec, "FIQ",
+-			current_fiq->name);
++	if (current_fiq != &default_owner) {
++		seq_printf(p, "%*s: ", prec, "FIQ");
++		seq_printf(p, "%10u ", fiq_number[0]);
++		seq_printf(p, "%10u ", fiq_number[1]);
++		seq_printf(p, "      %s\n", current_fiq->name);
++	}
+ 
+ 	return 0;
+ }
+--- a/arch/arm/kernel/smp.c
++++ b/arch/arm/kernel/smp.c
+@@ -400,13 +400,13 @@ void show_ipi_list(struct seq_file *p, i
+ 	unsigned int cpu, i;
+ 
+ 	for (i = 0; i < NR_IPI; i++) {
+-		seq_printf(p, "%*s%u: ", prec - 1, "IPI", i);
++		seq_printf(p, "%*s%u:", prec - 1, "IPI", i);
+ 
+ 		for_each_present_cpu(cpu)
+ 			seq_printf(p, "%10u ",
+ 				   __get_irq_stat(cpu, ipi_irqs[i]));
+ 
+-		seq_printf(p, " %s\n", ipi_types[i]);
++		seq_printf(p, "      %s\n", ipi_types[i]);
+ 	}
+ }
+ 
+@@ -461,7 +461,7 @@ void show_local_irqs(struct seq_file *p,
+ 	for_each_present_cpu(cpu)
+ 		seq_printf(p, "%10u ", __get_irq_stat(cpu, local_timer_irqs));
+ 
+-	seq_printf(p, " Local timer interrupts\n");
++	seq_printf(p, "      Local timer interrupts\n");
+ }
+ #endif
+ 
Index: trunk/target/linux/cns3xxx/patches/300-smp_support.patch
===================================================================
--- trunk/target/linux/cns3xxx/patches/300-smp_support.patch	(revision 0)
+++ trunk/target/linux/cns3xxx/patches/300-smp_support.patch	(revision 0)
@@ -0,0 +1,63 @@
+--- a/arch/arm/Kconfig
++++ b/arch/arm/Kconfig
+@@ -312,7 +312,7 @@ config ARCH_CLPS711X
+ 
+ config ARCH_CNS3XXX
+ 	bool "Cavium Networks CNS3XXX family"
+-	select CPU_V6
++	select CPU_V6K
+ 	select ARCH_WANT_OPTIONAL_GPIOLIB
+ 	select GENERIC_CLOCKEVENTS
+ 	select ARM_GIC
+--- a/arch/arm/mach-cns3xxx/localtimer.c
++++ b/arch/arm/mach-cns3xxx/localtimer.c
+@@ -22,8 +22,9 @@
+ /*
+  * Setup the local clock events for a CPU.
+  */
+-void __cpuinit local_timer_setup(struct clock_event_device *evt)
++int __cpuinit local_timer_setup(struct clock_event_device *evt)
+ {
+ 	evt->irq = IRQ_LOCALTIMER;
+ 	twd_timer_setup(evt);
++	return 0;
+ }
+--- a/drivers/tty/serial/8250.c
++++ b/drivers/tty/serial/8250.c
+@@ -1785,6 +1785,7 @@ static void serial8250_backup_timeout(un
+ 	unsigned int iir, ier = 0, lsr;
+ 	unsigned long flags;
+ 
++	spin_lock_irqsave(&up->port.lock, flags);
+ 	/*
+ 	 * Must disable interrupts or else we risk racing with the interrupt
+ 	 * based handler.
+@@ -1802,10 +1803,8 @@ static void serial8250_backup_timeout(un
+ 	 * the "Diva" UART used on the management processor on many HP
+ 	 * ia64 and parisc boxes.
+ 	 */
+-	spin_lock_irqsave(&up->port.lock, flags);
+ 	lsr = serial_in(up, UART_LSR);
+ 	up->lsr_saved_flags |= lsr & LSR_SAVE_FLAGS;
+-	spin_unlock_irqrestore(&up->port.lock, flags);
+ 	if ((iir & UART_IIR_NO_INT) && (up->ier & UART_IER_THRI) &&
+ 	    (!uart_circ_empty(&up->port.state->xmit) || up->port.x_char) &&
+ 	    (lsr & UART_LSR_THRE)) {
+@@ -1813,12 +1812,14 @@ static void serial8250_backup_timeout(un
+ 		iir |= UART_IIR_THRI;
+ 	}
+ 
+-	if (!(iir & UART_IIR_NO_INT))
+-		serial8250_handle_port(up);
+-
+ 	if (is_real_interrupt(up->port.irq))
+ 		serial_out(up, UART_IER, ier);
+ 
++	spin_unlock_irqrestore(&up->port.lock, flags);
++
++	if (!(iir & UART_IIR_NO_INT))
++		serial8250_handle_port(up);
++
+ 	/* Standard timer interval plus 0.2s to keep the port running */
+ 	mod_timer(&up->timer,
+ 		jiffies + uart_poll_timeout(&up->port) + HZ / 5);
Index: trunk/target/linux/cns3xxx/patches/104-cns3xxx_gpio.patch
===================================================================
--- trunk/target/linux/cns3xxx/patches/104-cns3xxx_gpio.patch	(revision 27590)
+++ trunk/target/linux/cns3xxx/patches/104-cns3xxx_gpio.patch	(working copy)
@@ -1,6 +1,6 @@
 --- a/arch/arm/mach-cns3xxx/cns3420vb.c
 +++ b/arch/arm/mach-cns3xxx/cns3420vb.c
-@@ -191,7 +191,7 @@ static struct map_desc cns3420_io_desc[]
+@@ -189,7 +189,7 @@ static struct map_desc cns3420_io_desc[]
  
  static void __init cns3420_map_io(void)
  {
@@ -131,8 +131,17 @@
  
 --- a/arch/arm/mach-cns3xxx/laguna.c
 +++ b/arch/arm/mach-cns3xxx/laguna.c
-@@ -520,7 +520,7 @@ static struct map_desc laguna_io_desc[]
+@@ -488,7 +488,7 @@ static struct memory_accessor *at24_mem_
  
+ static void at24_setup(struct memory_accessor *mem_acc, void *context)
+ {
+-	char buf[8];
++	char buf[16];
+ 
+ 	at24_mem_acc = mem_acc;
+ 
+@@ -616,7 +616,7 @@ static struct map_desc laguna_io_desc[]
+ 
  static void __init laguna_map_io(void)
  {
 -	cns3xxx_map_io();
Index: trunk/target/linux/cns3xxx/patches/100-laguna_support.patch
===================================================================
--- trunk/target/linux/cns3xxx/patches/100-laguna_support.patch	(revision 27590)
+++ trunk/target/linux/cns3xxx/patches/100-laguna_support.patch	(working copy)
@@ -1,6 +1,6 @@
 --- /dev/null
 +++ b/arch/arm/mach-cns3xxx/laguna.c
-@@ -0,0 +1,761 @@
+@@ -0,0 +1,760 @@
 +/*
 + * Gateworks Corporation Laguna Platform
 + *
@@ -381,6 +381,7 @@
 +		.uartclk        = 24000000,
 +		.type           = PORT_16550A,
 +	},
++	{ },
 +};
 +
 +static struct platform_device laguna_uart = {
@@ -554,11 +555,10 @@
 +/*
 + * Watchdog
 + */
-+
 +static struct resource laguna_watchdog_resource[] = {
 +	{
 +		.start = CNS3XXX_TC11MP_TWD_BASE,
-+		.end = CNS3XXX_TC11MP_TWD_BASE + SZ_4K - 1,
++		.end = CNS3XXX_TC11MP_TWD_BASE + 0x100 - 1,
 +		.flags = IORESOURCE_MEM,
 +	},{
 +		.start = IRQ_LOCALWDOG,
@@ -575,9 +575,16 @@
 +};
 +
 +/*
-+ * Initialization
++ * GPIO
 + */
++static struct platform_device laguna_gpio_dev = {
++	.name = "GPIODEV",
++	.id = -1,
++};
 +
++/*
++ * Initialization
++ */
 +static void __init laguna_init(void)
 +{
 +	platform_device_register(&laguna_watchdog);
@@ -623,7 +630,6 @@
 +{
 +	u32 __iomem *mem;
 +	u32 reg;
-+	u8 pcie_bitmap = 0;
 +
 +	printk("Running on Gateworks Laguna %s\n", laguna_info.model);
 +
@@ -641,14 +647,6 @@
 +		    (laguna_info.config_bitmap & SATA1_LOAD))
 +			cns3xxx_ahci_init();
 +
-+		if (laguna_info.config_bitmap & (PCIE0_LOAD))
-+			pcie_bitmap |= 0x1;
-+
-+		if (laguna_info.config_bitmap & (PCIE1_LOAD))
-+			pcie_bitmap |= 0x2;
-+
-+		cns3xxx_pcie_init(pcie_bitmap);
-+
 +		if (laguna_info.config_bitmap & (USB0_LOAD)) {
 +			cns3xxx_pwr_power_up(1 << PM_PLL_HM_PD_CTRL_REG_OFFSET_PLL_USB);
 +
@@ -747,6 +745,7 @@
 +			laguna_gpio_leds_data.num_leds = 2;
 +		}
 +		platform_device_register(&laguna_gpio_leds_device);
++		platform_device_register(&laguna_gpio_dev);
 +	} else {
 +		// Do some defaults here, not sure what yet
 +	}
@@ -946,48 +945,16 @@
  spear310		MACH_SPEAR310		SPEAR310		2660
 --- a/arch/arm/mach-cns3xxx/pcie.c
 +++ b/arch/arm/mach-cns3xxx/pcie.c
-@@ -365,7 +365,7 @@ static int cns3xxx_pcie_abort_handler(un
- 	return 0;
- }
- 
--static int __init cns3xxx_pcie_init(void)
-+int cns3xxx_pcie_init(u8 bitmap)
- {
- 	int i;
- 
-@@ -373,6 +373,9 @@ static int __init cns3xxx_pcie_init(void
- 			"imprecise external abort");
- 
- 	for (i = 0; i < ARRAY_SIZE(cns3xxx_pcie); i++) {
-+		if (!(bitmap & (1 << i)))
-+			continue;
-+
+@@ -376,8 +376,10 @@ static int __init cns3xxx_pcie_init(void
  		iotable_init(cns3xxx_pcie[i].cfg_bases,
  			     ARRAY_SIZE(cns3xxx_pcie[i].cfg_bases));
  		cns3xxx_pcie_check_link(&cns3xxx_pcie[i]);
-@@ -384,4 +387,3 @@ static int __init cns3xxx_pcie_init(void
+-		cns3xxx_pcie_hw_init(&cns3xxx_pcie[i]);
+-		pci_common_init(&cns3xxx_pcie[i].hw_pci);
++		if (cns3xxx_pcie[i].linked) {
++			cns3xxx_pcie_hw_init(&cns3xxx_pcie[i]);
++			pci_common_init(&cns3xxx_pcie[i].hw_pci);
++		}
+ 	}
  
- 	return 0;
- }
--device_initcall(cns3xxx_pcie_init);
---- a/arch/arm/mach-cns3xxx/cns3420vb.c
-+++ b/arch/arm/mach-cns3xxx/cns3420vb.c
-@@ -175,6 +175,8 @@ static void __init cns3420_init(void)
- 	cns3xxx_ahci_init();
- 	cns3xxx_sdhci_init();
- 
-+	cns3xxx_pcie_init(0x3);
-+
- 	pm_power_off = cns3xxx_power_off;
- }
- 
---- a/arch/arm/mach-cns3xxx/include/mach/platform.h
-+++ b/arch/arm/mach-cns3xxx/include/mach/platform.h
-@@ -22,5 +22,7 @@ struct cns3xxx_plat_info {
- 	u32 phy[3];
- };
- 
-+extern int cns3xxx_pcie_init(u8 bitmap);
-+
- #endif /* __ASM_ARCH_PLATFORM_H */
- #endif
+ 	pci_assign_unassigned_resources();
Index: trunk/target/linux/cns3xxx/patches/053-cns3xxx_wdt.patch
===================================================================
--- trunk/target/linux/cns3xxx/patches/053-cns3xxx_wdt.patch	(revision 27590)
+++ trunk/target/linux/cns3xxx/patches/053-cns3xxx_wdt.patch	(working copy)
@@ -52,6 +52,15 @@
  
  	/* We only accept one device, and it must have an id of -1 */
  	if (dev->id != -1)
+@@ -352,7 +355,7 @@ static int __devinit mpcore_wdt_probe(st
+ 		ret = -ENXIO;
+ 		goto err_free;
+ 	}
+-	wdt->base = ioremap(res->start, resource_size(res));
++	wdt->base = ioremap(res->start + 0x100, resource_size(res));
+ 	if (!wdt->base) {
+ 		ret = -ENOMEM;
+ 		goto err_free;
 @@ -375,6 +378,22 @@ static int __devinit mpcore_wdt_probe(st
  		goto err_irq;
  	}
Index: trunk/target/linux/cns3xxx/patches/051-cns3xxx_gigabit.patch
===================================================================
--- trunk/target/linux/cns3xxx/patches/051-cns3xxx_gigabit.patch	(revision 27590)
+++ trunk/target/linux/cns3xxx/patches/051-cns3xxx_gigabit.patch	(working copy)
@@ -27,7 +27,7 @@
  obj-$(CONFIG_AMD8111_ETH) += amd8111e.o
 --- /dev/null
 +++ b/drivers/net/cns3xxx_eth.c
-@@ -0,0 +1,1269 @@
+@@ -0,0 +1,1311 @@
 +/*
 + * Cavium CNS3xxx Gigabit driver for Linux
 + *
@@ -60,7 +60,7 @@
 +#define RX_POOL_ALLOC_SIZE (sizeof(struct rx_desc) * RX_DESCS)
 +#define TX_POOL_ALLOC_SIZE (sizeof(struct tx_desc) * TX_DESCS)
 +#define REGS_SIZE 336
-+#define MAX_MRU	9500
++#define MAX_MRU (1536 + SKB_DMA_REALIGN)
 +
 +#define NAPI_WEIGHT 64
 +
@@ -81,7 +81,12 @@
 +#define TCP_CHECKSUM 0x00010000
 +
 +/* Port Config Defines */
++#define PORT_BP_ENABLE 0x00020000
 +#define PORT_DISABLE 0x00040000
++#define PORT_LEARN_DIS 0x00080000
++#define PORT_BLOCK_STATE 0x00100000
++#define PORT_BLOCK_MODE 0x00200000
++
 +#define PROMISC_OFFSET 29
 +
 +/* Global Config Defines */
@@ -103,6 +108,14 @@
 +#define QUEUE_THRESHOLD 0x000000f0
 +#define CLR_FS_STATE 0x80000000
 +
++/* Interrupt Status Defines */
++#define MAC0_STATUS_CHANGE 0x00004000
++#define MAC1_STATUS_CHANGE 0x00008000
++#define MAC2_STATUS_CHANGE 0x00010000
++#define MAC0_RX_ERROR 0x00100000
++#define MAC1_RX_ERROR 0x00200000
++#define MAC2_RX_ERROR 0x00400000
++
 +struct tx_desc
 +{
 +	u32 sdp; /* segment data pointer */
@@ -258,6 +271,8 @@
 +	u32 fs_dma_ctrl1;
 +	u32 fs_desc_ptr1;
 +	u32 fs_desc_base_addr1;
++	u32 __res7[109];
++	u32 mac_counter0[13];
 +};
 +
 +struct _tx_ring {
@@ -265,6 +280,7 @@
 +	dma_addr_t phys_addr;
 +	struct tx_desc *cur_addr;
 +	struct sk_buff *buff_tab[TX_DESCS];
++	unsigned int phys_tab[TX_DESCS];
 +	u32 free_index;
 +	u32 count_index;
 +	u32 cur_index;
@@ -277,6 +293,7 @@
 +	dma_addr_t phys_addr;
 +	struct rx_desc *cur_addr;
 +	struct sk_buff *buff_tab[RX_DESCS];
++	unsigned int phys_tab[RX_DESCS];
 +	u32 cur_index;
 +	u32 alloc_index;
 +	int alloc_count;
@@ -289,7 +306,6 @@
 +	struct cns3xxx_plat_info *plat;
 +	struct _tx_ring *tx_ring;
 +	struct _rx_ring *rx_ring;
-+	u32 mtu;
 +};
 +
 +struct port {
@@ -298,16 +314,14 @@
 +	struct sw *sw;
 +	int id;			/* logical port ID */
 +	int speed, duplex;
-+	u32 mtu;
 +};
 +
 +static spinlock_t mdio_lock;
-+static spinlock_t tx_lock;
-+static spinlock_t stat_lock;
++static DEFINE_RWLOCK(tx_lock);
 +static struct switch_regs __iomem *mdio_regs; /* mdio command and status only */
 +struct mii_bus *mdio_bus;
 +static int ports_open;
-+static struct port *switch_port_tab[3];
++static struct port *switch_port_tab[4];
 +static struct dma_pool *rx_dma_pool;
 +static struct dma_pool *tx_dma_pool;
 +struct net_device *napi_dev;
@@ -405,6 +419,21 @@
 +	mdiobus_free(mdio_bus);
 +}
 +
++static void enable_tx_dma(struct sw *sw)
++{
++	__raw_writel(0x1, &sw->regs->ts_dma_ctrl0);
++}
++
++static void disable_tx_dma(struct sw *sw)
++{
++	__raw_writel(0x0, &sw->regs->ts_dma_ctrl0);
++}
++
++static void enable_rx_dma(struct sw *sw)
++{
++	__raw_writel(0x1, &sw->regs->fs_dma_ctrl0);
++}
++
 +static void cns3xxx_adjust_link(struct net_device *dev)
 +{
 +	struct port *port = netdev_priv(dev);
@@ -439,31 +468,85 @@
 +	return (IRQ_HANDLED);
 +}
 +
++irqreturn_t eth_stat_irq(int irq, void *pdev)
++{
++	struct net_device *dev = pdev;
++	struct sw *sw = netdev_priv(dev);
++	u32 cfg;
++	u32 stat = __raw_readl(&sw->regs->intr_stat);
++	__raw_writel(0xffffffff, &sw->regs->intr_stat);
 +
++	if (stat & MAC2_RX_ERROR)
++		switch_port_tab[3]->netdev->stats.rx_dropped++;
++	if (stat & MAC1_RX_ERROR)
++		switch_port_tab[1]->netdev->stats.rx_dropped++;
++	if (stat & MAC0_RX_ERROR)
++		switch_port_tab[0]->netdev->stats.rx_dropped++;
++
++	if (stat & MAC0_STATUS_CHANGE) {
++		cfg = __raw_readl(&sw->regs->mac_cfg[0]);
++		switch_port_tab[0]->phydev->link = (cfg & 0x1);
++		switch_port_tab[0]->phydev->duplex = ((cfg >> 4) & 0x1);
++		if (((cfg >> 2) & 0x3) == 2)
++			switch_port_tab[0]->phydev->speed = 1000;
++		else if (((cfg >> 2) & 0x3) == 1)
++			switch_port_tab[0]->phydev->speed = 100;
++		else
++			switch_port_tab[0]->phydev->speed = 10;
++		cns3xxx_adjust_link(switch_port_tab[0]->netdev);
++	}
++
++	if (stat & MAC1_STATUS_CHANGE) {
++		cfg = __raw_readl(&sw->regs->mac_cfg[1]);
++		switch_port_tab[1]->phydev->link = (cfg & 0x1);
++		switch_port_tab[1]->phydev->duplex = ((cfg >> 4) & 0x1);
++		if (((cfg >> 2) & 0x3) == 2)
++			switch_port_tab[1]->phydev->speed = 1000;
++		else if (((cfg >> 2) & 0x3) == 1)
++			switch_port_tab[1]->phydev->speed = 100;
++		else
++			switch_port_tab[1]->phydev->speed = 10;
++		cns3xxx_adjust_link(switch_port_tab[1]->netdev);
++	}
++
++	if (stat & MAC2_STATUS_CHANGE) {
++		cfg = __raw_readl(&sw->regs->mac_cfg[3]);
++		switch_port_tab[3]->phydev->link = (cfg & 0x1);
++		switch_port_tab[3]->phydev->duplex = ((cfg >> 4) & 0x1);
++		if (((cfg >> 2) & 0x3) == 2)
++			switch_port_tab[3]->phydev->speed = 1000;
++		else if (((cfg >> 2) & 0x3) == 1)
++			switch_port_tab[3]->phydev->speed = 100;
++		else
++			switch_port_tab[3]->phydev->speed = 10;
++		cns3xxx_adjust_link(switch_port_tab[3]->netdev);
++	}
++
++	return (IRQ_HANDLED);
++}
++
++
 +static void cns3xxx_alloc_rx_buf(struct sw *sw, int received)
 +{
 +	struct _rx_ring *rx_ring = sw->rx_ring;
 +	unsigned int i = rx_ring->alloc_index;
-+	struct rx_desc *desc;
++	struct rx_desc *desc = &(rx_ring)->desc[i];
 +	struct sk_buff *skb;
-+	u32 mtu = sw->mtu;
++	unsigned int phys;
 +
-+	rx_ring->alloc_count += received;
-+
-+	for (received = rx_ring->alloc_count; received > 0; received--) {
-+		desc = &(rx_ring)->desc[i];
-+
-+		if ((skb = dev_alloc_skb(mtu))) {
++	for (received += rx_ring->alloc_count; received > 0; received--) {
++		if ((skb = dev_alloc_skb(MAX_MRU))) {
 +			if (SKB_DMA_REALIGN)
 +				skb_reserve(skb, SKB_DMA_REALIGN);
 +			skb_reserve(skb, NET_IP_ALIGN);
-+			desc->sdp = dma_map_single(NULL, skb->data,
-+				    mtu, DMA_FROM_DEVICE);
-+			if (dma_mapping_error(NULL, desc->sdp)) {
++			phys = dma_map_single(NULL, skb->data,
++				    MAX_MRU, DMA_FROM_DEVICE);
++			if (dma_mapping_error(NULL, phys)) {
 +				dev_kfree_skb(skb);
 +				/* Failed to map, better luck next time */
 +				goto out;;
 +			}
++			desc->sdp = phys;
 +		} else {
 +			/* Failed to allocate skb, try again next time */
 +			goto out;
@@ -471,13 +554,16 @@
 +
 +		/* put the new buffer on RX-free queue */
 +		rx_ring->buff_tab[i] = skb;
-+
-+		if (++i == RX_DESCS) {
++		rx_ring->phys_tab[i] = phys;
++		if (i == RX_DESCS - 1) {
 +			i = 0;
 +			desc->config0 = END_OF_RING | FIRST_SEGMENT |
-+					LAST_SEGMENT | mtu;
++					LAST_SEGMENT | MAX_MRU;
++			desc = &(rx_ring)->desc[i];
 +		} else {
-+			desc->config0 = FIRST_SEGMENT | LAST_SEGMENT | mtu;
++			desc->config0 = FIRST_SEGMENT | LAST_SEGMENT | MAX_MRU;
++			i++;
++			desc++;
 +		}
 +	}
 +out:
@@ -485,58 +571,14 @@
 +	rx_ring->alloc_index = i;
 +}
 +
-+static void update_tx_stats(struct sw *sw)
-+{
-+	struct _tx_ring *tx_ring = sw->tx_ring;
-+	struct tx_desc *desc;
-+	struct tx_desc *next_desc;
-+	struct sk_buff *skb;
-+	int i;
-+	int index;
-+	int num_count;
-+
-+	spin_lock_bh(&stat_lock);
-+
-+	num_count = tx_ring->num_count;
-+
-+	if (!num_count) {
-+		spin_unlock_bh(&stat_lock);
-+		return;
-+	}
-+
-+	index = tx_ring->count_index;
-+	desc = &(tx_ring)->desc[index];
-+	for (i = 0; i < num_count; i++) {
-+		skb = tx_ring->buff_tab[index];
-+		if (desc->cown) {
-+			tx_ring->buff_tab[index] = 0;
-+			if (unlikely(++index == TX_DESCS)) index = 0;
-+			next_desc = &(tx_ring)->desc[index];
-+			prefetch(next_desc + 4);
-+			if (likely(skb)) {
-+				skb->dev->stats.tx_packets++;
-+				skb->dev->stats.tx_bytes += skb->len;
-+				dev_kfree_skb_any(skb);
-+			}
-+			desc = next_desc;
-+		} else {
-+			break;
-+		}
-+	}
-+	tx_ring->num_count -= i;
-+	tx_ring->count_index = index;
-+
-+	spin_unlock_bh(&stat_lock);
-+}
-+
 +static void clear_tx_desc(struct sw *sw)
 +{
 +	struct _tx_ring *tx_ring = sw->tx_ring;
 +	struct tx_desc *desc;
-+	struct tx_desc *next_desc;
 +	int i;
 +	int index;
-+	int num_used = tx_ring->num_used - tx_ring->num_count;
++	int num_used = tx_ring->num_used;
++	struct sk_buff *skb;
 +
 +	if (num_used < (TX_DESCS >> 1))
 +		return;
@@ -545,14 +587,18 @@
 +	desc = &(tx_ring)->desc[index];
 +	for (i = 0; i < num_used; i++) {
 +		if (desc->cown) {
-+			if (unlikely(++index == TX_DESCS)) index = 0;
-+			next_desc = &(tx_ring)->desc[index];
-+			prefetch(next_desc);
-+			prefetch(next_desc + 4);
-+			if (likely(desc->sdp))
-+				dma_unmap_single(NULL, desc->sdp,
-+					desc->sdl, DMA_TO_DEVICE);
-+			desc = next_desc;
++			skb = tx_ring->buff_tab[index];
++			tx_ring->buff_tab[index] = 0;
++			if (skb)
++				dev_kfree_skb_any(skb);
++			dma_unmap_single(NULL, tx_ring->phys_tab[index],
++				desc->sdl, DMA_TO_DEVICE);
++			if (++index == TX_DESCS) {
++				index = 0;
++				desc = &(tx_ring)->desc[index];
++			} else {
++				desc++;
++			}
 +		} else {
 +			break;
 +		}
@@ -569,9 +615,7 @@
 +	int received = 0;
 +	unsigned int length;
 +	unsigned int i = rx_ring->cur_index;
-+	struct rx_desc *next_desc;
 +	struct rx_desc *desc = &(rx_ring)->desc[i];
-+	int port_id;
 +
 +	while (desc->cown) {
 +		struct sk_buff *skb;
@@ -581,19 +625,11 @@
 +
 +		skb = rx_ring->buff_tab[i];
 +
-+		if (++i == RX_DESCS) i = 0;
-+		next_desc = &(rx_ring)->desc[i];
-+		prefetch(next_desc);
++		dev = switch_port_tab[desc->sp]->netdev;
 +
-+		port_id = desc->sp;
-+		if (port_id == 4)
-+			dev = switch_port_tab[2]->netdev;
-+		else
-+			dev = switch_port_tab[port_id]->netdev;
-+
 +		length = desc->sdl;
 +		/* process received frame */
-+		dma_unmap_single(&dev->dev, desc->sdp,
++		dma_unmap_single(&dev->dev, rx_ring->phys_tab[i],
 +				 length, DMA_FROM_DEVICE);
 +
 +		skb_put(skb, length);
@@ -624,10 +660,17 @@
 +		napi_gro_receive(napi, skb);
 +
 +		received++;
-+		desc = next_desc;
++
++		if (++i == RX_DESCS) {
++			i = 0;
++			desc = &(rx_ring)->desc[i];
++		} else {
++			desc++;
++		}
 +	}
 +
 +	cns3xxx_alloc_rx_buf(sw, received);
++
 +	rx_ring->cur_index = i;
 +
 +	if (received != budget) {
@@ -635,6 +678,8 @@
 +		enable_irq(IRQ_CNS3XXX_SW_R0RXC);
 +	}
 +
++	enable_rx_dma(sw);
++
 +	return received;
 +}
 +
@@ -645,63 +690,145 @@
 +	struct _tx_ring *tx_ring = sw->tx_ring;
 +	struct tx_desc *tx_desc;
 +	int index;
-+	int len = skb->len;
++	int len;
 +	char pmap = (1 << port->id);
++	unsigned int phys;
++	unsigned int nr_frags = skb_shinfo(skb)->nr_frags;
++	struct skb_frag_struct *frag;
++	unsigned int i;
 +
 +	if (pmap == 8)
 +		pmap = (1 << 4);
 +
-+	if (unlikely(len > sw->mtu)) {
++	if (skb->len > MAX_MRU) {
 +		dev_kfree_skb(skb);
 +		dev->stats.tx_errors++;
 +		return NETDEV_TX_OK;
 +	}
 +
-+	update_tx_stats(sw);
++	write_lock(&tx_lock);
 +
-+	spin_lock_bh(&tx_lock);
-+
-+	clear_tx_desc(sw);
-+
-+	if (unlikely(tx_ring->num_used == TX_DESCS)) {
-+		spin_unlock_bh(&tx_lock);
-+		return NETDEV_TX_BUSY;
++	if ((tx_ring->num_used + nr_frags) >= TX_DESCS) {
++		clear_tx_desc(sw);
++		if ((tx_ring->num_used + nr_frags) >= TX_DESCS) {
++			write_unlock(&tx_lock);
++			return NETDEV_TX_BUSY;
++		}
 +	}
 +
 +	index = tx_ring->cur_index;
++	tx_ring->cur_index = ((tx_ring->cur_index + nr_frags + 1) % TX_DESCS);
 +
-+	if (unlikely(++tx_ring->cur_index == TX_DESCS))
-+		tx_ring->cur_index = 0;
++	write_unlock(&tx_lock);
 +
-+	tx_ring->num_used++;
-+	tx_ring->num_count++;
++	tx_desc = &(tx_ring)->desc[index];
 +
-+	spin_unlock_bh(&tx_lock);
++	if (!nr_frags) {
++		len = skb->len;
 +
-+	tx_desc = &(tx_ring)->desc[index];
++		phys = dma_map_single(NULL, skb->data, len,
++				      	DMA_TO_DEVICE);
 +
-+	tx_desc->sdp = dma_map_single(NULL, skb->data, len,
-+				      DMA_TO_DEVICE);
++		tx_desc->sdp = phys;
++		tx_desc->pmap = pmap;
++		tx_ring->phys_tab[index] = phys;
 +
-+	if (dma_mapping_error(NULL, tx_desc->sdp)) {
-+		dev_kfree_skb(skb);
-+		dev->stats.tx_errors++;
-+		return NETDEV_TX_OK;
-+	}
++		tx_ring->buff_tab[index] = skb;
++		if (index == TX_DESCS - 1) {
++			tx_desc->config0 = END_OF_RING | FIRST_SEGMENT | LAST_SEGMENT |
++				   	FORCE_ROUTE | IP_CHECKSUM | UDP_CHECKSUM |
++				   	TCP_CHECKSUM | len;
++		} else {
++			tx_desc->config0 = FIRST_SEGMENT | LAST_SEGMENT |
++				   	FORCE_ROUTE | IP_CHECKSUM | UDP_CHECKSUM |
++				   	TCP_CHECKSUM | len;
++		}
++	} else {
 +
-+	tx_desc->pmap = pmap;
-+	tx_ring->buff_tab[index] = skb;
++		disable_tx_dma(sw);
++		len = skb->len - skb->data_len;
 +
-+	if (index == TX_DESCS - 1) {
-+		tx_desc->config0 = END_OF_RING | FIRST_SEGMENT | LAST_SEGMENT |
-+				   FORCE_ROUTE | IP_CHECKSUM | UDP_CHECKSUM |
-+				   TCP_CHECKSUM | len;
-+	} else {
-+		tx_desc->config0 = FIRST_SEGMENT | LAST_SEGMENT |
-+				   FORCE_ROUTE | IP_CHECKSUM | UDP_CHECKSUM |
-+				   TCP_CHECKSUM | len;
++		phys = dma_map_single(NULL, skb->data, len,
++				      	DMA_TO_DEVICE);
++
++		tx_desc->sdp = phys;
++		tx_desc->pmap = pmap;
++		tx_ring->phys_tab[index] = phys;
++
++		if (index == TX_DESCS - 1) {
++			tx_desc->config0 = END_OF_RING | FIRST_SEGMENT |
++				   	FORCE_ROUTE | IP_CHECKSUM | UDP_CHECKSUM |
++				   	TCP_CHECKSUM | len;
++			index = 0;
++			tx_desc = &(tx_ring)->desc[index];
++		} else {
++			tx_desc->config0 = FIRST_SEGMENT |
++				   	FORCE_ROUTE | IP_CHECKSUM | UDP_CHECKSUM |
++				   	TCP_CHECKSUM | len;
++			index++;
++			tx_desc++;
++		}
++
++		for (i = 0; i < nr_frags - 1; i++) {
++
++			frag = &skb_shinfo(skb)->frags[i];
++			len = frag->size;
++
++			phys = dma_map_single(NULL, page_address(frag->page) + frag->page_offset, len,
++					      	DMA_TO_DEVICE);
++
++			tx_desc->sdp = phys;
++
++			tx_desc->pmap = pmap;
++			tx_ring->phys_tab[index] = phys;
++
++			if (index == TX_DESCS - 1) {
++				tx_desc->config0 = END_OF_RING |
++			   			FORCE_ROUTE | IP_CHECKSUM | UDP_CHECKSUM |
++			   			TCP_CHECKSUM | len;
++				index = 0;
++				tx_desc = &(tx_ring)->desc[index];
++			} else {
++				tx_desc->config0 = FORCE_ROUTE | IP_CHECKSUM | UDP_CHECKSUM |
++			   			TCP_CHECKSUM | len;
++				index++;
++				tx_desc++;
++			}
++		}
++
++		frag = &skb_shinfo(skb)->frags[i];
++		len = frag->size;
++
++		phys = dma_map_single(NULL, page_address(frag->page) + frag->page_offset, len,
++					      DMA_TO_DEVICE);
++
++		tx_desc->sdp = phys;
++
++		tx_desc->pmap = pmap;
++		tx_ring->phys_tab[index] = phys;
++		tx_ring->buff_tab[index] = skb;
++		if (index == TX_DESCS - 1) {
++			tx_desc->config0 = END_OF_RING | LAST_SEGMENT |
++				   	FORCE_ROUTE | IP_CHECKSUM | UDP_CHECKSUM |
++				   	TCP_CHECKSUM | len;
++		} else {
++			tx_desc->config0 = LAST_SEGMENT |
++				   	FORCE_ROUTE | IP_CHECKSUM | UDP_CHECKSUM |
++				   	TCP_CHECKSUM | len;
++		}
 +	}
 +
++	mb();
++
++	write_lock(&tx_lock);
++	tx_ring->num_used += nr_frags + 1;
++	write_unlock(&tx_lock);
++
++	dev->stats.tx_packets++;
++	dev->stats.tx_bytes += skb->len;
++
++	enable_tx_dma(sw);
++
 +	return NETDEV_TX_OK;
 +}
 +
@@ -776,23 +903,24 @@
 +	for (i = 0; i < RX_DESCS; i++) {
 +		struct rx_desc *desc = &(rx_ring)->desc[i];
 +		struct sk_buff *skb;
-+		if (!(skb = dev_alloc_skb(sw->mtu)))
++		if (!(skb = dev_alloc_skb(MAX_MRU)))
 +			return -ENOMEM;
 +		if (SKB_DMA_REALIGN)
 +			skb_reserve(skb, SKB_DMA_REALIGN);
 +		skb_reserve(skb, NET_IP_ALIGN);
-+		desc->sdl = sw->mtu;
++		desc->sdl = MAX_MRU;
 +		if (i == (RX_DESCS - 1))
 +			desc->eor = 1;
 +		desc->fsd = 1;
 +		desc->lsd = 1;
 +
 +		desc->sdp = dma_map_single(NULL, skb->data,
-+					    sw->mtu, DMA_FROM_DEVICE);
++					    MAX_MRU, DMA_FROM_DEVICE);
 +		if (dma_mapping_error(NULL, desc->sdp)) {
 +			return -EIO;
 +		}
 +		rx_ring->buff_tab[i] = skb;
++		rx_ring->phys_tab[i] = desc->sdp;
 +		desc->cown = 0;
 +	}
 +	__raw_writel(rx_ring->phys_addr, &sw->regs->fs_desc_ptr0);
@@ -833,7 +961,7 @@
 +			if (skb) {
 +				dma_unmap_single(NULL,
 +						 desc->sdp,
-+						 sw->mtu, DMA_FROM_DEVICE);
++						 MAX_MRU, DMA_FROM_DEVICE);
 +				dev_kfree_skb(skb);
 +			}
 +		}
@@ -873,10 +1001,13 @@
 +
 +	if (!ports_open) {
 +		request_irq(IRQ_CNS3XXX_SW_R0RXC, eth_rx_irq, IRQF_SHARED, "gig_switch", napi_dev);
++		request_irq(IRQ_CNS3XXX_SW_STATUS, eth_stat_irq, IRQF_SHARED, "gig_stat", napi_dev);
 +		napi_enable(&sw->napi);
 +		netif_start_queue(napi_dev);
-+		//enable_irq(IRQ_CNS3XXX_SW_R0RXC);
 +
++ 		__raw_writel(~(MAC0_STATUS_CHANGE | MAC1_STATUS_CHANGE | MAC2_STATUS_CHANGE |
++ 									 MAC0_RX_ERROR | MAC1_RX_ERROR | MAC2_RX_ERROR), &sw->regs->intr_mask);
++
 +		temp = __raw_readl(&sw->regs->mac_cfg[2]);
 +		temp &= ~(PORT_DISABLE);
 +		__raw_writel(temp, &sw->regs->mac_cfg[2]);
@@ -885,7 +1016,7 @@
 +		temp &= ~(TS_SUSPEND | FS_SUSPEND);
 +		__raw_writel(temp, &sw->regs->dma_auto_poll_cfg);
 +
-+		__raw_writel((TS_POLL_EN | FS_POLL_EN), &sw->regs->dma_auto_poll_cfg);
++		enable_rx_dma(sw);
 +	}
 +	temp = __raw_readl(&sw->regs->mac_cfg[port->id]);
 +	temp &= ~(PORT_DISABLE);
@@ -916,6 +1047,8 @@
 +	if (!ports_open) {
 +		disable_irq(IRQ_CNS3XXX_SW_R0RXC);
 +		free_irq(IRQ_CNS3XXX_SW_R0RXC, napi_dev);
++		disable_irq(IRQ_CNS3XXX_SW_STATUS);
++		free_irq(IRQ_CNS3XXX_SW_STATUS, napi_dev);
 +		napi_disable(&sw->napi);
 +		netif_stop_queue(napi_dev);
 +		temp = __raw_readl(&sw->regs->mac_cfg[2]);
@@ -1005,96 +1138,13 @@
 +	return 0;
 +}
 +
-+static int cns3xxx_change_mtu(struct net_device *netdev, int new_mtu)
-+{
-+	struct port *port = netdev_priv(netdev);
-+	struct sw *sw = port->sw;
-+	u32 temp;
-+	int i;
-+	struct _rx_ring *rx_ring = sw->rx_ring;
-+	struct rx_desc *desc;
-+	struct sk_buff *skb;
-+
-+	if (new_mtu > MAX_MRU)
-+		return -EINVAL;
-+
-+	netdev->mtu = new_mtu;
-+
-+	new_mtu += 36 + SKB_DMA_REALIGN;
-+	port->mtu = new_mtu;
-+
-+	new_mtu = 0;
-+	for (i = 0; i < 3; i++) {
-+		if (switch_port_tab[i]) {
-+			if (switch_port_tab[i]->mtu > new_mtu)
-+				new_mtu = switch_port_tab[i]->mtu;
-+		}
-+	}
-+
-+
-+	if (new_mtu == sw->mtu)
-+		return 0;
-+
-+	disable_irq(IRQ_CNS3XXX_SW_R0RXC);
-+
-+	sw->mtu = new_mtu;
-+
-+	/* Disable DMA */
-+	__raw_writel(TS_SUSPEND | FS_SUSPEND, &sw->regs->dma_auto_poll_cfg);
-+
-+	for (i = 0; i < RX_DESCS; i++) {
-+		desc = &(rx_ring)->desc[i];
-+		/* Check if we own it, if we do, it will get set correctly
-+		 * when it is re-used */
-+		if (!desc->cown) {
-+			skb = rx_ring->buff_tab[i];
-+			dma_unmap_single(NULL, desc->sdp, desc->sdl,
-+					 DMA_FROM_DEVICE);
-+			dev_kfree_skb(skb);
-+
-+			if ((skb = dev_alloc_skb(new_mtu))) {
-+				if (SKB_DMA_REALIGN)
-+					skb_reserve(skb, SKB_DMA_REALIGN);
-+				skb_reserve(skb, NET_IP_ALIGN);
-+				desc->sdp = dma_map_single(NULL, skb->data,
-+					    new_mtu, DMA_FROM_DEVICE);
-+				if (dma_mapping_error(NULL, desc->sdp)) {
-+					dev_kfree_skb(skb);
-+					skb = NULL;
-+				}
-+			}
-+
-+			/* put the new buffer on RX-free queue */
-+			rx_ring->buff_tab[i] = skb;
-+
-+			if (i == RX_DESCS - 1)
-+				desc->config0 = END_OF_RING | FIRST_SEGMENT |
-+						LAST_SEGMENT | new_mtu;
-+			else
-+				desc->config0 = FIRST_SEGMENT |
-+						LAST_SEGMENT | new_mtu;
-+		}
-+	}
-+
-+	/* Re-ENABLE DMA */
-+	temp = __raw_readl(&sw->regs->dma_auto_poll_cfg);
-+	temp &= ~(TS_SUSPEND | FS_SUSPEND);
-+	__raw_writel(temp, &sw->regs->dma_auto_poll_cfg);
-+
-+	__raw_writel((TS_POLL_EN | FS_POLL_EN), &sw->regs->dma_auto_poll_cfg);
-+
-+	enable_irq(IRQ_CNS3XXX_SW_R0RXC);
-+
-+	return 0;
-+}
-+
 +static const struct net_device_ops cns3xxx_netdev_ops = {
 +	.ndo_open = eth_open,
 +	.ndo_stop = eth_close,
 +	.ndo_start_xmit = eth_xmit,
 +	.ndo_set_rx_mode = eth_rx_mode,
 +	.ndo_do_ioctl = eth_ioctl,
-+	.ndo_change_mtu = cns3xxx_change_mtu,
++	.ndo_change_mtu = eth_change_mtu,
 +	.ndo_set_mac_address = eth_set_mac,
 +	.ndo_validate_addr = eth_validate_addr,
 +};
@@ -1111,12 +1161,10 @@
 +	int err;
 +	u32 temp;
 +
-+	spin_lock_init(&tx_lock);
-+	spin_lock_init(&stat_lock);
-+
 +	if (!(napi_dev = alloc_etherdev(sizeof(struct sw))))
 +		return -ENOMEM;
 +	strcpy(napi_dev->name, "switch%d");
++	napi_dev->features = NETIF_F_IP_CSUM | NETIF_F_SG;
 +
 +	SET_NETDEV_DEV(napi_dev, &pdev->dev);
 +	sw = netdev_priv(napi_dev);
@@ -1129,11 +1177,9 @@
 +		goto err_free;
 +	}
 +
-+	sw->mtu = 1536 + SKB_DMA_REALIGN;
-+
 +	for (i = 0; i < 4; i++) {
 +		temp = __raw_readl(&sw->regs->mac_cfg[i]);
-+		temp |= (PORT_DISABLE) | 0x80000000;
++		temp |= (PORT_DISABLE);
 +		__raw_writel(temp, &sw->regs->mac_cfg[i]);
 +	}
 +
@@ -1144,7 +1190,7 @@
 +	temp |= NIC_MODE | VLAN_UNAWARE;
 +	__raw_writel(temp, &sw->regs->vlan_cfg);
 +
-+	__raw_writel(UNKNOWN_VLAN_TO_CPU | ACCEPT_CRC_PACKET |
++	__raw_writel(UNKNOWN_VLAN_TO_CPU |
 +		     CRC_STRIPPING, &sw->regs->mac_glob_cfg);
 +
 +	if (!(sw->rx_ring = kmalloc(sizeof(struct _rx_ring), GFP_KERNEL))) {
@@ -1177,7 +1223,6 @@
 +			goto free_ports;
 +		}
 +
-+		//SET_NETDEV_DEV(dev, &pdev->dev);
 +		port = netdev_priv(dev);
 +		port->netdev = dev;
 +		if (i == 2)
@@ -1185,36 +1230,33 @@
 +		else
 +			port->id = i;
 +		port->sw = sw;
-+		port->mtu = sw->mtu;
 +
 +		temp = __raw_readl(&sw->regs->mac_cfg[port->id]);
-+		temp |= (PORT_DISABLE);
++		temp |= (PORT_DISABLE | PORT_BLOCK_STATE | PORT_LEARN_DIS);
 +		__raw_writel(temp, &sw->regs->mac_cfg[port->id]);
 +
 +		dev->netdev_ops = &cns3xxx_netdev_ops;
 +		dev->ethtool_ops = &cns3xxx_ethtool_ops;
 +		dev->tx_queue_len = 1000;
-+		dev->features = NETIF_F_HW_CSUM;
++		dev->features = NETIF_F_IP_CSUM | NETIF_F_SG;
 +
-+		dev->vlan_features = NETIF_F_HW_CSUM;
-+
-+		switch_port_tab[i] = port;
++		switch_port_tab[port->id] = port;
 +		memcpy(dev->dev_addr, &plat->hwaddr[i], ETH_ALEN);
 +
 +		snprintf(phy_id, MII_BUS_ID_SIZE + 3, PHY_ID_FMT, "0", plat->phy[i]);
 +		port->phydev = phy_connect(dev, phy_id, &cns3xxx_adjust_link, 0,
 +			PHY_INTERFACE_MODE_RGMII);
 +		if ((err = IS_ERR(port->phydev))) {
-+			switch_port_tab[i] = 0;
++			switch_port_tab[port->id] = 0;
 +			free_netdev(dev);
 +			goto free_ports;
 +		}
 +
-+		port->phydev->irq = PHY_POLL;
++		port->phydev->irq = PHY_IGNORE_INTERRUPT;
 +
 +		if ((err = register_netdev(dev))) {
 +			phy_disconnect(port->phydev);
-+			switch_port_tab[i] = 0;
++			switch_port_tab[port->id] = 0;
 +			free_netdev(dev);
 +			goto free_ports;
 +		}
@@ -1254,7 +1296,7 @@
 +	int i;
 +	destroy_rings(sw);
 +
-+	for (i = 2; i >= 0; i--) {
++	for (i = 3; i >= 0; i--) {
 +		if (switch_port_tab[i]) {
 +			struct port *port = switch_port_tab[i];
 +			struct net_device *dev = port->netdev;
Index: trunk/target/linux/cns3xxx/patches/107-cns3xxx_memory_layout.patch
===================================================================
--- trunk/target/linux/cns3xxx/patches/107-cns3xxx_memory_layout.patch	(revision 0)
+++ trunk/target/linux/cns3xxx/patches/107-cns3xxx_memory_layout.patch	(revision 0)
@@ -0,0 +1,20 @@
+--- a/arch/arm/mach-cns3xxx/Makefile.boot
++++ b/arch/arm/mach-cns3xxx/Makefile.boot
+@@ -1,3 +1,3 @@
+-   zreladdr-y	:= 0x00008000
+-params_phys-y	:= 0x00000100
+-initrd_phys-y	:= 0x00C00000
++   zreladdr-y	:= 0x20008000
++params_phys-y	:= 0x20000100
++initrd_phys-y	:= 0x20C00000
+--- a/arch/arm/mach-cns3xxx/include/mach/memory.h
++++ b/arch/arm/mach-cns3xxx/include/mach/memory.h
+@@ -13,7 +13,7 @@
+ /*
+  * Physical DRAM offset.
+  */
+-#define PLAT_PHYS_OFFSET		UL(0x00000000)
++#define PLAT_PHYS_OFFSET		UL(0x20000000)
+ 
+ #define __phys_to_bus(x)	((x) + PHYS_OFFSET)
+ #define __bus_to_phys(x)	((x) - PHYS_OFFSET)
Index: trunk/target/linux/cns3xxx/config-up
===================================================================
--- trunk/target/linux/cns3xxx/config-up	(revision 0)
+++ trunk/target/linux/cns3xxx/config-up	(revision 0)
@@ -0,0 +1,187 @@
+CONFIG_ALIGNMENT_TRAP=y
+CONFIG_ARCH_CNS3XXX=y
+# CONFIG_ARCH_EXYNOS4 is not set
+CONFIG_ARCH_HAS_CPU_IDLE_WAIT=y
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+# CONFIG_ARCH_USES_GETTIMEOFFSET is not set
+# CONFIG_ARCH_VT8500 is not set
+CONFIG_ARCH_WANT_OPTIONAL_GPIOLIB=y
+CONFIG_ARM=y
+CONFIG_ARM_GIC=y
+CONFIG_ARM_L1_CACHE_SHIFT=5
+CONFIG_ARM_THUMB=y
+CONFIG_ATA=y
+# CONFIG_ATA_SFF is not set
+CONFIG_ATA_VERBOSE_ERROR=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=2
+CONFIG_BLK_DEV_RAM_SIZE=16384
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CACHE_L2X0 is not set
+CONFIG_CNS3XXX_ETH=y
+CONFIG_CPU_32v6=y
+CONFIG_CPU_32v6K=y
+CONFIG_CPU_ABRT_EV6=y
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+CONFIG_CPU_CACHE_V6=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_HAS_PMU=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+CONFIG_CPU_PABRT_V6=y
+CONFIG_CPU_TLB_V6=y
+CONFIG_CPU_V6K=y
+CONFIG_DEBUG_BUGVERBOSE=y
+# CONFIG_DEBUG_USER is not set
+CONFIG_DECOMPRESS_GZIP=y
+# CONFIG_DWC_DEBUG is not set
+# CONFIG_DWC_DEVICE_ONLY is not set
+# CONFIG_DWC_HOST_ONLY is not set
+CONFIG_DWC_OTG_MODE=y
+CONFIG_EEPROM_AT24=y
+CONFIG_FIQ=y
+CONFIG_FRAME_POINTER=y
+# CONFIG_FSNOTIFY is not set
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_GENERIC_FIND_LAST_BIT=y
+CONFIG_GENERIC_GPIO=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_GPIOLIB=y
+CONFIG_GPIO_PCA953X=y
+CONFIG_GPIO_PCA953X_IRQ=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_HAS_DMA=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAVE_AOUT=y
+CONFIG_HAVE_ARCH_KGDB=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_HAVE_GENERIC_HARDIRQS=y
+CONFIG_HAVE_IDE=y
+CONFIG_HAVE_IRQ_WORK=y
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_HAVE_OPROFILE=y
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_SPARSE_IRQ=y
+CONFIG_HWMON=y
+# CONFIG_HWMON_DEBUG_CHIP is not set
+CONFIG_HW_RANDOM=m
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_CNS3XXX=y
+# CONFIG_I2C_PXA_PCI is not set
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_LZMA is not set
+CONFIG_KTIME_SCALAR=y
+CONFIG_LEDS_GPIO=y
+# CONFIG_LEDS_TRIGGER_NETDEV is not set
+CONFIG_M25PXX_USE_FAST_READ=y
+CONFIG_MACH_CNS3420VB=y
+CONFIG_MACH_GW2388=y
+CONFIG_MIGHT_HAVE_PCI=y
+CONFIG_MMC=y
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_CNS3XXX=y
+# CONFIG_MMC_SDHCI_PCI is not set
+CONFIG_MMC_SDHCI_PLTFM=y
+# CONFIG_MMC_TIFM_SD is not set
+CONFIG_MPCORE_WATCHDOG=y
+CONFIG_MTD_M25P80=y
+CONFIG_MTD_PHYSMAP=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_NEED_PER_CPU_KM=y
+CONFIG_NLS=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_PAGE_OFFSET=0x80000000
+CONFIG_PCI=y
+CONFIG_PCI_DOMAINS=y
+CONFIG_PERF_USE_VMALLOC=y
+CONFIG_PHYLIB=y
+# CONFIG_PREEMPT_RCU is not set
+# CONFIG_QUOTACTL is not set
+CONFIG_RAID_ATTRS=y
+CONFIG_RD_GZIP=y
+# CONFIG_RD_LZMA is not set
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_DS1672=y
+CONFIG_SATA_AHCI=y
+CONFIG_SATA_AHCI_CNS3XXX=y
+CONFIG_SATA_AHCI_PLATFORM=y
+CONFIG_SCSI=y
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SDIO_UART is not set
+CONFIG_SENSORS_AD7418=y
+CONFIG_SENSORS_GSP=y
+CONFIG_SERIAL_8250_NR_UARTS=20
+CONFIG_SERIAL_8250_PCI=y
+CONFIG_SERIAL_8250_RUNTIME_UARTS=20
+CONFIG_SPI=y
+CONFIG_SPI_BITBANG=y
+CONFIG_SPI_CNS3XXX=y
+# CONFIG_SPI_GPIO is not set
+CONFIG_SPI_MASTER=y
+# CONFIG_STAGING is not set
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_UID16=y
+CONFIG_USB=y
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+# CONFIG_USB_CDC_COMPOSITE is not set
+CONFIG_USB_CNS3XXX_EHCI=y
+CONFIG_USB_CNS3XXX_OHCI=y
+CONFIG_USB_DEBUG=y
+CONFIG_USB_DWC_OTG=y
+CONFIG_USB_EHCI_HCD=y
+# CONFIG_USB_ETH is not set
+# CONFIG_USB_FILE_STORAGE is not set
+# CONFIG_USB_FUNCTIONFS is not set
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGETFS is not set
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+# CONFIG_USB_GADGET_DEBUG_FS is not set
+# CONFIG_USB_GADGET_DUALSPEED is not set
+# CONFIG_USB_MIDI_GADGET is not set
+CONFIG_USB_GADGET_SELECTED=y
+CONFIG_USB_GADGET_VBUS_DRAW=2
+# CONFIG_USB_G_DBGP is not set
+# CONFIG_USB_G_HID is not set
+# CONFIG_USB_G_NCM is not set
+# CONFIG_USB_G_PRINTER is not set
+# CONFIG_USB_G_SERIAL is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_MMIO is not set
+CONFIG_USB_OHCI_HCD=y
+CONFIG_USB_SUPPORT=y
+# CONFIG_USB_UHCI_HCD is not set
+# CONFIG_USB_ZERO is not set
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_VFP=y
+CONFIG_VMSPLIT_2G=y
+# CONFIG_VMSPLIT_3G is not set
+CONFIG_WATCHDOG_NOWAYOUT=y
+CONFIG_XZ_DEC=y
+CONFIG_ZBOOT_ROM_BSS=0
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_ZONE_DMA_FLAG=0
