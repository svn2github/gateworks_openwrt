Index: trunk/target/linux/imx61/base-files/etc/inittab
===================================================================
--- trunk/target/linux/imx61/base-files/etc/inittab	(revision 0)
+++ trunk/target/linux/imx61/base-files/etc/inittab	(working copy)
@@ -0,0 +1,5 @@
+::sysinit:/etc/init.d/rcS S boot
+::shutdown:/etc/init.d/rcS K shutdown
+tts/0::askfirst:/bin/ash --login
+ttymxc1::askfirst:/bin/ash --login
+tty1::askfirst:/bin/ash --login
Index: trunk/target/linux/imx61/base-files/lib/imx61.sh
===================================================================
--- trunk/target/linux/imx61/base-files/lib/imx61.sh	(revision 0)
+++ trunk/target/linux/imx61/base-files/lib/imx61.sh	(working copy)
@@ -0,0 +1,22 @@
+#!/bin/sh
+#
+# Copyright (C) 2012 OpenWrt.org
+#
+
+imx61_board_name() {
+	local machine
+	local name
+
+	machine=$(awk 'BEGIN{FS="[ \t]+:[ \t]"} /Hardware/ {print $2}' /proc/cpuinfo)
+
+	case "$machine" in
+		"Freescale i.MX6 Quad (Device Tree)")
+			name="imx6-dt"
+			;;
+		*)
+			name="generic";
+			;;
+	esac
+	
+	echo $name
+}
Index: trunk/target/linux/imx61/base-files/lib/upgrade/platform.sh
===================================================================
--- trunk/target/linux/imx61/base-files/lib/upgrade/platform.sh	(revision 0)
+++ trunk/target/linux/imx61/base-files/lib/upgrade/platform.sh	(working copy)
@@ -0,0 +1,122 @@
+. /lib/imx61.sh
+
+RAMFS_COPY_DATA="/lib/imx61.sh"
+
+CI_BLKSZ=65536
+
+platform_find_partitions() {
+	local first dev size erasesize name
+	while read dev size erasesize name; do
+		name=${name#'"'}; name=${name%'"'}
+		case "$name" in
+			kernel|rootfs)
+				if [ -z "$first" ]; then
+					first="$name"
+				else
+					echo "$erasesize:$first:$name"
+					break
+				fi
+			;;
+		esac
+	done < /proc/mtd
+}
+
+platform_find_kernelpart() {
+	local part
+	for part in "${1%:*}" "${1#*:}"; do
+		case "$part" in
+			kernel)
+				echo "$part"
+				break
+			;;
+		esac
+	done
+}
+
+platform_do_upgrade_combined() {
+	local partitions=$(platform_find_partitions)
+	local kernelpart=$(platform_find_kernelpart "${partitions#*:}")
+	local erase_size=$((0x${partitions%%:*})); partitions="${partitions#*:}"
+	local kern_length=0x$(dd if="$1" bs=2 skip=1 count=4 2>/dev/null)
+	local kern_blocks=$(($kern_length / $CI_BLKSZ))
+	local root_blocks=$((0x$(dd if="$1" bs=2 skip=5 count=4 2>/dev/null) / $CI_BLKSZ))
+
+	v "platform_do_upgrade_combined"
+	v "partitions=$partitions"
+	v "kernelpart=$kernelpart"
+	v "erase_size=$erase_size" 
+	v "kern_blocks=$kern_blocks"
+	v "root_blocks=$root_blocks"
+
+	if [ -n "$partitions" ] && [ -n "$kernelpart" ] && \
+	   [ ${kern_blocks:-0} -gt 0 ] && \
+	   [ ${root_blocks:-0} -gt 0 ] && \
+	   [ ${erase_size:-0} -gt 0 ];
+	then
+		local append=""
+		[ -f "$CONF_TAR" -a "$SAVE_CONFIG" -eq 1 ] && append="-j $CONF_TAR"
+
+		dd if="$1" bs=$CI_BLKSZ skip=1 count=$kern_blocks 2>/dev/null | mtd write - kernel
+		dd if="$1" bs=$CI_BLKSZ skip=$((1+$kern_blocks)) count=$root_blocks 2>/dev/null | \
+				 mtd -r $append write - rootfs
+	else
+		echo "invalid image"
+	fi
+}
+
+platform_check_image() {
+	local board=$(imx61_board_name)
+	local magic="$(get_magic_word "$1")"
+	local magic_long="$(get_magic_long "$1")"
+
+	[ "$ARGC" -gt 1 ] && return 1
+
+	case "$board" in
+	imx6-dt)
+		[ "$magic" != "4349" ] && {
+			echo "Invalid image. Use *-sysupgrade.bin files on this board"
+			return 1
+		}
+
+		local md5_img=$(dd if="$1" bs=2 skip=9 count=16 2>/dev/null)
+		local md5_chk=$(dd if="$1" bs=$CI_BLKSZ skip=1 2>/dev/null | md5sum -); md5_chk="${md5_chk%% *}"
+
+		if [ -n "$md5_img" -a -n "$md5_chk" ] && [ "$md5_img" = "$md5_chk" ]; then
+			return 0
+		else
+			echo "Invalid image. Contents do not match checksum (image:$md5_img calculated:$md5_chk)"
+			return 1
+		fi
+		return 0
+		;;
+	esac
+
+	echo "Sysupgrade is not yet supported on $board."
+	return 1
+}
+
+platform_do_upgrade() {
+	local board=$(imx61_board_name)
+
+	v "board=$board"
+	case "$board" in
+	imx6-dt)
+		platform_do_upgrade_combined "$ARGV"
+		;;
+	*)
+		default_do_upgrade "$ARGV"
+		;;
+	esac
+}
+
+disable_watchdog() {
+	v "killing watchdog"
+	killall watchdog
+	( ps | grep -v 'grep' | grep '/dev/watchdog' ) && {
+		echo 'Could not disable watchdog'
+		return 1
+	}
+}
+
+# CONFIG_WATCHDOG_NOWAYOUT=y - can't kill watchdog unless kernel cmdline has a mpcore_wdt.nowayout=0
+#append sysupgrade_pre_upgrade disable_watchdog
Index: trunk/target/linux/imx61/config-3.8
===================================================================
--- trunk/target/linux/imx61/config-3.8	(revision 0)
+++ trunk/target/linux/imx61/config-3.8	(working copy)
@@ -0,0 +1,505 @@
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_AMBA_PL08X is not set
+# CONFIG_ARCH_BCM is not set
+CONFIG_ARCH_BINFMT_ELF_RANDOMIZE_PIE=y
+CONFIG_ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE=y
+CONFIG_ARCH_HAS_CPUFREQ=y
+CONFIG_ARCH_HAS_OPP=y
+CONFIG_ARCH_HAVE_CUSTOM_GPIO_H=y
+CONFIG_ARCH_MULTIPLATFORM=y
+# CONFIG_ARCH_MULTI_CPU_AUTO is not set
+# CONFIG_ARCH_MULTI_V6 is not set
+CONFIG_ARCH_MULTI_V6_V7=y
+CONFIG_ARCH_MULTI_V7=y
+CONFIG_ARCH_MXC=y
+# CONFIG_ARCH_NEEDS_CPU_IDLE_COUPLED is not set
+CONFIG_ARCH_NR_GPIO=0
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SUNXI is not set
+CONFIG_ARCH_SUPPORTS_MSI=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_ARCH_VEXPRESS=y
+# CONFIG_ARCH_VEXPRESS_CA9X4 is not set
+CONFIG_ARCH_VEXPRESS_CORTEX_A5_A9_ERRATA=y
+# CONFIG_ARCH_VT8500_SINGLE is not set
+CONFIG_ARCH_WANT_IPC_PARSE_VERSION=y
+CONFIG_ARM=y
+CONFIG_ARM_AMBA=y
+CONFIG_ARM_APPENDED_DTB=y
+CONFIG_ARM_ATAG_DTB_COMPAT=y
+# CONFIG_ARM_ATAG_DTB_COMPAT_CMDLINE_EXTEND is not set
+CONFIG_ARM_ATAG_DTB_COMPAT_CMDLINE_FROM_BOOTLOADER=y
+# CONFIG_ARM_CHARLCD is not set
+# CONFIG_ARM_CPU_SUSPEND is not set
+# CONFIG_ARM_ERRATA_430973 is not set
+CONFIG_ARM_ERRATA_720789=y
+CONFIG_ARM_ERRATA_754322=y
+# CONFIG_ARM_ERRATA_754327 is not set
+CONFIG_ARM_ERRATA_764369=y
+CONFIG_ARM_ERRATA_775420=y
+# CONFIG_ARM_EXYNOS4210_CPUFREQ is not set
+# CONFIG_ARM_EXYNOS4X12_CPUFREQ is not set
+# CONFIG_ARM_EXYNOS5250_CPUFREQ is not set
+CONFIG_ARM_GIC=y
+CONFIG_ARM_L1_CACHE_SHIFT=6
+CONFIG_ARM_L1_CACHE_SHIFT_6=y
+# CONFIG_ARM_LPAE is not set
+CONFIG_ARM_NR_BANKS=8
+CONFIG_ARM_PATCH_PHYS_VIRT=y
+# CONFIG_ARM_SP805_WATCHDOG is not set
+CONFIG_ARM_THUMB=y
+# CONFIG_ARM_THUMBEE is not set
+CONFIG_ARM_TIMER_SP804=y
+CONFIG_ATA=y
+CONFIG_ATAGS=y
+# CONFIG_ATA_SFF is not set
+CONFIG_AUTO_ZRELADDR=y
+CONFIG_CACHE_L2X0=y
+CONFIG_CACHE_PL310=y
+CONFIG_CLKDEV_LOOKUP=y
+CONFIG_CLKSRC_MMIO=y
+CONFIG_CLONE_BACKWARDS=y
+CONFIG_CMDLINE="console=ttymxc1,115200"
+CONFIG_CMDLINE_FROM_BOOTLOADER=y
+CONFIG_COMMON_CLK=y
+CONFIG_COMMON_CLK_DEBUG=y
+CONFIG_COMMON_CLK_VERSATILE=y
+CONFIG_COMPACTION=y
+CONFIG_CPU_32v6K=y
+CONFIG_CPU_32v7=y
+CONFIG_CPU_ABRT_EV7=y
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+CONFIG_CPU_CACHE_V7=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+CONFIG_CPU_FREQ=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
+# CONFIG_CPU_FREQ_GOV_CONSERVATIVE is not set
+# CONFIG_CPU_FREQ_GOV_ONDEMAND is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_GOV_POWERSAVE is not set
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_IMX=y
+CONFIG_CPU_FREQ_STAT=y
+# CONFIG_CPU_FREQ_STAT_DETAILS is not set
+CONFIG_CPU_FREQ_TABLE=y
+CONFIG_CPU_HAS_ASID=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+CONFIG_CPU_PABRT_V7=y
+CONFIG_CPU_RMAP=y
+CONFIG_CPU_TLB_V7=y
+CONFIG_CPU_V7=y
+CONFIG_CRC16=y
+CONFIG_CRYPTO_CRC32C=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_DCACHE_WORD_ACCESS=y
+CONFIG_DEBUG_IMX6Q_UART=y
+CONFIG_DEBUG_IMX6Q_UART_PORT=2
+CONFIG_DEBUG_LL=y
+CONFIG_DEBUG_LL_INCLUDE="debug/imx.S"
+# CONFIG_DEBUG_PINCTRL is not set
+# CONFIG_DEBUG_USER is not set
+# CONFIG_DEBUG_VEXPRESS_UART0_CA9 is not set
+# CONFIG_DEBUG_VEXPRESS_UART0_DETECT is not set
+# CONFIG_DEBUG_VEXPRESS_UART0_RS1 is not set
+CONFIG_DECOMPRESS_LZMA=y
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_DEVFREQ_GOV_PERFORMANCE=y
+CONFIG_DEVFREQ_GOV_POWERSAVE=y
+CONFIG_DEVFREQ_GOV_SIMPLE_ONDEMAND=y
+CONFIG_DEVFREQ_GOV_USERSPACE=y
+CONFIG_DMADEVICES=y
+CONFIG_DMADEVICES_DEBUG=y
+CONFIG_DMADEVICES_VDEBUG=y
+CONFIG_DMA_ENGINE=y
+CONFIG_DMA_SHARED_BUFFER=y
+CONFIG_DRM=y
+# CONFIG_DRM_AST is not set
+# CONFIG_DRM_CIRRUS_QEMU is not set
+# CONFIG_DRM_EXYNOS is not set
+CONFIG_DRM_GEM_CMA_HELPER=y
+# CONFIG_DRM_I2C_CH7006 is not set
+# CONFIG_DRM_I2C_SIL164 is not set
+CONFIG_DRM_IMX=y
+CONFIG_DRM_IMX_FB_HELPER=y
+CONFIG_DRM_IMX_IPUV3=y
+CONFIG_DRM_IMX_IPUV3_CORE=y
+CONFIG_DRM_IMX_PARALLEL_DISPLAY=y
+CONFIG_DRM_KMS_CMA_HELPER=y
+CONFIG_DRM_KMS_HELPER=y
+# CONFIG_DRM_LOAD_EDID_FIRMWARE is not set
+# CONFIG_DRM_MGA is not set
+# CONFIG_DRM_MGAG200 is not set
+# CONFIG_DRM_NOUVEAU is not set
+# CONFIG_DRM_R128 is not set
+# CONFIG_DRM_RADEON is not set
+# CONFIG_DRM_SAVAGE is not set
+# CONFIG_DRM_TDFX is not set
+# CONFIG_DRM_UDL is not set
+# CONFIG_DRM_VIA is not set
+# CONFIG_DRM_VMWGFX is not set
+CONFIG_DTC=y
+# CONFIG_DW_DMAC is not set
+CONFIG_EARLY_PRINTK=y
+CONFIG_EEPROM_AT24=y
+CONFIG_EXT3_FS=y
+CONFIG_EXT4_FS=y
+CONFIG_EXTRA_FIRMWARE="imx/sdma/sdma-imx6q-to1.bin"
+CONFIG_EXTRA_FIRMWARE_DIR="firmware"
+CONFIG_FB=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+CONFIG_FB_MX3=y
+# CONFIG_FB_SSD1307 is not set
+CONFIG_FB_SYS_COPYAREA=y
+CONFIG_FB_SYS_FILLRECT=y
+CONFIG_FB_SYS_IMAGEBLIT=y
+# CONFIG_FB_WMT_GE_ROPS is not set
+CONFIG_FEC=y
+# CONFIG_FEC_PTP is not set
+CONFIG_FIRMWARE_EDID=y
+CONFIG_FRAME_POINTER=y
+CONFIG_FS_MBCACHE=y
+CONFIG_GENERIC_BUG=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_GENERIC_GPIO=y
+CONFIG_GENERIC_IO=y
+CONFIG_GENERIC_IRQ_CHIP=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_GENERIC_PWM=y
+CONFIG_GENERIC_SMP_IDLE_THREAD=y
+CONFIG_GENERIC_STRNCPY_FROM_USER=y
+CONFIG_GENERIC_STRNLEN_USER=y
+CONFIG_GPIOLIB=y
+CONFIG_GPIO_GENERIC=y
+CONFIG_GPIO_MXC=y
+CONFIG_GPIO_PCA953X=y
+# CONFIG_GPIO_PCA953X_IRQ is not set
+# CONFIG_GPIO_PWM is not set
+CONFIG_GPIO_SYSFS=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_HAS_DMA=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAVE_AOUT=y
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+CONFIG_HAVE_ARCH_KGDB=y
+CONFIG_HAVE_ARCH_PFN_VALID=y
+CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_ARM_SCU=y
+CONFIG_HAVE_ARM_TWD=y
+CONFIG_HAVE_BPF_JIT=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_CLK_PREPARE=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_HAVE_DEBUG_KMEMLEAK=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_HAVE_DMA_ATTRS=y
+CONFIG_HAVE_DMA_CONTIGUOUS=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_HAVE_GENERIC_HARDIRQS=y
+CONFIG_HAVE_IDE=y
+CONFIG_HAVE_IMX_GPC=y
+CONFIG_HAVE_IMX_MMDC=y
+CONFIG_HAVE_IMX_SRC=y
+CONFIG_HAVE_IRQ_WORK=y
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_HAVE_KERNEL_XZ=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_HAVE_NET_DSA=y
+CONFIG_HAVE_OPROFILE=y
+CONFIG_HAVE_PATA_PLATFORM=y
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_SMP=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_HAVE_UID16=y
+CONFIG_HWMON=y
+CONFIG_I2C=y
+CONFIG_I2C_ALGOBIT=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_IMX=y
+CONFIG_ICST=y
+CONFIG_IMX2_WDT=y
+# CONFIG_IMX_DMA is not set
+CONFIG_IMX_PCIE=y
+CONFIG_IMX_SDMA=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_INPUT=y
+CONFIG_INPUT_MMA8450=y
+CONFIG_INPUT_POLLDEV=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_IRQ_DOMAIN=y
+CONFIG_JBD=y
+CONFIG_JBD2=y
+CONFIG_KTIME_SCALAR=y
+# CONFIG_LBDAF is not set
+CONFIG_LEDS_GPIO=y
+# CONFIG_LEDS_REGULATOR is not set
+CONFIG_LEDS_TRIGGER_BACKLIGHT=y
+CONFIG_LEDS_TRIGGER_GPIO=y
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+CONFIG_LEDS_TRIGGER_USBDEV=y
+CONFIG_LOCAL_TIMERS=y
+CONFIG_LOGO=y
+CONFIG_LOGO_LINUX_CLUT224=y
+CONFIG_LOGO_LINUX_MONO=y
+CONFIG_LOGO_LINUX_VGA16=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_M25PXX_USE_FAST_READ=y
+# CONFIG_MACH_EUKREA_CPUIMX51SD is not set
+# CONFIG_MACH_IMX51_DT is not set
+# CONFIG_MACH_MX51_3DS is not set
+# CONFIG_MACH_MX51_BABBAGE is not set
+CONFIG_MDIO_BOARDINFO=y
+CONFIG_MEDIA_ANALOG_TV_SUPPORT=y
+CONFIG_MEDIA_SUBDRV_AUTOSELECT=y
+CONFIG_MEDIA_SUPPORT=y
+CONFIG_MEDIA_TUNER=y
+CONFIG_MEDIA_TUNER_MC44S803=y
+CONFIG_MEDIA_TUNER_MT20XX=y
+CONFIG_MEDIA_TUNER_SIMPLE=y
+CONFIG_MEDIA_TUNER_TDA18271=y
+CONFIG_MEDIA_TUNER_TDA827X=y
+CONFIG_MEDIA_TUNER_TDA8290=y
+CONFIG_MEDIA_TUNER_TDA9887=y
+CONFIG_MEDIA_TUNER_XC2028=y
+CONFIG_MEDIA_TUNER_XC4000=y
+CONFIG_MEDIA_TUNER_XC5000=y
+CONFIG_MFD_SYSCON=y
+CONFIG_MIGHT_HAVE_CACHE_L2X0=y
+CONFIG_MIGRATION=y
+CONFIG_MMC=y
+CONFIG_MMC_BLOCK=y
+# CONFIG_MMC_MXC is not set
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_ESDHC_IMX=y
+CONFIG_MMC_SDHCI_IO_ACCESSORS=y
+# CONFIG_MMC_SDHCI_PCI is not set
+CONFIG_MMC_SDHCI_PLTFM=y
+# CONFIG_MMC_TIFM_SD is not set
+CONFIG_MODULES_USE_ELF_REL=y
+# CONFIG_MPCORE_WATCHDOG is not set
+CONFIG_MTD_M25P80=y
+CONFIG_MTD_OF_PARTS=y
+CONFIG_MTD_PHYSMAP=y
+CONFIG_MTD_PHYSMAP_OF=y
+CONFIG_MULTI_IRQ_HANDLER=y
+CONFIG_MUTEX_SPIN_ON_OWNER=y
+CONFIG_MX3_IPU=y
+CONFIG_MX3_IPU_IRQS=4
+# CONFIG_MXC_DEBUG_BOARD is not set
+CONFIG_MXC_IRQ_PRIOR=y
+CONFIG_MXS_DMA=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_NEED_MACH_IO_H=y
+# CONFIG_NET_DMA is not set
+CONFIG_NET_SCH_FQ_CODEL=y
+CONFIG_NLS=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_NO_HZ=y
+CONFIG_NR_CPUS=4
+CONFIG_OF=y
+CONFIG_OF_ADDRESS=y
+CONFIG_OF_DEVICE=y
+CONFIG_OF_EARLY_FLATTREE=y
+CONFIG_OF_FLATTREE=y
+CONFIG_OF_GPIO=y
+CONFIG_OF_I2C=y
+CONFIG_OF_IRQ=y
+CONFIG_OF_MDIO=y
+CONFIG_OF_MTD=y
+CONFIG_OF_NET=y
+CONFIG_OF_PCI=y
+CONFIG_OF_PCI_IRQ=y
+CONFIG_OUTER_CACHE=y
+CONFIG_OUTER_CACHE_SYNC=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_PAGE_OFFSET=0xC0000000
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_PCI=y
+CONFIG_PCI_MSI=y
+CONFIG_PERCPU_RWSEM=y
+CONFIG_PERF_USE_VMALLOC=y
+CONFIG_PHYLIB=y
+CONFIG_PINCONF=y
+CONFIG_PINCTRL=y
+CONFIG_PINCTRL_IMX=y
+CONFIG_PINCTRL_IMX6Q=y
+# CONFIG_PINCTRL_SINGLE is not set
+CONFIG_PINMUX=y
+CONFIG_PL310_ERRATA_588369=y
+CONFIG_PL310_ERRATA_727915=y
+CONFIG_PL310_ERRATA_753970=y
+CONFIG_PL310_ERRATA_769419=y
+# CONFIG_PL330_DMA is not set
+CONFIG_PLAT_VERSATILE=y
+CONFIG_PLAT_VERSATILE_CLCD=y
+CONFIG_PLAT_VERSATILE_SCHED_CLOCK=y
+CONFIG_PM_DEVFREQ=y
+# CONFIG_PM_OPP is not set
+CONFIG_PPS=y
+CONFIG_PPS_CLIENT_GPIO=y
+# CONFIG_PREEMPT_RCU is not set
+CONFIG_PROC_DEVICETREE=y
+CONFIG_RATIONAL=y
+CONFIG_REGMAP=y
+CONFIG_REGMAP_I2C=y
+CONFIG_REGMAP_MMIO=y
+CONFIG_REGMAP_SPI=y
+CONFIG_REGULATOR=y
+# CONFIG_REGULATOR_AD5398 is not set
+CONFIG_REGULATOR_ANATOP=y
+# CONFIG_REGULATOR_DEBUG is not set
+# CONFIG_REGULATOR_DUMMY is not set
+# CONFIG_REGULATOR_FAN53555 is not set
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+CONFIG_REGULATOR_GPIO=y
+# CONFIG_REGULATOR_ISL6271A is not set
+# CONFIG_REGULATOR_LP3971 is not set
+# CONFIG_REGULATOR_LP3972 is not set
+# CONFIG_REGULATOR_LP872X is not set
+# CONFIG_REGULATOR_MAX1586 is not set
+# CONFIG_REGULATOR_MAX8649 is not set
+# CONFIG_REGULATOR_MAX8660 is not set
+# CONFIG_REGULATOR_MAX8952 is not set
+# CONFIG_REGULATOR_MAX8973 is not set
+# CONFIG_REGULATOR_TPS51632 is not set
+# CONFIG_REGULATOR_TPS62360 is not set
+# CONFIG_REGULATOR_TPS65023 is not set
+# CONFIG_REGULATOR_TPS6507X is not set
+# CONFIG_REGULATOR_TPS6524X is not set
+# CONFIG_REGULATOR_USERSPACE_CONSUMER is not set
+# CONFIG_REGULATOR_VEXPRESS is not set
+# CONFIG_RFKILL_REGULATOR is not set
+CONFIG_RFS_ACCEL=y
+CONFIG_RPS=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_DS1672=y
+# CONFIG_RTC_DRV_IMXDI is not set
+# CONFIG_RTC_DRV_MXC is not set
+CONFIG_SATA_AHCI_PLATFORM=y
+CONFIG_SCHED_MC=y
+CONFIG_SCSI=y
+# CONFIG_SENSORS_VEXPRESS is not set
+# CONFIG_SERIAL_8250 is not set
+# CONFIG_SERIAL_AMBA_PL010 is not set
+# CONFIG_SERIAL_AMBA_PL011 is not set
+CONFIG_SERIAL_IMX=y
+CONFIG_SERIAL_IMX_CONSOLE=y
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+CONFIG_SMP=y
+CONFIG_SMP_ON_UP=y
+CONFIG_SND=y
+CONFIG_SND_COMPRESS_OFFLOAD=y
+# CONFIG_SND_EMU10K1_SEQ is not set
+CONFIG_SND_IMX_SOC=y
+CONFIG_SND_JACK=y
+# CONFIG_SND_OPL3_LIB_SEQ is not set
+# CONFIG_SND_OPL4_LIB_SEQ is not set
+CONFIG_SND_PCM=y
+# CONFIG_SND_RAWMIDI_SEQ is not set
+# CONFIG_SND_SBAWE_SEQ is not set
+CONFIG_SND_SOC=y
+# CONFIG_SND_SOC_ALL_CODECS is not set
+CONFIG_SND_SOC_DMAENGINE_PCM=y
+CONFIG_SND_SOC_FSL_SSI=y
+CONFIG_SND_SOC_FSL_UTILS=y
+CONFIG_SND_SOC_I2C_AND_SPI=y
+CONFIG_SND_SOC_IMX_AUDMUX=y
+CONFIG_SND_SOC_IMX_PCM=y
+CONFIG_SND_SOC_IMX_PCM_DMA=y
+CONFIG_SND_SOC_IMX_SGTL5000=y
+CONFIG_SND_SOC_SGTL5000=y
+CONFIG_SND_TIMER=y
+# CONFIG_SND_USB is not set
+# CONFIG_SOC_IMX53 is not set
+CONFIG_SOC_IMX6Q=y
+CONFIG_SOUND=y
+# CONFIG_SOUND_OSS_CORE is not set
+CONFIG_SPARSE_IRQ=y
+CONFIG_SPI=y
+CONFIG_SPI_BITBANG=y
+CONFIG_SPI_IMX=y
+CONFIG_SPI_MASTER=y
+CONFIG_STAGING_MEDIA=y
+CONFIG_STMP_DEVICE=y
+CONFIG_STOP_MACHINE=y
+CONFIG_SWP_EMULATE=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+# CONFIG_THUMB2_KERNEL is not set
+CONFIG_TICK_CPU_ACCOUNTING=y
+CONFIG_TREE_RCU=y
+CONFIG_UID16=y
+CONFIG_UIDGID_CONVERTED=y
+# CONFIG_UIDGID_STRICT_TYPE_CHECKS is not set
+CONFIG_USB=y
+# CONFIG_USB_AMD5536UDC is not set
+CONFIG_USB_ARCH_HAS_XHCI=y
+# CONFIG_USB_AUDIO is not set
+CONFIG_USB_CHIPIDEA=y
+# CONFIG_USB_CHIPIDEA_DEBUG is not set
+CONFIG_USB_CHIPIDEA_HOST=y
+CONFIG_USB_CHIPIDEA_UDC=y
+CONFIG_USB_COMMON=y
+# CONFIG_USB_EG20T is not set
+CONFIG_USB_EHCI_HCD=y
+# CONFIG_USB_EHCI_HCD_PLATFORM is not set
+# CONFIG_USB_EHCI_MXC is not set
+CONFIG_USB_EHCI_PCI=y
+# CONFIG_USB_ETH is not set
+# CONFIG_USB_FSL_USB2 is not set
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GOKU is not set
+# CONFIG_USB_G_CCG is not set
+# CONFIG_USB_IMX is not set
+# CONFIG_USB_IMX21_HCD is not set
+CONFIG_USB_MXS_PHY=y
+# CONFIG_USB_NET2280 is not set
+CONFIG_USB_OTG_UTILS=y
+CONFIG_USB_SUPPORT=y
+# CONFIG_USB_UHCI_HCD is not set
+CONFIG_USE_GENERIC_SMP_HELPERS=y
+CONFIG_USE_OF=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_VEXPRESS_CONFIG=y
+# CONFIG_VFP is not set
+CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_V4L2=y
+CONFIG_WATCHDOG_CORE=y
+CONFIG_WATCHDOG_NOWAYOUT=y
+# CONFIG_XEN is not set
+CONFIG_XPS=y
+CONFIG_XZ_DEC_ARM=y
+CONFIG_XZ_DEC_BCJ=y
+CONFIG_ZBOOT_ROM_BSS=0
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_ZONE_DMA_FLAG=0
+# CONFIG_KEYBOARD_IMX is not set
Index: trunk/target/linux/imx61/files-3.8/arch/arm/boot/dts/imx6q-gw5400.dts
===================================================================
--- trunk/target/linux/imx61/files-3.8/arch/arm/boot/dts/imx6q-gw5400.dts	(revision 0)
+++ trunk/target/linux/imx61/files-3.8/arch/arm/boot/dts/imx6q-gw5400.dts	(working copy)
@@ -0,0 +1,534 @@
+/*
+ * Copyright 2013 Gateworks Corporation
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+
+/dts-v1/;
+/include/ "imx6q.dtsi"
+
+/ {
+	model = "Gateworks Ventana GW5400";
+	compatible = "gw,imx6q-gw5400", "fsl,imx6q";
+
+	aliases {
+		ethernet0 = &eth0;
+		ethernet1 = &eth1;
+		sky2 = &eth1;
+	};
+
+	/* SDRAM addressing */
+	memory {
+		reg = <0x10000000 0x40000000>;
+	};
+
+	leds {
+		compatible = "gpio-leds";
+
+		user0 {
+			label = "gw5400::user0";
+			gpios = <&gpio4 6 0>; /* 102 -> MX6_PANLEDG# */
+			linux,default-trigger = "heartbeat";
+		};
+
+		user1 {
+			label = "gw5400::user1";
+			gpios = <&gpio4 10 0>; /* 106 -> MX6_PANLEDR# */
+		};
+
+		user2 {
+			label = "gw5400::user2";
+			gpios = <&gpio4 15 0>; /* 111 -> MX6_LOCLEDR# */
+		};
+	};
+
+	soc {
+
+		aips-bus@02000000 { /* AIPS1 */
+			spba-bus@02000000 {
+				ecspi@02008000 { /* eCSPI1 */
+					fsl,spi-num-chipselects = <1>;
+					cs-gpios = <&gpio3 19 0>;
+					pinctrl-names = "default";
+					pinctrl-0 = <&pinctrl_ecspi1_1>;
+					status = "okay";
+
+					flash: m25p80@0 {
+						#address-cells = <1>;
+						#size-cells = <1>;
+						compatible = "sst,w25q256";
+						spi-max-frequency = <30000000>;
+						reg = <0>;
+						uboot@0 {
+							reg = <0x000000 0x80000>;
+							read-only;
+						};
+						env@80000 {
+							reg = <0x080000 0x10000>;
+						};
+						kernel@90000 {
+							reg = <0x090000 0x200000>;
+						};
+						rootfs@300000 {
+							reg = <0x290000 0x0d70000>;
+						};
+					};
+				};
+
+				uart1: serial@02020000 {
+					pinctrl-names = "default";
+					pinctrl-0 = <&pinctrl_serial1_1>;
+					status = "okay";
+				};
+
+				/* i2s for aud4 */
+				ssi1: ssi@02028000 {
+					fsl,mode = "i2s-slave";
+					status = "okay";
+				};
+
+				/* i2s for aud5 */
+				ssi2: ssi@0202c000 {
+					fsl,mode = "i2s-slave";
+//					status = "okay";
+				};
+			};
+
+			/* override/augment pinmux in imxq6.dsti
+			 */
+			iomuxc@020e0000 {
+				pinctrl-names = "default";
+				pinctrl-0 = <&pinctrl_hog>;
+
+				/* audmux: HDMI Audio in I2S (Digital Audio In) */
+				audmux1 {
+					pinctrl_audmux1_1: audmux1-1 {
+						fsl,pins = <
+							177  0x80000000 /* MX6Q_PAD_EIM_D25__AUDMUX_AUD5_RXC */
+							649  0x80000000 /* MX6Q_PAD_DISP0_DAT18__AUDMUX_AUD5_TXFS */
+							657  0x80000000 /* MX6Q_PAD_DISP0_DAT19__AUDMUX_AUD5_RXD */
+						>;
+					};
+				};	
+
+				/* i2c2: PFUSE, PCIe Switch/Clock/Mezz */
+				i2c2 {
+					pinctrl_i2c2_1: i2c2grp-1 {
+						fsl,pins = <
+							925  0x4001b8b1 /* MX6Q_PAD_KEY_COL3__I2C2_SCL */
+							933  0x4001b8b1 /* MX6Q_PAD_KEY_ROW3__I2C2_SDA */
+						>;
+					};
+				};
+
+				/* i2c3: Accel, Audio Codec, Video Decoder/Encoder, MIPI, LVDS, DIO */
+				i2c3 {
+					pinctrl_i2c3_1: i2c3grp-1 {
+						fsl,pins = <
+							977  0x4001b8b1 /* MX6Q_PAD_GPIO_3__I2C3_SCL */
+							985  0x4001b8b1 /* MX6Q_PAD_GPIO_6__I2C3_SDA */
+						>;
+					};
+				};
+
+				/* UART1: RS485 */
+				serial1 {
+					pinctrl_serial1_1: serial1grp-1 {
+						fsl,pins = <
+							1242 0x1b0b1    /* MX6Q_PAD_SD3_DAT7__UART1_TXD */
+							1250 0x1b0b1    /* MX6Q_PAD_SD3_DAT6__UART1_RXD */
+//							170  0x1b0b1    /* MX6Q_PAD_EIM_D24__UART1_DTR */
+						>;
+					};
+				};
+
+				/* UART2: Console */
+				serial2 {
+					pinctrl_serial2_2: serial2grp-2 {
+						fsl,pins = <
+							1518 0x1b0b1    /* MX6Q_PAD_SD4_DAT7__UART2_TXD */
+							1494 0x1b0b1    /* MX6Q_PAD_SD4_DAT4__UART2_RXD */
+						>;
+					};
+				};
+
+				/* UART3: GPS */
+				serial3 {
+					pinctrl_serial3_1: serial3grp-1 {
+						fsl,pins = <
+							1388 0x1b0b1    /* MX6Q_PAD_SD4_CMD__UART3_TXD */
+							1394 0x1b0b1    /* MX6Q_PAD_SD4_CLK__UART3_RXD */
+						>;
+					};
+				};
+
+				/* LVDS Output */
+				lvds0 {
+					pinctrl_lvds0_1: lvds1grp-5 {
+						fsl,pins = <
+/* TODO: config */
+							1232 /* LVDS0_TX0_P__LDB_LVDS0_TX0 */
+							1231 /* LVDS0_TX1_P__LDB_LVDS0_TX1 */
+							1230 /* LVDS0_TX2_P__LDB_LVDS0_TX2 */
+							1229 /* LVDS0_CLK_P__LDB_LVDS0_CLK */
+						>;
+					};
+				};
+				
+				/* ipu1: IPU1_CSI0: HDMI reciver (Digital Video In) */
+				ipu1 {
+					pinctrl_ipu1_1: ipu1grp-5 {
+						fsl,pins = <
+/* TODO: config */
+							1068 /* CSI0_MCLK__IPU1_CSI0_HSYNC */
+							1075 /* CSI0_DATA_EN__IPU1_CSI0_DA_EN */
+							1062 /* CSI0_PIXCLK__IPU1_CSI0_PIXCLK */
+							1082 /* CSI0_VSYNC__IPU1_CSIO0_VSYNC */
+							1089 /* CSI0_DAT4__IPU1_CSI0_D_4 */
+							1097 /* CSI0_DAT5__IPU1_CSI0_D_5 */
+							1105 /* CSI0_DAT6__IPU1_CSI0_D_6 */
+							1113 /* CSI0_DAT7__IPU1_CSI0_D_7 */
+							1121 /* CSI0_DAT8__IPU1_CSI0_D_8 */
+							1129 /* CSI0_DAT9__IPU1_CSI0_D_9 */
+							1137 /* CSI0_DAT10__IPU1_CSI0_D_10 */
+							1145 /* CSI0_DAT11__IPU1_CSI0_D_11 */
+							1153 /* CSI0_DAT12__IPU1_CSI0_D_12 */
+							1161 /* CSI0_DAT13__IPU1_CSI0_D_13 */
+							1169 /* CSI0_DAT14__IPU1_CSI0_D_14 */
+							1177 /* CSI0_DAT15__IPU1_CSI0_D_15 */
+							1185 /* CSI0_DAT16__IPU1_CSI0_D_16 */
+							1193 /* CSI0_DAT17__IPU1_CSI0_D_17 */
+							1201 /* CSI0_DAT18__IPU1_CSI0_D_18 */
+							1209 /* CSI0_DAT19__IPU1_CSI0_D_19 */
+						>;
+					};
+				};
+
+				/* ipu2: IPU1_CSI1: Analog Video Decoder (Analog Video In) */
+				/* IPU2_CSI1: Analog Video Decoder (Analog Video In) */
+				ipu2 {
+					pinctrl_ipu2_1: ipu2grp-1 {
+/* TODO: config */
+						fsl,pins = <
+							358  /* PIX0 EIM_DA2__IPU2_CSI1_D_7 */
+							366  /* PIX1 EIM_DA3__IPU2_CSI1_D_6 */
+							374  /* PIX2 EIM_DA4__IPU2_CSI1_D_5 */
+							382  /* PIX3 EIM_DA5__IPU2_CSI1_D_4 */
+							390  /* PIX4 EIM_DA6__IPU2_CSI1_D_3 */
+							398  /* PIX5 EIM_DA7__IPU2_CSI1_D_2 */
+							405  /* PIX6 EIM_DA8__IPU2_CSI1_D_1 */
+							412  /* PIX7 EIM_DA9__IPU2_CSI1_D_0 */
+
+							208  /* EIM_D29__IPU2_CSI1_VSYNC */
+							159  /* EIM_EB3__IPU2_CSI1_HSYNC */
+// not sure why this causes kernel to crash in early init
+//							290  /* EIM_A16__IPU2_CSI1_PIXCLK */
+						>;
+					};
+				};
+
+
+				/* ipu3: IPU2_DISP0: Analog Video Encoder (Analog Video Out) */
+				ipu3 {
+					pinctrl_ipu3_1: ipu3grp-5 {
+						fsl,pins = <
+/* TODO: config */
+							510  /* DISP0_DAT0__IPU2_DISP0_DAT_0 */
+							517  /* DISP0_DAT1__IPU2_DISP0_DAT_1 */
+							525  /* DISP0_DAT2__IPU2_DISP0_DAT_2 */
+							533  /* DISP0_DAT3__IPU2_DISP0_DAT_3 */
+							541  /* DISP0_DAT4__IPU2_DISP0_DAT_4 */
+							549  /* DISP0_DAT5__IPU2_DISP0_DAT_5 */
+							557  /* DISP0_DAT6__IPU2_DISP0_DAT_6 */
+							565  /* DISP0_DAT7__IPU2_DISP0_DAT_7 */
+							573  /* DISP0_DAT8__IPU2_DISP0_DAT_8 */
+							581  /* DISP0_DAT9__IPU2_DISP0_DAT_9 */
+							589  /* DISP0_DAT10__IPU2_DISP0_DAT_10 */
+							596  /* DISP0_DAT11__IPU2_DISP0_DAT_11 */
+							603  /* DISP0_DAT12__IPU2_DISP0_DAT_12 */
+							610  /* DISP0_DAT13__IPU2_DISP0_DAT_13 */
+							617  /* DISP0_DAT14__IPU2_DISP0_DAT_14 */
+							623  /* DISP0_DAT15__IPU2_DISP0_DAT_15 */
+						>;
+					};
+				};
+
+				hog {
+					pinctrl_hog: hoggrp {
+						fsl,pins = <
+							/* USB OTG Power Enable */
+							144  0x80000000	/* MX6Q_PAD_EIM_D22__GPIO_3_22 */
+
+							/*  3:19 SPINOR_CS0# */
+							121  0x80000000 /* MX6Q_PAD_EIM_D19__GPIO_3_19 */
+
+							/*  1:09 MX6_DIO0 (could also be PWM1_PWM0) */
+							972  0x80000000 /* MX6Q_PAD_GPIO_9__GPIO_1_9 */
+							/*  1:19 MX6_DIO1 (could also be PWM2_PWM0) */
+							1559 0x80000000 /* MX6Q_PAD_SD1_DAT2__GPIO_1_19 */
+							/*  2:09 MX6_DIO2 (could also be PWM3_PWM0) */
+							1474 0x80000000 /* MX6Q_PAD_SD4_DAT1__GPIO_2_9 */
+							/*  2:10 MX6_DIO3 (could also be PWM3_PWM0) */
+							1482 0x80000000 /* SD4_DAT2__GPIO_2_10 */
+
+							/*  1:16 USBHUB_RST# */
+							1537 0x80000000 /* SD1_DAT0__GPIO_1_16 */
+
+							/* PCIE IRQ */
+							739  0x80000000 /* MX6Q_PAD_ENET_TX_EN__GPIO_1_28 */
+							/* PCIE RST */
+							746  0x08000000 /* MX6Q_PAD_ENET_TXD1__GPIO_1_29 */
+							/*  1:19 PCICK_SSON (resistor not loaded - or PWM, WDOG, etc) */
+							1556 0x80000000 /* SD1_CLK__GPIO_1_20 */
+
+							/*  1:12 MIPI_DIO */
+							1545  0x80000000 /* SD1_DAT3__GPIO_1_21 */
+
+							/*  AUD4_MCK */
+							953  0x80000000 /* GPIO_0__CCM_CLK0 */
+
+							/*  AUD5_MCK */
+							1375 0x80000000 /* MX6Q_PAD_NANDF_CS2__CCM_CLKO2 */
+
+							/*  MMC_CD */
+//							1262 0x80000000 /* MX6Q_PAD_SD3_DAT5__GPIO_7_0 */
+
+							/*  RS485 TXEN */
+							168  0x80000000 /* MX6Q_PAD_EIM_D24__GPIO_3_24 - gpio-88 */
+						 >;
+					};
+				};
+			};
+		};
+
+		aips-bus@02100000 { /* AIPS2 */
+			usb@02184000 { /* USB OTG */
+				vbus-supply = <&reg_usb_otg_vbus>;
+				pinctrl-names = "default";
+				pinctrl-0 = <&pinctrl_usbotg_1>;
+				disable-over-current;
+				status = "okay";
+			};
+
+			usb@02184200 { /* USB1 */
+				status = "okay";
+			};
+
+			pcie@01ffc000 { /* PCIE */
+				rst-gpios = <&gpio1 29 0>; /* PCIESWT_RST# */
+				clken-gpios = <&gpio1 20 0>; /* not used */
+				status = "okay";
+
+				eth1: sky2@8 { /* MAC/PHY on bus 8 */
+					compatible = "marvell,sky2";
+					/* Filled in by U-Boot */
+					mac-address = [ 00 00 00 00 00 00 ];
+				};	
+			};
+
+			eth0: ethernet@02188000 {
+				pinctrl-names = "default";
+				pinctrl-0 = <&pinctrl_enet_1>;
+				phy-mode = "rgmii";
+				phy-reset-gpios = <&gpio1 30 0>;
+				status = "okay";
+			};
+
+			usdhc@02198000 { /* uSDHC3 */
+				pinctrl-names = "default";
+				pinctrl-0 = <&pinctrl_usdhc3_2>;
+				cd-gpios = <&gpio7 0 0>;
+				vmmc-supply = <&reg_3p3v>;
+				status = "okay";
+			};
+
+			audmux@021d8000 {
+				status = "okay";
+				pinctrl-names = "default";
+				pinctrl-0 = <&pinctrl_audmux_1>;
+			};
+
+			uart2: serial@021e8000 {
+				status = "okay";
+				pinctrl-names = "default";
+				pinctrl-0 = <&pinctrl_serial2_2>;
+			};
+
+			uart3: serial@021ec000 {
+				status = "okay";
+				pinctrl-names = "default";
+				pinctrl-0 = <&pinctrl_serial3_1>;
+			};
+
+			i2c@021a0000 { /* I2C1 */
+				status = "okay";
+				clock-frequency = <100000>;
+				pinctrl-names = "default";
+				pinctrl-0 = <&pinctrl_i2c1_1>;
+
+				eeprom: eeprom@50 {
+					compatible = "atmel,24c02";
+					reg = <0x50>;
+					pagesize = <16>;
+				};
+
+				eeprom1: eeprom@50 {
+					compatible = "atmel,24c02";
+					reg = <0x50>;
+					pagesize = <16>;
+				};
+
+				eeprom2: eeprom@51 {
+					compatible = "atmel,24c02";
+					reg = <0x51>;
+					pagesize = <16>;
+				};
+
+				eeprom3: eeprom@52 {
+					compatible = "atmel,24c02";
+					reg = <0x52>;
+					pagesize = <16>;
+				};
+
+				eeprom4: eeprom@53 {
+					compatible = "atmel,24c02";
+					reg = <0x53>;
+					pagesize = <16>;
+				};
+
+				rtc: ds1672@68 {
+					compatible = "dallas,ds1672";
+					reg = <0x68>;
+				};
+
+				gpio: pca9555@23 {
+					compatible = "nxp,pca9555";
+					reg = <0x23>;
+					gpio-controller;
+					#gpio-cells = <2>;
+        };
+
+				hwmon: gsc@29 {
+					compatible = "gw,gsp";
+					reg = <0x29>;
+				};
+			};
+
+			i2c@021a4000 { /* I2C2 */
+				status = "okay";
+				clock-frequency = <100000>;
+				pinctrl-names = "default";
+				pinctrl-0 = <&pinctrl_i2c2_1>;
+
+				pmic: pfuze@08 {
+					compatible = "fsl,pfuze100";
+					reg = <0x0a>;
+//					interrupt-parent = <&gpio1>;
+//					interrupts = <8 0x8>; /* low-level active IRQ at GPIO1_8 */
+				};
+
+				pciswitch: pex8609@3f {
+					compatible = "plx,pex8609";
+					reg = <0x3f>;
+				};
+
+				pciclkgen: si52147@6b {
+					compatible = "sil,si52147";
+					reg = <0x6b>;
+				};
+			};
+
+			i2c@021a8000 { /* I2C3 */
+				status = "okay";
+				clock-frequency = <100000>;
+				pinctrl-names = "default";
+				pinctrl-0 = <&pinctrl_i2c3_1>;
+
+				codec: sgtl5000@0a {
+					compatible = "fsl,sgtl5000";
+					reg = <0x0a>;
+					clocks = <&clks 169>;
+					VDDA-supply = <&reg_2p5v>;
+					VDDIO-supply = <&reg_3p3v>;
+				};
+
+				accelerometer: mma8450@1c {
+					compatible = "fsl,mma8450";
+					reg = <0x1c>;
+				};
+
+				videoout: adv7393@2a {
+					compatible = "adi,adv7393";
+					reg = <0x2a>;
+				};
+
+				videoin: adv7180@20 {
+					compatible = "adi,adv7180";
+					reg = <0x20>;
+				};
+
+				hdmiin: adv7611@4c {
+					compatible = "adi,adv7611";
+					reg = <0x4c>;
+				};
+
+				touchscreen: egalax_ts@04 {
+					compatible = "eeti,egalax_ts";
+					reg = <0x04>;
+//					interrupt-parent = <&gpio7>;
+//					interrupts = <12 0x8>; /* low-level active IRQ at GPIO7_12 */
+					wakeup-gpios = <&gpio1 12 0>;
+				};
+			};
+		};
+	};
+
+	regulators {
+		compatible = "simple-bus";
+
+		reg_2p5v: 2p5v {
+			compatible = "regulator-fixed";
+			regulator-name = "2P5V";
+			regulator-min-microvolt = <2500000>;
+			regulator-max-microvolt = <2500000>;
+			regulator-always-on;
+		};
+
+		reg_3p3v: 3p3v {
+			compatible = "regulator-fixed";
+			regulator-name = "3P3V";
+			regulator-min-microvolt = <3300000>;
+			regulator-max-microvolt = <3300000>;
+			regulator-always-on;
+		};
+
+		reg_usb_otg_vbus: usb_otg_vbus {
+			compatible = "regulator-fixed";
+			regulator-name = "usb_otg_vbus";
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			gpio = <&gpio3 22 0>;
+			enable-active-high;
+		};
+	};
+
+	sound {
+		compatible = "fsl,imx6q-sabrelite-sgtl5000",
+			     "fsl,imx-audio-sgtl5000";
+		model = "imx6q-sabrelite-sgtl5000";
+		ssi-controller = <&ssi1>;
+		audio-codec = <&codec>;
+		audio-routing =
+			"MIC_IN", "Mic Jack",
+			"Mic Jack", "Mic Bias",
+			"Headphone Jack", "HP_OUT";
+		mux-int-port = <1>;
+		mux-ext-port = <4>;
+	};
+};
Index: trunk/target/linux/imx61/files-3.8/arch/arm/mach-imx/include/mach/io.h
===================================================================
--- trunk/target/linux/imx61/files-3.8/arch/arm/mach-imx/include/mach/io.h	(revision 0)
+++ trunk/target/linux/imx61/files-3.8/arch/arm/mach-imx/include/mach/io.h	(working copy)
@@ -0,0 +1,27 @@
+/*
+ * arch/arm/mach-imx/include/mach/io.h
+ *
+ *  Copyright (C) 2013 Gateworks Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_IO_H
+#define __ASM_ARCH_IO_H
+
+#define IO_SPACE_LIMIT		((resource_size_t)0xffffffff)
+#define __io(a)			__typesafe_io((a) & IO_SPACE_LIMIT)
+
+#endif
Index: trunk/target/linux/imx61/files-3.8/arch/arm/mach-imx/msi.c
===================================================================
--- trunk/target/linux/imx61/files-3.8/arch/arm/mach-imx/msi.c	(revision 0)
+++ trunk/target/linux/imx61/files-3.8/arch/arm/mach-imx/msi.c	(working copy)
@@ -0,0 +1,156 @@
+/*
+ * arch/arm/mach-mx6/msi.c
+ *
+ * PCI MSI support for the imx processor
+ *
+ * Copyright (c) 2013, Boundary Devices.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307 USA.
+ *
+ */
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/msi.h>
+#include <asm/bitops.h>
+#include <asm/mach/irq.h>
+#include <asm/irq.h>
+
+#include "hardware.h"
+#include "msi.h"
+
+#define IMX_NUM_MSI_IRQS 128
+static DECLARE_BITMAP(msi_irq_in_use, IMX_NUM_MSI_IRQS);
+static int irq_base;
+
+static void imx_msi_handler(unsigned int irq, struct irq_desc *desc)
+{
+	int i, j;
+	unsigned status;
+	struct irq_chip *chip = irq_get_chip(irq);
+
+	irq_base = irq_alloc_descs(-1, 0, IMX_NUM_MSI_IRQS, 0);
+	if (irq_base < 0) {
+		printk(KERN_ERR "%s: could not allocate IRQ numbers\n", __func__);
+		return;
+	}
+printk("%s: irq_base=%d\n", __func__, irq_base);
+
+	chained_irq_enter(chip, desc);
+	for (i = 0; i < 8; i++) {
+		status = imx_pcie_msi_pending(i);
+		while (status) {
+			j = __fls(status);
+			generic_handle_irq(irq_base + j);
+			status &= ~(1 << j);
+		}
+		irq_base += 32;
+	}
+	chained_irq_exit(chip, desc);
+}
+
+/*
+ * Dynamic irq allocate and deallocation
+ */
+int create_irq(void)
+{
+	int irq, pos;
+
+	do {
+		pos = find_first_zero_bit(msi_irq_in_use, IMX_NUM_MSI_IRQS);
+		if ((unsigned)pos >= IMX_NUM_MSI_IRQS)
+			return -ENOSPC;
+		/* test_and_set_bit operates on 32-bits at a time */
+	} while (test_and_set_bit(pos, msi_irq_in_use));
+
+	irq = irq_base + pos;
+	dynamic_irq_init(irq);
+	return irq;
+}
+
+void destroy_irq(unsigned int irq)
+{
+	int pos = irq - irq_base;
+
+	dynamic_irq_cleanup(irq);
+	clear_bit(pos, msi_irq_in_use);
+}
+
+void arch_teardown_msi_irq(unsigned int irq)
+{
+	destroy_irq(irq);
+}
+
+static void imx_msi_irq_ack(struct irq_data *d)
+{
+	return;
+}
+
+static void imx_msi_irq_enable(struct irq_data *d)
+{
+	imx_pcie_enable_irq(d->irq - irq_base, 1);
+	return unmask_msi_irq(d);
+}
+
+static void imx_msi_irq_disable(struct irq_data *d)
+{
+	imx_pcie_enable_irq(d->irq - irq_base, 0);
+	return mask_msi_irq(d);
+}
+
+static void imx_msi_irq_mask(struct irq_data *d)
+{
+	imx_pcie_mask_irq(d->irq - irq_base, 1);
+	return mask_msi_irq(d);
+}
+
+static void imx_msi_irq_unmask(struct irq_data *d)
+{
+	imx_pcie_mask_irq(d->irq - irq_base, 0);
+	return unmask_msi_irq(d);
+}
+
+static struct irq_chip imx_msi_chip = {
+	.name = "PCIe-MSI",
+	.irq_ack = imx_msi_irq_ack,
+	.irq_enable = imx_msi_irq_enable,
+	.irq_disable = imx_msi_irq_disable,
+	.irq_mask = imx_msi_irq_mask,
+	.irq_unmask = imx_msi_irq_unmask,
+};
+
+int arch_setup_msi_irq(struct pci_dev *pdev, struct msi_desc *desc)
+{
+	int irq = create_irq();
+	struct msi_msg msg;
+
+	if (irq < 0)
+		return irq;
+
+	irq_set_msi_desc(irq, desc);
+
+	msg.address_hi = 0x0;
+	msg.address_lo = MSI_MATCH_ADDR;
+	msg.data = (mxc_cpu_type << 15) | ((irq - irq_base) & 0xff);
+
+	write_msi_msg(irq, &msg);
+	irq_set_chip_and_handler(irq, &imx_msi_chip, handle_simple_irq);
+	set_irq_flags(irq, IRQF_VALID);
+	pr_info("%s: %d of %d\n", __func__, irq, NR_IRQS);
+	return 0;
+}
+
+void imx_msi_init(void)
+{
+	irq_set_chained_handler(MXC_INT_PCIE_0, imx_msi_handler);
+}
Index: trunk/target/linux/imx61/files-3.8/arch/arm/mach-imx/msi.h
===================================================================
--- trunk/target/linux/imx61/files-3.8/arch/arm/mach-imx/msi.h	(revision 0)
+++ trunk/target/linux/imx61/files-3.8/arch/arm/mach-imx/msi.h	(working copy)
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2013 Boundary Devices, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+void imx_pcie_enable_irq(unsigned pos, int set);
+void imx_pcie_mask_irq(unsigned pos, int set);
+unsigned imx_pcie_msi_pending(unsigned index);
+
+#define MSI_MATCH_ADDR	0x10000050
+#define MXC_INT_PCIE_0      152
+#define MXC_INT_PCIE_1      153
+#define MXC_INT_PCIE_2      154
+#define MXC_INT_PCIE_3      155
+
+void imx_msi_init(void);
Index: trunk/target/linux/imx61/files-3.8/arch/arm/mach-imx/pcie.c
===================================================================
--- trunk/target/linux/imx61/files-3.8/arch/arm/mach-imx/pcie.c	(revision 0)
+++ trunk/target/linux/imx61/files-3.8/arch/arm/mach-imx/pcie.c	(working copy)
@@ -0,0 +1,1023 @@
+/*
+ * arch/arm/mach-imx/pcie.c
+ *
+ * PCIe host controller driver for IMX6 SOCs
+ *
+ * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2013 Tim Harvey <tharvey@gateworks.com>
+ *
+ * Bits taken from arch/arm/mach-dove/pcie.c
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/of_gpio.h>
+
+#include <asm/signal.h>
+#include <asm/mach/pci.h>
+#include <asm/sizes.h>
+
+#include "msi.h"
+
+/* PCIe Registers */
+#define PCIE_ARB_BASE_ADDR  0x01000000
+#define PCIE_ARB_END_ADDR   0x01FFFFFF
+#define PCIE_RC_IOBLSSR     0x1c
+
+/* Register Definitions */
+#define PRT_LOG_R_BaseAddress 0x700
+
+/* Register DB_R0 */
+/* Debug Register 0 */
+#define DB_R0 (PRT_LOG_R_BaseAddress + 0x28)
+#define DB_R0_RegisterSize 32
+#define DB_R0_RegisterResetValue 0x0
+#define DB_R0_RegisterResetMask 0xFFFFFFFF
+/* End of Register Definition for DB_R0 */
+
+/* Register DB_R1 */
+/* Debug Register 1 */
+#define DB_R1 (PRT_LOG_R_BaseAddress + 0x2c)
+#define DB_R1_RegisterSize 32
+#define DB_R1_RegisterResetValue 0x0
+#define DB_R1_RegisterResetMask 0xFFFFFFFF
+/* End of Register Definition for DB_R1 */
+
+#define PCIE_PL_MSICA		0x820
+#define PCIE_PL_MSICUA		0x824
+#define PCIE_PL_MSIC_INT	0x828
+
+#define MSIC_INT_EN	0x0
+#define MSIC_INT_MASK	0x4
+#define MSIC_INT_STATUS	0x8
+
+#define ATU_R_BaseAddress 0x900
+#define ATU_VIEWPORT_R (ATU_R_BaseAddress + 0x0)
+#define ATU_REGION_CTRL1_R (ATU_R_BaseAddress + 0x4)
+#define ATU_REGION_CTRL2_R (ATU_R_BaseAddress + 0x8)
+#define ATU_REGION_LOWBASE_R (ATU_R_BaseAddress + 0xC)
+#define ATU_REGION_UPBASE_R (ATU_R_BaseAddress + 0x10)
+#define ATU_REGION_LIMIT_ADDR_R (ATU_R_BaseAddress + 0x14)
+#define ATU_REGION_LOW_TRGT_ADDR_R (ATU_R_BaseAddress + 0x18)
+#define ATU_REGION_UP_TRGT_ADDR_R (ATU_R_BaseAddress + 0x1C)
+
+/* IOMUXC */
+#define IOMUXC_GPR_BASE_ADDR	0x020E0000
+#define IOMUXC_GPR1     (imx_pcie.gpr_base + 0x04)
+#define IOMUXC_GPR8     (imx_pcie.gpr_base + 0x20)
+#define IOMUXC_GPR12    (imx_pcie.gpr_base + 0x30)
+/* GPR1: iomuxc_gpr1_pcie_ref_clk_en(iomuxc_gpr1[16]) */
+#define iomuxc_gpr1_pcie_ref_clk_en		(1 << 16)
+/* GPR1: iomuxc_gpr1_test_powerdown(iomuxc_gpr1_18) */
+#define iomuxc_gpr1_test_powerdown		(1 << 18)
+/* GPR12: iomuxc_gpr12_los_level(iomuxc_gpr12[8:4]) */
+#define iomuxc_gpr12_los_level			(0x1F << 4)
+/* GPR12: iomuxc_gpr12_app_ltssm_enable(iomuxc_gpr12[10]) */
+#define iomuxc_gpr12_app_ltssm_enable		(1 << 10)
+/* GPR12: iomuxc_gpr12_device_type(iomuxc_gpr12[15:12]) */
+#define iomuxc_gpr12_device_type		(0xF << 12)
+/* GPR8: iomuxc_gpr8_tx_deemph_gen1(iomuxc_gpr8[5:0]) */
+#define iomuxc_gpr8_tx_deemph_gen1		(0x3F << 0)
+/* GPR8: iomuxc_gpr8_tx_deemph_gen2_3p5db(iomuxc_gpr8[11:6]) */
+#define iomuxc_gpr8_tx_deemph_gen2_3p5db	(0x3F << 6)
+/* GPR8: iomuxc_gpr8_tx_deemph_gen2_6db(iomuxc_gpr8[17:12]) */
+#define iomuxc_gpr8_tx_deemph_gen2_6db		(0x3F << 12)
+/* GPR8: iomuxc_gpr8_tx_swing_full(iomuxc_gpr8[24:18]) */
+#define iomuxc_gpr8_tx_swing_full		(0x7F << 18)
+/* GPR8: iomuxc_gpr8_tx_swing_low(iomuxc_gpr8[31:25]) */
+#define iomuxc_gpr8_tx_swing_low		(0x7F << 25)
+
+/* Registers of PHY */
+/* Register PHY_STS_R */
+/* PHY Status Register */
+#define PHY_STS_R (PRT_LOG_R_BaseAddress + 0x110)
+
+/* Register PHY_CTRL_R */
+/* PHY Control Register */
+#define PHY_CTRL_R (PRT_LOG_R_BaseAddress + 0x114)
+
+#define SSP_CR_SUP_DIG_MPLL_OVRD_IN_LO 0x0011
+/* FIELD: RES_ACK_IN_OVRD [15:15]
+// FIELD: RES_ACK_IN [14:14]
+// FIELD: RES_REQ_IN_OVRD [13:13]
+// FIELD: RES_REQ_IN [12:12]
+// FIELD: RTUNE_REQ_OVRD [11:11]
+// FIELD: RTUNE_REQ [10:10]
+// FIELD: MPLL_MULTIPLIER_OVRD [9:9]
+// FIELD: MPLL_MULTIPLIER [8:2]
+// FIELD: MPLL_EN_OVRD [1:1]
+// FIELD: MPLL_EN [0:0]
+*/
+
+#define SSP_CR_SUP_DIG_ATEOVRD 0x0010
+/* FIELD: ateovrd_en [2:2]
+// FIELD: ref_usb2_en [1:1]
+// FIELD: ref_clkdiv2 [0:0]
+*/
+
+#define SSP_CR_LANE0_DIG_RX_OVRD_IN_LO 0x1005
+/* FIELD: RX_LOS_EN_OVRD [13:13]
+// FIELD: RX_LOS_EN [12:12]
+// FIELD: RX_TERM_EN_OVRD [11:11]
+// FIELD: RX_TERM_EN [10:10]
+// FIELD: RX_BIT_SHIFT_OVRD [9:9]
+// FIELD: RX_BIT_SHIFT [8:8]
+// FIELD: RX_ALIGN_EN_OVRD [7:7]
+// FIELD: RX_ALIGN_EN [6:6]
+// FIELD: RX_DATA_EN_OVRD [5:5]
+// FIELD: RX_DATA_EN [4:4]
+// FIELD: RX_PLL_EN_OVRD [3:3]
+// FIELD: RX_PLL_EN [2:2]
+// FIELD: RX_INVERT_OVRD [1:1]
+// FIELD: RX_INVERT [0:0]
+*/
+
+#define SSP_CR_LANE0_DIG_RX_ASIC_OUT 0x100D
+/* FIELD: LOS [2:2]
+// FIELD: PLL_STATE [1:1]
+// FIELD: VALID [0:0]
+*/
+
+/* control bus bit definition */
+#define PCIE_CR_CTL_DATA_LOC 0
+#define PCIE_CR_CTL_CAP_ADR_LOC 16
+#define PCIE_CR_CTL_CAP_DAT_LOC 17
+#define PCIE_CR_CTL_WR_LOC 18
+#define PCIE_CR_CTL_RD_LOC 19
+#define PCIE_CR_STAT_DATA_LOC 0
+#define PCIE_CR_STAT_ACK_LOC 16
+
+#define PCIE_CAP_STRUC_BaseAddress 0x70
+
+/* Register LNK_CAP */
+/* PCIE Link cap */
+#define LNK_CAP (PCIE_CAP_STRUC_BaseAddress + 0xc)
+
+/* End of Register Definitions */
+
+enum {
+	MemRdWr = 0,
+	MemRdLk = 1,
+	IORdWr = 2,
+	CfgRdWr0 = 4,
+	CfgRdWr1 = 5
+};
+
+struct imx_pcie_port {
+	u8			index;
+	u8			root_bus_nr;
+	void __iomem		*base;
+	void __iomem		*dbi_base;
+	spinlock_t		conf_lock;
+
+	char			io_space_name[16];
+	char			mem_space_name[16];
+
+	struct resource		res[2];
+};
+
+struct imx_pcie_info {
+	struct imx_pcie_port imx_pcie_port[1];
+	int num_pcie_ports;
+
+	void __iomem *base;
+	void __iomem *dbi_base;
+	void __iomem *gpr_base;
+
+	unsigned int pcie_pwr_en;
+	unsigned int pcie_rst;
+	unsigned int pcie_wake_up;
+	unsigned int pcie_dis;
+	unsigned int pcie_clken;
+};
+
+static struct imx_pcie_info imx_pcie;
+
+static int pcie_phy_cr_read(int addr, int *data);
+static int pcie_phy_cr_write(int addr, int data);
+static void change_field(int *in, int start, int end, int val);
+
+/* IMX PCIE GPR configure routines */
+static inline void imx_pcie_clrset(u32 mask, u32 val, void __iomem *addr)
+{
+	writel(((readl(addr) & ~mask) | (val & mask)), addr);
+}
+
+static int imx_pcie_setup(int nr, struct pci_sys_data *sys)
+{
+	struct imx_pcie_port *pp;
+
+	if (nr >= imx_pcie.num_pcie_ports)
+		return 0;
+
+	pp = &imx_pcie.imx_pcie_port[nr];
+	pp->root_bus_nr = sys->busnr;
+
+	/*
+	 * IORESOURCE_IO
+	 */
+	snprintf(pp->io_space_name, sizeof(pp->io_space_name),
+		 "PCIe %d I/O", pp->index);
+	pp->io_space_name[sizeof(pp->io_space_name) - 1] = 0;
+	pp->res[0].name = pp->io_space_name;
+	if (pp->index == 0) {
+		pp->res[0].start = PCIE_ARB_BASE_ADDR;
+		pp->res[0].end = pp->res[0].start + SZ_1M - 1;
+	}
+	pp->res[0].flags = IORESOURCE_IO;
+	if (request_resource(&ioport_resource, &pp->res[0]))
+		panic("Request PCIe IO resource failed\n");
+	pci_add_resource_offset(&sys->resources, &pp->res[0], sys->io_offset);
+
+	/*
+	 * IORESOURCE_MEM
+	 */
+	snprintf(pp->mem_space_name, sizeof(pp->mem_space_name),
+			"PCIe %d MEM", pp->index);
+	pp->mem_space_name[sizeof(pp->mem_space_name) - 1] = 0;
+	pp->res[1].name = pp->mem_space_name;
+	if (pp->index == 0) {
+		pp->res[1].start = PCIE_ARB_BASE_ADDR + SZ_1M;
+		pp->res[1].end = pp->res[1].start + SZ_16M - SZ_2M - 1;
+	}
+	pp->res[1].flags = IORESOURCE_MEM;
+	if (request_resource(&iomem_resource, &pp->res[1]))
+		panic("Request PCIe Memory resource failed\n");
+	pci_add_resource_offset(&sys->resources, &pp->res[1], sys->mem_offset);
+
+	return 1;
+}
+
+static int imx_pcie_link_up(void __iomem *dbi_base)
+{
+	/* Check the pcie link up or link down */
+	int iterations = 200;
+	u32 rc, ltssm, rx_valid, temp;
+
+	do {
+		/* link is debug bit 36 debug 1 start in bit 32 */
+		rc = readl(dbi_base + DB_R1) & (0x1 << (36 - 32)) ;
+		iterations--;
+		usleep_range(2000, 3000);
+
+		/* From L0, initiate MAC entry to gen2 if EP/RC supports gen2.
+		 * Wait 2ms (LTSSM timeout is 24ms, PHY lock is ~5us in gen2).
+		 * If (MAC/LTSSM.state == Recovery.RcvrLock)
+		 * && (PHY/rx_valid==0) then pulse PHY/rx_reset. Transition
+		 * to gen2 is stuck
+		 */
+		pcie_phy_cr_read(SSP_CR_LANE0_DIG_RX_ASIC_OUT, &rx_valid);
+		ltssm = readl(dbi_base + DB_R0) & 0x3F;
+		if ((ltssm == 0x0D) && ((rx_valid & 0x01) == 0)) {
+			pr_info("Transition to gen2 is stuck, reset PHY!\n");
+			pcie_phy_cr_read(SSP_CR_LANE0_DIG_RX_OVRD_IN_LO, &temp);
+			change_field(&temp, 3, 3, 0x1);
+			change_field(&temp, 5, 5, 0x1);
+			pcie_phy_cr_write(SSP_CR_LANE0_DIG_RX_OVRD_IN_LO,
+					0x0028);
+			usleep_range(2000, 3000);
+			pcie_phy_cr_read(SSP_CR_LANE0_DIG_RX_OVRD_IN_LO, &temp);
+			change_field(&temp, 3, 3, 0x0);
+			change_field(&temp, 5, 5, 0x0);
+			pcie_phy_cr_write(SSP_CR_LANE0_DIG_RX_OVRD_IN_LO,
+					0x0000);
+		}
+
+		if ((iterations < 0))
+			pr_info("link up failed, DB_R0:0x%08x, DB_R1:0x%08x!\n"
+					, readl(dbi_base + DB_R0)
+					, readl(dbi_base + DB_R1));
+	} while (!rc && iterations);
+
+	if (!rc)
+		return 0;
+	return 1;
+}
+
+static void imx_pcie_regions_setup(void __iomem *dbi_base)
+{
+	unsigned bus;
+	unsigned i;
+	unsigned untranslated_base = PCIE_ARB_END_ADDR +1 - SZ_1M;
+	void __iomem *p = dbi_base + PCIE_PL_MSIC_INT;
+	/*
+	 * i.MX6 defines 16MB in the AXI address map for PCIe.
+	 *
+	 * That address space excepted the pcie registers is
+	 * split and defined into different regions by iATU,
+	 * with sizes and offsets as follows:
+	 *
+	 * 0x0100_0000 --- 0x010F_FFFF 1MB IORESOURCE_IO
+	 * 0x0110_0000 --- 0x01EF_FFFF 14MB IORESOURCE_MEM
+	 * 0x01F0_0000 --- 0x01FF_FFFF 1MB Cfg + Registers
+	 */
+
+	/* CMD reg:I/O space, MEM space, and Bus Master Enable */
+	writel(readl(dbi_base + PCI_COMMAND)
+			| PCI_COMMAND_IO
+			| PCI_COMMAND_MEMORY
+			| PCI_COMMAND_MASTER,
+			dbi_base + PCI_COMMAND);
+
+	/* Set the CLASS_REV of RC CFG header to PCI_CLASS_BRIDGE_PCI */
+	writel(readl(dbi_base + PCI_CLASS_REVISION)
+			| (PCI_CLASS_BRIDGE_PCI << 16),
+			dbi_base + PCI_CLASS_REVISION);
+
+	/*
+	 * region0-3 outbound used to access target cfg
+	 */
+	for (bus = 1; bus <= 4; bus++) {
+		writel(bus - 1, dbi_base + ATU_VIEWPORT_R);
+		writel(untranslated_base, dbi_base + ATU_REGION_LOWBASE_R);
+		untranslated_base += (1 << 18);
+		if (bus == 4)
+			untranslated_base -= (1 << 14); //(remove registers)
+		writel(untranslated_base - 1, dbi_base + ATU_REGION_LIMIT_ADDR_R);
+		writel(0, dbi_base + ATU_REGION_UPBASE_R);
+
+		writel(bus << 24, dbi_base + ATU_REGION_LOW_TRGT_ADDR_R);
+		writel(0, dbi_base + ATU_REGION_UP_TRGT_ADDR_R);
+		writel((bus > 1) ? CfgRdWr1 : CfgRdWr0,
+				dbi_base + ATU_REGION_CTRL1_R);
+		writel((1<<31), dbi_base + ATU_REGION_CTRL2_R);
+	}
+
+	writel(MSI_MATCH_ADDR, dbi_base + PCIE_PL_MSICA);
+	writel(0, dbi_base + PCIE_PL_MSICUA);
+	for (i = 0; i < 8 ; i++) {
+		writel(0, p + MSIC_INT_EN);
+		writel(0xffffffff, p + MSIC_INT_MASK);
+		writel(0xffffffff, p + MSIC_INT_STATUS);
+		p += 12;
+	}
+}
+
+void imx_pcie_mask_irq(unsigned pos, int set)
+{
+	unsigned mask = 1 << (pos & 0x1f);
+	unsigned val, newval;
+	void __iomem *p = imx_pcie.dbi_base + PCIE_PL_MSIC_INT + MSIC_INT_MASK + ((pos >> 5) * 12);
+	if (pos >= (8 * 32))
+		return;
+	val = readl(p);
+	if (set)
+		newval = val | mask;
+	else
+		newval = val & ~mask;
+	if (val != newval)
+		writel(newval, p);
+}
+
+void imx_pcie_enable_irq(unsigned pos, int set)
+{
+	unsigned mask = 1 << (pos & 0x1f);
+	unsigned val, newval;
+	void __iomem *p = imx_pcie.dbi_base + PCIE_PL_MSIC_INT + MSIC_INT_EN + ((pos >> 5) * 12);
+	if (pos >= (8 * 32))
+		return;
+	val = readl(p);
+	if (set)
+		newval = val | mask;
+	else
+		newval = val & ~mask;
+	if (val != newval)
+		writel(newval, p);
+	if (set && (val != newval))
+		imx_pcie_mask_irq(pos, 0);	/* unmask when enabled */
+}
+
+unsigned imx_pcie_msi_pending(unsigned index)
+{
+	unsigned val, mask;
+	void __iomem *p = imx_pcie.dbi_base + PCIE_PL_MSIC_INT + (index * 12);
+	if (index >= 8)
+		return 0;
+	val = readl(p + MSIC_INT_STATUS);
+	mask = readl(p + MSIC_INT_MASK);
+	val &= ~mask;
+	writel(val, p + MSIC_INT_STATUS);
+	return val;
+}
+
+static char master_abort(struct pci_bus *bus, u32 devfn, int where)
+{
+	u32 reg;
+	void __iomem *dbi_base = imx_pcie.dbi_base;
+	int ret = 0;
+
+ 	reg = readl(dbi_base + PCIE_RC_IOBLSSR);
+	if (reg & 0x71000000) {
+		if (reg & 1<<30)
+			pr_err("%d:%02d.%d 0x%04x: parity error\n", bus->number, PCI_SLOT(devfn), PCI_FUNC(devfn), where);
+		if (reg & 1<<29) {
+			pr_err("%d:%02d.%d 0x%04x: master abort\n", bus->number, PCI_SLOT(devfn), PCI_FUNC(devfn), where);
+			ret = 1;
+		}
+		if (reg & 1<<28)
+			pr_err("%d:%02d.%d 0x%04x: target abort\n", bus->number, PCI_SLOT(devfn), PCI_FUNC(devfn), where);
+		if (reg & 1<<24)
+			pr_err("%d:%02d.%d 0x%04x: master data parity error\n", bus->number, PCI_SLOT(devfn), PCI_FUNC(devfn), where);
+		writel(reg, dbi_base + PCIE_RC_IOBLSSR);
+		udelay(1500); // without this delay subsequent reads through bridge can erroneously return 0???
+	}
+	return ret;
+}
+
+static volatile void *get_cfg_addr(struct pci_bus *bus, u32 devfn, int where)
+{
+	unsigned busnum;
+	void __iomem *base = imx_pcie.base;
+	void __iomem *dbi_base = imx_pcie.dbi_base;
+
+	if (!bus->number) {
+		if (devfn != 0)
+			return 0;
+		return (imx_pcie.dbi_base) + (where & 0x0ffc);
+	}
+	if ((devfn > 0xff) || (bus->number > 15))
+		return 0;
+	busnum = bus->number - 1;
+	if ((busnum < 3) && (devfn <= 3)) {
+		return (base) + (busnum << 18) + (devfn << 16) + (where & 0xfffc);
+	}
+	writel(3, dbi_base + ATU_VIEWPORT_R);
+	writel((bus->number << 24) | (devfn << 16),
+			dbi_base + ATU_REGION_LOW_TRGT_ADDR_R);
+	writel((bus->number > 1) ? CfgRdWr1 : CfgRdWr0,
+			dbi_base + ATU_REGION_CTRL1_R);
+	return (base) + (3 << 18) + (where & 0xfffc);
+}
+
+static int imx_pcie_rd_conf(struct pci_bus *bus, u32 devfn, int where,
+			int size, u32 *val)
+{
+	const volatile void *va_address;
+	u32 v;
+
+	if (0)
+		pr_info("%s: bus=%x, devfn=%x, where=%x size=%x\n", __func__, bus->number, devfn, where, size);
+	va_address = get_cfg_addr(bus, devfn, where);
+	if (!va_address) {
+		*val = 0xffffffff;
+		return PCIBIOS_DEVICE_NOT_FOUND;
+	}
+	v = readl(va_address);
+	if (master_abort(bus, devfn, where)) {
+		return PCIBIOS_DEVICE_NOT_FOUND;	
+	}
+	if (0)
+		pr_info("%s: bus=%x, devfn=%x, where=%x size=%x v=%x\n", __func__, bus->number, devfn, where, size, v);
+	if (size == 4) {
+		*val = v;
+	} else if (size == 1) {
+		*val = (v >> (8 * (where & 3))) & 0xFF;
+	} else if (size == 2) {
+		*val = (v >> (8 * (where & 3))) & 0xFFFF;
+	} else {
+		*val = 0xffffffff;
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+	}
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int imx_pcie_wr_conf(struct pci_bus *bus, u32 devfn,
+			int where, int size, u32 val)
+{
+	volatile void *va_address;
+	u32 mask, tmp;
+
+	if (0)
+		pr_info("%s: bus=%x, devfn=%x, where=%x size=%x val=%x\n", __func__, bus->number, devfn, where, size, val);
+	va_address = get_cfg_addr(bus, devfn, where);
+	if (!va_address)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+	if (size == 4) {
+		writel(val, va_address);
+		return (master_abort(bus, devfn, where))
+			?PCIBIOS_DEVICE_NOT_FOUND:PCIBIOS_SUCCESSFUL;
+	}
+	if (size == 2)
+		mask = ~(0xFFFF << ((where & 0x3) * 8));
+	else if (size == 1)
+		mask = ~(0xFF << ((where & 0x3) * 8));
+	else
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+
+	tmp = readl(va_address) & mask;
+	tmp |= val << ((where & 0x3) * 8);
+	writel(tmp, va_address);
+	return (master_abort(bus, devfn, where))
+		?PCIBIOS_DEVICE_NOT_FOUND:PCIBIOS_SUCCESSFUL;
+}
+
+static struct pci_ops imx_pcie_ops = {
+	.read = imx_pcie_rd_conf,
+	.write = imx_pcie_wr_conf,
+};
+
+signed short irq_map[] = {
+	-EINVAL,
+	MXC_INT_PCIE_3,		/* int a */
+	MXC_INT_PCIE_2,		/* int b */
+	MXC_INT_PCIE_1,		/* int c */
+	MXC_INT_PCIE_0,		/* int d/MSI */
+};
+
+static int imx_pcie_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
+{
+	int val = -EINVAL;
+	if (pin <= 4)
+		val = irq_map[pin];
+	return val;
+}
+
+static struct hw_pci imx_pci __initdata = {
+	.nr_controllers	= 1,
+	.setup		= imx_pcie_setup,
+	.ops    = &imx_pcie_ops,
+	.map_irq	= imx_pcie_map_irq,
+};
+
+/* PHY CR bus acess routines */
+static int pcie_phy_cr_ack_polling(int max_iterations, int exp_val)
+{
+	u32 temp_rd_data, wait_counter = 0;
+
+	do {
+		temp_rd_data = readl(imx_pcie.dbi_base + PHY_STS_R);
+		temp_rd_data = (temp_rd_data >> PCIE_CR_STAT_ACK_LOC) & 0x1;
+		wait_counter++;
+	} while ((wait_counter < max_iterations) && (temp_rd_data != exp_val));
+
+	if (temp_rd_data != exp_val)
+		return 0 ;
+	return 1 ;
+}
+
+static int pcie_phy_cr_cap_addr(int addr)
+{
+	u32 temp_wr_data;
+	void __iomem *dbi_base = imx_pcie.dbi_base;
+
+	/* write addr */
+	temp_wr_data = addr << PCIE_CR_CTL_DATA_LOC ;
+	writel(temp_wr_data, dbi_base + PHY_CTRL_R);
+
+	/* capture addr */
+	temp_wr_data |= (0x1 << PCIE_CR_CTL_CAP_ADR_LOC);
+	writel(temp_wr_data, dbi_base + PHY_CTRL_R);
+
+	/* wait for ack */
+	if (!pcie_phy_cr_ack_polling(100, 1))
+		return 0;
+
+	/* deassert cap addr */
+	temp_wr_data = addr << PCIE_CR_CTL_DATA_LOC;
+	writel(temp_wr_data, dbi_base + PHY_CTRL_R);
+
+	/* wait for ack de-assetion */
+	if (!pcie_phy_cr_ack_polling(100, 0))
+		return 0 ;
+
+	return 1 ;
+}
+
+static int pcie_phy_cr_read(int addr , int *data)
+{
+	u32 temp_rd_data, temp_wr_data;
+	void __iomem *dbi_base = imx_pcie.dbi_base;
+
+	/*  write addr */
+	/* cap addr */
+	if (!pcie_phy_cr_cap_addr(addr))
+		return 0;
+
+	/* assert rd signal */
+	temp_wr_data = 0x1 << PCIE_CR_CTL_RD_LOC;
+	writel(temp_wr_data, dbi_base + PHY_CTRL_R);
+
+	/* wait for ack */
+	if (!pcie_phy_cr_ack_polling(100, 1))
+		return 0;
+
+	/* after got ack return data */
+	temp_rd_data = readl(dbi_base + PHY_STS_R);
+	*data = (temp_rd_data & (0xffff << PCIE_CR_STAT_DATA_LOC)) ;
+
+	/* deassert rd signal */
+	temp_wr_data = 0x0;
+	writel(temp_wr_data, dbi_base + PHY_CTRL_R);
+
+	/* wait for ack de-assetion */
+	if (!pcie_phy_cr_ack_polling(100, 0))
+		return 0 ;
+
+	return 1 ;
+
+}
+
+static int pcie_phy_cr_write(int addr, int data)
+{
+	u32 temp_wr_data;
+	void __iomem *dbi_base = imx_pcie.dbi_base;
+
+	/* write addr */
+	/* cap addr */
+	if (!pcie_phy_cr_cap_addr(addr))
+		return 0 ;
+
+	temp_wr_data = data << PCIE_CR_CTL_DATA_LOC;
+	writel(temp_wr_data, dbi_base + PHY_CTRL_R);
+
+	/* capture data */
+	temp_wr_data |= (0x1 << PCIE_CR_CTL_CAP_DAT_LOC);
+	writel(temp_wr_data, dbi_base + PHY_CTRL_R);
+
+	/* wait for ack */
+	if (!pcie_phy_cr_ack_polling(100, 1))
+		return 0 ;
+
+	/* deassert cap data */
+	temp_wr_data = data << PCIE_CR_CTL_DATA_LOC;
+	writel(temp_wr_data, dbi_base + PHY_CTRL_R);
+
+	/* wait for ack de-assetion */
+	if (!pcie_phy_cr_ack_polling(100, 0))
+		return 0;
+
+	/* assert wr signal */
+	temp_wr_data = 0x1 << PCIE_CR_CTL_WR_LOC;
+	writel(temp_wr_data, dbi_base + PHY_CTRL_R);
+
+	/* wait for ack */
+	if (!pcie_phy_cr_ack_polling(100, 1))
+		return 0;
+
+	/* deassert wr signal */
+	temp_wr_data = data << PCIE_CR_CTL_DATA_LOC;
+	writel(temp_wr_data, dbi_base + PHY_CTRL_R);
+
+	/* wait for ack de-assetion */
+	if (!pcie_phy_cr_ack_polling(100, 0))
+		return 0;
+
+	temp_wr_data = 0x0 ;
+	writel(temp_wr_data, dbi_base + PHY_CTRL_R);
+
+	return 1 ;
+}
+
+static void change_field(int *in, int start, int end, int val)
+{
+	int mask;
+
+	mask = ((0xFFFFFFFF << start) ^ (0xFFFFFFFF << (end + 1))) & 0xFFFFFFFF;
+	*in = (*in & ~mask) | (val << start);
+}
+
+static int imx_pcie_enable_controller(struct device *dev)
+{
+	struct clk *pcie_clk;
+
+	if (gpio_is_valid(imx_pcie.pcie_pwr_en)) {
+		/* Enable PCIE power */
+		gpio_request(imx_pcie.pcie_pwr_en, "PCIE POWER_EN");
+
+		/* activate PCIE_PWR_EN */
+		gpio_direction_output(imx_pcie.pcie_pwr_en, 1);
+	}
+
+	// power up PCIe PHY
+	imx_pcie_clrset(iomuxc_gpr1_test_powerdown, 0 << 18, IOMUXC_GPR1);
+
+	/* enable the clks */
+	pcie_clk = devm_clk_get(dev, "pcie_clk");
+	if (IS_ERR(pcie_clk)) {
+		pr_err("no pcie clock.\n");
+		return -EINVAL;
+	}
+
+	if (clk_prepare_enable(pcie_clk)) {
+		pr_err("can't enable pcie clock.\n");
+		clk_put(pcie_clk);
+		return -EINVAL;
+	}
+
+	// Enable PCIe PHY ref clock
+	imx_pcie_clrset(iomuxc_gpr1_pcie_ref_clk_en, 1 << 16, IOMUXC_GPR1);
+
+	return 0;
+}
+
+static void card_reset(struct device *dev)
+{
+	if (gpio_is_valid(imx_pcie.pcie_rst)) {
+		/* PCIE RESET */
+		gpio_request(imx_pcie.pcie_rst, "PCIE RESET");
+
+		/* activate PERST_B */
+		gpio_direction_output(imx_pcie.pcie_rst, 0);
+
+		/* Add one reset to the pcie external device */
+		msleep(100);
+
+		/* deactive PERST_B */
+		gpio_direction_output(imx_pcie.pcie_rst, 1);
+	}
+}
+
+static void add_pcie_port(void __iomem *base, void __iomem *dbi_base)
+{
+	struct clk *pcie_clk;
+
+	if (imx_pcie_link_up(dbi_base)) {
+		struct imx_pcie_port *pp = &imx_pcie.imx_pcie_port[imx_pcie.num_pcie_ports++];
+
+		pr_info("IMX PCIe port: link up.\n");
+
+		pp->index = 0;
+		pp->root_bus_nr = -1;
+		pp->base = base;
+		pp->dbi_base = dbi_base;
+		spin_lock_init(&pp->conf_lock);
+		memset(pp->res, 0, sizeof(pp->res));
+	} else {
+		pr_info("IMX PCIe port: link down!\n");
+		/* Release the clocks, and disable the power */
+
+		pcie_clk = clk_get(NULL, "pcie_clk");
+		if (IS_ERR(pcie_clk)) {
+			pr_err("no pcie clock.\n");
+			return;
+		}
+
+		clk_disable_unprepare(pcie_clk);
+		clk_put(pcie_clk);
+
+		// Disable the PCIE PHY Ref Clock
+		imx_pcie_clrset(iomuxc_gpr1_pcie_ref_clk_en, 0 << 16, IOMUXC_GPR1);
+
+		if (gpio_is_valid(imx_pcie.pcie_pwr_en)) {
+			/* Disable PCIE power */
+			gpio_request(imx_pcie.pcie_pwr_en, "PCIE POWER_EN");
+
+			/* activate PCIE_PWR_EN */
+			gpio_direction_output(imx_pcie.pcie_pwr_en, 0);
+		}
+
+		// Power down PCIE PHY
+		imx_pcie_clrset(iomuxc_gpr1_test_powerdown, 1 << 18, IOMUXC_GPR1);
+	}
+}
+
+static int imx_pcie_abort_handler(unsigned long addr, unsigned int fsr,
+		struct pt_regs *regs)
+{
+	unsigned long instr;
+	unsigned long pc = instruction_pointer(regs) - 4;
+
+	instr = *(unsigned long *)pc;
+/* imprecise aborts are no longer enabled in 3.7+ during init it would appear.
+ * We now using PCIE_RC_IOBLSSR to detect master abort however we will still get
+ * at least one imprecise abort and need to have a handler.
+ */
+#if 0
+	if (instr == 0xf57ff04f) {
+		/* dsb sy */
+		pc -= 4;
+		instr = *(unsigned long *)pc;
+	}
+	pr_info("PCIe abort: address = 0x%08lx fsr = 0x%03x PC = 0x%08lx LR = 0x%08lx instr=%08lx\n",
+		addr, fsr, regs->ARM_pc, regs->ARM_lr, instr);
+
+
+	/*
+	 * If the instruction being executed was a read,
+	 * make it look like it read all-ones.
+	 */
+	if ((instr & 0x0c500000) == 0x04100000) {
+		/* LDR instruction */
+		int reg = (instr >> 12) & 15;
+
+		regs->uregs[reg] = -1;
+		regs->ARM_pc = pc + 4;
+		return 0;
+	}
+	return 1;
+#else
+	pr_info("PCIe abort: address = 0x%08lx fsr = 0x%03x PC = 0x%08lx LR = 0x%08lx instr=%08lx\n",
+		addr, fsr, regs->ARM_pc, regs->ARM_lr, instr);
+
+	return 0;
+#endif
+}
+
+
+static int imx_pcie_pltfm_probe(struct platform_device *pdev)
+{
+	struct resource *mem;
+	struct device *dev = &pdev->dev;
+	struct device_node *np = pdev->dev.of_node;
+	struct resource res;
+	int ret;
+
+	if (!np) {
+		dev_err(&pdev->dev, "No of data found\n");
+		return -EINVAL;
+	}
+
+	res.start = res.end = 0;
+	ret = of_address_to_resource(np, 0, &res);
+	if (ret)
+		goto err;
+	mem = &res;
+	imx_pcie.pcie_pwr_en = of_get_named_gpio(np, "pwren-gpios", 0);
+	imx_pcie.pcie_rst = of_get_named_gpio(np, "rst-gpios", 0);
+	imx_pcie.pcie_wake_up = of_get_named_gpio(np, "wake-gpios", 0);
+	imx_pcie.pcie_dis = of_get_named_gpio(np, "dis-gpios", 0);
+	//pdev->dev.platform_data = pdata;
+
+	imx_pcie.base = ioremap_nocache(PCIE_ARB_END_ADDR - SZ_1M + 1, SZ_1M - SZ_16K);
+	if (!imx_pcie.base) {
+		pr_err("error with ioremap in function %s\n", __func__);
+		return -EIO;
+	}
+
+	imx_pcie.dbi_base = devm_ioremap(dev, mem->start, resource_size(mem));
+	if (!imx_pcie.dbi_base) {
+		dev_err(dev, "can't map %pR\n", mem);
+		return -ENOMEM;
+	}
+
+	np = of_find_compatible_node(NULL, NULL, "fsl,imx6q-iomuxc-gpr");
+	if (!np) {
+		dev_err(dev, "can't find iomux\n");
+		return -ENOMEM;
+	}
+	ret = of_address_to_resource(np, 0, &res);
+	of_node_put(np);
+	if (ret)
+		goto err;
+	mem = &res;
+	imx_pcie.gpr_base = devm_ioremap(dev, mem->start, resource_size(mem));
+	if (!imx_pcie.gpr_base) {
+		dev_err(dev, "can't map %pR\n", mem);
+		return -ENOMEM;
+	}
+
+	// hold LTSSM in detect state
+	imx_pcie_clrset(iomuxc_gpr12_app_ltssm_enable, 0 << 10, IOMUXC_GPR12);
+
+	/* configure constant input signal to the pcie ctrl and phy */
+	// set device type to RC (PCI_EXP_TYPE_ROOT_PORT=4 is from pcie_regs.h)
+	imx_pcie_clrset(iomuxc_gpr12_device_type, PCI_EXP_TYPE_ROOT_PORT << 12, IOMUXC_GPR12);
+	// loss of signal detect sensitivity function - must be 0x9
+	imx_pcie_clrset(iomuxc_gpr12_los_level, 9 << 4, IOMUXC_GPR12);
+	// not clear what values these should have from RM
+	imx_pcie_clrset(iomuxc_gpr8_tx_deemph_gen1, 0 << 0, IOMUXC_GPR8);
+	imx_pcie_clrset(iomuxc_gpr8_tx_deemph_gen2_3p5db, 0 << 6, IOMUXC_GPR8);
+	imx_pcie_clrset(iomuxc_gpr8_tx_deemph_gen2_6db, 20 << 12, IOMUXC_GPR8);
+	imx_pcie_clrset(iomuxc_gpr8_tx_swing_full, 127 << 18, IOMUXC_GPR8);
+	imx_pcie_clrset(iomuxc_gpr8_tx_swing_low, 127 << 25, IOMUXC_GPR8);
+
+	/* Enable the pwr, clks and so on */
+	ret = imx_pcie_enable_controller(dev);
+	if (ret)
+		goto err;
+
+	/* togle the external card's reset */
+	card_reset(dev) ;
+
+	usleep_range(3000, 4000);
+	imx_pcie_regions_setup(imx_pcie.dbi_base);
+	usleep_range(3000, 4000);
+
+	/*
+	 * Force to GEN1 because of PCIE2USB storage stress tests
+	 * would be failed when GEN2 is enabled
+	 */
+	writel(((readl(imx_pcie.dbi_base + LNK_CAP) & 0xfffffff0) | 0x1),
+			imx_pcie.dbi_base + LNK_CAP);
+
+	/* start link up */
+	imx_pcie_clrset(iomuxc_gpr12_app_ltssm_enable, 1 << 10, IOMUXC_GPR12);
+
+	hook_fault_code(16 + 6, imx_pcie_abort_handler, SIGBUS, 0,
+			"imprecise external abort");
+
+	/* add the pcie port */
+	add_pcie_port(imx_pcie.base, imx_pcie.dbi_base);
+
+	pci_common_init(&imx_pci);
+
+	return 0;
+
+err:
+	return ret;
+}
+
+static int imx_pcie_pltfm_remove(struct platform_device *pdev)
+{
+	struct clk *pcie_clk;
+	struct device *dev = &pdev->dev;
+	struct resource *iomem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+
+	/* Release clocks, and disable power  */
+	pcie_clk = devm_clk_get(dev, "pcie_clk");
+	if (IS_ERR(pcie_clk))
+		pr_err("no pcie clock.\n");
+
+	if (pcie_clk) {
+		clk_disable_unprepare(pcie_clk);
+		clk_put(pcie_clk);
+	}
+
+	// disable PCIe PHY clock ref
+	imx_pcie_clrset(iomuxc_gpr1_pcie_ref_clk_en, 0 << 16, IOMUXC_GPR1);
+
+	if (gpio_is_valid(imx_pcie.pcie_pwr_en)) {
+		/* Disable PCIE power */
+		gpio_request(imx_pcie.pcie_pwr_en, "PCIE POWER_EN");
+
+		/* activate PCIE_PWR_EN */
+		gpio_direction_output(imx_pcie.pcie_pwr_en, 0);
+	}
+
+	// power down PCIe PHY
+	imx_pcie_clrset(iomuxc_gpr1_test_powerdown, 1 << 18, IOMUXC_GPR1);
+
+	iounmap(imx_pcie.base);
+	iounmap(imx_pcie.dbi_base);
+	iounmap(imx_pcie.gpr_base);
+	release_mem_region(iomem->start, resource_size(iomem));
+	//platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+static const struct of_device_id of_imx_pcie_match[] = {
+	{ .compatible = "fsl,pcie" },
+	{}
+};
+MODULE_DEVICE_TABLE(of, of_imx_pcie_match);
+
+static struct platform_driver imx_pcie_pltfm_driver = {
+	.driver = {
+		.name	= "imx-pcie",
+		.owner	= THIS_MODULE,
+		.of_match_table = of_imx_pcie_match,
+	},
+	.probe		= imx_pcie_pltfm_probe,
+	.remove		= imx_pcie_pltfm_remove,
+};
+
+/*****************************************************************************\
+ *                                                                           *
+ * Driver init/exit                                                          *
+ *                                                                           *
+\*****************************************************************************/
+
+static int __init imx_pcie_drv_init(void)
+{
+	pcibios_min_io = 0;
+	pcibios_min_mem = 0;
+
+	return platform_driver_register(&imx_pcie_pltfm_driver);
+}
+
+static void __exit imx_pcie_drv_exit(void)
+{
+	platform_driver_unregister(&imx_pcie_pltfm_driver);
+}
+
+module_init(imx_pcie_drv_init);
+module_exit(imx_pcie_drv_exit);
+
+MODULE_DESCRIPTION("i.MX PCIE platform driver");
+MODULE_LICENSE("GPL v2");
Index: trunk/target/linux/imx61/files-3.8/firmware/imx/sdma/sdma-imx6q-to1.bin.ihex
===================================================================
--- trunk/target/linux/imx61/files-3.8/firmware/imx/sdma/sdma-imx6q-to1.bin.ihex	(revision 0)
+++ trunk/target/linux/imx61/files-3.8/firmware/imx/sdma/sdma-imx6q-to1.bin.ihex	(working copy)
@@ -0,0 +1,116 @@
+:1000000053444D4101000000010000001C000000AD
+:1000100026000000B40000007A0600008202000002
+:10002000FFFFFFFF00000000FFFFFFFFFFFFFFFFDC
+:10003000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFD0
+:10004000FFFFFFFFFFFFFFFF6A1A0000FFFFFFFF38
+:10005000EB020000BB180000FFFFFFFF08040000D8
+:10006000FFFFFFFFC0030000FFFFFFFFFFFFFFFFD9
+:10007000FFFFFFFFAB020000FFFFFFFF7B0300005D
+:10008000FFFFFFFFFFFFFFFF4C0400006E040000B6
+:10009000FFFFFFFF00180000FFFFFFFFFFFFFFFF54
+:1000A000000000000018000062180000161A00008E
+:1000B000061B0000E3C1DB57E35FE357F352016A1D
+:1000C0008F00D500017D8D00A005EB5D7804037DD8
+:1000D00079042C7D367C79041F7CEE56000F600677
+:1000E000057D0965437E0A62417E20980A623E7E54
+:1000F00009653C7E12051205AD026007037DFB55C4
+:10010000D36D2B98FB55041DD36DC86A2F7F011F3B
+:1001100003200048E47C5398FB55D76D1500057803
+:100120000962C86A0962C86AD76D5298FB55D76DD3
+:100130001500150005780A62C86A0A62C86AD76D98
+:100140005298FB55D76D15001500150005780B6208
+:10015000C86A0B62C86AD76D097CDF6D077F000033
+:10016000EB55004D077DFAC1E35706980700CC68B0
+:100170000C6813C20AC20398D9C1E3C1DB57E35F1D
+:10018000E357F352216A8F00D500017D8D00A00551
+:10019000EB5DFB567804037D79042A7D317C79047C
+:1001A000207C700B1103EB53000F6003057D096584
+:1001B000377E0A62357E86980A62327E0965307E15
+:1001C00012051205AD026007027C065A8E98265A67
+:1001D000277F011F03200048E87C700B1103135395
+:1001E000AF98150004780962065A0962265AAE983B
+:1001F0001500150004780A62065A0A62265AAE985B
+:1002000015001500150004780B62065A0B62265A79
+:10021000077C0000EB55004D067DFAC1E357699855
+:1002200007000C6813C20AC26698700B11031353BF
+:100230006C07017CD9C1FB5E8A066B07017CD9C1C2
+:10024000F35EDB59D3588F0110010F398B003CC18D
+:100250002B7DC05AC85B4EC1277C88038906E35CAE
+:10026000FF0D1105FF1DBC053E07004D187D7008F0
+:1002700011007E07097D7D07027D2852E698F8521D
+:10028000DB54BC02CC02097C7C07027D2852EF982B
+:10029000F852D354BC02CC02097D0004DD988B00D7
+:1002A000C052C85359C1D67D0002CD98FF08BF0087
+:1002B0007F07157D8804D500017D8D00A005EB5DCD
+:1002C0008F0212021202FF3ADA05027C3E071899E9
+:1002D000A402DD02027D3E0718995E071899EB55CE
+:1002E0009805EB5DF352FB546A07267D6C07017D90
+:1002F00055996B07577C6907047D6807027D010EDD
+:100300002F999358D600017D8E009355A005935DDB
+:10031000A00602780255045D1D7C004E087C69072A
+:10032000037D0255177E3C99045D147F8906935026
+:100330000048017D2799A099150006780255045DB3
+:100340004F070255245D2F07017CA09917006F0706
+:10035000017C012093559D000700A7D9F598D36C27
+:100360006907047D6807027D010E64999358D600E1
+:10037000017D8E009355A005935DA006027802557D
+:10038000C86D0F7C004E087C6907037D0255097E0D
+:100390007199C86D067F890693500048017D5C996C
+:1003A000A0999A99C36A6907047D6807027D010EC6
+:1003B00087999358D600017D8E009355A005935DD3
+:1003C000A0060278C865045D0F7C004E087C6907B2
+:1003D000037DC865097E9499045D067F8906935064
+:1003E0000048017D7F99A09993559D000700FF6CFF
+:1003F000A7D9F5980000E354EB55004D017CF59822
+:10040000DD98E354EB55FF0A1102FF1A7F07027CC7
+:10041000A005B4999D008C05BA05A0051002BA0488
+:10042000AD0454040600E3C1DB57FB52C36AF35228
+:10043000056A8F00D500017D8D00A005EB5D780475
+:10044000037D79042B7D1E7C7904337CEE56000FEE
+:10045000FB556007027DC36DD599041DC36DC8624D
+:100460003B7E6006027D10021202096A357F12028D
+:10047000096A327F1202096A2F7F011F0320004898
+:10048000E77C099AFB55C76D150015001500057826
+:10049000C8620B6AC8620B6AC76D089AFB55C76DC4
+:1004A000150015000578C8620A6AC8620A6AC76D35
+:1004B000089AFB55C76D15000578C862096AC862BD
+:1004C000096AC76D097C286A077F0000EB55004D5B
+:1004D000057DFAC1DB57BF9977C254040AC2BA99A5
+:1004E000D9C1E3C1DB57F352056A8F00D500017D06
+:1004F0008D00A005FB567804037D7904297D1F7CBF
+:1005000079042E7CE35D700D1105ED55000F600739
+:10051000027D0652329A2652337E6005027D100219
+:100520001202096A2D7F1202096A2A7F1202096AE1
+:10053000277F011F03200048EA7CE3555D9A1500E0
+:1005400015001500047806520B6A26520B6A5C9A55
+:1005500015001500047806520A6A26520A6A5C9A47
+:10056000150004780652096A2652096A097C286A2D
+:10057000077F0000DB57004D057DFAC1DB571B9A52
+:1005800077C254040AC2189AE3C1DB57F352056AD2
+:10059000FB568E02941AC36AC8626902247D941EB7
+:1005A000C36ED36EC8624802C86A9426981EC36E92
+:1005B000D36EC8624C02C86A9826C36E981EC36E7A
+:1005C000C8629826C36E6002097CC8626E02247DF0
+:1005D000096A1E7F0125004D257D849A286A187FAF
+:1005E00004627AC2B89AE36E8F00D805017D8D004F
+:1005F000A005C8626E02107D096A0A7F0120F97C9D
+:10060000286A067F0000004D0D7DFAC1DB576E9A07
+:10061000070004620C6AB59A286AFA7F04627AC2FB
+:1006200058045404286AF47F0AC26B9AD9C1E3C102
+:10063000DB57F352056AFB568E02941A0252690286
+:100640001D7D941E06524802065A9426981E065294
+:100650004C02065A9826981E065260020A7C98267A
+:1006600006526E02237D096A1D7F0125004D247DFF
+:10067000D19A286A177F04627AC2029B8F00D8053C
+:10068000017D8D00A00506526E02107D096A0A7F69
+:100690000120F97C286A067F0000004D0D7DFAC11B
+:1006A000DB57C19A070004620C6AFF9A286AFA7F36
+:1006B00004627AC258045404286AF47F0AC2BE9ABB
+:1006C000016E0B612F7E0B622D7E0B632B7E0C0D5A
+:1006D0001704170417049D04081DCC05017C0C0D9C
+:1006E000D16A000F4207C86FDD6F1C7F8E009D002E
+:1006F00001680B67177ED56B04080278C86F120774
+:10070000117C0B670F7E04080278C86F12070A7C01
+:10071000DD6F087FD169010FC86FDD6F037F0101B5
+:0E0720000004129B0700FF680C680002129B89
+:00000001FF
Index: trunk/target/linux/imx61/files-3.8/scripts/mkits.sh
===================================================================
--- trunk/target/linux/imx61/files-3.8/scripts/mkits.sh	(revision 0)
+++ trunk/target/linux/imx61/files-3.8/scripts/mkits.sh	(working copy)
@@ -0,0 +1,111 @@
+#!/bin/bash
+#
+# Licensed under the terms of the GNU GPL License version 2 or later.
+#
+# Author: Peter Tyser <ptyser@xes-inc.com>
+#
+# U-Boot firmware supports the booting of images in the Flattened Image
+# Tree (FIT) format.  The FIT format uses a device tree structure to
+# describe a kernel image, device tree blob, ramdisk, etc.  This script
+# creates an Image Tree Source (.its file) which can be passed to the
+# 'mkimage' utility to generate an Image Tree Blob (.itb file).  The .itb
+# file can then be booted by U-Boot (or other bootloaders which support
+# FIT images).  See doc/uImage.FIT/howto.txt in U-Boot source code for
+# additional information on FIT images.
+#
+
+usage() {
+	echo "Usage: `basename $0` -A arch -C comp -a addr -e entry" \
+		"-v version -k kernel [-d dtb] -o its_file"
+	echo -e "\t-A ==> set architecture to 'arch'"
+	echo -e "\t-C ==> set compression type 'comp'"
+	echo -e "\t-a ==> set load address to 'addr' (hex)"
+	echo -e "\t-e ==> set entry point to 'entry' (hex)"
+	echo -e "\t-v ==> set kernel version to 'version'"
+	echo -e "\t-k ==> include kernel image 'kernel'"
+	echo -e "\t-d ==> include Device Tree Blob 'dtb'"
+	echo -e "\t-o ==> create output file 'its_file'"
+	exit 1
+}
+
+while getopts ":A:C:a:d:e:k:o:v:" OPTION
+do
+	case $OPTION in
+		A ) ARCH=$OPTARG;;
+		C ) COMPRESS=$OPTARG;;
+		a ) LOAD_ADDR=$OPTARG;;
+		d ) DTB=$OPTARG;;
+		e ) ENTRY_ADDR=$OPTARG;;
+		k ) KERNEL=$OPTARG;;
+		o ) OUTPUT=$OPTARG;;
+		v ) VERSION=$OPTARG;;
+		* ) echo "Invalid option passed to '$0' (options:$@)"
+		usage;;
+	esac
+done
+
+# Make sure user entered all required parameters
+if [ -z "${ARCH}" ] || [ -z "${COMPRESS}" ] || [ -z "${LOAD_ADDR}" ] || \
+	[ -z "${ENTRY_ADDR}" ] || [ -z "${VERSION}" ] || [ -z "${KERNEL}" ] || \
+	[ -z "${OUTPUT}" ]; then
+	usage
+fi
+
+# Create a default, fully populated DTS file
+DATA="/dts-v1/;
+
+/ {
+	description = \"Linux kernel ${VERSION}\";
+	#address-cells = <1>;
+
+	images {
+		kernel@1 {
+			description = \"Linux Kernel ${VERSION}\";
+			data = /incbin/(\"${KERNEL}\");
+			type = \"kernel\";
+			arch = \"${ARCH}\";
+			os = \"linux\";
+			compression = \"${COMPRESS}\";
+			load = <${LOAD_ADDR}>;
+			entry = <${ENTRY_ADDR}>;
+			hash@1 {
+				algo = \"crc32\";
+			};
+			hash@2 {
+				algo = \"sha1\";
+			};
+		};
+
+		fdt@1 { /* start fdt */
+			description = \"Flattened Device Tree blob\";
+			data = /incbin/(\"${DTB}\");
+			type = \"flat_dt\";
+			arch = \"${ARCH}\";
+			compression = \"none\";
+			hash@1 {
+				algo = \"crc32\";
+			};
+			hash@2 {
+				algo = \"sha1\";
+			};
+		}; /* end fdt */
+	};
+
+	configurations {
+		default = \"config@1\";
+		config@1 {
+			description = \"Default Linux kernel\";
+			kernel = \"kernel@1\";
+			fdt = \"fdt@1\";
+		};
+	};
+};"
+
+# Conditionally strip fdt information out of tree
+if [ -z "${DTB}" ]; then
+	DATA=`echo "$DATA" | sed '/start fdt/,/end fdt/d'`
+	DATA=`echo "$DATA" | sed '/fdt/d'`
+fi
+
+# Write .its file to disk
+echo "$DATA" > ${OUTPUT}
Index: trunk/target/linux/imx61/image/Makefile
===================================================================
--- trunk/target/linux/imx61/image/Makefile	(revision 0)
+++ trunk/target/linux/imx61/image/Makefile	(working copy)
@@ -0,0 +1,59 @@
+#
+# Copyright (C) 2013 OpenWrt.org
+#
+# This is free software, licensed under the GNU General Public License v2.
+# See /LICENSE for more information.
+#
+include $(TOPDIR)/rules.mk
+include $(INCLUDE_DIR)/image.mk
+
+BOARDS:=imx6q-gw5400
+
+# board-specific Flattened Image Tree
+define mkfit
+	/bin/sh $(LINUX_DIR)/scripts/mkits.sh -A arm -C none -a $(2) -e $(2) \
+		-v 'OpenWrt Linux-$(LINUX_VERSION)' \
+		-d $(LINUX_DIR)/arch/arm/boot/dts/$(1).dtb -k $(LINUX_DIR)/arch/arm/boot/zImage \
+		-o $(KDIR)/$(1)-uImage.its
+	PATH=${PATH}:$(LINUX_DIR)/scripts/dtc/ mkimage -f $(KDIR)/$(1)-uImage.its $(BIN_DIR)/openwrt-$(1)-uImage.itb
+endef
+
+# emit FIT images, DTB's and generic zImage
+define Image/BuildKernel
+	$(foreach board,$(BOARDS),
+		$(call mkfit,$(board),0x10008000)
+		cp $(LINUX_DIR)/arch/arm/boot/dts/$(board).dtb $(BIN_DIR)
+	)
+	cp $(LINUX_DIR)/arch/arm/boot/zImage $(BIN_DIR)/openwrt-$(BOARD)-zImage
+endef
+
+# board-specific sysupgrade image
+define BuildFirmware/Generic
+	dd if=$(BIN_DIR)/openwrt-$(1)-uImage.itb of=$(KDIR)/uImage.pad bs=64k conv=sync; \
+	dd if=$(KDIR)/root.$(2) of=$(KDIR)/root.$(2).pad bs=128k conv=sync; \
+	sh $(TOPDIR)/scripts/combined-image.sh \
+		$(KDIR)/uImage.pad \
+		$(KDIR)/root.$(2).pad \
+		$(BIN_DIR)/$(IMG_PREFIX)-$(patsubst jffs2-%,jffs2,$(patsubst squashfs-%,squashfs,$(1)))-sysupgrade.bin
+endef
+
+define Image/Build
+	$(call Image/Build/$(1),$(1))
+	$(foreach board,$(BOARDS),
+		$(call BuildFirmware/Generic,$(board),$(1))
+	)
+endef
+
+# rootfs and board-specific combined kernel+rootfs for convenience
+define Image/Build/squashfs
+	$(call prepare_generic_squashfs,$(KDIR)/root.$(1))
+	dd if=$(KDIR)/root.$(1) of=$(BIN_DIR)/openwrt-$(BOARD)-$(1).img bs=128k conv=sync
+	$(foreach board,$(BOARDS),
+		( \
+		dd if=$(BIN_DIR)/openwrt-$(board)-uImage.itb bs=2048k conv=sync; \
+		dd if=$(KDIR)/root.$(1) bs=64k conv=sync; \
+		) > $(BIN_DIR)/$(IMG_PREFIX)-$(board)-$(1).bin
+	)
+endef
+
+$(eval $(call BuildImage))
Index: trunk/target/linux/imx61/Makefile
===================================================================
--- trunk/target/linux/imx61/Makefile	(revision 0)
+++ trunk/target/linux/imx61/Makefile	(working copy)
@@ -0,0 +1,27 @@
+#
+# Copyright (C) 2012 OpenWrt.org
+#
+# This is free software, licensed under the GNU General Public License v2.
+# See /LICENSE for more information.
+#
+include $(TOPDIR)/rules.mk
+
+ARCH:=arm
+BOARD:=imx61
+BOARDNAME:=Freescale IMX61
+FEATURES:=audio display gpio pcie usb usbgadget squashfs targz
+
+CFLAGS:=-Os -pipe -mtune=cortex-a9 -march=armv7-a -mfpu=vfpv3-d16 -mfloat-abi=softfp
+MAINTAINER:=Tim Harvey <tharvey@gateworks.com>
+
+LINUX_VERSION:=3.8.6
+
+include $(INCLUDE_DIR)/target.mk
+
+define Target/Description
+	Freescale IMX61
+endef
+
+KERNELNAME:="zImage dtbs"
+
+$(eval $(call BuildTarget))
Index: trunk/target/linux/imx61/patches-3.8/010-imx6_pcie.patch
===================================================================
--- trunk/target/linux/imx61/patches-3.8/010-imx6_pcie.patch	(revision 0)
+++ trunk/target/linux/imx61/patches-3.8/010-imx6_pcie.patch	(working copy)
@@ -0,0 +1,139 @@
+--- a/arch/arm/boot/dts/imx6q-sabrelite.dts
++++ b/arch/arm/boot/dts/imx6q-sabrelite.dts
+@@ -78,6 +78,10 @@
+ 				status = "okay";
+ 			};
+ 
++			pcie@01ffc000 { /* PCIe */
++				status = "okay";
++			};
++
+ 			ethernet@02188000 {
+ 				pinctrl-names = "default";
+ 				pinctrl-0 = <&pinctrl_enet_1>;
+--- a/arch/arm/boot/dts/imx6q.dtsi
++++ b/arch/arm/boot/dts/imx6q.dtsi
+@@ -862,6 +862,14 @@
+ 				clocks = <&clks 162>;
+ 			};
+ 
++			pcie: pcie@01ffc000 {
++				compatible = "fsl,imx6q-pcie", "fsl,pcie";
++				reg = <0x01ffc000 0x4000>;
++				clocks = <&clks 144>, <&clks 189>;
++				clock-names = "pcie_axi", "pcie_ref_125m";
++				status = "disabled";
++			};
++
+ 			fec: ethernet@02188000 {
+ 				compatible = "fsl,imx6q-fec";
+ 				reg = <0x02188000 0x4000>;
+--- a/arch/arm/include/asm/io.h
++++ b/arch/arm/include/asm/io.h
+@@ -177,7 +177,12 @@ extern int pci_ioremap_io(unsigned int o
+  * Now, pick up the machine-defined IO definitions
+  */
+ #ifdef CONFIG_NEED_MACH_IO_H
++#ifdef CONFIG_SOC_IMX6Q
++// ugly hack: <mach/io.h> can't be found in arch/arm/mach-imx/include/mach/io.h??
++#include "../../mach-imx/include/mach/io.h"
++#else
+ #include <mach/io.h>
++#endif
+ #elif defined(CONFIG_PCI)
+ #define IO_SPACE_LIMIT	((resource_size_t)0xfffff)
+ #define __io(a)		__typesafe_io(PCI_IO_VIRT_BASE + ((a) & IO_SPACE_LIMIT))
+@@ -197,7 +202,7 @@ extern int pci_ioremap_io(unsigned int o
+  * readb() et.al. on such platforms.
+  */
+ #ifndef IO_SPACE_LIMIT
+-#if defined(CONFIG_PCMCIA_SOC_COMMON) || defined(CONFIG_PCMCIA_SOC_COMMON_MODULE)
++#if defined(CONFIG_PCMCIA_SOC_COMMON) || defined(CONFIG_PCMCIA_SOC_COMMON_MODULE) || defined(CONFIG_SOC_IMX6Q)
+ #define IO_SPACE_LIMIT ((resource_size_t)0xffffffff)
+ #elif defined(CONFIG_PCI) || defined(CONFIG_ISA) || defined(CONFIG_PCCARD)
+ #define IO_SPACE_LIMIT ((resource_size_t)0xffff)
+--- a/arch/arm/mach-imx/Kconfig
++++ b/arch/arm/mach-imx/Kconfig
+@@ -838,6 +838,9 @@ config	SOC_IMX53
+ 
+ config SOC_IMX6Q
+ 	bool "i.MX6 Quad support"
++	select ARCH_HAS_IMX_PCIE
++	select ARCH_SUPPORTS_MSI
++	select NEED_MACH_IO_H if PCI
+ 	select ARCH_HAS_CPUFREQ
+ 	select ARCH_HAS_OPP
+ 	select ARM_CPU_SUSPEND if PM
+@@ -864,6 +867,10 @@ config SOC_IMX6Q
+ 	help
+ 	  This enables support for Freescale i.MX6 Quad processor.
+ 
++config IMX_PCIE
++	bool "PCI Express support"
++	select PCI
++
+ endif
+ 
+ source "arch/arm/mach-imx/devices/Kconfig"
+--- a/arch/arm/mach-imx/Makefile
++++ b/arch/arm/mach-imx/Makefile
+@@ -1,3 +1,5 @@
++ccflags-$(CONFIG_ARCH_MULTIPLATFORM) := -I$(srctree)/$(src)/include
++
+ obj-y := time.o cpu.o system.o irq-common.o
+ 
+ obj-$(CONFIG_SOC_IMX1) += clk-imx1.o mm-imx1.o
+@@ -96,6 +98,8 @@ AFLAGS_headsmp.o :=-Wa,-march=armv7-a
+ obj-$(CONFIG_SMP) += headsmp.o platsmp.o
+ obj-$(CONFIG_HOTPLUG_CPU) += hotplug.o
+ obj-$(CONFIG_SOC_IMX6Q) += clk-imx6q.o mach-imx6q.o
++obj-$(CONFIG_IMX_PCIE) += pcie.o
++obj-$(CONFIG_PCI_MSI) += msi.o
+ 
+ ifeq ($(CONFIG_PM),y)
+ obj-$(CONFIG_SOC_IMX6Q) += pm-imx6q.o headsmp.o
+--- a/arch/arm/mach-imx/clk-imx6q.c
++++ b/arch/arm/mach-imx/clk-imx6q.c
+@@ -425,6 +425,12 @@ int __init mx6q_clocks_init(void)
+ 	clk_register_clkdev(clk[ahb], "ahb", NULL);
+ 	clk_register_clkdev(clk[cko1], "cko1", NULL);
+ 	clk_register_clkdev(clk[arm], NULL, "cpu0");
++	clk_register_clkdev(clk[pcie_axi_sel], "pcie_axi_sel", NULL);
++	clk_register_clkdev(clk[axi], "axi", NULL);
++	clk_register_clkdev(clk[pll6_enet], "pll6_enet", NULL);
++	clk_register_clkdev(clk[pcie_ref], "pcie_ref", NULL);
++	clk_register_clkdev(clk[pcie_ref_125m], "pcie_ref_125m", NULL);
++	clk_register_clkdev(clk[pcie_axi], "pcie_axi", NULL);
+ 
+ 	/*
+ 	 * The gpmi needs 100MHz frequency in the EDO/Sync mode,
+--- a/arch/arm/mach-imx/mxc.h
++++ b/arch/arm/mach-imx/mxc.h
+@@ -35,6 +35,9 @@
+ #define MXC_CPU_MX50		50
+ #define MXC_CPU_MX51		51
+ #define MXC_CPU_MX53		53
++#define MXC_CPU_MX6Q    63
++#define MXC_CPU_MX6DL   61
++#define MXC_CPU_MX6SL   60
+ 
+ #define IMX_CHIP_REVISION_1_0		0x10
+ #define IMX_CHIP_REVISION_1_1		0x11
+@@ -162,6 +165,17 @@ extern unsigned int __mxc_cpu_type;
+ # define cpu_is_mx53()		(0)
+ #endif
+ 
++#ifdef CONFIG_SOC_IMX6Q
++#  define mxc_cpu_type __mxc_cpu_type
++# define cpu_is_mx6q()    (mxc_cpu_type == MXC_CPU_MX6Q)
++# define cpu_is_mx6dl()   (mxc_cpu_type == MXC_CPU_MX6DL)
++# define cpu_is_mx6sl()   (mxc_cpu_type == MXC_CPU_MX6SL)
++#else
++# define cpu_is_mx6q()    (0)
++# define cpu_is_mx6dl()   (0)
++# define cpu_is_mx6sl()   (0)
++#endif
++
+ #ifndef __ASSEMBLY__
+ 
+ struct cpu_op {
Index: trunk/target/linux/imx61/patches-3.8/020-marvell-sky2-macdt.patch
===================================================================
--- trunk/target/linux/imx61/patches-3.8/020-marvell-sky2-macdt.patch	(revision 0)
+++ trunk/target/linux/imx61/patches-3.8/020-marvell-sky2-macdt.patch	(working copy)
@@ -0,0 +1,56 @@
+--- a/drivers/net/ethernet/marvell/sky2.c
++++ b/drivers/net/ethernet/marvell/sky2.c
+@@ -44,6 +44,8 @@
+ #include <linux/prefetch.h>
+ #include <linux/debugfs.h>
+ #include <linux/mii.h>
++#include <linux/of_device.h>
++#include <linux/of_net.h>
+ 
+ #include <asm/irq.h>
+ 
+@@ -4746,6 +4748,8 @@ static struct net_device *sky2_init_netd
+ {
+ 	struct sky2_port *sky2;
+ 	struct net_device *dev = alloc_etherdev(sizeof(*sky2));
++	unsigned char *iap, tmpaddr[ETH_ALEN];
++	struct device_node *np;
+ 
+ 	if (!dev)
+ 		return NULL;
+@@ -4799,8 +4803,34 @@ static struct net_device *sky2_init_netd
+ 
+ 	dev->features |= dev->hw_features;
+ 
++	/*
++	 * try to get mac address in the following order:
++	 * 1) from device tree data
++	 * 2) from internal registers set by bootloader
++	 */
++#ifdef CONFIG_OF
++	np = of_find_node_by_path("/aliases");
++	if (np) {
++		const char *path = of_get_property(np, "sky2", NULL);
++		if (path)
++			np = of_find_node_by_path(path);
++		if (np)
++			path = of_get_mac_address(np);
++		if (path)
++			iap = (unsigned char *) path;
++	}
++#endif
++
++	/*
++	 * 2) mac registers set by bootloader
++	 */
++	if (!iap || !is_valid_ether_addr(iap)) {
++		memcpy_fromio(&tmpaddr, hw->regs + B2_MAC_1 + port * 8, ETH_ALEN);
++		iap = &tmpaddr[0];
++	}
++
+ 	/* read the mac address */
+-	memcpy_fromio(dev->dev_addr, hw->regs + B2_MAC_1 + port * 8, ETH_ALEN);
++	memcpy(dev->dev_addr, iap, ETH_ALEN);
+ 	memcpy(dev->perm_addr, dev->dev_addr, dev->addr_len);
+ 
+ 	return dev;
Index: trunk/target/linux/imx61/patches-3.8/030-pci-ioport.patch
===================================================================
--- trunk/target/linux/imx61/patches-3.8/030-pci-ioport.patch	(revision 0)
+++ trunk/target/linux/imx61/patches-3.8/030-pci-ioport.patch	(working copy)
@@ -0,0 +1,11 @@
+--- a/arch/arm/mach-vexpress/Kconfig
++++ b/arch/arm/mach-vexpress/Kconfig
+@@ -14,7 +14,7 @@ config ARCH_VEXPRESS
+ 	select HAVE_SMP
+ 	select ICST
+ 	select MIGHT_HAVE_CACHE_L2X0
+-	select NO_IOPORT
++	select NO_IOPORT if !PCI
+ 	select PLAT_VERSATILE
+ 	select PLAT_VERSATILE_CLCD
+ 	select REGULATOR_FIXED_VOLTAGE if REGULATOR
Index: trunk/target/linux/imx61/patches-3.8/100-gwventana.patch
===================================================================
--- trunk/target/linux/imx61/patches-3.8/100-gwventana.patch	(revision 0)
+++ trunk/target/linux/imx61/patches-3.8/100-gwventana.patch	(working copy)
@@ -0,0 +1,105 @@
+--- a/arch/arm/boot/dts/Makefile
++++ b/arch/arm/boot/dts/Makefile
+@@ -87,7 +87,8 @@ dtb-$(CONFIG_ARCH_MXC) += imx51-babbage.
+ 	imx6q-arm2.dtb \
+ 	imx6q-sabreauto.dtb \
+ 	imx6q-sabrelite.dtb \
+-	imx6q-sabresd.dtb
++	imx6q-sabresd.dtb \
++	imx6q-gw5400.dtb
+ dtb-$(CONFIG_ARCH_MXS) += imx23-evk.dtb \
+ 	imx23-olinuxino.dtb \
+ 	imx23-stmp378x_devb.dtb \
+--- a/arch/arm/mach-imx/mach-imx6q.c
++++ b/arch/arm/mach-imx/mach-imx6q.c
+@@ -23,6 +23,7 @@
+ #include <linux/of_irq.h>
+ #include <linux/of_platform.h>
+ #include <linux/phy.h>
++#include <linux/pci.h>
+ #include <linux/regmap.h>
+ #include <linux/micrel_phy.h>
+ #include <linux/mfd/syscon.h>
+@@ -151,6 +152,72 @@ static void __init imx6q_sabrelite_init(
+ 	imx6q_sabrelite_cko1_setup();
+ }
+ 
++/* fixup for PEX 8909 bridge to configure GPIO1-7 as output High
++ * as they are used for slots1-7 PERST#
++ */
++static void mx6_ventana_pciesw_early_fixup(struct pci_dev *dev)
++{
++	u32 dw;
++
++	if (!of_machine_is_compatible("gw,imx6q-gw5400"))
++		return;
++
++	if (dev->devfn != 0)
++		return;
++
++	pci_read_config_dword(dev, 0x62c, &dw);
++	dw |= 0xaaa8; // GPIO1-7 outputs
++	pci_write_config_dword(dev, 0x62c, dw);
++
++	pci_read_config_dword(dev, 0x644, &dw);
++	dw |= 0xfe;   // GPIO1-7 output high
++	pci_write_config_dword(dev, 0x644, dw);
++}
++DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_PLX, 0x8609,
++	mx6_ventana_pciesw_early_fixup);
++
++/* configure PCIe core clock and PCIe ref clock
++ *
++ * TODO: disable CLK1 output and use CLK2 input from si52147 as PCIe ref
++ */
++static void __init imx6q_ventana_pcie_setup(void)
++{
++	struct clk *axi_sel, *axi, *ref;
++
++	axi_sel = clk_get_sys(NULL, "pcie_axi_sel");
++	axi = clk_get_sys(NULL, "axi");
++	ref = clk_get_sys(NULL, "pcie_ref_125m");
++	if (IS_ERR(axi_sel) || IS_ERR(axi) || IS_ERR(ref)) {
++		pr_err("pcie setup failed - can't get clocks\n");
++		goto put_clk;
++	}
++	clk_set_parent(axi_sel, axi);
++	clk_prepare_enable(ref);
++
++	// create an alias for pcie_clk for driver to use
++	if (clk_add_alias("pcie_clk", NULL, "pcie_axi", NULL))
++		pr_err("could not register alias for pcie_clk\n");
++
++put_clk:
++	if (!IS_ERR(axi_sel))
++		clk_put(axi_sel);
++	if (!IS_ERR(axi))
++		clk_put(axi);
++	if (!IS_ERR(ref))
++		clk_put(ref);
++}
++
++static void __init imx6q_ventana_init(void)
++{
++	imx6q_ventana_pcie_setup();
++	imx6q_sabrelite_cko1_setup();
++}
++
++static void __init imx6q_gw5400_init(void)
++{
++	imx6q_ventana_init();
++}
++
+ static void __init imx6q_1588_init(void)
+ {
+ 	struct regmap *gpr;
+@@ -191,6 +258,9 @@ static void __init imx6q_usb_init(void)
+ 
+ static void __init imx6q_init_machine(void)
+ {
++	if (of_machine_is_compatible("gw,imx6q-gw5400"))
++		imx6q_gw5400_init();
++
+ 	if (of_machine_is_compatible("fsl,imx6q-sabrelite"))
+ 		imx6q_sabrelite_init();
+ 
