Index: trunk/target/linux/generic/patches-2.6.38/402-partial_eraseblock_unlock.patch
===================================================================
--- trunk/target/linux/generic/patches-2.6.38/402-partial_eraseblock_unlock.patch	(revision 0)
+++ trunk/target/linux/generic/patches-2.6.38/402-partial_eraseblock_unlock.patch	(working copy)
@@ -0,0 +1,30 @@
+--- a/drivers/mtd/mtdpart.c
++++ b/drivers/mtd/mtdpart.c
+@@ -360,7 +360,26 @@ static int part_unlock(struct mtd_info *
+ 	struct mtd_part *part = PART(mtd);
+ 	if ((len + ofs) > mtd->size)
+ 		return -EINVAL;
+-	return part->master->unlock(part->master, ofs + part->offset, len);
++
++	if (mtd->flags & MTD_ERASE_PARTIAL
++		 && (mtd_mod_by_eb(ofs + part->offset, part->master) == 0) )
++	{
++		struct mtd_part *part = PART(mtd);
++		/* Round up to next erasesize */
++		uint64_t newlen = (uint64_t) (mtd_div_by_eb(len, part->master) + 1)
++				* part->master->erasesize;
++		printk("%s: unlocking partial block\n", mtd->name);
++		return part->master->unlock(part->master, ofs + part->offset, newlen);
++	} else if (mtd->flags & MTD_ERASE_PARTIAL) {
++		/* presumably this was unlocked by previous partition that it shares
++		   sector(s) with
++		 */
++		printk(KERN_INFO "%s: assuming partial block already unlocked\n",
++			mtd->name);
++		return 0;
++	} else {
++		return part->master->unlock(part->master, ofs + part->offset, len);
++	}
+ }
+ 
+ static int part_is_locked(struct mtd_info *mtd, loff_t ofs, uint64_t len)
Index: trunk/target/linux/generic/patches-2.6.38/475-cfi_1.5_backport.patch
===================================================================
--- trunk/target/linux/generic/patches-2.6.38/475-cfi_1.5_backport.patch	(revision 0)
+++ trunk/target/linux/generic/patches-2.6.38/475-cfi_1.5_backport.patch	(working copy)
@@ -0,0 +1,18 @@
+--- a/drivers/mtd/chips/cfi_cmdset_0002.c
++++ b/drivers/mtd/chips/cfi_cmdset_0002.c
+@@ -462,13 +462,13 @@ struct mtd_info *cfi_cmdset_0002(struct
+ 			cfi_fixup_major_minor(cfi, extp);
+ 
+ 			/*
+-			 * Valid primary extension versions are: 1.0, 1.1, 1.2, 1.3, 1.4
++			 * Valid primary extension versions are: 1.0, 1.1, 1.2, 1.3, 1.4, 1.5
+  			 * see: Spec 1.3 http://cs.ozerki.net/zap/pub/axim-x5/docs/cfi_r20.pdf, page 19 
+  			 *               http://www.spansion.com/Support/AppNotes/cfi_100_20011201.pdf
+ 			 *      Spec 1.4 http://www.spansion.com/Support/AppNotes/CFI_Spec_AN_03.pdf, page 9
+ 			 */
+ 			if (extp->MajorVersion != '1' ||
+-			    (extp->MajorVersion == '1' && (extp->MinorVersion < '0' || extp->MinorVersion > '4'))) {
++			    (extp->MajorVersion == '1' && (extp->MinorVersion < '0' || extp->MinorVersion > '5'))) {
+ 				printk(KERN_ERR "  Unknown Amd/Fujitsu Extended Query "
+ 				       "version %c.%c (%#02x/%#02x).\n",
+ 				       extp->MajorVersion, extp->MinorVersion,
Index: trunk/target/linux/generic/patches-2.6.38/800-option_new_devices.patch
===================================================================
--- trunk/target/linux/generic/patches-2.6.38/800-option_new_devices.patch	(revision 0)
+++ trunk/target/linux/generic/patches-2.6.38/800-option_new_devices.patch	(working copy)
@@ -0,0 +1,40 @@
+Index: linux-2.6.39.2/drivers/net/usb/hso.c
+===================================================================
+--- linux-2.6.39.2.orig/drivers/net/usb/hso.c	2012-03-26 00:11:02.685780812 -0700
++++ linux-2.6.39.2/drivers/net/usb/hso.c	2012-03-26 00:12:41.722271908 -0700
+@@ -476,8 +476,10 @@
+ 	{USB_DEVICE(0x0af0, 0x8400)},
+ 	{USB_DEVICE(0x0af0, 0x8600)},
+ 	{USB_DEVICE(0x0af0, 0x8800)},
+-	{USB_DEVICE(0x0af0, 0x8900)},
+-	{USB_DEVICE(0x0af0, 0x9000)},
++	{USB_DEVICE(0x0af0, 0x8900)},		/* GTM 67xx */
++	{USB_DEVICE(0x0af0, 0x9000)},		/* GTM 66xx */
++	{USB_DEVICE(0x0af0, 0x9200)},		/* GTM 67xxWFS */
++	{USB_DEVICE(0x0af0, 0x9300)},		/* GTM 66xxWFS */
+ 	{USB_DEVICE(0x0af0, 0xd035)},
+ 	{USB_DEVICE(0x0af0, 0xd055)},
+ 	{USB_DEVICE(0x0af0, 0xd155)},
+Index: linux-2.6.39.2/drivers/usb/storage/unusual_devs.h
+===================================================================
+--- linux-2.6.39.2.orig/drivers/usb/storage/unusual_devs.h	2012-03-26 00:13:17.206447856 -0700
++++ linux-2.6.39.2/drivers/usb/storage/unusual_devs.h	2012-03-26 00:14:08.842703910 -0700
+@@ -1231,6 +1231,18 @@
+ 		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
+ 		0 ),
+ 
++UNUSUAL_DEV( 0x0af0, 0x9200, 0x0000, 0x0000,
++		"Option",
++		"Globetrotter 67xxWFS SD-Card",
++		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
++		0 ),
++
++UNUSUAL_DEV( 0x0af0, 0x9300, 0x0000, 0x0000,
++		"Option",
++		"Globetrotter 66xxWFS SD-Card",
++		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
++		0 ),
++
+ UNUSUAL_DEV( 0x0af0, 0xc100, 0x0000, 0x0000,
+ 		"Option",
+ 		"GI 070x SD-Card",
Index: trunk/target/linux/generic/patches-2.6.39/475-cfi_1.5_backport.patch
===================================================================
--- trunk/target/linux/generic/patches-2.6.39/475-cfi_1.5_backport.patch	(revision 0)
+++ trunk/target/linux/generic/patches-2.6.39/475-cfi_1.5_backport.patch	(working copy)
@@ -0,0 +1,18 @@
+--- a/drivers/mtd/chips/cfi_cmdset_0002.c
++++ b/drivers/mtd/chips/cfi_cmdset_0002.c
+@@ -462,13 +462,13 @@ struct mtd_info *cfi_cmdset_0002(struct
+ 			cfi_fixup_major_minor(cfi, extp);
+ 
+ 			/*
+-			 * Valid primary extension versions are: 1.0, 1.1, 1.2, 1.3, 1.4
++			 * Valid primary extension versions are: 1.0, 1.1, 1.2, 1.3, 1.4, 1.5
+  			 * see: Spec 1.3 http://cs.ozerki.net/zap/pub/axim-x5/docs/cfi_r20.pdf, page 19 
+  			 *               http://www.spansion.com/Support/AppNotes/cfi_100_20011201.pdf
+ 			 *      Spec 1.4 http://www.spansion.com/Support/AppNotes/CFI_Spec_AN_03.pdf, page 9
+ 			 */
+ 			if (extp->MajorVersion != '1' ||
+-			    (extp->MajorVersion == '1' && (extp->MinorVersion < '0' || extp->MinorVersion > '4'))) {
++			    (extp->MajorVersion == '1' && (extp->MinorVersion < '0' || extp->MinorVersion > '5'))) {
+ 				printk(KERN_ERR "  Unknown Amd/Fujitsu Extended Query "
+ 				       "version %c.%c (%#02x/%#02x).\n",
+ 				       extp->MajorVersion, extp->MinorVersion,
Index: trunk/target/linux/generic/patches-2.6.39/530-gspca-sn9c20x-jpeg.patch
===================================================================
--- trunk/target/linux/generic/patches-2.6.39/530-gspca-sn9c20x-jpeg.patch	(revision 0)
+++ trunk/target/linux/generic/patches-2.6.39/530-gspca-sn9c20x-jpeg.patch	(working copy)
@@ -0,0 +1,148 @@
+increate JPEG buffersize and add JPEG quality set/get
+
+The largest framesize I've encountered was 230KB resulting from quality=95
+and a complex/blury image)
+--- a/drivers/media/video/gspca/sn9c20x.c
++++ b/drivers/media/video/gspca/sn9c20x.c
+@@ -33,6 +33,14 @@ MODULE_LICENSE("GPL");
+ 
+ #define MODULE_NAME "sn9c20x"
+ 
++#define QUALITY_MIN 20
++#define QUALITY_DEF 85
++#define QUALITY_MAX 95
++
++static int jpeg_quality = QUALITY_DEF;
++module_param(jpeg_quality, int, 0644);
++MODULE_PARM_DESC(jpeg_quality, "JPEG Quality");
++
+ /*
+  * Pixel format private data
+  */
+@@ -361,7 +369,7 @@ static const struct ctrl sd_ctrls[] = {
+ static const struct v4l2_pix_format vga_mode[] = {
+ 	{160, 120, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,
+ 		.bytesperline = 160,
+-		.sizeimage = 160 * 120 * 4 / 8 + 590,
++		.sizeimage = 160 * 120 * 7 / 8 + 590,
+ 		.colorspace = V4L2_COLORSPACE_JPEG,
+ 		.priv = SCALE_160x120 | MODE_JPEG},
+ 	{160, 120, V4L2_PIX_FMT_SBGGR8, V4L2_FIELD_NONE,
+@@ -376,7 +384,7 @@ static const struct v4l2_pix_format vga_
+ 		.priv = SCALE_160x120},
+ 	{320, 240, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,
+ 		.bytesperline = 320,
+-		.sizeimage = 320 * 240 * 4 / 8 + 590,
++		.sizeimage = 320 * 240 * 7 / 8 + 590,
+ 		.colorspace = V4L2_COLORSPACE_JPEG,
+ 		.priv = SCALE_320x240 | MODE_JPEG},
+ 	{320, 240, V4L2_PIX_FMT_SBGGR8, V4L2_FIELD_NONE,
+@@ -391,7 +399,7 @@ static const struct v4l2_pix_format vga_
+ 		.priv = SCALE_320x240},
+ 	{640, 480, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,
+ 		.bytesperline = 640,
+-		.sizeimage = 640 * 480 * 4 / 8 + 590,
++		.sizeimage = 640 * 480 * 7 / 8 + 590,
+ 		.colorspace = V4L2_COLORSPACE_JPEG,
+ 		.priv = SCALE_640x480 | MODE_JPEG},
+ 	{640, 480, V4L2_PIX_FMT_SBGGR8, V4L2_FIELD_NONE,
+@@ -409,7 +417,7 @@ static const struct v4l2_pix_format vga_
+ static const struct v4l2_pix_format sxga_mode[] = {
+ 	{160, 120, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,
+ 		.bytesperline = 160,
+-		.sizeimage = 160 * 120 * 4 / 8 + 590,
++		.sizeimage = 160 * 120 * 7 / 8 + 590,
+ 		.colorspace = V4L2_COLORSPACE_JPEG,
+ 		.priv = SCALE_160x120 | MODE_JPEG},
+ 	{160, 120, V4L2_PIX_FMT_SBGGR8, V4L2_FIELD_NONE,
+@@ -424,7 +432,7 @@ static const struct v4l2_pix_format sxga
+ 		.priv = SCALE_160x120},
+ 	{320, 240, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,
+ 		.bytesperline = 320,
+-		.sizeimage = 320 * 240 * 4 / 8 + 590,
++		.sizeimage = 320 * 240 * 7 / 8 + 590,
+ 		.colorspace = V4L2_COLORSPACE_JPEG,
+ 		.priv = SCALE_320x240 | MODE_JPEG},
+ 	{320, 240, V4L2_PIX_FMT_SBGGR8, V4L2_FIELD_NONE,
+@@ -439,7 +447,7 @@ static const struct v4l2_pix_format sxga
+ 		.priv = SCALE_320x240},
+ 	{640, 480, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,
+ 		.bytesperline = 640,
+-		.sizeimage = 640 * 480 * 4 / 8 + 590,
++		.sizeimage = 640 * 480 * 7 / 8 + 590,
+ 		.colorspace = V4L2_COLORSPACE_JPEG,
+ 		.priv = SCALE_640x480 | MODE_JPEG},
+ 	{640, 480, V4L2_PIX_FMT_SBGGR8, V4L2_FIELD_NONE,
+@@ -2087,7 +2095,7 @@ static int sd_config(struct gspca_dev *g
+ 	sd->gain = GAIN_DEFAULT;
+ 	sd->auto_exposure = AUTO_EXPOSURE_DEFAULT;
+ 
+-	sd->quality = 95;
++	sd->quality = jpeg_quality;
+ 
+ 	return 0;
+ }
+@@ -2464,6 +2472,38 @@ static void sd_pkt_scan(struct gspca_dev
+ 	}
+ }
+ 
++static int sd_set_jcomp(struct gspca_dev *gspca_dev,
++			struct v4l2_jpegcompression *jcomp)
++{
++	struct sd *sd = (struct sd *) gspca_dev;
++
++	if (jcomp->quality < QUALITY_MIN)
++		sd->quality = QUALITY_MIN;
++	else if (jcomp->quality > QUALITY_MAX)
++		sd->quality = QUALITY_MAX;
++	else
++		sd->quality = jcomp->quality;
++	if (gspca_dev->streaming)
++	{
++		jpeg_set_qual(sd->jpeg_hdr, sd->quality);
++		reg_w(gspca_dev, 0x1100, &sd->jpeg_hdr[JPEG_QT0_OFFSET], 64);
++		reg_w(gspca_dev, 0x1140, &sd->jpeg_hdr[JPEG_QT1_OFFSET], 64);
++	}
++	return gspca_dev->usb_err;
++}
++
++static int sd_get_jcomp(struct gspca_dev *gspca_dev,
++			struct v4l2_jpegcompression *jcomp)
++{
++	struct sd *sd = (struct sd *) gspca_dev;
++
++	memset(jcomp, 0, sizeof *jcomp);
++	jcomp->quality = sd->quality;
++	jcomp->jpeg_markers = V4L2_JPEG_MARKER_DHT
++			| V4L2_JPEG_MARKER_DQT;
++	return 0;
++}
++
+ /* sub-driver description */
+ static const struct sd_desc sd_desc = {
+ 	.name = MODULE_NAME,
+@@ -2483,6 +2523,8 @@ static const struct sd_desc sd_desc = {
+ 	.get_register = sd_dbg_g_register,
+ #endif
+ 	.get_chip_ident = sd_chip_ident,
++	.set_jcomp = sd_set_jcomp,
++	.get_jcomp = sd_get_jcomp,
+ };
+ 
+ #define SN9C20X(sensor, i2c_addr, flags) \
+--- a/drivers/media/video/gspca/gspca.c
++++ b/drivers/media/video/gspca/gspca.c
+@@ -931,11 +931,13 @@ static int gspca_get_mode(struct gspca_d
+ 								== pixfmt)
+ 				return modeD;
+ 		}
++/*
+ 		if (++modeU < gspca_dev->cam.nmodes) {
+ 			if (gspca_dev->cam.cam_mode[modeU].pixelformat
+ 								== pixfmt)
+ 				return modeU;
+ 		}
++*/
+ 	}
+ 	return -EINVAL;
+ }
Index: trunk/target/linux/generic/patches-2.6.39/800-option_new_devices.patch
===================================================================
--- trunk/target/linux/generic/patches-2.6.39/800-option_new_devices.patch	(revision 0)
+++ trunk/target/linux/generic/patches-2.6.39/800-option_new_devices.patch	(working copy)
@@ -0,0 +1,36 @@
+--- a/drivers/net/usb/hso.c
++++ b/drivers/net/usb/hso.c
+@@ -476,8 +476,10 @@ static const struct usb_device_id hso_id
+ 	{USB_DEVICE(0x0af0, 0x8400)},
+ 	{USB_DEVICE(0x0af0, 0x8600)},
+ 	{USB_DEVICE(0x0af0, 0x8800)},
+-	{USB_DEVICE(0x0af0, 0x8900)},
+-	{USB_DEVICE(0x0af0, 0x9000)},
++	{USB_DEVICE(0x0af0, 0x8900)},		/* GTM 67xx */
++	{USB_DEVICE(0x0af0, 0x9000)},		/* GTM 66xx */
++	{USB_DEVICE(0x0af0, 0x9200)},		/* GTM 67xxWFS */
++	{USB_DEVICE(0x0af0, 0x9300)},		/* GTM 66xxWFS */
+ 	{USB_DEVICE(0x0af0, 0xd035)},
+ 	{USB_DEVICE(0x0af0, 0xd055)},
+ 	{USB_DEVICE(0x0af0, 0xd155)},
+--- a/drivers/usb/storage/unusual_devs.h
++++ b/drivers/usb/storage/unusual_devs.h
+@@ -1231,6 +1231,18 @@ UNUSUAL_DEV( 0x0af0, 0x8304, 0x0000, 0x0
+ 		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
+ 		0 ),
+ 
++UNUSUAL_DEV( 0x0af0, 0x9200, 0x0000, 0x0000,
++		"Option",
++		"Globetrotter 67xxWFS SD-Card",
++		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
++		0 ),
++
++UNUSUAL_DEV( 0x0af0, 0x9300, 0x0000, 0x0000,
++		"Option",
++		"Globetrotter 66xxWFS SD-Card",
++		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
++		0 ),
++
+ UNUSUAL_DEV( 0x0af0, 0xc100, 0x0000, 0x0000,
+ 		"Option",
+ 		"GI 070x SD-Card",
Index: trunk/target/linux/generic/patches-2.6.39/970-usb3380_usb3_support.patch
===================================================================
--- trunk/target/linux/generic/patches-2.6.39/970-usb3380_usb3_support.patch	(revision 0)
+++ trunk/target/linux/generic/patches-2.6.39/970-usb3380_usb3_support.patch	(working copy)
@@ -0,0 +1,7725 @@
+--- a/drivers/usb/gadget/Kconfig
++++ b/drivers/usb/gadget/Kconfig
+@@ -467,6 +467,25 @@ config USB_NET2280
+ 	default USB_GADGET
+ 	select USB_GADGET_SELECTED
+ 
++config USB_GADGET_USB3380
++	boolean "PLX USB338x"
++	depends on PCI
++	select USB_GADGET_DUALSPEED
++	select USB_GADGET_SUPERSPEED
++	help
++	   PLX USB 338x is a PCI based USB peripheral controller which
++	   supports full/high/super speed USB 3.0 data transfers.
++
++	   Say "y" to link the driver statically, or "m" to build a
++	   dynamically linked module called "usb3380" and force all
++	   gadget drivers to also be dynamically linked.
++
++config USB_USB3380
++	tristate
++	depends on USB_GADGET_USB3380
++	default USB_GADGET
++	select USB_GADGET_SELECTED
++
+ config USB_GADGET_GOKU
+ 	boolean "Toshiba TC86C001 'Goku-S'"
+ 	depends on PCI
+@@ -605,6 +624,13 @@ config USB_GADGET_DUALSPEED
+ 	  Means that gadget drivers should include extra descriptors
+ 	  and code to handle dual-speed controllers.
+ 
++
++# Selected by UDC drivers that support super-speed opperation
++config USB_GADGET_SUPERSPEED
++	bool
++	depends on USB_GADGET
++	depends on USB_GADGET_DUALSPEED
++
+ #
+ # USB Gadget Drivers
+ #
+@@ -654,6 +680,11 @@ config USB_ZERO
+ 	  Say "y" to link the driver statically, or "m" to build a
+ 	  dynamically linked module called "g_zero".
+ 
++config PLX_LOOPHOST_TEST
++	bool "PLX LoopHost Test"
++	depends on USB_ZERO
++	default y
++
+ config USB_ZERO_HNPTEST
+ 	boolean "HNP Test Device"
+ 	depends on USB_ZERO && USB_OTG
+--- a/drivers/usb/gadget/Makefile
++++ b/drivers/usb/gadget/Makefile
+@@ -3,8 +3,12 @@
+ #
+ ccflags-$(CONFIG_USB_GADGET_DEBUG) := -DDEBUG
+ 
++ifndef CONFIG_USB_DWC_OTG
++obj-$(CONFIG_USB_GADGET)	+= udc-core.o
++endif
+ obj-$(CONFIG_USB_DUMMY_HCD)	+= dummy_hcd.o
+ obj-$(CONFIG_USB_NET2280)	+= net2280.o
++obj-$(CONFIG_USB_USB3380)	+= usb3380.o
+ obj-$(CONFIG_USB_AMD5536UDC)	+= amd5536udc.o
+ obj-$(CONFIG_USB_PXA25X)	+= pxa25x_udc.o
+ obj-$(CONFIG_USB_PXA27X)	+= pxa27x_udc.o
+--- a/drivers/usb/gadget/composite.c
++++ b/drivers/usb/gadget/composite.c
+@@ -27,7 +27,7 @@
+ #include <linux/utsname.h>
+ 
+ #include <linux/usb/composite.h>
+-
++#include <asm/unaligned.h>
+ 
+ /*
+  * The code in this file is utility code, used to build a gadget driver
+@@ -42,7 +42,7 @@
+ static struct usb_composite_driver *composite;
+ static int (*composite_gadget_bind)(struct usb_composite_dev *cdev);
+ 
+-/* Some systems will need runtime overrides for the  product identifiers
++/* Some systems will need runtime overrides for the  product identifers
+  * published in the device descriptor, either numbers or strings or both.
+  * String parameters are in UTF-8 (superset of ASCII's 7 bit characters).
+  */
+@@ -74,6 +74,130 @@ MODULE_PARM_DESC(iSerialNumber, "SerialN
+ static char composite_manufacturer[50];
+ 
+ /*-------------------------------------------------------------------------*/
++/**
++ * next_ep_desc() - advance to the next EP descriptor
++ * @t: currect pointer within descriptor array
++ *
++ * Return: next EP descriptor or NULL
++ *
++ * Iterate over @t until either EP descriptor found or
++ * NULL (that indicates end of list) encountered
++ */
++static struct usb_descriptor_header**
++next_ep_desc(struct usb_descriptor_header **t)
++{
++	for (; *t; t++) {
++		if ((*t)->bDescriptorType == USB_DT_ENDPOINT)
++			return t;
++	}
++	return NULL;
++}
++
++/*
++ * for_each_ep_desc()- iterate over endpoint descriptors in the
++ *		descriptors list
++ * @start:	pointer within descriptor array.
++ * @ep_desc:	endpoint descriptor to use as the loop cursor
++ */
++#define for_each_ep_desc(start, ep_desc) \
++	for (ep_desc = next_ep_desc(start); \
++	      ep_desc; ep_desc = next_ep_desc(ep_desc+1))
++
++/**
++ * config_ep_by_speed() - configures the given endpoint
++ * according to gadget speed.
++ * @g: pointer to the gadget
++ * @f: usb function
++ * @_ep: the endpoint to configure
++ *
++ * Return: error code, 0 on success
++ *
++ * This function chooses the right descriptors for a given
++ * endpoint according to gadget speed and saves it in the
++ * endpoint desc field. If the endpoint already has a descriptor
++ * assigned to it - overwrites it with currently corresponding
++ * descriptor. The endpoint maxpacket field is updated according
++ * to the chosen descriptor.
++ * Note: the supplied function should hold all the descriptors
++ * for supported speeds
++ */
++int config_ep_by_speed(struct usb_gadget *g,
++			struct usb_function *f,
++			struct usb_ep *_ep)
++{
++	struct usb_endpoint_descriptor *chosen_desc = NULL;
++	struct usb_descriptor_header **speed_desc = NULL;
++
++	struct usb_ss_ep_comp_descriptor *comp_desc = NULL;
++	int want_comp_desc = 0;
++
++	struct usb_descriptor_header **d_spd; /* cursor for speed desc */
++
++	if (!g || !f || !_ep)
++		return -EIO;
++
++	/* select desired speed */
++	switch (g->speed) {
++	case USB_SPEED_SUPER:
++		if (gadget_is_superspeed(g)) {
++			speed_desc = f->ss_descriptors;
++			want_comp_desc = 1;
++			break;
++		}
++		/* else: Fall trough */
++	case USB_SPEED_HIGH:
++		if (gadget_is_dualspeed(g)) {
++			speed_desc = f->hs_descriptors;
++			break;
++		}
++		/* else: fall through */
++	default:
++		speed_desc = f->descriptors;
++	}
++	/* find descriptors */
++	for_each_ep_desc(speed_desc, d_spd) {
++		chosen_desc = (struct usb_endpoint_descriptor *)*d_spd;
++		if (chosen_desc->bEndpointAddress == _ep->address)
++			goto ep_found;
++	}
++	return -EIO;
++
++ep_found:
++	/* commit results */
++	_ep->maxpacket = le16_to_cpu(chosen_desc->wMaxPacketSize);
++	_ep->desc = chosen_desc;
++	_ep->comp_desc = NULL;
++	_ep->maxburst = 0;
++	_ep->mult = 0;
++	if (!want_comp_desc)
++		return 0;
++
++	/*
++	 * Companion descriptor should follow EP descriptor
++	 * USB 3.0 spec, #9.6.7
++	 */
++	comp_desc = (struct usb_ss_ep_comp_descriptor *)*(++d_spd);
++	if (!comp_desc ||
++	    (comp_desc->bDescriptorType != USB_DT_SS_ENDPOINT_COMP))
++		return -EIO;
++	_ep->comp_desc = comp_desc;
++	if (g->speed == USB_SPEED_SUPER) {
++		switch (usb_endpoint_type(_ep->desc)) {
++		case USB_ENDPOINT_XFER_BULK:
++		case USB_ENDPOINT_XFER_INT:
++			_ep->maxburst = comp_desc->bMaxBurst;
++			break;
++		case USB_ENDPOINT_XFER_ISOC:
++			/* mult: bits 1:0 of bmAttributes */
++			_ep->mult = comp_desc->bmAttributes & 0x3;
++			break;
++		default:
++			/* Do nothing for control endpoints */
++			break;
++		}
++	}
++	return 0;
++}
+ 
+ /**
+  * usb_add_function() - add a function to a configuration
+@@ -123,6 +247,8 @@ int usb_add_function(struct usb_configur
+ 		config->fullspeed = true;
+ 	if (!config->highspeed && function->hs_descriptors)
+ 		config->highspeed = true;
++	if (!config->superspeed && function->ss_descriptors)
++		config->superspeed = true;
+ 
+ done:
+ 	if (value)
+@@ -205,14 +331,14 @@ int usb_function_activate(struct usb_fun
+  * usb_interface_id() is called from usb_function.bind() callbacks to
+  * allocate new interface IDs.  The function driver will then store that
+  * ID in interface, association, CDC union, and other descriptors.  It
+- * will also handle any control requests targeted at that interface,
++ * will also handle any control requests targetted at that interface,
+  * particularly changing its altsetting via set_alt().  There may
+  * also be class-specific or vendor-specific requests to handle.
+  *
+  * All interface identifier should be allocated using this routine, to
+  * ensure that for example different functions don't wrongly assign
+  * different meanings to the same identifier.  Note that since interface
+- * identifiers are configuration-specific, functions used in more than
++ * identifers are configuration-specific, functions used in more than
+  * one configuration (or more than once in a given configuration) need
+  * multiple versions of the relevant descriptors.
+  *
+@@ -266,10 +392,17 @@ static int config_buf(struct usb_configu
+ 	list_for_each_entry(f, &config->functions, list) {
+ 		struct usb_descriptor_header **descriptors;
+ 
+-		if (speed == USB_SPEED_HIGH)
++		switch (speed) {
++		case USB_SPEED_SUPER:
++			descriptors = f->ss_descriptors;
++			break;
++		case USB_SPEED_HIGH:
+ 			descriptors = f->hs_descriptors;
+-		else
++			break;
++		default:
+ 			descriptors = f->descriptors;
++		}
++
+ 		if (!descriptors)
+ 			continue;
+ 		status = usb_descriptor_fillbuf(next, len,
+@@ -292,9 +425,10 @@ static int config_desc(struct usb_compos
+ 	u8				type = w_value >> 8;
+ 	enum usb_device_speed		speed = USB_SPEED_UNKNOWN;
+ 
+-	if (gadget_is_dualspeed(gadget)) {
+-		int			hs = 0;
+-
++	if (gadget->speed == USB_SPEED_SUPER)
++		speed = gadget->speed;
++	else if (gadget_is_dualspeed(gadget)) {
++		int	hs = 0;
+ 		if (gadget->speed == USB_SPEED_HIGH)
+ 			hs = 1;
+ 		if (type == USB_DT_OTHER_SPEED_CONFIG)
+@@ -308,13 +442,20 @@ static int config_desc(struct usb_compos
+ 	w_value &= 0xff;
+ 	list_for_each_entry(c, &cdev->configs, list) {
+ 		/* ignore configs that won't work at this speed */
+-		if (speed == USB_SPEED_HIGH) {
++		switch (speed) {
++		case USB_SPEED_SUPER:
++			if (!c->superspeed)
++				continue;
++			break;
++		case USB_SPEED_HIGH:
+ 			if (!c->highspeed)
+ 				continue;
+-		} else {
++			break;
++		default:
+ 			if (!c->fullspeed)
+ 				continue;
+ 		}
++
+ 		if (w_value == 0)
+ 			return config_buf(c, speed, cdev->req->buf, type);
+ 		w_value--;
+@@ -328,16 +469,22 @@ static int count_configs(struct usb_comp
+ 	struct usb_configuration	*c;
+ 	unsigned			count = 0;
+ 	int				hs = 0;
++	int				ss = 0;
+ 
+ 	if (gadget_is_dualspeed(gadget)) {
+ 		if (gadget->speed == USB_SPEED_HIGH)
+ 			hs = 1;
++		if (gadget->speed == USB_SPEED_SUPER)
++			ss = 1;
+ 		if (type == USB_DT_DEVICE_QUALIFIER)
+ 			hs = !hs;
+ 	}
+ 	list_for_each_entry(c, &cdev->configs, list) {
+ 		/* ignore configs that won't work at this speed */
+-		if (hs) {
++		if (ss) {
++			if (!c->superspeed)
++				continue;
++		} else if (hs) {
+ 			if (!c->highspeed)
+ 				continue;
+ 		} else {
+@@ -349,6 +496,71 @@ static int count_configs(struct usb_comp
+ 	return count;
+ }
+ 
++/**
++ * bos_desc() - prepares the BOS descriptor.
++ * @cdev: pointer to usb_composite device to generate the bos
++ *	descriptor for
++ *
++ * This function generates the BOS (Binary Device Object)
++ * descriptor and its device capabilities descriptors. The BOS
++ * descriptor should be supported by a SuperSpeed device.
++ */
++static int bos_desc(struct usb_composite_dev *cdev)
++{
++	struct usb_ext_cap_descriptor	*usb_ext;
++	struct usb_ss_cap_descriptor	*ss_cap;
++	struct usb_dcd_config_params	dcd_config_params;
++	struct usb_bos_descriptor	*bos = cdev->req->buf;
++
++	bos->bLength = USB_DT_BOS_SIZE;
++	bos->bDescriptorType = USB_DT_BOS;
++
++	bos->wTotalLength = cpu_to_le16(USB_DT_BOS_SIZE);
++	bos->bNumDeviceCaps = 0;
++
++	/*
++	 * A SuperSpeed device shall include the USB2.0 extension descriptor
++	 * and shall support LPM when operating in USB2.0 HS mode.
++	 */
++	usb_ext = cdev->req->buf + le16_to_cpu(bos->wTotalLength);
++	bos->bNumDeviceCaps++;
++	le16_add_cpu(&bos->wTotalLength, USB_DT_USB_EXT_CAP_SIZE);
++	usb_ext->bLength = USB_DT_USB_EXT_CAP_SIZE;
++	usb_ext->bDescriptorType = USB_DT_DEVICE_CAPABILITY;
++	usb_ext->bDevCapabilityType = USB_CAP_TYPE_EXT;
++	usb_ext->bmAttributes = cpu_to_le32(USB_LPM_SUPPORT);
++
++	/*
++	 * The Superspeed USB Capability descriptor shall be implemented by all
++	 * SuperSpeed devices.
++	 */
++	ss_cap = cdev->req->buf + le16_to_cpu(bos->wTotalLength);
++	bos->bNumDeviceCaps++;
++	le16_add_cpu(&bos->wTotalLength, USB_DT_USB_SS_CAP_SIZE);
++	ss_cap->bLength = USB_DT_USB_SS_CAP_SIZE;
++	ss_cap->bDescriptorType = USB_DT_DEVICE_CAPABILITY;
++	ss_cap->bDevCapabilityType = USB_SS_CAP_TYPE;
++	ss_cap->bmAttributes = 0; /* LTM is not supported yet */
++	ss_cap->wSpeedSupported = cpu_to_le16(USB_LOW_SPEED_OPERATION |
++				USB_FULL_SPEED_OPERATION |
++				USB_HIGH_SPEED_OPERATION |
++				USB_5GBPS_OPERATION);
++	ss_cap->bFunctionalitySupport = USB_LOW_SPEED_OPERATION;
++
++	/* Get Controller configuration */
++	if (cdev->gadget->ops->get_config_params)
++		cdev->gadget->ops->get_config_params(&dcd_config_params);
++	else {
++		dcd_config_params.bU1devExitLat = USB_DEFULT_U1_DEV_EXIT_LAT;
++		dcd_config_params.bU2DevExitLat =
++			cpu_to_le16(USB_DEFULT_U2_DEV_EXIT_LAT);
++	}
++	ss_cap->bU1devExitLat = dcd_config_params.bU1devExitLat;
++	ss_cap->bU2DevExitLat = dcd_config_params.bU2DevExitLat;
++
++	return le16_to_cpu(bos->wTotalLength);
++}
++
+ static void device_qual(struct usb_composite_dev *cdev)
+ {
+ 	struct usb_qualifier_descriptor	*qual = cdev->req->buf;
+@@ -361,7 +573,7 @@ static void device_qual(struct usb_compo
+ 	qual->bDeviceSubClass = cdev->desc.bDeviceSubClass;
+ 	qual->bDeviceProtocol = cdev->desc.bDeviceProtocol;
+ 	/* ASSUME same EP0 fifo size at both speeds */
+-	qual->bMaxPacketSize0 = cdev->desc.bMaxPacketSize0;
++	qual->bMaxPacketSize0 = cdev->gadget->ep0->maxpacket;
+ 	qual->bNumConfigurations = count_configs(cdev, USB_DT_DEVICE_QUALIFIER);
+ 	qual->bRESERVED = 0;
+ }
+@@ -373,7 +585,6 @@ static void reset_config(struct usb_comp
+ 	struct usb_function		*f;
+ 
+ 	DBG(cdev, "reset config\n");
+-
+ 	list_for_each_entry(f, &cdev->config->functions, list) {
+ 		if (f->disable)
+ 			f->disable(f);
+@@ -392,28 +603,46 @@ static int set_config(struct usb_composi
+ 	unsigned		power = gadget_is_otg(gadget) ? 8 : 100;
+ 	int			tmp;
+ 
+-	if (cdev->config)
+-		reset_config(cdev);
+-
+ 	if (number) {
+ 		list_for_each_entry(c, &cdev->configs, list) {
+ 			if (c->bConfigurationValue == number) {
++				/*
++				 * We disable the FDs of the previous
++				 * configuration only if the new configuration
++				 * is a valid one
++				 */
++				if (cdev->config)
++					reset_config(cdev);
+ 				result = 0;
+ 				break;
+ 			}
+ 		}
+ 		if (result < 0)
+ 			goto done;
+-	} else
++	} else { /* Zero configuration value - need to reset the config */
++		if (cdev->config)
++			reset_config(cdev);
+ 		result = 0;
++	}
+ 
+ 	INFO(cdev, "%s speed config #%d: %s\n",
+ 		({ char *speed;
+ 		switch (gadget->speed) {
+-		case USB_SPEED_LOW:	speed = "low"; break;
+-		case USB_SPEED_FULL:	speed = "full"; break;
+-		case USB_SPEED_HIGH:	speed = "high"; break;
+-		default:		speed = "?"; break;
++		case USB_SPEED_LOW:
++			speed = "low";
++			break;
++		case USB_SPEED_FULL:
++			speed = "full";
++			break;
++		case USB_SPEED_HIGH:
++			speed = "high";
++			break;
++		case USB_SPEED_SUPER:
++			speed = "super";
++			break;
++		default:
++			speed = "?";
++			break;
+ 		} ; speed; }), number, c ? c->label : "unconfigured");
+ 
+ 	if (!c)
+@@ -435,10 +664,16 @@ static int set_config(struct usb_composi
+ 		 * function's setup callback instead of the current
+ 		 * configuration's setup callback.
+ 		 */
+-		if (gadget->speed == USB_SPEED_HIGH)
++		switch (gadget->speed) {
++		case USB_SPEED_SUPER:
++			descriptors = f->ss_descriptors;
++			break;
++		case USB_SPEED_HIGH:
+ 			descriptors = f->hs_descriptors;
+-		else
++			break;
++		default:
+ 			descriptors = f->descriptors;
++		}
+ 
+ 		for (; *descriptors; ++descriptors) {
+ 			struct usb_endpoint_descriptor *ep;
+@@ -461,12 +696,23 @@ static int set_config(struct usb_composi
+ 			reset_config(cdev);
+ 			goto done;
+ 		}
++
++		if (result == USB_GADGET_DELAYED_STATUS) {
++			DBG(cdev,
++			 "%s: interface %d (%s) requested delayed status\n",
++					__func__, tmp, f->name);
++			cdev->delayed_status++;
++			DBG(cdev, "delayed_status count %d\n",
++					cdev->delayed_status);
++		}
+ 	}
+ 
+ 	/* when we return, be sure our power usage is valid */
+ 	power = c->bMaxPower ? (2 * c->bMaxPower) : CONFIG_USB_GADGET_VBUS_DRAW;
+ done:
+ 	usb_gadget_vbus_draw(gadget, power);
++	if (result >= 0 && cdev->delayed_status)
++		result = USB_GADGET_DELAYED_STATUS;
+ 	return result;
+ }
+ 
+@@ -520,8 +766,9 @@ int usb_add_config(struct usb_composite_
+ 	} else {
+ 		unsigned	i;
+ 
+-		DBG(cdev, "cfg %d/%p speeds:%s%s\n",
++		DBG(cdev, "cfg %d/%p speeds:%s%s%s\n",
+ 			config->bConfigurationValue, config,
++			config->superspeed ? " super" : "",
+ 			config->highspeed ? " high" : "",
+ 			config->fullspeed
+ 				? (gadget_is_dualspeed(cdev->gadget)
+@@ -800,6 +1047,7 @@ composite_setup(struct usb_gadget *gadge
+ 	struct usb_composite_dev	*cdev = get_gadget_data(gadget);
+ 	struct usb_request		*req = cdev->req;
+ 	int				value = -EOPNOTSUPP;
++	int				status = 0;
+ 	u16				w_index = le16_to_cpu(ctrl->wIndex);
+ 	u8				intf = w_index & 0xFF;
+ 	u16				w_value = le16_to_cpu(ctrl->wValue);
+@@ -827,18 +1075,29 @@ composite_setup(struct usb_gadget *gadge
+ 		case USB_DT_DEVICE:
+ 			cdev->desc.bNumConfigurations =
+ 				count_configs(cdev, USB_DT_DEVICE);
++			cdev->desc.bMaxPacketSize0 =
++				cdev->gadget->ep0->maxpacket;
++			if (gadget_is_superspeed(gadget)) {
++				if (gadget->speed >= USB_SPEED_SUPER) {
++					cdev->desc.bcdUSB = cpu_to_le16(0x0300);
++					cdev->desc.bMaxPacketSize0 = cpu_to_le16(0x09);
++				} else
++					cdev->desc.bcdUSB = cpu_to_le16(0x0210);
++			}
+ 			value = min(w_length, (u16) sizeof cdev->desc);
+ 			memcpy(req->buf, &cdev->desc, value);
+ 			break;
+ 		case USB_DT_DEVICE_QUALIFIER:
+-			if (!gadget_is_dualspeed(gadget))
++			if (!gadget_is_dualspeed(gadget) ||
++			    gadget->speed >= USB_SPEED_SUPER)
+ 				break;
+ 			device_qual(cdev);
+ 			value = min_t(int, w_length,
+ 				sizeof(struct usb_qualifier_descriptor));
+ 			break;
+ 		case USB_DT_OTHER_SPEED_CONFIG:
+-			if (!gadget_is_dualspeed(gadget))
++			if (!gadget_is_dualspeed(gadget) ||
++			    gadget->speed >= USB_SPEED_SUPER)
+ 				break;
+ 			/* FALLTHROUGH */
+ 		case USB_DT_CONFIG:
+@@ -852,6 +1111,12 @@ composite_setup(struct usb_gadget *gadge
+ 			if (value >= 0)
+ 				value = min(w_length, (u16) value);
+ 			break;
++		case USB_DT_BOS:
++			if (gadget_is_superspeed(gadget)) {
++				value = bos_desc(cdev);
++				value = min(w_length, (u16) value);
++			}
++			break;
+ 		}
+ 		break;
+ 
+@@ -895,6 +1160,14 @@ composite_setup(struct usb_gadget *gadge
+ 		if (w_value && !f->set_alt)
+ 			break;
+ 		value = f->set_alt(f, w_index, w_value);
++		if (value == USB_GADGET_DELAYED_STATUS) {
++			DBG(cdev,
++			 "%s: interface %d (%s) requested delayed status\n",
++					__func__, intf, f->name);
++			cdev->delayed_status++;
++			DBG(cdev, "delayed_status count %d\n",
++					cdev->delayed_status);
++		}
+ 		break;
+ 	case USB_REQ_GET_INTERFACE:
+ 		if (ctrl->bRequestType != (USB_DIR_IN|USB_RECIP_INTERFACE))
+@@ -911,6 +1184,60 @@ composite_setup(struct usb_gadget *gadge
+ 		*((u8 *)req->buf) = value;
+ 		value = min(w_length, (u16) 1);
+ 		break;
++	/*
++	 * USB 3.0 additions:
++	 * Function driver should handle get_status request. If such cb
++	 * wasn't supplied we respond with default value = 0
++	 * Note: function driver should supply such cb only for the first
++	 * interface of the function
++	 */
++	case USB_REQ_GET_STATUS:
++		if (!gadget_is_superspeed(gadget))
++			goto unknown;
++		if (ctrl->bRequestType != (USB_DIR_IN | USB_RECIP_INTERFACE))
++			goto unknown;
++		value = 2;	/* This is the length of the get_status reply */
++		put_unaligned_le16(0, req->buf);
++		if (!cdev->config || intf >= MAX_CONFIG_INTERFACES)
++			break;
++		f = cdev->config->interface[intf];
++		if (!f)
++			break;
++		status = f->get_status ? f->get_status(f) : 0;
++		if (status < 0)
++			break;
++		put_unaligned_le16(status & 0x0000ffff, req->buf);
++		break;
++	/*
++	 * Function drivers should handle SetFeature/ClearFeature
++	 * (FUNCTION_SUSPEND) request. function_suspend cb should be supplied
++	 * only for the first interface of the function
++	 */
++	case USB_REQ_CLEAR_FEATURE:
++	case USB_REQ_SET_FEATURE:
++		if (!gadget_is_superspeed(gadget))
++			goto unknown;
++		if (ctrl->bRequestType != (USB_DIR_OUT | USB_RECIP_INTERFACE))
++			goto unknown;
++		switch (w_value) {
++		case USB_INTRF_FUNC_SUSPEND:
++			if (!cdev->config || intf >= MAX_CONFIG_INTERFACES)
++				break;
++			f = cdev->config->interface[intf];
++			if (!f)
++				break;
++			value = 0;
++			if (f->func_suspend)
++				value = f->func_suspend(f, w_index >> 8);
++			if (value < 0) {
++				ERROR(cdev,
++				      "func_suspend() returned error %d\n",
++				      value);
++				value = 0;
++			}
++			break;
++		}
++		break;
+ 	default:
+ unknown:
+ 		VDBG(cdev,
+@@ -958,7 +1285,7 @@ unknown:
+ 	}
+ 
+ 	/* respond with data transfer before status phase? */
+-	if (value >= 0) {
++	if (value >= 0 && value != USB_GADGET_DELAYED_STATUS) {
+ 		req->length = value;
+ 		req->zero = value < w_length;
+ 		value = usb_ep_queue(gadget->ep0, req, GFP_ATOMIC);
+@@ -967,6 +1294,10 @@ unknown:
+ 			req->status = 0;
+ 			composite_setup_complete(gadget->ep0, req);
+ 		}
++	} else if (value == USB_GADGET_DELAYED_STATUS && w_length != 0) {
++		WARN(cdev,
++			"%s: Delayed status not supported for w_length != 0",
++			__func__);
+ 	}
+ 
+ done:
+@@ -978,7 +1309,6 @@ static void composite_disconnect(struct
+ {
+ 	struct usb_composite_dev	*cdev = get_gadget_data(gadget);
+ 	unsigned long			flags;
+-
+ 	/* REVISIT:  should we have config and device level
+ 	 * disconnect callbacks?
+ 	 */
+@@ -1099,8 +1429,9 @@ static int composite_bind(struct usb_gad
+ 	 * more than 100mA from USB must report itself as bus-powered in
+ 	 * the GetStatus(DEVICE) call.
+ 	 */
+-	if (CONFIG_USB_GADGET_VBUS_DRAW <= USB_SELF_POWER_VBUS_MAX_DRAW)
++	if (CONFIG_USB_GADGET_VBUS_DRAW <= USB_SELF_POWER_VBUS_MAX_DRAW) {
+ 		usb_gadget_set_selfpowered(gadget);
++	}
+ 
+ 	/* interface and string IDs start at zero via kzalloc.
+ 	 * we force endpoints to start unassigned; few controller
+@@ -1117,7 +1448,6 @@ static int composite_bind(struct usb_gad
+ 		goto fail;
+ 
+ 	cdev->desc = *composite->dev;
+-	cdev->desc.bMaxPacketSize0 = gadget->ep0->maxpacket;
+ 
+ 	/* standardized runtime overrides for device ID data */
+ 	if (idVendor)
+@@ -1224,7 +1554,11 @@ composite_resume(struct usb_gadget *gadg
+ /*-------------------------------------------------------------------------*/
+ 
+ static struct usb_gadget_driver composite_driver = {
++#ifdef CONFIG_USB_GADGET_SUPERSPEED
++	.speed		= USB_SPEED_SUPER,
++#else
+ 	.speed		= USB_SPEED_HIGH,
++#endif
+ 
+ 	.unbind		= composite_unbind,
+ 
+@@ -1270,6 +1604,8 @@ int usb_composite_probe(struct usb_compo
+ 		driver->iProduct = driver->name;
+ 	composite_driver.function =  (char *) driver->name;
+ 	composite_driver.driver.name = driver->name;
++	composite_driver.speed = min((u8)composite_driver.speed,
++				     (u8)driver->max_speed);
+ 	composite = driver;
+ 	composite_gadget_bind = bind;
+ 
+@@ -1289,3 +1625,40 @@ void usb_composite_unregister(struct usb
+ 		return;
+ 	usb_gadget_unregister_driver(&composite_driver);
+ }
++
++/**
++ * usb_composite_setup_continue() - Continue with the control transfer
++ * @cdev: the composite device who's control transfer was kept waiting
++ *
++ * This function must be called by the USB function driver to continue
++ * with the control transfer's data/status stage in case it had requested to
++ * delay the data/status stages. A USB function's setup handler (e.g. set_alt())
++ * can request the composite framework to delay the setup request's data/status
++ * stages by returning USB_GADGET_DELAYED_STATUS.
++ */
++void usb_composite_setup_continue(struct usb_composite_dev *cdev)
++{
++	int			value;
++	struct usb_request	*req = cdev->req;
++	unsigned long		flags;
++
++	DBG(cdev, "%s\n", __func__);
++	spin_lock_irqsave(&cdev->lock, flags);
++
++	if (cdev->delayed_status == 0) {
++		WARN(cdev, "%s: Unexpected call\n", __func__);
++
++	} else if (--cdev->delayed_status == 0) {
++		DBG(cdev, "%s: Completing delayed status\n", __func__);
++		req->length = 0;
++		value = usb_ep_queue(cdev->gadget->ep0, req, GFP_ATOMIC);
++		if (value < 0) {
++			DBG(cdev, "ep_queue --> %d\n", value);
++			req->status = 0;
++			composite_setup_complete(cdev->gadget->ep0, req);
++		}
++	}
++
++	spin_unlock_irqrestore(&cdev->lock, flags);
++}
++
+--- a/drivers/usb/gadget/epautoconf.c
++++ b/drivers/usb/gadget/epautoconf.c
+@@ -63,13 +63,16 @@ static int
+ ep_matches (
+ 	struct usb_gadget		*gadget,
+ 	struct usb_ep			*ep,
+-	struct usb_endpoint_descriptor	*desc
++	struct usb_endpoint_descriptor	*desc,
++	struct usb_ss_ep_comp_descriptor *ep_comp
+ )
+ {
+ 	u8		type;
+ 	const char	*tmp;
+ 	u16		max;
+ 
++	int		num_req_streams = 0;
++
+ 	/* endpoint already claimed? */
+ 	if (NULL != ep->driver_data)
+ 		return 0;
+@@ -129,6 +132,22 @@ ep_matches (
+ 	}
+ 
+ 	/*
++	 * Get the number of required streams from the EP companion
++	 * descriptor and see if the EP matches it
++	 */
++	if (usb_endpoint_xfer_bulk(desc)) {
++		if (ep_comp) {
++			num_req_streams = ep_comp->bmAttributes & 0x1f;
++			if (num_req_streams > ep->max_streams)
++				return 0;
++			/* Update the ep_comp descriptor if needed */
++			if (num_req_streams != ep->max_streams)
++				ep_comp->bmAttributes = ep->max_streams;
++		}
++
++	}
++
++	/*
+ 	 * If the protocol driver hasn't yet decided on wMaxPacketSize
+ 	 * and wants to know the maximum possible, provide the info.
+ 	 */
+@@ -142,13 +161,13 @@ ep_matches (
+ 	max = 0x7ff & le16_to_cpu(desc->wMaxPacketSize);
+ 	switch (type) {
+ 	case USB_ENDPOINT_XFER_INT:
+-		/* INT:  limit 64 bytes full speed, 1024 high speed */
++		/* INT:  limit 64 bytes full speed, 1024 high/super speed */
+ 		if (!gadget->is_dualspeed && max > 64)
+ 			return 0;
+ 		/* FALLTHROUGH */
+ 
+ 	case USB_ENDPOINT_XFER_ISOC:
+-		/* ISO:  limit 1023 bytes full speed, 1024 high speed */
++		/* ISO:  limit 1023 bytes full speed, 1024 high/super speed */
+ 		if (ep->maxpacket < max)
+ 			return 0;
+ 		if (!gadget->is_dualspeed && max > 1023)
+@@ -183,7 +202,7 @@ ep_matches (
+ 	}
+ 
+ 	/* report (variable) full speed bulk maxpacket */
+-	if (USB_ENDPOINT_XFER_BULK == type) {
++	if ((USB_ENDPOINT_XFER_BULK == type) && !ep_comp) {
+ 		int size = ep->maxpacket;
+ 
+ 		/* min() doesn't work on bitfields with gcc-3.5 */
+@@ -191,6 +210,7 @@ ep_matches (
+ 			size = 64;
+ 		desc->wMaxPacketSize = cpu_to_le16(size);
+ 	}
++	ep->address = desc->bEndpointAddress;
+ 	return 1;
+ }
+ 
+@@ -207,38 +227,53 @@ find_ep (struct usb_gadget *gadget, cons
+ }
+ 
+ /**
+- * usb_ep_autoconfig - choose an endpoint matching the descriptor
++ * usb_ep_autoconfig_ss() - choose an endpoint matching the ep
++ * descriptor and ep companion descriptor
+  * @gadget: The device to which the endpoint must belong.
+  * @desc: Endpoint descriptor, with endpoint direction and transfer mode
+- *	initialized.  For periodic transfers, the maximum packet
+- *	size must also be initialized.  This is modified on success.
++ *    initialized.  For periodic transfers, the maximum packet
++ *    size must also be initialized.  This is modified on
++ *    success.
++ * @ep_comp: Endpoint companion descriptor, with the required
++ *    number of streams. Will be modified when the chosen EP
++ *    supports a different number of streams.
+  *
+- * By choosing an endpoint to use with the specified descriptor, this
+- * routine simplifies writing gadget drivers that work with multiple
+- * USB device controllers.  The endpoint would be passed later to
+- * usb_ep_enable(), along with some descriptor.
++ * This routine replaces the usb_ep_autoconfig when needed
++ * superspeed enhancments. If such enhancemnets are required,
++ * the FD should call usb_ep_autoconfig_ss directly and provide
++ * the additional ep_comp parameter.
++ *
++ * By choosing an endpoint to use with the specified descriptor,
++ * this routine simplifies writing gadget drivers that work with
++ * multiple USB device controllers.  The endpoint would be
++ * passed later to usb_ep_enable(), along with some descriptor.
+  *
+  * That second descriptor won't always be the same as the first one.
+  * For example, isochronous endpoints can be autoconfigured for high
+  * bandwidth, and then used in several lower bandwidth altsettings.
+  * Also, high and full speed descriptors will be different.
+  *
+- * Be sure to examine and test the results of autoconfiguration on your
+- * hardware.  This code may not make the best choices about how to use the
+- * USB controller, and it can't know all the restrictions that may apply.
+- * Some combinations of driver and hardware won't be able to autoconfigure.
++ * Be sure to examine and test the results of autoconfiguration
++ * on your hardware.  This code may not make the best choices
++ * about how to use the USB controller, and it can't know all
++ * the restrictions that may apply. Some combinations of driver
++ * and hardware won't be able to autoconfigure.
+  *
+  * On success, this returns an un-claimed usb_ep, and modifies the endpoint
+  * descriptor bEndpointAddress.  For bulk endpoints, the wMaxPacket value
+- * is initialized as if the endpoint were used at full speed.  To prevent
+- * the endpoint from being returned by a later autoconfig call, claim it
+- * by assigning ep->driver_data to some non-null value.
++ * is initialized as if the endpoint were used at full speed and
++ * the bmAttribute field in the ep companion descriptor is
++ * updated with the assigned number of streams if it is
++ * different from the original value. To prevent the endpoint
++ * from being returned by a later autoconfig call, claim it by
++ * assigning ep->driver_data to some non-null value.
+  *
+  * On failure, this returns a null endpoint descriptor.
+  */
+-struct usb_ep *usb_ep_autoconfig (
++struct usb_ep *usb_ep_autoconfig_ss(
+ 	struct usb_gadget		*gadget,
+-	struct usb_endpoint_descriptor	*desc
++	struct usb_endpoint_descriptor	*desc,
++	struct usb_ss_ep_comp_descriptor *ep_comp
+ )
+ {
+ 	struct usb_ep	*ep;
+@@ -252,23 +287,24 @@ struct usb_ep *usb_ep_autoconfig (
+ 	if (gadget_is_net2280 (gadget) && type == USB_ENDPOINT_XFER_INT) {
+ 		/* ep-e, ep-f are PIO with only 64 byte fifos */
+ 		ep = find_ep (gadget, "ep-e");
+-		if (ep && ep_matches (gadget, ep, desc))
++		if (ep && ep_matches(gadget, ep, desc, ep_comp))
+ 			return ep;
+ 		ep = find_ep (gadget, "ep-f");
+-		if (ep && ep_matches (gadget, ep, desc))
++		if (ep && ep_matches(gadget, ep, desc, ep_comp))
+ 			return ep;
+ 
+ 	} else if (gadget_is_goku (gadget)) {
+ 		if (USB_ENDPOINT_XFER_INT == type) {
+ 			/* single buffering is enough */
+-			ep = find_ep (gadget, "ep3-bulk");
+-			if (ep && ep_matches (gadget, ep, desc))
++			ep = find_ep(gadget, "ep3-bulk");
++			if (ep && ep_matches(gadget, ep, desc, ep_comp))
+ 				return ep;
+ 		} else if (USB_ENDPOINT_XFER_BULK == type
+ 				&& (USB_DIR_IN & desc->bEndpointAddress)) {
+ 			/* DMA may be available */
+-			ep = find_ep (gadget, "ep2-bulk");
+-			if (ep && ep_matches (gadget, ep, desc))
++			ep = find_ep(gadget, "ep2-bulk");
++			if (ep && ep_matches(gadget, ep, desc,
++					      ep_comp))
+ 				return ep;
+ 		}
+ 
+@@ -287,14 +323,14 @@ struct usb_ep *usb_ep_autoconfig (
+ 				ep = find_ep(gadget, "ep2out");
+ 		} else
+ 			ep = NULL;
+-		if (ep && ep_matches (gadget, ep, desc))
++		if (ep && ep_matches(gadget, ep, desc, ep_comp))
+ 			return ep;
+ #endif
+ 	}
+ 
+ 	/* Second, look at endpoints until an unclaimed one looks usable */
+ 	list_for_each_entry (ep, &gadget->ep_list, ep_list) {
+-		if (ep_matches (gadget, ep, desc))
++		if (ep_matches(gadget, ep, desc, ep_comp))
+ 			return ep;
+ 	}
+ 
+@@ -303,6 +339,46 @@ struct usb_ep *usb_ep_autoconfig (
+ }
+ 
+ /**
++ * usb_ep_autoconfig() - choose an endpoint matching the
++ * descriptor
++ * @gadget: The device to which the endpoint must belong.
++ * @desc: Endpoint descriptor, with endpoint direction and transfer mode
++ *	initialized.  For periodic transfers, the maximum packet
++ *	size must also be initialized.  This is modified on success.
++ *
++ * By choosing an endpoint to use with the specified descriptor, this
++ * routine simplifies writing gadget drivers that work with multiple
++ * USB device controllers.  The endpoint would be passed later to
++ * usb_ep_enable(), along with some descriptor.
++ *
++ * That second descriptor won't always be the same as the first one.
++ * For example, isochronous endpoints can be autoconfigured for high
++ * bandwidth, and then used in several lower bandwidth altsettings.
++ * Also, high and full speed descriptors will be different.
++ *
++ * Be sure to examine and test the results of autoconfiguration on your
++ * hardware.  This code may not make the best choices about how to use the
++ * USB controller, and it can't know all the restrictions that may apply.
++ * Some combinations of driver and hardware won't be able to autoconfigure.
++ *
++ * On success, this returns an un-claimed usb_ep, and modifies the endpoint
++ * descriptor bEndpointAddress.  For bulk endpoints, the wMaxPacket value
++ * is initialized as if the endpoint were used at full speed.  To prevent
++ * the endpoint from being returned by a later autoconfig call, claim it
++ * by assigning ep->driver_data to some non-null value.
++ *
++ * On failure, this returns a null endpoint descriptor.
++ */
++struct usb_ep *usb_ep_autoconfig(
++	struct usb_gadget		*gadget,
++	struct usb_endpoint_descriptor	*desc
++)
++{
++	return usb_ep_autoconfig_ss(gadget, desc, NULL);
++}
++
++
++/**
+  * usb_ep_autoconfig_reset - reset endpoint autoconfig state
+  * @gadget: device for which autoconfig state will be reset
+  *
+--- a/drivers/usb/gadget/f_loopback.c
++++ b/drivers/usb/gadget/f_loopback.c
+@@ -118,6 +118,57 @@ static struct usb_descriptor_header *hs_
+ 	NULL,
+ };
+ 
++/* super speed support: */
++
++static struct usb_endpoint_descriptor ss_loop_source_desc = {
++	.bLength =		USB_DT_ENDPOINT_SIZE,
++	.bDescriptorType =	USB_DT_ENDPOINT,
++
++	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
++	.wMaxPacketSize =	cpu_to_le16(1024),
++};
++
++struct usb_ss_ep_comp_descriptor ss_loop_source_comp_desc = {
++	.bLength =		USB_DT_SS_EP_COMP_SIZE,
++	.bDescriptorType =	USB_DT_SS_ENDPOINT_COMP,
++#ifdef CONFIG_PLX_LOOPHOST_TEST
++	.bMaxBurst =		3,
++#else
++	.bMaxBurst =		0,
++#endif
++	.bmAttributes =		0,
++	.wBytesPerInterval =	0,
++};
++
++static struct usb_endpoint_descriptor ss_loop_sink_desc = {
++	.bLength =		USB_DT_ENDPOINT_SIZE,
++	.bDescriptorType =	USB_DT_ENDPOINT,
++
++	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
++	.wMaxPacketSize =	cpu_to_le16(1024),
++};
++
++struct usb_ss_ep_comp_descriptor ss_loop_sink_comp_desc = {
++	.bLength =		USB_DT_SS_EP_COMP_SIZE,
++	.bDescriptorType =	USB_DT_SS_ENDPOINT_COMP,
++#ifdef CONFIG_PLX_LOOPHOST_TEST
++	.bMaxBurst =		3,
++#else
++	.bMaxBurst =		0,
++#endif
++	.bmAttributes =		0,
++	.wBytesPerInterval =	0,
++};
++
++static struct usb_descriptor_header *ss_loopback_descs[] = {
++	(struct usb_descriptor_header *) &loopback_intf,
++	(struct usb_descriptor_header *) &ss_loop_source_desc,
++	(struct usb_descriptor_header *) &ss_loop_source_comp_desc,
++	(struct usb_descriptor_header *) &ss_loop_sink_desc,
++	(struct usb_descriptor_header *) &ss_loop_sink_comp_desc,
++	NULL,
++};
++
+ /* function-specific strings: */
+ 
+ static struct usb_string strings_loopback[] = {
+@@ -175,8 +226,18 @@ autoconf_fail:
+ 		f->hs_descriptors = hs_loopback_descs;
+ 	}
+ 
++	/* support super speed hardware */
++	if (gadget_is_superspeed(c->cdev->gadget)) {
++		ss_loop_source_desc.bEndpointAddress =
++				fs_loop_source_desc.bEndpointAddress;
++		ss_loop_sink_desc.bEndpointAddress =
++				fs_loop_sink_desc.bEndpointAddress;
++		f->ss_descriptors = ss_loopback_descs;
++	}
++
+ 	DBG(cdev, "%s speed %s: IN/%s, OUT/%s\n",
+-			gadget_is_dualspeed(c->cdev->gadget) ? "dual" : "full",
++	    (gadget_is_superspeed(c->cdev->gadget) ? "super" :
++	     (gadget_is_dualspeed(c->cdev->gadget) ? "dual" : "full")),
+ 			f->name, loop->in_ep->name, loop->out_ep->name);
+ 	return 0;
+ }
+@@ -198,7 +259,13 @@ static void loopback_complete(struct usb
+ 	case 0:				/* normal completion? */
+ 		if (ep == loop->out_ep) {
+ 			/* loop this OUT packet back IN to the host */
++#ifdef CONFIG_PLX_LOOPHOST_TEST
++			req->zero = (req->actual < req->length) |
++				((req->actual == req->length) &&
++				(req->length % ep->maxpacket == 0));
++#else
+ 			req->zero = (req->actual < req->length);
++#endif
+ 			req->length = req->actual;
+ 			status = usb_ep_queue(loop->in_ep, req, GFP_ATOMIC);
+ 			if (status == 0)
+@@ -250,26 +317,26 @@ static int
+ enable_loopback(struct usb_composite_dev *cdev, struct f_loopback *loop)
+ {
+ 	int					result = 0;
+-	const struct usb_endpoint_descriptor	*src, *sink;
+ 	struct usb_ep				*ep;
+ 	struct usb_request			*req;
+ 	unsigned				i;
+ 
+-	src = ep_choose(cdev->gadget,
+-			&hs_loop_source_desc, &fs_loop_source_desc);
+-	sink = ep_choose(cdev->gadget,
+-			&hs_loop_sink_desc, &fs_loop_sink_desc);
+-
+ 	/* one endpoint writes data back IN to the host */
+ 	ep = loop->in_ep;
+-	result = usb_ep_enable(ep, src);
++	result = config_ep_by_speed(cdev->gadget, &(loop->function), ep);
++	if (result)
++		return result;
++	result = usb_ep_enable(ep);
+ 	if (result < 0)
+ 		return result;
+ 	ep->driver_data = loop;
+ 
+ 	/* one endpoint just reads OUT packets */
+ 	ep = loop->out_ep;
+-	result = usb_ep_enable(ep, sink);
++	result = config_ep_by_speed(cdev->gadget, &(loop->function), ep);
++	if (result)
++		goto fail0;
++	result = usb_ep_enable(ep);
+ 	if (result < 0) {
+ fail0:
+ 		ep = loop->in_ep;
+--- a/drivers/usb/gadget/f_sourcesink.c
++++ b/drivers/usb/gadget/f_sourcesink.c
+@@ -131,6 +131,49 @@ static struct usb_descriptor_header *hs_
+ 	NULL,
+ };
+ 
++/* super speed support: */
++
++static struct usb_endpoint_descriptor ss_source_desc = {
++	.bLength =		USB_DT_ENDPOINT_SIZE,
++	.bDescriptorType =	USB_DT_ENDPOINT,
++
++	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
++	.wMaxPacketSize =	cpu_to_le16(1024),
++};
++
++struct usb_ss_ep_comp_descriptor ss_source_comp_desc = {
++	.bLength =		USB_DT_SS_EP_COMP_SIZE,
++	.bDescriptorType =	USB_DT_SS_ENDPOINT_COMP,
++	.bMaxBurst =		0,
++	.bmAttributes =		0,
++	.wBytesPerInterval =	0,
++};
++
++static struct usb_endpoint_descriptor ss_sink_desc = {
++	.bLength =		USB_DT_ENDPOINT_SIZE,
++	.bDescriptorType =	USB_DT_ENDPOINT,
++
++	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
++	.wMaxPacketSize =	cpu_to_le16(1024),
++};
++
++struct usb_ss_ep_comp_descriptor ss_sink_comp_desc = {
++	.bLength =		USB_DT_SS_EP_COMP_SIZE,
++	.bDescriptorType =	USB_DT_SS_ENDPOINT_COMP,
++	.bMaxBurst =		0,
++	.bmAttributes =		0,
++	.wBytesPerInterval =	0,
++};
++
++static struct usb_descriptor_header *ss_source_sink_descs[] = {
++	(struct usb_descriptor_header *) &source_sink_intf,
++	(struct usb_descriptor_header *) &ss_source_desc,
++	(struct usb_descriptor_header *) &ss_source_comp_desc,
++	(struct usb_descriptor_header *) &ss_sink_desc,
++	(struct usb_descriptor_header *) &ss_sink_comp_desc,
++	NULL,
++};
++
+ /* function-specific strings: */
+ 
+ static struct usb_string strings_sourcesink[] = {
+@@ -187,8 +230,18 @@ autoconf_fail:
+ 		f->hs_descriptors = hs_source_sink_descs;
+ 	}
+ 
++	/* support super speed hardware */
++	if (gadget_is_superspeed(c->cdev->gadget)) {
++		ss_source_desc.bEndpointAddress =
++				fs_source_desc.bEndpointAddress;
++		ss_sink_desc.bEndpointAddress =
++				fs_sink_desc.bEndpointAddress;
++		f->ss_descriptors = ss_source_sink_descs;
++	}
++
+ 	DBG(cdev, "%s speed %s: IN/%s, OUT/%s\n",
+-			gadget_is_dualspeed(c->cdev->gadget) ? "dual" : "full",
++	    (gadget_is_superspeed(c->cdev->gadget) ? "super" :
++	     (gadget_is_dualspeed(c->cdev->gadget) ? "dual" : "full")),
+ 			f->name, ss->in_ep->name, ss->out_ep->name);
+ 	return 0;
+ }
+@@ -343,15 +396,14 @@ static int
+ enable_source_sink(struct usb_composite_dev *cdev, struct f_sourcesink *ss)
+ {
+ 	int					result = 0;
+-	const struct usb_endpoint_descriptor	*src, *sink;
+ 	struct usb_ep				*ep;
+ 
+-	src = ep_choose(cdev->gadget, &hs_source_desc, &fs_source_desc);
+-	sink = ep_choose(cdev->gadget, &hs_sink_desc, &fs_sink_desc);
+-
+ 	/* one endpoint writes (sources) zeroes IN (to the host) */
+ 	ep = ss->in_ep;
+-	result = usb_ep_enable(ep, src);
++	result = config_ep_by_speed(cdev->gadget, &(ss->function), ep);
++	if (result)
++		return result;
++	result = usb_ep_enable(ep);
+ 	if (result < 0)
+ 		return result;
+ 	ep->driver_data = ss;
+@@ -367,7 +419,10 @@ fail:
+ 
+ 	/* one endpoint reads (sinks) anything OUT (from the host) */
+ 	ep = ss->out_ep;
+-	result = usb_ep_enable(ep, sink);
++	result = config_ep_by_speed(cdev->gadget, &(ss->function), ep);
++	if (result)
++		goto fail;
++	result = usb_ep_enable(ep);
+ 	if (result < 0)
+ 		goto fail;
+ 	ep->driver_data = ss;
+@@ -435,6 +490,8 @@ static int sourcesink_setup(struct usb_c
+ 	u16			w_value = le16_to_cpu(ctrl->wValue);
+ 	u16			w_length = le16_to_cpu(ctrl->wLength);
+ 
++	req->length = USB_BUFSIZ;
++
+ 	/* composite driver infrastructure handles everything except
+ 	 * the two control test requests.
+ 	 */
+--- a/drivers/usb/gadget/f_subset.c
++++ b/drivers/usb/gadget/f_subset.c
+@@ -57,18 +57,10 @@
+  * caring about specific product and vendor IDs.
+  */
+ 
+-struct geth_descs {
+-	struct usb_endpoint_descriptor	*in;
+-	struct usb_endpoint_descriptor	*out;
+-};
+-
+ struct f_gether {
+ 	struct gether			port;
+ 
+ 	char				ethaddr[14];
+-
+-	struct geth_descs		fs;
+-	struct geth_descs		hs;
+ };
+ 
+ static inline struct f_gether *func_to_geth(struct usb_function *f)
+@@ -209,6 +201,46 @@ static struct usb_descriptor_header *hs_
+ 	NULL,
+ };
+ 
++/* super speed support: */
++
++static struct usb_endpoint_descriptor ss_subset_in_desc __initdata = {
++	.bLength =		USB_DT_ENDPOINT_SIZE,
++	.bDescriptorType =	USB_DT_ENDPOINT,
++
++	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
++	.wMaxPacketSize =	cpu_to_le16(1024),
++};
++
++static struct usb_endpoint_descriptor ss_subset_out_desc __initdata = {
++	.bLength =		USB_DT_ENDPOINT_SIZE,
++	.bDescriptorType =	USB_DT_ENDPOINT,
++
++	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
++	.wMaxPacketSize =	cpu_to_le16(1024),
++};
++
++static struct usb_ss_ep_comp_descriptor ss_subset_bulk_comp_desc __initdata = {
++	.bLength =		sizeof ss_subset_bulk_comp_desc,
++	.bDescriptorType =	USB_DT_SS_ENDPOINT_COMP,
++
++	/* the following 2 values can be tweaked if necessary */
++	/* .bMaxBurst =		0, */
++	/* .bmAttributes =	0, */
++};
++
++static struct usb_descriptor_header *ss_eth_function[] __initdata = {
++	(struct usb_descriptor_header *) &subset_data_intf,
++	(struct usb_descriptor_header *) &mdlm_header_desc,
++	(struct usb_descriptor_header *) &mdlm_desc,
++	(struct usb_descriptor_header *) &mdlm_detail_desc,
++	(struct usb_descriptor_header *) &ether_desc,
++	(struct usb_descriptor_header *) &ss_subset_in_desc,
++	(struct usb_descriptor_header *) &ss_subset_bulk_comp_desc,
++	(struct usb_descriptor_header *) &ss_subset_out_desc,
++	(struct usb_descriptor_header *) &ss_subset_bulk_comp_desc,
++	NULL,
++};
++
+ /* string descriptors: */
+ 
+ static struct usb_string geth_string_defs[] = {
+@@ -243,10 +275,12 @@ static int geth_set_alt(struct usb_funct
+ 	}
+ 
+ 	DBG(cdev, "init + activate cdc subset\n");
+-	geth->port.in = ep_choose(cdev->gadget,
+-			geth->hs.in, geth->fs.in);
+-	geth->port.out = ep_choose(cdev->gadget,
+-			geth->hs.out, geth->fs.out);
++	if (config_ep_by_speed(cdev->gadget, f, geth->port.in_ep) ||
++	    config_ep_by_speed(cdev->gadget, f, geth->port.out_ep)) {
++		geth->port.in_ep->desc = NULL;
++		geth->port.out_ep->desc = NULL;
++		return -EINVAL;
++	}
+ 
+ 	net = gether_connect(&geth->port);
+ 	return IS_ERR(net) ? PTR_ERR(net) : 0;
+@@ -296,12 +330,8 @@ geth_bind(struct usb_configuration *c, s
+ 
+ 	/* copy descriptors, and track endpoint copies */
+ 	f->descriptors = usb_copy_descriptors(fs_eth_function);
+-
+-	geth->fs.in = usb_find_endpoint(fs_eth_function,
+-			f->descriptors, &fs_subset_in_desc);
+-	geth->fs.out = usb_find_endpoint(fs_eth_function,
+-			f->descriptors, &fs_subset_out_desc);
+-
++	if (!f->descriptors)
++		goto fail;
+ 
+ 	/* support all relevant hardware speeds... we expect that when
+ 	 * hardware is dual speed, all bulk-capable endpoints work at
+@@ -315,11 +345,20 @@ geth_bind(struct usb_configuration *c, s
+ 
+ 		/* copy descriptors, and track endpoint copies */
+ 		f->hs_descriptors = usb_copy_descriptors(hs_eth_function);
++		if (!f->hs_descriptors)
++			goto fail;
++	}
+ 
+-		geth->hs.in = usb_find_endpoint(hs_eth_function,
+-				f->hs_descriptors, &hs_subset_in_desc);
+-		geth->hs.out = usb_find_endpoint(hs_eth_function,
+-				f->hs_descriptors, &hs_subset_out_desc);
++	if (gadget_is_superspeed(c->cdev->gadget)) {
++		ss_subset_in_desc.bEndpointAddress =
++				fs_subset_in_desc.bEndpointAddress;
++		ss_subset_out_desc.bEndpointAddress =
++				fs_subset_out_desc.bEndpointAddress;
++
++		/* copy descriptors, and track endpoint copies */
++		f->ss_descriptors = usb_copy_descriptors(ss_eth_function);
++		if (!f->ss_descriptors)
++			goto fail;
+ 	}
+ 
+ 	/* NOTE:  all that is done without knowing or caring about
+@@ -328,15 +367,21 @@ geth_bind(struct usb_configuration *c, s
+ 	 */
+ 
+ 	DBG(cdev, "CDC Subset: %s speed IN/%s OUT/%s\n",
++			gadget_is_superspeed(c->cdev->gadget) ? "super" :
+ 			gadget_is_dualspeed(c->cdev->gadget) ? "dual" : "full",
+ 			geth->port.in_ep->name, geth->port.out_ep->name);
+ 	return 0;
+ 
+ fail:
++	if (f->descriptors)
++		usb_free_descriptors(f->descriptors);
++	if (f->hs_descriptors)
++		usb_free_descriptors(f->hs_descriptors);
++
+ 	/* we might as well release our claims on endpoints */
+-	if (geth->port.out)
++	if (geth->port.out_ep->desc)
+ 		geth->port.out_ep->driver_data = NULL;
+-	if (geth->port.in)
++	if (geth->port.in_ep->desc)
+ 		geth->port.in_ep->driver_data = NULL;
+ 
+ 	ERROR(cdev, "%s: can't bind, err %d\n", f->name, status);
+@@ -347,6 +392,8 @@ fail:
+ static void
+ geth_unbind(struct usb_configuration *c, struct usb_function *f)
+ {
++	if (gadget_is_superspeed(c->cdev->gadget))
++		usb_free_descriptors(f->ss_descriptors);
+ 	if (gadget_is_dualspeed(c->cdev->gadget))
+ 		usb_free_descriptors(f->hs_descriptors);
+ 	usb_free_descriptors(f->descriptors);
+--- a/drivers/usb/gadget/mass_storage.c
++++ b/drivers/usb/gadget/mass_storage.c
+@@ -169,6 +169,7 @@ static struct usb_composite_driver msg_d
+ 	.name		= "g_mass_storage",
+ 	.dev		= &msg_device_desc,
+ 	.iProduct	= DRIVER_DESC,
++	.max_speed	= USB_SPEED_SUPER,
+ 	.needs_serial	= 1,
+ };
+ 
+--- a/drivers/usb/gadget/storage_common.c
++++ b/drivers/usb/gadget/storage_common.c
+@@ -70,7 +70,6 @@
+ 
+ /*-------------------------------------------------------------------------*/
+ 
+-
+ #ifndef DEBUG
+ #undef VERBOSE_DEBUG
+ #undef DUMP_MSGS
+@@ -493,8 +492,74 @@ static struct usb_descriptor_header *fsg
+ 	NULL,
+ };
+ 
++/* super speed */
++static struct usb_endpoint_descriptor
++fsg_ss_bulk_in_desc = {
++	.bLength =		USB_DT_ENDPOINT_SIZE,
++	.bDescriptorType =	USB_DT_ENDPOINT,
++
++	/* bEndpointAddress copied from fs_bulk_in_desc during fsg_bind() */
++	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
++	.wMaxPacketSize =	cpu_to_le16(1024),
++};
++
++static struct usb_endpoint_descriptor
++fsg_ss_bulk_out_desc = {
++	.bLength =		USB_DT_ENDPOINT_SIZE,
++	.bDescriptorType =	USB_DT_ENDPOINT,
++
++	/* bEndpointAddress copied from fs_bulk_out_desc during fsg_bind() */
++	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
++	.wMaxPacketSize =	cpu_to_le16(1024),
++};
++
++struct usb_ss_ep_comp_descriptor fsg_ss_comp_desc = {
++	.bLength =		USB_DT_SS_EP_COMP_SIZE,
++	.bDescriptorType =	USB_DT_SS_ENDPOINT_COMP,
++	.bMaxBurst =		0,
++	.bmAttributes =		0,
++	.wBytesPerInterval =	0,
++};
++
++#ifndef FSG_NO_INTR_EP
++
++static struct usb_endpoint_descriptor
++fsg_ss_intr_in_desc = {
++	.bLength =		USB_DT_ENDPOINT_SIZE,
++	.bDescriptorType =	USB_DT_ENDPOINT,
++
++	/* bEndpointAddress copied from fs_intr_in_desc during fsg_bind() */
++	.bmAttributes =		USB_ENDPOINT_XFER_INT,
++	.wMaxPacketSize =	cpu_to_le16(2),
++	.bInterval =		9,	/* 2**(9-1) = 256 uframes -> 32 ms */
++};
++
++#ifndef FSG_NO_OTG
++#  define FSG_SS_FUNCTION_PRE_EP_ENTRIES	2
++#else
++#  define FSG_SS_FUNCTION_PRE_EP_ENTRIES	1
++#endif
++
++#endif
++
++static struct usb_descriptor_header *fsg_ss_function[] = {
++#ifndef FSG_NO_OTG
++	(struct usb_descriptor_header *) &fsg_otg_desc,
++#endif
++	(struct usb_descriptor_header *) &fsg_intf_desc,
++	(struct usb_descriptor_header *) &fsg_ss_bulk_in_desc,
++	(struct usb_descriptor_header *) &fsg_ss_comp_desc,
++	(struct usb_descriptor_header *) &fsg_ss_bulk_out_desc,
++	(struct usb_descriptor_header *) &fsg_ss_comp_desc,
++#ifndef FSG_NO_INTR_EP
++	(struct usb_descriptor_header *) &fsg_ss_intr_in_desc,
++	(struct usb_descriptor_header *) &fsg_ss_comp_desc,
++#endif
++	NULL,
++};
++
+ /* Maxpacket and other transfer characteristics vary by speed. */
+-static struct usb_endpoint_descriptor *
++static __maybe_unused struct usb_endpoint_descriptor *
+ fsg_ep_desc(struct usb_gadget *g, struct usb_endpoint_descriptor *fs,
+ 		struct usb_endpoint_descriptor *hs)
+ {
+--- a/drivers/usb/gadget/u_ether.c
++++ b/drivers/usb/gadget/u_ether.c
+@@ -97,16 +97,17 @@ struct eth_dev {
+ 
+ static unsigned qmult = 5;
+ module_param(qmult, uint, S_IRUGO|S_IWUSR);
+-MODULE_PARM_DESC(qmult, "queue length multiplier at high speed");
++MODULE_PARM_DESC(qmult, "queue length multiplier at high/super speed");
+ 
+ #else	/* full speed (low speed doesn't do bulk) */
+ #define qmult		1
+ #endif
+ 
+-/* for dual-speed hardware, use deeper queues at highspeed */
++/* for dual-speed hardware, use deeper queues at high/super speed */
+ static inline int qlen(struct usb_gadget *gadget)
+ {
+-	if (gadget_is_dualspeed(gadget) && gadget->speed == USB_SPEED_HIGH)
++	if (gadget_is_dualspeed(gadget) && (gadget->speed == USB_SPEED_HIGH ||
++					    gadget->speed == USB_SPEED_SUPER))
+ 		return qmult * DEFAULT_QLEN;
+ 	else
+ 		return DEFAULT_QLEN;
+@@ -598,9 +599,10 @@ static netdev_tx_t eth_start_xmit(struct
+ 
+ 	req->length = length;
+ 
+-	/* throttle highspeed IRQ rate back slightly */
++	/* throttle high/super speed IRQ rate back slightly */
+ 	if (gadget_is_dualspeed(dev->gadget))
+-		req->no_interrupt = (dev->gadget->speed == USB_SPEED_HIGH)
++		req->no_interrupt = (dev->gadget->speed == USB_SPEED_HIGH ||
++				     dev->gadget->speed == USB_SPEED_SUPER)
+ 			? ((atomic_read(&dev->tx_qlen) % qmult) != 0)
+ 			: 0;
+ 
+@@ -693,8 +695,8 @@ static int eth_stop(struct net_device *n
+ 		usb_ep_disable(link->out_ep);
+ 		if (netif_carrier_ok(net)) {
+ 			DBG(dev, "host still using in/out endpoints\n");
+-			usb_ep_enable(link->in_ep, link->in);
+-			usb_ep_enable(link->out_ep, link->out);
++			usb_ep_enable(link->in_ep);
++			usb_ep_enable(link->out_ep);
+ 		}
+ 	}
+ 	spin_unlock_irqrestore(&dev->lock, flags);
+@@ -871,7 +873,7 @@ struct net_device *gether_connect(struct
+ 		return ERR_PTR(-EINVAL);
+ 
+ 	link->in_ep->driver_data = dev;
+-	result = usb_ep_enable(link->in_ep, link->in);
++	result = usb_ep_enable(link->in_ep);
+ 	if (result != 0) {
+ 		DBG(dev, "enable %s --> %d\n",
+ 			link->in_ep->name, result);
+@@ -879,7 +881,7 @@ struct net_device *gether_connect(struct
+ 	}
+ 
+ 	link->out_ep->driver_data = dev;
+-	result = usb_ep_enable(link->out_ep, link->out);
++	result = usb_ep_enable(link->out_ep);
+ 	if (result != 0) {
+ 		DBG(dev, "enable %s --> %d\n",
+ 			link->out_ep->name, result);
+@@ -969,7 +971,7 @@ void gether_disconnect(struct gether *li
+ 	}
+ 	spin_unlock(&dev->req_lock);
+ 	link->in_ep->driver_data = NULL;
+-	link->in = NULL;
++	link->in_ep->desc = NULL;
+ 
+ 	usb_ep_disable(link->out_ep);
+ 	spin_lock(&dev->req_lock);
+@@ -984,7 +986,7 @@ void gether_disconnect(struct gether *li
+ 	}
+ 	spin_unlock(&dev->req_lock);
+ 	link->out_ep->driver_data = NULL;
+-	link->out = NULL;
++	link->out_ep->desc = NULL;
+ 
+ 	/* finish forgetting about this USB link episode */
+ 	dev->header_len = 0;
+--- a/drivers/usb/gadget/u_ether.h
++++ b/drivers/usb/gadget/u_ether.h
+@@ -53,8 +53,8 @@ struct gether {
+ 	struct usb_ep			*out_ep;
+ 
+ 	/* descriptors match device speed at gether_connect() time */
+-	struct usb_endpoint_descriptor	*in;
+-	struct usb_endpoint_descriptor	*out;
++	//struct usb_endpoint_descriptor	*in;
++	//struct usb_endpoint_descriptor	*out;
+ 
+ 	bool				is_zlp_ok;
+ 
+--- /dev/null
++++ b/drivers/usb/gadget/udc-core.c
+@@ -0,0 +1,484 @@
++/**
++ * udc.c - Core UDC Framework
++ *
++ * Copyright (C) 2010 Texas Instruments
++ * Author: Felipe Balbi <balbi@ti.com>
++ *
++ * This program is free software: you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2  of
++ * the License as published by the Free Software Foundation.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
++ */
++
++#include <linux/kernel.h>
++#include <linux/module.h>
++#include <linux/device.h>
++#include <linux/list.h>
++#include <linux/err.h>
++
++#include <linux/usb/ch9.h>
++#include <linux/usb/gadget.h>
++
++/**
++ * struct usb_udc - describes one usb device controller
++ * @driver - the gadget driver pointer. For use by the class code
++ * @dev - the child device to the actual controller
++ * @gadget - the gadget. For use by the class code
++ * @list - for use by the udc class driver
++ *
++ * This represents the internal data structure which is used by the UDC-class
++ * to hold information about udc driver and gadget together.
++ */
++struct usb_udc {
++	struct usb_gadget_driver	*driver;
++	struct usb_gadget		*gadget;
++	struct device			dev;
++	struct list_head		list;
++};
++
++static struct class *udc_class;
++static LIST_HEAD(udc_list);
++static DEFINE_MUTEX(udc_lock);
++
++/* ------------------------------------------------------------------------- */
++
++/**
++ * usb_gadget_start - tells usb device controller to start up
++ * @gadget: The gadget we want to get started
++ * @driver: The driver we want to bind to @gadget
++ * @bind: The bind function for @driver
++ *
++ * This call is issued by the UDC Class driver when it's about
++ * to register a gadget driver to the device controller, before
++ * calling gadget driver's bind() method.
++ *
++ * It allows the controller to be powered off until strictly
++ * necessary to have it powered on.
++ *
++ * Returns zero on success, else negative errno.
++ */
++static inline int usb_gadget_start(struct usb_gadget *gadget,
++		struct usb_gadget_driver *driver,
++		int (*bind)(struct usb_gadget *))
++{
++	return gadget->ops->start(driver, bind);
++}
++
++/**
++ * usb_gadget_udc_start - tells usb device controller to start up
++ * @gadget: The gadget we want to get started
++ * @driver: The driver we want to bind to @gadget
++ *
++ * This call is issued by the UDC Class driver when it's about
++ * to register a gadget driver to the device controller, before
++ * calling gadget driver's bind() method.
++ *
++ * It allows the controller to be powered off until strictly
++ * necessary to have it powered on.
++ *
++ * Returns zero on success, else negative errno.
++ */
++static inline int usb_gadget_udc_start(struct usb_gadget *gadget,
++		struct usb_gadget_driver *driver)
++{
++	return gadget->ops->udc_start(gadget, driver);
++}
++
++/**
++ * usb_gadget_stop - tells usb device controller we don't need it anymore
++ * @gadget: The device we want to stop activity
++ * @driver: The driver to unbind from @gadget
++ *
++ * This call is issued by the UDC Class driver after calling
++ * gadget driver's unbind() method.
++ *
++ * The details are implementation specific, but it can go as
++ * far as powering off UDC completely and disable its data
++ * line pullups.
++ */
++static inline void usb_gadget_stop(struct usb_gadget *gadget,
++		struct usb_gadget_driver *driver)
++{
++	gadget->ops->stop(driver);
++}
++
++/**
++ * usb_gadget_udc_stop - tells usb device controller we don't need it anymore
++ * @gadget: The device we want to stop activity
++ * @driver: The driver to unbind from @gadget
++ *
++ * This call is issued by the UDC Class driver after calling
++ * gadget driver's unbind() method.
++ *
++ * The details are implementation specific, but it can go as
++ * far as powering off UDC completely and disable its data
++ * line pullups.
++ */
++static inline void usb_gadget_udc_stop(struct usb_gadget *gadget,
++		struct usb_gadget_driver *driver)
++{
++	gadget->ops->udc_stop(gadget, driver);
++}
++
++/**
++ * usb_udc_release - release the usb_udc struct
++ * @dev: the dev member within usb_udc
++ *
++ * This is called by driver's core in order to free memory once the last
++ * reference is released.
++ */
++static void usb_udc_release(struct device *dev)
++{
++	struct usb_udc *udc;
++
++	udc = container_of(dev, struct usb_udc, dev);
++	dev_dbg(dev, "releasing '%s'\n", dev_name(dev));
++	kfree(udc);
++}
++
++static const struct attribute_group *usb_udc_attr_groups[];
++/**
++ * usb_add_gadget_udc - adds a new gadget to the udc class driver list
++ * @parent: the parent device to this udc. Usually the controller
++ * driver's device.
++ * @gadget: the gadget to be added to the list
++ *
++ * Returns zero on success, negative errno otherwise.
++ */
++int usb_add_gadget_udc(struct device *parent, struct usb_gadget *gadget)
++{
++	struct usb_udc		*udc;
++	int			ret = -ENOMEM;
++
++	udc = kzalloc(sizeof(*udc), GFP_KERNEL);
++	if (!udc)
++		goto err1;
++
++	device_initialize(&udc->dev);
++	udc->dev.release = usb_udc_release;
++	udc->dev.class = udc_class;
++	udc->dev.groups = usb_udc_attr_groups;
++	udc->dev.parent = parent;
++	ret = dev_set_name(&udc->dev, "%s", kobject_name(&parent->kobj));
++	if (ret)
++		goto err2;
++
++	udc->gadget = gadget;
++
++	mutex_lock(&udc_lock);
++	list_add_tail(&udc->list, &udc_list);
++
++	ret = device_add(&udc->dev);
++	if (ret)
++		goto err3;
++
++	mutex_unlock(&udc_lock);
++
++	return 0;
++err3:
++	list_del(&udc->list);
++	mutex_unlock(&udc_lock);
++
++err2:
++	put_device(&udc->dev);
++
++err1:
++	return ret;
++}
++EXPORT_SYMBOL_GPL(usb_add_gadget_udc);
++
++static int udc_is_newstyle(struct usb_udc *udc)
++{
++	if (udc->gadget->ops->udc_start && udc->gadget->ops->udc_stop)
++		return 1;
++	return 0;
++}
++
++
++static void usb_gadget_remove_driver(struct usb_udc *udc)
++{
++	dev_dbg(&udc->dev, "unregistering UDC driver [%s]\n",
++			udc->gadget->name);
++
++	kobject_uevent(&udc->dev.kobj, KOBJ_CHANGE);
++
++	if (udc_is_newstyle(udc)) {
++		usb_gadget_disconnect(udc->gadget);
++		udc->driver->unbind(udc->gadget);
++		usb_gadget_udc_stop(udc->gadget, udc->driver);
++
++	} else {
++		usb_gadget_stop(udc->gadget, udc->driver);
++	}
++
++	udc->driver = NULL;
++	udc->dev.driver = NULL;
++}
++
++/**
++ * usb_del_gadget_udc - deletes @udc from udc_list
++ * @gadget: the gadget to be removed.
++ *
++ * This, will call usb_gadget_unregister_driver() if
++ * the @udc is still busy.
++ */
++void usb_del_gadget_udc(struct usb_gadget *gadget)
++{
++	struct usb_udc		*udc = NULL;
++
++	mutex_lock(&udc_lock);
++	list_for_each_entry(udc, &udc_list, list)
++		if (udc->gadget == gadget)
++			goto found;
++
++	dev_err(gadget->dev.parent, "gadget not registered.\n");
++	mutex_unlock(&udc_lock);
++
++	return;
++
++found:
++	dev_vdbg(gadget->dev.parent, "unregistering gadget\n");
++
++	list_del(&udc->list);
++	mutex_unlock(&udc_lock);
++
++	if (udc->driver)
++		usb_gadget_remove_driver(udc);
++
++	kobject_uevent(&udc->dev.kobj, KOBJ_REMOVE);
++	device_unregister(&udc->dev);
++}
++EXPORT_SYMBOL_GPL(usb_del_gadget_udc);
++
++/* ------------------------------------------------------------------------- */
++
++int usb_gadget_probe_driver(struct usb_gadget_driver *driver,
++		int (*bind)(struct usb_gadget *))
++{
++	struct usb_udc		*udc = NULL;
++	int			ret;
++
++	if (!driver || !bind || !driver->setup)
++		return -EINVAL;
++
++	mutex_lock(&udc_lock);
++	list_for_each_entry(udc, &udc_list, list) {
++		/* For now we take the first one */
++		if (!udc->driver)
++			goto found;
++	}
++
++	pr_debug("couldn't find an available UDC\n");
++	mutex_unlock(&udc_lock);
++	return -ENODEV;
++
++found:
++	dev_dbg(&udc->dev, "registering UDC driver [%s]\n",
++			driver->function);
++
++	udc->driver = driver;
++	udc->dev.driver = &driver->driver;
++
++	if (udc_is_newstyle(udc)) {
++		ret = bind(udc->gadget);
++		if (ret)
++			goto err1;
++		ret = usb_gadget_udc_start(udc->gadget, driver);
++		if (ret) {
++			driver->unbind(udc->gadget);
++			goto err1;
++		}
++		usb_gadget_connect(udc->gadget);
++	} else {
++
++		ret = usb_gadget_start(udc->gadget, driver, bind);
++		if (ret)
++			goto err1;
++
++	}
++
++	kobject_uevent(&udc->dev.kobj, KOBJ_CHANGE);
++	mutex_unlock(&udc_lock);
++	return 0;
++
++err1:
++	dev_err(&udc->dev, "failed to start %s: %d\n",
++			udc->driver->function, ret);
++	udc->driver = NULL;
++	udc->dev.driver = NULL;
++	mutex_unlock(&udc_lock);
++	return ret;
++}
++EXPORT_SYMBOL_GPL(usb_gadget_probe_driver);
++
++int usb_gadget_unregister_driver(struct usb_gadget_driver *driver)
++{
++	struct usb_udc		*udc = NULL;
++	int			ret = -ENODEV;
++
++	if (!driver || !driver->unbind)
++		return -EINVAL;
++
++	mutex_lock(&udc_lock);
++	list_for_each_entry(udc, &udc_list, list)
++		if (udc->driver == driver) {
++			usb_gadget_remove_driver(udc);
++			ret = 0;
++			break;
++		}
++
++	mutex_unlock(&udc_lock);
++	return ret;
++}
++EXPORT_SYMBOL_GPL(usb_gadget_unregister_driver);
++
++/* ------------------------------------------------------------------------- */
++
++static ssize_t usb_udc_srp_store(struct device *dev,
++		struct device_attribute *attr, const char *buf, size_t n)
++{
++	struct usb_udc		*udc = dev_get_drvdata(dev);
++
++	if (sysfs_streq(buf, "1"))
++		usb_gadget_wakeup(udc->gadget);
++
++	return n;
++}
++static DEVICE_ATTR(srp, S_IWUSR, NULL, usb_udc_srp_store);
++
++static ssize_t usb_udc_softconn_store(struct device *dev,
++		struct device_attribute *attr, const char *buf, size_t n)
++{
++	struct usb_udc		*udc = dev_get_drvdata(dev);
++
++	if (sysfs_streq(buf, "connect")) {
++		usb_gadget_connect(udc->gadget);
++	} else if (sysfs_streq(buf, "disconnect")) {
++		usb_gadget_disconnect(udc->gadget);
++	} else {
++		dev_err(dev, "unsupported command '%s'\n", buf);
++		return -EINVAL;
++	}
++
++	return n;
++}
++static DEVICE_ATTR(soft_connect, S_IWUSR, NULL, usb_udc_softconn_store);
++
++static ssize_t usb_udc_speed_show(struct device *dev,
++		struct device_attribute *attr, char *buf)
++{
++	struct usb_udc		*udc = container_of(dev, struct usb_udc, dev);
++	struct usb_gadget	*gadget = udc->gadget;
++
++	switch (gadget->speed) {
++	case USB_SPEED_LOW:
++		return snprintf(buf, PAGE_SIZE, "low-speed\n");
++	case USB_SPEED_FULL:
++		return snprintf(buf, PAGE_SIZE, "full-speed\n");
++	case USB_SPEED_HIGH:
++		return snprintf(buf, PAGE_SIZE, "high-speed\n");
++	case USB_SPEED_WIRELESS:
++		return snprintf(buf, PAGE_SIZE, "wireless\n");
++	case USB_SPEED_SUPER:
++		return snprintf(buf, PAGE_SIZE, "super-speed\n");
++	case USB_SPEED_UNKNOWN:	/* FALLTHROUGH */
++	default:
++		return snprintf(buf, PAGE_SIZE, "UNKNOWN\n");
++	}
++}
++static DEVICE_ATTR(speed, S_IRUSR, usb_udc_speed_show, NULL);
++
++#define USB_UDC_ATTR(name)					\
++ssize_t usb_udc_##name##_show(struct device *dev,		\
++		struct device_attribute *attr, char *buf)	\
++{								\
++	struct usb_udc		*udc = container_of(dev, struct usb_udc, dev); \
++	struct usb_gadget	*gadget = udc->gadget;		\
++								\
++	return snprintf(buf, PAGE_SIZE, "%d\n", gadget->name);	\
++}								\
++static DEVICE_ATTR(name, S_IRUSR, usb_udc_##name##_show, NULL)
++
++static USB_UDC_ATTR(is_dualspeed);
++static USB_UDC_ATTR(is_otg);
++static USB_UDC_ATTR(is_a_peripheral);
++static USB_UDC_ATTR(b_hnp_enable);
++static USB_UDC_ATTR(a_hnp_support);
++static USB_UDC_ATTR(a_alt_hnp_support);
++
++static struct attribute *usb_udc_attrs[] = {
++	&dev_attr_srp.attr,
++	&dev_attr_soft_connect.attr,
++	&dev_attr_speed.attr,
++
++	&dev_attr_is_dualspeed.attr,
++	&dev_attr_is_otg.attr,
++	&dev_attr_is_a_peripheral.attr,
++	&dev_attr_b_hnp_enable.attr,
++	&dev_attr_a_hnp_support.attr,
++	&dev_attr_a_alt_hnp_support.attr,
++	NULL,
++};
++
++static const struct attribute_group usb_udc_attr_group = {
++	.attrs = usb_udc_attrs,
++};
++
++static const struct attribute_group *usb_udc_attr_groups[] = {
++	&usb_udc_attr_group,
++	NULL,
++};
++
++static int usb_udc_uevent(struct device *dev, struct kobj_uevent_env *env)
++{
++	struct usb_udc		*udc = container_of(dev, struct usb_udc, dev);
++	int			ret;
++
++	ret = add_uevent_var(env, "USB_UDC_NAME=%s", udc->gadget->name);
++	if (ret) {
++		dev_err(dev, "failed to add uevent USB_UDC_NAME\n");
++		return ret;
++	}
++
++	if (udc->driver) {
++		ret = add_uevent_var(env, "USB_UDC_DRIVER=%s",
++				udc->driver->function);
++		if (ret) {
++			dev_err(dev, "failed to add uevent USB_UDC_DRIVER\n");
++			return ret;
++		}
++	}
++
++	return 0;
++}
++
++static int __init usb_udc_init(void)
++{
++	udc_class = class_create(THIS_MODULE, "udc");
++	if (IS_ERR(udc_class)) {
++		pr_err("failed to create udc class --> %ld\n",
++				PTR_ERR(udc_class));
++		return PTR_ERR(udc_class);
++	}
++
++	udc_class->dev_uevent = usb_udc_uevent;
++	return 0;
++}
++subsys_initcall(usb_udc_init);
++
++static void __exit usb_udc_exit(void)
++{
++	class_destroy(udc_class);
++}
++module_exit(usb_udc_exit);
++
++MODULE_DESCRIPTION("UDC Framework");
++MODULE_AUTHOR("Felipe Balbi <balbi@ti.com>");
++MODULE_LICENSE("GPL v2");
+--- /dev/null
++++ b/drivers/usb/gadget/usb3380.c
+@@ -0,0 +1,3277 @@
++
++#include <linux/module.h>
++#include <linux/pci.h>
++#include <linux/dma-mapping.h>
++#include <linux/kernel.h>
++#include <linux/delay.h>
++#include <linux/ioport.h>
++#include <linux/slab.h>
++#include <linux/errno.h>
++#include <linux/init.h>
++#include <linux/timer.h>
++#include <linux/list.h>
++#include <linux/interrupt.h>
++#include <linux/moduleparam.h>
++#include <linux/device.h>
++#include <linux/usb/ch9.h>
++#include <linux/usb/gadget.h>
++#include <linux/prefetch.h>
++#include <linux/version.h>
++#include <linux/vmalloc.h>
++
++#include <asm/byteorder.h>
++#include <asm/io.h>
++#include <asm/irq.h>
++#include <asm/system.h>
++#include <asm/unaligned.h>
++
++/*****************************************************************************/
++static int use_dma = 1;
++module_param (use_dma, bool, S_IRUGO);
++
++/* enable_suspend -- When enabled, the driver will respond to
++ * USB suspend requests by powering down the USB3380.  Otherwise,
++ * USB suspend requests will be ignored.  This is acceptible for
++ * self-powered devices
++ */
++static int enable_suspend = 0;
++module_param (enable_suspend, bool, S_IRUGO);
++
++static int log_entries = 2000;
++module_param (log_entries, uint, S_IRUGO);
++
++/*****************************************************************************/
++#define	DRIVER_DESC		"PLX USB338x Peripheral Controller"
++#define	DRIVER_VERSION		"2011 May 2"
++
++static const char driver_name [] = "usb3380";
++static const char driver_desc [] = DRIVER_DESC;
++
++#define	DMA_ADDR_INVALID	(~(dma_addr_t)0)
++
++static int enhanced = 0;
++
++static const char ep0name [] = "ep0";
++static const char *ep_name[][9] = {
++	{ ep0name, "ep1", "ep2", "ep3", "ep4", },
++	{ ep0name, "ep1out", "ep1in", "ep2out", "ep2in", "ep3out", "ep3in", "ep4out", "ep4in" },
++};
++
++static int ep_count;
++
++#include "usb3380.h"
++
++static u32 log_level = LOG_INFO;
++
++static struct usb3380	*usb3380_controller;
++
++#define MAX_PACKET_PER_SERVICE_INTERVAL 11
++static void set_ep_maxpacket(struct usb3380_ep *ep, u32 max)
++{
++	struct usb3380 *dev = ep->dev;
++	u32 speed_bias = 0; /* High-Speed */
++	u32 index;
++
++	switch (dev->gadget.speed) {
++		case USB_SPEED_FULL:
++			speed_bias = 1;
++			break;
++		case USB_SPEED_SUPER:
++			speed_bias = 2;
++			max |= (0x2 << MAX_PACKET_PER_SERVICE_INTERVAL);
++			break;
++		default:
++			break;
++	}
++
++	if (enhanced) {
++		/* Even GPEPs are OUT endpoints, and Odd GPEPs are IN endpoints. */
++		index = (ep->num % 2 != 0) ?
++			/* OUT */ ((ep->num / 2) * 0x10) + 0x20 + speed_bias :
++			/* IN */ ((ep->num / 2 ) * 0x10) + 0x50 + speed_bias;
++	} else {
++		/* Legacy Mode
++		 * The values in GPEP OUT CSRs are used for both the IN and OUT
++		 * direction of a GPEP.
++		 */
++		index = (ep->num + 1) * 0x10 + speed_bias;
++	}
++
++	set_idx_reg(dev->regs, index, max);
++}
++
++static inline u32 PCIIRQBit(u32 ep_num)
++{
++	return (enhanced) ?
++		((ep_num % 2 == 0) ? (ep_num / 2 + 16) : (ep_num / 2 + 1)) :
++		ep_num;
++}
++
++static __maybe_unused char *
++EpTypeString (const struct usb_endpoint_descriptor *desc) 
++{
++	static char *xfer_string[] = { "control", "iso", "bulk", "intr" };
++
++	if (!desc)
++		return xfer_string[USB_ENDPOINT_XFER_CONTROL];
++
++	switch (usb_endpoint_type(desc)) {
++		case USB_ENDPOINT_XFER_INT:
++			return xfer_string[USB_ENDPOINT_XFER_INT];
++		case USB_ENDPOINT_XFER_BULK:
++			return xfer_string[USB_ENDPOINT_XFER_BULK];
++		case USB_ENDPOINT_XFER_ISOC:
++			return xfer_string[USB_ENDPOINT_XFER_ISOC];
++	};
++	return xfer_string[USB_ENDPOINT_XFER_CONTROL];
++}
++
++/*****************************************************************************/
++
++void __dbglog(log_level_t level, char *text, u32 arg1, u32 arg2, u32 arg3)
++{
++	log_entry_t *queue = usb3380_controller->logger.queue;
++	unsigned int entries = usb3380_controller->logger.entries;
++	unsigned int *wrptr = &usb3380_controller->logger.wrptr;
++	unsigned int *rdptr = &usb3380_controller->logger.rdptr;
++	const unsigned int w_index = *wrptr;
++
++	if (likely(level > log_level))
++		return;
++	
++	memcpy(&queue[w_index].text, text, sizeof(queue[w_index].text));
++	queue[w_index].arg1 = arg1;
++	queue[w_index].arg2 = arg2;
++	queue[w_index].arg3 = arg3;
++
++	*wrptr = (w_index + 1) % entries;
++	if (*wrptr == *rdptr)	/* overflow */
++		*rdptr = (*rdptr + 1) % entries;
++}
++
++int usb3380_init_logger(struct usb3380 *dev, unsigned int entries)
++{
++	unsigned int bufsiz = PAGE_ALIGN(entries * sizeof(log_entry_t));
++	void *mem = vmalloc(bufsiz);
++
++	if (mem == NULL) {
++		ERRMSG(dev, "Failed to allocate %d bytes for logger\n", bufsiz);
++		return -ENOMEM;
++	}
++
++	dev->logger.rdptr = dev->logger.wrptr = 0;
++	dev->logger.entries = bufsiz / sizeof(log_entry_t);
++	dev->logger.queue = (log_entry_t *)mem;
++
++	return 0;
++}
++
++void usb3380_cleanup_logger(struct usb3380 *dev)
++{
++	if (dev->logger.queue)
++		vfree(dev->logger.queue);
++}
++
++/*****************************************************************************/
++#ifdef CONFIG_USB_GADGET_DEBUG_FS
++
++#include <linux/debugfs.h>
++#include <linux/uaccess.h>
++#include <linux/seq_file.h>
++
++#define USB3380_SEQ_RO_ATTR(_name)	\
++struct file_operations _name##_dbg_fops = {	\
++	.owner   = THIS_MODULE,	\
++	.open    = _name##_dbg_open,	\
++	.llseek  = seq_lseek,	\
++	.read    = seq_read,	\
++	.release = single_release,	\
++}
++
++#define USB3380_UDC_SEQ_RO_ATTR(_name)	\
++static int _name##_dbg_open(struct inode *inode, struct file *file)	\
++{	\
++	return single_open(file, _name##_dbg_show, inode->i_private);	\
++}	\
++\
++USB3380_SEQ_RO_ATTR(_name);
++
++#define USB3380_RW_ATTR(_name)	\
++static struct file_operations _name##_dbg_fops = {	\
++	.owner   = THIS_MODULE,	\
++	.open    = _name##_dbg_open,	\
++	.llseek  = default_llseek,	\
++	.read    = _name##_dbg_read,	\
++	.write   = _name##_dbg_write,	\
++}
++
++#define USB3380_UDC_RW_ATTR(_name)	\
++static int _name##_dbg_open(struct inode *inode, struct file *file)	\
++{	\
++	file->private_data = inode->i_private;	\
++	return 0;	\
++}	\
++\
++USB3380_RW_ATTR(_name);
++
++static int regs_dbg_show(struct seq_file *s, void *p)
++{
++	struct usb3380 *dev = s->private;
++	unsigned long flags;
++	int pos = 0, i;
++	u32 t1, t2;
++
++	if (!dev->driver)
++		return -ENODEV;
++
++	spin_lock_irqsave (&dev->lock, flags);
++
++	/* USB Controller Device-Specific Registers */
++	pos += seq_printf(s, "%s version " DRIVER_VERSION
++			", chiprev %04x, dma %s\n\n"
++			"devinit %03x gadget '%s'\n"
++			"cpu irqenb0 %06x irqenb1 %08x "
++			"pci irqenb0 %06x irqenb1 %08x "
++			"irqstat0 %04x irqstat1 %08x "
++			"gpioctrl %08x gpiostat %01x\n",
++			driver_name, dev->chiprev,
++			use_dma ? "enabled" : "disabled",
++			readl (&dev->regs->devinit),
++			dev->driver
++				? dev->driver->driver.name
++				: "(none)",
++			readl (&dev->regs->cpuirqenb0),
++			readl (&dev->regs->cpuirqenb1),
++			readl (&dev->regs->pciirqenb0),
++			readl (&dev->regs->pciirqenb1),
++			readl (&dev->regs->irqstat0),
++			readl (&dev->regs->irqstat1),
++			readl (&dev->regs->gpioctrl),
++			readl (&dev->regs->gpiostat));
++
++	/* USB Control Registers */
++	t1 = readl (&dev->usb->usbctl);
++	t2 = readl (&dev->usb->usbstat);
++
++	pos += seq_printf(s, "stdrsp %08x usbctl %08x usbctl2 %08x usbstat %08x "
++			"xcvrdiag %08x addr 0x%02x ",
++			readl (&dev->usb->stdrsp), t1,
++			readl (&dev->usb->usbctl2), t2,
++			readl (&dev->usb->xcvrdiag),
++			readl (&dev->usb->ouraddr));
++
++	if (t1 & (1 << VBUS_PIN)) {	/* Connected to the USB */
++		if (t2 & (1 << SUPER_SPEED_MODE))
++			pos += seq_printf(s, "(super speed)\n");
++		else if (t2 & (1 << HIGH_SPEED_MODE))
++			pos += seq_printf(s, "(high speed)\n");
++		else if (dev->gadget.speed == USB_SPEED_UNKNOWN)
++			pos += seq_printf(s, "(powered)\n");
++		else
++			pos += seq_printf(s, "(full speed)\n");
++	} else
++		pos += seq_printf(s, "(not attached)\n");
++
++	/* PCI Master Control Registers */
++
++	/* DMA Control Registers */
++
++	/* Configurable EP Control Registers */
++	for (i = 0; i <= ep_count; i++) {
++		struct usb3380_ep *ep = &dev->ep[i];
++
++		if (i && !ep->desc)
++			continue;
++
++		t1 = readl (&ep->cfg->ep_cfg);
++		t2 = readl (&ep->regs->ep_rsp) & 0xff;
++
++		pos += seq_printf(s,
++				"\n%s\tcfg %08x rsp (%02x) %s%s%s%s%s%s%s%s irqenb %02x\n",
++				ep->ep.name, t1, t2,
++				(t2 & (1 << CLEAR_NAK_PACKETS))
++					? "NAK " : "",
++				(t2 & (1 << CLEAR_EP_HIDE_STATUS_STAGE))
++					? "hide " : "",
++				(t2 & (1 << CLEAR_EP_FORCE_CRC_ERROR))
++					? "CRC " : "",
++				(t2 & (1 << CLEAR_INTERRUPT_MODE))
++					? "interrupt " : "",
++				(t2 & (1<<CLEAR_CONTROL_STATUS_STAGE_HANDSHAKE))
++					? "status " : "",
++				(t2 & (1 << CLEAR_NAK_OUT_PACKETS_MODE))
++					? "NAKmode " : "",
++				(t2 & (1 << CLEAR_ENDPOINT_TOGGLE))
++					? "DATA1 " : "DATA0 ",
++				(t2 & (1 << CLEAR_ENDPOINT_HALT))
++					? "HALT " : "",
++				readl (&ep->regs->ep_irqenb));
++
++		pos += seq_printf(s, "\tstat %08x avail %04x ",
++				readl (&ep->regs->ep_stat),
++				readl (&ep->regs->ep_avail));
++
++		if (enhanced) {
++			pos += seq_printf(s, "(%s-%s)%s\n",
++					ep_name[enhanced][ep->num], EpTypeString(ep->desc),
++					ep->stopped ? "*": "");
++		} else {
++			pos += seq_printf(s, "(%s%s-%s)%s\n",
++					ep_name[enhanced][ep->num], (ep->is_in) ? "in": "out",
++					EpTypeString(ep->desc),
++					ep->stopped ? "*": "");
++		}
++
++		if (!ep->dma)
++			continue;
++
++		pos += seq_printf(s, "  dma\tctl %08x stat %08x count %08x "
++				"countp %08x\n"
++				"\taddr %08x addrp %08x desc %08x descp %08x\n",
++				readl (&ep->dma->dmactl),
++				readl (&ep->dma->dmastat),
++				readl (&ep->dma->dmacount),
++				readl (&ep->dmap->dmacountp),
++				readl (&ep->dma->dmaaddr),
++				readl (&ep->dmap->dmaaddrp),
++				readl (&ep->dma->dmadesc),
++				readl (&ep->dmap->dmadescp));
++	}
++
++	spin_unlock_irqrestore (&dev->lock, flags);
++	return 0;
++}
++USB3380_UDC_SEQ_RO_ATTR(regs);
++
++static int queues_dbg_show(struct seq_file *s, void *p)
++{
++	struct usb3380 *dev = s->private;
++	unsigned long flags;
++	int i, pos = 0;
++
++	if (!dev->driver)
++		return -ENODEV;
++
++	spin_lock_irqsave (&dev->lock, flags);
++
++	for (i = 0; i < ep_count; i++) {
++		struct usb3380_ep *ep = &dev->ep[i];
++		struct usb3380_request *req;
++
++		if (i != 0) {
++			const struct usb_endpoint_descriptor *d = ep->desc;
++
++			if (!d)
++				continue;
++
++			if (enhanced) {
++				pos += seq_printf(s, "(%s-%s) ",
++						ep->ep.name, EpTypeString(ep->desc));
++			} else {
++				pos += seq_printf(s, "(%s%s-%s) ",
++						ep->ep.name, (ep->is_in) ? "in": "out",
++						EpTypeString(ep->desc));
++			}
++			pos += seq_printf(s, "max %04x %s fifo %x\n",
++					le16_to_cpu(d->wMaxPacketSize) & 0x1fff,
++					ep->dma ? "dma" : "pio", ep->fifo_size);
++		} else {
++			pos += seq_printf(s, "ep0 max %04x pio %s fifo %x\n",
++					ep->ep.maxpacket,
++					(ep->is_in) ? "in": "out",
++					ep->fifo_size);
++		}
++
++		if (list_empty (&ep->queue)) {
++			pos += seq_printf(s, "\t(nothing queued)\n");
++			continue;
++		}
++		list_for_each_entry (req, &ep->queue, queue) {
++			if (ep->dma && req->td_dma == readl (&ep->dma->dmadesc))
++				pos += seq_printf(s, "\treq %p len %x/%x "
++					"buf %p (dmacount %08x)\n",
++					&req->req, req->req.actual,
++					req->req.length, req->req.buf,
++					readl (&ep->dma->dmacount));
++			else
++				pos += seq_printf(s, "\treq %p len %x/%x buf %p\n",
++					&req->req, req->req.actual,
++					req->req.length, req->req.buf);
++
++			if (ep->dma) {
++				struct usb3380_dma *td = req->td;
++
++				pos += seq_printf(s, "\t    td %08x "
++					" count %08x buf %08x desc %08x\n",
++					(u32) req->td_dma,
++					le32_to_cpu (td->dmacount),
++					le32_to_cpu (td->dmaaddr),
++					le32_to_cpu (td->dmadesc));
++			}
++		}
++	}
++
++	spin_unlock_irqrestore (&dev->lock, flags);
++	return 0;
++}
++USB3380_UDC_SEQ_RO_ATTR(queues);
++
++static int func_dbg_show(struct seq_file *s, void *p)
++{
++	struct usb3380 *dev = s->private;
++
++	if (!(dev->driver && dev->driver->function))
++		return -ENODEV;
++
++	seq_printf(s, "%s\n", dev->driver->function);
++	return 0;
++}
++USB3380_UDC_SEQ_RO_ATTR(func);
++
++static int logs_dbg_show(struct seq_file *s, void *p)
++{
++	struct usb3380 *dev = s->private;
++	unsigned long flags;
++	unsigned int wrptr, rdptr, line;
++
++	spin_lock_irqsave (&dev->lock, flags);
++
++	for (line = 0, wrptr = dev->logger.wrptr, rdptr = dev->logger.rdptr;
++			(wrptr != rdptr);
++			rdptr = (rdptr + 1) % dev->logger.entries, line++) {
++		seq_printf(s, "  -%3u: "LOGFMT"\n",
++				line,
++				(char*)&dev->logger.queue[rdptr].text,
++				dev->logger.queue[rdptr].arg1,
++				dev->logger.queue[rdptr].arg2,
++				dev->logger.queue[rdptr].arg3);
++	}
++
++	spin_unlock_irqrestore (&dev->lock, flags);
++
++	return 0;
++}
++USB3380_UDC_SEQ_RO_ATTR(logs);
++
++static ssize_t loglvl_dbg_read(struct file *file, char __user *user_buf,
++		size_t count, loff_t *ppos)
++{
++	char buf[32];
++	unsigned int len;
++
++	len = sprintf(buf, "%u\n", log_level);
++	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
++}
++
++static ssize_t loglvl_dbg_write(struct file *file, const char __user *user_buf,
++		size_t count, loff_t *ppos)
++{
++	unsigned long mask;
++	char buf[32];
++	ssize_t len;
++
++	len = min(count, sizeof(buf) - 1);
++	if (copy_from_user(buf, user_buf, len))
++		return -EFAULT;
++
++	buf[len] = '\0';
++	if (strict_strtoul(buf, 0, &mask))
++		return -EINVAL;
++
++	log_level = mask;
++	return count;
++}
++USB3380_UDC_RW_ATTR(loglvl);
++
++static struct dbgfs_regmap {
++	char *qualifier;
++	char *name;
++	u32 offset;
++} dbgfs_regs[] = {
++	/* USB Configuration Registers */
++	/* USB Controller Device-Specific Registers */
++	{0, "devinit", 0x0}, {0, "pciirqenb0", 0x10}, {0, "pciirqenb1", 0x14},
++	{0, "cpuirqenb0", 0x18}, {0, "cpuirqenb1", 0x1c}, {0, "irqstat0", 0x28},
++	{0, "irqstat1", 0x2c}, {0, "idxaddr", 0x30}, {0, "idxdata", 0x34},
++	{0, "gpioctrl", 0x50}, {0, "gpiostat", 0x54}, 
++	/* USB Interface Control Register */
++	{0, "stdrsp", 0x80}, {0, "usbctl", 0x8c}, {0, "usbstat", 0x90}, 
++	{0, "xcvrdiag", 0x94}, {0, "usbctl2", 0xc8},
++	/* DMA Registers */
++	{"dma", "dmactl", 0x180}, {"dma", "dmastat", 0x184},
++	{"dma", "dmacount", 0x190}, {"dma", "dmaaddr", 0x194},
++	{"dma", "dmadesc", 0x198}, {"dma", "dmacountp", 0x680},
++	{"dma", "dmaaddrp", 0x684}, {"dma", "dmadescp", 0x688},
++	/* EP0 and GPEPx Registers */
++	{"ep", "ep_cfg", 0x300}, {"ep", "ep_rsp", 0x304},
++	{"ep", "ep_irqenb", 0x308}, {"ep", "ep_stat", 0x30c},
++	{"ep", "ep_avail", 0x310}, {"ep", "ep_val", 0x31c}
++};
++
++static ssize_t regval_dbg_read(struct file *file, char __user *user_buf,
++		size_t count, loff_t *ppos)
++{
++	char buf[] = "\"<reg> = <val>\" or \"<epN>.<reg> = <val>\" or "
++		"\"<dmaN>.<reg> = <val>\"\n";
++	return simple_read_from_buffer(user_buf, count, ppos, buf, strlen(buf));
++}
++
++static char *strtrim(char *string)
++{
++	int last = strlen(string) - 1;
++	char c;
++
++	/* trim tail */
++	for (c = string[last]; c == ' ' || c == '\t'; last--, c = string[last])
++		string[last] = '\0';
++	/* trim head */
++	for (c = *string; c == ' ' || c == '\t'; string++, c = *string);
++
++	return string;
++}
++
++#define QTYPE_EP	1
++#define QTYPE_DMA	2
++static ssize_t regval_dbg_write(struct file *file, const char __user *user_buf,
++		size_t count, loff_t *ppos)
++{
++	unsigned long val32, bias = 0;
++	char buf[80];
++	ssize_t len;
++	char *line = &buf[0];
++	char *name = NULL, *value = NULL, *qualifier = NULL;
++	int loc, q_type = 0;
++	struct dbgfs_regmap *entry;
++
++	struct usb3380 *dev = file->private_data;
++	u32 __iomem *addr;
++
++	len = min(count, sizeof(buf) - 1);
++	if (copy_from_user(buf, user_buf, len))
++		return -EFAULT;
++
++	buf[len] = '\0';
++
++	if ((qualifier = strsep(&line, "=")) != NULL)
++		qualifier = strtrim(qualifier);
++
++	if ((name = strchr(qualifier, '.')) != NULL) {
++		*name++ = '\0';
++		if (!strncmp(qualifier, "ep", 2)) {
++			if (strict_strtoul(&qualifier[2], 0, &bias))
++				return -EINVAL;
++			qualifier[2] = '\0';
++			q_type = QTYPE_EP;
++		} else if (!strncmp(qualifier, "dma", 3)) {
++			if (strict_strtoul(&qualifier[3], 0, &bias))
++				return -EINVAL;
++			qualifier[3] = '\0';
++			q_type = QTYPE_DMA;
++		} else
++			return -EINVAL;
++	} else
++		name = qualifier;
++
++	if ((value = strsep(&line, "=")) != NULL)
++		value = strtrim(value);
++
++	for (loc = 0; loc < ARRAY_SIZE(dbgfs_regs); loc++) {
++		if (dbgfs_regs[loc].qualifier && (name != qualifier) &&
++				strcmp(dbgfs_regs[loc].qualifier, qualifier))
++			continue;
++		if (!strcmp(dbgfs_regs[loc].name, name))
++			break;
++	}
++
++	if (loc >= ARRAY_SIZE(dbgfs_regs))
++		return -EINVAL;
++
++	if (strict_strtoul(value, 16, &val32))
++		return -EINVAL;
++
++	entry = &dbgfs_regs[loc];
++	switch (q_type) {
++		case QTYPE_DMA:
++			if (bias > NR_DMA_CHANNEL) return -EINVAL;
++			if (entry->name[strlen(entry->name) - 1] == 'p')
++				bias *= 0x10;
++			else
++				bias *= 0x20;
++			break;
++		case QTYPE_EP:
++			if (bias > ep_count) return -EINVAL;
++			if (enhanced) {
++			   if (strcmp(entry->name, "ep_cfg") &&
++					   strcmp(entry->name, "ep_val")) {
++				   	bias = ((bias != 0) && (bias % 2 == 0)) ?
++						(bias + 1) / 2 * 0x20 + 0xC0:
++						(bias + 1) / 2 * 0x20;
++			   } else
++				   bias = (bias + 1) / 2 * 0x20;
++			} else 
++				bias *= 0x20;
++			break;
++		default:
++			bias = 0;
++	}
++
++	addr = (void *)dev->regs + entry->offset + bias;
++
++	writel (val32, addr);
++
++	return count;
++}
++USB3380_UDC_RW_ATTR(regval);
++
++static struct dbgfs_config {
++	char *name;
++	struct file_operations *fops;
++	mode_t mode;
++} dbgfs_vars[] = {
++	{"regs", &regs_dbg_fops, 0400},
++	{"queues", &queues_dbg_fops, 0400},
++	{"functions", &func_dbg_fops, 0400},
++	{"logs", &logs_dbg_fops, 0400},
++	{"log_level", &loglvl_dbg_fops, 0600},
++	{"reg_val", &regval_dbg_fops, 0600},
++};
++
++static void usb3380_init_debugfs(struct usb3380 *dev)
++{
++	struct dentry *root, *attr;
++	int i;
++
++    root = debugfs_create_dir(dev->gadget.name, NULL);
++	if (IS_ERR(root) || !root)
++		goto err_root;
++
++	for (i=0; i<ARRAY_SIZE(dbgfs_vars); i++) {
++		attr = debugfs_create_file(dbgfs_vars[i].name,
++				dbgfs_vars[i].mode,
++				root, dev, dbgfs_vars[i].fops);
++		if (!attr)
++			ERRMSG(dev, "Failed to create %s in debugfs\n", dbgfs_vars[i].name);
++	}
++
++	dev->debugfs_root = root;
++	return;
++
++err_root:
++	ERRMSG(dev, "debugfs is not available\n");
++}
++
++static void usb3380_cleanup_debugfs(struct usb3380 *dev)
++{
++	if (dev->debugfs_root) {
++		debugfs_remove_recursive(dev->debugfs_root);
++		dev->debugfs_root = NULL;
++	}
++}
++
++#else
++
++static void usb3380_init_debugfs(struct usb3380 *dev) {}
++static void usb3380_cleanup_debugfs(struct usb3380 *dev) {}
++
++#endif
++
++/*****************************************************************************/
++
++static int handshake (u32 __iomem *ptr, u32 mask, u32 done, int usec)
++{
++	u32	result;
++
++	do {
++		result = readl (ptr);
++		if (result == ~(u32)0)		/* "device unplugged" */
++			return -ENODEV;
++		result &= mask;
++		if (result == done)
++			return 0;
++		udelay (1);
++		usec--;
++	} while (usec > 0);
++	VLOG("Timo", 0, 0, 0);
++	return -ETIMEDOUT;
++}
++
++ /*
++  * used where the host wrote "too much" data to us.
++  */
++static __maybe_unused void
++out_flush (struct usb3380_ep *ep)
++{
++	u32	__iomem *statp;
++	u32	tmp;
++
++	statp = &ep->regs->ep_stat;
++	writel ((1 << DATA_OUT_PING_TOKEN_INTERRUPT) |
++			(1 << DATA_PACKET_RECEIVED_INTERRUPT)
++			, statp);
++	writel ((1 << FIFO_FLUSH), statp);
++	mb ();
++	tmp = readl (statp);
++	DBG("Flsh", ep->num, tmp, 0);
++	if (tmp & (1 << DATA_OUT_PING_TOKEN_INTERRUPT)
++			/* high speed did bulk NYET; fifo isn't filling */
++			&& ep->dev->gadget.speed == USB_SPEED_FULL) {
++		unsigned	usec;
++
++		usec = 50;		/* 64 byte bulk/interrupt */
++		handshake (statp, (1 << USB_OUT_NAK_SENT),
++				(1 << USB_OUT_NAK_SENT), usec);
++		/* NAK done; now CLEAR_NAK_OUT_PACKETS is safe */
++	}
++}
++
++/* unload packet(s) from the fifo we use for usb OUT transfers.
++ * returns true iff the request completed, because of short packet
++ * or the request buffer having filled with full packets.
++ */
++static int
++read_fifo (struct usb3380_ep *ep, struct usb3380_request *req)
++{
++	struct usb3380_ep_regs __iomem *regs = ep->regs;
++	u8 *buf = req->req.buf + req->req.actual;
++	u32 tmp, count, ep_stat;
++	int is_short;
++
++	/* never overflow the rx buffer. the fifo reads packets until
++	 * it sees a short one; we might not be ready for them all.
++	 */
++	prefetchw (buf);
++	ep_stat = readl (&regs->ep_stat);
++	count = readl (&regs->ep_avail);
++
++	do {
++		DBG("Aval", count, ep_stat, ep->ep.maxpacket);
++
++		/* A ZLP OUT packet may be in the endpoint */
++		if (count == 0)
++			break;
++
++		writel ((1 << DATA_OUT_PING_TOKEN_INTERRUPT) |
++				(1 << DATA_IN_TOKEN_INTERRUPT)
++				, &regs->ep_stat);
++
++		tmp = req->req.length - req->req.actual;
++		if (count > tmp)
++			count = tmp;
++
++		req->req.actual += count;
++
++		/* read data from the fifo */
++		while (count >= 4) {
++			tmp = readl (&regs->ep_data);
++			cpu_to_le32s (&tmp);
++			put_unaligned (tmp, (u32 *)buf);
++			buf += 4;
++			count -= 4;
++		}
++		/* the remaining bytes (less than 4 bytes) */
++		if (count) {
++			tmp = readl (&regs->ep_data);
++			/* LE conversion is implicit here: */
++			do {
++				*buf++ = (u8) tmp;
++				tmp >>= 8;
++			} while (--count);
++		}
++
++		ep_stat = readl (&regs->ep_stat);
++		count = readl (&regs->ep_avail);
++
++	} while (count && req->req.actual != req->req.length);
++
++	is_short = ep_stat & ((1 << SHORT_OUT_PACKET_RECEIVED_INTERRUPT) |
++			(1 << ZLP_INTERRUPT));
++
++	if (ep_stat & (1 << ZLP_INTERRUPT))
++		writel ((1 << ZLP_INTERRUPT), &regs->ep_stat);
++
++	if (ep_stat & (1 << SHORT_OUT_PACKET_RECEIVED_INTERRUPT)) {
++		writel ((1 << SHORT_OUT_PACKET_RECEIVED_INTERRUPT) |
++				(1 << DATA_OUT_PING_TOKEN_INTERRUPT) |
++				(1 << SHORT_OUT_PACKET_DONE_INTERRUPT)
++				, &regs->ep_stat);
++	}
++
++	DBG("RdFl", ep_stat, req->req.actual, req->req.length);
++
++	/* return true if the transfer is complete */
++	return is_short || ((req->req.actual == req->req.length)
++				&& !req->req.zero);
++}
++
++/* load a packet into the fifo we use for usb IN transfers.
++ * works for all endpoints.
++ * one packet is written to the fifo at a time
++ */
++static void
++write_fifo (struct usb3380_ep *ep, struct usb_request *req)
++{
++	struct usb3380_ep_regs __iomem *regs = ep->regs;
++	u8 *buf;
++	u32 tmp;
++	unsigned count, total;
++
++	if (req) {
++		buf = req->buf + req->actual;
++		prefetch (buf);
++		total = req->length - req->actual;
++	} else {
++		total = 0;
++		buf = NULL;
++	}
++
++	if (readl (&ep->regs->ep_avail) == 0) {
++		VLOG("Full", readl (&ep->regs->ep_stat), req->actual, req->length);
++		return;
++	}
++
++	/* write just one packet at a time */
++	count = ep->ep.maxpacket;
++	if (count > total)	/* min() cannot be used on a bitfield */
++		count = total;
++
++	DBG("WrF0", count, req->actual, req->length);
++
++	while (count >= 4) {
++		/* NOTE be careful if you try to align these. fifo lines
++		 * should normally be full (4 bytes) and successive partial
++		 * lines are ok only in certain cases.
++		 */
++		tmp = get_unaligned ((u32 *)buf);
++		cpu_to_le32s (&tmp);
++		writel (tmp, &regs->ep_data);
++		buf += 4;
++		count -= 4;
++	}
++
++	/* last fifo entry is "short" unless we wrote a full packet.
++	 * also explicitly validate last word in (periodic) transfers
++	 * when maxpacket is not a multiple of 4 bytes.
++	 */
++	if (count || total < ep->ep.maxpacket) {
++		tmp = count ? get_unaligned ((u32 *)buf) : count;
++		cpu_to_le32s (&tmp);
++		set_fifo_bytecount (ep, count & 0x03);
++		writel (tmp, &regs->ep_data);
++	}
++}
++
++/*****************************************************************************/
++#define valid_bit	(cpu_to_le32 (1 << VALID_BIT))
++#define dma_done_ie	(cpu_to_le32 (1 << DMA_DONE_INTERRUPT_ENABLE))
++
++static void
++done (struct usb3380_ep *ep, struct usb3380_request *req, int status)
++{
++	struct usb3380 *dev;
++	unsigned stopped = ep->stopped;
++
++	VLOG("Done", ep->num, req->req.actual, req->req.length);
++
++	list_del_init (&req->queue);
++
++	if (req->req.status == -EINPROGRESS)
++		req->req.status = status;
++	else
++		status = req->req.status;
++
++	dev = ep->dev;
++	if (req->mapped) {
++		pci_unmap_single (dev->pdev, req->req.dma, req->req.length,
++			ep->is_in ? PCI_DMA_TODEVICE : PCI_DMA_FROMDEVICE);
++		req->req.dma = DMA_ADDR_INVALID;
++		req->mapped = 0;
++	}
++
++	/* don't modify queue heads during completion callback */
++	ep->stopped = 1;
++	spin_unlock (&dev->lock);
++	req->req.complete (&ep->ep, &req->req);
++	spin_lock (&dev->lock);
++	/* Mass Storage might issue a halt */
++	if (!ep->is_halt)
++		ep->stopped = stopped;
++}
++
++static inline void
++dma_done (struct usb3380_ep *ep,
++		struct usb3380_request *req,
++		u32 dmacount,
++		int status)
++{
++	VLOG("DmaD", ep->num, dmacount, (u32)req->td_dma);
++	req->req.actual = req->req.length - (DMA_TRANSFER_MAX_LENGTH & dmacount);
++	if (likely(req->req.actual))
++		done (ep, req, status);
++	else {
++		/* When interrupted by ZLP, the DMA engine will be aborted, causing
++		 * the valid bit of the current dmacount being turned off.
++		 */
++		req->td->dmacount |= valid_bit;
++	}
++}
++
++static void scan_dma_completions (struct usb3380_ep *ep)
++{
++	VLOG("DScn", ep->num, ep->td_dma, 0);
++	/* only look at descriptors that were "naturally" retired,
++	 * so fifo and list head state won't matter
++	 */
++	while (!list_empty (&ep->queue)) {
++		struct usb3380_request *req;
++		u32 stat, avail, dmacount;
++
++		req = list_entry (ep->queue.next, struct usb3380_request, queue);
++		if (!req->valid)
++			break;
++
++		rmb ();
++		dmacount = le32_to_cpup (&req->td->dmacount);
++		VLOG("CkCt", ep->num, dmacount, (u32)req->td_dma);
++		if ((dmacount & (1 << VALID_BIT)) != 0)
++			break;
++
++		if (!ep->is_in && (req->req.length % ep->ep.maxpacket) != 0) {
++			stat = readl (&ep->regs->ep_stat);
++			avail = readl (&ep->regs->ep_avail);
++			/* AVOID TROUBLE HERE by not issuing short reads from
++			 * your gadget driver. Not all cases trigger the warning.
++			 */
++			/* Your gadget driver requests 600 + 200, but the host sends out
++			 * 400 + 400 */
++			WARNING("Lost", stat, avail, dmacount);
++		}
++
++		dma_done (ep, req, dmacount, 0);
++	}
++}
++
++static inline void spin_stop_dma (struct usb3380_dma_regs __iomem *dma)
++{
++	handshake (&dma->dmactl, (1 << DMA_ENABLE)|(1 << DMA_ABORT), 0, 50);
++}
++
++static inline void stop_dma (struct usb3380_ep *ep)
++{
++	writel (readl (&ep->dma->dmactl) & ~(1 << DMA_ENABLE), &ep->dma->dmactl);
++	spin_stop_dma (ep->dma);
++	ep->dma_started = false;
++}
++
++static inline void resume_dma (struct usb3380_ep *ep)
++{
++	writel (readl (&ep->dma->dmactl) | (1 << DMA_ENABLE), &ep->dma->dmactl);
++	ep->dma_started = true;
++}
++
++static inline void abort_dma (struct usb3380_ep *ep)
++{
++	VLOG("DAbt", ep->num, ep->td_dma, 0);
++	writel ((1 << DMA_ABORT), &ep->dma->dmastat);
++	spin_stop_dma (ep->dma);
++	ep->dma_started = false;
++}
++
++/*
++ * 10.3.1: The DMA Scatter/Gather Controller can be configured to pause when
++ * a Cleared Valid bit is detected. In this case, the firmware must restart
++ * the DMA Scatter/Gather Controller after setting up and validating additional
++ * Descriptors.
++ * We use polling so we don't have to setup registers every time.
++ */
++#define DMACTL_SG_STANDARD	\
++	((1 << DMA_DESCRIPTOR_DONE_INTERRUPT_ENABLE) |	\
++	 ((POLL_1_USEC) << DESCRIPTOR_POLLING_RATE) |	\
++	 (1 << DMA_VALID_BIT_POLLING_ENABLE) |	\
++	 (1 << DMA_VALID_BIT_ENABLE) |	\
++	 (1 << DMA_DESCRIPTOR_MODE) |	\
++	 (1 << DMA_CLEAR_COUNT_ENABLE) |	\
++	 (1 << DMA_ENABLE))
++
++static void start_queue (struct usb3380_ep *ep, u32 dmactl, u32 td_dma)
++{
++	struct usb3380_dma_regs	__iomem *dma = ep->dma;
++	u32 tmp = (1 << VALID_BIT) | (ep->is_in << DMA_DIRECTION);
++
++#ifndef USE_3380_FPGA
++	/* FIXME Enabling DMA_REQUEST_OUTSTANDING for USB-IN is highly
++	 * platform dependent. If running Loophost with errors, try to
++	 * enable this for USB-OUT only
++	 */
++	//if (!ep->is_in)
++		dmactl |=  (0x6 << DMA_REQUEST_OUTSTANDING);
++#endif
++
++	//writel (0, &dma->dmaaddr);
++	writel (tmp, &dma->dmacount);
++	writel (readl (&dma->dmastat), &dma->dmastat);
++
++#if defined(USE_TUNE_LOOPHOST) && defined(INTERNAL_DESCRIPTOR)
++	writel (td_dma|(1<<DMA_DESC_ONCHIP), &dma->dmadesc);
++#else
++	writel (td_dma, &dma->dmadesc);
++#endif
++	writel (dmactl, &dma->dmactl);
++	wmb();
++	writel ((1 << DMA_START), &dma->dmastat);
++
++	VLOG("SDqu", ep->num, dmactl, td_dma);
++
++	ep->dma_started = true;
++
++	if (!ep->is_in)
++		stop_out_naking (ep);
++}
++
++static void
++fill_dma_desc (struct usb3380_ep *ep, struct usb3380_request *req, int valid)
++{
++	struct usb3380_dma *td = req->td;
++	u32 dmacount = req->req.length;
++
++	/* don't let DMA continue after a short OUT packet,
++	 * so overruns can't affect the next transfer.
++	 * in case of overruns on max-size packets, we can't
++	 * stop the fifo from filling but we can flush it.
++	 */
++	if (ep->is_in)
++		dmacount |= (1 << DMA_DIRECTION);
++	else if (dmacount % ep->ep.maxpacket != 0)
++		dmacount |= (1 << LAST_DESCRIPTOR);
++
++	req->valid = valid;
++	if (valid)
++		dmacount |= (1 << VALID_BIT);
++	if (likely(!req->req.no_interrupt))
++		dmacount |= (1 << DMA_DONE_INTERRUPT_ENABLE);
++
++	/* td->dmadesc = previously set by caller */
++	td->dmaaddr = cpu_to_le32 (req->req.dma);
++	/* Be careful here. DMA may be polling the valid bit until it's set on to
++	 * proceed.
++	 */
++	wmb ();
++	td->dmacount = cpu_to_le32 (dmacount);
++}
++
++static void queue_dma(struct usb3380_ep *ep, struct usb3380_request *req)
++{
++	struct usb3380_dma *end;
++	dma_addr_t addr;
++
++	u32 tmp = DMACTL_SG_STANDARD;
++	int valid = 1;
++
++	/* If DMA is still working, it's probably waiting for the valid bit of the
++	 * last descriptor to be turn on. In the case, we switch the descriptor
++	 * with the dummy and turn on the valid bit to start DMA
++	 * PS: We always switch the descriptor with the dummy even the DMA is not
++	 * working because it's no harm.
++	 */ 
++
++	VLOG("QDma", ep->num, req->req.length, ep->td_dma);
++	/* swap new dummy for old, link; fill and maybe activate */
++	end = ep->dummy;
++	ep->dummy = req->td;
++	req->td = end;
++
++	addr = ep->td_dma;
++	ep->td_dma = req->td_dma;
++	req->td_dma = addr;
++	/* pointing to the current dummy */
++#if defined(USE_TUNE_LOOPHOST) && defined(INTERNAL_DESCRIPTOR)
++	end->dmadesc = cpu_to_le32 (ep->td_dma |(1<<DMA_DESC_ONCHIP));
++#else
++	end->dmadesc = cpu_to_le32 (ep->td_dma);
++#endif
++	/* Fill out the descriptor and turn on the valid bit to start DMA
++	 * transfers.
++	 */
++	/* kickstart this i/o queue? */
++	if (list_empty (&ep->queue) && !ep->stopped) {
++		writel (0, &ep->dma->dmactl);
++		/* force packet boundaries between dma requests, but prevent the
++		 * controller from automagically writing a last "short" packet
++		 * (zero length) unless the driver explicitly said to do that.
++		 */
++		if (ep->is_in) {
++			if (req->req.zero || (req->req.length % ep->ep.maxpacket)) {
++				tmp |= (1 << DMA_FIFO_VALIDATE);
++				ep->in_fifo_validate = 1;
++			} else
++				ep->in_fifo_validate = 0;
++		}
++		fill_dma_desc (ep, req, 1);
++		start_queue (ep, tmp, req->td_dma);
++	} else {
++		int validate = req->req.zero || (req->req.length % ep->ep.maxpacket);
++		/* The DMA is working and probably has reached the last descriptor,
++		 * waiting for the valid bit to be turned on
++		 */
++		if (ep->is_in && validate != ep->in_fifo_validate)
++			valid = 0;
++
++		fill_dma_desc (ep, req, valid);
++	}
++}
++
++static void restart_dma (struct usb3380_ep *ep)
++{
++	struct usb3380_request	*req;
++	u32 dmactl = DMACTL_SG_STANDARD;
++
++	if (ep->stopped)
++		return;
++
++	req = list_entry (ep->queue.next, struct usb3380_request, queue);
++
++	VLOG("SDma", ep->num, req->req.actual, req->req.length);
++
++	/* the 3380 will be processing the queue unless queue hiccups after
++	 * the previous transfer:
++	 *  IN:   wanted automagic zlp, head doesn't (or vice versa)
++	 *        DMA_FIFO_VALIDATE doesn't init from dma descriptors.
++	 *  OUT:  was "usb-short", we must restart.
++	 */
++	if (ep->is_in && !req->valid) {
++		struct usb3380_request	*entry, *prev = NULL;
++		int	reqmode, done = 0;
++
++		ep->in_fifo_validate = likely (req->req.zero
++			|| (req->req.length % ep->ep.maxpacket) != 0);
++		if (ep->in_fifo_validate)
++			dmactl |= (1 << DMA_FIFO_VALIDATE);
++
++		VLOG("Hicp", ep->in_fifo_validate, req->req.zero, ep->td_dma);
++
++		list_for_each_entry (entry, &ep->queue, queue) {
++			__le32		dmacount;
++
++			if (entry == req)
++				continue;
++			dmacount = entry->td->dmacount;
++			if (!done) {
++				reqmode = likely (entry->req.zero
++					|| (entry->req.length
++						% ep->ep.maxpacket) != 0);
++				if (reqmode == ep->in_fifo_validate) {
++					entry->valid = 1;
++					dmacount |= valid_bit;
++					entry->td->dmacount = dmacount;
++					prev = entry;
++					continue;
++				} else {
++					/* force a hiccup */
++					prev->td->dmacount |= dma_done_ie;
++					done = 1;
++				}
++			}
++
++			/* walk the rest of the queue so unlinks behave */
++			entry->valid = 0;
++			dmacount &= ~valid_bit;
++			entry->td->dmacount = dmacount;
++			prev = entry;
++		}
++		/* Set the valid bit for the first one */
++		req->valid = 1;
++		if (dma_in_progress (ep)) {
++			writel (dmactl, &ep->dma->dmactl);
++			wmb();
++			/* The DMA Engine is waiting for valid_bit turned on to resume
++			 * DMA transfer */
++			req->td->dmacount |= valid_bit;
++			return;
++		}
++		req->td->dmacount |= valid_bit;
++	}
++
++	writel (0, &ep->dma->dmactl);
++	start_queue (ep, dmactl, req->td_dma);
++}
++
++/*****************************************************************************/
++
++/* dequeue ALL requests */
++static void nuke (struct usb3380_ep *ep)
++{
++	struct usb3380_request	*req;
++
++	VLOG("Nuke", ep->num, 0, 0);
++	/* called with spinlock held */
++	ep->stopped = 1;
++	if (ep->dma)
++		abort_dma (ep);
++	while (!list_empty (&ep->queue)) {
++		req = list_entry (ep->queue.next, struct usb3380_request, queue);
++		done (ep, req, -ESHUTDOWN);
++	}
++}
++
++/* dequeue JUST ONE request */
++static int usb3380_dequeue (struct usb_ep *_ep, struct usb_request *_req)
++{
++	struct usb3380_ep *ep;
++	struct usb3380_request *req;
++	unsigned long flags;
++	u32 dmactl;
++	int stopped;
++
++	ep = container_of (_ep, struct usb3380_ep, ep);
++	if (!_ep || (!ep->desc && ep->num != 0) || !_req)
++		return -EINVAL;
++
++	if (!ep->dev->driver)
++		return -ESHUTDOWN;
++
++	spin_lock_irqsave (&ep->dev->lock, flags);
++	stopped = ep->stopped;
++
++	VLOG("DeQu", ep->num, 0, 0);
++	/* quiesce dma while we patch the queue */
++	dmactl = 0;
++	ep->stopped = 1;
++	if (ep->dma) {
++		dmactl = readl (&ep->dma->dmactl);
++		stop_dma (ep);
++		scan_dma_completions (ep);
++	}
++
++	/* make sure it's still queued on this endpoint */
++	list_for_each_entry (req, &ep->queue, queue) {
++		if (&req->req == _req)
++			break;
++	}
++	if (&req->req != _req) {
++		spin_unlock_irqrestore (&ep->dev->lock, flags);
++		return -EINVAL;
++	}
++
++	/* queue head may be partially complete. */
++	if (ep->queue.next == &req->queue) {
++		if (ep->dma) {
++			INFO("Unlk", 0, 0, 0);
++			_req->status = -ECONNRESET;
++			abort_dma (ep);
++			if (likely (ep->queue.next == &req->queue)) {
++				// NOTE: misreports single-transfer mode
++				req->td->dmacount = 0;	/* invalidate */
++				dma_done (ep, req,
++					readl (&ep->dma->dmacount),
++					-ECONNRESET);
++			}
++		} else {
++			INFO("Unk1", 0, 0, 0);
++			done (ep, req, -ECONNRESET);
++		}
++		req = NULL;
++
++	/* patch up hardware chaining data */
++	} else if (ep->dma) {
++		VLOG("Ptch", (u32)req->queue.prev, (u32)ep->queue.next, ep->td_dma);
++		if (req->queue.prev == ep->queue.next) {
++			writel (le32_to_cpu (req->td->dmadesc), &ep->dma->dmadesc);
++			if (req->td->dmacount & dma_done_ie)
++				writel (readl (&ep->dma->dmacount) | le32_to_cpu(dma_done_ie),
++					&ep->dma->dmacount);
++		} else {
++			struct usb3380_request *prev;
++			prev = list_entry (req->queue.prev, struct usb3380_request, queue);
++			prev->td->dmadesc = req->td->dmadesc;
++			if (req->td->dmacount & dma_done_ie)
++				prev->td->dmacount |= dma_done_ie;
++		}
++	}
++
++	if (req)
++		done (ep, req, -ECONNRESET);
++
++	ep->stopped = stopped;
++	if (ep->dma) {
++		/* turn off dma on inactive queues */
++		if (list_empty (&ep->queue)) {
++			abort_dma (ep);
++		} else if (!ep->stopped) {
++			/* resume current request, or start new one */
++			if (req)
++				writel (dmactl, &ep->dma->dmactl);
++			else
++				restart_dma (ep);
++		}
++	}
++
++	spin_unlock_irqrestore (&ep->dev->lock, flags);
++	return 0;
++}
++
++static int
++usb3380_queue(struct usb_ep *_ep, struct usb_request *_req, gfp_t gfp_flags)
++{
++	struct usb3380_request *req;
++	struct usb3380_ep *ep;
++	struct usb3380 *dev;
++	unsigned long flags;
++
++	/* we always require a cpu-view buffer, so that we can
++	 * always use pio (as fallback or whatever).
++	 */
++	req = container_of (_req, struct usb3380_request, req);
++	if (!_req || !_req->complete || !_req->buf
++			|| !list_empty (&req->queue))
++		return -EINVAL;
++	if (_req->length > DMA_TRANSFER_MAX_LENGTH)
++		return -EDOM;
++	ep = container_of (_ep, struct usb3380_ep, ep);
++	if (!_ep || (!ep->desc && ep->num != 0))
++		return -EINVAL;
++	dev = ep->dev;
++	if (!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN)
++		return -ESHUTDOWN;
++
++	/* FIXME implement PIO fallback for ZLPs with DMA */
++	if (ep->dma && _req->length == 0)
++		return -EOPNOTSUPP;
++
++	/* set up dma mapping in case the caller didn't */
++	if (ep->dma && _req->dma == DMA_ADDR_INVALID) {
++		_req->dma = pci_map_single (dev->pdev, _req->buf, _req->length,
++			ep->is_in ? PCI_DMA_TODEVICE : PCI_DMA_FROMDEVICE);
++		req->mapped = 1;
++	}
++
++	spin_lock_irqsave (&dev->lock, flags);
++
++	DBG("Enq0", ep->num, (u32)req->td_dma, _req->length);
++
++	_req->status = -EINPROGRESS;
++	_req->actual = 0;
++
++	if (ep->dma) {
++		queue_dma(ep, req);
++	} else
++	/* kickstart this i/o queue? */
++	if (list_empty (&ep->queue) && !ep->stopped) {
++		/* maybe there's no control data, just status ack */
++		if (ep->num == 0 && _req->length == 0) {
++			allow_status (ep);
++			done (ep, req, 0);
++			VLOG("Ack0", 0, 0, 0);
++			goto done;
++		}
++
++		/* PIO ... stuff the fifo, or unblock it.  */
++		if (ep->is_in) {
++			write_fifo (ep, _req);
++		}
++		else if (list_empty (&ep->queue)) {
++			u32	s;
++
++			/* OUT FIFO might have packet(s) buffered */
++			s = readl (&ep->regs->ep_stat);
++			if ((s & (1 << FIFO_EMPTY)) == 0) {
++				/* note:  _req->short_not_ok is
++				 * ignored here since PIO _always_
++				 * stops queue advance here, and
++				 * _req->status doesn't change for
++				 * short reads (only _req->actual)
++				 */
++				if (read_fifo (ep, req)) {
++					done (ep, req, 0);
++					if (ep->num == 0) {
++						allow_status (ep);
++					}
++					/* don't queue it */
++					req = NULL;
++				} else
++					s = readl (&ep->regs->ep_stat);
++			}
++			/* don't NAK, let the fifo fill */
++			if (req && (s & (1 << NAK_PACKETS)))
++				stop_out_naking(ep);
++		}
++	}
++
++	ep->responded = 1;
++	if (req)
++		list_add_tail (&req->queue, &ep->queue);
++done:
++	spin_unlock_irqrestore (&dev->lock, flags);
++	return 0;
++}
++#if defined(USE_TUNE_LOOPHOST) && defined(INTERNAL_DESCRIPTOR)
++static void *bar_pool_alloc(struct usb3380 *dev, dma_addr_t *handle)
++{
++	unsigned long flags;
++	struct usb3380_dma *td;
++
++	spin_lock_irqsave (&dev->lock, flags);
++
++	td = dev->pool_desc;
++	*handle = dev->pool_desc_dma;
++	/* We know 64K is big enough, and it won't overrun. Too bad, too lazy */
++	dev->pool_desc += sizeof(struct usb3380_dma);
++	dev->pool_desc_dma += sizeof(struct usb3380_dma);
++
++	spin_unlock_irqrestore (&dev->lock, flags);
++	return td;
++}
++#endif
++
++static struct usb_request *
++usb3380_alloc_request (struct usb_ep *_ep, gfp_t gfp_flags)
++{
++	struct usb3380_ep *ep;
++	struct usb3380_request *req;
++	//unsigned long flags;
++
++	if (!_ep)
++		return NULL;
++	ep = container_of (_ep, struct usb3380_ep, ep);
++
++	req = kzalloc(sizeof(*req), gfp_flags);
++	if (!req)
++		return NULL;
++
++	req->req.dma = DMA_ADDR_INVALID;
++	INIT_LIST_HEAD (&req->queue);
++
++	/* this dma descriptor may be swapped with the previous dummy */
++	if (ep->dma) {
++		struct usb3380_dma *td;
++#if defined(USE_TUNE_LOOPHOST) && defined(INTERNAL_DESCRIPTOR)
++		td = bar_pool_alloc(ep->dev, &req->td_dma);
++#else
++		td = pci_pool_alloc (ep->dev->requests, gfp_flags,
++				&req->td_dma);
++		if (!td) {
++			kfree (req);
++			return NULL;
++		}
++#endif
++		td->dmacount = 0;	/* not VALID */
++		td->dmaaddr = cpu_to_le32 (DMA_ADDR_INVALID);
++		td->dmadesc = td->dmaaddr;
++		req->td = td;
++	}
++	return &req->req;
++}
++
++static void
++usb3380_free_request (struct usb_ep *_ep, struct usb_request *_req)
++{
++	struct usb3380_ep *ep;
++	struct usb3380_request *req;
++	//unsigned long flags;
++
++	ep = container_of (_ep, struct usb3380_ep, ep);
++	if (!_ep || !_req)
++		return;
++
++	req = container_of (_req, struct usb3380_request, req);
++	WARN_ON (!list_empty (&req->queue));
++#ifndef INTERNAL_DESCRIPTOR
++	if (req->td)
++		pci_pool_free (ep->dev->requests, req->td, req->td_dma);
++#endif
++	kfree (req);
++}
++
++static int
++usb3380_fifo_status (struct usb_ep *_ep)
++{
++	struct usb3380_ep	*ep;
++	u32			avail;
++
++	ep = container_of (_ep, struct usb3380_ep, ep);
++	if (!_ep || (!ep->desc && ep->num != 0))
++		return -ENODEV;
++	if (!ep->dev->driver || ep->dev->gadget.speed == USB_SPEED_UNKNOWN)
++		return -ESHUTDOWN;
++
++	avail = readl (&ep->regs->ep_avail);
++	if (avail > ep->fifo_size)
++		return -EOVERFLOW;
++	if (ep->is_in)
++		avail = ep->fifo_size - avail;
++
++	return avail;
++}
++
++static void
++usb3380_fifo_flush (struct usb_ep *_ep)
++{
++	struct usb3380_ep	*ep;
++
++	ep = container_of (_ep, struct usb3380_ep, ep);
++	if (!_ep || (!ep->desc && ep->num != 0))
++		return;
++	if (!ep->dev->driver || ep->dev->gadget.speed == USB_SPEED_UNKNOWN)
++		return;
++
++	writel ((1 << FIFO_FLUSH), &ep->regs->ep_stat);
++	(void) readl (&ep->regs->ep_rsp);
++}
++
++static void ep_reset(struct usb3380_regs __iomem *, struct usb3380_ep *);
++static int usb3380_disable (struct usb_ep *_ep)
++{
++	struct usb3380_ep *ep;
++	unsigned long flags;
++
++	ep = container_of (_ep, struct usb3380_ep, ep);
++	if (!_ep || !ep->desc || _ep->name == ep0name)
++		return -EINVAL;
++
++	spin_lock_irqsave (&ep->dev->lock, flags);
++	DBG("Disb", ep->num, 0, 0);
++	nuke(ep);
++	ep_reset (ep->dev->regs, ep);
++
++	/* synch memory views with the device */
++	(void) readl (&ep->cfg->ep_cfg);
++
++	if (use_dma && !ep->dma && ep->num >= 1 && ep->num <= NR_DMA_CHANNEL) {
++		ep->dma = (struct usb3380_dma_regs __iomem *)
++			&ep->dev->dma[ep->num - 1];
++		ep->dmap = (struct usb3380_dmap_regs __iomem *)
++			&ep->dev->dmap[ep->num - 1];
++	}
++
++	spin_unlock_irqrestore (&ep->dev->lock, flags);
++	return 0;
++}
++
++static int
++usb3380_enable(struct usb_ep *_ep, const struct usb_endpoint_descriptor *desc)
++{
++	struct usb3380 *dev;
++	struct usb3380_ep *ep;
++	u32 max, tmp;
++	unsigned long flags;
++	int rc = 0;
++
++	ep = container_of (_ep, struct usb3380_ep, ep);
++	if (!_ep || !desc || ep->desc || _ep->name == ep0name
++			|| desc->bDescriptorType != USB_DT_ENDPOINT)
++		return -EINVAL;
++
++	dev = ep->dev;
++	if (!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN)
++		return -ESHUTDOWN;
++
++	if (!enhanced && (ep->num != usb_endpoint_num(desc)))
++		return -EINVAL;
++	/* Dedicated endpoints start at 0x0c */
++	if ((desc->bEndpointAddress & 0x0f) >= 0x0c)
++		return -EDOM;
++
++	/* In Legacy Adapter mode, the 4 endpoints could be configured as either
++	 * IN or OUT endpoint. But in Enhanced mode, we have to check if it's
++	 * compliant with the EP definition
++	 */
++	ep->is_in = usb_endpoint_dir_in(desc) ? 1 : 0;
++	if (enhanced && ep->is_in && (ep->num % 2 != 0))
++		return -EINVAL;
++
++	max = le16_to_cpu(desc->wMaxPacketSize) & 0x7ff;
++	tmp = usb_endpoint_type(desc);
++	switch (tmp) {
++		case USB_ENDPOINT_XFER_INT:
++			if (dev->gadget.speed == USB_SPEED_FULL && max != 0x40)
++				return -ERANGE;
++			/* FIXME: DMA doesn't help a lot on Intr Endpoints. However, when
++			 * the chip is working on enhanced mode, simply disabling the DMA
++			 * channel might not be a good solution. In that case, extra
++			 * effort like the current implementation in epautoconf.c would
++			 * be required to help class drivers choose a suitable endpoint
++			 */
++			if (!enhanced)
++				ep->dma = NULL;
++			break;
++		case USB_ENDPOINT_XFER_BULK:
++			if ((dev->gadget.speed == USB_SPEED_HIGH && max != 0x200) ||
++					(dev->gadget.speed == USB_SPEED_FULL && max > 0x40))
++				return -ERANGE;
++			break;
++		case USB_ENDPOINT_XFER_ISOC:
++			ep->is_iso = 1;
++			break;
++		default:
++			break;
++	}
++
++	/* Enable this endpoint */
++	/* In Legacy mode, only OUT endpoints are used */
++	if (ep->is_in && enhanced) {
++		tmp <<= IN_ENDPOINT_TYPE;
++		tmp |= (1 << IN_ENDPOINT_ENABLE);
++		tmp |= (1 << ENDPOINT_DIRECTION); /* Not applicable to Legacy */
++	} else {
++		tmp <<= OUT_ENDPOINT_TYPE;
++		tmp |= (1 << OUT_ENDPOINT_ENABLE);
++		tmp |= (ep->is_in << ENDPOINT_DIRECTION);
++	}
++	tmp |= usb_endpoint_num(desc);
++	tmp |= (ep->ep.maxburst << MAX_BURST_SIZE);
++
++	spin_lock_irqsave (&dev->lock, flags);
++	/* GPEPx In/Out share the same ep_cfg. Overwriting this register
++	 * is prohibited */
++	writel (tmp | readl(&ep->cfg->ep_cfg), &ep->cfg->ep_cfg);
++
++	writel ((1 << SET_NAK_OUT_PACKETS_MODE) |
++			(1 << SET_NAK_PACKETS)
++			, &ep->regs->ep_rsp);
++
++	_ep->maxpacket = max;
++	/* set speed-dependent max packet; may kick in high bandwidth */
++	set_ep_maxpacket(ep, max);
++
++	ep->desc = desc;
++	ep->stopped = 0;
++	ep->wedged = 0;
++	ep->out_overflow = 0;
++
++	/* Compute the fifo size for this endpoint */
++	tmp = readl (&ep->ffregs->ep_fifo_size_base) >> (ep->is_in ?
++		IN_FIFO_SIZE : OUT_FIFO_SIZE);
++	switch (tmp & 0x7) {
++		case FIFO_SIZE_64:
++			ep->fifo_size = 0x40;
++			break;
++		case FIFO_SIZE_128:
++			ep->fifo_size = 0x80;
++			break;
++		case FIFO_SIZE_256:
++			ep->fifo_size = 0x100;
++			break;
++		case FIFO_SIZE_512:
++			ep->fifo_size = 0x200;
++			break;
++		case FIFO_SIZE_1024:
++			ep->fifo_size = 0x400;
++			break;
++		case FIFO_SIZE_2048:
++			ep->fifo_size = 0x800;
++			break;
++		case FIFO_SIZE_4096:
++			ep->fifo_size = 0x1000;
++			break;
++		default:
++			ERROR("FCfg", ep->num, tmp, 0);
++			rc = -EINVAL;
++			goto out;
++	}
++
++	DBG("FSiz", ep->num, ep->fifo_size, ep->is_in);
++
++	/* set type, direction, address; reset fifo counters */
++	writel ((1 << NAK_PACKETS) |
++			(1 << SHORT_PACKET_TRANSFERRED_STATUS) |
++			(1 << DATA_PACKET_RECEIVED_INTERRUPT) |
++			(1 << DATA_PACKET_TRANSMITTED_INTERRUPT) |
++			(1 << DATA_OUT_PING_TOKEN_INTERRUPT) |
++			(1 << DATA_IN_TOKEN_INTERRUPT)
++			, &ep->regs->ep_stat);
++	wmb ();
++
++	if (!ep->dma) {
++		/* Enable the corresponding PIO interrupts */
++		tmp = (1 << PCIIRQBit(ep->num)) | readl(&dev->regs->pciirqenb0);
++		writel(tmp, &dev->regs->pciirqenb0);
++
++		tmp = (1 << DATA_PACKET_RECEIVED_INTERRUPT_ENABLE) |
++			  (1 << SHORT_PACKET_TRANSFERRED_INTERRUPT_ENABLE) |
++			  (1 << DATA_PACKET_TRANSMITTED_INTERRUPT_ENABLE);
++		writel(tmp, &ep->regs->ep_irqenb);
++	} else {
++		/* Enable the corresponding DMA channel interrupts */
++		tmp = (1 << (8 + ep->num)) | readl(&dev->regs->pciirqenb1);
++		writel (tmp, &dev->regs->pciirqenb1);
++
++		/* for short OUT transfers, dma completions can't
++		 * advance the queue; do it pio-style, by hand.
++		 */
++		if (!ep->is_in) {
++			//writel((1 << SHORT_PACKET_TRANSFERRED_INTERRUPT_ENABLE),
++			writel((1 << SHORT_PACKET_OUT_DONE_INTERRUPT_ENABLE),
++					&ep->regs->ep_irqenb);
++
++			tmp = (1 << PCIIRQBit(ep->num)) | readl(&dev->regs->pciirqenb0);
++			writel(tmp, &dev->regs->pciirqenb0);
++		}
++	}
++
++	INFO("Enb0", usb_endpoint_num(ep->desc), ep->is_in, 0);
++out:
++	spin_unlock_irqrestore (&dev->lock, flags);
++	return rc;
++}
++
++static void
++__ep_set_halt_and_wedge(struct usb3380_ep *ep, int value, int wedged)
++{
++	DBG("Hlt0", value, wedged, 0);
++	/* set/clear, then synch memory views with the device */
++	if (value) {
++		ep->stopped = 1;
++		if (ep->num == 0) {
++			ep->dev->protocol_stall = 1;
++		} else {
++			if (ep->dma)
++				stop_dma (ep);
++			ep_stall (ep, true);
++		}
++		if (wedged)
++			ep->wedged = 1;
++	} else {
++		ep->stopped = 0;
++		ep->wedged = 0;
++		ep_stall (ep, false);
++		/* Flush the queue */
++		if (!list_empty(&ep->queue)) {
++			struct usb3380_request *req = list_entry(ep->queue.next,
++					struct usb3380_request, queue);
++			if (ep->dma)
++				resume_dma (ep);
++			else {
++				if (ep->is_in)
++					write_fifo(ep, &req->req);
++				else {
++					if (read_fifo(ep, req))
++						done (ep, req, 0);
++				}
++			}
++		}
++	}
++}
++
++static int
++usb3380_set_halt_and_wedge(struct usb3380_ep *ep, int value, int wedged)
++{
++	unsigned long flags;
++
++	if (!ep->desc && ep->num != 0)
++		return -EINVAL;
++	if (!ep->dev->driver || ep->dev->gadget.speed == USB_SPEED_UNKNOWN)
++		return -ESHUTDOWN;
++	if (ep->desc /* not ep0 */ &&
++			usb_endpoint_type(ep->desc) == USB_ENDPOINT_XFER_ISOC)
++		return -EINVAL;
++
++	if (!list_empty (&ep->queue))
++		return -EAGAIN;
++	else if (ep->is_in && value && usb3380_fifo_status (&ep->ep) != 0)
++		return -EAGAIN;
++
++	spin_lock_irqsave (&ep->dev->lock, flags);
++	if (wedged)
++		__ep_set_halt_and_wedge(ep, 1, 1);
++	else
++		__ep_set_halt_and_wedge(ep, value, 0);
++	spin_unlock_irqrestore (&ep->dev->lock, flags);
++
++	return 0;
++}
++
++static int
++usb3380_set_halt(struct usb_ep *_ep, int value)
++{
++	struct usb3380_ep *ep = container_of (_ep, struct usb3380_ep, ep);
++
++	if (!_ep) return -EINVAL;
++
++	return usb3380_set_halt_and_wedge(ep, value, 0);
++}
++
++static int
++usb3380_set_wedge(struct usb_ep *_ep)
++{
++	struct usb3380_ep *ep = container_of (_ep, struct usb3380_ep, ep);
++
++	if (!_ep || _ep->name == ep0name)
++		return -EINVAL;
++
++	return usb3380_set_halt_and_wedge(ep, 1, 1);
++}
++
++static const struct usb_ep_ops usb3380_ep_ops = {
++	/* configure endpoint, making it usable */
++	.enable		= usb3380_enable,
++	/* endpoint is no longer usable */
++	.disable	= usb3380_disable,
++
++	/* allocate a request object to use with this endpoint */
++	.alloc_request	= usb3380_alloc_request,
++	/* frees a request object */
++	.free_request	= usb3380_free_request,
++
++	/* queues (submits) an I/O request to an endpoint */
++	.queue		= usb3380_queue,
++	/* dequeues (cancels, unlinks) an I/O request from an endpoint */
++	.dequeue	= usb3380_dequeue,
++
++	/* sets the endpoint halt feature */
++	.set_halt	= usb3380_set_halt,
++	.set_wedge	= usb3380_set_wedge,
++	/* returns number of bytes in fifo, or error */
++	.fifo_status	= usb3380_fifo_status,
++	/* flushes contents of a fifo */
++	.fifo_flush	= usb3380_fifo_flush,
++};
++
++/*****************************************************************************/
++
++static void
++ep_reset(struct usb3380_regs __iomem *regs, struct usb3380_ep *ep)
++{
++	u32 tmp;
++
++	ep->desc = NULL;
++	INIT_LIST_HEAD (&ep->queue);
++
++	ep->ep.maxpacket = ~0;
++	ep->ep.ops = &usb3380_ep_ops;
++
++	/* disable the dma, irqs, endpoint... */
++	if (ep->dma) {
++		/* In legacy mode, bit 1..4 correspond to the interrupt enable bits of
++		 * GPEP0..4
++		 * In enhanced mode, bit 1..4 correspond to the interrupt enable bits
++		 * of GPEP0..4 OUT, and bit 17..20 to GPEP0..4 IN
++		 */
++		writel (0, &ep->dma->dmactl);
++		writel ((1 << DMA_ABORT_DONE_INTERRUPT) |
++				(1 << DMA_PAUSE_DONE_INTERRUPT) |
++				(1 << DMA_LAST_DESCRIPTOR_DONE_INTERRUPT) |
++				(1 << DMA_TRANSACTION_DONE_INTERRUPT)
++				, &ep->dma->dmastat);
++
++		tmp = readl (&regs->pciirqenb0);
++		tmp &= ~(1 << PCIIRQBit(ep->num));
++		writel (tmp, &regs->pciirqenb0);
++	} else {
++		tmp = readl (&regs->pciirqenb1);
++		/* make sure the DMA channel is disabled */
++		tmp &= ~(1 << (8 + ep->num));
++		writel (tmp, &regs->pciirqenb1);
++	}
++	writel (0, &ep->regs->ep_irqenb);
++
++	usb3380_set_halt_and_wedge(ep, 0, 0);
++	/* scrub most status bits, and flush any fifo state */
++	writel ((1 << SHORT_OUT_PACKET_DONE_INTERRUPT) |
++			(1 << SHORT_OUT_PACKET_RECEIVED_INTERRUPT) |
++			(1 << ZLP_INTERRUPT) |
++			(1 << DATA_PACKET_RECEIVED_INTERRUPT) |
++			(1 << DATA_PACKET_TRANSMITTED_INTERRUPT) |
++			(1 << DATA_OUT_PING_TOKEN_INTERRUPT) |
++			(1 << DATA_IN_TOKEN_INTERRUPT)
++			, &ep->regs->ep_stat);
++}
++
++static void usb_reinit (struct usb3380 *dev)
++{
++	int i, tmp;
++
++	INIT_LIST_HEAD (&dev->gadget.ep_list);
++	dev->gadget.ep0 = &dev->ep[0].ep;
++	dev->gadget.speed = USB_SPEED_UNKNOWN;
++	dev->gadget.is_dualspeed = 1;
++	dev->ep[0].stopped = 0;
++
++	for (i = 0; i <= ep_count; i++) {
++		struct usb3380_ep *ep = &dev->ep[i];
++		
++		ep->num = i;
++		ep->ep.name = ep_name[enhanced][i];
++
++		ep->ep.ops = &usb3380_ep_ops;
++		list_add_tail (&ep->ep.ep_list, &dev->gadget.ep_list);
++		ep->dev = dev;
++		INIT_LIST_HEAD (&ep->queue);
++
++		/* EP0 and GPEPx Registers: See the header file for detail info */
++		/* In Legacy Adapter mode, only the OUT register offset is used to
++		 * access the corresponding register, although the endpoint can be
++		 * programmed as IN or OUT
++		 */
++		if (enhanced) {
++			u32 offset = ((i != 0) && (i % 2 == 0))  ? 0xC0 : 0;
++
++			ep->cfg = &dev->epcfg[(i+1)/2];
++			ep->regs = (struct usb3380_ep_regs __iomem *)
++				(((unsigned char *)&dev->epregs[(i+1)/2]) + offset);
++			ep->ffregs = &dev->ffregs[(i+1)/2];
++		} else {
++			ep->cfg = &dev->epcfg[i];
++			ep->regs = &dev->epregs[i];
++			ep->ffregs = &dev->ffregs[i];
++		}
++
++		/* We only have 4 channels */
++		if (use_dma && i > 0 && i <= NR_DMA_CHANNEL) {
++			ep->dma = &dev->dma[i-1];
++			ep->dmap = &dev->dmap[i-1];
++		}
++
++		ep_reset(dev->regs, ep);
++	}
++
++	dev->ep[0].fifo_size = 0x200;
++	dev->ep[0].ep.maxpacket = EP0_HS_MAX_PACKET_SIZE;
++	list_del_init (&dev->ep[0].ep.ep_list);
++
++	/* Link layer set up */
++	tmp = readl(&dev->usb->usbctl2) &
++		~((1 << U1_ENABLE) | (1 << U2_ENABLE) | (1 << LTM_ENABLE));
++	writel(tmp, &dev->usb->usbctl2);
++	writel ((1 << PM_DIR_LINK_REJECT), &dev->llregs->ll_general_ctrl1);
++	/* FIXME: Sometimes when the USB3380 is connected to a host, it flutuates
++	 * between super speed and high speed and finally become stable at high
++	 * speed. If that keeps happening. The following code is a potential
++	 * workaround
++	 */
++#if 0
++	/* Polarity inversion workaround */
++	tmp = (readl(&dev->llregs->ll_general_ctrl2) & ~(1 << SELECT_INVERT_LANE_POLARITY)) | (1 << FORCE_INVERT_LANE_POLARITY);
++	writel (tmp, &dev->llregs->ll_general_ctrl2);
++#endif
++
++#ifdef USE_TUNE_LOOPHOST
++	/* Gadget zero support only one pair of loopback endpoints. We can enlarge
++	 * the first pair's fifo size to improve the performance.
++	 * Changing Fifo configuration to (4K 2K 1K 1K)
++	 */
++	{
++		u32 fsiz[4] = { FIFO_SIZE_4096, FIFO_SIZE_2048,
++						FIFO_SIZE_1024, FIFO_SIZE_1024 };
++		struct usb3380_ep *ep;
++		u32 ffreg;
++
++		for (i = 4; i >= 1; i--) {
++			ep = &dev->ep[i];
++			ffreg = (readl (&ep->ffregs->ep_fifo_size_base) &
++				~(0x7 << IN_FIFO_SIZE)) | (fsiz[i-1] << IN_FIFO_SIZE);
++			writel (ffreg, &ep->ffregs->ep_fifo_size_base);
++		}
++	}
++#endif
++
++	/* Explicitly disable the 6 dedicated endpoints */
++	tmp = 0x0d;
++	for (i = 0; i < 4; i+=2, tmp++) {
++		writel (tmp, &dev->dep[i].dep_cfg);
++		writel (tmp, &dev->dep[i+1].dep_cfg);
++	}
++	writel (0x0f, &dev->dep[4].dep_cfg);
++	writel (0x0c, &dev->dep[5].dep_cfg);
++}
++
++static void usb_reset (struct usb3380 *dev)
++{
++	u32 tmp;
++
++	usb3380_led_init(dev);
++
++	/* disable automatic responses, and irqs */
++	writel (0, &dev->usb->stdrsp);
++	writel (0, &dev->regs->pciirqenb0);
++	writel (0, &dev->regs->pciirqenb1);
++
++	/* clear old dma and irq state */
++	for (tmp = 1; tmp <= ep_count; tmp++) {
++		struct usb3380_ep *ep = &dev->ep[tmp];
++
++		if (ep->dma) {
++			nuke(ep);
++		}
++	}
++	/* Clear pending status */
++	writel (~0, &dev->regs->irqstat0);
++	writel (~0, &dev->regs->irqstat1),
++
++	/* reset, and enable pci */
++	tmp = readl (&dev->regs->devinit) |
++		(1 << FIFO_SOFT_RESET) |
++		(1 << USB_SOFT_RESET) |
++		(1 << PCI_ENABLE) |
++		(1 << M8051_RESET);
++	writel (tmp, &dev->regs->devinit);
++}
++
++/* when a driver is successfully registered, it will receive
++ * control requests including set_configuration(), which enables
++ * non-control requests.  then usb traffic follows until a
++ * disconnect is reported.  then a host may connect again, or
++ * the driver might get unbound.
++ */
++static void
++stop_activity (struct usb3380 *dev, struct usb_gadget_driver *driver)
++{
++	int i;
++
++	VLOG("StpA", 0, 0, 0);
++
++	/* don't disconnect if it's not connected */
++	if (dev->gadget.speed == USB_SPEED_UNKNOWN)
++		driver = NULL;
++
++	/* stop hardware; prevent new request submissions;
++	 * and kill any outstanding requests.
++	 */
++	usb_reset (dev);
++	for (i = 0; i <= ep_count; i++)
++		nuke (&dev->ep [i]);
++
++	/* report disconnect; the driver is already quiesced */
++	if (driver) {
++		spin_unlock (&dev->lock);
++		driver->disconnect (&dev->gadget);
++		spin_lock (&dev->lock);
++	}
++
++	usb_reinit (dev);
++}
++
++static void ep0_start(struct usb3380 *dev)
++{
++	writel ((1 << CLEAR_NAK_OUT_PACKETS_MODE) |
++			(1 << SET_EP_HIDE_STATUS_STAGE)
++			, &dev->epregs[0].ep_rsp);
++
++	/* enable irqs so we can see ep0 and general operation  */
++	writel ((1 << SETUP_PACKET_PCIE_INTERRUPT_ENABLE) |
++			(1 << ENDPOINT_0_PCIE_INTERRUPT_ENABLE)
++			, &dev->regs->pciirqenb0);
++
++	writel ((1 << GLOBAL_PCIE_INTERRUPT) |
++			(1 << ROOT_PORT_RESET_PCIE_INTERRUPT_ENABLE) |
++			(1 << SUSPEND_REQUEST_CHANGE_PCIE_INTERRUPT_ENABLE) |
++			(1 << VBUS_PCIE_INTERRUPT_ENABLE)
++			, &dev->regs->pciirqenb1);
++
++	/*
++	 * hardware optionally handles a bunch of standard requests
++	 * that the API hides from drivers anyway.  have it do so.
++	 * endpoint status/features are handled in software, to
++	 * help pass tests for some dubious behavior.
++	 */
++	writel ((1 << SET_TEST_MODE) |
++			//(1 << DEVICE_SET_CLEAR_DEVICE_REMOTE_WAKEUP) |
++			(1 << SET_ADDRESS) |
++			(1 << SET_SEL) |
++			(1 << ISOCHRONOUS_DELAY) |
++			(1 << GET_INTERFACE_STATUS)
++			, &dev->usb->stdrsp);
++
++	dev->wakeup_enable = 1;
++	writel ((1 << USB_ROOT_PORT_WAKEUP_ENABLE) |
++			(dev->softconnect << USB_DETECT_ENABLE) |
++			(1 << REMOTE_WAKEUP_ENABLE)
++			, &dev->usb->usbctl);
++
++	(void) readl (&dev->usb->usbctl);
++}
++
++int usb_gadget_probe_driver(struct usb_gadget_driver *driver,
++		int (*bind)(struct usb_gadget *))
++{
++	struct usb3380 *dev = usb3380_controller;
++	int	retval, i;
++
++	/* don't support low speed devices */
++	if (!driver
++			|| driver->speed < USB_SPEED_FULL
++			|| !bind || !driver->setup)
++		return -EINVAL;
++	if (!dev)
++		return -ENODEV;
++	if (dev->driver)
++		return -EBUSY;
++
++	for (i = 0; i <= ep_count; i++)
++		dev->ep[i].irqs = 0;
++
++	/* hook up the driver ... */
++	dev->softconnect = 1;
++	driver->driver.bus = NULL;
++	dev->driver = driver;
++	dev->gadget.dev.driver = &driver->driver;
++	retval = bind(&dev->gadget);
++	if (retval) {
++		DBGMSG(dev, "bind to driver %s --> %d\n", driver->driver.name, retval);
++		dev->driver = NULL;
++		dev->gadget.dev.driver = NULL;
++		return retval;
++	}
++
++	/* ... then enable host detection and ep0; and we're ready
++	 * for set_configuration as well as eventual disconnect.
++	 */
++	usb3380_led_active (dev, 1);
++	ep0_start (dev);
++
++	DBGMSG(dev, "%s ready, usbctl %08x usbstat %08x stdrsp %08x\n",
++			driver->driver.name,
++			readl (&dev->usb->usbctl),
++			readl (&dev->usb->usbstat),
++			readl (&dev->usb->stdrsp));
++
++	return 0;
++}
++#ifndef USB_GADGET_NAPI
++EXPORT_SYMBOL(usb_gadget_probe_driver);
++#endif
++
++static int usb3380_pullup(struct usb_gadget *, int);
++int usb_gadget_unregister_driver (struct usb_gadget_driver *driver)
++{
++	struct usb3380 *dev = usb3380_controller;
++	unsigned long flags;
++
++	if (!dev)
++		return -ENODEV;
++	if (!driver || driver != dev->driver || !driver->unbind)
++		return -EINVAL;
++
++	spin_lock_irqsave (&dev->lock, flags);
++	stop_activity (dev, driver);
++	spin_unlock_irqrestore (&dev->lock, flags);
++
++	usb3380_pullup (&dev->gadget, 0);
++
++	driver->unbind (&dev->gadget);
++	dev->gadget.dev.driver = NULL;
++	dev->driver = NULL;
++
++	usb3380_led_active (dev, 0);
++
++	DBGMSG(dev, "unregistered driver '%s'\n", driver->driver.name);
++	return 0;
++}
++#ifndef USB_GADGET_NAPI
++EXPORT_SYMBOL (usb_gadget_unregister_driver);
++#endif
++
++/*****************************************************************************/
++static int usb3380_get_frame (struct usb_gadget *_gadget)
++{
++	struct usb3380 *dev;
++	unsigned long flags;
++	u16	retval;
++
++	if (!_gadget)
++		return -ENODEV;
++
++	dev = container_of (_gadget, struct usb3380, gadget);
++	spin_lock_irqsave (&dev->lock, flags);
++	/* Index 02h FRMAE frame counter 10:0 */
++	retval = get_idx_reg (dev->regs, IDXREG_FRAME) & 0x03ff;
++	spin_unlock_irqrestore (&dev->lock, flags);
++
++	return retval;
++}
++
++static int usb3380_wakeup (struct usb_gadget *_gadget)
++{
++	struct usb3380 *dev;
++	u32 tmp;
++	unsigned long flags;
++
++	if (!_gadget)
++		return 0;
++	dev = container_of (_gadget, struct usb3380, gadget);
++
++	spin_lock_irqsave (&dev->lock, flags);
++	tmp = readl (&dev->usb->usbctl);
++	if (tmp & (1 << REMOTE_WAKEUP_ENABLE))
++		writel (1 << GENERATE_RESUME, &dev->usb->usbstat);
++	spin_unlock_irqrestore (&dev->lock, flags);
++
++	return 0;
++}
++
++static int usb3380_set_selfpowered (struct usb_gadget *_gadget, int value)
++{
++	struct usb3380 *dev;
++	u32 tmp;
++	unsigned long flags;
++
++	if (!_gadget)
++		return 0;
++	dev = container_of (_gadget, struct usb3380, gadget);
++
++	spin_lock_irqsave (&dev->lock, flags);
++	tmp = readl (&dev->usb->usbctl);
++	if (value) {
++		tmp |= (1 << SELF_POWERED_STATUS);
++		dev->selfpowered = 1;
++	} else {
++		tmp &= ~(1 << SELF_POWERED_STATUS);
++		dev->selfpowered = 0;
++	}
++	writel (tmp, &dev->usb->usbctl);
++	spin_unlock_irqrestore (&dev->lock, flags);
++
++	return 0;
++}
++
++static int usb3380_pullup(struct usb_gadget *_gadget, int is_on)
++{
++	struct usb3380 *dev;
++	u32             tmp;
++	unsigned long   flags;
++
++	if (!_gadget)
++		return -ENODEV;
++	dev = container_of (_gadget, struct usb3380, gadget);
++
++	spin_lock_irqsave (&dev->lock, flags);
++
++	/* Redetect the speed of the connection */
++	dev->gadget.speed = USB_SPEED_UNKNOWN;
++
++	tmp = readl (&dev->usb->usbctl);
++	dev->softconnect = (is_on != 0);
++	if (is_on)
++		tmp |= (1 << USB_DETECT_ENABLE);
++	else
++		tmp &= ~(1 << USB_DETECT_ENABLE);
++	writel (tmp, &dev->usb->usbctl);
++	spin_unlock_irqrestore (&dev->lock, flags);
++
++	return 0;
++}
++
++static const struct usb_gadget_ops usb3380_ops = {
++	/* returns the current frame number */
++	.get_frame	= usb3380_get_frame,
++	/* tries to wake up the host connected to this gadget */
++	.wakeup		= usb3380_wakeup,
++	/* sets the device selfpowered feature */
++	.set_selfpowered = usb3380_set_selfpowered,
++	.pullup		= usb3380_pullup,
++#ifdef USB_GADGET_NAPI
++	.start		= usb_gadget_probe_driver,
++	.stop		= usb_gadget_unregister_driver,
++#endif
++};
++
++static void gadget_release (struct device *_dev)
++{
++	struct usb3380 *dev = dev_get_drvdata(_dev);
++	kfree (dev);
++}
++
++/*****************************************************************************/
++static struct usb3380_ep *
++get_ep_by_addr (struct usb3380 *dev, u16 wIndex)
++{
++	struct usb3380_ep	*ep;
++
++	if ((wIndex & USB_ENDPOINT_NUMBER_MASK) == 0)
++		return &dev->ep [0];
++	list_for_each_entry (ep, &dev->gadget.ep_list, ep.ep_list) {
++		u8	bEndpointAddress;
++
++		if (!ep->desc)
++			continue;
++		bEndpointAddress = ep->desc->bEndpointAddress;
++		if ((wIndex ^ bEndpointAddress) & USB_DIR_IN)
++			continue;
++		if ((wIndex & 0x0f) == (bEndpointAddress & 0x0f))
++			return ep;
++	}
++	return NULL;
++}
++
++/* handle endpoints in pio mode or just to manually
++ * advance the queue after short OUT transfers.
++ */
++static void handle_ep_intr (struct usb3380_ep *ep)
++{
++	struct usb3380_request	*req;
++	volatile u32			t;
++	/* 0 error, 1 mid-data, 2 done */
++	int			mode = 1;
++
++	if (!list_empty (&ep->queue))
++		req = list_entry (ep->queue.next, struct usb3380_request, queue);
++	else
++		req = NULL;
++
++	/* ack all, and handle what we care about */
++	t = readl (&ep->regs->ep_stat);
++	ep->irqs++;
++
++	DBG("Intr", ep->num, ep->is_in, t);
++
++	if (ep->is_in)
++		writel (t, &ep->regs->ep_stat);
++
++	/* for ep0, monitor token irqs to catch data stage length errors
++	 * and to synchronize on status.
++	 *
++	 * also, to defer reporting of protocol stalls ... here's where
++	 * data or status first appears, handling stalls here should never
++	 * cause trouble on the host side..
++	 *
++	 * control requests could be slightly faster without token synch for
++	 * status, but status can jam up that way.
++	 */
++
++	VLOG("Int0", ep->dev->protocol_stall, ep->stopped, (u32)req);
++
++	if (unlikely (ep->num == 0)) {
++		if (ep->is_in) {
++			/* status; stop NAKing */
++			if (t & (1 << DATA_OUT_PING_TOKEN_INTERRUPT)) {
++				if (ep->dev->protocol_stall) {
++					ep->stopped = 1;
++					ep_stall (ep, true);
++				}
++				if (!req) {
++					allow_status (ep);
++				}
++				mode = 2;
++			/* reply to extra IN data tokens with a zlp */
++			} else if (t & (1 << DATA_IN_TOKEN_INTERRUPT)) {
++				if (ep->dev->protocol_stall) {
++					ep->stopped = 1;
++					ep_stall (ep, true);
++					mode = 2;
++				} else if (ep->responded && !req && !ep->stopped) {
++					VLOG("Rsbd", 0, 0, 0);
++					write_fifo (ep, NULL);
++				}
++			}
++		} else {
++			/* status; stop NAKing */
++			if (t & (1 << DATA_IN_TOKEN_INTERRUPT)) {
++				if (ep->dev->protocol_stall) {
++					ep->stopped = 1;
++					ep_stall (ep, true);
++				}
++				mode = 2;
++			/* an extra OUT token is an error */
++			} else if (((t & (1 << DATA_OUT_PING_TOKEN_INTERRUPT))
++					&& req
++					&& req->req.actual == req->req.length)
++					|| (ep->responded && !req)) {
++				VLOG("DOPT", ep->responded, req ? req->req.actual: 0,
++						req ? req->req.length: 0);
++				ep->dev->protocol_stall = 1;
++				ep->stopped = 1;
++				ep_stall (ep, true);
++				if (req)
++					done (ep, req, -EOVERFLOW);
++				req = NULL;
++			}
++		}
++	}
++
++	if (unlikely (!req))
++		goto out;
++
++	/* manual DMA queue advance after short OUT */
++	if (likely (ep->dma != 0)) {
++		writel (t & ~(1 << NAK_PACKETS), &ep->regs->ep_stat);
++		if (t & (1 << SHORT_OUT_PACKET_DONE_INTERRUPT)) {
++		//if (t & (1 << SHORT_OUT_PACKET_RECEIVED_INTERRUPT)) {
++			int	stopped = ep->stopped;
++			ep->stopped = 1;
++
++			/* 10.4 DMA OUT Transfer Completion
++			 * software polls the FIFO Empty status flag until the FIFO
++			 * indicates there's no remaining data.
++			 */
++			//while (!(readl(&ep->regs->ep_stat) & (1 << FIFO_EMPTY)));
++			/* DMA transfer is complete, data has been in the buffer now. */
++			/* stop DMA, leave ep NAKing */
++			abort_dma(ep);
++			scan_dma_completions (ep);
++			ep->stopped = stopped;
++			/* (re)start dma if needed, stop NAKing */
++			if (!list_empty (&ep->queue))
++				restart_dma (ep);
++		}
++		return;
++	} else
++	/* data packet(s) received (in the fifo, OUT) */
++	if (t & (1 << DATA_PACKET_RECEIVED_INTERRUPT)) {
++		if (read_fifo (ep, req) && ep->num != 0)
++			mode = 2;
++
++		/* These states has been taken care of in the read_fifo */
++		t &= ~((1 << ZLP_INTERRUPT) |
++				(1 << SHORT_OUT_PACKET_RECEIVED_INTERRUPT) |
++				(1 << DATA_OUT_PING_TOKEN_INTERRUPT) |
++				(1 << SHORT_OUT_PACKET_DONE_INTERRUPT));
++
++	/* data packet(s) transmitted (IN) */
++	} else if (t & (1 << DATA_PACKET_TRANSMITTED_INTERRUPT)) {
++		unsigned	len;
++
++		len = req->req.length - req->req.actual;
++		if (len > ep->ep.maxpacket)
++			len = ep->ep.maxpacket;
++		req->req.actual += len;
++
++		DBG("Xmit", req->req.actual, req->req.length, len);
++
++		/* if we wrote it all, we're usually done */
++		if (req->req.actual == req->req.length) {
++			if (ep->num == 0) {
++				/* send zlps until the status stage */
++			} else if (!req->req.zero || len != ep->ep.maxpacket)
++				mode = 2;
++		}
++
++	/* there was nothing to do ...  */
++	} else if (mode == 1)
++		goto out;
++
++	/* done */
++	if (mode == 2) {
++		/* stream endpoints often resubmit/unlink in completion */
++		done (ep, req, 0);
++
++		/* maybe advance queue to next request */
++		if (ep->num == 0) {
++			/* NOTE:  usb3380 could let gadget driver start the
++			 * status stage later. since not all controllers let
++			 * them control that, the api doesn't (yet) allow it.
++			 */
++			if (!ep->stopped) {
++				allow_status (ep);
++			}
++			req = NULL;
++			goto out;
++		} else {
++			if (!list_empty (&ep->queue) && !ep->stopped)
++				req = list_entry (ep->queue.next,
++					struct usb3380_request, queue);
++			else
++				req = NULL;
++			if (req && !ep->is_in) {
++				VLOG("SNak", ep->num, req->req.actual, req->req.length);
++				stop_out_naking (ep);
++			}
++		}
++	}
++
++	/* is there a buffer for the next packet?
++	 * for best streaming performance, make sure there is one.
++	 */
++	if (req && !ep->stopped) {
++		/* load IN fifo with next packet (may be zlp) */
++		if (t & (1 << DATA_PACKET_TRANSMITTED_INTERRUPT))
++			write_fifo (ep, &req->req);
++	}
++
++	return;
++out:
++	if (!ep->is_in)
++		writel (t & ~(1 << NAK_PACKETS), &ep->regs->ep_stat);
++}
++
++static void handle_stat0_irqs (struct usb3380 *dev, u32 stat)
++{
++	struct usb3380_ep	*ep;
++	u32			num, scratch;
++
++	/* most of these don't need individual acks */
++	stat &= ~(1 << INTA_ASSERTED);
++	if (!stat)
++		return;
++
++	DBG("Ist0", stat, 0, 0);
++
++	/* starting a control request? */
++	if (unlikely (stat & (1 << SETUP_PACKET_INTERRUPT_STATUS))) {
++		union {
++			u32 raw[2];
++			struct usb_ctrlrequest r;
++		} u;
++		int	tmp = 0;
++		struct usb3380_request *req;
++		u16 status;
++
++		if (dev->gadget.speed == USB_SPEED_UNKNOWN) {
++			u32 val = readl (&dev->usb->usbstat);
++			if (val & (1 << SUPER_SPEED_MODE)) {
++				dev->gadget.speed = USB_SPEED_SUPER;
++				dev->ep[0].ep.maxpacket = EP0_SS_MAX_PACKET_SIZE;
++			} else if (val & (1 << HIGH_SPEED_MODE)) {
++				dev->gadget.speed = USB_SPEED_HIGH;
++				dev->ep[0].ep.maxpacket = EP0_HS_MAX_PACKET_SIZE;
++			} else {
++				dev->gadget.speed = USB_SPEED_FULL;
++				dev->ep[0].ep.maxpacket = EP0_HS_MAX_PACKET_SIZE;
++			}
++			usb3380_led_speed (dev, dev->gadget.speed);
++			INFO("CSpd", dev->gadget.speed, 0, 0);
++		}
++
++		ep = &dev->ep [0];
++		ep->irqs++;
++
++		/* make sure any leftover request state is cleared */
++		stat &= ~(1 << ENDPOINT_0_INTERRUPT_STATUS);
++		while (!list_empty (&ep->queue)) {
++			req = list_entry (ep->queue.next, struct usb3380_request, queue);
++			done (ep, req, (req->req.actual == req->req.length)
++						? 0 : -EPROTO);
++		}
++
++		ep->stopped = 0;
++		ep->is_halt = 0;
++		dev->protocol_stall = 0;
++
++		writel ((1 << SHORT_OUT_PACKET_DONE_INTERRUPT) |
++				(1 << SHORT_OUT_PACKET_RECEIVED_INTERRUPT) |
++				(1 << DATA_PACKET_RECEIVED_INTERRUPT) |
++				(1 << DATA_PACKET_TRANSMITTED_INTERRUPT) |
++				(1 << DATA_OUT_PING_TOKEN_INTERRUPT) |
++				(1 << DATA_IN_TOKEN_INTERRUPT)
++				, &ep->regs->ep_stat);
++
++		u.raw [0] = readl (&dev->usb->setupdw0);
++		u.raw [1] = readl (&dev->usb->setupdw1);
++
++		cpu_to_le32s (&u.raw [0]);
++		cpu_to_le32s (&u.raw [1]);
++
++#define	w_value		le16_to_cpu(u.r.wValue)
++#define	w_index		le16_to_cpu(u.r.wIndex)
++#define	w_length	le16_to_cpu(u.r.wLength)
++
++		/* ack the irq */
++		writel (1 << SETUP_PACKET_INTERRUPT_STATUS, &dev->regs->irqstat0);
++		stat ^= (1 << SETUP_PACKET_INTERRUPT_STATUS);
++
++		/* watch control traffic at the token level, and force
++		 * synchronization before letting the status stage happen.
++		 * FIXME ignore tokens we'll NAK, until driver responds.
++		 * that'll mean a lot less irqs for some drivers.
++		 */
++		ep->is_in = (u.r.bRequestType & USB_DIR_IN) != 0;
++		if (ep->is_in) {
++			scratch = (1 << DATA_PACKET_TRANSMITTED_INTERRUPT_ENABLE) |
++				(1 << DATA_OUT_PING_TOKEN_INTERRUPT_ENABLE) |
++				(1 << DATA_IN_TOKEN_INTERRUPT_ENABLE);
++			stop_out_naking (ep);
++		} else
++			scratch = (1 << DATA_PACKET_RECEIVED_INTERRUPT_ENABLE) |
++				(1 << DATA_OUT_PING_TOKEN_INTERRUPT_ENABLE) |
++				(1 << DATA_IN_TOKEN_INTERRUPT_ENABLE);
++		writel (scratch, &dev->epregs [0].ep_irqenb);
++
++		/* we made the hardware handle most lowlevel requests;
++		 * everything else goes uplevel to the gadget code.
++		 */
++		ep->responded = 1;
++		switch (u.r.bRequest) {
++			struct usb3380_ep *e;
++
++			case USB_REQ_SET_CONFIGURATION:
++				if (w_value == 0)
++					dev->addressed_state = true;
++				else
++					dev->addressed_state = false;
++				goto delegate;
++			
++			case USB_REQ_GET_STATUS:
++
++			switch (u.r.bRequestType) {
++				case (USB_DIR_IN | USB_TYPE_STANDARD | USB_RECIP_DEVICE):
++					status = dev->wakeup_enable ? 0x02 : 0x00;
++					if (dev->selfpowered)
++						status |= 1<<0;
++					if (dev->gadget.speed == USB_SPEED_SUPER)
++						status |= (
++								dev->u1_enable << 2 |
++								dev->u2_enable << 3 |
++								dev->ltm_enable << 4);
++					else if (dev->wakeup_enable)
++						status |= 0x01;
++
++					writel (0, &dev->epregs[0].ep_irqenb);
++					set_fifo_bytecount(ep, sizeof(status));
++					writel ((__force u32)status, &dev->epregs[0].ep_data);
++					VLOG("Spk0", status, 0, 0);
++					allow_status(ep);
++					break;
++
++				case (USB_DIR_IN | USB_TYPE_STANDARD | USB_RECIP_ENDPOINT):
++					e = get_ep_by_addr (dev, w_index);
++					if (!e) goto do_stall;
++					
++					status = readl (&e->regs->ep_rsp) &
++						(1 << CLEAR_ENDPOINT_HALT);
++					
++					writel (0, &dev->epregs[0].ep_irqenb);
++					set_fifo_bytecount(ep, sizeof(status));
++					writel ((__force u32)status, &dev->epregs[0].ep_data);
++					allow_status(ep);
++					VLOG("Spk0", status, 0, 0);
++					break;
++
++				default:
++					goto delegate;
++			}
++			break;
++
++			case USB_REQ_CLEAR_FEATURE:
++
++			switch (u.r.bRequestType) {
++				case (USB_DIR_OUT | USB_TYPE_STANDARD | USB_RECIP_DEVICE):
++					if (dev->gadget.speed == USB_SPEED_SUPER &&
++						   !dev->addressed_state) {
++						switch (w_value) {
++							case USB_DEVICE_U1_ENABLE:
++								dev->u1_enable = 0;
++								writel (readl(&dev->usb->usbctl2) &
++										~(1 << U1_ENABLE)
++										, &dev->usb->usbctl2);
++								allow_status(ep);
++								goto next_endpoints;
++							case USB_DEVICE_U2_ENABLE:
++								dev->u2_enable = 0;
++								writel (readl(&dev->usb->usbctl2) &
++										~(1 << U2_ENABLE)
++										, &dev->usb->usbctl2);
++								allow_status(ep);
++								goto next_endpoints;
++							case USB_DEVICE_LTM_ENABLE:
++								dev->ltm_enable = 0;
++								writel (readl(&dev->usb->usbctl2) &
++										~(1 << LTM_ENABLE)
++										, &dev->usb->usbctl2);
++								allow_status(ep);
++								goto next_endpoints;
++							default:
++								break;
++						}
++					}
++					if (w_value == USB_DEVICE_REMOTE_WAKEUP) {
++						dev->wakeup_enable = 0;
++						writel (readl(&dev->usb->usbctl) &
++								~(1 << REMOTE_WAKEUP_ENABLE)
++								, &dev->usb->usbctl);
++						allow_status(ep);
++						break;
++					}
++					goto delegate;
++
++				case (USB_DIR_OUT | USB_TYPE_STANDARD | USB_RECIP_ENDPOINT):
++					e = get_ep_by_addr (dev, w_index);
++					if (!e) goto do_stall;
++
++					if (w_value != USB_ENDPOINT_HALT)
++						goto do_stall;
++
++					__ep_set_halt_and_wedge(e, false, false);
++					allow_status(ep);
++					break;
++
++				default:
++					goto delegate;
++			}
++			break;
++
++			case USB_REQ_SET_FEATURE:
++
++			switch (u.r.bRequestType) {
++				case (USB_DIR_OUT | USB_TYPE_STANDARD | USB_RECIP_DEVICE):
++					if (dev->gadget.speed == USB_SPEED_SUPER &&
++						   !dev->addressed_state) {
++						switch (w_value) {
++							case USB_DEVICE_U1_ENABLE:
++								dev->u1_enable = 1;
++								writel (readl(&dev->usb->usbctl2) |
++										(1 << U1_ENABLE)
++										, &dev->usb->usbctl2);
++								allow_status(ep);
++								goto next_endpoints;
++							case USB_DEVICE_U2_ENABLE:
++								dev->u2_enable = 1;
++								writel (readl(&dev->usb->usbctl2) |
++										(1 << U2_ENABLE)
++										, &dev->usb->usbctl2);
++								allow_status(ep);
++								goto next_endpoints;
++							case USB_DEVICE_LTM_ENABLE:
++								dev->ltm_enable = 1;
++								writel (readl(&dev->usb->usbctl2) |
++										(1 << LTM_ENABLE)
++										, &dev->usb->usbctl2);
++								allow_status(ep);
++								goto next_endpoints;
++							default:
++								break;
++						}
++					}
++					if (w_value == USB_DEVICE_REMOTE_WAKEUP) {
++						dev->wakeup_enable = 1;
++						writel (readl(&dev->usb->usbctl) |
++								(1 << REMOTE_WAKEUP_ENABLE)
++								, &dev->usb->usbctl);
++						allow_status(ep);
++						break;
++					}
++					goto delegate;
++
++				case (USB_DIR_OUT | USB_TYPE_STANDARD | USB_RECIP_ENDPOINT):
++					e = get_ep_by_addr (dev, w_index);
++					if (!e) goto do_stall;
++
++					if (w_value != USB_ENDPOINT_HALT)
++						goto do_stall;
++
++					__ep_set_halt_and_wedge(e, true, false);
++					allow_status(ep);
++					break;
++
++				default:
++					goto delegate;
++			}
++			break;
++
++			default:
++delegate:
++			VLOG("Spk4", u.r.bRequestType, u.r.bRequest, w_value);
++			VLOG("Spk5", w_index, w_length, readl(&ep->cfg->ep_cfg));
++			ep->responded = 0;
++			spin_unlock (&dev->lock);
++			tmp = dev->driver->setup (&dev->gadget, &u.r);
++			spin_lock (&dev->lock);
++		}
++
++		/* stall ep0 on error */
++		if (tmp < 0) {
++do_stall:
++			DBG("Stal", u.r.bRequestType, u.r.bRequest, tmp);
++			dev->protocol_stall = 1;
++		}
++
++		/* some in/out token irq should follow; maybe stall then.
++		 * driver must queue a request (even zlp) or halt ep0
++		 * before the host times out.
++		 */
++	}
++
++#undef	w_value
++#undef	w_index
++#undef	w_length
++
++next_endpoints:
++	/* endpoint 0, GPEPx (out if enhanced)  */
++	scratch = stat & 0x1f;
++	stat &= ~0x1f;
++	for (num = 0; scratch; num++) {
++		u32		t;
++		/* do this endpoint's FIFO and queue need tending? */
++		t = 1 << num;
++		if ((scratch & t) == 0)
++			continue;
++		scratch ^= t;
++
++		if (num == 0)
++			ep = &dev->ep[0];
++		else
++			ep = (enhanced) ? &dev->ep [num * 2 - 1] : &dev->ep [num];
++
++		handle_ep_intr (ep);
++	}
++	/* Bit 17..20 for GPEPx in */
++	scratch = (stat & 0x1e0000) >> 16;
++	stat &= ~0x1e000;
++	for (num = 1; enhanced && scratch; num++) {
++		u32 t = 1 << num;
++		if ((scratch & t) == 0)
++			continue;
++		scratch ^= t;
++		
++		ep = &dev->ep[num * 2];
++
++		handle_ep_intr (ep);
++	}
++
++	if (stat)
++		WARNING("Uis0", stat, 0, 0);
++}
++
++#define DMA_INTERRUPTS ( \
++		  (1 << DMA_3_INTERRUPT) \
++		| (1 << DMA_2_INTERRUPT) \
++		| (1 << DMA_1_INTERRUPT) \
++		| (1 << DMA_0_INTERRUPT))
++
++#define	PCI_ERROR_INTERRUPTS ( \
++		  (1 << PCI_MASTER_ABORT_RECEIVED_INTERRUPT) \
++		| (1 << PCI_TARGET_ABORT_RECEIVED_INTERRUPT))
++
++static void handle_stat1_irqs (struct usb3380 *dev, u32 stat)
++{
++	struct usb3380_ep *ep;
++	u32 num, mask, scratch, tmp;
++
++	/* after disconnect there's nothing else to do! */
++	tmp = (1 << VBUS_INTERRUPT) | (1 << ROOT_PORT_RESET_INTERRUPT);
++	mask = (1 << SUPER_SPEED_MODE) |
++		(1 << HIGH_SPEED_MODE) | (1 << FULL_SPEED_MODE);
++
++	/* VBUS disconnect is indicated by VBUS_PIN and VBUS_INTERRUPT set.
++	 * Root Port Reset is indicated by ROOT_PORT_RESET_INTERRRUPT set and
++	 * both HIGH_SPEED and FULL_SPEED clear (as ROOT_PORT_RESET_INTERRUPT
++	 * only indicates a change in the reset state).
++	 */
++	if (stat & tmp) {
++		writel (tmp, &dev->regs->irqstat1);
++		if ((((stat & (1 << ROOT_PORT_RESET_INTERRUPT))
++					&& ((readl (&dev->usb->usbstat) & mask) == 0)) ||
++			((readl (&dev->usb->usbctl) & (1 << VBUS_PIN)) == 0)) &&
++			    (dev->gadget.speed != USB_SPEED_UNKNOWN)) {
++			INFO("Dsct", 0, 0, 0);
++			stop_activity (dev, dev->driver);
++			ep0_start (dev);
++			return;
++		}
++		stat &= ~tmp;
++
++		/* vBUS can bounce ... one of many reasons to ignore the
++		 * notion of hotplug events on bus connect/disconnect!
++		 */
++		if (!stat)
++			return;
++	}
++
++	/* NOTE: chip stays in PCI D0 state for now, but it could
++	 * enter D1 to save more power
++	 */
++	tmp = (1 << SUSPEND_REQUEST_CHANGE_INTERRUPT);
++	if (stat & tmp) {
++		writel (tmp, &dev->regs->irqstat1);
++		if (stat & (1 << SUSPEND_REQUEST_INTERRUPT)) {
++			if (dev->driver->suspend)
++				dev->driver->suspend (&dev->gadget);
++			if (!enable_suspend)
++				stat &= ~(1 << SUSPEND_REQUEST_INTERRUPT);
++		} else {
++			if (dev->driver->resume)
++				dev->driver->resume (&dev->gadget);
++			/* at high speed, note erratum 0133 */
++		}
++		stat &= ~tmp;
++	}
++
++	/* clear any other status/irqs */
++	if (stat)
++		writel (stat, &dev->regs->irqstat1);
++
++	/* some status we can just ignore */
++	stat &= ~((1 << CONTROL_STATUS_INTERRUPT)
++			  | (1 << RESUME_INTERRUPT)
++			  | (1 << SOF_DOWNCOUNT_INTERRUPT)
++			  | (1 << SOF_INTERRUPT));
++
++	if (!stat)
++		return;
++
++	DBG("Ist1", stat, 0, 0);
++
++	/* DMA status */
++	scratch = stat & DMA_INTERRUPTS;
++	stat &= ~DMA_INTERRUPTS;
++	scratch >>= DMA_0_INTERRUPT;
++	for (num = 0; scratch; num++) {
++		struct usb3380_dma_regs	__iomem *dma;
++
++		tmp = 1 << num;
++		if ((tmp & scratch) == 0)
++			continue;
++		scratch ^= tmp;
++
++		ep = &dev->ep [num + 1];
++		dma = ep->dma;
++
++		if (!dma)
++			continue;
++
++		/* clear ep's dma status */
++		tmp = readl (&dma->dmastat);
++		writel (tmp, &dma->dmastat);
++
++		if ((tmp & (1 << DMA_TRANSACTION_DONE_INTERRUPT)) == 0) {
++			VLOG("None", stat, tmp, 0);
++			continue;
++		}
++
++		VLOG("Ddne", ep->num, tmp, 0);
++
++		scan_dma_completions (ep);
++
++		/* disable dma on inactive queues; else maybe restart */
++		if (list_empty (&ep->queue)) {
++			abort_dma(ep);
++		} else {
++			if (!dma_in_progress(ep))
++				restart_dma (ep);
++			else if (ep->is_in) {
++				struct usb3380_request	*req;
++				__le32			dmacount;
++				/* the descriptor at the head of the chain
++				 * may still have VALID_BIT clear; that's
++				 * used to trigger changing DMA_FIFO_VALIDATE
++				 * (affects automagic zlp writes).
++				 */
++				req = list_entry (ep->queue.next,
++						struct usb3380_request, queue);
++				dmacount = req->td->dmacount;
++				dmacount &= cpu_to_le32 (
++						(1 << VALID_BIT)
++						| DMA_TRANSFER_MAX_LENGTH);
++				VLOG("CVad", ep->num, dmacount, (u32)req->td_dma);
++				if (dmacount && (dmacount & valid_bit) == 0) {
++					restart_dma (ep);
++				}
++			}
++		}
++		ep->irqs++;
++	}
++
++	/* NOTE:  there are other PCI errors we might usefully notice.
++	 * if they appear very often, here's where to try recovering.
++	 */
++	if (stat & PCI_ERROR_INTERRUPTS) {
++		ERRMSG (dev, "pci dma error; stat %08x\n", stat);
++		stat &= ~PCI_ERROR_INTERRUPTS;
++		/* these are fatal errors, but "maybe" they won't
++		 * happen again ...
++		 */
++		stop_activity (dev, dev->driver);
++		ep0_start (dev);
++		stat = 0;
++	}
++
++	if (stat)
++		WARNING("Uis1", stat, 0, 0);
++}
++
++static irqreturn_t usb3380_intr (int irq, void *_dev)
++{
++	struct usb3380 *dev = _dev;
++
++	/* shared interrupt, not ours */
++	if (!(readl(&dev->regs->irqstat0) & (1 << INTA_ASSERTED)))
++		return IRQ_NONE;
++
++	spin_lock (&dev->lock);
++
++	/* handle disconnect, dma, and more */
++	handle_stat1_irqs (dev, readl (&dev->regs->irqstat1));
++
++	/* control requests and PIO */
++	handle_stat0_irqs (dev, readl (&dev->regs->irqstat0));
++
++	spin_unlock (&dev->lock);
++
++	return IRQ_HANDLED;
++}
++
++/*****************************************************************************/
++
++static void usb3380_shutdown (struct pci_dev *pdev)
++{
++	struct usb3380 *dev = pci_get_drvdata(pdev);
++
++	/* disable IRQs */
++	writel (0, &dev->regs->pciirqenb0);
++	writel (0, &dev->regs->pciirqenb1);
++
++	/* disable the pullup so the host will think we're gone */
++	writel (0, &dev->usb->usbctl);
++}
++
++static void usb3380_remove (struct pci_dev *pdev)
++{
++	struct usb3380 *dev = pci_get_drvdata(pdev);
++
++#ifdef USB_GADGET_NAPI
++	usb_del_gadget_udc(&dev->gadget);
++#endif
++	BUG_ON(dev->driver);
++
++	usb3380_led_shutdown(dev);
++
++	/* recycle the allocated resources */
++	if (dev->requests) {
++		int i;
++		for (i = 1; i < 5; i++) {
++			if (!dev->ep [i].dummy)
++				continue;
++#ifndef INTERNAL_DESCRIPTOR
++			pci_pool_free (dev->requests, dev->ep [i].dummy,
++					dev->ep [i].td_dma);
++#endif
++		}
++		pci_pool_destroy (dev->requests);
++	}
++
++	if (dev->got_irq)
++		free_irq (pdev->irq, dev);
++	if (dev->regs)
++		iounmap (dev->regs);
++	if (dev->region)
++		release_mem_region (pci_resource_start (pdev, 0),
++				pci_resource_len (pdev, 0));
++#if defined(USE_TUNE_LOOPHOST) && defined(INTERNAL_DESCRIPTOR)
++	if (dev->region_bar1)
++		release_mem_region (pci_resource_start (pdev, 1),
++				pci_resource_len (pdev, 1));
++#endif
++	if (dev->enabled)
++		pci_disable_device (pdev);
++
++	device_unregister (&dev->gadget.dev);
++	pci_set_drvdata (pdev, NULL);
++	usb3380_cleanup_debugfs(dev);
++	usb3380_cleanup_logger(dev);
++
++	INFOMSG(dev, "USB3380 driver unbound\n");
++
++	usb3380_controller = NULL;
++}
++
++static int __devinit usb3380_probe(struct pci_dev *pdev,
++				const struct pci_device_id *ent)
++{
++	struct usb3380	*dev;
++	unsigned long resource, len;
++	void __iomem *base;
++	int i, err = 0;
++
++	/* one controller only */
++	if (usb3380_controller) {
++		printk(KERN_WARNING "already probed\n");
++		return -EBUSY;
++	}
++
++	if (!pdev->irq) {
++		printk(KERN_ERR "Check PCI %s IRQ setup!\n", pci_name(pdev));
++		return -ENODEV;
++	}
++
++	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
++	if (NULL == dev) {
++		printk(KERN_ERR "enomem %s\n", pci_name(pdev));
++		return -ENOMEM;
++	}
++
++	err = usb3380_init_logger(dev, log_entries);
++	if (err) goto done;
++
++	spin_lock_init (&dev->lock);
++
++	dev->pdev = pdev;
++	dev->gadget.ops = &usb3380_ops;		/* usb_gadget_ops */
++
++	/* the "gadget" abstracts/virtualizes the controller */
++	dev_set_name(&dev->gadget.dev, "gadget");
++	dev->gadget.dev.parent = &pdev->dev;
++	dev->gadget.dev.dma_mask = pdev->dev.dma_mask;
++	dev->gadget.dev.release = gadget_release;
++	dev->gadget.name = driver_name;
++
++	/* now all the pci goodies ... */
++	if (pci_enable_device (pdev) < 0) {
++		ERRMSG(dev, "can't enable\n");
++		err = -ENODEV;
++		goto done;
++	}
++	dev->enabled = 1;
++
++	resource = pci_resource_start(pdev, 0);
++	len = pci_resource_len(pdev, 0);
++	if (!request_mem_region(resource, len, driver_name)) {
++		ERRMSG(dev, "controller already in use\n");
++		err = -EBUSY;
++		goto done;
++	}
++	dev->region = 1;
++
++	base = ioremap_nocache(resource, len);
++	if (!base) {
++		ERRMSG(dev, "cannot ioremap MMIO base\n");
++		err = -EFAULT;
++		goto done;
++	}
++
++#if defined(USE_TUNE_LOOPHOST) && defined(INTERNAL_DESCRIPTOR)
++	resource = pci_resource_start(pdev, 1);
++	len = pci_resource_len(pdev, 1);
++	if (!request_mem_region(resource, len, driver_name)) {
++		ERRMSG(dev, "cannot request memory region for BAR1\n");
++		err = -EBUSY;
++		goto done;
++	}
++	dev->region_bar1 = 1;
++
++	dev->pool_desc = ioremap_nocache(resource, len);
++	if (!dev->pool_desc) {
++		ERRMSG(dev, "cannot ioremap BAR1 iomem\n");
++		err = -EFAULT;
++		goto done;
++	}
++	/* if (desc-on-chip) virt(BAR1) == phys(0x4000) */
++	dev->pool_desc_dma = INTERNAL_DESCRIPTOR_OFFSET;
++#endif
++
++	dev->regs = (struct usb3380_regs __iomem *) base;
++	dev->usb = (struct usb3380_usb_regs __iomem *) (base + 0x0080);
++	dev->pci = (struct usb3380_pci_regs __iomem *) (base + 0x0100);
++	dev->dma = (struct usb3380_dma_regs __iomem *) (base + 0x0180);
++	dev->dmap = (struct usb3380_dmap_regs __iomem *) (base + 0x0680);
++	dev->dep = (struct usb3380_dep_regs __iomem *) (base + 0x0200);
++	dev->epcfg = (struct usb3380_ep_cfg __iomem *) (base + 0x0300);
++	dev->epregs = (struct usb3380_ep_regs __iomem *) (base + 0x0304);
++	dev->ffregs = (struct usb3380_fifo_regs __iomem *) (base + 0x0500);
++	dev->llregs = (struct usb3380_ll_regs __iomem *) (base + 0x0700);
++
++	/* Enhanced or Legacy Mode? */
++	enhanced = (readl(&dev->usb->usbstat) & (1 << ENHANCED_MODE)) ? 1 : 0;
++	ep_count = (enhanced) ? NR_EPS_ENHANCE : NR_EPS_LEGCY;
++
++	pci_set_drvdata(pdev, dev);
++
++	writel (0, &dev->usb->usbctl);
++	/* controller endpoints reinit */
++	usb_reset (dev);
++	usb_reinit (dev);
++
++	if (request_irq (pdev->irq, usb3380_intr, IRQF_SHARED, driver_name, dev)
++			!= 0) {
++		ERRMSG(dev, "request interrupt %d failed\n", pdev->irq);
++		err = -EBUSY;
++		goto done;
++	}
++	dev->got_irq = 1;
++
++	/* DMA setup */
++	dev->requests = pci_pool_create ("requests", pdev,
++		sizeof (struct usb3380_dma),
++		0 /* no alignment requirements */,
++		0 /* or page-crossing issues */);
++	if (!dev->requests) {
++		ERRMSG(dev, "can't get request data pool\n");
++		err = -ENOMEM;
++		goto done;
++	}
++
++	for (i = 1; i < 5; i++) {
++		struct usb3380_dma	*td;
++#if defined(USE_TUNE_LOOPHOST) && defined(INTERNAL_DESCRIPTOR)
++		td = bar_pool_alloc(dev, &dev->ep[i].td_dma);
++#else
++		td = pci_pool_alloc (dev->requests, GFP_KERNEL,
++				&dev->ep [i].td_dma);
++#endif
++		if (!td) {
++			ERRMSG(dev, "can't get dummy %d\n", i);
++			err = -ENOMEM;
++			goto done;
++		}
++		td->dmacount = 0;
++		td->dmaaddr = cpu_to_le32 (DMA_ADDR_INVALID);
++		td->dmadesc = td->dmaaddr;
++		dev->ep [i].dummy = td;
++	}
++
++	pci_set_master (pdev);
++	pci_try_set_mwi (pdev);
++
++	dev->chiprev = get_idx_reg (dev->regs, IDXREG_CHIPREV) & 0xffff;
++	/* done */
++	INFOMSG(dev, "%s\n", driver_desc);
++	INFOMSG(dev, "irq %d, pci mem %p, chip rev %04x\n",
++			pdev->irq, base, dev->chiprev);
++	INFOMSG(dev, "Driver version: " DRIVER_VERSION "\n");
++	INFOMSG(dev, "Mode: %s Adapter Mode\n",
++			enhanced ? "Enhanced" : "Legacy");
++	INFOMSG(dev, "DMA %s\n", use_dma ? "enabled" : "disabled");
++
++	usb3380_controller = dev;
++
++	err = device_register (&dev->gadget.dev);
++	if (err) goto done;
++
++	usb3380_init_debugfs(dev);
++
++#ifdef USB_GADGET_NAPI
++	err = usb_add_gadget_udc(&pdev->dev, &dev->gadget);
++	if (err) goto done;
++#endif
++
++	return 0;
++
++done:
++	if (dev)
++		usb3380_remove(pdev);
++
++	return err;
++}
++
++/*****************************************************************************/
++
++static DEFINE_PCI_DEVICE_TABLE(usb3380_pci_tbl) = {
++	PLX_USB_CONTROLLER_DEVICE(0x2380),
++	PLX_USB_CONTROLLER_DEVICE(0x3380),
++	PLX_USB_CONTROLLER_DEVICE(0x3382),
++	/* required last entry */
++	{0,}
++};
++
++MODULE_DEVICE_TABLE(pci, usb3380_pci_tbl);
++
++static struct pci_driver usb3380_driver = {
++	.name     = (char *) driver_name,
++	.id_table = usb3380_pci_tbl,
++
++	.probe    = usb3380_probe,
++	.remove   = __devexit_p(usb3380_remove),
++	.shutdown = usb3380_shutdown,
++};
++
++MODULE_AUTHOR("PLX Technology");
++MODULE_DESCRIPTION(DRIVER_DESC);
++MODULE_LICENSE("GPL");
++MODULE_VERSION(DRIVER_VERSION);
++
++/**
++ * usb3380_init_module - Driver Registration Routine
++ **/
++
++static int __init usb3380_init_module(void)
++{
++	return pci_register_driver (&usb3380_driver);
++}
++
++module_init(usb3380_init_module);
++
++/**
++ * usb3380_exit_module - Driver Exit Cleanup Routine
++ **/
++
++static void __exit usb3380_exit_module(void)
++{
++	pci_unregister_driver (&usb3380_driver);
++}
++
++module_exit(usb3380_exit_module);
++
+--- /dev/null
++++ b/drivers/usb/gadget/usb3380.h
+@@ -0,0 +1,289 @@
++
++#ifndef _USB3380_H_
++#define _USB3380_H_
++
++#include "usb3380_hw.h"
++
++#define PLX_USB_CONTROLLER_DEVICE(device_id) {	\
++	PCI_DEVICE(PCI_VENDOR_ID_PLX, device_id)}
++
++
++#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,0,0)) || \
++	defined(CONFIG_USB_GADGET_SUPERSPEED)
++#define USB_GADGET_NAPI
++#endif
++
++#define USE_RDK_LEDS
++#define USE_3380_FPGA
++//#define USE_TUNE_LOOPHOST
++//#define INTERNAL_DESCRIPTOR
++/****************************************************************************/
++#define LOGFMT "%-4.4s  %8.8x  %8.8x  %8.8x  "
++
++typedef enum {
++	LOG_ERR,
++	LOG_WARN,
++	LOG_INFO,
++	LOG_DEBUG,
++	LOG_VERBOSE,
++} log_level_t;
++
++typedef struct _log_entry {
++	u32 text;
++	u32 arg1;
++	u32 arg2;
++	u32 arg3;
++} log_entry_t;
++
++struct logger {
++	log_entry_t *queue;
++	unsigned int entries;
++	unsigned int rdptr, wrptr;
++};
++
++#define ERROR(text, arg1, arg2, arg3)	\
++	__dbglog(LOG_ERR, text, arg1, arg2, arg3)
++
++#define WARNING(text, arg1, arg2, arg3)	\
++	__dbglog(LOG_WARN, text, arg1, arg2, arg3)
++
++#define INFO(text, arg1, arg2, arg3)	\
++	__dbglog(LOG_INFO, text, arg1, arg2, arg3)
++
++#define DBG(text, arg1, arg2, arg3)	\
++	__dbglog(LOG_DEBUG, text, arg1, arg2, arg3)
++
++#define VLOG(text, arg1, arg2, arg3)	\
++	__dbglog(LOG_VERBOSE, text, arg1, arg2, arg3)
++
++#define xprintk(level, dev, fmt, args ...)	\
++		printk(level "%s %s: "	fmt, \
++				driver_name, pci_name(dev->pdev), ## args)
++
++#define DBGMSG(dev, fmt, args ...)	\
++	xprintk(KERN_DEBUG, dev, fmt, ## args)
++#define INFOMSG(dev, fmt, args ...)	\
++	xprintk(KERN_INFO, dev, fmt, ## args)
++#define ERRMSG(dev, fmt, args ...)	\
++	xprintk(KERN_ERR, dev, fmt, ## args)
++/*****************************************************************************/
++
++struct usb3380_dma {
++	__le32		dmacount;
++	__le32		dmaaddr;		/* the buffer */
++	__le32		dmadesc;		/* next dma descriptor */
++	__le32		_reserved;
++} __attribute__ ((aligned (16)));
++
++struct usb3380_ep {
++	struct usb_ep				ep;
++	struct usb3380_ep_cfg		__iomem *cfg;
++	struct usb3380_ep_regs		__iomem *regs;
++	struct usb3380_fifo_regs    __iomem *ffregs;
++	struct usb3380_dma_regs		__iomem *dma;
++	struct usb3380_dmap_regs	__iomem *dmap;
++	struct usb3380_dma			*dummy;
++	dma_addr_t					td_dma;	/* of dummy */
++	struct usb3380				*dev;
++	unsigned long				irqs;
++
++	/* analogous to a host-side qh */
++	struct list_head			queue;
++	const struct usb_endpoint_descriptor	*desc;
++	unsigned			num : 8,
++						fifo_size : 16,
++						in_fifo_validate : 1,
++						out_overflow : 1,
++						stopped : 1,
++						wedged : 1,
++						is_in : 1,
++						is_iso : 1,
++						in_zlp : 1,
++						responded : 1;
++	unsigned			is_halt : 1,
++						dma_started : 1;
++};
++
++struct usb3380_request {
++	struct usb_request		req;
++	struct usb3380_dma		*td;
++	dma_addr_t			td_dma;
++	struct list_head		queue;
++	unsigned			mapped : 1,
++					valid : 1;
++};
++
++struct usb3380_dep_regs {
++	/* offset 0x0200, 0x0210, 0x220, 0x230, 0x240, 0x250 */
++	u32     dep_cfg;
++	/* offset 0x0204, 0x0214, 0x224, 0x234, 0x244, 0x254 */
++	u32     dep_rsp;
++	u32     _unused[2];
++} __attribute__ ((packed));
++
++struct usb3380 {
++	/* each pci device provides one gadget, several endpoints */
++	struct usb_gadget			gadget;
++	spinlock_t					lock;
++	struct usb3380_ep			ep[9];
++	struct usb_gadget_driver 	*driver;
++	unsigned		enabled : 1,
++					protocol_stall : 1,
++					softconnect : 1,
++					got_irq : 1,
++					region : 1,
++#if defined(USE_TUNE_LOOPHOST) && defined(INTERNAL_DESCRIPTOR)
++					region_bar1 : 1,
++#endif
++					u1_enable: 1,
++					u2_enable: 1,
++					ltm_enable: 1,
++					wakeup_enable: 1,
++					selfpowered: 1,
++					addressed_state: 1;
++	u16				chiprev;
++
++	/* pci state used to access those endpoints */
++	struct pci_dev			*pdev;
++	struct usb3380_regs			__iomem *regs;
++	struct usb3380_usb_regs		__iomem *usb;
++	struct usb3380_pci_regs		__iomem *pci;
++	struct usb3380_dma_regs		__iomem *dma;
++	struct usb3380_dmap_regs	__iomem *dmap;
++	struct usb3380_dep_regs		__iomem *dep;
++	struct usb3380_ep_cfg		__iomem *epcfg;
++	struct usb3380_ep_regs		__iomem *epregs;
++	struct usb3380_fifo_regs	__iomem *ffregs;
++	struct usb3380_ll_regs		__iomem *llregs;
++
++	struct pci_pool			*requests;
++#ifdef CONFIG_USB_GADGET_DEBUG_FS
++	struct dentry               *debugfs_root;
++#endif
++	struct logger               logger;
++#if defined(USE_TUNE_LOOPHOST) && defined(INTERNAL_DESCRIPTOR)
++	void __iomem *pool_desc;
++	dma_addr_t pool_desc_dma;
++#endif
++};
++
++#ifdef USE_RDK_LEDS
++static inline void usb3380_led_init (struct usb3380 *dev)
++{
++	writel ((1 << GPIO3_LED_SELECT)
++		| (1 << GPIO3_OUTPUT_ENABLE)
++		| (1 << GPIO2_OUTPUT_ENABLE)
++		| (1 << GPIO1_OUTPUT_ENABLE)
++		| (1 << GPIO0_OUTPUT_ENABLE)
++		, &dev->regs->gpioctrl);
++}
++
++/* indicate speed with bi-color LED 0/1 */
++static inline
++void usb3380_led_speed (struct usb3380 *dev, enum usb_device_speed speed)
++{
++	u32	val = readl (&dev->regs->gpioctrl);
++	switch (speed) {
++	case USB_SPEED_HIGH:		/* green */
++		val &= ~(1 << GPIO0_DATA);
++		val |= (1 << GPIO1_DATA);
++		break;
++	case USB_SPEED_FULL:		/* red */
++		val &= ~(1 << GPIO1_DATA);
++		val |= (1 << GPIO0_DATA);
++		break;
++	case USB_SPEED_SUPER:
++		val |= (1 << GPIO0_DATA);
++		val |= (1 << GPIO1_DATA);
++		break;
++	default:			/* (off/black) */
++		val &= ~((1 << GPIO1_DATA) | (1 << GPIO0_DATA));
++		break;
++	}
++	writel (val, &dev->regs->gpioctrl);
++}
++
++/* indicate power with LED 2 */
++static inline void usb3380_led_active (struct usb3380 *dev, int is_active)
++{
++	u32	val = readl (&dev->regs->gpioctrl);
++
++	// FIXME this LED never seems to turn on.
++	if (is_active)
++		val |= GPIO2_DATA;
++	else
++		val &= ~GPIO2_DATA;
++	writel (val, &dev->regs->gpioctrl);
++}
++
++static inline void usb3380_led_shutdown (struct usb3380 *dev)
++{
++	/* turn off all four GPIO*_DATA bits */
++	writel (readl (&dev->regs->gpioctrl) & ~0x0f,
++			&dev->regs->gpioctrl);
++}
++#else /* USE_RDK_LEDS */
++
++#define usb3380_led_init(dev)		do { } while (0)
++#define usb3380_led_speed(dev, speed)	do { } while (0)
++#define usb3380_led_shutdown(dev)	do { } while (0)
++
++#endif
++
++static inline void allow_status (struct usb3380_ep *ep)
++{
++	/* ep0 only */
++#if 0
++	writel ((1 << CLEAR_CONTROL_STATUS_STAGE_HANDSHAKE) |
++			(1 << CLEAR_NAK_PACKETS) |
++			(1 << CLEAR_NAK_OUT_PACKETS_MODE)
++			, &ep->regs->ep_rsp);
++#endif
++	/* Control Status Phase Handshake was set by the chip when the setup
++	 * packet arrived. While set, the chip automatically NAKs the host's
++	 * Status Phase tokens.
++	 */
++	writel (1 << CLEAR_CONTROL_STATUS_STAGE_HANDSHAKE, &ep->regs->ep_rsp);
++	ep->stopped = 1;
++}
++
++static inline void start_out_naking (struct usb3380_ep *ep)
++{
++	writel ((1 << SET_NAK_PACKETS), &ep->regs->ep_rsp);
++}
++
++static inline void stop_out_naking (struct usb3380_ep *ep)
++{
++	writel ((1 << NAK_PACKETS), &ep->regs->ep_stat);
++}
++
++/* count (<= 4) bytes in the next fifo write will be valid */
++static inline void set_fifo_bytecount (struct usb3380_ep *ep, unsigned count)
++{
++	u32 tmp = readl(&ep->cfg->ep_cfg) & (~(0x07 << EP_FIFO_BYTE_COUNT));
++	writel (tmp | (count << EP_FIFO_BYTE_COUNT), &ep->cfg->ep_cfg);
++}
++
++static inline void ep_stall (struct usb3380_ep *ep, int stall)
++{
++	if (stall) {
++		writel ((1 << SET_ENDPOINT_HALT) |
++				//(1 << SET_NAK_PACKETS) |
++				(1 << CLEAR_CONTROL_STATUS_STAGE_HANDSHAKE)
++				, &ep->regs->ep_rsp);
++		ep->is_halt = 1;
++	} else {
++		writel ((1 << CLEAR_ENDPOINT_HALT)
++				//| (1 << CLEAR_NAK_PACKETS)
++				, &ep->regs->ep_rsp);
++		ep->is_halt = 0;
++	}
++}
++
++static inline int dma_in_progress(struct usb3380_ep *ep)
++{
++	return ep->dma_started && (readl (&ep->dma->dmactl) & (1 << DMA_ENABLE));
++}
++
++#endif
++
+--- /dev/null
++++ b/drivers/usb/gadget/usb3380_hw.h
+@@ -0,0 +1,593 @@
++
++#ifndef _USB3380_HW_H_
++#define _USB3380_HW_H_
++
++/* PCI Configuration Register Map */
++#define REG_DEVICE_STATUS_AND_CONTROL                       0x70
++#define     MAX_PAYLOAD_SIZE                            5   /* 7:5 */
++#define         MAX_PAYLOAD_128                         0   /* 000b */
++#define         MAX_PAYLOAD_256                         1   /* 001b */
++#define     MAX_READ_REQUEST_SIZE                       12  /* 14:12 */
++#define         MAX_READ_REQUEST_512                    2   /* 010b */
++#define         MAX_READ_REQUEST_1024                   3   /* 011b */
++#define         MAX_READ_REQUEST_2048                   4   /* 100b */
++#define         MAX_READ_REQUEST_4096                   5   /* 101b */
++
++/* main registers, BAR0 + 0x0000 */
++struct usb3380_regs {
++	/* offset 0x0000 */
++	u32		devinit;
++#define     LOCAL_CLOCK_FREQUENCY                       8	/* 11:8 */
++#define     FORCE_PCI_RESET                             7
++#define     PCI_ID                                      6
++#define     PCI_ENABLE                                  5
++#define     FIFO_SOFT_RESET                             4
++#define     CFG_SOFT_RESET                              3
++#define     PCI_SOFT_RESET                              2
++#define     USB_SOFT_RESET                              1
++#define     M8051_RESET                                 0
++	u32		eectl;
++	u32		eeclkfreq;
++	u32		_unused0;
++	/* offset 0x0010 */
++	u32		pciirqenb0;	/* PCIE Interrupt Request Enable 0 */
++#define     GPEP3_IN_PCIE_INTERRUPT                             20
++#define     GPEP2_IN_PCIE_INTERRUPT                             19
++#define     GPEP1_IN_PCIE_INTERRUPT                             18
++#define     GPEP0_IN_PCIE_INTERRUPT                             17
++#define     USB_IN_FIFO_TIMEOUT_PCIE_INTERRUPT_ENABLE           11
++#define     USB_CFG_RETRY_PCIE_INTERRUPT_ENABLE                 10
++#define     USB2PCIE_TLP_DRAINED_PORT_1_PCIE_INTERRUPT_ENABLE   9
++#define     USB2PCIE_TLP_DRAINED_PORT_0_PCIE_INTERRUPT_ENABLE   8
++#define     SETUP_PACKET_PCIE_INTERRUPT_ENABLE                  7
++#define     GPEP3_OUT_PCIE_INTERRUPT_ENABLE                     4
++#define     GPEP2_OUT_PCIE_INTERRUPT_ENABLE                     3
++#define     GPEP1_OUT_PCIE_INTERRUPT_ENABLE                     2
++#define     GPEP0_OUT_PCIE_INTERRUPT_ENABLE                     1
++#define     ENDPOINT_0_PCIE_INTERRUPT_ENABLE                    0
++	u32		pciirqenb1;	/* PCIE Interrupt Request Enable 1 */
++#define     GLOBAL_PCIE_INTERRUPT                               31
++#define     PCIE_ENDPOINT_POWER_MGMT_PCIE_INTERRUPT_ENABLE      30
++#define     PCIE_HOT_RESET_PCIE_INTERRUPT_ENABLE                29
++#define     PCIE_DL_DOWN_STATE_CHANGE_PCIE_INTERRUPT_ENABLE     28
++#define     POWER_STATE_CHANGE_PCIE_INTERRUPT_ENABLE            27
++#define     PCI_PARITY_ERROR_PCIE_INTERRUPT_ENABLE              25
++#define     PCI_MASTER_ABORT_RECEIVED_PCIE_INTERRUPT_ENABLE     20
++#define     PCI_TARGET_ABORT_RECEIVED_PCIE_INTERRUPT_ENABLE     19
++#define     PCIE_HOT_PLUG_PCIE_INTERRUPT_ENABLE                 18
++#define     PCI_MASTER_CYCLE_DONE_PCIE_INTERRUPT_ENABLE         16
++#define     SOF_DOWNCOUNT_PCIE_INTERRUPT_ENABLE                 14
++#define     GPIO_PCIE_INTERRUPT_ENABLE                          13
++#define     DMA_3_PCIE_INTERRUPT_ENABLE                         12
++#define     DMA_2_PCIE_INTERRUPT_ENABLE                         11
++#define     DMA_1_PCIE_INTERRUPT_ENABLE                         10
++#define     DMA_0_PCIE_INTERRUPT_ENABLE                         9
++#define     EEPROM_DONE_PCIE_INTERRUPT_ENABLE                   8
++#define     VBUS_PCIE_INTERRUPT_ENABLE                          7
++#define     CONTROL_STATUS_PCIE_INTERRUPT_ENABLE                6
++#define     ROOT_PORT_RESET_PCIE_INTERRUPT_ENABLE               4
++#define     SUSPEND_REQUEST_PCIE_INTERRUPT_ENABLE               3
++#define     SUSPEND_REQUEST_CHANGE_PCIE_INTERRUPT_ENABLE        2
++#define     RESUME_PCIE_INTERRUPT_ENABLE                        1
++#define     SOF_PCIE_INTERRUPT_ENABLE                           0
++	u32		cpuirqenb0;		/* 8051 Interrupt Request Enable 0 */
++#define     GPEP3_IN_8051_INTERRUPT_ENABLE                      20
++#define     GPEP2_IN_8051_INTERRUPT_ENABLE                      19
++#define     GPEP1_IN_8051_INTERRUPT_ENABLE                      18
++#define     GPEP0_IN_8051_INTERRUPT_ENABLE                      17
++#define     USB_IN_FIFO_TIMEOUT_8051_INTERRUPT_ENABLE           11
++#define     USB_CFG_RETRY_8051_INTERRUPT_ENABLE                 10
++#define     USB2PCIE_TLP_DRAINED_PORT_1_8051_INTERRUPT_ENABLE   9
++#define     USB2PCIE_TLP_DRAINED_PORT_0_8051_INTERRUPT_ENABLE   8
++#define     SETUP_PACKET_8051_INTERRUPT_ENABLE                  7
++#define     GPEP3_OUT_8051_INTERRUPT_ENABLE                     4
++#define     GPEP2_OUT_8051_INTERRUPT_ENABLE                     3
++#define     GPEP1_OUT_8051_INTERRUPT_ENABLE                     2
++#define     GPEP0_OUT_8051_INTERRUPT_ENABLE                     1
++#define     ENDPOINT_0_8051_INTERRUPT_ENABLE                    0
++	u32		cpuirqenb1;
++#define     GLOBAL_8051_INTERRUPT_ENABLE                        31
++#define     PCIE_ENDPOINT_POWER_MGMT_8051_INTERRUPT_ENABLE      30
++#define     PCIE_HOT_RESET_8051_INTERRUPT_ENABLE                29
++#define     PCIE_DL_DOWN_STATE_CHANGE_8051_INTERRUPT_ENABLE     28
++#define     POWER_STATE_CHANGE_8051_INTERRUPT_ENABLE            27
++#define     PCI_PARITY_ERROR_8051_INTERRUPT_ENABLE              25
++#define     PCI_INTA_8051_INTERRUPT_ENABLE                      24
++#define     PCI_MASTER_ABORT_RECEIVED_8051_INTERRUPT_ENABLE     20
++#define     PCI_TARGET_ABORT_RECEIVED_8051_INTERRUPT_ENABLE     19
++#define     PCIE_HOT_PLUG_8051_INTERRUPT_ENABLE                 18
++#define     PCI_MASTER_CYCLE_DONE_8051_INTERRUPT_ENABLE         16
++#define     SOF_DOWNCOUNT_8051_INTERRUPT_ENABLE                 14
++#define     GPIO_8051_INTERRUPT_ENABLE                          13
++#define     DMA_3_8051_INTERRUPT_ENABLE                         12
++#define     DMA_2_8051_INTERRUPT_ENABLE                         11
++#define     DMA_1_8051_INTERRUPT_ENABLE                         10
++#define     DMA_0_8051_INTERRUPT_ENABLE                         9
++#define     SERIAL_EEPROM_DONE_8051_INTERRUPT_ENABLE            8
++#define     VBUS_8051_INTERRUPT_ENABLE                          7
++#define     CONTROL_STATUS_8051_INTERRUPT_ENABLE                6
++#define     ROOT_PORT_RESET_8051_INTERRUPT_ENABLE               4
++#define     SUSPEND_REQUEST_8051_INTERRUPT_ENABLE               3
++#define     SUSPEND_REQUEST_CHANGE_8051_INTERRUPT_ENABLE        2
++#define     RESUME_8051_INTERRUPT_ENABLE                        1
++#define     SOF_8051_INTERRUPT_ENABLE                           0
++	/* offset 0x0020 */
++	u32		usbirqenb0;	/* Used only by firmware running on the 8051 */
++	u32		usbirqenb1; /* Reserved in Legacy Adapter mode */
++	u32		irqstat0;
++	/* GPEP[0..3]_IN_PCIE_INTERRUPT_STATUS - Enahnced Mode only */
++#define     GPEP3_IN_PCIE_INTERRUPT_STATUS                      20
++#define     GPEP2_IN_PCIE_INTERRUPT_STATUS                      19
++#define     GPEP1_IN_PCIE_INTERRUPT_STATUS                      18
++#define     GPEP0_IN_PCIE_INTERRUPT_STATUS                      17
++#define     INTA_ASSERTED                                       12
++#define     USB_IN_FIFO_TIMEOUT_INTERRUPT_STATUS                11
++#define     USB_CFG_RETRY_INTERRUPT_STATUS                      10
++#define     USB2PCIE_TLP_DRAINED_PORT_1_STATUS                  9
++#define     USB2PCIE_TLP_DRAINED_PORT_0_STATUS                  8
++#define     SETUP_PACKET_INTERRUPT_STATUS                       7
++#define     GPEP3_OUT_PCIE_INTERRUPT_STATUS                     4
++#define     GPEP2_OUT_PCIE_INTERRUPT_STATUS                     3
++#define     GPEP1_OUT_PCIE_INTERRUPT_STATUS                     2
++#define     GPEP0_OUT_PCIE_INTERRUPT_STATUS                     1
++#define     ENDPOINT_0_INTERRUPT_STATUS                         0
++	u32		irqstat1;
++#define     PCIE_ENDPOINT_POWER_MGMT_INTERRUPT                  30
++#define     PCIE_HOT_RESET_INTERRUPT                            29
++#define     PCIE_DL_DOWN_STATE_CHANGE_INTERRUPT                 28
++#define     POWER_STATE_CHANGE_INTERRUPT                        27
++#define     PCI_PARITY_ERROR_INTERRUPT                          25
++#define     PCI_INTA_INTERRUPT                                  24
++#define     PCI_MASTER_ABORT_RECEIVED_INTERRUPT                 20
++#define     PCI_TARGET_ABORT_RECEIVED_INTERRUPT                 19
++#define     PCIE_HOT_PLUG_INTERRUPT                             18
++#define     PCI_MASTER_CYCLE_DONE_INTERRUPT                     16
++#define     SOF_DOWNCOUNT_INTERRUPT                             14
++#define     GPIO_INTERRUPT                                      13
++#define     DMA_3_INTERRUPT                                     12
++#define     DMA_2_INTERRUPT                                     11
++#define     DMA_1_INTERRUPT                                     10
++#define     DMA_0_INTERRUPT                                     9
++#define     SERIAL_EEPROM_DONE_INTERRUPT                        8
++#define     VBUS_INTERRUPT                                      7
++#define     CONTROL_STATUS_INTERRUPT                            6
++#define     ROOT_PORT_RESET_INTERRUPT                           4
++#define     SUSPEND_REQUEST_INTERRUPT                           3
++#define     SUSPEND_REQUEST_CHANGE_INTERRUPT                    2
++#define     RESUME_INTERRUPT                                    1
++#define     SOF_INTERRUPT                                       0
++	/* Index Access Registers: offset 0x0030 */
++	u32		idxaddr;
++#define     IDXREG_DIAG            0x00
++#define     IDXREG_PKTLEN          0x01
++#define     IDXREG_FRAME           0x02
++#define     IDXREG_CHIPREV         0x03
++#define     IDXREG_UFRAME          0x04
++#define     IDXREG_FRAME_COUNT     0x05
++#define     IDXREG_HS_MAXPOWER     0x06
++#define     IDXREG_FS_MAXPOWER     0x07
++#define     IDXREG_HS_INTPOLL_RATE 0x08
++#define     IDXREG_FS_INTPOLL_RATE 0x09
++#define     HS_NAK_RATE            0x0a
++#define     SCRATCH                0x0b
++	/* Index 0ch - 1fh: Reserved */
++	/* Index 20h + n * 10h: GPEP[3:0/Out/In]_HS_MAXPKT */
++	u32		idxdata;
++	u32		fifoctl;
++#define     EP_ABCD_1K             0
++#define     EP_AB_2K               1
++#define     EP_A_2K_BC_1K          2
++	u32		bar2ctl;
++    u32		bar3ctl;
++	u32		_unused2[3];	/* 0x0044-0x004c */
++	/* offset 0x0050 */
++	u32		gpioctrl;
++#define     GPIO3_PWM_ENABLE                                    27
++#define     GPIO2_PWM_ENABLE                                    26
++#define     GPIO1_PWM_ENABLE                                    25
++#define     GPIO0_PWM_ENABLE                                    24
++#define     GPIO3_INPUT_DEBOUNCE_ENABLE                         19
++#define     GPIO2_INPUT_DEBOUNCE_ENABLE                         18
++#define     GPIO1_INPUT_DEBOUNCE_ENABLE                         17
++#define     GPIO0_INPUT_DEBOUNCE_ENABLE                         16
++#define     GPIO3_LED_SELECT                                    12
++#define     GPIO3_INTERRUPT_ENABLE                              11
++#define     GPIO2_INTERRUPT_ENABLE                              10
++#define     GPIO1_INTERRUPT_ENABLE                              9
++#define     GPIO0_INTERRUPT_ENABLE                              8
++#define     GPIO3_OUTPUT_ENABLE                                 7
++#define     GPIO2_OUTPUT_ENABLE                                 6
++#define     GPIO1_OUTPUT_ENABLE                                 5
++#define     GPIO0_OUTPUT_ENABLE                                 4
++#define     GPIO3_DATA                                          3
++#define     GPIO2_DATA                                          2
++#define     GPIO1_DATA                                          1
++#define     GPIO0_DATA                                          0
++	u32		gpiostat;
++#define     GPIO3_INTERRUPT                                     3
++#define     GPIO2_INTERRUPT                                     2
++#define     GPIO1_INTERRUPT                                     1
++#define     GPIO0_INTERRUPT                                     0
++} __attribute__ ((packed));
++
++/* usb control, BAR0 + 0x0080 */
++struct usb3380_usb_regs {
++	/* offset 0x0080 */
++	u32		stdrsp;
++#define     STALL_UNSUPPORTED_REQUESTS                          31
++#define     SET_ISOCHRONOUS_DELAY                               24
++#define     GET_STRING_DESCRIPTOR_3                             23
++#define     SET_SEL                                             22
++#define     GET_BOS_DESCRIPTOR                                  21
++#define     SET_CLR_LTM_ENABLE                                  20
++#define     SET_CLR_U2_ENABLE                                   19
++#define     SET_CLR_U1_ENABLE                                   18
++#define     SET_CLR_FUNCTION_SUSPEND                            17
++#define     SET_TEST_MODE                                       16
++#define     GET_OTHER_SPEED_CFG                                 15
++#define     GET_DEVICE_QUALIFIER                                14
++#define     SET_ADDRESS                                         13
++#define     ENDPOINT_SET_CLEAR_HALT                             12
++#define     DEVICE_SET_CLEAR_DEVICE_REMOTE_WAKEUP               11
++#define     GET_STRING_DESCRIPTOR_2                             10
++#define     GET_STRING_DESCRIPTOR_1                             9
++#define     GET_STRING_DESCRIPTOR_0                             8
++#define     GET_SET_INTERFACE                                   6
++#define     GET_SET_CFG                                         5
++#define     GET_CFG_DESCRIPTOR                                  4
++#define     GET_DEVICE_DESCRIPTOR                               3
++#define     GET_ENDPOINT_STATUS                                 2
++#define     GET_INTERFACE_STATUS                                1
++#define     GET_DEVICE_STATUS                                   0
++	u32		prodvendid;
++#define     PRODUCT_ID                                          16
++#define     VENDOR_ID                                           0
++	u32		relnum;
++#define     DEVICE_RELEASE_NUMBER                               0
++	u32		usbctl;
++#define     PRODUCT_ID_STRING_ENABLE                            13
++#define     VENDOR_ID_STRING_ENABLE                             12
++#define     USB_ROOT_PORT_WAKEUP_ENABLE                         11
++#define     VBUS_PIN                                            10
++#define     TIMED_DISCONNECT                                    9
++#define     IMMEDIATELY_SUSPEND                                 7
++#define     SELF_POWERED_USB_DEVICE                             6
++#define     REMOTE_WAKEUP_SUPPORT                               5
++#define     PME_POLARITY                                        4
++#define     USB_DETECT_ENABLE                                   3
++#define     PCIE_WAKEUP_ENABLE                                  2
++#define     REMOTE_WAKEUP_ENABLE                                1
++#define     SELF_POWERED_STATUS                                 0
++	/* offset 0x0090 */
++	u32		usbstat;
++#define     HOST_MODE                                           12
++#define     ENHANCED_MODE                                       11
++#define     REMOTE_WAKEUP_STATUS                                10
++#define     SUSPEND_STATUS                                      9
++#define     SUPER_SPEED_MODE                                    8
++#define     HIGH_SPEED_MODE                                     7
++#define     FULL_SPEED_MODE                                     6
++#define     GENERATE_RESUME                                     5
++#define     GENERATE_DEVICE_REMOTE_WAKEUP                       4
++	u32		xcvrdiag;
++#define     FORCE_HIGH_SPEED_MODE                               31
++#define     FORCE_FULL_SPEED_MODE                               30
++#define     USB_TEST_MODE                                       24	/* 26:24 */
++#define     LINE_STATE                                          16	/* 17:16 */
++#define     TRANSCEIVER_OPERATION_MODE                          2	/* 3:2 */
++#define     TRANSCEIVER_SELECT                                  1
++#define     TERMINATION_SELECT                                  0
++	u32		setupdw0;
++	u32		setupdw1;
++	/* offset 0x00A0 */
++	u32		_unused0;
++	u32		ouraddr;
++#define     FORCE_IMMEDIATE                                     7
++#define     OUR_USB_ADDRESS                                     0	/* 6:0 */
++	u32		ourconfig;
++	u32		_unused1[2];
++	/* offset 0x00B4 */
++	u32     usbclass;
++#define     DEVICE_PROTOCOL                     16	/* 23:16 */
++#define     DEVICE_SUB_CLASS                    8	/* 15:8 */
++#define     DEVICE_CLASS                        0	/* 7:0 */
++	u32		ss_sel;
++#define		U2_SYSTEM_EXIT_LATENCY				8	/* 23:8 */
++#define		U1_SYSTEM_EXIT_LATENCY				0	/* 7:0 */
++	u32		ss_del;
++#define		U2_DEVICE_EXIT_LATENCY				8	/* 23:8 */
++#define		U1_DEVICE_EXIT_LATENCY				0	/* 7:0 */
++	u32		usb2lpm;
++#define		USB_L1_LPM_HIRD                     2	/* 5:2 */
++#define		USB_L1_LPM_REMOTE_WAKE              1
++#define		USB_L1_LPM_SUPPORT                  0
++	u32		usb3belt;
++#define		BELT_MULTIPLIER					    10	/* 11:10 */
++#define		BEST_EFFORT_LATENCY_TOLERANCE		0	/* 9:0 */
++	u32		usbctl2;
++#define		LTM_ENABLE                          7
++#define		U2_ENABLE                           6
++#define		U1_ENABLE                           5
++#define		FUNCTION_SUSPEND                    4
++#define		USB3_CORE_ENABLE                    3
++#define		USB2_CORE_ENABLE                    2
++#define		SERIAL_NUMBER_STRING_ENABLE         0
++	u32		in_timeout;
++#define		GPEP3_TIMEOUT					19
++#define		GPEP2_TIMEOUT					18
++#define		GPEP1_TIMEOUT					17
++#define		GPEP0_TIMEOUT					16
++#define		GPEP3_TIMEOUT_VALUE				13	/* 15:13 */
++#define		GPEP3_TIMEOUT_ENABLE			12
++#define		GPEP2_TIMEOUT_VALUE				9	/* 11:9 */
++#define		GPEP2_TIMEOUT_ENABLE			8
++#define		GPEP1_TIMEOUT_VALUE				5	/* 7:5 */
++#define		GPEP1_TIMEOUT_ENABLE			4
++#define		GPEP0_TIMEOUT_VALUE				1	/* 3:1 */
++#define		GPEP0_TIMEOUT_ENABLE			0
++	u32		isodelay;
++#define		ISOCHRONOUS_DELAY				0
++} __attribute__ ((packed));
++
++/* pci control, BAR0 + 0x0100 */
++struct usb3380_pci_regs {
++	/* offset 0x0100 */
++	u32		 pcimstctl;
++#define		PCIE_DW_LENGTH					24	/* 30:24 */
++#define		PCIE_PORT						20
++#define		MESSAGE_TYPE					19
++#define		MESSAGE_ROUTING					16	/* 18:16 */
++#define		MESSAGE_CODE					8	/* 15:8 */
++#define		PCIE_MASTER_READ_WRITE			7
++#define		PCIE_MASTER_START				6
++#define		PCIE_MASTER_COMMAND_SELECT		4	/* 5:4 */
++#define		PCIE_FIRST_BYTE_ENABLES			0	/* 3:0 */
++	u32		 pcimstaddr;
++	u32		 pcimstdata;
++	u32		 pcimststat;
++#define     ROOT_COMPLEX_MODE               0
++	u32		csrctl;
++#define		CSR_ADDRESS                     16	/* 31:16 */
++#define		CSR_READ_WRITE                  7
++#define		CSR_START                       6
++#define		CSR_SPACE_SELECT                4	/* 5:4 */
++#define		CSR_BYTE_ENABLES                0	/* 3:0 */
++	u32		csrdata;
++#define		CSR_DATA                        0	/* 31:0 */
++	u32		semaphore;
++#define		CSR_SEMAPHORE					0
++	u32		pcimstmsg;
++#define		PCI_MASTER_MSG					0	/* 31:0 */
++} __attribute__ ((packed));
++
++/* dma control, BAR0 + 0x0180 */
++struct usb3380_dma_regs {
++	/* offset 0x0180, 0x01a0, 0x01c0, 0x01e0, */
++	u32		dmactl;
++#define     DMA_ABORT_DONE_INTERRUPT_ENABLE                     27
++#define     DMA_PAUSE_DONE_INTERRUPT_ENABLE                     26
++#define     DMA_DESCRIPTOR_DONE_INTERRUPT_ENABLE                25
++#define     PAUSE_MODE                                          23
++#define     PREFETCH_DISABLE                                    22
++#define     DMA_CLEAR_COUNT_ENABLE                              21
++#define     DESCRIPTOR_POLLING_RATE                             19	/* 20:19 */
++#define         POLL_CONTINUOUS                                 0
++#define         POLL_1_USEC                                     1
++#define         POLL_100_USEC                                   2
++#define         POLL_1_MSEC                                     3
++#define     DMA_VALID_BIT_POLLING_ENABLE                        18
++#define     DMA_VALID_BIT_ENABLE                                17
++#define     DMA_DESCRIPTOR_MODE                                 16
++#define     DMA_REQUEST_OUTSTANDING                             5	/* 7:5 */
++#define     DMA_OUT_AUTO_START_ENABLE                           4
++#define     DMA_FIFO_VALIDATE                                   2
++#define     DMA_ENABLE                                          1
++#define     DMA_ADDRESS_CONSTANT                                0
++	/* offset 0x184, 0x1a4, 0x1c4, 0x1e4 */
++	u32		dmastat;
++#define     DMA_COMPLETION_SEQUENCE_ERROR_STATUS                31
++#define     DMA_ABORT_DONE_INTERRUPT                            27
++#define     DMA_PAUSE_DONE_INTERRUPT                            26
++#define     DMA_LAST_DESCRIPTOR_DONE_INTERRUPT                  25
++#define     DMA_TRANSACTION_DONE_INTERRUPT                      24
++#define     DMA_ABORT                                           1
++#define     DMA_START                                           0
++	u32		_unused0[2];
++	/* offset 0x0190, 0x01b0, 0x01d0, 0x01f0 */
++	u32		dmacount;
++#define     VALID_BIT                                           31
++#define     DMA_DIRECTION                                       30
++#define     DMA_DONE_INTERRUPT_ENABLE                           29
++#define     LAST_DESCRIPTOR                                     28
++#define     DMA_DESCRIPTOR_FIFO_VALIDATE                        27
++#define     DMA_OUT_CONTINUE                                    24
++#define     DMA_TRANSFER_MAX_LENGTH                             ((1UL<<24)-1)
++#define     DMA_TRANSFER_LENGTH                                 0	/* 23:0 */
++	/* offset 0x194, 0x1b4, 0x1d4, 0x1f4 */
++	u32		dmaaddr;
++	/* offset 0x198, 0x1b8, 0x1d8, 0x1f8 */
++	u32		dmadesc;
++#define     DMA_DESC_ONCHIP                                     0
++	u32		_unused1;
++} __attribute__ ((packed));
++
++#define INTERNAL_DESCRIPTOR_OFFSET                              0x4000
++
++/* dma control, BAR0 + 0x0680 */
++struct usb3380_dmap_regs {
++	u32     dmacountp;
++	u32     dmaaddrp;
++	u32     dmadescp;
++	u32     _unused1;
++} __attribute__ ((packed));
++
++/* configurable endpoint registers, BAR0 + 0x0300
++ */
++struct usb3380_ep_cfg {
++	/* offset 0x300, 0x320, 0x340, 0x360, 0x380 */
++	u32		ep_cfg;
++#define     USAGE_TYPE                      30  /* Legacy/Enhanced: 31:30 */
++#define     SYNC_TYPE                       28  /* Legacy/Enhanced: 29:28 */
++#define     MAX_BURST_SIZE                  24  /* Legacy/Enhanced: 27:24 */
++#define     SERVICE_INTERVAL                19  /* Legacy/Enhanced: 23:19 */
++#define     EP_FIFO_BYTE_COUNT              16	/* 18:16 */
++#define     IN_EP_FORMAT                    15	/* Legacy/Enhanced */
++#define		IN_ENDPOINT_ENABLE				14	/* Enhanced */
++#define		IN_ENDPOINT_TYPE				12	/* Enhanced: 13:12 */
++#define     BYTE_PACKING_ENABLE             11
++#define     ENDPOINT_ENABLE					10	/* Legacy/ep0 */
++#define 	OUT_ENDPOINT_ENABLE				10	/* Enhanced */
++#define     ENDPOINT_TYPE					8	/* Legacy/ep0: 9:8 */
++#define		OUT_ENDPOINT_TYPE				8	/* Enhanced: 9:8 */
++#define     ENDPOINT_DIRECTION				7	/* Legacy/ep0 */
++#define     ENDPOINT_NUMBER					0	/* 3:0 */
++	u32		_unused0[7];
++};
++
++struct usb3380_ep_regs {
++	/* ep0, ep1-out/in, ep2-out/in, ep3-out/in, ep4-out/in */
++	/* offset 0x304, 0x324/0x3e4, 0x344/0x404, 0x364/0x424, 0x384/0x444 */
++	u32		ep_rsp;
++#define     SET_NAK_PACKETS                                     15
++#define     SET_EP_HIDE_STATUS_STAGE                            14
++#define     SET_EP_FORCE_CRC_ERROR                              13
++#define     SET_INTERRUPT_MODE                                  12
++#define     SET_CONTROL_STATUS_STAGE_HANDSHAKE                  11
++#define     SET_NAK_OUT_PACKETS_MODE                            10
++#define     SET_ENDPOINT_TOGGLE                                 9
++#define     SET_ENDPOINT_HALT                                   8
++#define     CLEAR_NAK_PACKETS                                   7
++#define     CLEAR_EP_HIDE_STATUS_STAGE                          6
++#define     CLEAR_EP_FORCE_CRC_ERROR                            5
++#define     CLEAR_INTERRUPT_MODE                                4
++#define     CLEAR_CONTROL_STATUS_STAGE_HANDSHAKE                3
++#define     CLEAR_NAK_OUT_PACKETS_MODE                          2
++#define     CLEAR_ENDPOINT_TOGGLE                               1
++#define     CLEAR_ENDPOINT_HALT                                 0
++	u32		ep_irqenb;
++#define     DMA_CHANNEL_INTERRUPT_ENABLE                        14
++#define     ZLP_INTERRUPT_ENABLE                                13
++#define     SHORT_PACKET_OUT_DONE_INTERRUPT_ENABLE              6
++#define     SHORT_PACKET_TRANSFERRED_INTERRUPT_ENABLE           5
++#define     DATA_PACKET_RECEIVED_INTERRUPT_ENABLE               3
++#define     DATA_PACKET_TRANSMITTED_INTERRUPT_ENABLE            2
++#define     DATA_OUT_PING_TOKEN_INTERRUPT_ENABLE                1
++#define     DATA_IN_TOKEN_INTERRUPT_ENABLE                      0
++	u32		ep_stat;
++#define     FIFO_VALID_COUNT                                    24
++#define     HIGH_BANDWIDTH_OUT_TRANSACTION_PID                  22
++#define     TIMEOUT                                             21
++#define     USB_STALL_SENT                                      20
++#define     USB_IN_NAK_SENT                                     19
++#define     USB_IN_ACK_RCVD                                     18
++#define     USB_OUT_NAK_SENT                                    17
++#define     USB_OUT_ACK_SENT                                    16
++#define     ZLP_INTERRUPT                                       13
++#define     FIFO_FULL                                           11
++#define     FIFO_EMPTY                                          10
++#define     FIFO_FLUSH                                          9
++#define     FIFO_VALIDATE                                       8
++#define     SHORT_PACKET_TRANSFERRED_STATUS                     7
++#define     SHORT_OUT_PACKET_DONE_INTERRUPT                     6
++#define     SHORT_OUT_PACKET_RECEIVED_INTERRUPT                 5
++#define     NAK_PACKETS                                         4
++#define     DATA_PACKET_RECEIVED_INTERRUPT                      3
++#define     DATA_PACKET_TRANSMITTED_INTERRUPT                   2
++#define     DATA_OUT_PING_TOKEN_INTERRUPT                       1
++#define     DATA_IN_TOKEN_INTERRUPT                             0
++	/* offset 0x310, 0x330/0x3f0, 0x350/0x410, 0x370/0x430, 0x390/0x450 */
++	u32		ep_avail;
++	u32		ep_data;
++	u32		ep_data1;
++	u32		ep_val;
++	u32		_unused0; 
++} __attribute__ ((packed));
++
++struct usb3380_fifo_regs {
++	/* offset 0x0500, 0x0520, 0x0540, 0x0560, 0x0580 */
++	u32		ep_fifo_size_base;
++#define     OUT_FIFO_SIZE                                       0	/* 2:0 */
++#define     FIFO_SIZE_64                                        0
++#define     FIFO_SIZE_128                                       1
++#define     FIFO_SIZE_256                                       2
++#define     FIFO_SIZE_512                                       3
++#define     FIFO_SIZE_1024                                      4
++#define     FIFO_SIZE_2048                                      5
++#define     FIFO_SIZE_4096                                      6
++#define     OUT_FIFO_BASE_ADDRESS                               6	/* 14:6 */
++#define     IN_FIFO_SIZE                                        16	/* 18:16 */
++#define     IN_FIFO_BASE_ADDRESS                                22	/* 30:22 */
++	u32		ep_fifo_out_wrptr;
++	u32		ep_fifo_out_rdptr;
++	u32		ep_fifo_in_wrptr;
++	u32		ep_fifo_in_rdptr;
++	u32		unused[3];
++} __attribute__ ((packed));
++
++struct usb3380_ll_regs {
++	/* offset 0x700 */
++	u32     ll_ltssm_ctrl1;
++	u32     ll_ltssm_ctrl2;
++	u32     ll_ltssm_ctrl3;
++	u32     unused[2];
++	/* offset 0x714 */
++	u32     ll_general_ctrl0;
++	u32     ll_general_ctrl1;
++#define     FORCE_DL_BIT                                        5
++#define     DL_BIT_VALUE_FMW                                    6
++#define     RESEND_DPP_ON_LRTY_FMW                              7
++#define     SKP_THRESHOLD_ADJUST_FMW                            8	/* 13:8 */
++#define     PM_U1_ENABLE                                        16
++#define     PM_U2_ENABLE                                        17
++#define     PM_DIR_ENTRY_U1                                     18
++#define     PM_DIR_ENTRY_U2                                     19
++#define     PM_DIR_ENTRY_U3                                     20
++#define     PM_FORCE_LINK_ACCEPT                                22
++#define     PM_DIR_LINK_REJECT                                  23
++#define     PM_LGO_COLLISION_SEND_LAU                           24
++#define     PM_FORCE_U1_ENTRY                                   25
++#define     PM_FORCE_U2_ENTRY                                   26
++#define     PM_U1_AUTO_EXIT                                     27
++#define     PM_U2_AUTO_EXIT                                     28
++#define     PM_U3_AUTO_EXIT                                     29
++	u32     ll_general_ctrl2;
++#define     FORCE_INVERT_LANE_POLARITY                          6
++#define     SELECT_INVERT_LANE_POLARITY                         7
++	u32     ll_general_ctrl3;
++	u32     ll_general_ctrl4;
++	u32     ll_error_gen;
++} __attribute__ ((packed));
++
++/* 
++ * Indexed Register
++ */
++static inline u32
++get_idx_reg (struct usb3380_regs __iomem *regs, u32 index)
++{
++	writel (index, &regs->idxaddr);
++	/* NOTE:  synchs device/cpu memory views */
++	return readl (&regs->idxdata);
++}
++
++static inline void
++set_idx_reg (struct usb3380_regs __iomem *regs, u32 index, u32 value)
++{
++	writel (index, &regs->idxaddr);
++	writel (value, &regs->idxdata);
++	/* posted, may not be visible yet */
++}
++
++/****************************************************************************/
++#define NR_DMA_CHANNEL  4	/* Number of DMA channel */
++
++#define NR_EPS_LEGCY    4	/* 4 endpoints in legacy mode */
++#define NR_EPS_ENHANCE  8	/* 8 endpoints in enhanced mode */
++
++#define EP0_HS_MAX_PACKET_SIZE	0x40	/* 64 */
++#define EP0_SS_MAX_PACKET_SIZE	0x200	/* 512 */
++
++
++/****************************************************************************/
++
++#endif
++
+--- a/drivers/usb/gadget/zero.c
++++ b/drivers/usb/gadget/zero.c
+@@ -102,7 +102,11 @@ module_param(loopdefault, bool, S_IRUGO|
+  */
+ #ifndef	CONFIG_USB_ZERO_HNPTEST
+ #define DRIVER_VENDOR_NUM	0x0525		/* NetChip */
++#ifdef CONFIG_PLX_LOOPHOST_TEST
++#define DRIVER_PRODUCT_NUM	0x1000		/* Linux-USB "Gadget Zero" */
++#else
+ #define DRIVER_PRODUCT_NUM	0xa4a0		/* Linux-USB "Gadget Zero" */
++#endif
+ #define DEFAULT_AUTORESUME	0
+ #else
+ #define DRIVER_VENDOR_NUM	0x1a0a		/* OTG test device IDs */
+@@ -110,6 +114,7 @@ module_param(loopdefault, bool, S_IRUGO|
+ #define DEFAULT_AUTORESUME	5
+ #endif
+ 
++
+ /* If the optional "autoresume" mode is enabled, it provides good
+  * functional coverage for the "USBCV" test harness from USB-IF.
+  * It's always set if OTG mode is enabled.
+@@ -340,6 +345,7 @@ static struct usb_composite_driver zero_
+ 	.name		= "zero",
+ 	.dev		= &device_desc,
+ 	.strings	= dev_strings,
++	.max_speed	= USB_SPEED_SUPER,
+ 	.unbind		= zero_unbind,
+ 	.suspend	= zero_suspend,
+ 	.resume		= zero_resume,
+--- a/include/linux/usb/composite.h
++++ b/include/linux/usb/composite.h
+@@ -37,6 +37,14 @@
+ #include <linux/usb/ch9.h>
+ #include <linux/usb/gadget.h>
+ 
++/*
++ * USB function drivers should return USB_GADGET_DELAYED_STATUS if they
++ * wish to delay the data/status stages of the control transfer till they
++ * are ready. The control transfer will then be kept from completing till
++ * all the function drivers that requested for USB_GADGET_DELAYED_STAUS
++ * invoke usb_composite_setup_continue().
++ */
++#define USB_GADGET_DELAYED_STATUS       0x7fff	/* Impossibly large value */
+ 
+ struct usb_configuration;
+ 
+@@ -51,6 +59,10 @@ struct usb_configuration;
+  * @hs_descriptors: Table of high speed descriptors, using interface and
+  *	string identifiers assigned during @bind().  If this pointer is null,
+  *	the function will not be available at high speed.
++ * @ss_descriptors: Table of super speed descriptors, using interface and
++ *	string identifiers assigned during @bind(). If this
++ *	pointer is null after initiation, the function will not
++ *	be available at super speed.
+  * @config: assigned when @usb_add_function() is called; this is the
+  *	configuration with which this function is associated.
+  * @bind: Before the gadget can register, all of its functions bind() to the
+@@ -69,6 +81,10 @@ struct usb_configuration;
+  * @setup: Used for interface-specific control requests.
+  * @suspend: Notifies functions when the host stops sending USB traffic.
+  * @resume: Notifies functions when the host restarts USB traffic.
++ * @get_status: Returns function status as a reply to
++ *	GetStatus() request when the recepient is Interface.
++ * @func_suspend: callback to be called when
++ *	SetFeature(FUNCTION_SUSPEND) is reseived
+  *
+  * A single USB function uses one or more interfaces, and should in most
+  * cases support operation at both full and high speeds.  Each function is
+@@ -98,6 +114,7 @@ struct usb_function {
+ 	struct usb_gadget_strings	**strings;
+ 	struct usb_descriptor_header	**descriptors;
+ 	struct usb_descriptor_header	**hs_descriptors;
++	struct usb_descriptor_header	**ss_descriptors;
+ 
+ 	struct usb_configuration	*config;
+ 
+@@ -124,6 +141,11 @@ struct usb_function {
+ 	void			(*suspend)(struct usb_function *);
+ 	void			(*resume)(struct usb_function *);
+ 
++	/* USB 3.0 additions */
++	int			(*get_status)(struct usb_function *);
++	int			(*func_suspend)(struct usb_function *,
++						u8 suspend_opt);
++
+ 	/* private: */
+ 	/* internals */
+ 	struct list_head		list;
+@@ -137,20 +159,8 @@ int usb_function_activate(struct usb_fun
+ 
+ int usb_interface_id(struct usb_configuration *, struct usb_function *);
+ 
+-/**
+- * ep_choose - select descriptor endpoint at current device speed
+- * @g: gadget, connected and running at some speed
+- * @hs: descriptor to use for high speed operation
+- * @fs: descriptor to use for full or low speed operation
+- */
+-static inline struct usb_endpoint_descriptor *
+-ep_choose(struct usb_gadget *g, struct usb_endpoint_descriptor *hs,
+-		struct usb_endpoint_descriptor *fs)
+-{
+-	if (gadget_is_dualspeed(g) && g->speed == USB_SPEED_HIGH)
+-		return hs;
+-	return fs;
+-}
++int config_ep_by_speed(struct usb_gadget *g, struct usb_function *f,
++			struct usb_ep *_ep);
+ 
+ #define	MAX_CONFIG_INTERFACES		16	/* arbitrary; max 255 */
+ 
+@@ -223,6 +233,7 @@ struct usb_configuration {
+ 	struct list_head	list;
+ 	struct list_head	functions;
+ 	u8			next_interface_id;
++	unsigned		superspeed:1;
+ 	unsigned		highspeed:1;
+ 	unsigned		fullspeed:1;
+ 	struct usb_function	*interface[MAX_CONFIG_INTERFACES];
+@@ -271,6 +282,7 @@ struct usb_composite_driver {
+ 	const char				*iManufacturer;
+ 	const struct usb_device_descriptor	*dev;
+ 	struct usb_gadget_strings		**strings;
++	enum usb_device_speed			max_speed;
+ 	unsigned		needs_serial:1;
+ 
+ 	int			(*unbind)(struct usb_composite_dev *);
+@@ -285,6 +297,7 @@ struct usb_composite_driver {
+ extern int usb_composite_probe(struct usb_composite_driver *driver,
+ 			       int (*bind)(struct usb_composite_dev *cdev));
+ extern void usb_composite_unregister(struct usb_composite_driver *driver);
++extern void usb_composite_setup_continue(struct usb_composite_dev *cdev);
+ 
+ 
+ /**
+@@ -342,8 +355,14 @@ struct usb_composite_dev {
+ 	 */
+ 	unsigned			deactivations;
+ 
++	/* the composite driver won't complete the control transfer's
++	 * data/status stages till delayed_status is zero.
++	 */
++	int				delayed_status;
++
+ 	/* protects at least deactivation count */
+ 	spinlock_t			lock;
++	u8              devstatus;
+ };
+ 
+ extern int usb_string_id(struct usb_composite_dev *c);
+--- a/include/linux/usb/gadget.h
++++ b/include/linux/usb/gadget.h
+@@ -15,7 +15,13 @@
+ #ifndef __LINUX_USB_GADGET_H
+ #define __LINUX_USB_GADGET_H
+ 
++#include <linux/device.h>
++#include <linux/errno.h>
++#include <linux/init.h>
++#include <linux/list.h>
+ #include <linux/slab.h>
++#include <linux/types.h>
++#include <linux/usb/ch9.h>
+ 
+ struct usb_ep;
+ 
+@@ -27,6 +33,7 @@ struct usb_ep;
+  *	field, and the usb controller needs one, it is responsible
+  *	for mapping and unmapping the buffer.
+  * @length: Length of that data
++ * @stream_id: The stream id, when USB3.0 bulk streams are being used
+  * @no_interrupt: If true, hints that no completion irq is needed.
+  *	Helpful sometimes with deep request queues that are handled
+  *	directly by DMA controllers.
+@@ -81,6 +88,7 @@ struct usb_request {
+ 	unsigned		length;
+ 	dma_addr_t		dma;
+ 
++	unsigned		stream_id:16;
+ 	unsigned		no_interrupt:1;
+ 	unsigned		zero:1;
+ 	unsigned		short_not_ok:1;
+@@ -131,8 +139,17 @@ struct usb_ep_ops {
+  * @maxpacket:The maximum packet size used on this endpoint.  The initial
+  *	value can sometimes be reduced (hardware allowing), according to
+  *      the endpoint descriptor used to configure the endpoint.
+- * @driver_data:for use by the gadget driver.  all other fields are
+- *	read-only to gadget drivers.
++ * @max_streams: The maximum number of streams supported
++ *	by this EP (0 - 16, actual number is 2^n)
++ * @mult: multiplier, 'mult' value for SS Isoc EPs
++ * @maxburst: the maximum number of bursts supported by this EP (for usb3)
++ * @driver_data:for use by the gadget driver.
++ * @address: used to identify the endpoint when finding descriptor that
++ *	matches connection speed
++ * @desc: endpoint descriptor.  This pointer is set before the endpoint is
++ *	enabled and remains valid until the endpoint is disabled.
++ * @comp_desc: In case of SuperSpeed support, this is the endpoint companion
++ *	descriptor that is used to configure the endpoint
+  *
+  * the bus controller driver lists all the general purpose endpoints in
+  * gadget->ep_list.  the control endpoint (gadget->ep0) is not in that list,
+@@ -145,6 +162,12 @@ struct usb_ep {
+ 	const struct usb_ep_ops	*ops;
+ 	struct list_head	ep_list;
+ 	unsigned		maxpacket:16;
++	unsigned		max_streams:16;
++	unsigned		mult:2;
++	unsigned		maxburst:4;
++	u8			address;
++	const struct usb_endpoint_descriptor	*desc;
++	const struct usb_ss_ep_comp_descriptor	*comp_desc;
+ };
+ 
+ /*-------------------------------------------------------------------------*/
+@@ -153,9 +176,6 @@ struct usb_ep {
+  * usb_ep_enable - configure endpoint, making it usable
+  * @ep:the endpoint being configured.  may not be the endpoint named "ep0".
+  *	drivers discover endpoints through the ep_list of a usb_gadget.
+- * @desc:descriptor for desired behavior.  caller guarantees this pointer
+- *	remains valid until the endpoint is disabled; the data byte order
+- *	is little-endian (usb-standard).
+  *
+  * when configurations are set, or when interface settings change, the driver
+  * will enable or disable the relevant endpoints.  while it is enabled, an
+@@ -172,10 +192,9 @@ struct usb_ep {
+  *
+  * returns zero, or a negative error code.
+  */
+-static inline int usb_ep_enable(struct usb_ep *ep,
+-				const struct usb_endpoint_descriptor *desc)
++static inline int usb_ep_enable(struct usb_ep *ep)
+ {
+-	return ep->ops->enable(ep, desc);
++	return ep->ops->enable(ep, ep->desc);
+ }
+ 
+ /**
+@@ -416,7 +435,15 @@ static inline void usb_ep_fifo_flush(str
+ 
+ /*-------------------------------------------------------------------------*/
+ 
++struct usb_dcd_config_params {
++	__u8  bU1devExitLat;	/* U1 Device exit Latency */
++#define USB_DEFULT_U1_DEV_EXIT_LAT	0x01	/* Less then 1 microsec */
++	__le16 bU2DevExitLat;	/* U2 Device exit Latency */
++#define USB_DEFULT_U2_DEV_EXIT_LAT	0x1F4	/* Less then 500 microsec */
++};
++
+ struct usb_gadget;
++struct usb_gadget_driver;
+ 
+ /* the rest of the api to the controller hardware: device operations,
+  * which don't involve endpoints (or i/o).
+@@ -430,6 +457,16 @@ struct usb_gadget_ops {
+ 	int	(*pullup) (struct usb_gadget *, int is_on);
+ 	int	(*ioctl)(struct usb_gadget *,
+ 				unsigned code, unsigned long param);
++	void	(*get_config_params)(struct usb_dcd_config_params *);
++	int	(*udc_start)(struct usb_gadget *,
++			struct usb_gadget_driver *);
++	int	(*udc_stop)(struct usb_gadget *,
++			struct usb_gadget_driver *);
++
++	/* Those two are deprecated */
++	int	(*start)(struct usb_gadget_driver *,
++			int (*bind)(struct usb_gadget *));
++	int	(*stop)(struct usb_gadget_driver *);
+ };
+ 
+ /**
+@@ -521,6 +558,24 @@ static inline int gadget_is_dualspeed(st
+ }
+ 
+ /**
++ * gadget_is_superspeed() - return true if the hardware handles
++ * supperspeed
++ * @g: controller that might support supper speed
++ */
++static inline int gadget_is_superspeed(struct usb_gadget *g)
++{
++#ifdef CONFIG_USB_GADGET_SUPERSPEED
++	/*
++	 * runtime test would check "g->is_superspeed" ... that might be
++	 * useful to work around hardware bugs, but is mostly pointless
++	 */
++	return 1;
++#else
++	return 0;
++#endif
++}
++
++/**
+  * gadget_is_otg - return true iff the hardware is OTG-ready
+  * @g: controller that might have a Mini-AB connector
+  *
+@@ -821,6 +876,9 @@ int usb_gadget_probe_driver(struct usb_g
+  */
+ int usb_gadget_unregister_driver(struct usb_gadget_driver *driver);
+ 
++extern int usb_add_gadget_udc(struct device *parent, struct usb_gadget *gadget);
++extern void usb_del_gadget_udc(struct usb_gadget *gadget);
++
+ /*-------------------------------------------------------------------------*/
+ 
+ /* utility to simplify dealing with string descriptors */
+@@ -870,12 +928,6 @@ int usb_gadget_config_buf(const struct u
+ struct usb_descriptor_header **usb_copy_descriptors(
+ 		struct usb_descriptor_header **);
+ 
+-/* return copy of endpoint descriptor given original descriptor set */
+-struct usb_endpoint_descriptor *usb_find_endpoint(
+-	struct usb_descriptor_header **src,
+-	struct usb_descriptor_header **copy,
+-	struct usb_endpoint_descriptor *match);
+-
+ /**
+  * usb_free_descriptors - free descriptors returned by usb_copy_descriptors()
+  * @v: vector of descriptors
+@@ -890,8 +942,12 @@ static inline void usb_free_descriptors(
+ /* utility wrapping a simple endpoint selection policy */
+ 
+ extern struct usb_ep *usb_ep_autoconfig(struct usb_gadget *,
+-			struct usb_endpoint_descriptor *) __devinit;
++			struct usb_endpoint_descriptor *);
++
++extern struct usb_ep *usb_ep_autoconfig_ss(struct usb_gadget *,
++			struct usb_endpoint_descriptor *,
++			struct usb_ss_ep_comp_descriptor *);
+ 
+-extern void usb_ep_autoconfig_reset(struct usb_gadget *) __devinit;
++extern void usb_ep_autoconfig_reset(struct usb_gadget *);
+ 
+ #endif /* __LINUX_USB_GADGET_H */
+--- a/drivers/usb/gadget/ether.c
++++ b/drivers/usb/gadget/ether.c
+@@ -401,6 +401,7 @@ static struct usb_composite_driver eth_d
+ 	.name		= "g_ether",
+ 	.dev		= &device_desc,
+ 	.strings	= dev_strings,
++	.max_speed	= USB_SPEED_SUPER,
+ 	.unbind		= __exit_p(eth_unbind),
+ };
+ 
+--- a/drivers/usb/gadget/f_ecm.c
++++ b/drivers/usb/gadget/f_ecm.c
+@@ -46,11 +46,6 @@
+  * and also means that a get_alt() method is required.
+  */
+ 
+-struct ecm_ep_descs {
+-	struct usb_endpoint_descriptor	*in;
+-	struct usb_endpoint_descriptor	*out;
+-	struct usb_endpoint_descriptor	*notify;
+-};
+ 
+ enum ecm_notify_state {
+ 	ECM_NOTIFY_NONE,		/* don't notify */
+@@ -64,11 +59,7 @@ struct f_ecm {
+ 
+ 	char				ethaddr[14];
+ 
+-	struct ecm_ep_descs		fs;
+-	struct ecm_ep_descs		hs;
+-
+ 	struct usb_ep			*notify;
+-	struct usb_endpoint_descriptor	*notify_desc;
+ 	struct usb_request		*notify_req;
+ 	u8				notify_state;
+ 	bool				is_open;
+@@ -86,10 +77,12 @@ static inline struct f_ecm *func_to_ecm(
+ /* peak (theoretical) bulk transfer rate in bits-per-second */
+ static inline unsigned ecm_bitrate(struct usb_gadget *g)
+ {
+-	if (gadget_is_dualspeed(g) && g->speed == USB_SPEED_HIGH)
++	if (gadget_is_superspeed(g) && g->speed == USB_SPEED_SUPER)
++		return 13 * 1024 * 8 * 1000 * 8;
++	else if (gadget_is_dualspeed(g) && g->speed == USB_SPEED_HIGH)
+ 		return 13 * 512 * 8 * 1000 * 8;
+ 	else
+-		return 19 *  64 * 1 * 1000 * 8;
++		return 19 * 64 * 1 * 1000 * 8;
+ }
+ 
+ /*-------------------------------------------------------------------------*/
+@@ -219,8 +212,10 @@ static struct usb_descriptor_header *ecm
+ 	(struct usb_descriptor_header *) &ecm_header_desc,
+ 	(struct usb_descriptor_header *) &ecm_union_desc,
+ 	(struct usb_descriptor_header *) &ecm_desc,
++
+ 	/* NOTE: status endpoint might need to be removed */
+ 	(struct usb_descriptor_header *) &fs_ecm_notify_desc,
++
+ 	/* data interface, altsettings 0 and 1 */
+ 	(struct usb_descriptor_header *) &ecm_data_nop_intf,
+ 	(struct usb_descriptor_header *) &ecm_data_intf,
+@@ -240,6 +235,7 @@ static struct usb_endpoint_descriptor hs
+ 	.wMaxPacketSize =	cpu_to_le16(ECM_STATUS_BYTECOUNT),
+ 	.bInterval =		LOG2_STATUS_INTERVAL_MSEC + 4,
+ };
++
+ static struct usb_endpoint_descriptor hs_ecm_in_desc = {
+ 	.bLength =		USB_DT_ENDPOINT_SIZE,
+ 	.bDescriptorType =	USB_DT_ENDPOINT,
+@@ -264,8 +260,10 @@ static struct usb_descriptor_header *ecm
+ 	(struct usb_descriptor_header *) &ecm_header_desc,
+ 	(struct usb_descriptor_header *) &ecm_union_desc,
+ 	(struct usb_descriptor_header *) &ecm_desc,
++
+ 	/* NOTE: status endpoint might need to be removed */
+ 	(struct usb_descriptor_header *) &hs_ecm_notify_desc,
++
+ 	/* data interface, altsettings 0 and 1 */
+ 	(struct usb_descriptor_header *) &ecm_data_nop_intf,
+ 	(struct usb_descriptor_header *) &ecm_data_intf,
+@@ -274,6 +272,76 @@ static struct usb_descriptor_header *ecm
+ 	NULL,
+ };
+ 
++/* super speed support: */
++
++static struct usb_endpoint_descriptor ss_ecm_notify_desc = {
++	.bLength =		USB_DT_ENDPOINT_SIZE,
++	.bDescriptorType =	USB_DT_ENDPOINT,
++
++	.bEndpointAddress =	USB_DIR_IN,
++	.bmAttributes =		USB_ENDPOINT_XFER_INT,
++	.wMaxPacketSize =	cpu_to_le16(ECM_STATUS_BYTECOUNT),
++	.bInterval =		LOG2_STATUS_INTERVAL_MSEC + 4,
++};
++
++static struct usb_ss_ep_comp_descriptor ss_ecm_intr_comp_desc = {
++	.bLength =		sizeof ss_ecm_intr_comp_desc,
++	.bDescriptorType =	USB_DT_SS_ENDPOINT_COMP,
++
++	/* the following 3 values can be tweaked if necessary */
++	/* .bMaxBurst =		0, */
++	/* .bmAttributes =	0, */
++	.wBytesPerInterval =	cpu_to_le16(ECM_STATUS_BYTECOUNT),
++};
++
++static struct usb_endpoint_descriptor ss_ecm_in_desc = {
++	.bLength =		USB_DT_ENDPOINT_SIZE,
++	.bDescriptorType =	USB_DT_ENDPOINT,
++
++	.bEndpointAddress =	USB_DIR_IN,
++	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
++	.wMaxPacketSize =	cpu_to_le16(1024),
++};
++
++static struct usb_endpoint_descriptor ss_ecm_out_desc = {
++	.bLength =		USB_DT_ENDPOINT_SIZE,
++	.bDescriptorType =	USB_DT_ENDPOINT,
++
++	.bEndpointAddress =	USB_DIR_OUT,
++	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
++	.wMaxPacketSize =	cpu_to_le16(1024),
++};
++
++static struct usb_ss_ep_comp_descriptor ss_ecm_bulk_comp_desc = {
++	.bLength =		sizeof ss_ecm_bulk_comp_desc,
++	.bDescriptorType =	USB_DT_SS_ENDPOINT_COMP,
++
++	/* the following 2 values can be tweaked if necessary */
++	/* .bMaxBurst =		0, */
++	/* .bmAttributes =	0, */
++};
++
++static struct usb_descriptor_header *ecm_ss_function[] = {
++	/* CDC ECM control descriptors */
++	(struct usb_descriptor_header *) &ecm_control_intf,
++	(struct usb_descriptor_header *) &ecm_header_desc,
++	(struct usb_descriptor_header *) &ecm_union_desc,
++	(struct usb_descriptor_header *) &ecm_desc,
++
++	/* NOTE: status endpoint might need to be removed */
++	(struct usb_descriptor_header *) &ss_ecm_notify_desc,
++	(struct usb_descriptor_header *) &ss_ecm_intr_comp_desc,
++
++	/* data interface, altsettings 0 and 1 */
++	(struct usb_descriptor_header *) &ecm_data_nop_intf,
++	(struct usb_descriptor_header *) &ecm_data_intf,
++	(struct usb_descriptor_header *) &ss_ecm_in_desc,
++	(struct usb_descriptor_header *) &ss_ecm_bulk_comp_desc,
++	(struct usb_descriptor_header *) &ss_ecm_out_desc,
++	(struct usb_descriptor_header *) &ss_ecm_bulk_comp_desc,
++	NULL,
++};
++
+ /* string descriptors: */
+ 
+ static struct usb_string ecm_string_defs[] = {
+@@ -464,13 +532,13 @@ static int ecm_set_alt(struct usb_functi
+ 		if (ecm->notify->driver_data) {
+ 			VDBG(cdev, "reset ecm control %d\n", intf);
+ 			usb_ep_disable(ecm->notify);
+-		} else {
++		}
++		if (!(ecm->notify->desc)) {
+ 			VDBG(cdev, "init ecm ctrl %d\n", intf);
+-			ecm->notify_desc = ep_choose(cdev->gadget,
+-					ecm->hs.notify,
+-					ecm->fs.notify);
++			if (config_ep_by_speed(cdev->gadget, f, ecm->notify))
++				goto fail;
+ 		}
+-		usb_ep_enable(ecm->notify, ecm->notify_desc);
++		usb_ep_enable(ecm->notify);
+ 		ecm->notify->driver_data = ecm;
+ 
+ 	/* Data interface has two altsettings, 0 and 1 */
+@@ -483,12 +551,17 @@ static int ecm_set_alt(struct usb_functi
+ 			gether_disconnect(&ecm->port);
+ 		}
+ 
+-		if (!ecm->port.in) {
++		if (!ecm->port.in_ep->desc ||
++		    !ecm->port.out_ep->desc) {
+ 			DBG(cdev, "init ecm\n");
+-			ecm->port.in = ep_choose(cdev->gadget,
+-					ecm->hs.in, ecm->fs.in);
+-			ecm->port.out = ep_choose(cdev->gadget,
+-					ecm->hs.out, ecm->fs.out);
++			if (config_ep_by_speed(cdev->gadget, f,
++					       ecm->port.in_ep) ||
++			    config_ep_by_speed(cdev->gadget, f,
++					       ecm->port.out_ep)) {
++				ecm->port.in_ep->desc = NULL;
++				ecm->port.out_ep->desc = NULL;
++				goto fail;
++			}
+ 		}
+ 
+ 		/* CDC Ethernet only sends data in non-default altsettings.
+@@ -549,7 +622,7 @@ static void ecm_disable(struct usb_funct
+ 	if (ecm->notify->driver_data) {
+ 		usb_ep_disable(ecm->notify);
+ 		ecm->notify->driver_data = NULL;
+-		ecm->notify_desc = NULL;
++		ecm->notify->desc = NULL;
+ 	}
+ }
+ 
+@@ -665,13 +738,6 @@ ecm_bind(struct usb_configuration *c, st
+ 	if (!f->descriptors)
+ 		goto fail;
+ 
+-	ecm->fs.in = usb_find_endpoint(ecm_fs_function,
+-			f->descriptors, &fs_ecm_in_desc);
+-	ecm->fs.out = usb_find_endpoint(ecm_fs_function,
+-			f->descriptors, &fs_ecm_out_desc);
+-	ecm->fs.notify = usb_find_endpoint(ecm_fs_function,
+-			f->descriptors, &fs_ecm_notify_desc);
+-
+ 	/* support all relevant hardware speeds... we expect that when
+ 	 * hardware is dual speed, all bulk-capable endpoints work at
+ 	 * both speeds
+@@ -688,13 +754,20 @@ ecm_bind(struct usb_configuration *c, st
+ 		f->hs_descriptors = usb_copy_descriptors(ecm_hs_function);
+ 		if (!f->hs_descriptors)
+ 			goto fail;
++	}
+ 
+-		ecm->hs.in = usb_find_endpoint(ecm_hs_function,
+-				f->hs_descriptors, &hs_ecm_in_desc);
+-		ecm->hs.out = usb_find_endpoint(ecm_hs_function,
+-				f->hs_descriptors, &hs_ecm_out_desc);
+-		ecm->hs.notify = usb_find_endpoint(ecm_hs_function,
+-				f->hs_descriptors, &hs_ecm_notify_desc);
++	if (gadget_is_superspeed(c->cdev->gadget)) {
++		ss_ecm_in_desc.bEndpointAddress =
++				fs_ecm_in_desc.bEndpointAddress;
++		ss_ecm_out_desc.bEndpointAddress =
++				fs_ecm_out_desc.bEndpointAddress;
++		ss_ecm_notify_desc.bEndpointAddress =
++				fs_ecm_notify_desc.bEndpointAddress;
++
++		/* copy descriptors, and track endpoint copies */
++		f->ss_descriptors = usb_copy_descriptors(ecm_ss_function);
++		if (!f->ss_descriptors)
++			goto fail;
+ 	}
+ 
+ 	/* NOTE:  all that is done without knowing or caring about
+@@ -706,6 +779,7 @@ ecm_bind(struct usb_configuration *c, st
+ 	ecm->port.close = ecm_close;
+ 
+ 	DBG(cdev, "CDC Ethernet: %s speed IN/%s OUT/%s NOTIFY/%s\n",
++			gadget_is_superspeed(c->cdev->gadget) ? "super" :
+ 			gadget_is_dualspeed(c->cdev->gadget) ? "dual" : "full",
+ 			ecm->port.in_ep->name, ecm->port.out_ep->name,
+ 			ecm->notify->name);
+@@ -714,6 +788,8 @@ ecm_bind(struct usb_configuration *c, st
+ fail:
+ 	if (f->descriptors)
+ 		usb_free_descriptors(f->descriptors);
++	if (f->hs_descriptors)
++		usb_free_descriptors(f->hs_descriptors);
+ 
+ 	if (ecm->notify_req) {
+ 		kfree(ecm->notify_req->buf);
+@@ -723,9 +799,9 @@ fail:
+ 	/* we might as well release our claims on endpoints */
+ 	if (ecm->notify)
+ 		ecm->notify->driver_data = NULL;
+-	if (ecm->port.out)
++	if (ecm->port.out_ep->desc)
+ 		ecm->port.out_ep->driver_data = NULL;
+-	if (ecm->port.in)
++	if (ecm->port.in_ep->desc)
+ 		ecm->port.in_ep->driver_data = NULL;
+ 
+ 	ERROR(cdev, "%s: can't bind, err %d\n", f->name, status);
+@@ -740,6 +816,8 @@ ecm_unbind(struct usb_configuration *c,
+ 
+ 	DBG(c->cdev, "ecm unbind\n");
+ 
++	if (gadget_is_superspeed(c->cdev->gadget))
++		usb_free_descriptors(f->ss_descriptors);
+ 	if (gadget_is_dualspeed(c->cdev->gadget))
+ 		usb_free_descriptors(f->hs_descriptors);
+ 	usb_free_descriptors(f->descriptors);
+--- a/drivers/usb/gadget/f_eem.c
++++ b/drivers/usb/gadget/f_eem.c
+@@ -35,17 +35,9 @@
+  * Ethernet link.
+  */
+ 
+-struct eem_ep_descs {
+-	struct usb_endpoint_descriptor	*in;
+-	struct usb_endpoint_descriptor	*out;
+-};
+-
+ struct f_eem {
+ 	struct gether			port;
+ 	u8				ctrl_id;
+-
+-	struct eem_ep_descs		fs;
+-	struct eem_ep_descs		hs;
+ };
+ 
+ static inline struct f_eem *func_to_eem(struct usb_function *f)
+@@ -123,6 +115,45 @@ static struct usb_descriptor_header *eem
+ 	NULL,
+ };
+ 
++/* super speed support: */
++
++static struct usb_endpoint_descriptor eem_ss_in_desc __initdata = {
++	.bLength =		USB_DT_ENDPOINT_SIZE,
++	.bDescriptorType =	USB_DT_ENDPOINT,
++
++	.bEndpointAddress =	USB_DIR_IN,
++	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
++	.wMaxPacketSize =	cpu_to_le16(1024),
++};
++
++static struct usb_endpoint_descriptor eem_ss_out_desc __initdata = {
++	.bLength =		USB_DT_ENDPOINT_SIZE,
++	.bDescriptorType =	USB_DT_ENDPOINT,
++
++	.bEndpointAddress =	USB_DIR_OUT,
++	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
++	.wMaxPacketSize =	cpu_to_le16(1024),
++};
++
++static struct usb_ss_ep_comp_descriptor eem_ss_bulk_comp_desc __initdata = {
++	.bLength =		sizeof eem_ss_bulk_comp_desc,
++	.bDescriptorType =	USB_DT_SS_ENDPOINT_COMP,
++
++	/* the following 2 values can be tweaked if necessary */
++	/* .bMaxBurst =		0, */
++	/* .bmAttributes =	0, */
++};
++
++static struct usb_descriptor_header *eem_ss_function[] __initdata = {
++	/* CDC EEM control descriptors */
++	(struct usb_descriptor_header *) &eem_intf,
++	(struct usb_descriptor_header *) &eem_ss_in_desc,
++	(struct usb_descriptor_header *) &eem_ss_bulk_comp_desc,
++	(struct usb_descriptor_header *) &eem_ss_out_desc,
++	(struct usb_descriptor_header *) &eem_ss_bulk_comp_desc,
++	NULL,
++};
++
+ /* string descriptors: */
+ 
+ static struct usb_string eem_string_defs[] = {
+@@ -176,12 +207,16 @@ static int eem_set_alt(struct usb_functi
+ 			gether_disconnect(&eem->port);
+ 		}
+ 
+-		if (!eem->port.in) {
++		if (!eem->port.in_ep->desc || !eem->port.out_ep->desc) {
+ 			DBG(cdev, "init eem\n");
+-			eem->port.in = ep_choose(cdev->gadget,
+-					eem->hs.in, eem->fs.in);
+-			eem->port.out = ep_choose(cdev->gadget,
+-					eem->hs.out, eem->fs.out);
++			if (config_ep_by_speed(cdev->gadget, f,
++					       eem->port.in_ep) ||
++			    config_ep_by_speed(cdev->gadget, f,
++					       eem->port.out_ep)) {
++				eem->port.in_ep->desc = NULL;
++				eem->port.out_ep->desc = NULL;
++				goto fail;
++			}
+ 		}
+ 
+ 		/* zlps should not occur because zero-length EEM packets
+@@ -253,11 +288,6 @@ eem_bind(struct usb_configuration *c, st
+ 	if (!f->descriptors)
+ 		goto fail;
+ 
+-	eem->fs.in = usb_find_endpoint(eem_fs_function,
+-			f->descriptors, &eem_fs_in_desc);
+-	eem->fs.out = usb_find_endpoint(eem_fs_function,
+-			f->descriptors, &eem_fs_out_desc);
+-
+ 	/* support all relevant hardware speeds... we expect that when
+ 	 * hardware is dual speed, all bulk-capable endpoints work at
+ 	 * both speeds
+@@ -272,14 +302,22 @@ eem_bind(struct usb_configuration *c, st
+ 		f->hs_descriptors = usb_copy_descriptors(eem_hs_function);
+ 		if (!f->hs_descriptors)
+ 			goto fail;
++	}
++
++	if (gadget_is_superspeed(c->cdev->gadget)) {
++		eem_ss_in_desc.bEndpointAddress =
++				eem_fs_in_desc.bEndpointAddress;
++		eem_ss_out_desc.bEndpointAddress =
++				eem_fs_out_desc.bEndpointAddress;
+ 
+-		eem->hs.in = usb_find_endpoint(eem_hs_function,
+-				f->hs_descriptors, &eem_hs_in_desc);
+-		eem->hs.out = usb_find_endpoint(eem_hs_function,
+-				f->hs_descriptors, &eem_hs_out_desc);
++		/* copy descriptors, and track endpoint copies */
++		f->ss_descriptors = usb_copy_descriptors(eem_ss_function);
++		if (!f->ss_descriptors)
++			goto fail;
+ 	}
+ 
+ 	DBG(cdev, "CDC Ethernet (EEM): %s speed IN/%s OUT/%s\n",
++			gadget_is_superspeed(c->cdev->gadget) ? "super" :
+ 			gadget_is_dualspeed(c->cdev->gadget) ? "dual" : "full",
+ 			eem->port.in_ep->name, eem->port.out_ep->name);
+ 	return 0;
+@@ -287,11 +325,13 @@ eem_bind(struct usb_configuration *c, st
+ fail:
+ 	if (f->descriptors)
+ 		usb_free_descriptors(f->descriptors);
++	if (f->hs_descriptors)
++		usb_free_descriptors(f->hs_descriptors);
+ 
+ 	/* we might as well release our claims on endpoints */
+-	if (eem->port.out)
++	if (eem->port.out_ep->desc)
+ 		eem->port.out_ep->driver_data = NULL;
+-	if (eem->port.in)
++	if (eem->port.in_ep->desc)
+ 		eem->port.in_ep->driver_data = NULL;
+ 
+ 	ERROR(cdev, "%s: can't bind, err %d\n", f->name, status);
+@@ -306,6 +346,8 @@ eem_unbind(struct usb_configuration *c,
+ 
+ 	DBG(c->cdev, "eem unbind\n");
+ 
++	if (gadget_is_superspeed(c->cdev->gadget))
++		usb_free_descriptors(f->ss_descriptors);
+ 	if (gadget_is_dualspeed(c->cdev->gadget))
+ 		usb_free_descriptors(f->hs_descriptors);
+ 	usb_free_descriptors(f->descriptors);
+--- a/drivers/usb/gadget/f_mass_storage.c
++++ b/drivers/usb/gadget/f_mass_storage.c
+@@ -347,6 +347,7 @@ struct fsg_operations {
+ /* Data shared by all the FSG instances. */
+ struct fsg_common {
+ 	struct usb_gadget	*gadget;
++	struct usb_composite_dev *cdev;
+ 	struct fsg_dev		*fsg, *new_fsg;
+ 	wait_queue_head_t	fsg_wait;
+ 
+@@ -373,6 +374,7 @@ struct fsg_common {
+ 	struct fsg_lun		*curlun;
+ 
+ 	unsigned int		bulk_out_maxpacket;
++	unsigned int		bulk_in_maxpacket;
+ 	enum fsg_state		state;		/* For exception handling */
+ 	unsigned int		exception_req_tag;
+ 
+@@ -613,6 +615,11 @@ static int fsg_setup(struct usb_function
+ 	if (!fsg_is_set(fsg->common))
+ 		return -EOPNOTSUPP;
+ 
++	++fsg->common->ep0_req_tag;	/* Record arrival of a new request */
++	req->context = NULL;
++	req->length = 0;
++	dump_msg(fsg, "ep0-setup", (u8 *) ctrl, sizeof(*ctrl));
++
+ 	switch (ctrl->bRequest) {
+ 
+ 	case USB_BULK_RESET_REQUEST:
+@@ -829,7 +836,8 @@ static int do_read(struct fsg_common *co
+ 		} else if (nread < amount) {
+ 			LDBG(curlun, "partial file read: %d/%u\n",
+ 			     (int)nread, amount);
+-			nread -= (nread & 511);	/* Round down to a block */
++			/* Round down to a block */
++			nread -= (nread & (common->bulk_in_maxpacket - 1));
+ 		}
+ 		file_offset  += nread;
+ 		amount_left  -= nread;
+@@ -952,7 +960,7 @@ static int do_write(struct fsg_common *c
+ 				curlun->info_valid = 1;
+ 				continue;
+ 			}
+-			amount -= amount & 511;
++			amount -= amount & (common->bulk_out_maxpacket - 1);
+ 			if (amount == 0) {
+ 
+ 				/*
+@@ -971,7 +979,7 @@ static int do_write(struct fsg_common *c
+ 				get_some_more = 0;
+ 
+ 			/*
+-			 * amount is always divisible by 512, hence by
++			 * amount is always divisible by wMaxPacketSize, hence by
+ 			 * the bulk-out maxpacket size
+ 			 */
+ 			bh->outreq->length = amount;
+@@ -1027,7 +1035,7 @@ static int do_write(struct fsg_common *c
+ 			} else if (nwritten < amount) {
+ 				LDBG(curlun, "partial file write: %d/%u\n",
+ 				     (int)nwritten, amount);
+-				nwritten -= (nwritten & 511);
++				nwritten -= (nwritten & (common->bulk_out_maxpacket - 1));
+ 				/* Round down to a block */
+ 			}
+ 			file_offset += nwritten;
+@@ -1173,7 +1181,8 @@ static int do_verify(struct fsg_common *
+ 		} else if (nread < amount) {
+ 			LDBG(curlun, "partial file verify: %d/%u\n",
+ 			     (int)nread, amount);
+-			nread -= nread & 511;	/* Round down to a sector */
++			/* Round down to a sector */
++			nread -= nread & (common->bulk_in_maxpacket - 1);
+ 		}
+ 		if (nread == 0) {
+ 			curlun->sense_data = SS_UNRECOVERED_READ_ERROR;
+@@ -1194,25 +1203,49 @@ static int do_inquiry(struct fsg_common
+ {
+ 	struct fsg_lun *curlun = common->curlun;
+ 	u8	*buf = (u8 *) bh->buf;
++	u8	evpd = common->cmnd[1];
++	u8	page = common->cmnd[2];
++	int ret_len = 0;
+ 
+ 	if (!curlun) {		/* Unsupported LUNs are okay */
+ 		common->bad_lun_okay = 1;
+ 		memset(buf, 0, 36);
+ 		buf[0] = 0x7f;		/* Unsupported, no device-type */
+ 		buf[4] = 31;		/* Additional length */
+-		return 36;
++		ret_len = 36;
++		goto out;
+ 	}
+ 
+-	buf[0] = curlun->cdrom ? TYPE_ROM : TYPE_DISK;
+-	buf[1] = curlun->removable ? 0x80 : 0;
+-	buf[2] = 2;		/* ANSI SCSI level 2 */
+-	buf[3] = 2;		/* SCSI-2 INQUIRY data format */
+-	buf[4] = 31;		/* Additional length */
+-	buf[5] = 0;		/* No special options */
+-	buf[6] = 0;
+-	buf[7] = 0;
+-	memcpy(buf + 8, common->inquiry_string, sizeof common->inquiry_string);
+-	return 36;
++	if (evpd) {
++		switch (page) {
++			case 0x80:	/* Serial Number */
++				memset(buf, 8, 0x00);
++				buf[1] = 0x80;	/* Page Code */
++				memcpy(buf + 8, common->inquiry_string,
++						sizeof common->inquiry_string);
++				ret_len = 36;
++				goto out;
++			default:
++				return -EINVAL;
++		}
++	} else if (page == 0) { /* Standard Inquiry */
++		buf[0] = curlun->cdrom ? TYPE_ROM : TYPE_DISK;
++		buf[1] = curlun->removable ? 0x80 : 0;
++		buf[2] = 2;		/* ANSI SCSI level 2 */
++		buf[3] = 2;		/* SCSI-2 INQUIRY data format */
++		buf[4] = 31;		/* Additional length */
++		buf[5] = 0;		/* No special options */
++		buf[6] = 0;
++		buf[7] = 0;
++		memcpy(buf + 8, common->inquiry_string, sizeof common->inquiry_string);
++		ret_len = 36;
++		goto out;
++	}
++	return -EINVAL;
++out:
++	if (common->data_size > ret_len)
++		common->data_size = common->residue = ret_len;
++	return ret_len;
+ }
+ 
+ static int do_request_sense(struct fsg_common *common, struct fsg_buffhd *bh)
+@@ -1402,6 +1435,10 @@ static int do_mode_sense(struct fsg_comm
+ 					/* Maximum prefetch ceiling */
+ 		}
+ 		buf += 12;
++	} else if (page_code == 0x1c) {
++		/* Informational exceptions control */
++		valid_page = 1;
++		memset(buf, 4, 0x00);
+ 	}
+ 
+ 	/*
+@@ -1414,6 +1451,11 @@ static int do_mode_sense(struct fsg_comm
+ 		return -EINVAL;
+ 	}
+ 
++	if (valid_page) {
++		if (common->data_size > len)
++			common->data_size = common->residue = len;
++	}
++
+ 	/*  Store the mode data length */
+ 	if (mscmnd == MODE_SENSE)
+ 		buf0[0] = len - 1;
+@@ -1523,6 +1565,7 @@ static int do_read_format_capacities(str
+ 						/* Number of blocks */
+ 	put_unaligned_be32(512, &buf[4]);	/* Block length */
+ 	buf[4] = 0x02;				/* Current capacity */
++	common->data_size = common->residue = 12;
+ 	return 12;
+ }
+ 
+@@ -1584,37 +1627,6 @@ static int wedge_bulk_in_endpoint(struct
+ 	return rc;
+ }
+ 
+-static int pad_with_zeros(struct fsg_dev *fsg)
+-{
+-	struct fsg_buffhd	*bh = fsg->common->next_buffhd_to_fill;
+-	u32			nkeep = bh->inreq->length;
+-	u32			nsend;
+-	int			rc;
+-
+-	bh->state = BUF_STATE_EMPTY;		/* For the first iteration */
+-	fsg->common->usb_amount_left = nkeep + fsg->common->residue;
+-	while (fsg->common->usb_amount_left > 0) {
+-
+-		/* Wait for the next buffer to be free */
+-		while (bh->state != BUF_STATE_EMPTY) {
+-			rc = sleep_thread(fsg->common);
+-			if (rc)
+-				return rc;
+-		}
+-
+-		nsend = min(fsg->common->usb_amount_left, FSG_BUFLEN);
+-		memset(bh->buf + nkeep, 0, nsend - nkeep);
+-		bh->inreq->length = nsend;
+-		bh->inreq->zero = 0;
+-		start_transfer(fsg, fsg->bulk_in, bh->inreq,
+-			       &bh->inreq_busy, &bh->state);
+-		bh = fsg->common->next_buffhd_to_fill = bh->next;
+-		fsg->common->usb_amount_left -= nsend;
+-		nkeep = 0;
+-	}
+-	return 0;
+-}
+-
+ static int throw_away_data(struct fsg_common *common)
+ {
+ 	struct fsg_buffhd	*bh;
+@@ -1648,7 +1660,7 @@ static int throw_away_data(struct fsg_co
+ 			amount = min(common->usb_amount_left, FSG_BUFLEN);
+ 
+ 			/*
+-			 * amount is always divisible by 512, hence by
++			 * amount is always divisible by wMaxPacketSize, hence by
+ 			 * the bulk-out maxpacket size.
+ 			 */
+ 			bh->outreq->length = amount;
+@@ -1702,6 +1714,10 @@ static int finish_reply(struct fsg_commo
+ 		if (common->data_size == 0) {
+ 			/* Nothing to send */
+ 
++		/* Don't know what to do if common->fsg is NULL */
++		} else if (!fsg_is_set(common)) {
++			rc = -EIO;
++
+ 		/* If there's no residue, simply send the last buffer */
+ 		} else if (common->residue == 0) {
+ 			bh->inreq->zero = 0;
+@@ -1710,24 +1726,19 @@ static int finish_reply(struct fsg_commo
+ 			common->next_buffhd_to_fill = bh->next;
+ 
+ 		/*
+-		 * For Bulk-only, if we're allowed to stall then send the
+-		 * short packet and halt the bulk-in endpoint.  If we can't
+-		 * stall, pad out the remaining data with 0's.
++		 * For Bulk-only, mark the end of the data with a short
++		 * packet.  If we are allowed to stall, halt the bulk-in
++		 * endpoint.  (Note: This violates the Bulk-Only Transport
++		 * specification, which requires us to pad the data if we
++		 * don't halt the endpoint.  Presumably nobody will mind.)
+ 		 */
+-		} else if (common->can_stall) {
++		} else {
+ 			bh->inreq->zero = 1;
+ 			if (!start_in_transfer(common, bh))
+-				/* Don't know what to do if
+-				 * common->fsg is NULL */
+ 				rc = -EIO;
+ 			common->next_buffhd_to_fill = bh->next;
+-			if (common->fsg)
++			if (common->can_stall)
+ 				rc = halt_bulk_in_endpoint(common->fsg);
+-		} else if (fsg_is_set(common)) {
+-			rc = pad_with_zeros(common->fsg);
+-		} else {
+-			/* Don't know what to do if common->fsg is NULL */
+-			rc = -EIO;
+ 		}
+ 		break;
+ 
+@@ -1910,7 +1921,7 @@ static int check_command(struct fsg_comm
+ 		    common->lun, lun);
+ 
+ 	/* Check the LUN */
+-	if (common->lun >= 0 && common->lun < common->nluns) {
++	if (common->lun < common->nluns) {
+ 		curlun = &common->luns[common->lun];
+ 		common->curlun = curlun;
+ 		if (common->cmnd[0] != REQUEST_SENSE) {
+@@ -1993,7 +2004,7 @@ static int do_scsi_command(struct fsg_co
+ 	case INQUIRY:
+ 		common->data_size_from_cmnd = common->cmnd[4];
+ 		reply = check_command(common, 6, DATA_DIR_TO_HOST,
+-				      (1<<4), 0,
++				      (1<<1) | (1<<2) | (1<<4), 0,
+ 				      "INQUIRY");
+ 		if (reply == 0)
+ 			reply = do_inquiry(common, bh);
+@@ -2350,18 +2361,6 @@ static int get_next_command(struct fsg_c
+ 
+ /*-------------------------------------------------------------------------*/
+ 
+-static int enable_endpoint(struct fsg_common *common, struct usb_ep *ep,
+-		const struct usb_endpoint_descriptor *d)
+-{
+-	int	rc;
+-
+-	ep->driver_data = common;
+-	rc = usb_ep_enable(ep, d);
+-	if (rc)
+-		ERROR(common, "can't enable %s, result %d\n", ep->name, rc);
+-	return rc;
+-}
+-
+ static int alloc_request(struct fsg_common *common, struct usb_ep *ep,
+ 		struct usb_request **preq)
+ {
+@@ -2375,7 +2374,6 @@ static int alloc_request(struct fsg_comm
+ /* Reset interface setting and re-init endpoint state (toggle etc). */
+ static int do_set_interface(struct fsg_common *common, struct fsg_dev *new_fsg)
+ {
+-	const struct usb_endpoint_descriptor *d;
+ 	struct fsg_dev *fsg;
+ 	int i, rc = 0;
+ 
+@@ -2422,20 +2420,28 @@ reset:
+ 	fsg = common->fsg;
+ 
+ 	/* Enable the endpoints */
+-	d = fsg_ep_desc(common->gadget,
+-			&fsg_fs_bulk_in_desc, &fsg_hs_bulk_in_desc);
+-	rc = enable_endpoint(common, fsg->bulk_in, d);
++	rc = config_ep_by_speed(common->gadget, &(fsg->function), fsg->bulk_in);
++	if (rc)
++		goto reset;
++	rc = usb_ep_enable(fsg->bulk_in);
+ 	if (rc)
+ 		goto reset;
++	fsg->bulk_in->driver_data = common;
+ 	fsg->bulk_in_enabled = 1;
+ 
+-	d = fsg_ep_desc(common->gadget,
+-			&fsg_fs_bulk_out_desc, &fsg_hs_bulk_out_desc);
+-	rc = enable_endpoint(common, fsg->bulk_out, d);
++	rc = config_ep_by_speed(common->gadget, &(fsg->function),
++				fsg->bulk_out);
++	if (rc)
++		goto reset;
++	rc = usb_ep_enable(fsg->bulk_out);
+ 	if (rc)
+ 		goto reset;
++	fsg->bulk_out->driver_data = common;
+ 	fsg->bulk_out_enabled = 1;
+-	common->bulk_out_maxpacket = le16_to_cpu(d->wMaxPacketSize);
++	common->bulk_out_maxpacket =
++		le16_to_cpu(fsg->bulk_out->desc->wMaxPacketSize);
++	common->bulk_in_maxpacket = 
++		le16_to_cpu(fsg->bulk_in->desc->wMaxPacketSize);
+ 	clear_bit(IGNORE_BULK_OUT, &fsg->atomic_bitflags);
+ 
+ 	/* Allocate the requests */
+@@ -2456,7 +2462,7 @@ reset:
+ 
+ 	common->running = 1;
+ 	for (i = 0; i < common->nluns; ++i)
+-		common->luns[i].unit_attention_data = SS_RESET_OCCURRED;
++		common->luns[i].unit_attention_data = SS_NO_SENSE;
+ 	return rc;
+ }
+ 
+@@ -2468,7 +2474,7 @@ static int fsg_set_alt(struct usb_functi
+ 	struct fsg_dev *fsg = fsg_from_func(f);
+ 	fsg->common->new_fsg = fsg;
+ 	raise_exception(fsg->common, FSG_STATE_CONFIG_CHANGE);
+-	return 0;
++	return USB_GADGET_DELAYED_STATUS;
+ }
+ 
+ static void fsg_disable(struct usb_function *f)
+@@ -2604,6 +2610,8 @@ static void handle_exception(struct fsg_
+ 
+ 	case FSG_STATE_CONFIG_CHANGE:
+ 		do_set_interface(common, common->new_fsg);
++		if (common->new_fsg)
++			usb_composite_setup_continue(common->cdev);
+ 		break;
+ 
+ 	case FSG_STATE_EXIT:
+@@ -2774,6 +2782,7 @@ static struct fsg_common *fsg_common_ini
+ 	common->gadget = gadget;
+ 	common->ep0 = gadget->ep0;
+ 	common->ep0req = cdev->req;
++	common->cdev = cdev;
+ 
+ 	/* Maybe allocate device-global string IDs, and patch descriptors */
+ 	if (fsg_strings[FSG_STRING_INTERFACE].id == 0) {
+@@ -2800,6 +2809,7 @@ static struct fsg_common *fsg_common_ini
+ 	for (i = 0, lcfg = cfg->luns; i < nluns; ++i, ++curlun, ++lcfg) {
+ 		curlun->cdrom = !!lcfg->cdrom;
+ 		curlun->ro = lcfg->cdrom || lcfg->ro;
++		curlun->initially_ro = curlun->ro;
+ 		curlun->removable = lcfg->removable;
+ 		curlun->dev.release = fsg_lun_release;
+ 		curlun->dev.parent = &gadget->dev;
+@@ -2994,10 +3004,12 @@ static void fsg_unbind(struct usb_config
+ 		/* FIXME: make interruptible or killable somehow? */
+ 		wait_event(common->fsg_wait, common->fsg != fsg);
+ 	}
+-
+ 	fsg_common_put(common);
++	if (gadget_is_superspeed(c->cdev->gadget))
++		usb_free_descriptors(f->ss_descriptors);
++	if (gadget_is_dualspeed(c->cdev->gadget))
++		usb_free_descriptors(f->hs_descriptors);
+ 	usb_free_descriptors(fsg->function.descriptors);
+-	usb_free_descriptors(fsg->function.hs_descriptors);
+ 	kfree(fsg);
+ }
+ 
+@@ -3046,6 +3058,20 @@ static int fsg_bind(struct usb_configura
+ 			usb_free_descriptors(f->descriptors);
+ 			return -ENOMEM;
+ 		}
++	}
++
++	/* support super speed */
++	if (gadget_is_superspeed(gadget)) {
++		/* Assume endpoint addresses are the same for both speeds */
++		fsg_ss_bulk_in_desc.bEndpointAddress =
++			fsg_fs_bulk_in_desc.bEndpointAddress;
++		fsg_ss_bulk_out_desc.bEndpointAddress =
++			fsg_fs_bulk_out_desc.bEndpointAddress;
++		f->ss_descriptors = usb_copy_descriptors(fsg_ss_function);
++		if (unlikely(!f->ss_descriptors)) {
++			usb_free_descriptors(f->descriptors);
++			return -ENOMEM;
++		}
+ 	}
+ 
+ 	return 0;
+--- a/drivers/usb/gadget/f_rndis.c
++++ b/drivers/usb/gadget/f_rndis.c
+@@ -76,23 +76,13 @@
+  *   - MS-Windows drivers sometimes emit undocumented requests.
+  */
+ 
+-struct rndis_ep_descs {
+-	struct usb_endpoint_descriptor	*in;
+-	struct usb_endpoint_descriptor	*out;
+-	struct usb_endpoint_descriptor	*notify;
+-};
+-
+ struct f_rndis {
+ 	struct gether			port;
+ 	u8				ctrl_id, data_id;
+ 	u8				ethaddr[ETH_ALEN];
+ 	int				config;
+ 
+-	struct rndis_ep_descs		fs;
+-	struct rndis_ep_descs		hs;
+-
+ 	struct usb_ep			*notify;
+-	struct usb_endpoint_descriptor	*notify_desc;
+ 	struct usb_request		*notify_req;
+ 	atomic_t			notify_count;
+ };
+@@ -105,10 +95,12 @@ static inline struct f_rndis *func_to_rn
+ /* peak (theoretical) bulk transfer rate in bits-per-second */
+ static unsigned int bitrate(struct usb_gadget *g)
+ {
+-	if (gadget_is_dualspeed(g) && g->speed == USB_SPEED_HIGH)
++	if (gadget_is_superspeed(g) && g->speed == USB_SPEED_SUPER)
++		return 13 * 1024 * 8 * 1000 * 8;
++	else if (gadget_is_dualspeed(g) && g->speed == USB_SPEED_HIGH)
+ 		return 13 * 512 * 8 * 1000 * 8;
+ 	else
+-		return 19 *  64 * 1 * 1000 * 8;
++		return 19 * 64 * 1 * 1000 * 8;
+ }
+ 
+ /*-------------------------------------------------------------------------*/
+@@ -226,6 +218,7 @@ static struct usb_endpoint_descriptor fs
+ 
+ static struct usb_descriptor_header *eth_fs_function[] = {
+ 	(struct usb_descriptor_header *) &rndis_iad_descriptor,
++
+ 	/* control interface matches ACM, not Ethernet */
+ 	(struct usb_descriptor_header *) &rndis_control_intf,
+ 	(struct usb_descriptor_header *) &header_desc,
+@@ -233,6 +226,7 @@ static struct usb_descriptor_header *eth
+ 	(struct usb_descriptor_header *) &rndis_acm_descriptor,
+ 	(struct usb_descriptor_header *) &rndis_union_desc,
+ 	(struct usb_descriptor_header *) &fs_notify_desc,
++
+ 	/* data interface has no altsetting */
+ 	(struct usb_descriptor_header *) &rndis_data_intf,
+ 	(struct usb_descriptor_header *) &fs_in_desc,
+@@ -251,6 +245,7 @@ static struct usb_endpoint_descriptor hs
+ 	.wMaxPacketSize =	cpu_to_le16(STATUS_BYTECOUNT),
+ 	.bInterval =		LOG2_STATUS_INTERVAL_MSEC + 4,
+ };
++
+ static struct usb_endpoint_descriptor hs_in_desc = {
+ 	.bLength =		USB_DT_ENDPOINT_SIZE,
+ 	.bDescriptorType =	USB_DT_ENDPOINT,
+@@ -271,6 +266,7 @@ static struct usb_endpoint_descriptor hs
+ 
+ static struct usb_descriptor_header *eth_hs_function[] = {
+ 	(struct usb_descriptor_header *) &rndis_iad_descriptor,
++
+ 	/* control interface matches ACM, not Ethernet */
+ 	(struct usb_descriptor_header *) &rndis_control_intf,
+ 	(struct usb_descriptor_header *) &header_desc,
+@@ -278,6 +274,7 @@ static struct usb_descriptor_header *eth
+ 	(struct usb_descriptor_header *) &rndis_acm_descriptor,
+ 	(struct usb_descriptor_header *) &rndis_union_desc,
+ 	(struct usb_descriptor_header *) &hs_notify_desc,
++
+ 	/* data interface has no altsetting */
+ 	(struct usb_descriptor_header *) &rndis_data_intf,
+ 	(struct usb_descriptor_header *) &hs_in_desc,
+@@ -285,6 +282,76 @@ static struct usb_descriptor_header *eth
+ 	NULL,
+ };
+ 
++/* super speed support: */
++
++static struct usb_endpoint_descriptor ss_notify_desc = {
++	.bLength =		USB_DT_ENDPOINT_SIZE,
++	.bDescriptorType =	USB_DT_ENDPOINT,
++
++	.bEndpointAddress =	USB_DIR_IN,
++	.bmAttributes =		USB_ENDPOINT_XFER_INT,
++	.wMaxPacketSize =	cpu_to_le16(STATUS_BYTECOUNT),
++	.bInterval =		LOG2_STATUS_INTERVAL_MSEC + 4,
++};
++
++static struct usb_ss_ep_comp_descriptor ss_intr_comp_desc = {
++	.bLength =		sizeof ss_intr_comp_desc,
++	.bDescriptorType =	USB_DT_SS_ENDPOINT_COMP,
++
++	/* the following 3 values can be tweaked if necessary */
++	/* .bMaxBurst =		0, */
++	/* .bmAttributes =	0, */
++	.wBytesPerInterval =	cpu_to_le16(STATUS_BYTECOUNT),
++};
++
++static struct usb_endpoint_descriptor ss_in_desc = {
++	.bLength =		USB_DT_ENDPOINT_SIZE,
++	.bDescriptorType =	USB_DT_ENDPOINT,
++
++	.bEndpointAddress =	USB_DIR_IN,
++	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
++	.wMaxPacketSize =	cpu_to_le16(1024),
++};
++
++static struct usb_endpoint_descriptor ss_out_desc = {
++	.bLength =		USB_DT_ENDPOINT_SIZE,
++	.bDescriptorType =	USB_DT_ENDPOINT,
++
++	.bEndpointAddress =	USB_DIR_OUT,
++	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
++	.wMaxPacketSize =	cpu_to_le16(1024),
++};
++
++static struct usb_ss_ep_comp_descriptor ss_bulk_comp_desc = {
++	.bLength =		sizeof ss_bulk_comp_desc,
++	.bDescriptorType =	USB_DT_SS_ENDPOINT_COMP,
++
++	/* the following 2 values can be tweaked if necessary */
++	/* .bMaxBurst =		0, */
++	/* .bmAttributes =	0, */
++};
++
++static struct usb_descriptor_header *eth_ss_function[] = {
++	(struct usb_descriptor_header *) &rndis_iad_descriptor,
++
++	/* control interface matches ACM, not Ethernet */
++	(struct usb_descriptor_header *) &rndis_control_intf,
++	(struct usb_descriptor_header *) &header_desc,
++	(struct usb_descriptor_header *) &call_mgmt_descriptor,
++	(struct usb_descriptor_header *) &rndis_acm_descriptor,
++	(struct usb_descriptor_header *) &rndis_union_desc,
++	(struct usb_descriptor_header *) &ss_notify_desc,
++	(struct usb_descriptor_header *) &ss_intr_comp_desc,
++
++	/* data interface has no altsetting */
++	(struct usb_descriptor_header *) &rndis_data_intf,
++	(struct usb_descriptor_header *) &ss_in_desc,
++	(struct usb_descriptor_header *) &ss_bulk_comp_desc,
++	(struct usb_descriptor_header *) &ss_out_desc,
++	(struct usb_descriptor_header *) &ss_bulk_comp_desc,
++	NULL,
++};
++
+ /* string descriptors: */
+ 
+ static struct usb_string rndis_string_defs[] = {
+@@ -484,13 +551,13 @@ static int rndis_set_alt(struct usb_func
+ 		if (rndis->notify->driver_data) {
+ 			VDBG(cdev, "reset rndis control %d\n", intf);
+ 			usb_ep_disable(rndis->notify);
+-		} else {
++		}
++		if (!rndis->notify->desc) {
+ 			VDBG(cdev, "init rndis ctrl %d\n", intf);
+-			rndis->notify_desc = ep_choose(cdev->gadget,
+-					rndis->hs.notify,
+-					rndis->fs.notify);
++			if (config_ep_by_speed(cdev->gadget, f, rndis->notify))
++				goto fail;
+ 		}
+-		usb_ep_enable(rndis->notify, rndis->notify_desc);
++		usb_ep_enable(rndis->notify);
+ 		rndis->notify->driver_data = rndis;
+ 
+ 	} else if (intf == rndis->data_id) {
+@@ -501,12 +568,16 @@ static int rndis_set_alt(struct usb_func
+ 			gether_disconnect(&rndis->port);
+ 		}
+ 
+-		if (!rndis->port.in) {
++		if (!rndis->port.in_ep->desc || !rndis->port.out_ep->desc) {
+ 			DBG(cdev, "init rndis\n");
+-			rndis->port.in = ep_choose(cdev->gadget,
+-					rndis->hs.in, rndis->fs.in);
+-			rndis->port.out = ep_choose(cdev->gadget,
+-					rndis->hs.out, rndis->fs.out);
++			if (config_ep_by_speed(cdev->gadget, f,
++					       rndis->port.in_ep) ||
++			    config_ep_by_speed(cdev->gadget, f,
++					       rndis->port.out_ep)) {
++				rndis->port.in_ep->desc = NULL;
++				rndis->port.out_ep->desc = NULL;
++				goto fail;
++			}
+ 		}
+ 
+ 		/* Avoid ZLPs; they can be troublesome. */
+@@ -662,13 +733,6 @@ rndis_bind(struct usb_configuration *c,
+ 	if (!f->descriptors)
+ 		goto fail;
+ 
+-	rndis->fs.in = usb_find_endpoint(eth_fs_function,
+-			f->descriptors, &fs_in_desc);
+-	rndis->fs.out = usb_find_endpoint(eth_fs_function,
+-			f->descriptors, &fs_out_desc);
+-	rndis->fs.notify = usb_find_endpoint(eth_fs_function,
+-			f->descriptors, &fs_notify_desc);
+-
+ 	/* support all relevant hardware speeds... we expect that when
+ 	 * hardware is dual speed, all bulk-capable endpoints work at
+ 	 * both speeds
+@@ -683,16 +747,22 @@ rndis_bind(struct usb_configuration *c,
+ 
+ 		/* copy descriptors, and track endpoint copies */
+ 		f->hs_descriptors = usb_copy_descriptors(eth_hs_function);
+-
+ 		if (!f->hs_descriptors)
+ 			goto fail;
++	}
+ 
+-		rndis->hs.in = usb_find_endpoint(eth_hs_function,
+-				f->hs_descriptors, &hs_in_desc);
+-		rndis->hs.out = usb_find_endpoint(eth_hs_function,
+-				f->hs_descriptors, &hs_out_desc);
+-		rndis->hs.notify = usb_find_endpoint(eth_hs_function,
+-				f->hs_descriptors, &hs_notify_desc);
++	if (gadget_is_superspeed(c->cdev->gadget)) {
++		ss_in_desc.bEndpointAddress =
++				fs_in_desc.bEndpointAddress;
++		ss_out_desc.bEndpointAddress =
++				fs_out_desc.bEndpointAddress;
++		ss_notify_desc.bEndpointAddress =
++				fs_notify_desc.bEndpointAddress;
++
++		/* copy descriptors, and track endpoint copies */
++		f->ss_descriptors = usb_copy_descriptors(eth_ss_function);
++		if (!f->ss_descriptors)
++			goto fail;
+ 	}
+ 
+ 	rndis->port.open = rndis_open;
+@@ -719,12 +789,15 @@ rndis_bind(struct usb_configuration *c,
+ 	 */
+ 
+ 	DBG(cdev, "RNDIS: %s speed IN/%s OUT/%s NOTIFY/%s\n",
++			gadget_is_superspeed(c->cdev->gadget) ? "super" :
+ 			gadget_is_dualspeed(c->cdev->gadget) ? "dual" : "full",
+ 			rndis->port.in_ep->name, rndis->port.out_ep->name,
+ 			rndis->notify->name);
+ 	return 0;
+ 
+ fail:
++	if (gadget_is_superspeed(c->cdev->gadget) && f->ss_descriptors)
++		usb_free_descriptors(f->ss_descriptors);
+ 	if (gadget_is_dualspeed(c->cdev->gadget) && f->hs_descriptors)
+ 		usb_free_descriptors(f->hs_descriptors);
+ 	if (f->descriptors)
+@@ -738,9 +811,9 @@ fail:
+ 	/* we might as well release our claims on endpoints */
+ 	if (rndis->notify)
+ 		rndis->notify->driver_data = NULL;
+-	if (rndis->port.out)
++	if (rndis->port.out_ep->desc)
+ 		rndis->port.out_ep->driver_data = NULL;
+-	if (rndis->port.in)
++	if (rndis->port.in_ep->desc)
+ 		rndis->port.in_ep->driver_data = NULL;
+ 
+ 	ERROR(cdev, "%s: can't bind, err %d\n", f->name, status);
+@@ -756,6 +829,8 @@ rndis_unbind(struct usb_configuration *c
+ 	rndis_deregister(rndis->config);
+ 	rndis_exit();
+ 
++	if (gadget_is_superspeed(c->cdev->gadget))
++		usb_free_descriptors(f->ss_descriptors);
+ 	if (gadget_is_dualspeed(c->cdev->gadget))
+ 		usb_free_descriptors(f->hs_descriptors);
+ 	usb_free_descriptors(f->descriptors);
