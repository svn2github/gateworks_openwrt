Index: trunk/target/linux/ixp4xx/base-files/lib/ixp4xx.sh
===================================================================
--- trunk/target/linux/ixp4xx/base-files/lib/ixp4xx.sh	(revision 0)
+++ trunk/target/linux/ixp4xx/base-files/lib/ixp4xx.sh	(working copy)
@@ -0,0 +1,25 @@
+#!/bin/sh
+#
+# Copyright (C) 2009 OpenWrt.org
+#
+
+ixp4xx_board_name() {
+        local machine
+        local name
+
+        machine=$(awk 'BEGIN{FS="[ \t]+:[ \t]"} /Hardware/ {print $2}' /proc/cpuinfo)
+
+        case "$machine" in
+		"Gateworks Cambria"*)
+			name="cambria"
+			;;
+		"Gateworks Avila"*)
+			name="avila"
+			;;
+		*)
+			name="generic";
+			;;
+	esac
+	
+	echo $name
+}
Index: trunk/target/linux/ixp4xx/base-files/lib/upgrade/platform.sh
===================================================================
--- trunk/target/linux/ixp4xx/base-files/lib/upgrade/platform.sh	(revision 0)
+++ trunk/target/linux/ixp4xx/base-files/lib/upgrade/platform.sh	(working copy)
@@ -0,0 +1,154 @@
+. /lib/ixp4xx.sh
+
+RAMFS_COPY_DATA="/lib/ixp4xx.sh"
+
+# testing
+RAMFS_COPY_BIN="/usr/bin/less /usr/bin/hexdump"
+
+CI_BLKSZ=65536
+CI_LDADR=0x00800000
+
+platform_find_partitions() {
+	local first dev size erasesize name
+	while read dev size erasesize name; do
+		name=${name#'"'}; name=${name%'"'}
+		case "$name" in
+			vmlinux.bin.l7|kernel|linux|rootfs)
+				if [ -z "$first" ]; then
+					first="$name"
+				else
+					echo "$erasesize:$first:$name"
+					break
+				fi
+			;;
+		esac
+	done < /proc/mtd
+}
+
+platform_find_kernelpart() {
+	local part
+	for part in "${1%:*}" "${1#*:}"; do
+		case "$part" in
+			vmlinux.bin.l7|kernel|linux)
+				echo "$part"
+				break
+			;;
+		esac
+	done
+}
+
+platform_find_part_size() {
+	local first dev size erasesize name
+	while read dev size erasesize name; do
+		name=${name#'"'}; name=${name%'"'}
+		[ "$name" = "$1" ] && {
+			echo "$size"
+			break
+		}
+	done < /proc/mtd
+}
+
+platform_do_upgrade_combined() {
+	local partitions=$(platform_find_partitions)
+	local kernelpart=$(platform_find_kernelpart "${partitions#*:}")
+	local erase_size=$((0x${partitions%%:*})); partitions="${partitions#*:}"
+	local kern_part_size=0x$(platform_find_part_size "$kernelpart")
+	local kern_part_blocks=$(($kern_part_size / $CI_BLKSZ))
+	local kern_length=0x$(dd if="$1" bs=2 skip=1 count=4 2>/dev/null)
+	local kern_blocks=$(($kern_length / $CI_BLKSZ))
+	local root_blocks=$((0x$(dd if="$1" bs=2 skip=5 count=4 2>/dev/null) / $CI_BLKSZ))
+
+	v "platform_do_upgrade_combined"
+	v "partitions=$partitions"
+	v "kernelpart=$kernelpart"
+	v "kernel_part_size=$kern_part_size"
+	v "kernel_part_blocks=$kern_part_blocks"
+	v "kern_length=$kern_length"
+	v "erase_size=$erase_size" 
+	v "kern_blocks=$kern_blocks"
+	v "root_blocks=$root_blocks"
+	v "kern_pad_blocks=$(($kern_part_blocks-$kern_blocks))"
+
+	if [ -n "$partitions" ] && [ -n "$kernelpart" ] && \
+	   [ ${kern_blocks:-0} -gt 0 ] && \
+	   [ ${root_blocks:-0} -gt ${kern_blocks:-0} ] && \
+	   [ ${erase_size:-0} -gt 0 ];
+	then
+		local append=""
+		[ -f "$CONF_TAR" -a "$SAVE_CONFIG" -eq 1 ] && append="-j $CONF_TAR"
+
+		# write the kernel
+		dd if="$1" bs=$CI_BLKSZ skip=1 count=$kern_blocks 2>/dev/null | \
+			mtd -F$kernelpart:$kern_part_size:$CI_LDADR write - $kernelpart
+		# write the rootfs
+		dd if="$1" bs=$CI_BLKSZ skip=$((1+$kern_blocks)) count=$root_blocks 2>/dev/null | \
+			mtd $append write - rootfs
+	fi
+}
+
+platform_check_image() {
+	local board=$(ixp4xx_board_name)
+	local magic="$(get_magic_word "$1")"
+	local partitions=$(platform_find_partitions)
+	local kernelpart=$(platform_find_kernelpart "${partitions#*:}")
+	local kern_part_size=0x$(platform_find_part_size "$kernelpart")
+	local kern_length=0x$(dd if="$1" bs=2 skip=1 count=4 2>/dev/null)
+
+	[ "$ARGC" -gt 1 ] && return 1
+
+	case "$board" in
+	avila | cambria )
+		[ "$magic" != "4349" ] && {
+			echo "Invalid image. Use *-sysupgrade.bin files on this board"
+			return 1
+		}
+
+		kern_length_b=$(printf '%d' $kern_length)
+		kern_part_size_b=$(printf '%d' $kern_part_size)
+		if [ $kern_length_b -gt $kern_part_size_b ]; then
+			echo "Invalid image. Kernel size ($kern_length) exceeds kernel partition ($kern_part_size)"
+			return 1
+		fi 
+
+		local md5_img=$(dd if="$1" bs=2 skip=9 count=16 2>/dev/null)
+		local md5_chk=$(dd if="$1" bs=$CI_BLKSZ skip=1 2>/dev/null | md5sum -); md5_chk="${md5_chk%% *}"
+		if [ -n "$md5_img" -a -n "$md5_chk" ] && [ "$md5_img" = "$md5_chk" ]; then
+			return 0
+		else
+			echo "Invalid image. Contents do not match checksum (image:$md5_img calculated:$md5_chk)"
+			return 1
+		fi
+
+		return 0
+		;;
+	esac
+
+	echo "Sysupgrade is not yet supported on $board."
+	return 1
+}
+
+platform_do_upgrade() {
+	local board=$(ixp4xx_board_name)
+
+	v "board=$board"
+	case "$board" in
+	avila | cambria )
+		platform_do_upgrade_combined "$ARGV"
+		;;
+	*)
+		default_do_upgrade "$ARGV"
+		;;
+	esac
+}
+
+disable_watchdog() {
+	v "killing watchdog"
+	killall watchdog
+	( ps | grep -v 'grep' | grep '/dev/watchdog' ) && {
+		echo 'Could not disable watchdog'
+		return 1
+	}
+}
+
+# CONFIG_WATCHDOG_NOWAYOUT=y - can't kill watchdog unless kernel cmdline has a mpcore_wdt.nowayout=0
+#append sysupgrade_pre_upgrade disable_watchdog
Index: trunk/target/linux/ixp4xx/config-2.6.37
===================================================================
--- trunk/target/linux/ixp4xx/config-2.6.37	(revision 27590)
+++ trunk/target/linux/ixp4xx/config-2.6.37	(working copy)
@@ -17,7 +17,6 @@
 CONFIG_ARM_L1_CACHE_SHIFT=5
 # CONFIG_ARM_THUMB is not set
 # CONFIG_ARPD is not set
-CONFIG_BKL=y
 CONFIG_BOUNCE=y
 CONFIG_CMDLINE="root=/dev/mtdblock2 rootfstype=squashfs,jffs2 noinitrd console=ttyS0,115200"
 CONFIG_CPU_32v5=y
@@ -40,8 +39,6 @@
 CONFIG_DMABOUNCE=y
 CONFIG_DNOTIFY=y
 CONFIG_EEPROM_AT24=y
-# CONFIG_FPE_FASTFPE is not set
-# CONFIG_FPE_NWFPE is not set
 CONFIG_FRAME_POINTER=y
 CONFIG_GENERIC_ATOMIC64=y
 CONFIG_GENERIC_CLOCKEVENTS=y
@@ -137,7 +134,7 @@
 CONFIG_NEED_DMA_MAP_STATE=y
 CONFIG_NEED_PER_CPU_KM=y
 CONFIG_PAGEFLAGS_EXTENDED=y
-CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_PAGE_OFFSET=0x80000000
 CONFIG_PCI=y
 CONFIG_PERF_USE_VMALLOC=y
 CONFIG_PHYLIB=y
@@ -150,15 +147,19 @@
 CONFIG_RTC_DRV_X1205=y
 # CONFIG_SCSI_DMA is not set
 CONFIG_SENSORS_AD7418=y
+CONFIG_SENSORS_GSP=y
 CONFIG_SENSORS_MAX6650=y
 CONFIG_SENSORS_W83781D=y
-CONFIG_SERIAL_8250_NR_UARTS=4
-CONFIG_SERIAL_8250_RUNTIME_UARTS=4
+CONFIG_SERIAL_8250_NR_UARTS=20
+CONFIG_SERIAL_8250_PCI=y
+CONFIG_SERIAL_8250_RUNTIME_UARTS=20
 CONFIG_SPLIT_PTLOCK_CPUS=999999
 CONFIG_SYS_SUPPORTS_APM_EMULATION=y
 CONFIG_UID16=y
 CONFIG_USB_SUPPORT=y
 CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_VMSPLIT_2G=y
+# CONFIG_VMSPLIT_3G is not set
 CONFIG_VM_EVENT_COUNTERS=y
 CONFIG_WATCHDOG_NOWAYOUT=y
 CONFIG_XSCALE_PMU=y
Index: trunk/target/linux/ixp4xx/config-default
===================================================================
--- trunk/target/linux/ixp4xx/config-default	(revision 27590)
+++ trunk/target/linux/ixp4xx/config-default	(working copy)
@@ -17,7 +17,7 @@
 CONFIG_ARM_L1_CACHE_SHIFT=5
 # CONFIG_ARM_THUMB is not set
 # CONFIG_ARPD is not set
-CONFIG_BKL=y
+# CONFIG_AUTO_IRQ_AFFINITY is not set
 CONFIG_BOUNCE=y
 CONFIG_CMDLINE="root=/dev/mtdblock2 rootfstype=squashfs,jffs2 noinitrd console=ttyS0,115200"
 CONFIG_CPU_32v5=y
@@ -33,6 +33,7 @@
 CONFIG_CPU_IXP46X=y
 CONFIG_CPU_PABRT_LEGACY=y
 CONFIG_CPU_TLB_V4WBI=y
+CONFIG_CPU_USE_DOMAINS=y
 CONFIG_CPU_XSCALE=y
 CONFIG_DEBUG_BUGVERBOSE=y
 # CONFIG_DEBUG_USER is not set
@@ -40,18 +41,19 @@
 CONFIG_DMABOUNCE=y
 CONFIG_DNOTIFY=y
 CONFIG_EEPROM_AT24=y
-# CONFIG_FPE_FASTFPE is not set
-# CONFIG_FPE_NWFPE is not set
 CONFIG_FRAME_POINTER=y
 CONFIG_GENERIC_ATOMIC64=y
 CONFIG_GENERIC_CLOCKEVENTS=y
 CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
 CONFIG_GENERIC_FIND_LAST_BIT=y
 CONFIG_GENERIC_GPIO=y
-CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+# CONFIG_GENERIC_HARDIRQS_NO_DEPRECATED is not set
+# CONFIG_GENERIC_PENDING_IRQ is not set
 CONFIG_GPIOLIB=y
 CONFIG_GPIO_DEVICE=y
 CONFIG_GPIO_GW_I2C_PLD=y
+CONFIG_GPIO_PCA953X=y
+# CONFIG_GPIO_PCA953X_IRQ is not set
 CONFIG_GPIO_SYSFS=y
 # CONFIG_HAMRADIO is not set
 CONFIG_HARDIRQS_SW_RESEND=y
@@ -60,11 +62,14 @@
 CONFIG_HAS_IOPORT=y
 CONFIG_HAVE_AOUT=y
 CONFIG_HAVE_ARCH_KGDB=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_HAVE_DMA_API_DEBUG=y
 CONFIG_HAVE_DYNAMIC_FTRACE=y
 CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
 CONFIG_HAVE_FUNCTION_TRACER=y
 CONFIG_HAVE_GENERIC_DMA_COHERENT=y
-# CONFIG_HAVE_GENERIC_HARDIRQS is not set
+CONFIG_HAVE_GENERIC_HARDIRQS=y
 CONFIG_HAVE_IDE=y
 CONFIG_HAVE_IRQ_WORK=y
 CONFIG_HAVE_KERNEL_GZIP=y
@@ -77,6 +82,8 @@
 CONFIG_HAVE_PERF_EVENTS=y
 CONFIG_HAVE_PROC_CPU=y
 CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_SCHED_CLOCK=y
+CONFIG_HAVE_SPARSE_IRQ=y
 CONFIG_HWMON=y
 # CONFIG_HWMON_DEBUG_CHIP is not set
 CONFIG_HWMON_VID=y
@@ -88,14 +95,18 @@
 CONFIG_I2C_CHARDEV=y
 CONFIG_I2C_GPIO=y
 # CONFIG_I2C_IOP3XX is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
 CONFIG_INITRAMFS_SOURCE=""
 CONFIG_IP_PIMSM_V1=y
 CONFIG_IP_PIMSM_V2=y
+# CONFIG_IRQ_PER_CPU is not set
 # CONFIG_IWMMXT is not set
 CONFIG_IXP4XX_ETH=y
 # CONFIG_IXP4XX_INDIRECT_PCI is not set
 CONFIG_IXP4XX_NPE=y
 CONFIG_IXP4XX_QMGR=y
+# CONFIG_IXP4XX_SPREAD_SPECTRUM_CLK is not set
 CONFIG_IXP4XX_WATCHDOG=y
 CONFIG_LEDS_FSG=y
 CONFIG_LEDS_GPIO=y
@@ -129,6 +140,8 @@
 CONFIG_MACH_WG302V1=y
 CONFIG_MACH_WG302V2=y
 CONFIG_MACH_WRT300NV2=y
+# CONFIG_MFD_WL1273_CORE is not set
+CONFIG_MIGHT_HAVE_PCI=y
 CONFIG_MTD_CFI_ADV_OPTIONS=y
 # CONFIG_MTD_CFI_GEOMETRY is not set
 CONFIG_MTD_IXP4XX=y
@@ -137,7 +150,7 @@
 CONFIG_NEED_DMA_MAP_STATE=y
 CONFIG_NEED_PER_CPU_KM=y
 CONFIG_PAGEFLAGS_EXTENDED=y
-CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_PAGE_OFFSET=0x80000000
 CONFIG_PCI=y
 CONFIG_PERF_USE_VMALLOC=y
 CONFIG_PHYLIB=y
@@ -150,17 +163,24 @@
 CONFIG_RTC_DRV_X1205=y
 # CONFIG_SCSI_DMA is not set
 CONFIG_SENSORS_AD7418=y
+CONFIG_SENSORS_GSP=y
 CONFIG_SENSORS_MAX6650=y
 CONFIG_SENSORS_W83781D=y
-CONFIG_SERIAL_8250_NR_UARTS=4
-CONFIG_SERIAL_8250_RUNTIME_UARTS=4
+CONFIG_SERIAL_8250_NR_UARTS=20
+CONFIG_SERIAL_8250_PCI=y
+CONFIG_SERIAL_8250_RUNTIME_UARTS=20
 CONFIG_SPLIT_PTLOCK_CPUS=999999
 CONFIG_SYS_SUPPORTS_APM_EMULATION=y
 CONFIG_UID16=y
 CONFIG_USB_SUPPORT=y
 CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_VMSPLIT_2G=y
+# CONFIG_VMSPLIT_3G is not set
 CONFIG_VM_EVENT_COUNTERS=y
 CONFIG_WATCHDOG_NOWAYOUT=y
 CONFIG_XSCALE_PMU=y
+CONFIG_XZ_DEC=y
 CONFIG_ZBOOT_ROM_BSS=0x0
 CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_USB_DEVICEFS=y
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
Index: trunk/target/linux/ixp4xx/image/Makefile
===================================================================
--- trunk/target/linux/ixp4xx/image/Makefile	(revision 27590)
+++ trunk/target/linux/ixp4xx/image/Makefile	(working copy)
@@ -40,8 +40,19 @@
 	BIN_DIR=$(BIN_DIR) IMG_PREFIX="$(IMG_PREFIX)" $(TOPDIR)/scripts/arm-magic.sh
 endef
 
+# Build sysupgrade image
+define BuildFirmware/Generic
+	dd if=$(KDIR)/zImage of=$(KDIR)/zImage.pad bs=64k conv=sync; \
+	dd if=$(KDIR)/root.$(1) of=$(KDIR)/root.$(1).pad bs=128k conv=sync; \
+	sh $(TOPDIR)/scripts/combined-image.sh \
+		$(KDIR)/zImage.pad \
+		$(KDIR)/root.$(1).pad \
+		$(BIN_DIR)/$(IMG_PREFIX)-$(patsubst jffs2-%,jffs2,$(patsubst squashfs-%,squashfs,$(1)))-sysupgrade.bin
+endef
+
 define Image/Build
 	$(call Image/Build/$(1),$(1))
+	$(call BuildFirmware/Generic,$(1))
 endef
 
 define Image/Build/jffs2-64k
Index: trunk/target/linux/ixp4xx/Makefile
===================================================================
--- trunk/target/linux/ixp4xx/Makefile	(revision 27590)
+++ trunk/target/linux/ixp4xx/Makefile	(working copy)
@@ -13,7 +13,7 @@
 MAINTAINER:=Imre Kaloz <kaloz@openwrt.org>
 SUBTARGETS=generic harddisk
 
-LINUX_VERSION:=2.6.37.6
+LINUX_VERSION:=2.6.38.8
 
 include $(INCLUDE_DIR)/target.mk
 
Index: trunk/target/linux/ixp4xx/patches-2.6.37/301-avila_led.patch
===================================================================
--- trunk/target/linux/ixp4xx/patches-2.6.37/301-avila_led.patch	(revision 27590)
+++ trunk/target/linux/ixp4xx/patches-2.6.37/301-avila_led.patch	(working copy)
@@ -129,11 +129,12 @@
  }
  
  static void __init avila_gw2355_setup(void)
-@@ -222,11 +301,29 @@ static void __init avila_gw2355_setup(vo
+@@ -222,11 +301,30 @@ static void __init avila_gw2355_setup(vo
  
  	avila_npec_data.phy = 16;
  	platform_device_register(&avila_npec_device);
 +
++	avila_gpio_leds[0].gpio = AVILA_GW23X7_LED_USER_GPIO;
 +	platform_device_register(&avila_gpio_leds_device);
 +
 +	*IXP4XX_EXP_CS4 |= 0xbfff3c03;
Index: trunk/target/linux/ixp4xx/patches-2.6.37/302-avila_gpio_device.patch
===================================================================
--- trunk/target/linux/ixp4xx/patches-2.6.37/302-avila_gpio_device.patch	(revision 27590)
+++ trunk/target/linux/ixp4xx/patches-2.6.37/302-avila_gpio_device.patch	(working copy)
@@ -14,3 +14,28 @@
  struct avila_board_info {
  	unsigned char	*model;
  	void		(*setup)(void);
+@@ -243,6 +250,11 @@ static struct platform_device *avila_dev
+ 	&avila_uart
+ };
+ 
++static struct platform_device avila_gpio_dev = {
++	.name     = "GPIODEV",
++	.id     = -1,
++};
++
+ static void __init avila_gw23xx_setup(void)
+ {
+ 	platform_device_register(&avila_npeb_device);
+@@ -434,8 +446,10 @@ static void __init avila_init(void)
+ 
+ 	platform_device_register(&avila_pata);
+ 
+-		i2c_register_board_info(0, avila_i2c_board_info,
+-				ARRAY_SIZE(avila_i2c_board_info));
++	i2c_register_board_info(0, avila_i2c_board_info,
++			ARRAY_SIZE(avila_i2c_board_info));
++
++	platform_device_register(&avila_gpio_dev);
+ }
+ 
+ static int __init avila_model_setup(void)
Index: trunk/target/linux/ixp4xx/patches-2.6.37/501-cambria-e1000-irq.patch
===================================================================
--- trunk/target/linux/ixp4xx/patches-2.6.37/501-cambria-e1000-irq.patch	(revision 0)
+++ trunk/target/linux/ixp4xx/patches-2.6.37/501-cambria-e1000-irq.patch	(working copy)
@@ -0,0 +1,14 @@
+--- a/arch/arm/mach-ixp4xx/cambria-pci.c
++++ b/arch/arm/mach-ixp4xx/cambria-pci.c
+@@ -52,6 +52,11 @@ static int __init cambria_map_irq(struct
+ 		return IRQ_IXP4XX_GPIO9;
+ 	else if (slot == 4)
+ 		return IRQ_IXP4XX_GPIO8;
++  else if (slot == 6)
++    return IRQ_IXP4XX_GPIO10;
++  else if (slot == 15)
++    return IRQ_IXP4XX_GPIO8;
++
+ 	else return -1;
+ }
+ 
Index: trunk/target/linux/ixp4xx/patches-2.6.37/502-gw2365-eth.patch
===================================================================
--- trunk/target/linux/ixp4xx/patches-2.6.37/502-gw2365-eth.patch	(revision 0)
+++ trunk/target/linux/ixp4xx/patches-2.6.37/502-gw2365-eth.patch	(working copy)
@@ -0,0 +1,30 @@
+--- a/arch/arm/mach-ixp4xx/avila-setup.c
++++ b/arch/arm/mach-ixp4xx/avila-setup.c
+@@ -338,6 +338,17 @@ static void __init avila_gw2357_setup(vo
+ 	platform_device_register(&avila_latch_leds_device);
+ }
+ 
++static void __init avila_gw2365_setup(void)
++{
++	avila_npeb_data.phy = 1;
++	platform_device_register(&avila_npeb_device);
++
++	avila_npec_data.phy = 2;
++	platform_device_register(&avila_npec_device);
++
++	platform_device_register(&avila_gpio_leds_device);
++}
++
+ static struct avila_board_info avila_boards[] __initdata = {
+ 	{
+ 		.model		= "GW2342",
+@@ -360,6 +371,9 @@ static struct avila_board_info avila_boa
+ 	}, {
+ 		.model		= "GW2357",
+ 		.setup		= avila_gw2357_setup,
++	}, {
++		.model		= "GW2365",
++		.setup		= avila_gw2365_setup,
+ 	}
+ };
+ 
Index: trunk/target/linux/ixp4xx/patches-2.6.37/503-gw2365-optional-uart.patch
===================================================================
--- trunk/target/linux/ixp4xx/patches-2.6.37/503-gw2365-optional-uart.patch	(revision 0)
+++ trunk/target/linux/ixp4xx/patches-2.6.37/503-gw2365-optional-uart.patch	(working copy)
@@ -0,0 +1,105 @@
+--- a/arch/arm/mach-ixp4xx/avila-setup.c
++++ b/arch/arm/mach-ixp4xx/avila-setup.c
+@@ -125,6 +125,69 @@ static struct platform_device avila_uart
+ 	.resource		= avila_uart_resources
+ };
+ 
++static struct resource avila_optional_uart_resources[] = {
++  {
++    .start  = 0x54000000,
++    .end  = 0x54000fff,
++    .flags  = IORESOURCE_MEM
++  },
++  {
++    .start  = 0x55000000,
++    .end  = 0x55000fff,
++    .flags  = IORESOURCE_MEM
++  },
++  {
++    .start  = 0x56000000,
++    .end  = 0x56000fff,
++    .flags  = IORESOURCE_MEM
++  },
++  {
++    .start  = 0x57000000,
++    .end  = 0x57000fff,
++    .flags  = IORESOURCE_MEM
++  }
++};
++
++static struct plat_serial8250_port avila_optional_uart_data[] = {
++  {
++    .flags    = UPF_BOOT_AUTOCONF,
++    .iotype   = UPIO_MEM,
++    .regshift = 0,
++    .uartclk  = 18432000,
++    .rw_delay = 2,
++  },
++  {
++    .flags    = UPF_BOOT_AUTOCONF,
++    .iotype   = UPIO_MEM,
++    .regshift = 0,
++    .uartclk  = 18432000,
++    .rw_delay = 2,
++  },
++  {
++    .flags    = UPF_BOOT_AUTOCONF,
++    .iotype   = UPIO_MEM,
++    .regshift = 0,
++    .uartclk  = 18432000,
++    .rw_delay = 2,
++  },
++  {
++    .flags    = UPF_BOOT_AUTOCONF,
++    .iotype   = UPIO_MEM,
++    .regshift = 0,
++    .uartclk  = 18432000,
++    .rw_delay = 2,
++  },
++  { },
++};
++
++static struct platform_device avila_optional_uart = {
++  .name   = "serial8250",
++  .id   = PLAT8250_DEV_PLATFORM1,
++  .dev.platform_data  = avila_optional_uart_data,
++  .num_resources  = 4,
++  .resource = avila_optional_uart_resources,
++};
++
+ static struct resource avila_pata_resources[] = {
+ 	{
+ 		.flags	= IORESOURCE_MEM
+@@ -340,6 +403,32 @@ static void __init avila_gw2357_setup(vo
+ 
+ static void __init avila_gw2365_setup(void)
+ {
++	*IXP4XX_EXP_CS4 = 0xBFFF3C43;
++  set_irq_type(IRQ_IXP4XX_GPIO0, IRQ_TYPE_EDGE_RISING);
++  avila_optional_uart_data[0].mapbase = 0x54000000;
++  avila_optional_uart_data[0].membase = (void __iomem *)ioremap(0x54000000, 0x0fff);
++  avila_optional_uart_data[0].irq   = IRQ_IXP4XX_GPIO0;
++
++  *IXP4XX_EXP_CS5 = 0xBFFF3C43;
++  set_irq_type(IRQ_IXP4XX_GPIO1, IRQ_TYPE_EDGE_RISING);
++  avila_optional_uart_data[1].mapbase = 0x55000000;
++  avila_optional_uart_data[1].membase = (void __iomem *)ioremap(0x55000000, 0x0fff);
++  avila_optional_uart_data[1].irq   = IRQ_IXP4XX_GPIO1;
++
++  *IXP4XX_EXP_CS6 = 0xBFFF3C43;
++  set_irq_type(IRQ_IXP4XX_GPIO2, IRQ_TYPE_EDGE_RISING);
++  avila_optional_uart_data[2].mapbase = 0x56000000;
++  avila_optional_uart_data[2].membase = (void __iomem *)ioremap(0x56000000, 0x0fff);
++  avila_optional_uart_data[2].irq   = IRQ_IXP4XX_GPIO2;
++
++  *IXP4XX_EXP_CS7 = 0xBFFF3C43;
++  set_irq_type(IRQ_IXP4XX_GPIO3, IRQ_TYPE_EDGE_RISING);
++  avila_optional_uart_data[3].mapbase = 0x57000000;
++  avila_optional_uart_data[3].membase = (void __iomem *)ioremap(0x57000000, 0x0fff);
++  avila_optional_uart_data[3].irq   = IRQ_IXP4XX_GPIO3;
++
++	platform_device_register(&avila_optional_uart);
++	
+ 	avila_npeb_data.phy = 1;
+ 	platform_device_register(&avila_npeb_device);
+ 
Index: trunk/target/linux/ixp4xx/patches-2.6.37/504-gw2369_support.patch
===================================================================
--- trunk/target/linux/ixp4xx/patches-2.6.37/504-gw2369_support.patch	(revision 0)
+++ trunk/target/linux/ixp4xx/patches-2.6.37/504-gw2369_support.patch	(working copy)
@@ -0,0 +1,381 @@
+--- a/arch/arm/mach-ixp4xx/avila-setup.c
++++ b/arch/arm/mach-ixp4xx/avila-setup.c
+@@ -23,6 +23,7 @@
+ #include <linux/i2c.h>
+ #include <linux/i2c/at24.h>
+ #include <linux/leds.h>
++#include <linux/i2c/pca953x.h>
+ #include <linux/i2c-gpio.h>
+ #include <asm/types.h>
+ #include <asm/setup.h>
+@@ -32,6 +33,7 @@
+ #include <asm/irq.h>
+ #include <asm/mach/arch.h>
+ #include <asm/mach/flash.h>
++#include <linux/irq.h>
+ 
+ #define AVILA_SDA_PIN	7
+ #define AVILA_SCL_PIN	6
+@@ -126,58 +128,52 @@ static struct platform_device avila_uart
+ };
+ 
+ static struct resource avila_optional_uart_resources[] = {
+-  {
+-    .start  = 0x54000000,
+-    .end  = 0x54000fff,
+-    .flags  = IORESOURCE_MEM
+-  },
+-  {
+-    .start  = 0x55000000,
+-    .end  = 0x55000fff,
+-    .flags  = IORESOURCE_MEM
+-  },
+-  {
+-    .start  = 0x56000000,
+-    .end  = 0x56000fff,
+-    .flags  = IORESOURCE_MEM
+-  },
+-  {
+-    .start  = 0x57000000,
+-    .end  = 0x57000fff,
+-    .flags  = IORESOURCE_MEM
+-  }
++	{
++		.start  = 0x54000000,
++		.end  = 0x54000fff,
++		.flags  = IORESOURCE_MEM
++	},{
++		.start  = 0x55000000,
++		.end  = 0x55000fff,
++		.flags  = IORESOURCE_MEM
++	},{
++		.start  = 0x56000000,
++		.end  = 0x56000fff,
++		.flags  = IORESOURCE_MEM
++	},{
++		.start  = 0x57000000,
++		.end  = 0x57000fff,
++		.flags  = IORESOURCE_MEM
++	}
+ };
+ 
+ static struct plat_serial8250_port avila_optional_uart_data[] = {
+-  {
+-    .flags    = UPF_BOOT_AUTOCONF,
+-    .iotype   = UPIO_MEM,
+-    .regshift = 0,
+-    .uartclk  = 18432000,
+-    .rw_delay = 2,
+-  },
+-  {
+-    .flags    = UPF_BOOT_AUTOCONF,
+-    .iotype   = UPIO_MEM,
+-    .regshift = 0,
+-    .uartclk  = 18432000,
+-    .rw_delay = 2,
+-  },
+-  {
+-    .flags    = UPF_BOOT_AUTOCONF,
+-    .iotype   = UPIO_MEM,
+-    .regshift = 0,
+-    .uartclk  = 18432000,
+-    .rw_delay = 2,
+-  },
+-  {
+-    .flags    = UPF_BOOT_AUTOCONF,
+-    .iotype   = UPIO_MEM,
+-    .regshift = 0,
+-    .uartclk  = 18432000,
+-    .rw_delay = 2,
+-  },
+-  { },
++	{
++		.flags    = UPF_BOOT_AUTOCONF,
++		.iotype   = UPIO_MEM,
++		.regshift = 0,
++		.uartclk  = 18432000,
++		.rw_delay = 2,
++	},{
++		.flags    = UPF_BOOT_AUTOCONF,
++		.iotype   = UPIO_MEM,
++		.regshift = 0,
++		.uartclk  = 18432000,
++		.rw_delay = 2,
++	},{
++		.flags    = UPF_BOOT_AUTOCONF,
++		.iotype   = UPIO_MEM,
++		.regshift = 0,
++		.uartclk  = 18432000,
++		.rw_delay = 2,
++	},{
++		.flags    = UPF_BOOT_AUTOCONF,
++		.iotype   = UPIO_MEM,
++		.regshift = 0,
++		.uartclk  = 18432000,
++		.rw_delay = 2,
++	},
++	{ }
+ };
+ 
+ static struct platform_device avila_optional_uart = {
+@@ -191,11 +187,9 @@ static struct platform_device avila_opti
+ static struct resource avila_pata_resources[] = {
+ 	{
+ 		.flags	= IORESOURCE_MEM
+-	},
+-	{
++	},{
+ 		.flags	= IORESOURCE_MEM,
+-	},
+-	{
++	},{
+ 		.name	= "intrq",
+ 		.start	= IRQ_IXP4XX_GPIO12,
+ 		.end	= IRQ_IXP4XX_GPIO12,
+@@ -246,7 +240,28 @@ static struct gpio_led avila_gpio_leds[]
+ 		.name		= "user",  /* green led */
+ 		.gpio		= AVILA_GW23XX_LED_USER_GPIO,
+ 		.active_low	= 1,
+-	}
++	},
++	{
++		.name		= "radio1",  /* green led */
++		.gpio		= 104,
++		.active_low	= 1,
++	},
++	{
++		.name		= "radio2",  /* green led */
++		.gpio		= 105,
++		.active_low	= 1,
++	},
++	{
++		.name		= "radio3",  /* green led */
++		.gpio		= 106,
++		.active_low	= 1,
++	},
++	{
++		.name		= "radio4",  /* green led */
++		.gpio		= 107,
++		.active_low	= 1,
++	},
++
+ };
+ 
+ static struct gpio_led_platform_data avila_gpio_leds_data = {
+@@ -332,6 +347,17 @@ static void __init avila_gw2342_setup(vo
+ 	platform_device_register(&avila_npec_device);
+ 
+ 	platform_device_register(&avila_gpio_leds_device);
++
++	avila_pata_resources[0].start = IXP4XX_EXP_BUS_BASE(1);
++	avila_pata_resources[0].end = IXP4XX_EXP_BUS_END(1);
++
++	avila_pata_resources[1].start = IXP4XX_EXP_BUS_BASE(2);
++	avila_pata_resources[1].end = IXP4XX_EXP_BUS_END(2);
++
++	avila_pata_data.cs0_cfg = IXP4XX_EXP_CS1;
++	avila_pata_data.cs1_cfg = IXP4XX_EXP_CS2;
++
++	platform_device_register(&avila_pata);
+ }
+ 
+ static void __init avila_gw2345_setup(void)
+@@ -344,6 +370,17 @@ static void __init avila_gw2345_setup(vo
+ 	platform_device_register(&avila_npec_device);
+ 
+ 	platform_device_register(&avila_gpio_leds_device);
++
++	avila_pata_resources[0].start = IXP4XX_EXP_BUS_BASE(1);
++	avila_pata_resources[0].end = IXP4XX_EXP_BUS_END(1);
++
++	avila_pata_resources[1].start = IXP4XX_EXP_BUS_BASE(2);
++	avila_pata_resources[1].end = IXP4XX_EXP_BUS_END(2);
++
++	avila_pata_data.cs0_cfg = IXP4XX_EXP_CS1;
++	avila_pata_data.cs1_cfg = IXP4XX_EXP_CS2;
++
++	platform_device_register(&avila_pata);
+ }
+ 
+ static void __init avila_gw2347_setup(void)
+@@ -360,6 +397,17 @@ static void __init avila_gw2348_setup(vo
+ 	platform_device_register(&avila_npec_device);
+ 
+ 	platform_device_register(&avila_gpio_leds_device);
++
++	avila_pata_resources[0].start = IXP4XX_EXP_BUS_BASE(1);
++	avila_pata_resources[0].end = IXP4XX_EXP_BUS_END(1);
++
++	avila_pata_resources[1].start = IXP4XX_EXP_BUS_BASE(2);
++	avila_pata_resources[1].end = IXP4XX_EXP_BUS_END(2);
++
++	avila_pata_data.cs0_cfg = IXP4XX_EXP_CS1;
++	avila_pata_data.cs1_cfg = IXP4XX_EXP_CS2;
++
++	platform_device_register(&avila_pata);
+ }
+ 
+ static void __init avila_gw2353_setup(void)
+@@ -388,6 +436,17 @@ static void __init avila_gw2355_setup(vo
+ 	avila_latch_leds_data.num_leds = 5;
+ 	avila_latch_leds_data.mem = 0x54000000;
+ 	platform_device_register(&avila_latch_leds_device);
++
++	avila_pata_resources[0].start = IXP4XX_EXP_BUS_BASE(1);
++	avila_pata_resources[0].end = IXP4XX_EXP_BUS_END(1);
++
++	avila_pata_resources[1].start = IXP4XX_EXP_BUS_BASE(2);
++	avila_pata_resources[1].end = IXP4XX_EXP_BUS_END(2);
++
++	avila_pata_data.cs0_cfg = IXP4XX_EXP_CS1;
++	avila_pata_data.cs1_cfg = IXP4XX_EXP_CS2;
++
++	platform_device_register(&avila_pata);
+ }
+ 
+ static void __init avila_gw2357_setup(void)
+@@ -404,40 +463,62 @@ static void __init avila_gw2357_setup(vo
+ static void __init avila_gw2365_setup(void)
+ {
+ 	*IXP4XX_EXP_CS4 = 0xBFFF3C43;
+-  set_irq_type(IRQ_IXP4XX_GPIO0, IRQ_TYPE_EDGE_RISING);
+-  avila_optional_uart_data[0].mapbase = 0x54000000;
+-  avila_optional_uart_data[0].membase = (void __iomem *)ioremap(0x54000000, 0x0fff);
+-  avila_optional_uart_data[0].irq   = IRQ_IXP4XX_GPIO0;
+-
+-  *IXP4XX_EXP_CS5 = 0xBFFF3C43;
+-  set_irq_type(IRQ_IXP4XX_GPIO1, IRQ_TYPE_EDGE_RISING);
+-  avila_optional_uart_data[1].mapbase = 0x55000000;
+-  avila_optional_uart_data[1].membase = (void __iomem *)ioremap(0x55000000, 0x0fff);
+-  avila_optional_uart_data[1].irq   = IRQ_IXP4XX_GPIO1;
+-
+-  *IXP4XX_EXP_CS6 = 0xBFFF3C43;
+-  set_irq_type(IRQ_IXP4XX_GPIO2, IRQ_TYPE_EDGE_RISING);
+-  avila_optional_uart_data[2].mapbase = 0x56000000;
+-  avila_optional_uart_data[2].membase = (void __iomem *)ioremap(0x56000000, 0x0fff);
+-  avila_optional_uart_data[2].irq   = IRQ_IXP4XX_GPIO2;
+-
+-  *IXP4XX_EXP_CS7 = 0xBFFF3C43;
+-  set_irq_type(IRQ_IXP4XX_GPIO3, IRQ_TYPE_EDGE_RISING);
+-  avila_optional_uart_data[3].mapbase = 0x57000000;
+-  avila_optional_uart_data[3].membase = (void __iomem *)ioremap(0x57000000, 0x0fff);
+-  avila_optional_uart_data[3].irq   = IRQ_IXP4XX_GPIO3;
++	set_irq_type(IRQ_IXP4XX_GPIO0, IRQ_TYPE_EDGE_RISING);
++	avila_optional_uart_data[0].mapbase = 0x54000000;
++	avila_optional_uart_data[0].membase = (void __iomem *)ioremap(0x54000000, 0x0fff);
++	avila_optional_uart_data[0].irq   = IRQ_IXP4XX_GPIO0;
++
++	*IXP4XX_EXP_CS5 = 0xBFFF3C43;
++	set_irq_type(IRQ_IXP4XX_GPIO1, IRQ_TYPE_EDGE_RISING);
++	avila_optional_uart_data[1].mapbase = 0x55000000;
++	avila_optional_uart_data[1].membase = (void __iomem *)ioremap(0x55000000, 0x0fff);
++	avila_optional_uart_data[1].irq   = IRQ_IXP4XX_GPIO1;
++
++	*IXP4XX_EXP_CS6 = 0xBFFF3C43;
++	set_irq_type(IRQ_IXP4XX_GPIO2, IRQ_TYPE_EDGE_RISING);
++	avila_optional_uart_data[2].mapbase = 0x56000000;
++	avila_optional_uart_data[2].membase = (void __iomem *)ioremap(0x56000000, 0x0fff);
++	avila_optional_uart_data[2].irq   = IRQ_IXP4XX_GPIO2;
++
++	*IXP4XX_EXP_CS7 = 0xBFFF3C43;
++	set_irq_type(IRQ_IXP4XX_GPIO3, IRQ_TYPE_EDGE_RISING);
++	avila_optional_uart_data[3].mapbase = 0x57000000;
++	avila_optional_uart_data[3].membase = (void __iomem *)ioremap(0x57000000, 0x0fff);
++	avila_optional_uart_data[3].irq   = IRQ_IXP4XX_GPIO3;
+ 
+ 	platform_device_register(&avila_optional_uart);
+-	
++
+ 	avila_npeb_data.phy = 1;
+ 	platform_device_register(&avila_npeb_device);
+ 
+ 	avila_npec_data.phy = 2;
+ 	platform_device_register(&avila_npec_device);
+ 
++	avila_pata_resources[0].start = IXP4XX_EXP_BUS_BASE(1);
++	avila_pata_resources[0].end = IXP4XX_EXP_BUS_END(1);
++
++	avila_pata_resources[1].start = IXP4XX_EXP_BUS_BASE(2);
++	avila_pata_resources[1].end = IXP4XX_EXP_BUS_END(2);
++
++	avila_pata_data.cs0_cfg = IXP4XX_EXP_CS1;
++	avila_pata_data.cs1_cfg = IXP4XX_EXP_CS2;
++
++	platform_device_register(&avila_pata);
++
++	avila_gpio_leds[0].gpio = 109;
++	avila_gpio_leds_data.num_leds = 5;
+ 	platform_device_register(&avila_gpio_leds_device);
+ }
+ 
++static void __init avila_gw2369_setup(void)
++{
++	avila_npeb_data.phy = 1;
++	platform_device_register(&avila_npeb_device);
++
++	avila_npec_data.phy = 2;
++	platform_device_register(&avila_npec_device);
++}
++
+ static struct avila_board_info avila_boards[] __initdata = {
+ 	{
+ 		.model		= "GW2342",
+@@ -463,6 +544,9 @@ static struct avila_board_info avila_boa
+ 	}, {
+ 		.model		= "GW2365",
+ 		.setup		= avila_gw2365_setup,
++	}, {
++		.model		= "GW2369",
++		.setup		= avila_gw2369_setup,
+ 	}
+ };
+ 
+@@ -511,11 +595,22 @@ static struct at24_platform_data avila_e
+ 	.setup		= at24_setup,
+ };
+ 
++static struct pca953x_platform_data avila_pca_data = {
++	.gpio_base  = 100,
++};
++
+ static struct i2c_board_info __initdata avila_i2c_board_info[] = {
+ 	{
+ 		I2C_BOARD_INFO("ds1672", 0x68),
+ 	},
+ 	{
++		I2C_BOARD_INFO("gsp", 0x29),
++	},
++	{
++		I2C_BOARD_INFO("pca9555", 0x23),
++		.platform_data = &avila_pca_data,
++	},
++	{
+ 		I2C_BOARD_INFO("ad7418", 0x28),
+ 	},
+ 	{
+@@ -538,17 +633,6 @@ static void __init avila_init(void)
+ 
+ 	platform_add_devices(avila_devices, ARRAY_SIZE(avila_devices));
+ 
+-	avila_pata_resources[0].start = IXP4XX_EXP_BUS_BASE(1);
+-	avila_pata_resources[0].end = IXP4XX_EXP_BUS_END(1);
+-
+-	avila_pata_resources[1].start = IXP4XX_EXP_BUS_BASE(2);
+-	avila_pata_resources[1].end = IXP4XX_EXP_BUS_END(2);
+-
+-	avila_pata_data.cs0_cfg = IXP4XX_EXP_CS1;
+-	avila_pata_data.cs1_cfg = IXP4XX_EXP_CS2;
+-
+-	platform_device_register(&avila_pata);
+-
+ 	i2c_register_board_info(0, avila_i2c_board_info,
+ 			ARRAY_SIZE(avila_i2c_board_info));
+ 
+@@ -569,7 +653,6 @@ static int __init avila_model_setup(void
+ 						" -- defaults will be used\n");
+ 		avila_gw23xx_setup();
+ 	}
+-
+ 	return 0;
+ }
+ late_initcall(avila_model_setup);
Index: trunk/target/linux/ixp4xx/patches-2.6.37/505-gateworks_gsp.patch
===================================================================
--- trunk/target/linux/ixp4xx/patches-2.6.37/505-gateworks_gsp.patch	(revision 0)
+++ trunk/target/linux/ixp4xx/patches-2.6.37/505-gateworks_gsp.patch	(working copy)
@@ -0,0 +1,339 @@
+--- /dev/null
++++ b/drivers/hwmon/gsp.c
+@@ -0,0 +1,308 @@
++/*
++ * A hwmon driver for the Gateworks System Peripheral
++ * Copyright (C) 2009 Gateworks Corporation
++ *
++ * Author: Chris Lang <clang@gateworks.com>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License,
++ * as published by the Free Software Foundation - version 2.
++ */
++
++#include <linux/module.h>
++#include <linux/i2c.h>
++#include <linux/hwmon.h>
++#include <linux/hwmon-sysfs.h>
++#include <linux/err.h>
++#include <linux/slab.h>
++
++#define DRV_VERSION "0.2"
++
++enum chips { gsp };
++
++/* AD7418 registers */
++#define GSP_REG_TEMP_IN		0x00
++#define GSP_REG_VIN		0x02
++#define GSP_REG_3P3		0x05
++#define GSP_REG_BAT		0x08
++#define GSP_REG_5P0		0x0b
++#define GSP_REG_CORE		0x0e
++#define GSP_REG_CPU1		0x11
++#define GSP_REG_CPU2		0x14
++#define GSP_REG_DRAM		0x17
++#define GSP_REG_EXT_BAT		0x1a
++#define GSP_REG_IO1		0x1d
++#define GSP_REG_IO2 		0x20
++#define GSP_REG_PCIE		0x23
++#define GSP_REG_CURRENT		0x26
++#define GSP_FAN_0		0x2C
++#define GSP_FAN_1		0x2E
++#define GSP_FAN_2		0x30
++#define GSP_FAN_3		0x32
++#define GSP_FAN_4		0x34
++#define GSP_FAN_5		0x36
++
++struct gsp_sensor_info {
++	const char* name;
++	int reg;
++};
++
++static const struct gsp_sensor_info gsp_sensors[] = {
++	{"temp", GSP_REG_TEMP_IN},
++	{"vin", GSP_REG_VIN},
++	{"3p3", GSP_REG_3P3},
++	{"bat", GSP_REG_BAT},
++	{"5p0", GSP_REG_5P0},
++	{"core", GSP_REG_CORE},
++	{"cpu1", GSP_REG_CPU1},
++	{"cpu2", GSP_REG_CPU2},
++	{"dram", GSP_REG_DRAM},
++	{"ext_bat", GSP_REG_EXT_BAT},
++	{"io1", GSP_REG_IO1},
++	{"io2", GSP_REG_IO2},
++	{"pci2", GSP_REG_PCIE},
++	{"current", GSP_REG_CURRENT},
++	{"fan_point0", GSP_FAN_0},
++	{"fan_point1", GSP_FAN_1},
++	{"fan_point2", GSP_FAN_2},
++	{"fan_point3", GSP_FAN_3},
++	{"fan_point4", GSP_FAN_4},
++	{"fan_point5", GSP_FAN_5},
++};
++
++struct gsp_data {
++	struct device		*hwmon_dev;
++	struct attribute_group	attrs;
++	enum chips		type;
++};
++
++static int gsp_probe(struct i2c_client *client,
++			const struct i2c_device_id *id);
++static int gsp_remove(struct i2c_client *client);
++
++static const struct i2c_device_id gsp_id[] = {
++	{ "gsp", 0 },
++	{ }
++};
++MODULE_DEVICE_TABLE(i2c, gsp_id);
++
++static struct i2c_driver gsp_driver = {
++	.driver = {
++		.name	= "gsp",
++	},
++	.probe		= gsp_probe,
++	.remove		= gsp_remove,
++	.id_table	= gsp_id,
++};
++
++/* All registers are word-sized, except for the configuration registers.
++ * AD7418 uses a high-byte first convention. Do NOT use those functions to
++ * access the configuration registers CONF and CONF2, as they are byte-sized.
++ */
++static inline int gsp_read(struct i2c_client *client, u8 reg)
++{
++	unsigned int adc = 0;
++	if (reg == GSP_REG_TEMP_IN || reg > GSP_REG_CURRENT)
++	{
++		adc |= i2c_smbus_read_byte_data(client, reg);
++		adc |= i2c_smbus_read_byte_data(client, reg + 1) << 8;
++		return adc;
++	}
++	else
++	{
++		adc |= i2c_smbus_read_byte_data(client, reg);
++		adc |= i2c_smbus_read_byte_data(client, reg + 1) << 8;
++		adc |= i2c_smbus_read_byte_data(client, reg + 2) << 16;
++		return adc;
++	}
++}
++
++static inline int gsp_write(struct i2c_client *client, u8 reg, u16 value)
++{
++	i2c_smbus_write_byte_data(client, reg, value & 0xff);
++	i2c_smbus_write_byte_data(client, reg + 1, ((value >> 8) & 0xff));
++	return 1;
++}
++
++static ssize_t show_adc(struct device *dev, struct device_attribute *devattr,
++			char *buf)
++{
++	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
++	struct i2c_client *client = to_i2c_client(dev);
++	return sprintf(buf, "%d\n", gsp_read(client, gsp_sensors[attr->index].reg));
++}
++
++static ssize_t show_label(struct device *dev,
++			struct device_attribute *devattr, char *buf)
++{
++	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
++
++	return sprintf(buf, "%s\n", gsp_sensors[attr->index].name);
++}
++
++static ssize_t store_fan(struct device *dev,
++			struct device_attribute *devattr, const char *buf, size_t count)
++{
++	u16 val;
++	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
++	struct i2c_client *client = to_i2c_client(dev);
++	val = simple_strtoul(buf, NULL, 10);
++	gsp_write(client, gsp_sensors[attr->index].reg, val);
++	return count;
++}
++
++static SENSOR_DEVICE_ATTR(temp0_input, S_IRUGO, show_adc, NULL, 0);
++static SENSOR_DEVICE_ATTR(temp0_label, S_IRUGO, show_label, NULL, 0);
++
++static SENSOR_DEVICE_ATTR(in0_input, S_IRUGO, show_adc, NULL, 1);
++static SENSOR_DEVICE_ATTR(in0_label, S_IRUGO, show_label, NULL, 1);
++static SENSOR_DEVICE_ATTR(in1_input, S_IRUGO, show_adc, NULL, 2);
++static SENSOR_DEVICE_ATTR(in1_label, S_IRUGO, show_label, NULL, 2);
++static SENSOR_DEVICE_ATTR(in2_input, S_IRUGO, show_adc, NULL, 3);
++static SENSOR_DEVICE_ATTR(in2_label, S_IRUGO, show_label, NULL, 3);
++static SENSOR_DEVICE_ATTR(in3_input, S_IRUGO, show_adc, NULL, 4);
++static SENSOR_DEVICE_ATTR(in3_label, S_IRUGO, show_label, NULL, 4);
++static SENSOR_DEVICE_ATTR(in4_input, S_IRUGO, show_adc, NULL, 5);
++static SENSOR_DEVICE_ATTR(in4_label, S_IRUGO, show_label, NULL, 5);
++static SENSOR_DEVICE_ATTR(in5_input, S_IRUGO, show_adc, NULL, 6);
++static SENSOR_DEVICE_ATTR(in5_label, S_IRUGO, show_label, NULL, 6);
++static SENSOR_DEVICE_ATTR(in6_input, S_IRUGO, show_adc, NULL, 7);
++static SENSOR_DEVICE_ATTR(in6_label, S_IRUGO, show_label, NULL, 7);
++static SENSOR_DEVICE_ATTR(in7_input, S_IRUGO, show_adc, NULL, 8);
++static SENSOR_DEVICE_ATTR(in7_label, S_IRUGO, show_label, NULL, 8);
++static SENSOR_DEVICE_ATTR(in8_input, S_IRUGO, show_adc, NULL, 9);
++static SENSOR_DEVICE_ATTR(in8_label, S_IRUGO, show_label, NULL, 9);
++static SENSOR_DEVICE_ATTR(in9_input, S_IRUGO, show_adc, NULL, 10);
++static SENSOR_DEVICE_ATTR(in9_label, S_IRUGO, show_label, NULL, 10);
++static SENSOR_DEVICE_ATTR(in10_input, S_IRUGO, show_adc, NULL, 11);
++static SENSOR_DEVICE_ATTR(in10_label, S_IRUGO, show_label, NULL, 11);
++static SENSOR_DEVICE_ATTR(in11_input, S_IRUGO, show_adc, NULL, 12);
++static SENSOR_DEVICE_ATTR(in11_label, S_IRUGO, show_label, NULL, 12);
++static SENSOR_DEVICE_ATTR(in12_input, S_IRUGO, show_adc, NULL, 13);
++static SENSOR_DEVICE_ATTR(in12_label, S_IRUGO, show_label, NULL, 13);
++
++static SENSOR_DEVICE_ATTR(fan0_point0, S_IRUGO | S_IWUSR, show_adc, store_fan, 14);
++static SENSOR_DEVICE_ATTR(fan0_point1, S_IRUGO | S_IWUSR, show_adc, store_fan, 15);
++static SENSOR_DEVICE_ATTR(fan0_point2, S_IRUGO | S_IWUSR, show_adc, store_fan, 16);
++static SENSOR_DEVICE_ATTR(fan0_point3, S_IRUGO | S_IWUSR, show_adc, store_fan, 17);
++static SENSOR_DEVICE_ATTR(fan0_point4, S_IRUGO | S_IWUSR, show_adc, store_fan, 18);
++static SENSOR_DEVICE_ATTR(fan0_point5, S_IRUGO | S_IWUSR, show_adc, store_fan, 19);
++
++static struct attribute *gsp_attributes[] = {
++	&sensor_dev_attr_temp0_input.dev_attr.attr,
++	&sensor_dev_attr_in0_input.dev_attr.attr,
++	&sensor_dev_attr_in1_input.dev_attr.attr,
++	&sensor_dev_attr_in2_input.dev_attr.attr,
++	&sensor_dev_attr_in3_input.dev_attr.attr,
++	&sensor_dev_attr_in4_input.dev_attr.attr,
++	&sensor_dev_attr_in5_input.dev_attr.attr,
++	&sensor_dev_attr_in6_input.dev_attr.attr,
++	&sensor_dev_attr_in7_input.dev_attr.attr,
++	&sensor_dev_attr_in8_input.dev_attr.attr,
++	&sensor_dev_attr_in9_input.dev_attr.attr,
++	&sensor_dev_attr_in10_input.dev_attr.attr,
++	&sensor_dev_attr_in11_input.dev_attr.attr,
++	&sensor_dev_attr_in12_input.dev_attr.attr,
++
++	&sensor_dev_attr_temp0_label.dev_attr.attr,
++	&sensor_dev_attr_in0_label.dev_attr.attr,
++	&sensor_dev_attr_in1_label.dev_attr.attr,
++	&sensor_dev_attr_in2_label.dev_attr.attr,
++	&sensor_dev_attr_in3_label.dev_attr.attr,
++	&sensor_dev_attr_in4_label.dev_attr.attr,
++	&sensor_dev_attr_in5_label.dev_attr.attr,
++	&sensor_dev_attr_in6_label.dev_attr.attr,
++	&sensor_dev_attr_in7_label.dev_attr.attr,
++	&sensor_dev_attr_in8_label.dev_attr.attr,
++	&sensor_dev_attr_in9_label.dev_attr.attr,
++	&sensor_dev_attr_in10_label.dev_attr.attr,
++	&sensor_dev_attr_in11_label.dev_attr.attr,
++	&sensor_dev_attr_in12_label.dev_attr.attr,
++
++	&sensor_dev_attr_fan0_point0.dev_attr.attr,
++	&sensor_dev_attr_fan0_point1.dev_attr.attr,
++	&sensor_dev_attr_fan0_point2.dev_attr.attr,
++	&sensor_dev_attr_fan0_point3.dev_attr.attr,
++	&sensor_dev_attr_fan0_point4.dev_attr.attr,
++	&sensor_dev_attr_fan0_point5.dev_attr.attr,
++	NULL
++};
++
++
++static int gsp_probe(struct i2c_client *client,
++			 const struct i2c_device_id *id)
++{
++	struct i2c_adapter *adapter = client->adapter;
++	struct gsp_data *data;
++	int err;
++
++	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA |
++					I2C_FUNC_SMBUS_WORD_DATA)) {
++		err = -EOPNOTSUPP;
++		goto exit;
++	}
++
++	if (!(data = kzalloc(sizeof(struct gsp_data), GFP_KERNEL))) {
++		err = -ENOMEM;
++		goto exit;
++	}
++
++	i2c_set_clientdata(client, data);
++
++	data->type = id->driver_data;
++
++	switch (data->type) {
++	case 0:
++		data->attrs.attrs = gsp_attributes;
++		break;
++	}
++
++	dev_info(&client->dev, "%s chip found\n", client->name);
++
++	/* Register sysfs hooks */
++	if ((err = sysfs_create_group(&client->dev.kobj, &data->attrs)))
++		goto exit_free;
++
++	data->hwmon_dev = hwmon_device_register(&client->dev);
++	if (IS_ERR(data->hwmon_dev)) {
++		err = PTR_ERR(data->hwmon_dev);
++		goto exit_remove;
++	}
++
++	return 0;
++
++exit_remove:
++	sysfs_remove_group(&client->dev.kobj, &data->attrs);
++exit_free:
++	kfree(data);
++exit:
++	return err;
++}
++
++static int gsp_remove(struct i2c_client *client)
++{
++	struct gsp_data *data = i2c_get_clientdata(client);
++	hwmon_device_unregister(data->hwmon_dev);
++	sysfs_remove_group(&client->dev.kobj, &data->attrs);
++	kfree(data);
++	return 0;
++}
++
++static int __init gsp_init(void)
++{
++	return i2c_add_driver(&gsp_driver);
++}
++
++static void __exit gsp_exit(void)
++{
++	i2c_del_driver(&gsp_driver);
++}
++
++module_init(gsp_init);
++module_exit(gsp_exit);
++
++MODULE_AUTHOR("Chris Lang <clang@gateworks.com>");
++MODULE_DESCRIPTION("GSP HWMON driver");
++MODULE_LICENSE("GPL");
++MODULE_VERSION(DRV_VERSION);
++
+--- a/drivers/hwmon/Kconfig
++++ b/drivers/hwmon/Kconfig
+@@ -68,6 +68,15 @@ config SENSORS_ABITUGURU3
+ 	  This driver can also be built as a module.  If so, the module
+ 	  will be called abituguru3.
+ 
++config SENSORS_GSP
++  tristate "Gateworks System Peripheral"
++  depends on I2C && EXPERIMENTAL
++  help
++    If you say yes here you get support for the Gateworks System Peripherals.
++
++    This driver can also be built as a module. If so, the module
++    will be called gsp.
++
+ config SENSORS_AD7414
+ 	tristate "Analog Devices AD7414"
+ 	depends on I2C && EXPERIMENTAL
+--- a/drivers/hwmon/Makefile
++++ b/drivers/hwmon/Makefile
+@@ -20,6 +20,7 @@ obj-$(CONFIG_SENSORS_W83791D)	+= w83791d
+ 
+ obj-$(CONFIG_SENSORS_ABITUGURU)	+= abituguru.o
+ obj-$(CONFIG_SENSORS_ABITUGURU3)+= abituguru3.o
++obj-$(CONFIG_SENSORS_GSP)	+= gsp.o
+ obj-$(CONFIG_SENSORS_AD7414)	+= ad7414.o
+ obj-$(CONFIG_SENSORS_AD7418)	+= ad7418.o
+ obj-$(CONFIG_SENSORS_ADCXX)	+= adcxx.o
Index: trunk/target/linux/ixp4xx/patches-2.6.37/506-gw2370_support.patch
===================================================================
--- trunk/target/linux/ixp4xx/patches-2.6.37/506-gw2370_support.patch	(revision 0)
+++ trunk/target/linux/ixp4xx/patches-2.6.37/506-gw2370_support.patch	(working copy)
@@ -0,0 +1,89 @@
+--- a/arch/arm/mach-ixp4xx/avila-setup.c
++++ b/arch/arm/mach-ixp4xx/avila-setup.c
+@@ -493,14 +493,14 @@ static void __init avila_gw2365_setup(vo
+ 	avila_npec_data.phy = 2;
+ 	platform_device_register(&avila_npec_device);
+ 
+-	avila_pata_resources[0].start = IXP4XX_EXP_BUS_BASE(1);
+-	avila_pata_resources[0].end = IXP4XX_EXP_BUS_END(1);
++	avila_pata_resources[0].start = IXP4XX_EXP_BUS_BASE(2);
++	avila_pata_resources[0].end = IXP4XX_EXP_BUS_END(2);
+ 
+-	avila_pata_resources[1].start = IXP4XX_EXP_BUS_BASE(2);
+-	avila_pata_resources[1].end = IXP4XX_EXP_BUS_END(2);
++	avila_pata_resources[1].start = IXP4XX_EXP_BUS_BASE(3);
++	avila_pata_resources[1].end = IXP4XX_EXP_BUS_END(3);
+ 
+-	avila_pata_data.cs0_cfg = IXP4XX_EXP_CS1;
+-	avila_pata_data.cs1_cfg = IXP4XX_EXP_CS2;
++	avila_pata_data.cs0_cfg = IXP4XX_EXP_CS2;
++	avila_pata_data.cs1_cfg = IXP4XX_EXP_CS3;
+ 
+ 	platform_device_register(&avila_pata);
+ 
+@@ -518,6 +518,37 @@ static void __init avila_gw2369_setup(vo
+ 	platform_device_register(&avila_npec_device);
+ }
+ 
++static void __init avila_gw2370_setup(void)
++{
++	avila_npeb_data.phy = 5;
++	platform_device_register(&avila_npeb_device);
++
++	avila_npec_data.phy = IXP4XX_ETH_PHY_MAX_ADDR;
++	avila_npec_data.phy_mask = 0x1e; /* ports 1-4 of the KS8995 switch */
++	platform_device_register(&avila_npec_device);
++
++	*IXP4XX_EXP_CS2 = 0xBFFF3C43;
++	set_irq_type(IRQ_IXP4XX_GPIO2, IRQ_TYPE_EDGE_RISING);
++	avila_optional_uart_data[0].mapbase = 0x52000000;
++	avila_optional_uart_data[0].membase = (void __iomem *)ioremap(0x52000000, 0x0fff);
++	avila_optional_uart_data[0].irq   = IRQ_IXP4XX_GPIO2;
++
++	*IXP4XX_EXP_CS3 = 0xBFFF3C43;
++	set_irq_type(IRQ_IXP4XX_GPIO3, IRQ_TYPE_EDGE_RISING);
++	avila_optional_uart_data[1].mapbase = 0x53000000;
++	avila_optional_uart_data[1].membase = (void __iomem *)ioremap(0x53000000, 0x0fff);
++	avila_optional_uart_data[1].irq   = IRQ_IXP4XX_GPIO3;
++
++	avila_optional_uart.num_resources = 2;
++
++	platform_device_register(&avila_optional_uart);
++
++	avila_gpio_leds[0].gpio = 101;
++	platform_device_register(&avila_gpio_leds_device);
++}
++
++
++
+ static struct avila_board_info avila_boards[] __initdata = {
+ 	{
+ 		.model		= "GW2342",
+@@ -546,6 +577,9 @@ static struct avila_board_info avila_boa
+ 	}, {
+ 		.model		= "GW2369",
+ 		.setup		= avila_gw2369_setup,
++	}, {
++		.model		= "GW2370",
++		.setup		= avila_gw2370_setup,
+ 	}
+ };
+ 
+@@ -590,7 +624,7 @@ static void at24_setup(struct memory_acc
+ static struct at24_platform_data avila_eeprom_info = {
+ 	.byte_len	= 1024,
+ 	.page_size	= 16,
+-	.flags		= AT24_FLAG_READONLY,
++	//.flags		= AT24_FLAG_READONLY,
+ 	.setup		= at24_setup,
+ };
+ 
+@@ -628,7 +662,7 @@ static void __init avila_init(void)
+ 	 */
+ 	avila_flash_resource.start = IXP4XX_EXP_BUS_BASE(0);
+ 	avila_flash_resource.end =
+-		IXP4XX_EXP_BUS_BASE(0) + ixp4xx_exp_bus_size - 1;
++		IXP4XX_EXP_BUS_BASE(0) + (2 * ixp4xx_exp_bus_size) - 1;
+ 
+ 	platform_add_devices(avila_devices, ARRAY_SIZE(avila_devices));
+ 
Index: trunk/target/linux/ixp4xx/patches-2.6.37/507-gw2371_support.patch
===================================================================
--- trunk/target/linux/ixp4xx/patches-2.6.37/507-gw2371_support.patch	(revision 0)
+++ trunk/target/linux/ixp4xx/patches-2.6.37/507-gw2371_support.patch	(working copy)
@@ -0,0 +1,12 @@
+--- a/arch/arm/mach-ixp4xx/cambria-setup.c
++++ b/arch/arm/mach-ixp4xx/cambria-setup.c
+@@ -448,6 +448,9 @@ static struct cambria_board_info cambria
+ 	}, {
+ 		.model	= "GW2358",
+ 		.setup	= cambria_gw2358_setup,
++	}, {
++		.model	= "GW2371",
++		.setup	= cambria_gw2358_setup,
+ 	}
+ };
+ 
Index: trunk/target/linux/ixp4xx/patches-2.6.37/508-gw2373_support.patch
===================================================================
--- trunk/target/linux/ixp4xx/patches-2.6.37/508-gw2373_support.patch	(revision 0)
+++ trunk/target/linux/ixp4xx/patches-2.6.37/508-gw2373_support.patch	(working copy)
@@ -0,0 +1,12 @@
+--- a/arch/arm/mach-ixp4xx/avila-setup.c
++++ b/arch/arm/mach-ixp4xx/avila-setup.c
+@@ -580,6 +580,9 @@ static struct avila_board_info avila_boa
+ 	}, {
+ 		.model		= "GW2370",
+ 		.setup		= avila_gw2370_setup,
++	}, {
++		.model		= "GW2373",
++		.setup		= avila_gw2369_setup,
+ 	}
+ };
+ 
Index: trunk/target/linux/ixp4xx/patches-2.6.37/509-avila_hss_audio_support.patch
===================================================================
--- trunk/target/linux/ixp4xx/patches-2.6.37/509-avila_hss_audio_support.patch	(revision 0)
+++ trunk/target/linux/ixp4xx/patches-2.6.37/509-avila_hss_audio_support.patch	(working copy)
@@ -0,0 +1,2215 @@
+--- a/sound/soc/Kconfig
++++ b/sound/soc/Kconfig
+@@ -40,6 +40,7 @@ source "sound/soc/s3c24xx/Kconfig"
+ source "sound/soc/s6000/Kconfig"
+ source "sound/soc/sh/Kconfig"
+ source "sound/soc/txx9/Kconfig"
++source "sound/soc/gw-avila/Kconfig"
+ 
+ # Supported codecs
+ source "sound/soc/codecs/Kconfig"
+--- a/sound/soc/Makefile
++++ b/sound/soc/Makefile
+@@ -18,3 +18,4 @@ obj-$(CONFIG_SND_SOC)	+= s3c24xx/
+ obj-$(CONFIG_SND_SOC)	+= s6000/
+ obj-$(CONFIG_SND_SOC)	+= sh/
+ obj-$(CONFIG_SND_SOC)	+= txx9/
++obj-$(CONFIG_SND_SOC)	+= gw-avila/
+--- /dev/null
++++ b/sound/soc/gw-avila/Kconfig
+@@ -0,0 +1,17 @@
++config SND_GW_AVILA_SOC_PCM
++	tristate
++
++config SND_GW_AVILA_SOC_HSS
++	tristate
++
++config SND_GW_AVILA_SOC
++	tristate "SoC Audio for the Gateworks AVILA Family"
++	depends on ARCH_IXP4XX && SND_SOC
++	select SND_GW_AVILA_SOC_PCM
++	select SND_GW_AVILA_SOC_HSS
++	select SND_SOC_TLV320AIC3X
++	help
++	  Say Y or M if you want to add support for codecs attached to
++	  the Gateworks HSS interface. You will also need
++	  to select the audio interfaces to support below.
++
+--- /dev/null
++++ b/sound/soc/gw-avila/Makefile
+@@ -0,0 +1,8 @@
++# Gateworks Avila HSS Platform Support
++snd-soc-gw-avila-objs := gw-avila.o ixp4xx_hss.o
++snd-soc-gw-avila-pcm-objs := gw-avila-pcm.o
++snd-soc-gw-avila-hss-objs := gw-avila-hss.o
++
++obj-$(CONFIG_SND_GW_AVILA_SOC) += snd-soc-gw-avila.o
++obj-$(CONFIG_SND_GW_AVILA_SOC_PCM) += snd-soc-gw-avila-pcm.o
++obj-$(CONFIG_SND_GW_AVILA_SOC_HSS) += snd-soc-gw-avila-hss.o
+--- /dev/null
++++ b/sound/soc/gw-avila/gw-avila-hss.c
+@@ -0,0 +1,98 @@
++/*
++ * gw-avila-hss.c -- HSS Audio Support for Gateworks Avila
++ *
++ * Author:	Chris Lang	<clang@gateworks.com>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ */
++
++#include <linux/init.h>
++#include <linux/module.h>
++#include <linux/platform_device.h>
++#include <linux/interrupt.h>
++#include <linux/wait.h>
++#include <linux/delay.h>
++
++#include <sound/core.h>
++#include <sound/pcm.h>
++#include <sound/ac97_codec.h>
++#include <sound/initval.h>
++#include <sound/soc.h>
++
++#include <asm/irq.h>
++#include <linux/mutex.h>
++#include <linux/gpio.h>
++
++#include "ixp4xx_hss.h"
++#include "gw-avila-hss.h"
++
++#define gw_avila_hss_suspend	NULL
++#define gw_avila_hss_resume	NULL
++
++struct snd_soc_dai_driver gw_avila_hss_dai = {
++	.playback = {
++		.channels_min = 2,
++		.channels_max = 2,
++		.rates = (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000 |
++			SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_32000 |
++			SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 |
++			SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000 |
++			SNDRV_PCM_RATE_KNOT),
++		.formats = SNDRV_PCM_FMTBIT_S16_LE, },
++	.capture = {
++		.channels_min = 2,
++		.channels_max = 2,
++		.rates = (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000 |
++			SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_32000 |
++			SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 |
++			SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000 |
++			SNDRV_PCM_RATE_KNOT),
++		.formats = SNDRV_PCM_FMTBIT_S16_LE, },
++};
++
++static int gw_avila_hss_probe(struct platform_device *pdev)
++{
++	int port = (pdev->id < 2) ? 0 : 1;
++	int channel = (pdev->id % 2);
++
++	hss_handle[pdev->id] = hss_init(port, channel);
++	if (!hss_handle[pdev->id]) {
++		return -ENODEV;
++	}
++
++	return snd_soc_register_dai(&pdev->dev, &gw_avila_hss_dai);
++}
++
++static int gw_avila_hss_remove(struct platform_device *pdev)
++{
++	snd_soc_unregister_dai(&pdev->dev);
++
++	return 0;
++}
++
++static struct platform_driver gw_avila_hss_driver = {
++	.probe    = gw_avila_hss_probe,
++	.remove   = gw_avila_hss_remove,
++	.driver   = {
++		.name = "gw_avila_hss",
++		.owner  = THIS_MODULE,
++	}
++};
++
++static int __init gw_avila_hss_init(void)
++{
++	return platform_driver_register(&gw_avila_hss_driver);
++}
++module_init(gw_avila_hss_init);
++
++static void __exit gw_avila_hss_exit(void)
++{
++	platform_driver_unregister(&gw_avila_hss_driver);
++}
++module_exit(gw_avila_hss_exit);
++
++MODULE_AUTHOR("Chris Lang");
++MODULE_DESCRIPTION("HSS Audio Driver for Gateworks Avila");
++MODULE_LICENSE("GPL");
+--- /dev/null
++++ b/sound/soc/gw-avila/gw-avila-hss.h
+@@ -0,0 +1,12 @@
++/*
++ * Author: Chris Lang <clang@gateworks.com>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ */
++
++#ifndef _GW_AVILA_HSS_H
++#define _GW_AVILA_HSS_H
++
++#endif
+--- /dev/null
++++ b/sound/soc/gw-avila/gw-avila-pcm.c
+@@ -0,0 +1,325 @@
++/*
++ * ALSA PCM interface for the TI DAVINCI processor
++ *
++ * Author:      Chris Lang, <clang@gateworks.com>
++ * Copyright:   (C) 2009 Gateworks Corporation
++ *
++ * Based On:    davinci-evm.c, Author: Vladimir Barinov, <vbarinov@ru.mvista.com>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ */
++
++#include <linux/module.h>
++#include <linux/init.h>
++#include <linux/platform_device.h>
++#include <linux/slab.h>
++#include <linux/dma-mapping.h>
++
++#include <sound/core.h>
++#include <sound/pcm.h>
++#include <sound/pcm_params.h>
++#include <sound/soc.h>
++
++#include <asm/dma.h>
++
++#include "gw-avila-pcm.h"
++#include "gw-avila-hss.h"
++#include "ixp4xx_hss.h"
++
++#define GW_AVILA_PCM_DEBUG 0
++#if GW_AVILA_PCM_DEBUG
++#define DPRINTK(x...) printk(KERN_DEBUG x)
++#else
++#define DPRINTK(x...)
++#endif
++
++static struct snd_pcm_hardware gw_avila_pcm_hardware = {
++	.info = (SNDRV_PCM_INFO_INTERLEAVED | SNDRV_PCM_INFO_BLOCK_TRANSFER |
++		 SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_MMAP_VALID),
++/*		 SNDRV_PCM_INFO_PAUSE),*/
++	.formats = (SNDRV_PCM_FMTBIT_S16_LE),
++	.rates = (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000 |
++		  SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_32000 |
++		  SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 |
++		  SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000 |
++		  SNDRV_PCM_RATE_KNOT),
++	.rate_min = 8000,
++	.rate_max = 8000,
++	.channels_min = 2,
++	.channels_max = 2,
++	.buffer_bytes_max = 64 * 1024, // All of the lines below may need to be changed
++	.period_bytes_min = 128,
++	.period_bytes_max = 4 * 1024,
++	.periods_min = 16,
++	.periods_max = 32,
++	.fifo_size = 0,
++};
++
++struct gw_avila_runtime_data {
++	spinlock_t lock;
++	int period;		/* current DMA period */
++	int master_lch;		/* Master DMA channel */
++	int slave_lch;		/* Slave DMA channel */
++	struct gw_avila_pcm_dma_params *params;	/* DMA params */
++};
++
++static void gw_avila_dma_irq(void *data)
++{
++	struct snd_pcm_substream *substream = data;
++	snd_pcm_period_elapsed(substream);
++}
++
++static int gw_avila_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
++{
++	struct snd_pcm_runtime *runtime = substream->runtime;
++	struct hss_device *hdev = runtime->private_data;
++	int ret = 0;
++
++	switch (cmd) {
++	case SNDRV_PCM_TRIGGER_START:
++	case SNDRV_PCM_TRIGGER_RESUME:
++	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
++		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
++			hss_tx_start(hdev);
++		else
++			hss_rx_start(hdev);
++		break;
++	case SNDRV_PCM_TRIGGER_STOP:
++	case SNDRV_PCM_TRIGGER_SUSPEND:
++	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
++		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
++			hss_tx_stop(hdev);
++		else
++			hss_rx_stop(hdev);
++		break;
++	default:
++		ret = -EINVAL;
++		break;
++	}
++	return ret;
++}
++
++static int gw_avila_pcm_prepare(struct snd_pcm_substream *substream)
++{
++	struct snd_pcm_runtime *runtime = substream->runtime;
++	struct hss_device *hdev = runtime->private_data;
++
++	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
++		hss_set_tx_callback(hdev, gw_avila_dma_irq, substream);
++		hss_config_tx_dma(hdev, runtime->dma_area, runtime->buffer_size, runtime->period_size);
++	} else {
++		hss_set_rx_callback(hdev, gw_avila_dma_irq, substream);
++		hss_config_rx_dma(hdev, runtime->dma_area, runtime->buffer_size, runtime->period_size);
++	}
++
++	return 0;
++}
++
++static snd_pcm_uframes_t
++gw_avila_pcm_pointer(struct snd_pcm_substream *substream)
++{
++	struct snd_pcm_runtime *runtime = substream->runtime;
++	struct hss_device *hdev = runtime->private_data;
++
++	unsigned int curr = 0;
++	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
++		curr = hss_curr_offset_tx(hdev);
++	else
++		curr = hss_curr_offset_rx(hdev);
++  return curr;
++}
++
++static int gw_avila_pcm_open(struct snd_pcm_substream *substream)
++{
++	struct snd_pcm_runtime *runtime = substream->runtime;
++	struct snd_soc_pcm_runtime *rtd = substream->private_data;
++	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
++
++	snd_soc_set_runtime_hwparams(substream, &gw_avila_pcm_hardware);
++
++	if (hss_handle[cpu_dai->id] != NULL)
++		runtime->private_data = hss_handle[cpu_dai->id];
++	else {
++		pr_err("hss_handle is NULL\n");
++		return -1;
++	}
++
++	hss_chan_open(hss_handle[cpu_dai->id]);
++
++	return 0;
++}
++
++static int gw_avila_pcm_close(struct snd_pcm_substream *substream)
++{
++	struct snd_pcm_runtime *runtime = substream->runtime;
++	struct hss_device *hdev = runtime->private_data;
++
++	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
++		memset(hdev->tx_buf, 0, runtime->buffer_size);
++	} else
++		memset(hdev->rx_buf, 0, runtime->buffer_size);
++
++	hss_chan_close(hdev);
++
++	return 0;
++}
++
++static int gw_avila_pcm_hw_params(struct snd_pcm_substream *substream,
++				 struct snd_pcm_hw_params *hw_params)
++{
++	return snd_pcm_lib_malloc_pages(substream,
++					params_buffer_bytes(hw_params));
++}
++
++static int gw_avila_pcm_hw_free(struct snd_pcm_substream *substream)
++{
++	struct snd_pcm_runtime *runtime = substream->runtime;
++
++	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
++	  memset(runtime->dma_area, 0, runtime->buffer_size);
++
++	return snd_pcm_lib_free_pages(substream);
++}
++
++static int gw_avila_pcm_mmap(struct snd_pcm_substream *substream,
++          struct vm_area_struct *vma)
++{
++	struct snd_pcm_runtime *runtime = substream->runtime;
++
++	return dma_mmap_writecombine(substream->pcm->card->dev, vma,
++						runtime->dma_area,
++						runtime->dma_addr,
++						runtime->dma_bytes);
++}
++
++struct snd_pcm_ops gw_avila_pcm_ops = {
++	.open = 	gw_avila_pcm_open,
++	.close = 	gw_avila_pcm_close,
++	.ioctl = 	snd_pcm_lib_ioctl,
++	.hw_params = 	gw_avila_pcm_hw_params,
++	.hw_free = 	gw_avila_pcm_hw_free,
++	.prepare = 	gw_avila_pcm_prepare,
++	.trigger = 	gw_avila_pcm_trigger,
++	.pointer = 	gw_avila_pcm_pointer,
++	.mmap = gw_avila_pcm_mmap,
++};
++
++static int gw_avila_pcm_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)
++{
++	struct snd_pcm_substream *substream = pcm->streams[stream].substream;
++	struct snd_dma_buffer *buf = &substream->dma_buffer;
++	size_t size = gw_avila_pcm_hardware.buffer_bytes_max;
++
++	buf->dev.type = SNDRV_DMA_TYPE_DEV;
++	buf->dev.dev = pcm->card->dev;
++	buf->private_data = NULL;
++
++	buf->area = dma_alloc_coherent(pcm->card->dev, size,
++					   &buf->addr, GFP_KERNEL);
++
++	if (!buf->area) {
++		return -ENOMEM;
++	}
++
++	memset(buf->area, 0xff, size);
++
++	DPRINTK("preallocate_dma_buffer: area=%p, addr=%p, size=%d\n",
++		(void *) buf->area, (void *) buf->addr, size);
++
++	buf->bytes = size;
++
++	return 0;
++}
++
++static void gw_avila_pcm_free(struct snd_pcm *pcm)
++{
++	struct snd_pcm_substream *substream;
++	struct snd_dma_buffer *buf;
++	int stream;
++
++	for (stream = 0; stream < 2; stream++) {
++		substream = pcm->streams[stream].substream;
++		if (!substream)
++			continue;
++
++		buf = &substream->dma_buffer;
++		if (!buf->area)
++			continue;
++
++		dma_free_coherent(NULL, buf->bytes, buf->area, 0);
++		buf->area = NULL;
++	}
++}
++
++static u64 gw_avila_pcm_dmamask = 0xFFFFFFFF;
++
++static int gw_avila_pcm_new(struct snd_card *card,
++		struct snd_soc_dai *dai, struct snd_pcm *pcm)
++{
++	int ret;
++
++	if (!card->dev->dma_mask)
++		card->dev->dma_mask = &gw_avila_pcm_dmamask;
++	if (!card->dev->coherent_dma_mask)
++		card->dev->coherent_dma_mask = 0xFFFFFFFF;
++
++	if (dai->driver->playback.channels_min) {
++		ret = gw_avila_pcm_preallocate_dma_buffer(pcm,
++			SNDRV_PCM_STREAM_PLAYBACK);
++		if (ret)
++			return ret;
++	}
++
++	if (dai->driver->capture.channels_min) {
++		ret = gw_avila_pcm_preallocate_dma_buffer(pcm,
++			SNDRV_PCM_STREAM_CAPTURE);
++		if (ret)
++			return ret;
++	}
++
++	return 0;
++}
++
++struct snd_soc_platform_driver gw_avila_soc_platform = {
++	.ops = 	&gw_avila_pcm_ops,
++	.pcm_new = 	gw_avila_pcm_new,
++	.pcm_free = 	gw_avila_pcm_free,
++};
++
++static int __devinit gw_avila_pcm_platform_probe(struct platform_device *pdev)
++{
++	return snd_soc_register_platform(&pdev->dev, &gw_avila_soc_platform);
++}
++
++static int __devexit gw_avila_pcm_platform_remove(struct platform_device *pdev)
++{
++	snd_soc_unregister_platform(&pdev->dev);
++	return 0;
++}
++
++static struct platform_driver gw_avila_pcm_driver = {
++	.driver = {
++		.name = "gw_avila-audio",
++		.owner = THIS_MODULE,
++	},
++	.probe = gw_avila_pcm_platform_probe,
++	.remove = __devexit_p(gw_avila_pcm_platform_remove),
++};
++
++static int __init gw_avila_soc_platform_init(void)
++{
++	return platform_driver_register(&gw_avila_pcm_driver);
++}
++module_init(gw_avila_soc_platform_init);
++
++static void __exit gw_avila_soc_platform_exit(void)
++{
++	platform_driver_unregister(&gw_avila_pcm_driver);
++}
++module_exit(gw_avila_soc_platform_exit);
++
++MODULE_AUTHOR("Chris Lang");
++MODULE_DESCRIPTION("Gateworks Avila PCM DMA module");
++MODULE_LICENSE("GPL");
+--- /dev/null
++++ b/sound/soc/gw-avila/gw-avila-pcm.h
+@@ -0,0 +1,32 @@
++/*
++ * ALSA PCM interface for the Gateworks Avila platform
++ *
++ * Author:      Chris Lang, <clang@gateworks.com>
++ * Copyright:   (C) 2009 Gateworks Corporation
++ *
++ * Based On:    davinci-evm.c, Author: Vladimir Barinov, <vbarinov@ru.mvista.com>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ */
++
++#ifndef _GW_AVILA_PCM_H
++#define _GW_AVILA_PCM_H
++
++#if 0
++struct gw_avila_pcm_dma_params {
++	char *name;		/* stream identifier */
++	int channel;		/* sync dma channel ID */
++	dma_addr_t dma_addr;	/* device physical address for DMA */
++	unsigned int data_type;	/* xfer data type */
++};
++
++struct gw_avila_snd_platform_data {
++	int tx_dma_ch; // XXX Do we need this?
++	int rx_dma_ch; // XXX Do we need this
++};
++extern struct snd_soc_platform gw_avila_soc_platform[];
++#endif
++
++#endif
+--- /dev/null
++++ b/sound/soc/gw-avila/gw-avila.c
+@@ -0,0 +1,241 @@
++/*
++ * File:         sound/soc/gw-avila/gw_avila.c
++ * Author:       Chris Lang <clang@gateworks.com>
++ *
++ * Created:      Tue June 06 2008
++ * Description:  Board driver for Gateworks Avila
++ *
++ * Modified:
++ *               Copyright 2009 Gateworks Corporation
++ *
++ * Bugs:         What Bugs?
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, see the file COPYING, or write
++ * to the Free Software Foundation, Inc.,
++ * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
++ */
++
++#include <linux/module.h>
++#include <linux/moduleparam.h>
++#include <linux/device.h>
++#include <asm/dma.h>
++#include <linux/platform_device.h>
++#include <sound/core.h>
++#include <sound/pcm.h>
++#include <sound/soc.h>
++#include <sound/soc-dapm.h>
++#include <linux/slab.h>
++#include <linux/gpio.h>
++
++#include "../codecs/tlv320aic3x.h"
++#include "ixp4xx_hss.h"
++#include "gw-avila-hss.h"
++#include "gw-avila-pcm.h"
++
++#define CODEC_FREQ 33333000
++
++static int gw_avila_board_startup(struct snd_pcm_substream *substream)
++{
++	pr_debug("%s enter\n", __func__);
++	return 0;
++}
++
++static int gw_avila_hw_params(struct snd_pcm_substream *substream,
++		struct snd_pcm_hw_params *params)
++{
++	struct snd_soc_pcm_runtime *rtd = substream->private_data;
++	struct snd_soc_dai *codec_dai = rtd->codec_dai;
++	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
++
++	int ret = 0;
++
++	/* set codec DAI configuration */
++	if (cpu_dai->id % 2) {
++  		ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_DSP_B | SND_SOC_DAIFMT_IB_NF | SND_SOC_DAIFMT_CBS_CFS);
++			snd_soc_dai_set_tdm_slot(codec_dai, 0, 0, 1, 32);
++	} else {
++	  	ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_DSP_B | SND_SOC_DAIFMT_IB_NF | SND_SOC_DAIFMT_CBM_CFM);
++			snd_soc_dai_set_tdm_slot(codec_dai, 0, 0, 0, 32);
++	}
++
++	if (ret < 0)
++	    return ret;
++
++	/* set the codec system clock */
++	ret = snd_soc_dai_set_sysclk(codec_dai, 0, CODEC_FREQ, SND_SOC_CLOCK_OUT);
++	if (ret < 0)
++	    return ret;
++
++	return 0;
++}
++
++static const struct snd_soc_dapm_widget aic3x_dapm_widgets[] = {
++  SND_SOC_DAPM_HP("Headphone Jack", NULL),
++  SND_SOC_DAPM_LINE("Line Out", NULL),
++  SND_SOC_DAPM_LINE("Line In", NULL),
++};
++
++static const struct snd_soc_dapm_route audio_map[] = {
++  {"Headphone Jack", NULL, "HPLOUT"},
++  {"Headphone Jack", NULL, "HPROUT"},
++
++  /* Line Out connected to LLOUT, RLOUT */
++  {"Line Out", NULL, "LLOUT"},
++  {"Line Out", NULL, "RLOUT"},
++
++  /* Line In connected to (LINE1L | LINE2L), (LINE1R | LINE2R) */
++  {"LINE1L", NULL, "Line In"},
++  {"LINE1R", NULL, "Line In"},
++};
++
++/* Logic for a aic3x as connected on a davinci-evm */
++static int aic3x_init(struct snd_soc_pcm_runtime *rtd)
++{
++	struct snd_soc_codec *codec = rtd->codec;
++
++  /* Add davinci-evm specific widgets */
++  snd_soc_dapm_new_controls(codec, aic3x_dapm_widgets,
++          ARRAY_SIZE(aic3x_dapm_widgets));
++
++  /* Set up davinci-evm specific audio path audio_map */
++  snd_soc_dapm_add_routes(codec, audio_map, ARRAY_SIZE(audio_map));
++
++  /* not connected */
++  snd_soc_dapm_disable_pin(codec, "MONO_LOUT");
++  //snd_soc_dapm_disable_pin(codec, "HPLCOM");
++  //snd_soc_dapm_disable_pin(codec, "HPRCOM");
++  snd_soc_dapm_disable_pin(codec, "MIC3L");
++  snd_soc_dapm_disable_pin(codec, "MIC3R");
++  snd_soc_dapm_disable_pin(codec, "LINE2L");
++  snd_soc_dapm_disable_pin(codec, "LINE2R");
++
++  /* always connected */
++	snd_soc_dapm_enable_pin(codec, "Headphone Jack");
++  snd_soc_dapm_enable_pin(codec, "Line Out");
++  snd_soc_dapm_enable_pin(codec, "Line In");
++
++  snd_soc_dapm_sync(codec);
++
++	return 0;
++}
++
++static struct snd_soc_ops gw_avila_board_ops = {
++	.startup = gw_avila_board_startup,
++	.hw_params = gw_avila_hw_params,
++};
++
++static struct snd_soc_dai_link gw_avila_board_dai[] = {
++	{
++		.name = "HSS-0",
++		.stream_name = "HSS-0",
++		.cpu_dai_name = "gw_avila_hss.0",
++		.codec_dai_name = "tlv320aic3x-hifi",
++		.codec_name = "tlv320aic3x-codec.0-001b",
++		.platform_name = "gw_avila-audio.0",
++		.init = aic3x_init,
++		.ops = &gw_avila_board_ops,
++	},{
++		.name = "HSS-1",
++		.stream_name = "HSS-1",
++		.cpu_dai_name = "gw_avila_hss.1",
++		.codec_dai_name = "tlv320aic3x-hifi",
++		.codec_name = "tlv320aic3x-codec.0-001a",
++		.platform_name = "gw_avila-audio.1",
++		.init = aic3x_init,
++		.ops = &gw_avila_board_ops,
++	},{
++		.name = "HSS-2",
++		.stream_name = "HSS-2",
++		.cpu_dai_name = "gw_avila_hss.2",
++		.codec_dai_name = "tlv320aic3x-hifi",
++		.codec_name = "tlv320aic3x-codec.0-0019",
++		.platform_name = "gw_avila-audio.2",
++		.init = aic3x_init,
++		.ops = &gw_avila_board_ops,
++	},{
++		.name = "HSS-3",
++		.stream_name = "HSS-3",
++		.cpu_dai_name = "gw_avila_hss.3",
++		.codec_dai_name = "tlv320aic3x-hifi",
++		.codec_name = "tlv320aic3x-codec.0-0018",
++		.platform_name = "gw_avila-audio.3",
++		.init = aic3x_init,
++		.ops = &gw_avila_board_ops,
++	},
++};
++
++static struct snd_soc_card gw_avila_board[] = {
++	{
++		.name = "gw_avila-board.0",
++		.dai_link = &gw_avila_board_dai[0],
++		.num_links = 1,
++	},{
++		.name = "gw_avila-board.1",
++		.dai_link = &gw_avila_board_dai[1],
++		.num_links = 1,
++	},{
++		.name = "gw_avila-board.2",
++		.dai_link = &gw_avila_board_dai[2],
++		.num_links = 1,
++	},{
++		.name = "gw_avila-board.3",
++		.dai_link = &gw_avila_board_dai[3],
++		.num_links = 1,
++	}
++};
++
++static struct platform_device *gw_avila_board_snd_device[4];
++
++static int __init gw_avila_board_init(void)
++{
++	int ret;
++	struct port *port;
++	int i;
++
++	if ((hss_port[0] = kzalloc(sizeof(*port), GFP_KERNEL)) == NULL)
++		return -ENOMEM;
++
++	if ((hss_port[1] = kzalloc(sizeof(*port), GFP_KERNEL)) == NULL)
++		return -ENOMEM;
++
++	for (i = 0; i < 4; i++) {
++		gw_avila_board_snd_device[i] = platform_device_alloc("soc-audio", i);
++		if (!gw_avila_board_snd_device[i]) {
++			return -ENOMEM;
++		}
++
++		platform_set_drvdata(gw_avila_board_snd_device[i], &gw_avila_board[i]);
++		ret = platform_device_add(gw_avila_board_snd_device[i]);
++
++		if (ret) {
++			platform_device_put(gw_avila_board_snd_device[i]);
++		}
++	}
++	return ret;
++}
++
++static void __exit gw_avila_board_exit(void)
++{
++	int i;
++	for (i = 0; i < 4; i++)
++		platform_device_unregister(gw_avila_board_snd_device[i]);
++}
++
++module_init(gw_avila_board_init);
++module_exit(gw_avila_board_exit);
++
++/* Module information */
++MODULE_AUTHOR("Chris Lang");
++MODULE_DESCRIPTION("ALSA SoC HSS Audio gw_avila board");
++MODULE_LICENSE("GPL");
+--- /dev/null
++++ b/sound/soc/gw-avila/ixp4xx_hss.c
+@@ -0,0 +1,900 @@
++/*
++ * Intel IXP4xx HSS (synchronous serial port) driver for Linux
++ *
++ * Copyright (C) 2009 Chris Lang <clang@gateworks.com>
++ *
++ * This program is free software; you can redistribute it and/or modify it
++ * under the terms of version 2 of the GNU General Public License
++ * as published by the Free Software Foundation.
++ */
++
++#include <linux/bitops.h>
++#include <linux/cdev.h>
++#include <linux/dma-mapping.h>
++#include <linux/dmapool.h>
++#include <linux/fs.h>
++#include <linux/io.h>
++#include <linux/kernel.h>
++#include <linux/platform_device.h>
++#include <linux/poll.h>
++#include <linux/slab.h>
++#include <mach/npe.h>
++#include <mach/qmgr.h>
++#include <linux/delay.h>
++
++#include "ixp4xx_hss.h"
++
++/*****************************************************************************
++ * global variables
++ ****************************************************************************/
++
++void hss_chan_read(unsigned long data);
++static char lock_init = 0;
++static spinlock_t npe_lock;
++static struct npe *npe;
++
++static const struct {
++	int tx, txdone, rx, rxfree, chan;
++}queue_ids[2] = {{HSS0_PKT_TX0_QUEUE, HSS0_PKT_TXDONE_QUEUE, HSS0_PKT_RX_QUEUE,
++		  HSS0_PKT_RXFREE0_QUEUE, HSS0_CHL_RXTRIG_QUEUE},
++		 {HSS1_PKT_TX0_QUEUE, HSS1_PKT_TXDONE_QUEUE, HSS1_PKT_RX_QUEUE,
++		  HSS1_PKT_RXFREE0_QUEUE, HSS1_CHL_RXTRIG_QUEUE},
++};
++
++struct port *hss_port[2];
++struct hss_device *hss_handle[32];
++EXPORT_SYMBOL(hss_handle);
++
++/*****************************************************************************
++ * utility functions
++ ****************************************************************************/
++
++#ifndef __ARMEB__
++static inline void memcpy_swab32(u32 *dest, u32 *src, int cnt)
++{
++	int i;
++	for (i = 0; i < cnt; i++)
++		dest[i] = swab32(src[i]);
++}
++#endif
++
++static inline unsigned int sub_offset(unsigned int a, unsigned int b,
++				      unsigned int modulo)
++{
++	return (modulo /* make sure the result >= 0 */ + a - b) % modulo;
++}
++
++/*****************************************************************************
++ * HSS access
++ ****************************************************************************/
++
++static void hss_config_load(struct port *port)
++{
++	struct msg msg;
++
++	do {
++		memset(&msg, 0, sizeof(msg));
++		msg.cmd = PORT_CONFIG_LOAD;
++		msg.hss_port = port->id;
++		if (npe_send_message(npe, &msg, "HSS_LOAD_CONFIG"))
++			break;
++		if (npe_recv_message(npe, &msg, "HSS_LOAD_CONFIG"))
++			break;
++
++		/* HSS_LOAD_CONFIG for port #1 returns port_id = #4 */
++		if (msg.cmd != PORT_CONFIG_LOAD || msg.data32)
++			break;
++
++		/* HDLC may stop working without this */
++		npe_recv_message(npe, &msg, "FLUSH_IT");
++		return;
++	} while (0);
++
++	printk(KERN_CRIT "HSS-%i: unable to reload HSS configuration\n",
++	       port->id);
++	BUG();
++}
++
++static void hss_config_set_pcr(struct port *port)
++{
++	struct msg msg;
++
++	do {
++		memset(&msg, 0, sizeof(msg));
++		msg.cmd = PORT_CONFIG_WRITE;
++		msg.hss_port = port->id;
++		msg.index = HSS_CONFIG_TX_PCR;
++#if 0
++		msg.data32 = PCR_FRM_SYNC_RISINGEDGE | PCR_MSB_ENDIAN |
++			PCR_TX_DATA_ENABLE | PCR_TX_UNASS_HIGH_IMP | PCR_TX_V56K_HIGH_IMP | PCR_TX_FB_HIGH_IMP;
++#else
++		msg.data32 = PCR_FRM_SYNC_RISINGEDGE | PCR_MSB_ENDIAN |
++			PCR_TX_DATA_ENABLE | PCR_TX_FB_HIGH_IMP | PCR_DCLK_EDGE_RISING;
++#endif
++		if (port->frame_size % 8 == 0)
++			msg.data32 |= PCR_SOF_NO_FBIT;
++
++		if (npe_send_message(npe, &msg, "HSS_SET_TX_PCR"))
++			break;
++
++		msg.index = HSS_CONFIG_RX_PCR;
++		msg.data32 &= ~ (PCR_DCLK_EDGE_RISING | PCR_FCLK_EDGE_RISING | PCR_TX_DATA_ENABLE);
++
++		if (npe_send_message(npe, &msg, "HSS_SET_RX_PCR"))
++			break;
++		return;
++	} while (0);
++
++	printk(KERN_CRIT "HSS-%i: unable to set HSS PCR registers\n", port->id);
++	BUG();
++}
++
++static void hss_config_set_core(struct port *port)
++{
++	struct msg msg;
++
++	memset(&msg, 0, sizeof(msg));
++	msg.cmd = PORT_CONFIG_WRITE;
++	msg.hss_port = port->id;
++	msg.index = HSS_CONFIG_CORE_CR;
++#if 0
++	msg.data32 = 0 | CCR_LOOPBACK |
++		(port->id ? CCR_SECOND_HSS : 0);
++#else
++	msg.data32 = 0 |
++		(port->id ? CCR_SECOND_HSS : 0);
++#endif
++	if (npe_send_message(npe, &msg, "HSS_SET_CORE_CR")) {
++		printk(KERN_CRIT "HSS-%i: unable to set HSS core control"
++		       " register\n", port->id);
++		BUG();
++	}
++}
++
++static void hss_config_set_line(struct port *port)
++{
++	struct msg msg;
++
++	hss_config_set_pcr(port);
++	hss_config_set_core(port);
++
++	memset(&msg, 0, sizeof(msg));
++	msg.cmd = PORT_CONFIG_WRITE;
++	msg.hss_port = port->id;
++	msg.index = HSS_CONFIG_CLOCK_CR;
++	msg.data32 = CLK42X_SPEED_8192KHZ /* FIXME */;
++	if (npe_send_message(npe, &msg, "HSS_SET_CLOCK_CR")) {
++		printk(KERN_CRIT "HSS-%i: unable to set HSS clock control"
++		       " register\n", port->id);
++		BUG();
++	}
++}
++
++static void hss_config_set_rx_frame(struct port *port)
++{
++	struct msg msg;
++
++	memset(&msg, 0, sizeof(msg));
++	msg.cmd = PORT_CONFIG_WRITE;
++	msg.hss_port = port->id;
++	msg.index = HSS_CONFIG_RX_FCR;
++	msg.data16a = port->frame_sync_offset;
++	msg.data16b = port->frame_size - 1;
++	if (npe_send_message(npe, &msg, "HSS_SET_RX_FCR")) {
++		printk(KERN_CRIT "HSS-%i: unable to set HSS RX frame size"
++		       " and offset\n", port->id);
++		BUG();
++	}
++}
++
++static void hss_config_set_frame(struct port *port)
++{
++	struct msg msg;
++
++	memset(&msg, 0, sizeof(msg));
++	msg.cmd = PORT_CONFIG_WRITE;
++	msg.hss_port = port->id;
++	msg.index = HSS_CONFIG_TX_FCR;
++	msg.data16a = TX_FRAME_SYNC_OFFSET;
++	msg.data16b = port->frame_size - 1;
++	if (npe_send_message(npe, &msg, "HSS_SET_TX_FCR")) {
++		printk(KERN_CRIT "HSS-%i: unable to set HSS TX frame size"
++		       " and offset\n", port->id);
++		BUG();
++	}
++	hss_config_set_rx_frame(port);
++}
++
++static void hss_config_set_lut(struct port *port)
++{
++	struct msg msg;
++	int chan_count = 32;
++
++	memset(&msg, 0, sizeof(msg));
++	msg.cmd = PORT_CONFIG_WRITE;
++	msg.hss_port = port->id;
++
++	msg.index = HSS_CONFIG_TX_LUT;
++	msg.data32 = 0xffffffff;
++	npe_send_message(npe, &msg, "HSS_SET_TX_LUT");
++	msg.index += 4;
++	npe_send_message(npe, &msg, "HSS_SET_TX_LUT");
++	msg.data32 = 0x0;
++	msg.index += 4;
++	npe_send_message(npe, &msg, "HSS_SET_TX_LUT");
++	msg.index += 4;
++	npe_send_message(npe, &msg, "HSS_SET_TX_LUT");
++	msg.index += 4;
++	npe_send_message(npe, &msg, "HSS_SET_TX_LUT");
++	msg.index += 4;
++	npe_send_message(npe, &msg, "HSS_SET_TX_LUT");
++	msg.index += 4;
++	npe_send_message(npe, &msg, "HSS_SET_TX_LUT");
++	msg.index += 4;
++	npe_send_message(npe, &msg, "HSS_SET_TX_LUT");
++
++	msg.index = HSS_CONFIG_RX_LUT;
++	msg.data32 = 0xffffffff;
++	npe_send_message(npe, &msg, "HSS_SET_RX_LUT");
++	msg.index += 4;
++	npe_send_message(npe, &msg, "HSS_SET_RX_LUT");
++	msg.data32 = 0x0;
++	msg.index += 4;
++	npe_send_message(npe, &msg, "HSS_SET_RX_LUT");
++	msg.index += 4;
++	npe_send_message(npe, &msg, "HSS_SET_RX_LUT");
++	msg.index += 4;
++	npe_send_message(npe, &msg, "HSS_SET_RX_LUT");
++	msg.index += 4;
++	npe_send_message(npe, &msg, "HSS_SET_RX_LUT");
++	msg.index += 4;
++	npe_send_message(npe, &msg, "HSS_SET_RX_LUT");
++	msg.index += 4;
++	npe_send_message(npe, &msg, "HSS_SET_RX_LUT");
++
++	hss_config_set_frame(port);
++
++	memset(&msg, 0, sizeof(msg));
++	msg.cmd = CHAN_NUM_CHANS_WRITE;
++	msg.hss_port = port->id;
++	msg.data8a = chan_count;
++	if (npe_send_message(npe, &msg, "CHAN_NUM_CHANS_WRITE")) {
++		printk(KERN_CRIT "HSS-%i: unable to set HSS channel count\n",
++		       port->id);
++		BUG();
++	}
++}
++
++static u32 hss_config_get_status(struct port *port)
++{
++	struct msg msg;
++
++	do {
++		memset(&msg, 0, sizeof(msg));
++		msg.cmd = PORT_ERROR_READ;
++		msg.hss_port = port->id;
++		if (npe_send_message(npe, &msg, "PORT_ERROR_READ"))
++			break;
++		if (npe_recv_message(npe, &msg, "PORT_ERROR_READ"))
++			break;
++
++		return msg.data32;
++	} while (0);
++
++	printk(KERN_CRIT "HSS-%i: unable to read HSS status\n", port->id);
++	BUG();
++}
++
++static void hss_config_start_chan(struct port *port)
++{
++	struct msg msg;
++
++	port->chan_last_tx = 0;
++	port->chan_last_rx = 0;
++
++	do {
++		memset(&msg, 0, sizeof(msg));
++		msg.cmd = CHAN_RX_BUF_ADDR_WRITE;
++		msg.hss_port = port->id;
++		msg.data32 = port->chan_rx_buf_phys;
++		if (npe_send_message(npe, &msg, "CHAN_RX_BUF_ADDR_WRITE"))
++			break;
++
++		memset(&msg, 0, sizeof(msg));
++		msg.cmd = CHAN_TX_BUF_ADDR_WRITE;
++		msg.hss_port = port->id;
++		msg.data32 = port->chan_tx_pointers_phys;
++		if (npe_send_message(npe, &msg, "CHAN_TX_BUF_ADDR_WRITE"))
++			break;
++
++		memset(&msg, 0, sizeof(msg));
++		msg.cmd = CHAN_FLOW_ENABLE;
++		msg.hss_port = port->id;
++		if (npe_send_message(npe, &msg, "CHAN_FLOW_ENABLE"))
++			break;
++		port->chan_started = 1;
++		return;
++	} while (0);
++
++	printk(KERN_CRIT "HSS-%i: unable to start channelized flow\n",
++	       port->id);
++	BUG();
++}
++
++static void hss_config_stop_chan(struct port *port)
++{
++	struct msg msg;
++
++	if (!port->chan_started)
++		return;
++
++	memset(&msg, 0, sizeof(msg));
++	msg.cmd = CHAN_FLOW_DISABLE;
++	msg.hss_port = port->id;
++	if (npe_send_message(npe, &msg, "CHAN_FLOW_DISABLE")) {
++		printk(KERN_CRIT "HSS-%i: unable to stop channelized flow\n",
++		       port->id);
++		BUG();
++	}
++	hss_config_get_status(port); /* make sure it's halted */
++	port->chan_started = 0;
++}
++
++static int hss_config_load_firmware(struct port *port)
++{
++	struct msg msg;
++
++	if (port->initialized)
++		return 0;
++
++	if (!npe_running(npe)) {
++		int err;
++		if ((err = npe_load_firmware(npe, "NPE-A-HSS",
++					     port->dev)))
++			return err;
++	}
++
++	do {
++		/* HSS main configuration */
++		hss_config_set_line(port);
++
++		hss_config_set_frame(port);
++
++		/* Channelized operation settings */
++		memset(&msg, 0, sizeof(msg));
++		msg.cmd = CHAN_TX_BLK_CFG_WRITE;
++		msg.hss_port = port->id;
++		msg.data8b = (CHAN_TX_LIST_FRAMES & ~7) / 2;
++		msg.data8a = msg.data8b / 4;
++		msg.data8d = CHAN_TX_LIST_FRAMES - msg.data8b;
++		msg.data8c = msg.data8d / 4;
++		if (npe_send_message(npe, &msg, "CHAN_TX_BLK_CFG_WRITE"))
++			break;
++
++		memset(&msg, 0, sizeof(msg));
++		msg.cmd = CHAN_RX_BUF_CFG_WRITE;
++		msg.hss_port = port->id;
++		msg.data8a = CHAN_RX_TRIGGER / 8;
++		msg.data8b = CHAN_RX_FRAMES;
++		if (npe_send_message(npe, &msg, "CHAN_RX_BUF_CFG_WRITE"))
++			break;
++
++		memset(&msg, 0, sizeof(msg));
++		msg.cmd = CHAN_TX_BUF_SIZE_WRITE;
++		msg.hss_port = port->id;
++		msg.data8a = CHAN_TX_LISTS;
++		if (npe_send_message(npe, &msg, "CHAN_TX_BUF_SIZE_WRITE"))
++			break;
++
++		port->initialized = 1;
++		return 0;
++	} while (0);
++
++	printk(KERN_CRIT "HSS-%i: unable to start HSS operation\n", port->id);
++	BUG();
++}
++
++void hss_chan_irq(void *pdev)
++{
++	struct port *port = pdev;
++
++	qmgr_disable_irq(queue_ids[port->id].chan);
++
++	tasklet_hi_schedule(&port->task);
++}
++
++
++int hss_prepare_chan(struct port *port)
++{
++	int err, i, j;
++	u32 *temp;
++	u32 temp2;
++	u8 *temp3;
++
++	if (port->initialized)
++		return 0;
++
++	if ((err = hss_config_load_firmware(port)))
++		return err;
++
++	if ((err = qmgr_request_queue(queue_ids[port->id].chan,
++				      CHAN_QUEUE_LEN, 0, 0, "%s:hss", "hss")))
++		return err;
++
++	port->chan_tx_buf = dma_alloc_coherent(port->dev, chan_tx_buf_len(port), &port->chan_tx_buf_phys, GFP_DMA);
++	memset(port->chan_tx_buf, 0, chan_tx_buf_len(port));
++
++	port->chan_tx_pointers = dma_alloc_coherent(port->dev, chan_tx_buf_len(port) / CHAN_TX_LIST_FRAMES * 4, &port->chan_tx_pointers_phys, GFP_DMA);
++
++	temp3 = port->chan_tx_buf;
++	for (i = 0; i < CHAN_TX_LISTS; i++) {
++		for (j = 0; j < 8; j++) {
++			port->tx_lists[i][j] = temp3;
++			temp3 += CHAN_TX_LIST_FRAMES * 4;
++		}
++	}
++
++	temp = port->chan_tx_pointers;
++	temp2 = port->chan_tx_buf_phys;
++	for (i = 0; i < CHAN_TX_LISTS; i++)
++	{
++		for (j = 0; j < 32; j++)
++		{
++			*temp = temp2;
++			temp2 += CHAN_TX_LIST_FRAMES;
++			temp++;
++		}
++	}
++
++	port->chan_rx_buf = dma_alloc_coherent(port->dev, chan_rx_buf_len(port), &port->chan_rx_buf_phys, GFP_DMA);
++
++	for (i = 0; i < 8; i++) {
++		temp3 = port->chan_rx_buf + (i * 4 * 128);
++		for (j = 0; j < 8; j++) {
++			port->rx_frames[i][j] = temp3;
++			temp3 += CHAN_RX_TRIGGER;
++		}
++	}
++
++	qmgr_set_irq(queue_ids[port->id].chan, QUEUE_IRQ_SRC_NOT_EMPTY,
++		     hss_chan_irq, port);
++
++	return 0;
++
++}
++
++int hss_tx_start(struct hss_device *hdev)
++{
++	unsigned long flags;
++	struct port *port = hdev->port;
++
++	hdev->tx_loc = 0;
++	hdev->tx_frame = 0;
++
++	set_bit((1 << hdev->id), &port->chan_tx_bitmap);
++
++	if (!port->chan_started)
++	{
++		qmgr_enable_irq(queue_ids[port->id].chan);
++		spin_lock_irqsave(&npe_lock, flags);
++		hss_config_start_chan(port);
++		spin_unlock_irqrestore(&npe_lock, flags);
++		hss_chan_irq(port);
++	}
++
++	return 0;
++}
++EXPORT_SYMBOL(hss_tx_start);
++
++int hss_rx_start(struct hss_device *hdev)
++{
++	unsigned long flags;
++	struct port *port = hdev->port;
++
++	hdev->rx_loc = 0;
++	hdev->rx_frame = 0;
++
++	set_bit((1 << hdev->id), &port->chan_rx_bitmap);
++
++	if (!port->chan_started)
++	{
++		qmgr_enable_irq(queue_ids[port->id].chan);
++		spin_lock_irqsave(&npe_lock, flags);
++		hss_config_start_chan(port);
++		spin_unlock_irqrestore(&npe_lock, flags);
++		hss_chan_irq(port);
++	}
++
++	return 0;
++}
++EXPORT_SYMBOL(hss_rx_start);
++
++int hss_tx_stop(struct hss_device *hdev)
++{
++	struct port *port = hdev->port;
++
++	clear_bit((1 << hdev->id), &port->chan_tx_bitmap);
++
++	return 0;
++}
++EXPORT_SYMBOL(hss_tx_stop);
++
++int hss_rx_stop(struct hss_device *hdev)
++{
++	struct port *port = hdev->port;
++
++	clear_bit((1 << hdev->id), &port->chan_rx_bitmap);
++
++	return 0;
++}
++EXPORT_SYMBOL(hss_rx_stop);
++
++int hss_chan_open(struct hss_device *hdev)
++{
++	struct port *port = hdev->port;
++	int i, err = 0;
++
++	if (port->chan_open)
++		return 0;
++
++	if (port->mode == MODE_HDLC) {
++		err = -ENOSYS;
++		goto out;
++	}
++
++	if (port->mode == MODE_G704 && port->channels[0] == hdev->id) {
++		err = -EBUSY; /* channel #0 is used for G.704 signaling */
++		goto out;
++	}
++
++	for (i = MAX_CHANNELS; i > port->frame_size / 8; i--)
++		if (port->channels[i - 1] == hdev->id) {
++			err = -ECHRNG; /* frame too short */
++			goto out;
++		}
++
++	hdev->rx_loc = hdev->tx_loc = 0;
++	hdev->rx_frame = hdev->tx_frame = 0;
++
++	//clear_bit((1 << hdev->id), &port->chan_rx_bitmap);
++	//clear_bit((1 << hdev->id), &port->chan_tx_bitmap);
++
++	if (!port->initialized) {
++		hss_prepare_chan(port);
++
++		hss_config_stop_chan(port);
++		hdev->open_count++;
++		port->chan_open_count++;
++
++		hss_config_set_lut(port);
++		hss_config_load(port);
++
++	}
++	port->chan_open = 1;
++
++out:
++	return err;
++}
++EXPORT_SYMBOL(hss_chan_open);
++
++int hss_chan_close(struct hss_device *hdev)
++{
++	return 0;
++}
++EXPORT_SYMBOL(hss_chan_close);
++
++void hss_chan_read(unsigned long data)
++{
++	struct port *port = (void *)data;
++	struct hss_device *hdev;
++	u8 *hw_buf, *save_buf;
++	u8 *buf;
++	u32 v;
++  unsigned int tx_list, rx_frame;
++	int i, j, channel;
++	u8 more_work = 0;
++
++/*
++	My Data in the hardware buffer is scattered by channels into 4 trunks
++	as follows for rx
++
++					channel 0					channel 1					channel 2					channel 3
++Trunk 1	=	0			-> 	127			128		->	255			256		->	383			384		->	512
++Trunk 2 =	513		->	639			640		->	768			769		->	895			896		->	1023
++Trunk 3 =	1024	->	1151		1152	->	1207		1208	->	1407		1408	->	1535
++Trunk 4 = 1535	->	1663		1664	->	1791		1792	->	1920		1921	->	2047
++
++	I will get CHAN_RX_TRIGGER worth of bytes out of each channel on each trunk
++	with each IRQ
++
++	For TX Data, it is split into 8 lists with each list containing 16 bytes per
++	channel
++
++Trunk 1 = 0		->	16				17		->	32			33		->	48			49		->	64
++Trunk 2 = 65	->	80				81		->	96			97		->	112			113		->	128
++Trunk	3	=	129	->	144				145		->	160			161		->	176			177		->	192
++Trunk	4	=	193	->	208				209		->	224			225		->	240			241		->	256
++
++*/
++
++
++	while ((v = qmgr_get_entry(queue_ids[port->id].chan)))
++	{
++		tx_list = (v >> 8) & 0xFF;
++		rx_frame = v & 0xFF;
++
++		if (tx_list == 7)
++			tx_list = 0;
++		else
++			tx_list++;
++		for (channel = 0; channel < 8; channel++) {
++
++			hdev = port->chan_devices[channel];
++			if (!hdev)
++				continue;
++
++			if (test_bit(1 << channel, &port->chan_tx_bitmap)) {
++				buf = (u8 *)hdev->tx_buf + hdev->tx_loc;
++#if 0
++				hw_buf = (u8 *)port->chan_tx_buf;
++				hw_buf += (tx_list * CHAN_TX_LIST_FRAMES * 32);
++				hw_buf += (4 * CHAN_TX_LIST_FRAMES * channel);
++				save_buf = hw_buf;
++#else
++				save_buf = port->tx_lists[tx_list][channel];
++#endif
++				for (i = 0; i < CHAN_TX_LIST_FRAMES; i++) {
++					hw_buf = save_buf + i;
++					for (j = 0; j < 4; j++) {
++						*hw_buf = *(buf++);
++						hw_buf += CHAN_TX_LIST_FRAMES;
++					}
++
++					hdev->tx_loc += 4;
++					hdev->tx_frame++;
++					if (hdev->tx_loc >= hdev->tx_buffer_size) {
++						hdev->tx_loc = 0;
++						buf = (u8 *)hdev->tx_buf;
++					}
++				}
++			} else {
++#if 0
++				hw_buf = (u8 *)port->chan_tx_buf;
++				hw_buf += (tx_list * CHAN_TX_LIST_FRAMES * 32);
++				hw_buf += (4 * CHAN_TX_LIST_FRAMES * channel);
++#else
++				hw_buf = port->tx_lists[tx_list][channel];
++#endif
++				memset(hw_buf, 0, 64);
++			}
++
++			if (hdev->tx_frame >= hdev->tx_period_size && test_bit(1 << channel, &port->chan_tx_bitmap))
++			{
++				hdev->tx_frame %= hdev->tx_period_size;
++				if (hdev->tx_callback)
++					hdev->tx_callback(hdev->tx_data);
++				more_work = 1;
++			}
++
++			if (test_bit(1 << channel, &port->chan_rx_bitmap)) {
++				buf = (u8 *)hdev->rx_buf + hdev->rx_loc;
++#if 0
++				hw_buf = (u8 *)port->chan_rx_buf;
++				hw_buf += (4 * CHAN_RX_FRAMES * channel);
++				hw_buf += rx_frame;
++				save_buf = hw_buf;
++#else
++				save_buf = port->rx_frames[channel][rx_frame >> 4];
++#endif
++				for (i = 0; i < CHAN_RX_TRIGGER; i++) {
++					hw_buf = save_buf + i;
++					for (j = 0; j < 4; j++) {
++						*(buf++) = *hw_buf;
++						hw_buf += CHAN_RX_FRAMES;
++					}
++					hdev->rx_loc += 4;
++					hdev->rx_frame++;
++					if (hdev->rx_loc >= hdev->rx_buffer_size) {
++						hdev->rx_loc = 0;
++						buf = (u8 *)hdev->rx_buf;
++					}
++				}
++			}
++
++			if (hdev->rx_frame >= hdev->rx_period_size && test_bit(1 << channel, &port->chan_rx_bitmap))
++			{
++				hdev->rx_frame %= hdev->rx_period_size;
++				if (hdev->rx_callback)
++					hdev->rx_callback(hdev->rx_data);
++				more_work = 1;
++			}
++		}
++#if 0
++		if (more_work)
++		{
++			tasklet_hi_schedule(&port->task);
++			return;
++		}
++#endif
++	}
++
++	qmgr_enable_irq(queue_ids[port->id].chan);
++
++	return;
++
++}
++
++struct hss_device *hss_chan_create(struct port *port, unsigned int channel)
++{
++	struct hss_device *chan_dev;
++	unsigned long flags;
++
++	chan_dev = kzalloc(sizeof(struct hss_device), GFP_KERNEL);
++
++	spin_lock_irqsave(&npe_lock, flags);
++
++	chan_dev->id = channel;
++	chan_dev->port = port;
++
++	port->channels[channel] = channel;
++
++	port->chan_devices[channel] = chan_dev;
++
++	spin_unlock_irqrestore(&npe_lock, flags);
++
++	return chan_dev;
++}
++
++/*****************************************************************************
++ * initialization
++ ****************************************************************************/
++
++static struct platform_device gw_avila_hss_device_0 = {
++  .name     = "ixp4xx_hss",
++  .id       = 0,
++};
++
++static struct platform_device gw_avila_hss_device_1 = {
++  .name     = "ixp4xx_hss",
++  .id       = 1,
++};
++
++static struct platform_device *gw_avila_hss_port_0;
++static struct platform_device *gw_avila_hss_port_1;
++static u64 hss_dmamask = 0xFFFFFFFF;
++
++struct hss_device *hss_init(int id, int channel)
++{
++	struct port *port = hss_port[id];
++	struct hss_device *hdev;
++	int ret;
++
++	if (!lock_init)
++	{
++		spin_lock_init(&npe_lock);
++		lock_init = 1;
++		npe = npe_request(0);
++	}
++
++	if (!port->init) {
++		if (id == 0) {
++			gw_avila_hss_port_0 = platform_device_alloc("hss-port", 0);
++
++			platform_set_drvdata(gw_avila_hss_port_0, &gw_avila_hss_device_0);
++			port->dev = &gw_avila_hss_port_0->dev;
++
++			if (!port->dev->dma_mask)
++		    port->dev->dma_mask = &hss_dmamask;
++		  if (!port->dev->coherent_dma_mask)
++	    	port->dev->coherent_dma_mask = 0xFFFFFFFF;
++
++			ret = platform_device_add(gw_avila_hss_port_0);
++
++		  if (ret)
++	  	  platform_device_put(gw_avila_hss_port_0);
++
++			tasklet_init(&port->task, hss_chan_read, (unsigned long) port);
++		}
++		else
++		{
++			gw_avila_hss_port_1 = platform_device_alloc("hss-port", 1);
++
++			platform_set_drvdata(gw_avila_hss_port_1, &gw_avila_hss_device_1);
++			port->dev = &gw_avila_hss_port_1->dev;
++
++			if (!port->dev->dma_mask)
++		    port->dev->dma_mask = &hss_dmamask;
++		  if (!port->dev->coherent_dma_mask)
++	    	port->dev->coherent_dma_mask = 0xFFFFFFFF;
++
++			ret = platform_device_add(gw_avila_hss_port_1);
++
++		  if (ret)
++	  	  platform_device_put(gw_avila_hss_port_1);
++
++			tasklet_init(&port->task, hss_chan_read, (unsigned long) port);
++		}
++
++		port->init = 1;
++		port->id = id;
++		port->clock_type = CLOCK_EXT;
++		port->clock_rate = 8192000;
++		port->frame_size = 256; /* E1 */
++		port->mode = MODE_RAW;
++		port->next_rx_frame = 0;
++		memset(port->channels, CHANNEL_UNUSED, sizeof(port->channels));
++	}
++
++	hdev = hss_chan_create(port, channel);
++
++	return hdev;
++}
++EXPORT_SYMBOL(hss_init);
++
++int hss_set_tx_callback(struct hss_device *hdev, void (*tx_callback)(void *), void *tx_data)
++{
++  BUG_ON(tx_callback == NULL);
++  hdev->tx_callback = tx_callback;
++  hdev->tx_data = tx_data;
++
++  return 0;
++}
++EXPORT_SYMBOL(hss_set_tx_callback);
++
++int hss_set_rx_callback(struct hss_device *hdev, void (*rx_callback)(void *), void *rx_data)
++{
++  BUG_ON(rx_callback == NULL);
++  hdev->rx_callback = rx_callback;
++  hdev->rx_data = rx_data;
++
++  return 0;
++}
++EXPORT_SYMBOL(hss_set_rx_callback);
++
++int hss_config_rx_dma(struct hss_device *hdev, void *buf, size_t buffer_size, size_t period_size)
++{
++	/*
++	 * Period Size and Buffer Size are in Frames which are u32
++	 * We convert the u32 *buf to u8 in order to make channel reads
++	 * and rx_loc easier
++	 */
++
++	hdev->rx_buf = (u8 *)buf;
++	hdev->rx_buffer_size = buffer_size << 2;
++	hdev->rx_period_size = period_size;
++
++	return 0;
++}
++EXPORT_SYMBOL(hss_config_rx_dma);
++
++int hss_config_tx_dma(struct hss_device *hdev, void *buf, size_t buffer_size, size_t period_size)
++{
++	/*
++	 * Period Size and Buffer Size are in Frames which are u32
++	 * We convert the u32 *buf to u8 in order to make channel reads
++	 * and rx_loc easier
++	 */
++
++	hdev->tx_buf = (u8 *)buf;
++	hdev->tx_buffer_size = buffer_size << 2;
++	hdev->tx_period_size = period_size;
++
++	return 0;
++}
++EXPORT_SYMBOL(hss_config_tx_dma);
++
++unsigned long hss_curr_offset_rx(struct hss_device *hdev)
++{
++	return hdev->rx_loc >> 2;
++}
++EXPORT_SYMBOL(hss_curr_offset_rx);
++
++unsigned long hss_curr_offset_tx(struct hss_device *hdev)
++{
++	return hdev->tx_loc >> 2;
++}
++EXPORT_SYMBOL(hss_curr_offset_tx);
++
++MODULE_AUTHOR("Chris Lang");
++MODULE_DESCRIPTION("Intel IXP4xx HSS Audio driver");
++MODULE_LICENSE("GPL v2");
+--- /dev/null
++++ b/sound/soc/gw-avila/ixp4xx_hss.h
+@@ -0,0 +1,401 @@
++/*
++ *
++ *
++ * Copyright (C) 2009 Gateworks Corporation
++ *
++ * This program is free software; you can redistribute it and/or modify it
++ * under the terms of version 2 of the GNU General Public License
++ * as published by the Free Software Foundation.
++ */
++
++#include <linux/types.h>
++#include <linux/bitops.h>
++#include <linux/dma-mapping.h>
++#include <linux/dmapool.h>
++#include <linux/fs.h>
++#include <linux/io.h>
++#include <linux/kernel.h>
++#include <linux/platform_device.h>
++#include <linux/poll.h>
++#include <mach/npe.h>
++#include <mach/qmgr.h>
++#include <linux/interrupt.h>
++
++//#include <linux/hdlc.h> XXX We aren't HDLC
++
++#define DEBUG_QUEUES		0
++#define DEBUG_DESC		0
++#define DEBUG_RX		0
++#define DEBUG_TX		0
++#define DEBUG_PKT_BYTES		0
++#define DEBUG_CLOSE		0
++#define DEBUG_FRAMER		0
++
++#define DRV_NAME		"ixp4xx_hss"
++
++#define PKT_EXTRA_FLAGS		0 /* orig 1 */
++#define TX_FRAME_SYNC_OFFSET	0 /* channelized */
++#define PKT_NUM_PIPES		1 /* 1, 2 or 4 */
++#define PKT_PIPE_FIFO_SIZEW	4 /* total 4 dwords per HSS */
++
++#define RX_DESCS		512 /* also length of all RX queues */
++#define TX_DESCS		512 /* also length of all TX queues */
++
++//#define POOL_ALLOC_SIZE		(sizeof(struct desc) * (RX_DESCS + TX_DESCS))
++#define RX_SIZE			(HDLC_MAX_MRU + 4) /* NPE needs more space */
++#define MAX_CLOSE_WAIT		1000 /* microseconds */
++#define HSS_COUNT		2
++#define MIN_FRAME_SIZE		16   /* bits */
++#define MAX_FRAME_SIZE		257  /* 256 bits + framing bit */
++#define MAX_CHANNELS		(MAX_FRAME_SIZE / 8)
++#define MAX_CHAN_DEVICES	32
++#define CHANNEL_HDLC		0xFE
++#define CHANNEL_UNUSED		0xFF
++
++#define NAPI_WEIGHT		16
++#define CHAN_RX_TRIGGER		16 /* 8 RX frames = 1 ms @ E1 */
++#define CHAN_RX_FRAMES		128
++#define CHAN_RX_TRUNKS		1
++#define MAX_CHAN_RX_BAD_SYNC	(CHAN_RX_TRIGGER / 2 /* pairs */ - 3)
++
++#define CHAN_TX_LIST_FRAMES	CHAN_RX_TRIGGER /* bytes/channel per list, 16 - 48 */
++#define CHAN_TX_LISTS		8
++#define CHAN_TX_TRUNKS CHAN_RX_TRUNKS
++#define CHAN_TX_FRAMES		(CHAN_TX_LIST_FRAMES * CHAN_TX_LISTS)
++
++#define CHAN_QUEUE_LEN		32 /* minimum possible */
++
++#define chan_rx_buf_len(port)	(port->frame_size / 8 * CHAN_RX_FRAMES * CHAN_RX_TRUNKS)
++#define chan_tx_buf_len(port) (port->frame_size / 8 * CHAN_TX_FRAMES * CHAN_TX_TRUNKS)
++
++/* Queue IDs */
++#define HSS0_CHL_RXTRIG_QUEUE	12	/* orig size = 32 dwords */
++#define HSS0_PKT_RX_QUEUE	13	/* orig size = 32 dwords */
++#define HSS0_PKT_TX0_QUEUE	14	/* orig size = 16 dwords */
++#define HSS0_PKT_TX1_QUEUE	15
++#define HSS0_PKT_TX2_QUEUE	16
++#define HSS0_PKT_TX3_QUEUE	17
++#define HSS0_PKT_RXFREE0_QUEUE	18	/* orig size = 16 dwords */
++#define HSS0_PKT_RXFREE1_QUEUE	19
++#define HSS0_PKT_RXFREE2_QUEUE	20
++#define HSS0_PKT_RXFREE3_QUEUE	21
++#define HSS0_PKT_TXDONE_QUEUE	22	/* orig size = 64 dwords */
++
++#define HSS1_CHL_RXTRIG_QUEUE	10
++#define HSS1_PKT_RX_QUEUE	0
++#define HSS1_PKT_TX0_QUEUE	5
++#define HSS1_PKT_TX1_QUEUE	6
++#define HSS1_PKT_TX2_QUEUE	7
++#define HSS1_PKT_TX3_QUEUE	8
++#define HSS1_PKT_RXFREE0_QUEUE	1
++#define HSS1_PKT_RXFREE1_QUEUE	2
++#define HSS1_PKT_RXFREE2_QUEUE	3
++#define HSS1_PKT_RXFREE3_QUEUE	4
++#define HSS1_PKT_TXDONE_QUEUE	9
++
++#define NPE_PKT_MODE_HDLC		0
++#define NPE_PKT_MODE_RAW		1
++#define NPE_PKT_MODE_56KMODE		2
++#define NPE_PKT_MODE_56KENDIAN_MSB	4
++
++/* PKT_PIPE_HDLC_CFG_WRITE flags */
++#define PKT_HDLC_IDLE_ONES		0x1 /* default = flags */
++#define PKT_HDLC_CRC_32			0x2 /* default = CRC-16 */
++#define PKT_HDLC_MSB_ENDIAN		0x4 /* default = LE */
++
++
++/* hss_config, PCRs */
++/* Frame sync sampling, default = active low */
++#define PCR_FRM_SYNC_ACTIVE_HIGH	0x40000000
++#define PCR_FRM_SYNC_FALLINGEDGE	0x80000000
++#define PCR_FRM_SYNC_RISINGEDGE		0xC0000000
++
++/* Frame sync pin: input (default) or output generated off a given clk edge */
++#define PCR_FRM_SYNC_OUTPUT_FALLING	0x20000000
++#define PCR_FRM_SYNC_OUTPUT_RISING	0x30000000
++
++/* Frame and data clock sampling on edge, default = falling */
++#define PCR_FCLK_EDGE_RISING		0x08000000
++#define PCR_DCLK_EDGE_RISING		0x04000000
++
++/* Clock direction, default = input */
++#define PCR_SYNC_CLK_DIR_OUTPUT		0x02000000
++
++/* Generate/Receive frame pulses, default = enabled */
++#define PCR_FRM_PULSE_DISABLED		0x01000000
++
++ /* Data rate is full (default) or half the configured clk speed */
++#define PCR_HALF_CLK_RATE		0x00200000
++
++/* Invert data between NPE and HSS FIFOs? (default = no) */
++#define PCR_DATA_POLARITY_INVERT	0x00100000
++
++/* TX/RX endianness, default = LSB */
++#define PCR_MSB_ENDIAN			0x00080000
++
++/* Normal (default) / open drain mode (TX only) */
++#define PCR_TX_PINS_OPEN_DRAIN		0x00040000
++
++/* No framing bit transmitted and expected on RX? (default = framing bit) */
++#define PCR_SOF_NO_FBIT			0x00020000
++
++/* Drive data pins? */
++#define PCR_TX_DATA_ENABLE		0x00010000
++
++/* Voice 56k type: drive the data pins low (default), high, high Z */
++#define PCR_TX_V56K_HIGH		0x00002000
++#define PCR_TX_V56K_HIGH_IMP		0x00004000
++
++/* Unassigned type: drive the data pins low (default), high, high Z */
++#define PCR_TX_UNASS_HIGH		0x00000800
++#define PCR_TX_UNASS_HIGH_IMP		0x00001000
++
++/* T1 @ 1.544MHz only: Fbit dictated in FIFO (default) or high Z */
++#define PCR_TX_FB_HIGH_IMP		0x00000400
++
++/* 56k data endiannes - which bit unused: high (default) or low */
++#define PCR_TX_56KE_BIT_0_UNUSED	0x00000200
++
++/* 56k data transmission type: 32/8 bit data (default) or 56K data */
++#define PCR_TX_56KS_56K_DATA		0x00000100
++
++/* hss_config, cCR */
++/* Number of packetized clients, default = 1 */
++#define CCR_NPE_HFIFO_2_HDLC		0x04000000
++#define CCR_NPE_HFIFO_3_OR_4HDLC	0x08000000
++
++/* default = no loopback */
++#define CCR_LOOPBACK			0x02000000
++
++/* HSS number, default = 0 (first) */
++#define CCR_SECOND_HSS			0x01000000
++
++
++/* hss_config, clkCR: main:10, num:10, denom:12 */
++#define CLK42X_SPEED_EXP	((0x3FF << 22) | (  2 << 12) |   15) /*65 KHz*/
++
++#define CLK42X_SPEED_512KHZ	((  130 << 22) | (  2 << 12) |   15)
++#define CLK42X_SPEED_1536KHZ	((   43 << 22) | ( 18 << 12) |   47)
++#define CLK42X_SPEED_1544KHZ	((   43 << 22) | ( 33 << 12) |  192)
++#define CLK42X_SPEED_2048KHZ	((   32 << 22) | ( 34 << 12) |   63)
++#define CLK42X_SPEED_4096KHZ	((   16 << 22) | ( 34 << 12) |  127)
++#define CLK42X_SPEED_8192KHZ	((    8 << 22) | ( 34 << 12) |  255)
++
++#define CLK46X_SPEED_512KHZ	((  130 << 22) | ( 24 << 12) |  127)
++#define CLK46X_SPEED_1536KHZ	((   43 << 22) | (152 << 12) |  383)
++#define CLK46X_SPEED_1544KHZ	((   43 << 22) | ( 66 << 12) |  385)
++#define CLK46X_SPEED_2048KHZ	((   32 << 22) | (280 << 12) |  511)
++#define CLK46X_SPEED_4096KHZ	((   16 << 22) | (280 << 12) | 1023)
++#define CLK46X_SPEED_8192KHZ	((    8 << 22) | (280 << 12) | 2047)
++
++
++/* hss_config, LUT entries */
++#define TDMMAP_UNASSIGNED	0
++#define TDMMAP_HDLC		1	/* HDLC - packetized */
++#define TDMMAP_VOICE56K		2	/* Voice56K - 7-bit channelized */
++#define TDMMAP_VOICE64K		3	/* Voice64K - 8-bit channelized */
++
++/* offsets into HSS config */
++#define HSS_CONFIG_TX_PCR	0x00 /* port configuration registers */
++#define HSS_CONFIG_RX_PCR	0x04
++#define HSS_CONFIG_CORE_CR	0x08 /* loopback control, HSS# */
++#define HSS_CONFIG_CLOCK_CR	0x0C /* clock generator control */
++#define HSS_CONFIG_TX_FCR	0x10 /* frame configuration registers */
++#define HSS_CONFIG_RX_FCR	0x14
++#define HSS_CONFIG_TX_LUT	0x18 /* channel look-up tables */
++#define HSS_CONFIG_RX_LUT	0x38
++
++
++/* NPE command codes */
++/* writes the ConfigWord value to the location specified by offset */
++#define PORT_CONFIG_WRITE		0x40
++
++/* triggers the NPE to load the contents of the configuration table */
++#define PORT_CONFIG_LOAD		0x41
++
++/* triggers the NPE to return an HssErrorReadResponse message */
++#define PORT_ERROR_READ			0x42
++
++/* reset NPE internal status and enable the HssChannelized operation */
++#define CHAN_FLOW_ENABLE		0x43
++#define CHAN_FLOW_DISABLE		0x44
++#define CHAN_IDLE_PATTERN_WRITE		0x45
++#define CHAN_NUM_CHANS_WRITE		0x46
++#define CHAN_RX_BUF_ADDR_WRITE		0x47
++#define CHAN_RX_BUF_CFG_WRITE		0x48
++#define CHAN_TX_BLK_CFG_WRITE		0x49
++#define CHAN_TX_BUF_ADDR_WRITE		0x4A
++#define CHAN_TX_BUF_SIZE_WRITE		0x4B
++#define CHAN_TSLOTSWITCH_ENABLE		0x4C
++#define CHAN_TSLOTSWITCH_DISABLE	0x4D
++
++/* downloads the gainWord value for a timeslot switching channel associated
++   with bypassNum */
++#define CHAN_TSLOTSWITCH_GCT_DOWNLOAD	0x4E
++
++/* triggers the NPE to reset internal status and enable the HssPacketized
++   operation for the flow specified by pPipe */
++#define PKT_PIPE_FLOW_ENABLE		0x50
++#define PKT_PIPE_FLOW_DISABLE		0x51
++#define PKT_NUM_PIPES_WRITE		0x52
++#define PKT_PIPE_FIFO_SIZEW_WRITE	0x53
++#define PKT_PIPE_HDLC_CFG_WRITE		0x54
++#define PKT_PIPE_IDLE_PATTERN_WRITE	0x55
++#define PKT_PIPE_RX_SIZE_WRITE		0x56
++#define PKT_PIPE_MODE_WRITE		0x57
++
++/* HDLC packet status values - desc->status */
++#define ERR_SHUTDOWN		1 /* stop or shutdown occurrance */
++#define ERR_HDLC_ALIGN		2 /* HDLC alignment error */
++#define ERR_HDLC_FCS		3 /* HDLC Frame Check Sum error */
++#define ERR_RXFREE_Q_EMPTY	4 /* RX-free queue became empty while receiving
++				     this packet (if buf_len < pkt_len) */
++#define ERR_HDLC_TOO_LONG	5 /* HDLC frame size too long */
++#define ERR_HDLC_ABORT		6 /* abort sequence received */
++#define ERR_DISCONNECTING	7 /* disconnect is in progress */
++
++#define CLOCK_EXT 0
++#define CLOCK_INT 1
++
++enum mode {MODE_HDLC = 0, MODE_RAW, MODE_G704};
++enum rx_tx_bit {
++	TX_BIT = 0,
++	RX_BIT = 1
++};
++enum chan_bit {
++	CHAN_0 = (1 << 0),
++	CHAN_1 = (1 << 1),
++	CHAN_2 = (1 << 2),
++	CHAN_3 = (1 << 3),
++	CHAN_4 = (1 << 4),
++	CHAN_5 = (1 << 5),
++	CHAN_6 = (1 << 6),
++	CHAN_7 = (1 << 7),
++	CHAN_8 = (1 << 8),
++	CHAN_9 = (1 << 9),
++	CHAN_10 = (1 << 10),
++	CHAN_11 = (1 << 11),
++	CHAN_12 = (1 << 12),
++	CHAN_13 = (1 << 13),
++	CHAN_14 = (1 << 14),
++	CHAN_15 = (1 << 15)
++};
++
++enum alignment { NOT_ALIGNED = 0, EVEN_FIRST, ODD_FIRST };
++
++#ifdef __ARMEB__
++typedef struct sk_buff buffer_t;
++#define free_buffer dev_kfree_skb
++#define free_buffer_irq dev_kfree_skb_irq
++#else
++typedef void buffer_t;
++#define free_buffer kfree
++#define free_buffer_irq kfree
++#endif
++
++struct hss_device {
++	struct port *port;
++	unsigned int open_count, excl_open;
++	unsigned long tx_loc, rx_loc; /* bytes */
++	unsigned long tx_frame, rx_frame; /* Frames */
++	u8 id, chan_count;
++	u8 log_channels[MAX_CHANNELS];
++
++  u8 *rx_buf;
++  u8 *tx_buf;
++
++	size_t rx_buffer_size;
++	size_t rx_period_size;
++	size_t tx_buffer_size;
++	size_t tx_period_size;
++
++  void (*rx_callback)(void *data);
++  void *rx_data;
++  void (*tx_callback)(void *data);
++  void *tx_data;
++  void *private_data;
++};
++
++extern struct hss_device *hss_handle[32];
++extern struct port *hss_port[2];
++
++struct port {
++	unsigned char init;
++
++	struct device *dev;
++
++	struct tasklet_struct task;
++	unsigned int id;
++	unsigned long chan_rx_bitmap;
++	unsigned long chan_tx_bitmap;
++	unsigned char chan_open;
++
++	/* the following fields must be protected by npe_lock */
++	enum mode mode;
++	unsigned int clock_type, clock_rate, loopback;
++	unsigned int frame_size, frame_sync_offset;
++	unsigned int next_rx_frame;
++
++	struct hss_device *chan_devices[MAX_CHAN_DEVICES];
++	u32 chan_tx_buf_phys, chan_rx_buf_phys;
++	u32	chan_tx_pointers_phys;
++	u32 *chan_tx_pointers;
++	u8 *chan_rx_buf;
++	u8 *chan_tx_buf;
++	u8 *tx_lists[CHAN_TX_LISTS][8];
++	u8 *rx_frames[8][CHAN_TX_LISTS];
++	unsigned int chan_open_count, hdlc_open;
++	unsigned int chan_started, initialized, just_set_offset;
++	unsigned int chan_last_rx, chan_last_tx;
++
++	/* assigned channels, may be invalid with given frame length or mode */
++	u8 channels[MAX_CHANNELS];
++	int msg_count;
++};
++
++/* NPE message structure */
++struct msg {
++#ifdef __ARMEB__
++	u8 cmd, unused, hss_port, index;
++	union {
++		struct { u8 data8a, data8b, data8c, data8d; };
++		struct { u16 data16a, data16b; };
++		struct { u32 data32; };
++	};
++#else
++	u8 index, hss_port, unused, cmd;
++	union {
++		struct { u8 data8d, data8c, data8b, data8a; };
++		struct { u16 data16b, data16a; };
++		struct { u32 data32; };
++	};
++#endif
++};
++
++#define rx_desc_phys(port, n)	((port)->desc_tab_phys +		\
++				 (n) * sizeof(struct desc))
++#define rx_desc_ptr(port, n)	(&(port)->desc_tab[n])
++
++#define tx_desc_phys(port, n)	((port)->desc_tab_phys +		\
++				 ((n) + RX_DESCS) * sizeof(struct desc))
++#define tx_desc_ptr(port, n)	(&(port)->desc_tab[(n) + RX_DESCS])
++
++int hss_prepare_chan(struct port *port);
++void hss_chan_stop(struct port *port);
++
++struct hss_device *hss_init(int id, int channel);
++int hss_chan_open(struct hss_device *hdev);
++int hss_chan_close(struct hss_device *hdev);
++
++int hss_set_tx_callback(struct hss_device *hdev, void (*tx_callback)(void *), void *tx_data);
++int hss_set_rx_callback(struct hss_device *hdev, void (*rx_callback)(void *), void *rx_data);
++int hss_tx_start(struct hss_device *hdev);
++int hss_tx_stop(struct hss_device *hdev);
++int hss_rx_start(struct hss_device *hdev);
++int hss_rx_stop(struct hss_device *hdev);
++
++int hss_config_rx_dma(struct hss_device *hdev, void *buf, size_t buffer_size, size_t period_size);
++int hss_config_tx_dma(struct hss_device *hdev, void *buf, size_t buffer_size, size_t period_size);
++unsigned long hss_curr_offset_rx(struct hss_device *hdev);
++unsigned long hss_curr_offset_tx(struct hss_device *hdev);
++
+--- a/arch/arm/mach-ixp4xx/avila-setup.c
++++ b/arch/arm/mach-ixp4xx/avila-setup.c
+@@ -333,6 +333,54 @@ static struct platform_device avila_gpio
+ 	.id     = -1,
+ };
+ 
++/*
++ * Audio Devices
++ */
++
++static struct platform_device avila_hss_device[] = {
++	{
++		.name = "gw_avila_hss",
++		.id = 0,
++	},{
++		.name = "gw_avila_hss",
++		.id = 1,
++	},{
++		.name = "gw_avila_hss",
++		.id = 2,
++	},{
++		.name = "gw_avila_hss",
++		.id = 3,
++	},
++};
++
++static struct platform_device avila_pcm_device[] = {
++	{
++		.name = "gw_avila-audio",
++		.id = 0,
++	},{
++		.name = "gw_avila-audio",
++		.id = 1,
++	},{
++		.name = "gw_avila-audio",
++		.id = 2,
++	},{
++		.name = "gw_avila-audio",
++		.id = 3,
++	}
++};
++
++static void setup_audio_devices(void) {
++	platform_device_register(&avila_hss_device[0]);
++	platform_device_register(&avila_hss_device[1]);
++	platform_device_register(&avila_hss_device[2]);
++	platform_device_register(&avila_hss_device[3]);
++
++	platform_device_register(&avila_pcm_device[0]);
++	platform_device_register(&avila_pcm_device[1]);
++	platform_device_register(&avila_pcm_device[2]);
++	platform_device_register(&avila_pcm_device[3]);
++}
++
+ static void __init avila_gw23xx_setup(void)
+ {
+ 	platform_device_register(&avila_npeb_device);
+@@ -508,6 +556,8 @@ static void __init avila_gw2365_setup(vo
+ 	avila_gpio_leds[0].gpio = 109;
+ 	avila_gpio_leds_data.num_leds = 5;
+ 	platform_device_register(&avila_gpio_leds_device);
++
++	setup_audio_devices();
+ }
+ 
+ static void __init avila_gw2369_setup(void)
+@@ -517,6 +567,8 @@ static void __init avila_gw2369_setup(vo
+ 
+ 	avila_npec_data.phy = 2;
+ 	platform_device_register(&avila_npec_device);
++
++	setup_audio_devices();
+ }
+ 
+ static void __init avila_gw2370_setup(void)
+@@ -654,6 +706,18 @@ static struct i2c_board_info __initdata
+ 		I2C_BOARD_INFO("24c08", 0x51),
+ 		.platform_data	= &avila_eeprom_info
+ 	},
++	{
++		I2C_BOARD_INFO("tlv320aic33", 0x1b),
++	},
++	{
++		I2C_BOARD_INFO("tlv320aic33", 0x1a),
++	},
++	{
++		I2C_BOARD_INFO("tlv320aic33", 0x19),
++	},
++	{
++		I2C_BOARD_INFO("tlv320aic33", 0x18),
++	},
+ };
+ 
+ static void __init avila_init(void)
+--- a/sound/soc/codecs/tlv320aic3x.c
++++ b/sound/soc/codecs/tlv320aic3x.c
+@@ -985,6 +985,22 @@ static int aic3x_set_dai_sysclk(struct s
+ 	return 0;
+ }
+ 
++static int aic3x_set_tdm_slot(struct snd_soc_dai *codec_dai,
++	unsigned int tx_mask, unsigned int rx_mask,
++	int slots, int width)
++{
++	struct snd_soc_codec *codec = codec_dai->codec;
++	u8 iface_creg;
++
++	iface_creg = snd_soc_read(codec, AIC3X_ASD_INTF_CTRLC);
++
++	iface_creg = slots * width;
++
++	snd_soc_write(codec, AIC3X_ASD_INTF_CTRLC, iface_creg);
++
++	return 0;
++}
++
+ static int aic3x_set_dai_fmt(struct snd_soc_dai *codec_dai,
+ 			     unsigned int fmt)
+ {
+@@ -996,6 +1012,9 @@ static int aic3x_set_dai_fmt(struct snd_
+ 	iface_areg = snd_soc_read(codec, AIC3X_ASD_INTF_CTRLA) & 0x3f;
+ 	iface_breg = snd_soc_read(codec, AIC3X_ASD_INTF_CTRLB) & 0x3f;
+ 
++	iface_areg |= 0x30;
++	iface_breg |= 0x8;
++
+ 	/* set master/slave audio interface */
+ 	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+ 	case SND_SOC_DAIFMT_CBM_CFM:
+@@ -1227,6 +1246,7 @@ static struct snd_soc_dai_ops aic3x_dai_
+ 	.digital_mute	= aic3x_mute,
+ 	.set_sysclk	= aic3x_set_dai_sysclk,
+ 	.set_fmt	= aic3x_set_dai_fmt,
++	.set_tdm_slot	= aic3x_set_tdm_slot,
+ };
+ 
+ static struct snd_soc_dai_driver aic3x_dai = {
Index: trunk/target/linux/ixp4xx/patches-2.6.38/301-avila_led.patch
===================================================================
--- trunk/target/linux/ixp4xx/patches-2.6.38/301-avila_led.patch	(revision 27590)
+++ trunk/target/linux/ixp4xx/patches-2.6.38/301-avila_led.patch	(working copy)
@@ -129,11 +129,12 @@
  }
  
  static void __init avila_gw2355_setup(void)
-@@ -222,11 +301,29 @@ static void __init avila_gw2355_setup(vo
+@@ -222,11 +301,30 @@ static void __init avila_gw2355_setup(vo
  
  	avila_npec_data.phy = 16;
  	platform_device_register(&avila_npec_device);
 +
++	avila_gpio_leds[0].gpio = AVILA_GW23X7_LED_USER_GPIO;
 +	platform_device_register(&avila_gpio_leds_device);
 +
 +	*IXP4XX_EXP_CS4 |= 0xbfff3c03;
Index: trunk/target/linux/ixp4xx/patches-2.6.38/302-avila_gpio_device.patch
===================================================================
--- trunk/target/linux/ixp4xx/patches-2.6.38/302-avila_gpio_device.patch	(revision 27590)
+++ trunk/target/linux/ixp4xx/patches-2.6.38/302-avila_gpio_device.patch	(working copy)
@@ -14,3 +14,28 @@
  struct avila_board_info {
  	unsigned char	*model;
  	void		(*setup)(void);
+@@ -243,6 +250,11 @@ static struct platform_device *avila_dev
+ 	&avila_uart
+ };
+ 
++static struct platform_device avila_gpio_dev = {
++	.name     = "GPIODEV",
++	.id     = -1,
++};
++
+ static void __init avila_gw23xx_setup(void)
+ {
+ 	platform_device_register(&avila_npeb_device);
+@@ -435,8 +447,10 @@ static void __init avila_init(void)
+ 
+ 	platform_device_register(&avila_pata);
+ 
+-		i2c_register_board_info(0, avila_i2c_board_info,
+-				ARRAY_SIZE(avila_i2c_board_info));
++	i2c_register_board_info(0, avila_i2c_board_info,
++			ARRAY_SIZE(avila_i2c_board_info));
++
++	platform_device_register(&avila_gpio_dev);
+ }
+ 
+ static int __init avila_model_setup(void)
Index: trunk/target/linux/ixp4xx/patches-2.6.38/501-cambria-e1000-irq.patch
===================================================================
--- trunk/target/linux/ixp4xx/patches-2.6.38/501-cambria-e1000-irq.patch	(revision 0)
+++ trunk/target/linux/ixp4xx/patches-2.6.38/501-cambria-e1000-irq.patch	(working copy)
@@ -0,0 +1,14 @@
+--- a/arch/arm/mach-ixp4xx/cambria-pci.c
++++ b/arch/arm/mach-ixp4xx/cambria-pci.c
+@@ -52,6 +52,11 @@ static int __init cambria_map_irq(struct
+ 		return IRQ_IXP4XX_GPIO9;
+ 	else if (slot == 4)
+ 		return IRQ_IXP4XX_GPIO8;
++  else if (slot == 6)
++    return IRQ_IXP4XX_GPIO10;
++  else if (slot == 15)
++    return IRQ_IXP4XX_GPIO8;
++
+ 	else return -1;
+ }
+ 
Index: trunk/target/linux/ixp4xx/patches-2.6.38/502-gw2365-eth.patch
===================================================================
--- trunk/target/linux/ixp4xx/patches-2.6.38/502-gw2365-eth.patch	(revision 0)
+++ trunk/target/linux/ixp4xx/patches-2.6.38/502-gw2365-eth.patch	(working copy)
@@ -0,0 +1,30 @@
+--- a/arch/arm/mach-ixp4xx/avila-setup.c
++++ b/arch/arm/mach-ixp4xx/avila-setup.c
+@@ -339,6 +339,17 @@ static void __init avila_gw2357_setup(vo
+ 	platform_device_register(&avila_latch_leds_device);
+ }
+ 
++static void __init avila_gw2365_setup(void)
++{
++	avila_npeb_data.phy = 1;
++	platform_device_register(&avila_npeb_device);
++
++	avila_npec_data.phy = 2;
++	platform_device_register(&avila_npec_device);
++
++	platform_device_register(&avila_gpio_leds_device);
++}
++
+ static struct avila_board_info avila_boards[] __initdata = {
+ 	{
+ 		.model		= "GW2342",
+@@ -361,6 +372,9 @@ static struct avila_board_info avila_boa
+ 	}, {
+ 		.model		= "GW2357",
+ 		.setup		= avila_gw2357_setup,
++	}, {
++		.model		= "GW2365",
++		.setup		= avila_gw2365_setup,
+ 	}
+ };
+ 
Index: trunk/target/linux/ixp4xx/patches-2.6.38/503-gw2365-optional-uart.patch
===================================================================
--- trunk/target/linux/ixp4xx/patches-2.6.38/503-gw2365-optional-uart.patch	(revision 0)
+++ trunk/target/linux/ixp4xx/patches-2.6.38/503-gw2365-optional-uart.patch	(working copy)
@@ -0,0 +1,105 @@
+--- a/arch/arm/mach-ixp4xx/avila-setup.c
++++ b/arch/arm/mach-ixp4xx/avila-setup.c
+@@ -125,6 +125,69 @@ static struct platform_device avila_uart
+ 	.resource		= avila_uart_resources
+ };
+ 
++static struct resource avila_optional_uart_resources[] = {
++  {
++    .start  = 0x54000000,
++    .end  = 0x54000fff,
++    .flags  = IORESOURCE_MEM
++  },
++  {
++    .start  = 0x55000000,
++    .end  = 0x55000fff,
++    .flags  = IORESOURCE_MEM
++  },
++  {
++    .start  = 0x56000000,
++    .end  = 0x56000fff,
++    .flags  = IORESOURCE_MEM
++  },
++  {
++    .start  = 0x57000000,
++    .end  = 0x57000fff,
++    .flags  = IORESOURCE_MEM
++  }
++};
++
++static struct plat_serial8250_port avila_optional_uart_data[] = {
++  {
++    .flags    = UPF_BOOT_AUTOCONF,
++    .iotype   = UPIO_MEM,
++    .regshift = 0,
++    .uartclk  = 18432000,
++    .rw_delay = 2,
++  },
++  {
++    .flags    = UPF_BOOT_AUTOCONF,
++    .iotype   = UPIO_MEM,
++    .regshift = 0,
++    .uartclk  = 18432000,
++    .rw_delay = 2,
++  },
++  {
++    .flags    = UPF_BOOT_AUTOCONF,
++    .iotype   = UPIO_MEM,
++    .regshift = 0,
++    .uartclk  = 18432000,
++    .rw_delay = 2,
++  },
++  {
++    .flags    = UPF_BOOT_AUTOCONF,
++    .iotype   = UPIO_MEM,
++    .regshift = 0,
++    .uartclk  = 18432000,
++    .rw_delay = 2,
++  },
++  { },
++};
++
++static struct platform_device avila_optional_uart = {
++  .name   = "serial8250",
++  .id   = PLAT8250_DEV_PLATFORM1,
++  .dev.platform_data  = avila_optional_uart_data,
++  .num_resources  = 4,
++  .resource = avila_optional_uart_resources,
++};
++
+ static struct resource avila_pata_resources[] = {
+ 	{
+ 		.flags	= IORESOURCE_MEM
+@@ -341,6 +404,32 @@ static void __init avila_gw2357_setup(vo
+ 
+ static void __init avila_gw2365_setup(void)
+ {
++	*IXP4XX_EXP_CS4 = 0xBFFF3C43;
++  set_irq_type(IRQ_IXP4XX_GPIO0, IRQ_TYPE_EDGE_RISING);
++  avila_optional_uart_data[0].mapbase = 0x54000000;
++  avila_optional_uart_data[0].membase = (void __iomem *)ioremap(0x54000000, 0x0fff);
++  avila_optional_uart_data[0].irq   = IRQ_IXP4XX_GPIO0;
++
++  *IXP4XX_EXP_CS5 = 0xBFFF3C43;
++  set_irq_type(IRQ_IXP4XX_GPIO1, IRQ_TYPE_EDGE_RISING);
++  avila_optional_uart_data[1].mapbase = 0x55000000;
++  avila_optional_uart_data[1].membase = (void __iomem *)ioremap(0x55000000, 0x0fff);
++  avila_optional_uart_data[1].irq   = IRQ_IXP4XX_GPIO1;
++
++  *IXP4XX_EXP_CS6 = 0xBFFF3C43;
++  set_irq_type(IRQ_IXP4XX_GPIO2, IRQ_TYPE_EDGE_RISING);
++  avila_optional_uart_data[2].mapbase = 0x56000000;
++  avila_optional_uart_data[2].membase = (void __iomem *)ioremap(0x56000000, 0x0fff);
++  avila_optional_uart_data[2].irq   = IRQ_IXP4XX_GPIO2;
++
++  *IXP4XX_EXP_CS7 = 0xBFFF3C43;
++  set_irq_type(IRQ_IXP4XX_GPIO3, IRQ_TYPE_EDGE_RISING);
++  avila_optional_uart_data[3].mapbase = 0x57000000;
++  avila_optional_uart_data[3].membase = (void __iomem *)ioremap(0x57000000, 0x0fff);
++  avila_optional_uart_data[3].irq   = IRQ_IXP4XX_GPIO3;
++
++	platform_device_register(&avila_optional_uart);
++	
+ 	avila_npeb_data.phy = 1;
+ 	platform_device_register(&avila_npeb_device);
+ 
Index: trunk/target/linux/ixp4xx/patches-2.6.38/504-gw2369_support.patch
===================================================================
--- trunk/target/linux/ixp4xx/patches-2.6.38/504-gw2369_support.patch	(revision 0)
+++ trunk/target/linux/ixp4xx/patches-2.6.38/504-gw2369_support.patch	(working copy)
@@ -0,0 +1,381 @@
+--- a/arch/arm/mach-ixp4xx/avila-setup.c
++++ b/arch/arm/mach-ixp4xx/avila-setup.c
+@@ -23,6 +23,7 @@
+ #include <linux/i2c.h>
+ #include <linux/i2c/at24.h>
+ #include <linux/leds.h>
++#include <linux/i2c/pca953x.h>
+ #include <linux/i2c-gpio.h>
+ #include <asm/types.h>
+ #include <asm/setup.h>
+@@ -32,6 +33,7 @@
+ #include <asm/irq.h>
+ #include <asm/mach/arch.h>
+ #include <asm/mach/flash.h>
++#include <linux/irq.h>
+ 
+ #define AVILA_SDA_PIN	7
+ #define AVILA_SCL_PIN	6
+@@ -126,58 +128,52 @@ static struct platform_device avila_uart
+ };
+ 
+ static struct resource avila_optional_uart_resources[] = {
+-  {
+-    .start  = 0x54000000,
+-    .end  = 0x54000fff,
+-    .flags  = IORESOURCE_MEM
+-  },
+-  {
+-    .start  = 0x55000000,
+-    .end  = 0x55000fff,
+-    .flags  = IORESOURCE_MEM
+-  },
+-  {
+-    .start  = 0x56000000,
+-    .end  = 0x56000fff,
+-    .flags  = IORESOURCE_MEM
+-  },
+-  {
+-    .start  = 0x57000000,
+-    .end  = 0x57000fff,
+-    .flags  = IORESOURCE_MEM
+-  }
++	{
++		.start  = 0x54000000,
++		.end  = 0x54000fff,
++		.flags  = IORESOURCE_MEM
++	},{
++		.start  = 0x55000000,
++		.end  = 0x55000fff,
++		.flags  = IORESOURCE_MEM
++	},{
++		.start  = 0x56000000,
++		.end  = 0x56000fff,
++		.flags  = IORESOURCE_MEM
++	},{
++		.start  = 0x57000000,
++		.end  = 0x57000fff,
++		.flags  = IORESOURCE_MEM
++	}
+ };
+ 
+ static struct plat_serial8250_port avila_optional_uart_data[] = {
+-  {
+-    .flags    = UPF_BOOT_AUTOCONF,
+-    .iotype   = UPIO_MEM,
+-    .regshift = 0,
+-    .uartclk  = 18432000,
+-    .rw_delay = 2,
+-  },
+-  {
+-    .flags    = UPF_BOOT_AUTOCONF,
+-    .iotype   = UPIO_MEM,
+-    .regshift = 0,
+-    .uartclk  = 18432000,
+-    .rw_delay = 2,
+-  },
+-  {
+-    .flags    = UPF_BOOT_AUTOCONF,
+-    .iotype   = UPIO_MEM,
+-    .regshift = 0,
+-    .uartclk  = 18432000,
+-    .rw_delay = 2,
+-  },
+-  {
+-    .flags    = UPF_BOOT_AUTOCONF,
+-    .iotype   = UPIO_MEM,
+-    .regshift = 0,
+-    .uartclk  = 18432000,
+-    .rw_delay = 2,
+-  },
+-  { },
++	{
++		.flags    = UPF_BOOT_AUTOCONF,
++		.iotype   = UPIO_MEM,
++		.regshift = 0,
++		.uartclk  = 18432000,
++		.rw_delay = 2,
++	},{
++		.flags    = UPF_BOOT_AUTOCONF,
++		.iotype   = UPIO_MEM,
++		.regshift = 0,
++		.uartclk  = 18432000,
++		.rw_delay = 2,
++	},{
++		.flags    = UPF_BOOT_AUTOCONF,
++		.iotype   = UPIO_MEM,
++		.regshift = 0,
++		.uartclk  = 18432000,
++		.rw_delay = 2,
++	},{
++		.flags    = UPF_BOOT_AUTOCONF,
++		.iotype   = UPIO_MEM,
++		.regshift = 0,
++		.uartclk  = 18432000,
++		.rw_delay = 2,
++	},
++	{ }
+ };
+ 
+ static struct platform_device avila_optional_uart = {
+@@ -191,11 +187,9 @@ static struct platform_device avila_opti
+ static struct resource avila_pata_resources[] = {
+ 	{
+ 		.flags	= IORESOURCE_MEM
+-	},
+-	{
++	},{
+ 		.flags	= IORESOURCE_MEM,
+-	},
+-	{
++	},{
+ 		.name	= "intrq",
+ 		.start	= IRQ_IXP4XX_GPIO12,
+ 		.end	= IRQ_IXP4XX_GPIO12,
+@@ -246,7 +240,28 @@ static struct gpio_led avila_gpio_leds[]
+ 		.name		= "user",  /* green led */
+ 		.gpio		= AVILA_GW23XX_LED_USER_GPIO,
+ 		.active_low	= 1,
+-	}
++	},
++	{
++		.name		= "radio1",  /* green led */
++		.gpio		= 104,
++		.active_low	= 1,
++	},
++	{
++		.name		= "radio2",  /* green led */
++		.gpio		= 105,
++		.active_low	= 1,
++	},
++	{
++		.name		= "radio3",  /* green led */
++		.gpio		= 106,
++		.active_low	= 1,
++	},
++	{
++		.name		= "radio4",  /* green led */
++		.gpio		= 107,
++		.active_low	= 1,
++	},
++
+ };
+ 
+ static struct gpio_led_platform_data avila_gpio_leds_data = {
+@@ -332,6 +347,17 @@ static void __init avila_gw2342_setup(vo
+ 	platform_device_register(&avila_npec_device);
+ 
+ 	platform_device_register(&avila_gpio_leds_device);
++
++	avila_pata_resources[0].start = IXP4XX_EXP_BUS_BASE(1);
++	avila_pata_resources[0].end = IXP4XX_EXP_BUS_END(1);
++
++	avila_pata_resources[1].start = IXP4XX_EXP_BUS_BASE(2);
++	avila_pata_resources[1].end = IXP4XX_EXP_BUS_END(2);
++
++	avila_pata_data.cs0_cfg = IXP4XX_EXP_CS1;
++	avila_pata_data.cs1_cfg = IXP4XX_EXP_CS2;
++
++	platform_device_register(&avila_pata);
+ }
+ 
+ static void __init avila_gw2345_setup(void)
+@@ -344,6 +370,17 @@ static void __init avila_gw2345_setup(vo
+ 	platform_device_register(&avila_npec_device);
+ 
+ 	platform_device_register(&avila_gpio_leds_device);
++
++	avila_pata_resources[0].start = IXP4XX_EXP_BUS_BASE(1);
++	avila_pata_resources[0].end = IXP4XX_EXP_BUS_END(1);
++
++	avila_pata_resources[1].start = IXP4XX_EXP_BUS_BASE(2);
++	avila_pata_resources[1].end = IXP4XX_EXP_BUS_END(2);
++
++	avila_pata_data.cs0_cfg = IXP4XX_EXP_CS1;
++	avila_pata_data.cs1_cfg = IXP4XX_EXP_CS2;
++
++	platform_device_register(&avila_pata);
+ }
+ 
+ static void __init avila_gw2347_setup(void)
+@@ -360,6 +397,17 @@ static void __init avila_gw2348_setup(vo
+ 	platform_device_register(&avila_npec_device);
+ 
+ 	platform_device_register(&avila_gpio_leds_device);
++
++	avila_pata_resources[0].start = IXP4XX_EXP_BUS_BASE(1);
++	avila_pata_resources[0].end = IXP4XX_EXP_BUS_END(1);
++
++	avila_pata_resources[1].start = IXP4XX_EXP_BUS_BASE(2);
++	avila_pata_resources[1].end = IXP4XX_EXP_BUS_END(2);
++
++	avila_pata_data.cs0_cfg = IXP4XX_EXP_CS1;
++	avila_pata_data.cs1_cfg = IXP4XX_EXP_CS2;
++
++	platform_device_register(&avila_pata);
+ }
+ 
+ static void __init avila_gw2353_setup(void)
+@@ -389,6 +437,17 @@ static void __init avila_gw2355_setup(vo
+ 	avila_latch_leds_data.num_leds = 5;
+ 	avila_latch_leds_data.mem = 0x54000000;
+ 	platform_device_register(&avila_latch_leds_device);
++
++	avila_pata_resources[0].start = IXP4XX_EXP_BUS_BASE(1);
++	avila_pata_resources[0].end = IXP4XX_EXP_BUS_END(1);
++
++	avila_pata_resources[1].start = IXP4XX_EXP_BUS_BASE(2);
++	avila_pata_resources[1].end = IXP4XX_EXP_BUS_END(2);
++
++	avila_pata_data.cs0_cfg = IXP4XX_EXP_CS1;
++	avila_pata_data.cs1_cfg = IXP4XX_EXP_CS2;
++
++	platform_device_register(&avila_pata);
+ }
+ 
+ static void __init avila_gw2357_setup(void)
+@@ -405,40 +464,62 @@ static void __init avila_gw2357_setup(vo
+ static void __init avila_gw2365_setup(void)
+ {
+ 	*IXP4XX_EXP_CS4 = 0xBFFF3C43;
+-  set_irq_type(IRQ_IXP4XX_GPIO0, IRQ_TYPE_EDGE_RISING);
+-  avila_optional_uart_data[0].mapbase = 0x54000000;
+-  avila_optional_uart_data[0].membase = (void __iomem *)ioremap(0x54000000, 0x0fff);
+-  avila_optional_uart_data[0].irq   = IRQ_IXP4XX_GPIO0;
+-
+-  *IXP4XX_EXP_CS5 = 0xBFFF3C43;
+-  set_irq_type(IRQ_IXP4XX_GPIO1, IRQ_TYPE_EDGE_RISING);
+-  avila_optional_uart_data[1].mapbase = 0x55000000;
+-  avila_optional_uart_data[1].membase = (void __iomem *)ioremap(0x55000000, 0x0fff);
+-  avila_optional_uart_data[1].irq   = IRQ_IXP4XX_GPIO1;
+-
+-  *IXP4XX_EXP_CS6 = 0xBFFF3C43;
+-  set_irq_type(IRQ_IXP4XX_GPIO2, IRQ_TYPE_EDGE_RISING);
+-  avila_optional_uart_data[2].mapbase = 0x56000000;
+-  avila_optional_uart_data[2].membase = (void __iomem *)ioremap(0x56000000, 0x0fff);
+-  avila_optional_uart_data[2].irq   = IRQ_IXP4XX_GPIO2;
+-
+-  *IXP4XX_EXP_CS7 = 0xBFFF3C43;
+-  set_irq_type(IRQ_IXP4XX_GPIO3, IRQ_TYPE_EDGE_RISING);
+-  avila_optional_uart_data[3].mapbase = 0x57000000;
+-  avila_optional_uart_data[3].membase = (void __iomem *)ioremap(0x57000000, 0x0fff);
+-  avila_optional_uart_data[3].irq   = IRQ_IXP4XX_GPIO3;
++	set_irq_type(IRQ_IXP4XX_GPIO0, IRQ_TYPE_EDGE_RISING);
++	avila_optional_uart_data[0].mapbase = 0x54000000;
++	avila_optional_uart_data[0].membase = (void __iomem *)ioremap(0x54000000, 0x0fff);
++	avila_optional_uart_data[0].irq   = IRQ_IXP4XX_GPIO0;
++
++	*IXP4XX_EXP_CS5 = 0xBFFF3C43;
++	set_irq_type(IRQ_IXP4XX_GPIO1, IRQ_TYPE_EDGE_RISING);
++	avila_optional_uart_data[1].mapbase = 0x55000000;
++	avila_optional_uart_data[1].membase = (void __iomem *)ioremap(0x55000000, 0x0fff);
++	avila_optional_uart_data[1].irq   = IRQ_IXP4XX_GPIO1;
++
++	*IXP4XX_EXP_CS6 = 0xBFFF3C43;
++	set_irq_type(IRQ_IXP4XX_GPIO2, IRQ_TYPE_EDGE_RISING);
++	avila_optional_uart_data[2].mapbase = 0x56000000;
++	avila_optional_uart_data[2].membase = (void __iomem *)ioremap(0x56000000, 0x0fff);
++	avila_optional_uart_data[2].irq   = IRQ_IXP4XX_GPIO2;
++
++	*IXP4XX_EXP_CS7 = 0xBFFF3C43;
++	set_irq_type(IRQ_IXP4XX_GPIO3, IRQ_TYPE_EDGE_RISING);
++	avila_optional_uart_data[3].mapbase = 0x57000000;
++	avila_optional_uart_data[3].membase = (void __iomem *)ioremap(0x57000000, 0x0fff);
++	avila_optional_uart_data[3].irq   = IRQ_IXP4XX_GPIO3;
+ 
+ 	platform_device_register(&avila_optional_uart);
+-	
++
+ 	avila_npeb_data.phy = 1;
+ 	platform_device_register(&avila_npeb_device);
+ 
+ 	avila_npec_data.phy = 2;
+ 	platform_device_register(&avila_npec_device);
+ 
++	avila_pata_resources[0].start = IXP4XX_EXP_BUS_BASE(1);
++	avila_pata_resources[0].end = IXP4XX_EXP_BUS_END(1);
++
++	avila_pata_resources[1].start = IXP4XX_EXP_BUS_BASE(2);
++	avila_pata_resources[1].end = IXP4XX_EXP_BUS_END(2);
++
++	avila_pata_data.cs0_cfg = IXP4XX_EXP_CS1;
++	avila_pata_data.cs1_cfg = IXP4XX_EXP_CS2;
++
++	platform_device_register(&avila_pata);
++
++	avila_gpio_leds[0].gpio = 109;
++	avila_gpio_leds_data.num_leds = 5;
+ 	platform_device_register(&avila_gpio_leds_device);
+ }
+ 
++static void __init avila_gw2369_setup(void)
++{
++	avila_npeb_data.phy = 1;
++	platform_device_register(&avila_npeb_device);
++
++	avila_npec_data.phy = 2;
++	platform_device_register(&avila_npec_device);
++}
++
+ static struct avila_board_info avila_boards[] __initdata = {
+ 	{
+ 		.model		= "GW2342",
+@@ -464,6 +545,9 @@ static struct avila_board_info avila_boa
+ 	}, {
+ 		.model		= "GW2365",
+ 		.setup		= avila_gw2365_setup,
++	}, {
++		.model		= "GW2369",
++		.setup		= avila_gw2369_setup,
+ 	}
+ };
+ 
+@@ -512,11 +596,22 @@ static struct at24_platform_data avila_e
+ 	.setup		= at24_setup,
+ };
+ 
++static struct pca953x_platform_data avila_pca_data = {
++	.gpio_base  = 100,
++};
++
+ static struct i2c_board_info __initdata avila_i2c_board_info[] = {
+ 	{
+ 		I2C_BOARD_INFO("ds1672", 0x68),
+ 	},
+ 	{
++		I2C_BOARD_INFO("gsp", 0x29),
++	},
++	{
++		I2C_BOARD_INFO("pca9555", 0x23),
++		.platform_data = &avila_pca_data,
++	},
++	{
+ 		I2C_BOARD_INFO("ad7418", 0x28),
+ 	},
+ 	{
+@@ -539,17 +634,6 @@ static void __init avila_init(void)
+ 
+ 	platform_add_devices(avila_devices, ARRAY_SIZE(avila_devices));
+ 
+-	avila_pata_resources[0].start = IXP4XX_EXP_BUS_BASE(1);
+-	avila_pata_resources[0].end = IXP4XX_EXP_BUS_END(1);
+-
+-	avila_pata_resources[1].start = IXP4XX_EXP_BUS_BASE(2);
+-	avila_pata_resources[1].end = IXP4XX_EXP_BUS_END(2);
+-
+-	avila_pata_data.cs0_cfg = IXP4XX_EXP_CS1;
+-	avila_pata_data.cs1_cfg = IXP4XX_EXP_CS2;
+-
+-	platform_device_register(&avila_pata);
+-
+ 	i2c_register_board_info(0, avila_i2c_board_info,
+ 			ARRAY_SIZE(avila_i2c_board_info));
+ 
+@@ -570,7 +654,6 @@ static int __init avila_model_setup(void
+ 						" -- defaults will be used\n");
+ 		avila_gw23xx_setup();
+ 	}
+-
+ 	return 0;
+ }
+ late_initcall(avila_model_setup);
Index: trunk/target/linux/ixp4xx/patches-2.6.38/505-gateworks_gsp.patch
===================================================================
--- trunk/target/linux/ixp4xx/patches-2.6.38/505-gateworks_gsp.patch	(revision 0)
+++ trunk/target/linux/ixp4xx/patches-2.6.38/505-gateworks_gsp.patch	(working copy)
@@ -0,0 +1,342 @@
+--- /dev/null
++++ b/drivers/hwmon/gsp.c
+@@ -0,0 +1,311 @@
++/*
++ * A hwmon driver for the Gateworks System Peripheral
++ * Copyright (C) 2009 Gateworks Corporation
++ *
++ * Author: Chris Lang <clang@gateworks.com>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License,
++ * as published by the Free Software Foundation - version 2.
++ */
++
++#include <linux/module.h>
++#include <linux/i2c.h>
++#include <linux/hwmon.h>
++#include <linux/hwmon-sysfs.h>
++#include <linux/err.h>
++#include <linux/slab.h>
++
++#define DRV_VERSION "0.2"
++
++enum chips { gsp };
++
++/* AD7418 registers */
++#define GSP_REG_TEMP_IN		0x00
++#define GSP_REG_VIN		0x02
++#define GSP_REG_3P3		0x05
++#define GSP_REG_BAT		0x08
++#define GSP_REG_5P0		0x0b
++#define GSP_REG_CORE		0x0e
++#define GSP_REG_CPU1		0x11
++#define GSP_REG_CPU2		0x14
++#define GSP_REG_DRAM		0x17
++#define GSP_REG_EXT_BAT		0x1a
++#define GSP_REG_IO1		0x1d
++#define GSP_REG_IO2 		0x20
++#define GSP_REG_PCIE		0x23
++#define GSP_REG_CURRENT		0x26
++#define GSP_FAN_0		0x2C
++#define GSP_FAN_1		0x2E
++#define GSP_FAN_2		0x30
++#define GSP_FAN_3		0x32
++#define GSP_FAN_4		0x34
++#define GSP_FAN_5		0x36
++
++struct gsp_sensor_info {
++	const char* name;
++	int reg;
++};
++
++static const struct gsp_sensor_info gsp_sensors[] = {
++	{"temp", GSP_REG_TEMP_IN},
++	{"vin", GSP_REG_VIN},
++	{"3p3", GSP_REG_3P3},
++	{"bat", GSP_REG_BAT},
++	{"5p0", GSP_REG_5P0},
++	{"core", GSP_REG_CORE},
++	{"cpu1", GSP_REG_CPU1},
++	{"cpu2", GSP_REG_CPU2},
++	{"dram", GSP_REG_DRAM},
++	{"ext_bat", GSP_REG_EXT_BAT},
++	{"io1", GSP_REG_IO1},
++	{"io2", GSP_REG_IO2},
++	{"pci2", GSP_REG_PCIE},
++	{"current", GSP_REG_CURRENT},
++	{"fan_point0", GSP_FAN_0},
++	{"fan_point1", GSP_FAN_1},
++	{"fan_point2", GSP_FAN_2},
++	{"fan_point3", GSP_FAN_3},
++	{"fan_point4", GSP_FAN_4},
++	{"fan_point5", GSP_FAN_5},
++};
++
++struct gsp_data {
++	struct device		*hwmon_dev;
++	struct attribute_group	attrs;
++	enum chips		type;
++};
++
++static int gsp_probe(struct i2c_client *client,
++			const struct i2c_device_id *id);
++static int gsp_remove(struct i2c_client *client);
++
++static const struct i2c_device_id gsp_id[] = {
++	{ "gsp", 0 },
++	{ }
++};
++MODULE_DEVICE_TABLE(i2c, gsp_id);
++
++static struct i2c_driver gsp_driver = {
++	.driver = {
++		.name	= "gsp",
++	},
++	.probe		= gsp_probe,
++	.remove		= gsp_remove,
++	.id_table	= gsp_id,
++};
++
++/* All registers are word-sized, except for the configuration registers.
++ * AD7418 uses a high-byte first convention. Do NOT use those functions to
++ * access the configuration registers CONF and CONF2, as they are byte-sized.
++ */
++static inline int gsp_read(struct i2c_client *client, u8 reg)
++{
++	int adc = 0;
++	if (reg == GSP_REG_TEMP_IN || reg > GSP_REG_CURRENT)
++	{
++		adc |= i2c_smbus_read_byte_data(client, reg);
++		adc |= i2c_smbus_read_byte_data(client, reg + 1) << 8;
++		if (adc > 0x8000) { // convert neg temps from two's-complement
++        		adc = adc - 0xffff;
++		}
++		return adc;
++	}
++	else
++	{
++		adc |= i2c_smbus_read_byte_data(client, reg);
++		adc |= i2c_smbus_read_byte_data(client, reg + 1) << 8;
++		adc |= i2c_smbus_read_byte_data(client, reg + 2) << 16;
++		return adc;
++	}
++}
++
++static inline int gsp_write(struct i2c_client *client, u8 reg, u16 value)
++{
++	i2c_smbus_write_byte_data(client, reg, value & 0xff);
++	i2c_smbus_write_byte_data(client, reg + 1, ((value >> 8) & 0xff));
++	return 1;
++}
++
++static ssize_t show_adc(struct device *dev, struct device_attribute *devattr,
++			char *buf)
++{
++	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
++	struct i2c_client *client = to_i2c_client(dev);
++	return sprintf(buf, "%d\n", gsp_read(client, gsp_sensors[attr->index].reg));
++}
++
++static ssize_t show_label(struct device *dev,
++			struct device_attribute *devattr, char *buf)
++{
++	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
++
++	return sprintf(buf, "%s\n", gsp_sensors[attr->index].name);
++}
++
++static ssize_t store_fan(struct device *dev,
++			struct device_attribute *devattr, const char *buf, size_t count)
++{
++	u16 val;
++	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
++	struct i2c_client *client = to_i2c_client(dev);
++	val = simple_strtoul(buf, NULL, 10);
++	gsp_write(client, gsp_sensors[attr->index].reg, val);
++	return count;
++}
++
++static SENSOR_DEVICE_ATTR(temp0_input, S_IRUGO, show_adc, NULL, 0);
++static SENSOR_DEVICE_ATTR(temp0_label, S_IRUGO, show_label, NULL, 0);
++
++static SENSOR_DEVICE_ATTR(in0_input, S_IRUGO, show_adc, NULL, 1);
++static SENSOR_DEVICE_ATTR(in0_label, S_IRUGO, show_label, NULL, 1);
++static SENSOR_DEVICE_ATTR(in1_input, S_IRUGO, show_adc, NULL, 2);
++static SENSOR_DEVICE_ATTR(in1_label, S_IRUGO, show_label, NULL, 2);
++static SENSOR_DEVICE_ATTR(in2_input, S_IRUGO, show_adc, NULL, 3);
++static SENSOR_DEVICE_ATTR(in2_label, S_IRUGO, show_label, NULL, 3);
++static SENSOR_DEVICE_ATTR(in3_input, S_IRUGO, show_adc, NULL, 4);
++static SENSOR_DEVICE_ATTR(in3_label, S_IRUGO, show_label, NULL, 4);
++static SENSOR_DEVICE_ATTR(in4_input, S_IRUGO, show_adc, NULL, 5);
++static SENSOR_DEVICE_ATTR(in4_label, S_IRUGO, show_label, NULL, 5);
++static SENSOR_DEVICE_ATTR(in5_input, S_IRUGO, show_adc, NULL, 6);
++static SENSOR_DEVICE_ATTR(in5_label, S_IRUGO, show_label, NULL, 6);
++static SENSOR_DEVICE_ATTR(in6_input, S_IRUGO, show_adc, NULL, 7);
++static SENSOR_DEVICE_ATTR(in6_label, S_IRUGO, show_label, NULL, 7);
++static SENSOR_DEVICE_ATTR(in7_input, S_IRUGO, show_adc, NULL, 8);
++static SENSOR_DEVICE_ATTR(in7_label, S_IRUGO, show_label, NULL, 8);
++static SENSOR_DEVICE_ATTR(in8_input, S_IRUGO, show_adc, NULL, 9);
++static SENSOR_DEVICE_ATTR(in8_label, S_IRUGO, show_label, NULL, 9);
++static SENSOR_DEVICE_ATTR(in9_input, S_IRUGO, show_adc, NULL, 10);
++static SENSOR_DEVICE_ATTR(in9_label, S_IRUGO, show_label, NULL, 10);
++static SENSOR_DEVICE_ATTR(in10_input, S_IRUGO, show_adc, NULL, 11);
++static SENSOR_DEVICE_ATTR(in10_label, S_IRUGO, show_label, NULL, 11);
++static SENSOR_DEVICE_ATTR(in11_input, S_IRUGO, show_adc, NULL, 12);
++static SENSOR_DEVICE_ATTR(in11_label, S_IRUGO, show_label, NULL, 12);
++static SENSOR_DEVICE_ATTR(in12_input, S_IRUGO, show_adc, NULL, 13);
++static SENSOR_DEVICE_ATTR(in12_label, S_IRUGO, show_label, NULL, 13);
++
++static SENSOR_DEVICE_ATTR(fan0_point0, S_IRUGO | S_IWUSR, show_adc, store_fan, 14);
++static SENSOR_DEVICE_ATTR(fan0_point1, S_IRUGO | S_IWUSR, show_adc, store_fan, 15);
++static SENSOR_DEVICE_ATTR(fan0_point2, S_IRUGO | S_IWUSR, show_adc, store_fan, 16);
++static SENSOR_DEVICE_ATTR(fan0_point3, S_IRUGO | S_IWUSR, show_adc, store_fan, 17);
++static SENSOR_DEVICE_ATTR(fan0_point4, S_IRUGO | S_IWUSR, show_adc, store_fan, 18);
++static SENSOR_DEVICE_ATTR(fan0_point5, S_IRUGO | S_IWUSR, show_adc, store_fan, 19);
++
++static struct attribute *gsp_attributes[] = {
++	&sensor_dev_attr_temp0_input.dev_attr.attr,
++	&sensor_dev_attr_in0_input.dev_attr.attr,
++	&sensor_dev_attr_in1_input.dev_attr.attr,
++	&sensor_dev_attr_in2_input.dev_attr.attr,
++	&sensor_dev_attr_in3_input.dev_attr.attr,
++	&sensor_dev_attr_in4_input.dev_attr.attr,
++	&sensor_dev_attr_in5_input.dev_attr.attr,
++	&sensor_dev_attr_in6_input.dev_attr.attr,
++	&sensor_dev_attr_in7_input.dev_attr.attr,
++	&sensor_dev_attr_in8_input.dev_attr.attr,
++	&sensor_dev_attr_in9_input.dev_attr.attr,
++	&sensor_dev_attr_in10_input.dev_attr.attr,
++	&sensor_dev_attr_in11_input.dev_attr.attr,
++	&sensor_dev_attr_in12_input.dev_attr.attr,
++
++	&sensor_dev_attr_temp0_label.dev_attr.attr,
++	&sensor_dev_attr_in0_label.dev_attr.attr,
++	&sensor_dev_attr_in1_label.dev_attr.attr,
++	&sensor_dev_attr_in2_label.dev_attr.attr,
++	&sensor_dev_attr_in3_label.dev_attr.attr,
++	&sensor_dev_attr_in4_label.dev_attr.attr,
++	&sensor_dev_attr_in5_label.dev_attr.attr,
++	&sensor_dev_attr_in6_label.dev_attr.attr,
++	&sensor_dev_attr_in7_label.dev_attr.attr,
++	&sensor_dev_attr_in8_label.dev_attr.attr,
++	&sensor_dev_attr_in9_label.dev_attr.attr,
++	&sensor_dev_attr_in10_label.dev_attr.attr,
++	&sensor_dev_attr_in11_label.dev_attr.attr,
++	&sensor_dev_attr_in12_label.dev_attr.attr,
++
++	&sensor_dev_attr_fan0_point0.dev_attr.attr,
++	&sensor_dev_attr_fan0_point1.dev_attr.attr,
++	&sensor_dev_attr_fan0_point2.dev_attr.attr,
++	&sensor_dev_attr_fan0_point3.dev_attr.attr,
++	&sensor_dev_attr_fan0_point4.dev_attr.attr,
++	&sensor_dev_attr_fan0_point5.dev_attr.attr,
++	NULL
++};
++
++
++static int gsp_probe(struct i2c_client *client,
++			 const struct i2c_device_id *id)
++{
++	struct i2c_adapter *adapter = client->adapter;
++	struct gsp_data *data;
++	int err;
++
++	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA |
++					I2C_FUNC_SMBUS_WORD_DATA)) {
++		err = -EOPNOTSUPP;
++		goto exit;
++	}
++
++	if (!(data = kzalloc(sizeof(struct gsp_data), GFP_KERNEL))) {
++		err = -ENOMEM;
++		goto exit;
++	}
++
++	i2c_set_clientdata(client, data);
++
++	data->type = id->driver_data;
++
++	switch (data->type) {
++	case 0:
++		data->attrs.attrs = gsp_attributes;
++		break;
++	}
++
++	dev_info(&client->dev, "%s chip found\n", client->name);
++
++	/* Register sysfs hooks */
++	if ((err = sysfs_create_group(&client->dev.kobj, &data->attrs)))
++		goto exit_free;
++
++	data->hwmon_dev = hwmon_device_register(&client->dev);
++	if (IS_ERR(data->hwmon_dev)) {
++		err = PTR_ERR(data->hwmon_dev);
++		goto exit_remove;
++	}
++
++	return 0;
++
++exit_remove:
++	sysfs_remove_group(&client->dev.kobj, &data->attrs);
++exit_free:
++	kfree(data);
++exit:
++	return err;
++}
++
++static int gsp_remove(struct i2c_client *client)
++{
++	struct gsp_data *data = i2c_get_clientdata(client);
++	hwmon_device_unregister(data->hwmon_dev);
++	sysfs_remove_group(&client->dev.kobj, &data->attrs);
++	kfree(data);
++	return 0;
++}
++
++static int __init gsp_init(void)
++{
++	return i2c_add_driver(&gsp_driver);
++}
++
++static void __exit gsp_exit(void)
++{
++	i2c_del_driver(&gsp_driver);
++}
++
++module_init(gsp_init);
++module_exit(gsp_exit);
++
++MODULE_AUTHOR("Chris Lang <clang@gateworks.com>");
++MODULE_DESCRIPTION("GSP HWMON driver");
++MODULE_LICENSE("GPL");
++MODULE_VERSION(DRV_VERSION);
++
+--- a/drivers/hwmon/Kconfig
++++ b/drivers/hwmon/Kconfig
+@@ -68,6 +68,15 @@ config SENSORS_ABITUGURU3
+ 	  This driver can also be built as a module.  If so, the module
+ 	  will be called abituguru3.
+ 
++config SENSORS_GSP
++  tristate "Gateworks System Peripheral"
++  depends on I2C && EXPERIMENTAL
++  help
++    If you say yes here you get support for the Gateworks System Peripherals.
++
++    This driver can also be built as a module. If so, the module
++    will be called gsp.
++
+ config SENSORS_AD7414
+ 	tristate "Analog Devices AD7414"
+ 	depends on I2C && EXPERIMENTAL
+--- a/drivers/hwmon/Makefile
++++ b/drivers/hwmon/Makefile
+@@ -20,6 +20,7 @@ obj-$(CONFIG_SENSORS_W83791D)	+= w83791d
+ 
+ obj-$(CONFIG_SENSORS_ABITUGURU)	+= abituguru.o
+ obj-$(CONFIG_SENSORS_ABITUGURU3)+= abituguru3.o
++obj-$(CONFIG_SENSORS_GSP)	+= gsp.o
+ obj-$(CONFIG_SENSORS_AD7414)	+= ad7414.o
+ obj-$(CONFIG_SENSORS_AD7418)	+= ad7418.o
+ obj-$(CONFIG_SENSORS_ADCXX)	+= adcxx.o
Index: trunk/target/linux/ixp4xx/patches-2.6.38/506-gw2370_support.patch
===================================================================
--- trunk/target/linux/ixp4xx/patches-2.6.38/506-gw2370_support.patch	(revision 0)
+++ trunk/target/linux/ixp4xx/patches-2.6.38/506-gw2370_support.patch	(working copy)
@@ -0,0 +1,89 @@
+--- a/arch/arm/mach-ixp4xx/avila-setup.c
++++ b/arch/arm/mach-ixp4xx/avila-setup.c
+@@ -495,14 +495,14 @@ static void __init avila_gw2365_setup(vo
+ 	avila_npec_data.phy = 2;
+ 	platform_device_register(&avila_npec_device);
+ 
+-	avila_pata_resources[0].start = IXP4XX_EXP_BUS_BASE(1);
+-	avila_pata_resources[0].end = IXP4XX_EXP_BUS_END(1);
++	avila_pata_resources[0].start = IXP4XX_EXP_BUS_BASE(2);
++	avila_pata_resources[0].end = IXP4XX_EXP_BUS_END(2);
+ 
+-	avila_pata_resources[1].start = IXP4XX_EXP_BUS_BASE(2);
+-	avila_pata_resources[1].end = IXP4XX_EXP_BUS_END(2);
++	avila_pata_resources[1].start = IXP4XX_EXP_BUS_BASE(3);
++	avila_pata_resources[1].end = IXP4XX_EXP_BUS_END(3);
+ 
+-	avila_pata_data.cs0_cfg = IXP4XX_EXP_CS1;
+-	avila_pata_data.cs1_cfg = IXP4XX_EXP_CS2;
++	avila_pata_data.cs0_cfg = IXP4XX_EXP_CS2;
++	avila_pata_data.cs1_cfg = IXP4XX_EXP_CS3;
+ 
+ 	platform_device_register(&avila_pata);
+ 
+@@ -520,6 +520,37 @@ static void __init avila_gw2369_setup(vo
+ 	platform_device_register(&avila_npec_device);
+ }
+ 
++static void __init avila_gw2370_setup(void)
++{
++	avila_npeb_data.phy = 5;
++	platform_device_register(&avila_npeb_device);
++
++	avila_npec_data.phy = IXP4XX_ETH_PHY_MAX_ADDR;
++	avila_npec_data.phy_mask = 0x1e; /* ports 1-4 of the KS8995 switch */
++	platform_device_register(&avila_npec_device);
++
++	*IXP4XX_EXP_CS2 = 0xBFFF3C43;
++	set_irq_type(IRQ_IXP4XX_GPIO2, IRQ_TYPE_EDGE_RISING);
++	avila_optional_uart_data[0].mapbase = 0x52000000;
++	avila_optional_uart_data[0].membase = (void __iomem *)ioremap(0x52000000, 0x0fff);
++	avila_optional_uart_data[0].irq   = IRQ_IXP4XX_GPIO2;
++
++	*IXP4XX_EXP_CS3 = 0xBFFF3C43;
++	set_irq_type(IRQ_IXP4XX_GPIO3, IRQ_TYPE_EDGE_RISING);
++	avila_optional_uart_data[1].mapbase = 0x53000000;
++	avila_optional_uart_data[1].membase = (void __iomem *)ioremap(0x53000000, 0x0fff);
++	avila_optional_uart_data[1].irq   = IRQ_IXP4XX_GPIO3;
++
++	avila_optional_uart.num_resources = 2;
++
++	platform_device_register(&avila_optional_uart);
++
++	avila_gpio_leds[0].gpio = 101;
++	platform_device_register(&avila_gpio_leds_device);
++}
++
++
++
+ static struct avila_board_info avila_boards[] __initdata = {
+ 	{
+ 		.model		= "GW2342",
+@@ -548,6 +579,9 @@ static struct avila_board_info avila_boa
+ 	}, {
+ 		.model		= "GW2369",
+ 		.setup		= avila_gw2369_setup,
++	}, {
++		.model		= "GW2370",
++		.setup		= avila_gw2370_setup,
+ 	}
+ };
+ 
+@@ -592,7 +626,7 @@ static void at24_setup(struct memory_acc
+ static struct at24_platform_data avila_eeprom_info = {
+ 	.byte_len	= 1024,
+ 	.page_size	= 16,
+-	.flags		= AT24_FLAG_READONLY,
++	//.flags		= AT24_FLAG_READONLY,
+ 	.setup		= at24_setup,
+ };
+ 
+@@ -630,7 +664,7 @@ static void __init avila_init(void)
+ 	 */
+ 	avila_flash_resource.start = IXP4XX_EXP_BUS_BASE(0);
+ 	avila_flash_resource.end =
+-		IXP4XX_EXP_BUS_BASE(0) + ixp4xx_exp_bus_size - 1;
++		IXP4XX_EXP_BUS_BASE(0) + (2 * ixp4xx_exp_bus_size) - 1;
+ 
+ 	platform_add_devices(avila_devices, ARRAY_SIZE(avila_devices));
+ 
Index: trunk/target/linux/ixp4xx/patches-2.6.38/507-gw2371_support.patch
===================================================================
--- trunk/target/linux/ixp4xx/patches-2.6.38/507-gw2371_support.patch	(revision 0)
+++ trunk/target/linux/ixp4xx/patches-2.6.38/507-gw2371_support.patch	(working copy)
@@ -0,0 +1,22 @@
+--- a/arch/arm/mach-ixp4xx/cambria-setup.c
++++ b/arch/arm/mach-ixp4xx/cambria-setup.c
+@@ -448,6 +448,9 @@ static struct cambria_board_info cambria
+ 	}, {
+ 		.model	= "GW2358",
+ 		.setup	= cambria_gw2358_setup,
++	}, {
++		.model	= "GW2371",
++		.setup	= cambria_gw2358_setup,
+ 	}
+ };
+ 
+@@ -501,6 +504,9 @@ static struct i2c_board_info __initdata
+ 		I2C_BOARD_INFO("ds1672", 0x68),
+ 	},
+ 	{
++                I2C_BOARD_INFO("gsp", 0x29),
++        },
++	{
+ 		I2C_BOARD_INFO("ad7418", 0x28),
+ 	},
+ 	{
Index: trunk/target/linux/ixp4xx/patches-2.6.38/508-gw2373_support.patch
===================================================================
--- trunk/target/linux/ixp4xx/patches-2.6.38/508-gw2373_support.patch	(revision 0)
+++ trunk/target/linux/ixp4xx/patches-2.6.38/508-gw2373_support.patch	(working copy)
@@ -0,0 +1,12 @@
+--- a/arch/arm/mach-ixp4xx/avila-setup.c
++++ b/arch/arm/mach-ixp4xx/avila-setup.c
+@@ -582,6 +582,9 @@ static struct avila_board_info avila_boa
+ 	}, {
+ 		.model		= "GW2370",
+ 		.setup		= avila_gw2370_setup,
++	}, {
++		.model		= "GW2373",
++		.setup		= avila_gw2369_setup,
+ 	}
+ };
+ 
Index: trunk/target/linux/ixp4xx/patches-2.6.38/509-avila_hss_audio_support.patch
===================================================================
--- trunk/target/linux/ixp4xx/patches-2.6.38/509-avila_hss_audio_support.patch	(revision 0)
+++ trunk/target/linux/ixp4xx/patches-2.6.38/509-avila_hss_audio_support.patch	(working copy)
@@ -0,0 +1,2223 @@
+--- a/sound/soc/Kconfig
++++ b/sound/soc/Kconfig
+@@ -55,6 +55,7 @@ source "sound/soc/samsung/Kconfig"
+ source "sound/soc/s6000/Kconfig"
+ source "sound/soc/sh/Kconfig"
+ source "sound/soc/txx9/Kconfig"
++source "sound/soc/gw-avila/Kconfig"
+ 
+ # Supported codecs
+ source "sound/soc/codecs/Kconfig"
+--- a/sound/soc/Makefile
++++ b/sound/soc/Makefile
+@@ -18,3 +18,4 @@ obj-$(CONFIG_SND_SOC)	+= samsung/
+ obj-$(CONFIG_SND_SOC)	+= s6000/
+ obj-$(CONFIG_SND_SOC)	+= sh/
+ obj-$(CONFIG_SND_SOC)	+= txx9/
++obj-$(CONFIG_SND_SOC)	+= gw-avila/
+--- /dev/null
++++ b/sound/soc/gw-avila/Kconfig
+@@ -0,0 +1,17 @@
++config SND_GW_AVILA_SOC_PCM
++	tristate
++
++config SND_GW_AVILA_SOC_HSS
++	tristate
++
++config SND_GW_AVILA_SOC
++	tristate "SoC Audio for the Gateworks AVILA Family"
++	depends on ARCH_IXP4XX && SND_SOC
++	select SND_GW_AVILA_SOC_PCM
++	select SND_GW_AVILA_SOC_HSS
++	select SND_SOC_TLV320AIC3X
++	help
++	  Say Y or M if you want to add support for codecs attached to
++	  the Gateworks HSS interface. You will also need
++	  to select the audio interfaces to support below.
++
+--- /dev/null
++++ b/sound/soc/gw-avila/Makefile
+@@ -0,0 +1,8 @@
++# Gateworks Avila HSS Platform Support
++snd-soc-gw-avila-objs := gw-avila.o ixp4xx_hss.o
++snd-soc-gw-avila-pcm-objs := gw-avila-pcm.o
++snd-soc-gw-avila-hss-objs := gw-avila-hss.o
++
++obj-$(CONFIG_SND_GW_AVILA_SOC) += snd-soc-gw-avila.o
++obj-$(CONFIG_SND_GW_AVILA_SOC_PCM) += snd-soc-gw-avila-pcm.o
++obj-$(CONFIG_SND_GW_AVILA_SOC_HSS) += snd-soc-gw-avila-hss.o
+--- /dev/null
++++ b/sound/soc/gw-avila/gw-avila-hss.c
+@@ -0,0 +1,98 @@
++/*
++ * gw-avila-hss.c -- HSS Audio Support for Gateworks Avila
++ *
++ * Author:	Chris Lang	<clang@gateworks.com>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ */
++
++#include <linux/init.h>
++#include <linux/module.h>
++#include <linux/platform_device.h>
++#include <linux/interrupt.h>
++#include <linux/wait.h>
++#include <linux/delay.h>
++
++#include <sound/core.h>
++#include <sound/pcm.h>
++#include <sound/ac97_codec.h>
++#include <sound/initval.h>
++#include <sound/soc.h>
++
++#include <asm/irq.h>
++#include <linux/mutex.h>
++#include <linux/gpio.h>
++
++#include "ixp4xx_hss.h"
++#include "gw-avila-hss.h"
++
++#define gw_avila_hss_suspend	NULL
++#define gw_avila_hss_resume	NULL
++
++struct snd_soc_dai_driver gw_avila_hss_dai = {
++	.playback = {
++		.channels_min = 2,
++		.channels_max = 2,
++		.rates = (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000 |
++			SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_32000 |
++			SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 |
++			SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000 |
++			SNDRV_PCM_RATE_KNOT),
++		.formats = SNDRV_PCM_FMTBIT_S16_LE, },
++	.capture = {
++		.channels_min = 2,
++		.channels_max = 2,
++		.rates = (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000 |
++			SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_32000 |
++			SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 |
++			SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000 |
++			SNDRV_PCM_RATE_KNOT),
++		.formats = SNDRV_PCM_FMTBIT_S16_LE, },
++};
++
++static int gw_avila_hss_probe(struct platform_device *pdev)
++{
++	int port = (pdev->id < 2) ? 0 : 1;
++	int channel = (pdev->id % 2);
++
++	hss_handle[pdev->id] = hss_init(port, channel);
++	if (!hss_handle[pdev->id]) {
++		return -ENODEV;
++	}
++
++	return snd_soc_register_dai(&pdev->dev, &gw_avila_hss_dai);
++}
++
++static int gw_avila_hss_remove(struct platform_device *pdev)
++{
++	snd_soc_unregister_dai(&pdev->dev);
++
++	return 0;
++}
++
++static struct platform_driver gw_avila_hss_driver = {
++	.probe    = gw_avila_hss_probe,
++	.remove   = gw_avila_hss_remove,
++	.driver   = {
++		.name = "gw_avila_hss",
++		.owner  = THIS_MODULE,
++	}
++};
++
++static int __init gw_avila_hss_init(void)
++{
++	return platform_driver_register(&gw_avila_hss_driver);
++}
++module_init(gw_avila_hss_init);
++
++static void __exit gw_avila_hss_exit(void)
++{
++	platform_driver_unregister(&gw_avila_hss_driver);
++}
++module_exit(gw_avila_hss_exit);
++
++MODULE_AUTHOR("Chris Lang");
++MODULE_DESCRIPTION("HSS Audio Driver for Gateworks Avila");
++MODULE_LICENSE("GPL");
+--- /dev/null
++++ b/sound/soc/gw-avila/gw-avila-hss.h
+@@ -0,0 +1,12 @@
++/*
++ * Author: Chris Lang <clang@gateworks.com>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ */
++
++#ifndef _GW_AVILA_HSS_H
++#define _GW_AVILA_HSS_H
++
++#endif
+--- /dev/null
++++ b/sound/soc/gw-avila/gw-avila-pcm.c
+@@ -0,0 +1,325 @@
++/*
++ * ALSA PCM interface for the TI DAVINCI processor
++ *
++ * Author:      Chris Lang, <clang@gateworks.com>
++ * Copyright:   (C) 2009 Gateworks Corporation
++ *
++ * Based On:    davinci-evm.c, Author: Vladimir Barinov, <vbarinov@ru.mvista.com>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ */
++
++#include <linux/module.h>
++#include <linux/init.h>
++#include <linux/platform_device.h>
++#include <linux/slab.h>
++#include <linux/dma-mapping.h>
++
++#include <sound/core.h>
++#include <sound/pcm.h>
++#include <sound/pcm_params.h>
++#include <sound/soc.h>
++
++#include <asm/dma.h>
++
++#include "gw-avila-pcm.h"
++#include "gw-avila-hss.h"
++#include "ixp4xx_hss.h"
++
++#define GW_AVILA_PCM_DEBUG 0
++#if GW_AVILA_PCM_DEBUG
++#define DPRINTK(x...) printk(KERN_DEBUG x)
++#else
++#define DPRINTK(x...)
++#endif
++
++static struct snd_pcm_hardware gw_avila_pcm_hardware = {
++	.info = (SNDRV_PCM_INFO_INTERLEAVED | SNDRV_PCM_INFO_BLOCK_TRANSFER |
++		 SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_MMAP_VALID),
++/*		 SNDRV_PCM_INFO_PAUSE),*/
++	.formats = (SNDRV_PCM_FMTBIT_S16_LE),
++	.rates = (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000 |
++		  SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_32000 |
++		  SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 |
++		  SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000 |
++		  SNDRV_PCM_RATE_KNOT),
++	.rate_min = 8000,
++	.rate_max = 8000,
++	.channels_min = 2,
++	.channels_max = 2,
++	.buffer_bytes_max = 64 * 1024, // All of the lines below may need to be changed
++	.period_bytes_min = 128,
++	.period_bytes_max = 4 * 1024,
++	.periods_min = 16,
++	.periods_max = 32,
++	.fifo_size = 0,
++};
++
++struct gw_avila_runtime_data {
++	spinlock_t lock;
++	int period;		/* current DMA period */
++	int master_lch;		/* Master DMA channel */
++	int slave_lch;		/* Slave DMA channel */
++	struct gw_avila_pcm_dma_params *params;	/* DMA params */
++};
++
++static void gw_avila_dma_irq(void *data)
++{
++	struct snd_pcm_substream *substream = data;
++	snd_pcm_period_elapsed(substream);
++}
++
++static int gw_avila_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
++{
++	struct snd_pcm_runtime *runtime = substream->runtime;
++	struct hss_device *hdev = runtime->private_data;
++	int ret = 0;
++
++	switch (cmd) {
++	case SNDRV_PCM_TRIGGER_START:
++	case SNDRV_PCM_TRIGGER_RESUME:
++	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
++		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
++			hss_tx_start(hdev);
++		else
++			hss_rx_start(hdev);
++		break;
++	case SNDRV_PCM_TRIGGER_STOP:
++	case SNDRV_PCM_TRIGGER_SUSPEND:
++	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
++		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
++			hss_tx_stop(hdev);
++		else
++			hss_rx_stop(hdev);
++		break;
++	default:
++		ret = -EINVAL;
++		break;
++	}
++	return ret;
++}
++
++static int gw_avila_pcm_prepare(struct snd_pcm_substream *substream)
++{
++	struct snd_pcm_runtime *runtime = substream->runtime;
++	struct hss_device *hdev = runtime->private_data;
++
++	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
++		hss_set_tx_callback(hdev, gw_avila_dma_irq, substream);
++		hss_config_tx_dma(hdev, runtime->dma_area, runtime->buffer_size, runtime->period_size);
++	} else {
++		hss_set_rx_callback(hdev, gw_avila_dma_irq, substream);
++		hss_config_rx_dma(hdev, runtime->dma_area, runtime->buffer_size, runtime->period_size);
++	}
++
++	return 0;
++}
++
++static snd_pcm_uframes_t
++gw_avila_pcm_pointer(struct snd_pcm_substream *substream)
++{
++	struct snd_pcm_runtime *runtime = substream->runtime;
++	struct hss_device *hdev = runtime->private_data;
++
++	unsigned int curr = 0;
++	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
++		curr = hss_curr_offset_tx(hdev);
++	else
++		curr = hss_curr_offset_rx(hdev);
++  return curr;
++}
++
++static int gw_avila_pcm_open(struct snd_pcm_substream *substream)
++{
++	struct snd_pcm_runtime *runtime = substream->runtime;
++	struct snd_soc_pcm_runtime *rtd = substream->private_data;
++	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
++
++	snd_soc_set_runtime_hwparams(substream, &gw_avila_pcm_hardware);
++
++	if (hss_handle[cpu_dai->id] != NULL)
++		runtime->private_data = hss_handle[cpu_dai->id];
++	else {
++		pr_err("hss_handle is NULL\n");
++		return -1;
++	}
++
++	hss_chan_open(hss_handle[cpu_dai->id]);
++
++	return 0;
++}
++
++static int gw_avila_pcm_close(struct snd_pcm_substream *substream)
++{
++	struct snd_pcm_runtime *runtime = substream->runtime;
++	struct hss_device *hdev = runtime->private_data;
++
++	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
++		memset(hdev->tx_buf, 0, runtime->buffer_size);
++	} else
++		memset(hdev->rx_buf, 0, runtime->buffer_size);
++
++	hss_chan_close(hdev);
++
++	return 0;
++}
++
++static int gw_avila_pcm_hw_params(struct snd_pcm_substream *substream,
++				 struct snd_pcm_hw_params *hw_params)
++{
++	return snd_pcm_lib_malloc_pages(substream,
++					params_buffer_bytes(hw_params));
++}
++
++static int gw_avila_pcm_hw_free(struct snd_pcm_substream *substream)
++{
++	struct snd_pcm_runtime *runtime = substream->runtime;
++
++	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
++	  memset(runtime->dma_area, 0, runtime->buffer_size);
++
++	return snd_pcm_lib_free_pages(substream);
++}
++
++static int gw_avila_pcm_mmap(struct snd_pcm_substream *substream,
++          struct vm_area_struct *vma)
++{
++	struct snd_pcm_runtime *runtime = substream->runtime;
++
++	return dma_mmap_writecombine(substream->pcm->card->dev, vma,
++						runtime->dma_area,
++						runtime->dma_addr,
++						runtime->dma_bytes);
++}
++
++struct snd_pcm_ops gw_avila_pcm_ops = {
++	.open = 	gw_avila_pcm_open,
++	.close = 	gw_avila_pcm_close,
++	.ioctl = 	snd_pcm_lib_ioctl,
++	.hw_params = 	gw_avila_pcm_hw_params,
++	.hw_free = 	gw_avila_pcm_hw_free,
++	.prepare = 	gw_avila_pcm_prepare,
++	.trigger = 	gw_avila_pcm_trigger,
++	.pointer = 	gw_avila_pcm_pointer,
++	.mmap = gw_avila_pcm_mmap,
++};
++
++static int gw_avila_pcm_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)
++{
++	struct snd_pcm_substream *substream = pcm->streams[stream].substream;
++	struct snd_dma_buffer *buf = &substream->dma_buffer;
++	size_t size = gw_avila_pcm_hardware.buffer_bytes_max;
++
++	buf->dev.type = SNDRV_DMA_TYPE_DEV;
++	buf->dev.dev = pcm->card->dev;
++	buf->private_data = NULL;
++
++	buf->area = dma_alloc_coherent(pcm->card->dev, size,
++					   &buf->addr, GFP_KERNEL);
++
++	if (!buf->area) {
++		return -ENOMEM;
++	}
++
++	memset(buf->area, 0xff, size);
++
++	DPRINTK("preallocate_dma_buffer: area=%p, addr=%p, size=%d\n",
++		(void *) buf->area, (void *) buf->addr, size);
++
++	buf->bytes = size;
++
++	return 0;
++}
++
++static void gw_avila_pcm_free(struct snd_pcm *pcm)
++{
++	struct snd_pcm_substream *substream;
++	struct snd_dma_buffer *buf;
++	int stream;
++
++	for (stream = 0; stream < 2; stream++) {
++		substream = pcm->streams[stream].substream;
++		if (!substream)
++			continue;
++
++		buf = &substream->dma_buffer;
++		if (!buf->area)
++			continue;
++
++		dma_free_coherent(NULL, buf->bytes, buf->area, 0);
++		buf->area = NULL;
++	}
++}
++
++static u64 gw_avila_pcm_dmamask = 0xFFFFFFFF;
++
++static int gw_avila_pcm_new(struct snd_card *card,
++		struct snd_soc_dai *dai, struct snd_pcm *pcm)
++{
++	int ret;
++
++	if (!card->dev->dma_mask)
++		card->dev->dma_mask = &gw_avila_pcm_dmamask;
++	if (!card->dev->coherent_dma_mask)
++		card->dev->coherent_dma_mask = 0xFFFFFFFF;
++
++	if (dai->driver->playback.channels_min) {
++		ret = gw_avila_pcm_preallocate_dma_buffer(pcm,
++			SNDRV_PCM_STREAM_PLAYBACK);
++		if (ret)
++			return ret;
++	}
++
++	if (dai->driver->capture.channels_min) {
++		ret = gw_avila_pcm_preallocate_dma_buffer(pcm,
++			SNDRV_PCM_STREAM_CAPTURE);
++		if (ret)
++			return ret;
++	}
++
++	return 0;
++}
++
++struct snd_soc_platform_driver gw_avila_soc_platform = {
++	.ops = 	&gw_avila_pcm_ops,
++	.pcm_new = 	gw_avila_pcm_new,
++	.pcm_free = 	gw_avila_pcm_free,
++};
++
++static int __devinit gw_avila_pcm_platform_probe(struct platform_device *pdev)
++{
++	return snd_soc_register_platform(&pdev->dev, &gw_avila_soc_platform);
++}
++
++static int __devexit gw_avila_pcm_platform_remove(struct platform_device *pdev)
++{
++	snd_soc_unregister_platform(&pdev->dev);
++	return 0;
++}
++
++static struct platform_driver gw_avila_pcm_driver = {
++	.driver = {
++		.name = "gw_avila-audio",
++		.owner = THIS_MODULE,
++	},
++	.probe = gw_avila_pcm_platform_probe,
++	.remove = __devexit_p(gw_avila_pcm_platform_remove),
++};
++
++static int __init gw_avila_soc_platform_init(void)
++{
++	return platform_driver_register(&gw_avila_pcm_driver);
++}
++module_init(gw_avila_soc_platform_init);
++
++static void __exit gw_avila_soc_platform_exit(void)
++{
++	platform_driver_unregister(&gw_avila_pcm_driver);
++}
++module_exit(gw_avila_soc_platform_exit);
++
++MODULE_AUTHOR("Chris Lang");
++MODULE_DESCRIPTION("Gateworks Avila PCM DMA module");
++MODULE_LICENSE("GPL");
+--- /dev/null
++++ b/sound/soc/gw-avila/gw-avila-pcm.h
+@@ -0,0 +1,32 @@
++/*
++ * ALSA PCM interface for the Gateworks Avila platform
++ *
++ * Author:      Chris Lang, <clang@gateworks.com>
++ * Copyright:   (C) 2009 Gateworks Corporation
++ *
++ * Based On:    davinci-evm.c, Author: Vladimir Barinov, <vbarinov@ru.mvista.com>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ */
++
++#ifndef _GW_AVILA_PCM_H
++#define _GW_AVILA_PCM_H
++
++#if 0
++struct gw_avila_pcm_dma_params {
++	char *name;		/* stream identifier */
++	int channel;		/* sync dma channel ID */
++	dma_addr_t dma_addr;	/* device physical address for DMA */
++	unsigned int data_type;	/* xfer data type */
++};
++
++struct gw_avila_snd_platform_data {
++	int tx_dma_ch; // XXX Do we need this?
++	int rx_dma_ch; // XXX Do we need this
++};
++extern struct snd_soc_platform gw_avila_soc_platform[];
++#endif
++
++#endif
+--- /dev/null
++++ b/sound/soc/gw-avila/gw-avila.c
+@@ -0,0 +1,240 @@
++/*
++ * File:         sound/soc/gw-avila/gw_avila.c
++ * Author:       Chris Lang <clang@gateworks.com>
++ *
++ * Created:      Tue June 06 2008
++ * Description:  Board driver for Gateworks Avila
++ *
++ * Modified:
++ *               Copyright 2009 Gateworks Corporation
++ *
++ * Bugs:         What Bugs?
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, see the file COPYING, or write
++ * to the Free Software Foundation, Inc.,
++ * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
++ */
++
++#include <linux/module.h>
++#include <linux/moduleparam.h>
++#include <linux/device.h>
++#include <asm/dma.h>
++#include <linux/platform_device.h>
++#include <sound/core.h>
++#include <sound/pcm.h>
++#include <sound/soc.h>
++#include <linux/slab.h>
++#include <linux/gpio.h>
++
++#include "ixp4xx_hss.h"
++#include "gw-avila-hss.h"
++#include "gw-avila-pcm.h"
++
++#define CODEC_FREQ 33333000
++
++static int gw_avila_board_startup(struct snd_pcm_substream *substream)
++{
++	pr_debug("%s enter\n", __func__);
++	return 0;
++}
++
++static int gw_avila_hw_params(struct snd_pcm_substream *substream,
++		struct snd_pcm_hw_params *params)
++{
++	struct snd_soc_pcm_runtime *rtd = substream->private_data;
++	struct snd_soc_dai *codec_dai = rtd->codec_dai;
++	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
++
++	int ret = 0;
++
++	/* set codec DAI configuration */
++	if (cpu_dai->id % 2) {
++  		ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_DSP_B | SND_SOC_DAIFMT_IB_NF | SND_SOC_DAIFMT_CBS_CFS);
++			snd_soc_dai_set_tdm_slot(codec_dai, 0, 0, 1, 32);
++	} else {
++	  	ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_DSP_B | SND_SOC_DAIFMT_IB_NF | SND_SOC_DAIFMT_CBM_CFM);
++			snd_soc_dai_set_tdm_slot(codec_dai, 0, 0, 0, 32);
++	}
++
++	if (ret < 0)
++	    return ret;
++
++	/* set the codec system clock */
++	ret = snd_soc_dai_set_sysclk(codec_dai, 0, CODEC_FREQ, SND_SOC_CLOCK_OUT);
++	if (ret < 0)
++	    return ret;
++
++	return 0;
++}
++
++static const struct snd_soc_dapm_widget aic3x_dapm_widgets[] = {
++  SND_SOC_DAPM_HP("Headphone Jack", NULL),
++  SND_SOC_DAPM_LINE("Line Out", NULL),
++  SND_SOC_DAPM_LINE("Line In", NULL),
++};
++
++static const struct snd_soc_dapm_route audio_map[] = {
++  {"Headphone Jack", NULL, "HPLOUT"},
++  {"Headphone Jack", NULL, "HPROUT"},
++
++  /* Line Out connected to LLOUT, RLOUT */
++  {"Line Out", NULL, "LLOUT"},
++  {"Line Out", NULL, "RLOUT"},
++
++  /* Line In connected to (LINE1L | LINE2L), (LINE1R | LINE2R) */
++  {"LINE1L", NULL, "Line In"},
++  {"LINE1R", NULL, "Line In"},
++};
++
++/* Logic for a aic3x as connected on a davinci-evm */
++static int avila_aic3x_init(struct snd_soc_pcm_runtime *rtd)
++{
++	struct snd_soc_codec *codec = rtd->codec;
++	struct snd_soc_dapm_context *dapm = &codec->dapm;
++
++  /* Add davinci-evm specific widgets */
++  snd_soc_dapm_new_controls(dapm, aic3x_dapm_widgets,
++          ARRAY_SIZE(aic3x_dapm_widgets));
++
++  /* Set up davinci-evm specific audio path audio_map */
++  snd_soc_dapm_add_routes(dapm, audio_map, ARRAY_SIZE(audio_map));
++
++  /* not connected */
++  snd_soc_dapm_disable_pin(dapm, "MONO_LOUT");
++  //snd_soc_dapm_disable_pin(dapm, "HPLCOM");
++  //snd_soc_dapm_disable_pin(dapm, "HPRCOM");
++  snd_soc_dapm_disable_pin(dapm, "MIC3L");
++  snd_soc_dapm_disable_pin(dapm, "MIC3R");
++  snd_soc_dapm_disable_pin(dapm, "LINE2L");
++  snd_soc_dapm_disable_pin(dapm, "LINE2R");
++
++  /* always connected */
++	snd_soc_dapm_enable_pin(dapm, "Headphone Jack");
++  snd_soc_dapm_enable_pin(dapm, "Line Out");
++  snd_soc_dapm_enable_pin(dapm, "Line In");
++
++  snd_soc_dapm_sync(dapm);
++
++	return 0;
++}
++
++static struct snd_soc_ops gw_avila_board_ops = {
++	.startup = gw_avila_board_startup,
++	.hw_params = gw_avila_hw_params,
++};
++
++static struct snd_soc_dai_link gw_avila_board_dai[] = {
++	{
++		.name = "HSS-0",
++		.stream_name = "HSS-0",
++		.cpu_dai_name = "gw_avila_hss.0",
++		.codec_dai_name = "tlv320aic3x-hifi",
++		.codec_name = "tlv320aic3x-codec.0-001b",
++		.platform_name = "gw_avila-audio.0",
++		.init = avila_aic3x_init,
++		.ops = &gw_avila_board_ops,
++	},{
++		.name = "HSS-1",
++		.stream_name = "HSS-1",
++		.cpu_dai_name = "gw_avila_hss.1",
++		.codec_dai_name = "tlv320aic3x-hifi",
++		.codec_name = "tlv320aic3x-codec.0-001a",
++		.platform_name = "gw_avila-audio.1",
++		.init = avila_aic3x_init,
++		.ops = &gw_avila_board_ops,
++	},{
++		.name = "HSS-2",
++		.stream_name = "HSS-2",
++		.cpu_dai_name = "gw_avila_hss.2",
++		.codec_dai_name = "tlv320aic3x-hifi",
++		.codec_name = "tlv320aic3x-codec.0-0019",
++		.platform_name = "gw_avila-audio.2",
++		.init = avila_aic3x_init,
++		.ops = &gw_avila_board_ops,
++	},{
++		.name = "HSS-3",
++		.stream_name = "HSS-3",
++		.cpu_dai_name = "gw_avila_hss.3",
++		.codec_dai_name = "tlv320aic3x-hifi",
++		.codec_name = "tlv320aic3x-codec.0-0018",
++		.platform_name = "gw_avila-audio.3",
++		.init = avila_aic3x_init,
++		.ops = &gw_avila_board_ops,
++	},
++};
++
++static struct snd_soc_card gw_avila_board[] = {
++	{
++		.name = "gw_avila-board.0",
++		.dai_link = &gw_avila_board_dai[0],
++		.num_links = 1,
++	},{
++		.name = "gw_avila-board.1",
++		.dai_link = &gw_avila_board_dai[1],
++		.num_links = 1,
++	},{
++		.name = "gw_avila-board.2",
++		.dai_link = &gw_avila_board_dai[2],
++		.num_links = 1,
++	},{
++		.name = "gw_avila-board.3",
++		.dai_link = &gw_avila_board_dai[3],
++		.num_links = 1,
++	}
++};
++
++static struct platform_device *gw_avila_board_snd_device[4];
++
++static int __init gw_avila_board_init(void)
++{
++	int ret;
++	struct port *port;
++	int i;
++
++	if ((hss_port[0] = kzalloc(sizeof(*port), GFP_KERNEL)) == NULL)
++		return -ENOMEM;
++
++	if ((hss_port[1] = kzalloc(sizeof(*port), GFP_KERNEL)) == NULL)
++		return -ENOMEM;
++
++	for (i = 0; i < 4; i++) {
++		gw_avila_board_snd_device[i] = platform_device_alloc("soc-audio", i);
++		if (!gw_avila_board_snd_device[i]) {
++			return -ENOMEM;
++		}
++
++		platform_set_drvdata(gw_avila_board_snd_device[i], &gw_avila_board[i]);
++		ret = platform_device_add(gw_avila_board_snd_device[i]);
++
++		if (ret) {
++			platform_device_put(gw_avila_board_snd_device[i]);
++		}
++	}
++	return ret;
++}
++
++static void __exit gw_avila_board_exit(void)
++{
++	int i;
++	for (i = 0; i < 4; i++)
++		platform_device_unregister(gw_avila_board_snd_device[i]);
++}
++
++module_init(gw_avila_board_init);
++module_exit(gw_avila_board_exit);
++
++/* Module information */
++MODULE_AUTHOR("Chris Lang");
++MODULE_DESCRIPTION("ALSA SoC HSS Audio gw_avila board");
++MODULE_LICENSE("GPL");
+--- /dev/null
++++ b/sound/soc/gw-avila/ixp4xx_hss.c
+@@ -0,0 +1,900 @@
++/*
++ * Intel IXP4xx HSS (synchronous serial port) driver for Linux
++ *
++ * Copyright (C) 2009 Chris Lang <clang@gateworks.com>
++ *
++ * This program is free software; you can redistribute it and/or modify it
++ * under the terms of version 2 of the GNU General Public License
++ * as published by the Free Software Foundation.
++ */
++
++#include <linux/bitops.h>
++#include <linux/cdev.h>
++#include <linux/dma-mapping.h>
++#include <linux/dmapool.h>
++#include <linux/fs.h>
++#include <linux/io.h>
++#include <linux/kernel.h>
++#include <linux/platform_device.h>
++#include <linux/poll.h>
++#include <linux/slab.h>
++#include <mach/npe.h>
++#include <mach/qmgr.h>
++#include <linux/delay.h>
++
++#include "ixp4xx_hss.h"
++
++/*****************************************************************************
++ * global variables
++ ****************************************************************************/
++
++void hss_chan_read(unsigned long data);
++static char lock_init = 0;
++static spinlock_t npe_lock;
++static struct npe *npe;
++
++static const struct {
++	int tx, txdone, rx, rxfree, chan;
++}queue_ids[2] = {{HSS0_PKT_TX0_QUEUE, HSS0_PKT_TXDONE_QUEUE, HSS0_PKT_RX_QUEUE,
++		  HSS0_PKT_RXFREE0_QUEUE, HSS0_CHL_RXTRIG_QUEUE},
++		 {HSS1_PKT_TX0_QUEUE, HSS1_PKT_TXDONE_QUEUE, HSS1_PKT_RX_QUEUE,
++		  HSS1_PKT_RXFREE0_QUEUE, HSS1_CHL_RXTRIG_QUEUE},
++};
++
++struct port *hss_port[2];
++struct hss_device *hss_handle[32];
++EXPORT_SYMBOL(hss_handle);
++
++/*****************************************************************************
++ * utility functions
++ ****************************************************************************/
++
++#ifndef __ARMEB__
++static inline void memcpy_swab32(u32 *dest, u32 *src, int cnt)
++{
++	int i;
++	for (i = 0; i < cnt; i++)
++		dest[i] = swab32(src[i]);
++}
++#endif
++
++static inline unsigned int sub_offset(unsigned int a, unsigned int b,
++				      unsigned int modulo)
++{
++	return (modulo /* make sure the result >= 0 */ + a - b) % modulo;
++}
++
++/*****************************************************************************
++ * HSS access
++ ****************************************************************************/
++
++static void hss_config_load(struct port *port)
++{
++	struct msg msg;
++
++	do {
++		memset(&msg, 0, sizeof(msg));
++		msg.cmd = PORT_CONFIG_LOAD;
++		msg.hss_port = port->id;
++		if (npe_send_message(npe, &msg, "HSS_LOAD_CONFIG"))
++			break;
++		if (npe_recv_message(npe, &msg, "HSS_LOAD_CONFIG"))
++			break;
++
++		/* HSS_LOAD_CONFIG for port #1 returns port_id = #4 */
++		if (msg.cmd != PORT_CONFIG_LOAD || msg.data32)
++			break;
++
++		/* HDLC may stop working without this */
++		npe_recv_message(npe, &msg, "FLUSH_IT");
++		return;
++	} while (0);
++
++	printk(KERN_CRIT "HSS-%i: unable to reload HSS configuration\n",
++	       port->id);
++	BUG();
++}
++
++static void hss_config_set_pcr(struct port *port)
++{
++	struct msg msg;
++
++	do {
++		memset(&msg, 0, sizeof(msg));
++		msg.cmd = PORT_CONFIG_WRITE;
++		msg.hss_port = port->id;
++		msg.index = HSS_CONFIG_TX_PCR;
++#if 0
++		msg.data32 = PCR_FRM_SYNC_RISINGEDGE | PCR_MSB_ENDIAN |
++			PCR_TX_DATA_ENABLE | PCR_TX_UNASS_HIGH_IMP | PCR_TX_V56K_HIGH_IMP | PCR_TX_FB_HIGH_IMP;
++#else
++		msg.data32 = PCR_FRM_SYNC_RISINGEDGE | PCR_MSB_ENDIAN |
++			PCR_TX_DATA_ENABLE | PCR_TX_FB_HIGH_IMP | PCR_DCLK_EDGE_RISING;
++#endif
++		if (port->frame_size % 8 == 0)
++			msg.data32 |= PCR_SOF_NO_FBIT;
++
++		if (npe_send_message(npe, &msg, "HSS_SET_TX_PCR"))
++			break;
++
++		msg.index = HSS_CONFIG_RX_PCR;
++		msg.data32 &= ~ (PCR_DCLK_EDGE_RISING | PCR_FCLK_EDGE_RISING | PCR_TX_DATA_ENABLE);
++
++		if (npe_send_message(npe, &msg, "HSS_SET_RX_PCR"))
++			break;
++		return;
++	} while (0);
++
++	printk(KERN_CRIT "HSS-%i: unable to set HSS PCR registers\n", port->id);
++	BUG();
++}
++
++static void hss_config_set_core(struct port *port)
++{
++	struct msg msg;
++
++	memset(&msg, 0, sizeof(msg));
++	msg.cmd = PORT_CONFIG_WRITE;
++	msg.hss_port = port->id;
++	msg.index = HSS_CONFIG_CORE_CR;
++#if 0
++	msg.data32 = 0 | CCR_LOOPBACK |
++		(port->id ? CCR_SECOND_HSS : 0);
++#else
++	msg.data32 = 0 |
++		(port->id ? CCR_SECOND_HSS : 0);
++#endif
++	if (npe_send_message(npe, &msg, "HSS_SET_CORE_CR")) {
++		printk(KERN_CRIT "HSS-%i: unable to set HSS core control"
++		       " register\n", port->id);
++		BUG();
++	}
++}
++
++static void hss_config_set_line(struct port *port)
++{
++	struct msg msg;
++
++	hss_config_set_pcr(port);
++	hss_config_set_core(port);
++
++	memset(&msg, 0, sizeof(msg));
++	msg.cmd = PORT_CONFIG_WRITE;
++	msg.hss_port = port->id;
++	msg.index = HSS_CONFIG_CLOCK_CR;
++	msg.data32 = CLK42X_SPEED_8192KHZ /* FIXME */;
++	if (npe_send_message(npe, &msg, "HSS_SET_CLOCK_CR")) {
++		printk(KERN_CRIT "HSS-%i: unable to set HSS clock control"
++		       " register\n", port->id);
++		BUG();
++	}
++}
++
++static void hss_config_set_rx_frame(struct port *port)
++{
++	struct msg msg;
++
++	memset(&msg, 0, sizeof(msg));
++	msg.cmd = PORT_CONFIG_WRITE;
++	msg.hss_port = port->id;
++	msg.index = HSS_CONFIG_RX_FCR;
++	msg.data16a = port->frame_sync_offset;
++	msg.data16b = port->frame_size - 1;
++	if (npe_send_message(npe, &msg, "HSS_SET_RX_FCR")) {
++		printk(KERN_CRIT "HSS-%i: unable to set HSS RX frame size"
++		       " and offset\n", port->id);
++		BUG();
++	}
++}
++
++static void hss_config_set_frame(struct port *port)
++{
++	struct msg msg;
++
++	memset(&msg, 0, sizeof(msg));
++	msg.cmd = PORT_CONFIG_WRITE;
++	msg.hss_port = port->id;
++	msg.index = HSS_CONFIG_TX_FCR;
++	msg.data16a = TX_FRAME_SYNC_OFFSET;
++	msg.data16b = port->frame_size - 1;
++	if (npe_send_message(npe, &msg, "HSS_SET_TX_FCR")) {
++		printk(KERN_CRIT "HSS-%i: unable to set HSS TX frame size"
++		       " and offset\n", port->id);
++		BUG();
++	}
++	hss_config_set_rx_frame(port);
++}
++
++static void hss_config_set_lut(struct port *port)
++{
++	struct msg msg;
++	int chan_count = 32;
++
++	memset(&msg, 0, sizeof(msg));
++	msg.cmd = PORT_CONFIG_WRITE;
++	msg.hss_port = port->id;
++
++	msg.index = HSS_CONFIG_TX_LUT;
++	msg.data32 = 0xffffffff;
++	npe_send_message(npe, &msg, "HSS_SET_TX_LUT");
++	msg.index += 4;
++	npe_send_message(npe, &msg, "HSS_SET_TX_LUT");
++	msg.data32 = 0x0;
++	msg.index += 4;
++	npe_send_message(npe, &msg, "HSS_SET_TX_LUT");
++	msg.index += 4;
++	npe_send_message(npe, &msg, "HSS_SET_TX_LUT");
++	msg.index += 4;
++	npe_send_message(npe, &msg, "HSS_SET_TX_LUT");
++	msg.index += 4;
++	npe_send_message(npe, &msg, "HSS_SET_TX_LUT");
++	msg.index += 4;
++	npe_send_message(npe, &msg, "HSS_SET_TX_LUT");
++	msg.index += 4;
++	npe_send_message(npe, &msg, "HSS_SET_TX_LUT");
++
++	msg.index = HSS_CONFIG_RX_LUT;
++	msg.data32 = 0xffffffff;
++	npe_send_message(npe, &msg, "HSS_SET_RX_LUT");
++	msg.index += 4;
++	npe_send_message(npe, &msg, "HSS_SET_RX_LUT");
++	msg.data32 = 0x0;
++	msg.index += 4;
++	npe_send_message(npe, &msg, "HSS_SET_RX_LUT");
++	msg.index += 4;
++	npe_send_message(npe, &msg, "HSS_SET_RX_LUT");
++	msg.index += 4;
++	npe_send_message(npe, &msg, "HSS_SET_RX_LUT");
++	msg.index += 4;
++	npe_send_message(npe, &msg, "HSS_SET_RX_LUT");
++	msg.index += 4;
++	npe_send_message(npe, &msg, "HSS_SET_RX_LUT");
++	msg.index += 4;
++	npe_send_message(npe, &msg, "HSS_SET_RX_LUT");
++
++	hss_config_set_frame(port);
++
++	memset(&msg, 0, sizeof(msg));
++	msg.cmd = CHAN_NUM_CHANS_WRITE;
++	msg.hss_port = port->id;
++	msg.data8a = chan_count;
++	if (npe_send_message(npe, &msg, "CHAN_NUM_CHANS_WRITE")) {
++		printk(KERN_CRIT "HSS-%i: unable to set HSS channel count\n",
++		       port->id);
++		BUG();
++	}
++}
++
++static u32 hss_config_get_status(struct port *port)
++{
++	struct msg msg;
++
++	do {
++		memset(&msg, 0, sizeof(msg));
++		msg.cmd = PORT_ERROR_READ;
++		msg.hss_port = port->id;
++		if (npe_send_message(npe, &msg, "PORT_ERROR_READ"))
++			break;
++		if (npe_recv_message(npe, &msg, "PORT_ERROR_READ"))
++			break;
++
++		return msg.data32;
++	} while (0);
++
++	printk(KERN_CRIT "HSS-%i: unable to read HSS status\n", port->id);
++	BUG();
++}
++
++static void hss_config_start_chan(struct port *port)
++{
++	struct msg msg;
++
++	port->chan_last_tx = 0;
++	port->chan_last_rx = 0;
++
++	do {
++		memset(&msg, 0, sizeof(msg));
++		msg.cmd = CHAN_RX_BUF_ADDR_WRITE;
++		msg.hss_port = port->id;
++		msg.data32 = port->chan_rx_buf_phys;
++		if (npe_send_message(npe, &msg, "CHAN_RX_BUF_ADDR_WRITE"))
++			break;
++
++		memset(&msg, 0, sizeof(msg));
++		msg.cmd = CHAN_TX_BUF_ADDR_WRITE;
++		msg.hss_port = port->id;
++		msg.data32 = port->chan_tx_pointers_phys;
++		if (npe_send_message(npe, &msg, "CHAN_TX_BUF_ADDR_WRITE"))
++			break;
++
++		memset(&msg, 0, sizeof(msg));
++		msg.cmd = CHAN_FLOW_ENABLE;
++		msg.hss_port = port->id;
++		if (npe_send_message(npe, &msg, "CHAN_FLOW_ENABLE"))
++			break;
++		port->chan_started = 1;
++		return;
++	} while (0);
++
++	printk(KERN_CRIT "HSS-%i: unable to start channelized flow\n",
++	       port->id);
++	BUG();
++}
++
++static void hss_config_stop_chan(struct port *port)
++{
++	struct msg msg;
++
++	if (!port->chan_started)
++		return;
++
++	memset(&msg, 0, sizeof(msg));
++	msg.cmd = CHAN_FLOW_DISABLE;
++	msg.hss_port = port->id;
++	if (npe_send_message(npe, &msg, "CHAN_FLOW_DISABLE")) {
++		printk(KERN_CRIT "HSS-%i: unable to stop channelized flow\n",
++		       port->id);
++		BUG();
++	}
++	hss_config_get_status(port); /* make sure it's halted */
++	port->chan_started = 0;
++}
++
++static int hss_config_load_firmware(struct port *port)
++{
++	struct msg msg;
++
++	if (port->initialized)
++		return 0;
++
++	if (!npe_running(npe)) {
++		int err;
++		if ((err = npe_load_firmware(npe, "NPE-A-HSS",
++					     port->dev)))
++			return err;
++	}
++
++	do {
++		/* HSS main configuration */
++		hss_config_set_line(port);
++
++		hss_config_set_frame(port);
++
++		/* Channelized operation settings */
++		memset(&msg, 0, sizeof(msg));
++		msg.cmd = CHAN_TX_BLK_CFG_WRITE;
++		msg.hss_port = port->id;
++		msg.data8b = (CHAN_TX_LIST_FRAMES & ~7) / 2;
++		msg.data8a = msg.data8b / 4;
++		msg.data8d = CHAN_TX_LIST_FRAMES - msg.data8b;
++		msg.data8c = msg.data8d / 4;
++		if (npe_send_message(npe, &msg, "CHAN_TX_BLK_CFG_WRITE"))
++			break;
++
++		memset(&msg, 0, sizeof(msg));
++		msg.cmd = CHAN_RX_BUF_CFG_WRITE;
++		msg.hss_port = port->id;
++		msg.data8a = CHAN_RX_TRIGGER / 8;
++		msg.data8b = CHAN_RX_FRAMES;
++		if (npe_send_message(npe, &msg, "CHAN_RX_BUF_CFG_WRITE"))
++			break;
++
++		memset(&msg, 0, sizeof(msg));
++		msg.cmd = CHAN_TX_BUF_SIZE_WRITE;
++		msg.hss_port = port->id;
++		msg.data8a = CHAN_TX_LISTS;
++		if (npe_send_message(npe, &msg, "CHAN_TX_BUF_SIZE_WRITE"))
++			break;
++
++		port->initialized = 1;
++		return 0;
++	} while (0);
++
++	printk(KERN_CRIT "HSS-%i: unable to start HSS operation\n", port->id);
++	BUG();
++}
++
++void hss_chan_irq(void *pdev)
++{
++	struct port *port = pdev;
++
++	qmgr_disable_irq(queue_ids[port->id].chan);
++
++	tasklet_hi_schedule(&port->task);
++}
++
++
++int hss_prepare_chan(struct port *port)
++{
++	int err, i, j;
++	u32 *temp;
++	u32 temp2;
++	u8 *temp3;
++
++	if (port->initialized)
++		return 0;
++
++	if ((err = hss_config_load_firmware(port)))
++		return err;
++
++	if ((err = qmgr_request_queue(queue_ids[port->id].chan,
++				      CHAN_QUEUE_LEN, 0, 0, "%s:hss", "hss")))
++		return err;
++
++	port->chan_tx_buf = dma_alloc_coherent(port->dev, chan_tx_buf_len(port), &port->chan_tx_buf_phys, GFP_DMA);
++	memset(port->chan_tx_buf, 0, chan_tx_buf_len(port));
++
++	port->chan_tx_pointers = dma_alloc_coherent(port->dev, chan_tx_buf_len(port) / CHAN_TX_LIST_FRAMES * 4, &port->chan_tx_pointers_phys, GFP_DMA);
++
++	temp3 = port->chan_tx_buf;
++	for (i = 0; i < CHAN_TX_LISTS; i++) {
++		for (j = 0; j < 8; j++) {
++			port->tx_lists[i][j] = temp3;
++			temp3 += CHAN_TX_LIST_FRAMES * 4;
++		}
++	}
++
++	temp = port->chan_tx_pointers;
++	temp2 = port->chan_tx_buf_phys;
++	for (i = 0; i < CHAN_TX_LISTS; i++)
++	{
++		for (j = 0; j < 32; j++)
++		{
++			*temp = temp2;
++			temp2 += CHAN_TX_LIST_FRAMES;
++			temp++;
++		}
++	}
++
++	port->chan_rx_buf = dma_alloc_coherent(port->dev, chan_rx_buf_len(port), &port->chan_rx_buf_phys, GFP_DMA);
++
++	for (i = 0; i < 8; i++) {
++		temp3 = port->chan_rx_buf + (i * 4 * 128);
++		for (j = 0; j < 8; j++) {
++			port->rx_frames[i][j] = temp3;
++			temp3 += CHAN_RX_TRIGGER;
++		}
++	}
++
++	qmgr_set_irq(queue_ids[port->id].chan, QUEUE_IRQ_SRC_NOT_EMPTY,
++		     hss_chan_irq, port);
++
++	return 0;
++
++}
++
++int hss_tx_start(struct hss_device *hdev)
++{
++	unsigned long flags;
++	struct port *port = hdev->port;
++
++	hdev->tx_loc = 0;
++	hdev->tx_frame = 0;
++
++	set_bit((1 << hdev->id), &port->chan_tx_bitmap);
++
++	if (!port->chan_started)
++	{
++		qmgr_enable_irq(queue_ids[port->id].chan);
++		spin_lock_irqsave(&npe_lock, flags);
++		hss_config_start_chan(port);
++		spin_unlock_irqrestore(&npe_lock, flags);
++		hss_chan_irq(port);
++	}
++
++	return 0;
++}
++EXPORT_SYMBOL(hss_tx_start);
++
++int hss_rx_start(struct hss_device *hdev)
++{
++	unsigned long flags;
++	struct port *port = hdev->port;
++
++	hdev->rx_loc = 0;
++	hdev->rx_frame = 0;
++
++	set_bit((1 << hdev->id), &port->chan_rx_bitmap);
++
++	if (!port->chan_started)
++	{
++		qmgr_enable_irq(queue_ids[port->id].chan);
++		spin_lock_irqsave(&npe_lock, flags);
++		hss_config_start_chan(port);
++		spin_unlock_irqrestore(&npe_lock, flags);
++		hss_chan_irq(port);
++	}
++
++	return 0;
++}
++EXPORT_SYMBOL(hss_rx_start);
++
++int hss_tx_stop(struct hss_device *hdev)
++{
++	struct port *port = hdev->port;
++
++	clear_bit((1 << hdev->id), &port->chan_tx_bitmap);
++
++	return 0;
++}
++EXPORT_SYMBOL(hss_tx_stop);
++
++int hss_rx_stop(struct hss_device *hdev)
++{
++	struct port *port = hdev->port;
++
++	clear_bit((1 << hdev->id), &port->chan_rx_bitmap);
++
++	return 0;
++}
++EXPORT_SYMBOL(hss_rx_stop);
++
++int hss_chan_open(struct hss_device *hdev)
++{
++	struct port *port = hdev->port;
++	int i, err = 0;
++
++	if (port->chan_open)
++		return 0;
++
++	if (port->mode == MODE_HDLC) {
++		err = -ENOSYS;
++		goto out;
++	}
++
++	if (port->mode == MODE_G704 && port->channels[0] == hdev->id) {
++		err = -EBUSY; /* channel #0 is used for G.704 signaling */
++		goto out;
++	}
++
++	for (i = MAX_CHANNELS; i > port->frame_size / 8; i--)
++		if (port->channels[i - 1] == hdev->id) {
++			err = -ECHRNG; /* frame too short */
++			goto out;
++		}
++
++	hdev->rx_loc = hdev->tx_loc = 0;
++	hdev->rx_frame = hdev->tx_frame = 0;
++
++	//clear_bit((1 << hdev->id), &port->chan_rx_bitmap);
++	//clear_bit((1 << hdev->id), &port->chan_tx_bitmap);
++
++	if (!port->initialized) {
++		hss_prepare_chan(port);
++
++		hss_config_stop_chan(port);
++		hdev->open_count++;
++		port->chan_open_count++;
++
++		hss_config_set_lut(port);
++		hss_config_load(port);
++
++	}
++	port->chan_open = 1;
++
++out:
++	return err;
++}
++EXPORT_SYMBOL(hss_chan_open);
++
++int hss_chan_close(struct hss_device *hdev)
++{
++	return 0;
++}
++EXPORT_SYMBOL(hss_chan_close);
++
++void hss_chan_read(unsigned long data)
++{
++	struct port *port = (void *)data;
++	struct hss_device *hdev;
++	u8 *hw_buf, *save_buf;
++	u8 *buf;
++	u32 v;
++  unsigned int tx_list, rx_frame;
++	int i, j, channel;
++	u8 more_work = 0;
++
++/*
++	My Data in the hardware buffer is scattered by channels into 4 trunks
++	as follows for rx
++
++					channel 0					channel 1					channel 2					channel 3
++Trunk 1	=	0			-> 	127			128		->	255			256		->	383			384		->	512
++Trunk 2 =	513		->	639			640		->	768			769		->	895			896		->	1023
++Trunk 3 =	1024	->	1151		1152	->	1207		1208	->	1407		1408	->	1535
++Trunk 4 = 1535	->	1663		1664	->	1791		1792	->	1920		1921	->	2047
++
++	I will get CHAN_RX_TRIGGER worth of bytes out of each channel on each trunk
++	with each IRQ
++
++	For TX Data, it is split into 8 lists with each list containing 16 bytes per
++	channel
++
++Trunk 1 = 0		->	16				17		->	32			33		->	48			49		->	64
++Trunk 2 = 65	->	80				81		->	96			97		->	112			113		->	128
++Trunk	3	=	129	->	144				145		->	160			161		->	176			177		->	192
++Trunk	4	=	193	->	208				209		->	224			225		->	240			241		->	256
++
++*/
++
++
++	while ((v = qmgr_get_entry(queue_ids[port->id].chan)))
++	{
++		tx_list = (v >> 8) & 0xFF;
++		rx_frame = v & 0xFF;
++
++		if (tx_list == 7)
++			tx_list = 0;
++		else
++			tx_list++;
++		for (channel = 0; channel < 8; channel++) {
++
++			hdev = port->chan_devices[channel];
++			if (!hdev)
++				continue;
++
++			if (test_bit(1 << channel, &port->chan_tx_bitmap)) {
++				buf = (u8 *)hdev->tx_buf + hdev->tx_loc;
++#if 0
++				hw_buf = (u8 *)port->chan_tx_buf;
++				hw_buf += (tx_list * CHAN_TX_LIST_FRAMES * 32);
++				hw_buf += (4 * CHAN_TX_LIST_FRAMES * channel);
++				save_buf = hw_buf;
++#else
++				save_buf = port->tx_lists[tx_list][channel];
++#endif
++				for (i = 0; i < CHAN_TX_LIST_FRAMES; i++) {
++					hw_buf = save_buf + i;
++					for (j = 0; j < 4; j++) {
++						*hw_buf = *(buf++);
++						hw_buf += CHAN_TX_LIST_FRAMES;
++					}
++
++					hdev->tx_loc += 4;
++					hdev->tx_frame++;
++					if (hdev->tx_loc >= hdev->tx_buffer_size) {
++						hdev->tx_loc = 0;
++						buf = (u8 *)hdev->tx_buf;
++					}
++				}
++			} else {
++#if 0
++				hw_buf = (u8 *)port->chan_tx_buf;
++				hw_buf += (tx_list * CHAN_TX_LIST_FRAMES * 32);
++				hw_buf += (4 * CHAN_TX_LIST_FRAMES * channel);
++#else
++				hw_buf = port->tx_lists[tx_list][channel];
++#endif
++				memset(hw_buf, 0, 64);
++			}
++
++			if (hdev->tx_frame >= hdev->tx_period_size && test_bit(1 << channel, &port->chan_tx_bitmap))
++			{
++				hdev->tx_frame %= hdev->tx_period_size;
++				if (hdev->tx_callback)
++					hdev->tx_callback(hdev->tx_data);
++				more_work = 1;
++			}
++
++			if (test_bit(1 << channel, &port->chan_rx_bitmap)) {
++				buf = (u8 *)hdev->rx_buf + hdev->rx_loc;
++#if 0
++				hw_buf = (u8 *)port->chan_rx_buf;
++				hw_buf += (4 * CHAN_RX_FRAMES * channel);
++				hw_buf += rx_frame;
++				save_buf = hw_buf;
++#else
++				save_buf = port->rx_frames[channel][rx_frame >> 4];
++#endif
++				for (i = 0; i < CHAN_RX_TRIGGER; i++) {
++					hw_buf = save_buf + i;
++					for (j = 0; j < 4; j++) {
++						*(buf++) = *hw_buf;
++						hw_buf += CHAN_RX_FRAMES;
++					}
++					hdev->rx_loc += 4;
++					hdev->rx_frame++;
++					if (hdev->rx_loc >= hdev->rx_buffer_size) {
++						hdev->rx_loc = 0;
++						buf = (u8 *)hdev->rx_buf;
++					}
++				}
++			}
++
++			if (hdev->rx_frame >= hdev->rx_period_size && test_bit(1 << channel, &port->chan_rx_bitmap))
++			{
++				hdev->rx_frame %= hdev->rx_period_size;
++				if (hdev->rx_callback)
++					hdev->rx_callback(hdev->rx_data);
++				more_work = 1;
++			}
++		}
++#if 0
++		if (more_work)
++		{
++			tasklet_hi_schedule(&port->task);
++			return;
++		}
++#endif
++	}
++
++	qmgr_enable_irq(queue_ids[port->id].chan);
++
++	return;
++
++}
++
++struct hss_device *hss_chan_create(struct port *port, unsigned int channel)
++{
++	struct hss_device *chan_dev;
++	unsigned long flags;
++
++	chan_dev = kzalloc(sizeof(struct hss_device), GFP_KERNEL);
++
++	spin_lock_irqsave(&npe_lock, flags);
++
++	chan_dev->id = channel;
++	chan_dev->port = port;
++
++	port->channels[channel] = channel;
++
++	port->chan_devices[channel] = chan_dev;
++
++	spin_unlock_irqrestore(&npe_lock, flags);
++
++	return chan_dev;
++}
++
++/*****************************************************************************
++ * initialization
++ ****************************************************************************/
++
++static struct platform_device gw_avila_hss_device_0 = {
++  .name     = "ixp4xx_hss",
++  .id       = 0,
++};
++
++static struct platform_device gw_avila_hss_device_1 = {
++  .name     = "ixp4xx_hss",
++  .id       = 1,
++};
++
++static struct platform_device *gw_avila_hss_port_0;
++static struct platform_device *gw_avila_hss_port_1;
++static u64 hss_dmamask = 0xFFFFFFFF;
++
++struct hss_device *hss_init(int id, int channel)
++{
++	struct port *port = hss_port[id];
++	struct hss_device *hdev;
++	int ret;
++
++	if (!lock_init)
++	{
++		spin_lock_init(&npe_lock);
++		lock_init = 1;
++		npe = npe_request(0);
++	}
++
++	if (!port->init) {
++		if (id == 0) {
++			gw_avila_hss_port_0 = platform_device_alloc("hss-port", 0);
++
++			platform_set_drvdata(gw_avila_hss_port_0, &gw_avila_hss_device_0);
++			port->dev = &gw_avila_hss_port_0->dev;
++
++			if (!port->dev->dma_mask)
++		    port->dev->dma_mask = &hss_dmamask;
++		  if (!port->dev->coherent_dma_mask)
++	    	port->dev->coherent_dma_mask = 0xFFFFFFFF;
++
++			ret = platform_device_add(gw_avila_hss_port_0);
++
++		  if (ret)
++	  	  platform_device_put(gw_avila_hss_port_0);
++
++			tasklet_init(&port->task, hss_chan_read, (unsigned long) port);
++		}
++		else
++		{
++			gw_avila_hss_port_1 = platform_device_alloc("hss-port", 1);
++
++			platform_set_drvdata(gw_avila_hss_port_1, &gw_avila_hss_device_1);
++			port->dev = &gw_avila_hss_port_1->dev;
++
++			if (!port->dev->dma_mask)
++		    port->dev->dma_mask = &hss_dmamask;
++		  if (!port->dev->coherent_dma_mask)
++	    	port->dev->coherent_dma_mask = 0xFFFFFFFF;
++
++			ret = platform_device_add(gw_avila_hss_port_1);
++
++		  if (ret)
++	  	  platform_device_put(gw_avila_hss_port_1);
++
++			tasklet_init(&port->task, hss_chan_read, (unsigned long) port);
++		}
++
++		port->init = 1;
++		port->id = id;
++		port->clock_type = CLOCK_EXT;
++		port->clock_rate = 8192000;
++		port->frame_size = 256; /* E1 */
++		port->mode = MODE_RAW;
++		port->next_rx_frame = 0;
++		memset(port->channels, CHANNEL_UNUSED, sizeof(port->channels));
++	}
++
++	hdev = hss_chan_create(port, channel);
++
++	return hdev;
++}
++EXPORT_SYMBOL(hss_init);
++
++int hss_set_tx_callback(struct hss_device *hdev, void (*tx_callback)(void *), void *tx_data)
++{
++  BUG_ON(tx_callback == NULL);
++  hdev->tx_callback = tx_callback;
++  hdev->tx_data = tx_data;
++
++  return 0;
++}
++EXPORT_SYMBOL(hss_set_tx_callback);
++
++int hss_set_rx_callback(struct hss_device *hdev, void (*rx_callback)(void *), void *rx_data)
++{
++  BUG_ON(rx_callback == NULL);
++  hdev->rx_callback = rx_callback;
++  hdev->rx_data = rx_data;
++
++  return 0;
++}
++EXPORT_SYMBOL(hss_set_rx_callback);
++
++int hss_config_rx_dma(struct hss_device *hdev, void *buf, size_t buffer_size, size_t period_size)
++{
++	/*
++	 * Period Size and Buffer Size are in Frames which are u32
++	 * We convert the u32 *buf to u8 in order to make channel reads
++	 * and rx_loc easier
++	 */
++
++	hdev->rx_buf = (u8 *)buf;
++	hdev->rx_buffer_size = buffer_size << 2;
++	hdev->rx_period_size = period_size;
++
++	return 0;
++}
++EXPORT_SYMBOL(hss_config_rx_dma);
++
++int hss_config_tx_dma(struct hss_device *hdev, void *buf, size_t buffer_size, size_t period_size)
++{
++	/*
++	 * Period Size and Buffer Size are in Frames which are u32
++	 * We convert the u32 *buf to u8 in order to make channel reads
++	 * and rx_loc easier
++	 */
++
++	hdev->tx_buf = (u8 *)buf;
++	hdev->tx_buffer_size = buffer_size << 2;
++	hdev->tx_period_size = period_size;
++
++	return 0;
++}
++EXPORT_SYMBOL(hss_config_tx_dma);
++
++unsigned long hss_curr_offset_rx(struct hss_device *hdev)
++{
++	return hdev->rx_loc >> 2;
++}
++EXPORT_SYMBOL(hss_curr_offset_rx);
++
++unsigned long hss_curr_offset_tx(struct hss_device *hdev)
++{
++	return hdev->tx_loc >> 2;
++}
++EXPORT_SYMBOL(hss_curr_offset_tx);
++
++MODULE_AUTHOR("Chris Lang");
++MODULE_DESCRIPTION("Intel IXP4xx HSS Audio driver");
++MODULE_LICENSE("GPL v2");
+--- /dev/null
++++ b/sound/soc/gw-avila/ixp4xx_hss.h
+@@ -0,0 +1,401 @@
++/*
++ *
++ *
++ * Copyright (C) 2009 Gateworks Corporation
++ *
++ * This program is free software; you can redistribute it and/or modify it
++ * under the terms of version 2 of the GNU General Public License
++ * as published by the Free Software Foundation.
++ */
++
++#include <linux/types.h>
++#include <linux/bitops.h>
++#include <linux/dma-mapping.h>
++#include <linux/dmapool.h>
++#include <linux/fs.h>
++#include <linux/io.h>
++#include <linux/kernel.h>
++#include <linux/platform_device.h>
++#include <linux/poll.h>
++#include <mach/npe.h>
++#include <mach/qmgr.h>
++#include <linux/interrupt.h>
++
++//#include <linux/hdlc.h> XXX We aren't HDLC
++
++#define DEBUG_QUEUES		0
++#define DEBUG_DESC		0
++#define DEBUG_RX		0
++#define DEBUG_TX		0
++#define DEBUG_PKT_BYTES		0
++#define DEBUG_CLOSE		0
++#define DEBUG_FRAMER		0
++
++#define DRV_NAME		"ixp4xx_hss"
++
++#define PKT_EXTRA_FLAGS		0 /* orig 1 */
++#define TX_FRAME_SYNC_OFFSET	0 /* channelized */
++#define PKT_NUM_PIPES		1 /* 1, 2 or 4 */
++#define PKT_PIPE_FIFO_SIZEW	4 /* total 4 dwords per HSS */
++
++#define RX_DESCS		512 /* also length of all RX queues */
++#define TX_DESCS		512 /* also length of all TX queues */
++
++//#define POOL_ALLOC_SIZE		(sizeof(struct desc) * (RX_DESCS + TX_DESCS))
++#define RX_SIZE			(HDLC_MAX_MRU + 4) /* NPE needs more space */
++#define MAX_CLOSE_WAIT		1000 /* microseconds */
++#define HSS_COUNT		2
++#define MIN_FRAME_SIZE		16   /* bits */
++#define MAX_FRAME_SIZE		257  /* 256 bits + framing bit */
++#define MAX_CHANNELS		(MAX_FRAME_SIZE / 8)
++#define MAX_CHAN_DEVICES	32
++#define CHANNEL_HDLC		0xFE
++#define CHANNEL_UNUSED		0xFF
++
++#define NAPI_WEIGHT		16
++#define CHAN_RX_TRIGGER		16 /* 8 RX frames = 1 ms @ E1 */
++#define CHAN_RX_FRAMES		128
++#define CHAN_RX_TRUNKS		1
++#define MAX_CHAN_RX_BAD_SYNC	(CHAN_RX_TRIGGER / 2 /* pairs */ - 3)
++
++#define CHAN_TX_LIST_FRAMES	CHAN_RX_TRIGGER /* bytes/channel per list, 16 - 48 */
++#define CHAN_TX_LISTS		8
++#define CHAN_TX_TRUNKS CHAN_RX_TRUNKS
++#define CHAN_TX_FRAMES		(CHAN_TX_LIST_FRAMES * CHAN_TX_LISTS)
++
++#define CHAN_QUEUE_LEN		32 /* minimum possible */
++
++#define chan_rx_buf_len(port)	(port->frame_size / 8 * CHAN_RX_FRAMES * CHAN_RX_TRUNKS)
++#define chan_tx_buf_len(port) (port->frame_size / 8 * CHAN_TX_FRAMES * CHAN_TX_TRUNKS)
++
++/* Queue IDs */
++#define HSS0_CHL_RXTRIG_QUEUE	12	/* orig size = 32 dwords */
++#define HSS0_PKT_RX_QUEUE	13	/* orig size = 32 dwords */
++#define HSS0_PKT_TX0_QUEUE	14	/* orig size = 16 dwords */
++#define HSS0_PKT_TX1_QUEUE	15
++#define HSS0_PKT_TX2_QUEUE	16
++#define HSS0_PKT_TX3_QUEUE	17
++#define HSS0_PKT_RXFREE0_QUEUE	18	/* orig size = 16 dwords */
++#define HSS0_PKT_RXFREE1_QUEUE	19
++#define HSS0_PKT_RXFREE2_QUEUE	20
++#define HSS0_PKT_RXFREE3_QUEUE	21
++#define HSS0_PKT_TXDONE_QUEUE	22	/* orig size = 64 dwords */
++
++#define HSS1_CHL_RXTRIG_QUEUE	10
++#define HSS1_PKT_RX_QUEUE	0
++#define HSS1_PKT_TX0_QUEUE	5
++#define HSS1_PKT_TX1_QUEUE	6
++#define HSS1_PKT_TX2_QUEUE	7
++#define HSS1_PKT_TX3_QUEUE	8
++#define HSS1_PKT_RXFREE0_QUEUE	1
++#define HSS1_PKT_RXFREE1_QUEUE	2
++#define HSS1_PKT_RXFREE2_QUEUE	3
++#define HSS1_PKT_RXFREE3_QUEUE	4
++#define HSS1_PKT_TXDONE_QUEUE	9
++
++#define NPE_PKT_MODE_HDLC		0
++#define NPE_PKT_MODE_RAW		1
++#define NPE_PKT_MODE_56KMODE		2
++#define NPE_PKT_MODE_56KENDIAN_MSB	4
++
++/* PKT_PIPE_HDLC_CFG_WRITE flags */
++#define PKT_HDLC_IDLE_ONES		0x1 /* default = flags */
++#define PKT_HDLC_CRC_32			0x2 /* default = CRC-16 */
++#define PKT_HDLC_MSB_ENDIAN		0x4 /* default = LE */
++
++
++/* hss_config, PCRs */
++/* Frame sync sampling, default = active low */
++#define PCR_FRM_SYNC_ACTIVE_HIGH	0x40000000
++#define PCR_FRM_SYNC_FALLINGEDGE	0x80000000
++#define PCR_FRM_SYNC_RISINGEDGE		0xC0000000
++
++/* Frame sync pin: input (default) or output generated off a given clk edge */
++#define PCR_FRM_SYNC_OUTPUT_FALLING	0x20000000
++#define PCR_FRM_SYNC_OUTPUT_RISING	0x30000000
++
++/* Frame and data clock sampling on edge, default = falling */
++#define PCR_FCLK_EDGE_RISING		0x08000000
++#define PCR_DCLK_EDGE_RISING		0x04000000
++
++/* Clock direction, default = input */
++#define PCR_SYNC_CLK_DIR_OUTPUT		0x02000000
++
++/* Generate/Receive frame pulses, default = enabled */
++#define PCR_FRM_PULSE_DISABLED		0x01000000
++
++ /* Data rate is full (default) or half the configured clk speed */
++#define PCR_HALF_CLK_RATE		0x00200000
++
++/* Invert data between NPE and HSS FIFOs? (default = no) */
++#define PCR_DATA_POLARITY_INVERT	0x00100000
++
++/* TX/RX endianness, default = LSB */
++#define PCR_MSB_ENDIAN			0x00080000
++
++/* Normal (default) / open drain mode (TX only) */
++#define PCR_TX_PINS_OPEN_DRAIN		0x00040000
++
++/* No framing bit transmitted and expected on RX? (default = framing bit) */
++#define PCR_SOF_NO_FBIT			0x00020000
++
++/* Drive data pins? */
++#define PCR_TX_DATA_ENABLE		0x00010000
++
++/* Voice 56k type: drive the data pins low (default), high, high Z */
++#define PCR_TX_V56K_HIGH		0x00002000
++#define PCR_TX_V56K_HIGH_IMP		0x00004000
++
++/* Unassigned type: drive the data pins low (default), high, high Z */
++#define PCR_TX_UNASS_HIGH		0x00000800
++#define PCR_TX_UNASS_HIGH_IMP		0x00001000
++
++/* T1 @ 1.544MHz only: Fbit dictated in FIFO (default) or high Z */
++#define PCR_TX_FB_HIGH_IMP		0x00000400
++
++/* 56k data endiannes - which bit unused: high (default) or low */
++#define PCR_TX_56KE_BIT_0_UNUSED	0x00000200
++
++/* 56k data transmission type: 32/8 bit data (default) or 56K data */
++#define PCR_TX_56KS_56K_DATA		0x00000100
++
++/* hss_config, cCR */
++/* Number of packetized clients, default = 1 */
++#define CCR_NPE_HFIFO_2_HDLC		0x04000000
++#define CCR_NPE_HFIFO_3_OR_4HDLC	0x08000000
++
++/* default = no loopback */
++#define CCR_LOOPBACK			0x02000000
++
++/* HSS number, default = 0 (first) */
++#define CCR_SECOND_HSS			0x01000000
++
++
++/* hss_config, clkCR: main:10, num:10, denom:12 */
++#define CLK42X_SPEED_EXP	((0x3FF << 22) | (  2 << 12) |   15) /*65 KHz*/
++
++#define CLK42X_SPEED_512KHZ	((  130 << 22) | (  2 << 12) |   15)
++#define CLK42X_SPEED_1536KHZ	((   43 << 22) | ( 18 << 12) |   47)
++#define CLK42X_SPEED_1544KHZ	((   43 << 22) | ( 33 << 12) |  192)
++#define CLK42X_SPEED_2048KHZ	((   32 << 22) | ( 34 << 12) |   63)
++#define CLK42X_SPEED_4096KHZ	((   16 << 22) | ( 34 << 12) |  127)
++#define CLK42X_SPEED_8192KHZ	((    8 << 22) | ( 34 << 12) |  255)
++
++#define CLK46X_SPEED_512KHZ	((  130 << 22) | ( 24 << 12) |  127)
++#define CLK46X_SPEED_1536KHZ	((   43 << 22) | (152 << 12) |  383)
++#define CLK46X_SPEED_1544KHZ	((   43 << 22) | ( 66 << 12) |  385)
++#define CLK46X_SPEED_2048KHZ	((   32 << 22) | (280 << 12) |  511)
++#define CLK46X_SPEED_4096KHZ	((   16 << 22) | (280 << 12) | 1023)
++#define CLK46X_SPEED_8192KHZ	((    8 << 22) | (280 << 12) | 2047)
++
++
++/* hss_config, LUT entries */
++#define TDMMAP_UNASSIGNED	0
++#define TDMMAP_HDLC		1	/* HDLC - packetized */
++#define TDMMAP_VOICE56K		2	/* Voice56K - 7-bit channelized */
++#define TDMMAP_VOICE64K		3	/* Voice64K - 8-bit channelized */
++
++/* offsets into HSS config */
++#define HSS_CONFIG_TX_PCR	0x00 /* port configuration registers */
++#define HSS_CONFIG_RX_PCR	0x04
++#define HSS_CONFIG_CORE_CR	0x08 /* loopback control, HSS# */
++#define HSS_CONFIG_CLOCK_CR	0x0C /* clock generator control */
++#define HSS_CONFIG_TX_FCR	0x10 /* frame configuration registers */
++#define HSS_CONFIG_RX_FCR	0x14
++#define HSS_CONFIG_TX_LUT	0x18 /* channel look-up tables */
++#define HSS_CONFIG_RX_LUT	0x38
++
++
++/* NPE command codes */
++/* writes the ConfigWord value to the location specified by offset */
++#define PORT_CONFIG_WRITE		0x40
++
++/* triggers the NPE to load the contents of the configuration table */
++#define PORT_CONFIG_LOAD		0x41
++
++/* triggers the NPE to return an HssErrorReadResponse message */
++#define PORT_ERROR_READ			0x42
++
++/* reset NPE internal status and enable the HssChannelized operation */
++#define CHAN_FLOW_ENABLE		0x43
++#define CHAN_FLOW_DISABLE		0x44
++#define CHAN_IDLE_PATTERN_WRITE		0x45
++#define CHAN_NUM_CHANS_WRITE		0x46
++#define CHAN_RX_BUF_ADDR_WRITE		0x47
++#define CHAN_RX_BUF_CFG_WRITE		0x48
++#define CHAN_TX_BLK_CFG_WRITE		0x49
++#define CHAN_TX_BUF_ADDR_WRITE		0x4A
++#define CHAN_TX_BUF_SIZE_WRITE		0x4B
++#define CHAN_TSLOTSWITCH_ENABLE		0x4C
++#define CHAN_TSLOTSWITCH_DISABLE	0x4D
++
++/* downloads the gainWord value for a timeslot switching channel associated
++   with bypassNum */
++#define CHAN_TSLOTSWITCH_GCT_DOWNLOAD	0x4E
++
++/* triggers the NPE to reset internal status and enable the HssPacketized
++   operation for the flow specified by pPipe */
++#define PKT_PIPE_FLOW_ENABLE		0x50
++#define PKT_PIPE_FLOW_DISABLE		0x51
++#define PKT_NUM_PIPES_WRITE		0x52
++#define PKT_PIPE_FIFO_SIZEW_WRITE	0x53
++#define PKT_PIPE_HDLC_CFG_WRITE		0x54
++#define PKT_PIPE_IDLE_PATTERN_WRITE	0x55
++#define PKT_PIPE_RX_SIZE_WRITE		0x56
++#define PKT_PIPE_MODE_WRITE		0x57
++
++/* HDLC packet status values - desc->status */
++#define ERR_SHUTDOWN		1 /* stop or shutdown occurrance */
++#define ERR_HDLC_ALIGN		2 /* HDLC alignment error */
++#define ERR_HDLC_FCS		3 /* HDLC Frame Check Sum error */
++#define ERR_RXFREE_Q_EMPTY	4 /* RX-free queue became empty while receiving
++				     this packet (if buf_len < pkt_len) */
++#define ERR_HDLC_TOO_LONG	5 /* HDLC frame size too long */
++#define ERR_HDLC_ABORT		6 /* abort sequence received */
++#define ERR_DISCONNECTING	7 /* disconnect is in progress */
++
++#define CLOCK_EXT 0
++#define CLOCK_INT 1
++
++enum mode {MODE_HDLC = 0, MODE_RAW, MODE_G704};
++enum rx_tx_bit {
++	TX_BIT = 0,
++	RX_BIT = 1
++};
++enum chan_bit {
++	CHAN_0 = (1 << 0),
++	CHAN_1 = (1 << 1),
++	CHAN_2 = (1 << 2),
++	CHAN_3 = (1 << 3),
++	CHAN_4 = (1 << 4),
++	CHAN_5 = (1 << 5),
++	CHAN_6 = (1 << 6),
++	CHAN_7 = (1 << 7),
++	CHAN_8 = (1 << 8),
++	CHAN_9 = (1 << 9),
++	CHAN_10 = (1 << 10),
++	CHAN_11 = (1 << 11),
++	CHAN_12 = (1 << 12),
++	CHAN_13 = (1 << 13),
++	CHAN_14 = (1 << 14),
++	CHAN_15 = (1 << 15)
++};
++
++enum alignment { NOT_ALIGNED = 0, EVEN_FIRST, ODD_FIRST };
++
++#ifdef __ARMEB__
++typedef struct sk_buff buffer_t;
++#define free_buffer dev_kfree_skb
++#define free_buffer_irq dev_kfree_skb_irq
++#else
++typedef void buffer_t;
++#define free_buffer kfree
++#define free_buffer_irq kfree
++#endif
++
++struct hss_device {
++	struct port *port;
++	unsigned int open_count, excl_open;
++	unsigned long tx_loc, rx_loc; /* bytes */
++	unsigned long tx_frame, rx_frame; /* Frames */
++	u8 id, chan_count;
++	u8 log_channels[MAX_CHANNELS];
++
++  u8 *rx_buf;
++  u8 *tx_buf;
++
++	size_t rx_buffer_size;
++	size_t rx_period_size;
++	size_t tx_buffer_size;
++	size_t tx_period_size;
++
++  void (*rx_callback)(void *data);
++  void *rx_data;
++  void (*tx_callback)(void *data);
++  void *tx_data;
++  void *private_data;
++};
++
++extern struct hss_device *hss_handle[32];
++extern struct port *hss_port[2];
++
++struct port {
++	unsigned char init;
++
++	struct device *dev;
++
++	struct tasklet_struct task;
++	unsigned int id;
++	unsigned long chan_rx_bitmap;
++	unsigned long chan_tx_bitmap;
++	unsigned char chan_open;
++
++	/* the following fields must be protected by npe_lock */
++	enum mode mode;
++	unsigned int clock_type, clock_rate, loopback;
++	unsigned int frame_size, frame_sync_offset;
++	unsigned int next_rx_frame;
++
++	struct hss_device *chan_devices[MAX_CHAN_DEVICES];
++	u32 chan_tx_buf_phys, chan_rx_buf_phys;
++	u32	chan_tx_pointers_phys;
++	u32 *chan_tx_pointers;
++	u8 *chan_rx_buf;
++	u8 *chan_tx_buf;
++	u8 *tx_lists[CHAN_TX_LISTS][8];
++	u8 *rx_frames[8][CHAN_TX_LISTS];
++	unsigned int chan_open_count, hdlc_open;
++	unsigned int chan_started, initialized, just_set_offset;
++	unsigned int chan_last_rx, chan_last_tx;
++
++	/* assigned channels, may be invalid with given frame length or mode */
++	u8 channels[MAX_CHANNELS];
++	int msg_count;
++};
++
++/* NPE message structure */
++struct msg {
++#ifdef __ARMEB__
++	u8 cmd, unused, hss_port, index;
++	union {
++		struct { u8 data8a, data8b, data8c, data8d; };
++		struct { u16 data16a, data16b; };
++		struct { u32 data32; };
++	};
++#else
++	u8 index, hss_port, unused, cmd;
++	union {
++		struct { u8 data8d, data8c, data8b, data8a; };
++		struct { u16 data16b, data16a; };
++		struct { u32 data32; };
++	};
++#endif
++};
++
++#define rx_desc_phys(port, n)	((port)->desc_tab_phys +		\
++				 (n) * sizeof(struct desc))
++#define rx_desc_ptr(port, n)	(&(port)->desc_tab[n])
++
++#define tx_desc_phys(port, n)	((port)->desc_tab_phys +		\
++				 ((n) + RX_DESCS) * sizeof(struct desc))
++#define tx_desc_ptr(port, n)	(&(port)->desc_tab[(n) + RX_DESCS])
++
++int hss_prepare_chan(struct port *port);
++void hss_chan_stop(struct port *port);
++
++struct hss_device *hss_init(int id, int channel);
++int hss_chan_open(struct hss_device *hdev);
++int hss_chan_close(struct hss_device *hdev);
++
++int hss_set_tx_callback(struct hss_device *hdev, void (*tx_callback)(void *), void *tx_data);
++int hss_set_rx_callback(struct hss_device *hdev, void (*rx_callback)(void *), void *rx_data);
++int hss_tx_start(struct hss_device *hdev);
++int hss_tx_stop(struct hss_device *hdev);
++int hss_rx_start(struct hss_device *hdev);
++int hss_rx_stop(struct hss_device *hdev);
++
++int hss_config_rx_dma(struct hss_device *hdev, void *buf, size_t buffer_size, size_t period_size);
++int hss_config_tx_dma(struct hss_device *hdev, void *buf, size_t buffer_size, size_t period_size);
++unsigned long hss_curr_offset_rx(struct hss_device *hdev);
++unsigned long hss_curr_offset_tx(struct hss_device *hdev);
++
+--- a/arch/arm/mach-ixp4xx/avila-setup.c
++++ b/arch/arm/mach-ixp4xx/avila-setup.c
+@@ -333,6 +333,54 @@ static struct platform_device avila_gpio
+ 	.id     = -1,
+ };
+ 
++/*
++ * Audio Devices
++ */
++
++static struct platform_device avila_hss_device[] = {
++	{
++		.name = "gw_avila_hss",
++		.id = 0,
++	},{
++		.name = "gw_avila_hss",
++		.id = 1,
++	},{
++		.name = "gw_avila_hss",
++		.id = 2,
++	},{
++		.name = "gw_avila_hss",
++		.id = 3,
++	},
++};
++
++static struct platform_device avila_pcm_device[] = {
++	{
++		.name = "gw_avila-audio",
++		.id = 0,
++	},{
++		.name = "gw_avila-audio",
++		.id = 1,
++	},{
++		.name = "gw_avila-audio",
++		.id = 2,
++	},{
++		.name = "gw_avila-audio",
++		.id = 3,
++	}
++};
++
++static void setup_audio_devices(void) {
++	platform_device_register(&avila_hss_device[0]);
++	platform_device_register(&avila_hss_device[1]);
++	platform_device_register(&avila_hss_device[2]);
++	platform_device_register(&avila_hss_device[3]);
++
++	platform_device_register(&avila_pcm_device[0]);
++	platform_device_register(&avila_pcm_device[1]);
++	platform_device_register(&avila_pcm_device[2]);
++	platform_device_register(&avila_pcm_device[3]);
++}
++
+ static void __init avila_gw23xx_setup(void)
+ {
+ 	platform_device_register(&avila_npeb_device);
+@@ -509,6 +557,8 @@ static void __init avila_gw2365_setup(vo
+ 	avila_gpio_leds[0].gpio = 109;
+ 	avila_gpio_leds_data.num_leds = 5;
+ 	platform_device_register(&avila_gpio_leds_device);
++
++	setup_audio_devices();
+ }
+ 
+ static void __init avila_gw2369_setup(void)
+@@ -518,6 +568,8 @@ static void __init avila_gw2369_setup(vo
+ 
+ 	avila_npec_data.phy = 2;
+ 	platform_device_register(&avila_npec_device);
++
++	setup_audio_devices();
+ }
+ 
+ static void __init avila_gw2370_setup(void)
+@@ -547,6 +599,8 @@ static void __init avila_gw2370_setup(vo
+ 
+ 	avila_gpio_leds[0].gpio = 101;
+ 	platform_device_register(&avila_gpio_leds_device);
++
++	setup_audio_devices();
+ }
+ 
+ 
+@@ -655,6 +709,18 @@ static struct i2c_board_info __initdata
+ 		I2C_BOARD_INFO("24c08", 0x51),
+ 		.platform_data	= &avila_eeprom_info
+ 	},
++	{
++		I2C_BOARD_INFO("tlv320aic33", 0x1b),
++	},
++	{
++		I2C_BOARD_INFO("tlv320aic33", 0x1a),
++	},
++	{
++		I2C_BOARD_INFO("tlv320aic33", 0x19),
++	},
++	{
++		I2C_BOARD_INFO("tlv320aic33", 0x18),
++	},
+ };
+ 
+ static void __init avila_init(void)
+--- a/sound/soc/codecs/tlv320aic3x.c
++++ b/sound/soc/codecs/tlv320aic3x.c
+@@ -989,6 +989,22 @@ static int aic3x_set_dai_sysclk(struct s
+ 	return 0;
+ }
+ 
++static int aic3x_set_tdm_slot(struct snd_soc_dai *codec_dai,
++	unsigned int tx_mask, unsigned int rx_mask,
++	int slots, int width)
++{
++	struct snd_soc_codec *codec = codec_dai->codec;
++	u8 iface_creg;
++
++	iface_creg = snd_soc_read(codec, AIC3X_ASD_INTF_CTRLC);
++
++	iface_creg = slots * width;
++
++	snd_soc_write(codec, AIC3X_ASD_INTF_CTRLC, iface_creg);
++
++	return 0;
++}
++
+ static int aic3x_set_dai_fmt(struct snd_soc_dai *codec_dai,
+ 			     unsigned int fmt)
+ {
+@@ -1000,6 +1016,9 @@ static int aic3x_set_dai_fmt(struct snd_
+ 	iface_areg = snd_soc_read(codec, AIC3X_ASD_INTF_CTRLA) & 0x3f;
+ 	iface_breg = snd_soc_read(codec, AIC3X_ASD_INTF_CTRLB) & 0x3f;
+ 
++	iface_areg |= 0x30;
++	iface_breg |= 0x8;
++
+ 	/* set master/slave audio interface */
+ 	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+ 	case SND_SOC_DAIFMT_CBM_CFM:
+@@ -1231,6 +1250,7 @@ static struct snd_soc_dai_ops aic3x_dai_
+ 	.digital_mute	= aic3x_mute,
+ 	.set_sysclk	= aic3x_set_dai_sysclk,
+ 	.set_fmt	= aic3x_set_dai_fmt,
++	.set_tdm_slot	= aic3x_set_tdm_slot,
+ };
+ 
+ static struct snd_soc_dai_driver aic3x_dai = {
Index: trunk/target/linux/ixp4xx/patches-2.6.38/510-gw2360_support.patch
===================================================================
--- trunk/target/linux/ixp4xx/patches-2.6.38/510-gw2360_support.patch	(revision 0)
+++ trunk/target/linux/ixp4xx/patches-2.6.38/510-gw2360_support.patch	(working copy)
@@ -0,0 +1,468 @@
+--- a/arch/arm/mach-ixp4xx/cambria-setup.c
++++ b/arch/arm/mach-ixp4xx/cambria-setup.c
+@@ -4,19 +4,23 @@
+  * Board setup for the Gateworks Cambria series
+  *
+  * Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
++ * Copyright (C) 2012 Gateworks Corporation <support@gateworks.com>
+  *
+  * based on coyote-setup.c:
+  *      Copyright (C) 2003-2005 MontaVista Software, Inc.
+  *
+  * Author: Imre Kaloz <kaloz@openwrt.org>
++ *         Tim Harvey <tharvey@gateworks.com>
+  */
+ 
+ #include <linux/device.h>
+ #include <linux/gpio_buttons.h>
++#include <linux/gpio.h>
+ #include <linux/i2c.h>
+ #include <linux/i2c-gpio.h>
+ #include <linux/i2c/at24.h>
+ #include <linux/i2c/gw_i2c_pld.h>
++#include <linux/i2c/pca953x.h>
+ #include <linux/if_ether.h>
+ #include <linux/init.h>
+ #include <linux/input.h>
+@@ -39,6 +43,8 @@
+ #include <asm/setup.h>
+ #include <linux/irq.h>
+ 
++#define ARRAY_AND_SIZE(x)       (x), ARRAY_SIZE(x)
++
+ struct cambria_board_info {
+ 	unsigned char	*model;
+ 	void		(*setup)(void);
+@@ -78,6 +84,38 @@ static struct platform_device cambria_i2
+ 	},
+ };
+ 
++#ifdef SFP_SERIALID
++static struct i2c_gpio_platform_data cambria_i2c_gpio_sfpa_data = {
++	.sda_pin	= 113,
++	.scl_pin	= 112,
++	.sda_is_open_drain = 0,
++	.scl_is_open_drain = 0,
++};
++
++static struct platform_device cambria_i2c_gpio_sfpa = {
++	.name		= "i2c-gpio",
++	.id		= 1,
++	.dev = {
++		.platform_data	= &cambria_i2c_gpio_sfpa_data,
++	},
++};
++
++static struct i2c_gpio_platform_data cambria_i2c_gpio_sfpb_data = {
++	.sda_pin	= 115,
++	.scl_pin	= 114,
++	.sda_is_open_drain = 0,
++	.scl_is_open_drain = 0,
++};
++
++static struct platform_device cambria_i2c_gpio_sfpb = {
++	.name		= "i2c-gpio",
++	.id		= 2,
++	.dev = {
++		.platform_data	= &cambria_i2c_gpio_sfpb_data,
++	},
++};
++#endif // #ifdef SFP_SERIALID
++
+ static struct eth_plat_info cambria_npec_data = {
+ 	.phy		= 1,
+ 	.rxq		= 4,
+@@ -141,6 +179,36 @@ static struct resource cambria_optional_
+ 		.start	= 0x53000000,
+ 		.end	= 0x53000fff,
+ 		.flags	= IORESOURCE_MEM
++	},
++	{
++		.start	= 0x52000000,
++		.end	= 0x52000fff,
++		.flags	= IORESOURCE_MEM
++	},
++	{
++		.start	= 0x52000000,
++		.end	= 0x52000fff,
++		.flags	= IORESOURCE_MEM
++	},
++	{
++		.start	= 0x52000000,
++		.end	= 0x52000fff,
++		.flags	= IORESOURCE_MEM
++	},
++	{
++		.start	= 0x52000000,
++		.end	= 0x52000fff,
++		.flags	= IORESOURCE_MEM
++	},
++	{
++		.start	= 0x52000000,
++		.end	= 0x52000fff,
++		.flags	= IORESOURCE_MEM
++	},
++	{
++		.start	= 0x53000000,
++		.end	= 0x53000fff,
++		.flags	= IORESOURCE_MEM
+ 	}
+ };
+ 
+@@ -150,14 +218,44 @@ static struct plat_serial8250_port cambr
+ 		.iotype		= UPIO_MEM_DELAY,
+ 		.regshift	= 0,
+ 		.uartclk	= 1843200,
+-		.rw_delay	= 2,
++		.rw_delay	= 10,
+ 	},
+ 	{
+ 		.flags		= UPF_BOOT_AUTOCONF,
+ 		.iotype		= UPIO_MEM_DELAY,
+ 		.regshift	= 0,
+ 		.uartclk	= 1843200,
+-		.rw_delay	= 2,
++		.rw_delay	= 10,
++	},
++	{
++		.flags		= UPF_BOOT_AUTOCONF,
++		.iotype		= UPIO_MEM,
++		.regshift	= 0,
++		.uartclk	= 18432000,
++	},
++	{
++		.flags		= UPF_BOOT_AUTOCONF,
++		.iotype		= UPIO_MEM,
++		.regshift	= 0,
++		.uartclk	= 18432000,
++	},
++	{
++		.flags		= UPF_BOOT_AUTOCONF,
++		.iotype		= UPIO_MEM,
++		.regshift	= 0,
++		.uartclk	= 18432000,
++	},
++	{
++		.flags		= UPF_BOOT_AUTOCONF,
++		.iotype		= UPIO_MEM,
++		.regshift	= 0,
++		.uartclk	= 18432000,
++	},
++	{
++		.flags		= UPF_BOOT_AUTOCONF,
++		.iotype		= UPIO_MEM,
++		.regshift	= 0,
++		.uartclk	= 18432000,
+ 	},
+   { },
+ };
+@@ -200,9 +298,24 @@ static struct platform_device cambria_pa
+ 
+ static struct gpio_led cambria_gpio_leds[] = {
+ 	{
+-		.name		= "user",  /* green led */
++		.name		= "user",
+ 		.gpio		= 5,
+ 		.active_low 	= 1,
++	},
++	{
++		.name		= "user2",
++		.gpio		= 0,
++		.active_low 	= 1,
++	},
++	{
++		.name		= "user3",
++		.gpio		= 0,
++		.active_low 	= 1,
++	},
++	{
++		.name		= "user4",
++		.gpio		= 0,
++		.active_low 	= 1,
+ 	}
+ };
+ 
+@@ -224,6 +337,29 @@ static struct resource cambria_gpio_reso
+ 	},
+ };
+ 
++static struct gpio cambria_gpios_gw2360[] = {
++	// ARM GPIO
++	{  0, GPIOF_IN, "PCA_IRQ#" },
++	{ 11, GPIOF_OUT_INIT_LOW, "SER0_EN#" },
++	{ 12, GPIOF_IN, "GSC_IRQ#" },
++	{ 13, GPIOF_OUT_INIT_HIGH, "PCIE_RST#"},
++	// GSC GPIO
++#if !(defined(CONFIG_INPUT_GPIO_BUTTONS) || defined(CONFIG_INPUT_GPIO_BUTTONS_MODULE))
++	{100, GPIOF_IN, "USER_PB#" },
++#endif
++	{108, GPIOF_OUT_INIT_LOW, "ENET1_EN#" }, // ENET1 TX Enable
++	{109, GPIOF_IN, "ENET1_PRES#" },         // ENET1 Detect (0=SFP present)
++	{110, GPIOF_OUT_INIT_LOW, "ENET2_EN#" }, // ENET2 TX Enable
++	{111, GPIOF_IN, "ENET2_PRES#"},          // ENET2 Detect (0=SFP present)
++	// PCA GPIO
++	{116, GPIOF_OUT_INIT_HIGH, "USIM2_SEL#"},// USIM2 Slot select (1=Loc, 0=Rem)
++	{117, GPIOF_IN, "USIM2_DET_LOC#" },      // USIM2 Detect (Local Slot)
++	{118, GPIOF_IN, "USIM2_DET_REM#" },      // USIM2 Detect (Remote Slot)
++	{120, GPIOF_OUT_INIT_HIGH, "USB1_SEL#"}, // USB1 Select (1=PCIe1, 0=J1)
++	{121, GPIOF_OUT_INIT_HIGH, "USB2_SEL#"}, // USB2 Select (1=PCIe2, 0=J1
++	{122, GPIOF_IN, "USIM1_DET#"},           // USIM1 Detect
++};
++
+ static struct platform_device cambria_gpio = {
+ 	.name     = "GPIODEV",
+ 	.id     = -1,
+@@ -407,7 +543,7 @@ static void __init cambria_gw2350_setup(
+ 
+ static void __init cambria_gw2358_setup(void)
+ {
+-	*IXP4XX_EXP_CS3 = 0xBFFF3C43;
++	*IXP4XX_EXP_CS3 = 0xBFFF3C43; // bit0 = 16bit vs 8bit bus
+ 	set_irq_type(IRQ_IXP4XX_GPIO3, IRQ_TYPE_EDGE_RISING);
+ 	cambria_optional_uart_data[0].mapbase	= 0x53FC0000;
+ 	cambria_optional_uart_data[0].membase	= (void __iomem *)ioremap(0x53FC0000, 0x0fff);
+@@ -441,6 +577,125 @@ static void __init cambria_gw2358_setup(
+ 	platform_device_register(&cambria_gpio_buttons_device);
+ }
+ 
++static void __init cambria_gw2360_setup(void)
++{
++	/* The GW2360 has 8 UARTs in addition to the 1 IXP4xxx UART.
++	 * The chip-selects are expanded via a 3-to-8 decoder and CS2
++	 * and they are 8bit devices
++	 */
++	*IXP4XX_EXP_CS2 = 0xBFFF3C43;
++	cambria_optional_uart_data[0].mapbase = 0x52000000;
++	cambria_optional_uart_data[0].membase = (void __iomem *)ioremap(0x52000000, 0x0fff);
++	cambria_optional_uart_data[0].uartclk = 18432000;
++	cambria_optional_uart_data[0].iotype  = UPIO_MEM;
++	cambria_optional_uart_data[0].irq     = IRQ_IXP4XX_GPIO2;
++	set_irq_type(IRQ_IXP4XX_GPIO2, IRQ_TYPE_EDGE_RISING);
++
++	cambria_optional_uart_data[1].mapbase = 0x52000008;
++	cambria_optional_uart_data[1].membase = (void __iomem *)ioremap(0x52000008, 0x0fff);
++	cambria_optional_uart_data[1].uartclk = 18432000;
++	cambria_optional_uart_data[1].iotype  = UPIO_MEM;
++	cambria_optional_uart_data[1].irq     = IRQ_IXP4XX_GPIO3;
++	set_irq_type(IRQ_IXP4XX_GPIO3, IRQ_TYPE_EDGE_RISING);
++
++	cambria_optional_uart_data[2].mapbase = 0x52000010;
++	cambria_optional_uart_data[2].membase = (void __iomem *)ioremap(0x52000010, 0x0fff);
++	cambria_optional_uart_data[2].uartclk = 18432000;
++	cambria_optional_uart_data[2].iotype  = UPIO_MEM;
++	cambria_optional_uart_data[2].irq     = IRQ_IXP4XX_GPIO4;
++	set_irq_type(IRQ_IXP4XX_GPIO4, IRQ_TYPE_EDGE_RISING);
++
++	cambria_optional_uart_data[3].mapbase = 0x52000018;
++	cambria_optional_uart_data[3].membase = (void __iomem *)ioremap(0x52000018, 0x0fff);
++	cambria_optional_uart_data[3].uartclk = 18432000;
++	cambria_optional_uart_data[3].iotype  = UPIO_MEM;
++	cambria_optional_uart_data[3].irq     = IRQ_IXP4XX_GPIO5;
++	set_irq_type(IRQ_IXP4XX_GPIO5, IRQ_TYPE_EDGE_RISING);
++
++	cambria_optional_uart_data[4].mapbase = 0x52000020;
++	cambria_optional_uart_data[4].membase = (void __iomem *)ioremap(0x52000020, 0x0fff);
++	cambria_optional_uart_data[4].uartclk = 18432000;
++	cambria_optional_uart_data[4].iotype  = UPIO_MEM;
++	cambria_optional_uart_data[4].irq     = IRQ_IXP4XX_GPIO8;
++	set_irq_type(IRQ_IXP4XX_GPIO8, IRQ_TYPE_EDGE_RISING);
++
++	cambria_optional_uart_data[5].mapbase = 0x52000028;
++	cambria_optional_uart_data[5].membase = (void __iomem *)ioremap(0x52000028, 0x0fff);
++	cambria_optional_uart_data[5].uartclk = 18432000;
++	cambria_optional_uart_data[5].iotype  = UPIO_MEM;
++	cambria_optional_uart_data[5].irq     = IRQ_IXP4XX_GPIO9;
++	set_irq_type(IRQ_IXP4XX_GPIO9, IRQ_TYPE_EDGE_RISING);
++
++	cambria_optional_uart_data[6].mapbase = 0x52000030;
++	cambria_optional_uart_data[6].membase = (void __iomem *)ioremap(0x52000030, 0x0fff);
++	cambria_optional_uart_data[6].uartclk = 18432000;
++	cambria_optional_uart_data[6].iotype  = UPIO_MEM;
++	cambria_optional_uart_data[6].irq     = IRQ_IXP4XX_GPIO10;
++	set_irq_type(IRQ_IXP4XX_GPIO10, IRQ_TYPE_EDGE_RISING);
++
++	cambria_optional_uart.num_resources   = 7,
++	platform_device_register(&cambria_optional_uart);
++
++	platform_device_register(&cambria_gpio);
++
++#if defined(CONFIG_MVSWITCH_PHY) || defined(CONFIG_MVSWITCH_PHY_MODULE)
++	/* The mvswitch driver has some hard-coded values which could
++	 * easily be turned into a platform resource if needed.  For now they
++	 * match our hardware configuration:
++	 *  MV_BASE    0x10 - phy base address
++	 *  MV_WANPORT 0 - Port0 (ENET2) is WAN (SFP module)
++	 *  MV_CPUPORT 5 - Port5 is CPU NPEA (eth1)
++	 *
++	 * The mvswitch driver registers a fixup which forces a driver match
++	 * if phy_addr matches MV_BASE
++	 *
++	 * Two static defautl VLAN's are created: WAN port in 1, and all other ports
++	 * in the other.
++	 */
++	cambria_npea_data.phy = 0x10; // mvswitch driver catches this
++#else
++	// Switch Port5 to CPU is MII<->MII (no PHY) - this disables the generic PHY driver
++	cambria_npea_data.phy = IXP4XX_ETH_PHY_MAX_ADDR;
++#endif
++
++	// disable genphy autonegotiation on NPE-C PHY (eth1) as its 100BaseFX
++	cambria_npec_data.noautoneg = 1;   // disable autoneg
++	cambria_npec_data.speed_10 = 0;    // 100mbps
++	cambria_npec_data.half_duplex = 0; // full-duplex
++	platform_device_register(&cambria_npec_device);
++	platform_device_register(&cambria_npea_device);
++
++	platform_device_register(&cambria_usb0_device);
++	platform_device_register(&cambria_usb1_device);
++
++	cambria_gpio_leds_data.num_leds = 3;
++	cambria_gpio_leds[0].name = "user1";
++	cambria_gpio_leds[0].gpio = 125;
++	cambria_gpio_leds[1].gpio = 126;
++	cambria_gpio_leds[2].gpio = 119;
++	platform_device_register(&cambria_gpio_leds_device);
++
++#if (defined(CONFIG_INPUT_GPIO_BUTTONS) || defined(CONFIG_INPUT_GPIO_BUTTONS_MODULE))
++	cambria_gpio_buttons[0].gpio = 100;
++	platform_device_register(&cambria_gpio_buttons_device);
++#endif
++
++#ifdef SFP_SERIALID
++	/* the SFP modules each have an i2c bus for serial ident via GSC GPIO
++	 * To use these the i2c-gpio driver must be changed to use the _cansleep
++	 * varients of gpio_get_value/gpio_set_value (I don't know why it doesn't
++	 * use that anyway as it doesn't operate in an IRQ context).
++	 * Additionally the i2c-gpio module must set the gpio to output-high prior
++	 * to changing direction to an input to enable internal Pullups
++	 */
++	platform_device_register(&cambria_i2c_gpio_sfpa);
++	platform_device_register(&cambria_i2c_gpio_sfpb);
++#endif
++
++	/* gpio config (/sys/class/gpio) */
++	gpio_request_array(ARRAY_AND_SIZE(cambria_gpios_gw2360));
++}
++
+ static struct cambria_board_info cambria_boards[] __initdata = {
+ 	{
+ 		.model	= "GW2350",
+@@ -449,6 +704,9 @@ static struct cambria_board_info cambria
+ 		.model	= "GW2358",
+ 		.setup	= cambria_gw2358_setup,
+ 	}, {
++		.model	= "GW2360",
++		.setup	= cambria_gw2360_setup,
++	}, {
+ 		.model	= "GW2371",
+ 		.setup	= cambria_gw2358_setup,
+ 	}
+@@ -499,13 +757,31 @@ static struct at24_platform_data cambria
+ 	.setup		= at24_setup,
+ };
+ 
++static struct pca953x_platform_data cambria_pca_data = {
++	.gpio_base = 100,
++	.irq_base = -1,
++};
++
++static struct pca953x_platform_data cambria_pca2_data = {
++	.gpio_base = 116,
++	.irq_base = -1,
++};
++
+ static struct i2c_board_info __initdata cambria_i2c_board_info[] = {
+ 	{
++		I2C_BOARD_INFO("pca9555", 0x23),
++		.platform_data = &cambria_pca_data,
++	},
++	{
++		I2C_BOARD_INFO("pca9555", 0x27),
++		.platform_data = &cambria_pca2_data,
++	},
++	{
+ 		I2C_BOARD_INFO("ds1672", 0x68),
+ 	},
+ 	{
+-                I2C_BOARD_INFO("gsp", 0x29),
+-        },
++		I2C_BOARD_INFO("gsp", 0x29),
++	},
+ 	{
+ 		I2C_BOARD_INFO("ad7418", 0x28),
+ 	},
+@@ -530,10 +806,10 @@ static void __init cambria_init(void)
+ 	cambria_flash_resource.start = IXP4XX_EXP_BUS_BASE(0);
+ 	cambria_flash_resource.end = IXP4XX_EXP_BUS_BASE(0) + SZ_32M - 1;
+ 
+-	*IXP4XX_EXP_CS0 |= IXP4XX_FLASH_WRITABLE;
++	*IXP4XX_EXP_CS0 |= IXP4XX_FLASH_WRITABLE; // make sure window is writable
+ 	*IXP4XX_EXP_CS1 = *IXP4XX_EXP_CS0;
+ 
+-	platform_add_devices(cambria_devices, ARRAY_SIZE(cambria_devices));
++	platform_add_devices(ARRAY_AND_SIZE(cambria_devices));
+ 
+ 	cambria_pata_resources[0].start = 0x53e00000;
+ 	cambria_pata_resources[0].end = 0x53e3ffff;
+@@ -544,8 +820,7 @@ static void __init cambria_init(void)
+ 	cambria_pata_data.cs0_cfg = IXP4XX_EXP_CS3;
+ 	cambria_pata_data.cs1_cfg = IXP4XX_EXP_CS3;
+ 
+-	i2c_register_board_info(0, cambria_i2c_board_info,
+-				ARRAY_SIZE(cambria_i2c_board_info));
++	i2c_register_board_info(0, ARRAY_AND_SIZE(cambria_i2c_board_info));
+ }
+ 
+ static int __init cambria_model_setup(void)
+--- a/drivers/net/arm/ixp4xx_eth.c
++++ b/drivers/net/arm/ixp4xx_eth.c
+@@ -461,6 +461,15 @@ static int ixp4xx_phy_connect(struct net
+ 	port->phydev->supported &= PHY_BASIC_FEATURES;
+ 	port->phydev->advertising = port->phydev->supported;
+ 
++	if (plat->noautoneg)
++	{
++		port->speed = plat->speed_10 ? SPEED_10 : SPEED_100;
++		port->duplex = plat->half_duplex ? DUPLEX_HALF : DUPLEX_FULL;
++		port->phydev->autoneg = 0;
++		port->phydev->speed = port->speed;
++		port->phydev->duplex = port->duplex;
++	}
++
+ 	port->phydev->irq = PHY_POLL;
+ 
+ 	return 0;
+@@ -1394,8 +1403,10 @@ static int __devinit eth_init_one(struct
+ 		goto err_phy_dis;
+ 
+ 	port->link = 0;
+-	port->speed = 0;
+-	port->duplex = -1;
++	if (!plat->noautoneg) {
++		port->speed = 0;
++		port->duplex = -1;
++	}
+ 
+ 	printk(KERN_INFO "%s: MII PHY %i on %s\n", dev->name, plat->phy,
+ 	       npe_name(port->npe));
+--- a/arch/arm/mach-ixp4xx/include/mach/platform.h
++++ b/arch/arm/mach-ixp4xx/include/mach/platform.h
+@@ -111,6 +111,7 @@ struct eth_plat_info {
+ #else
+ 	int speed_10;
+ 	int half_duplex;
++	int noautoneg;
+ #endif
+ };
+ 
+--- a/drivers/net/phy/phy.c
++++ b/drivers/net/phy/phy.c
+@@ -908,7 +908,7 @@ void phy_state_machine(struct work_struc
+ 			if (phydev->link) {
+ 				phydev->state = PHY_RUNNING;
+ 				netif_carrier_on(phydev->attached_dev);
+-			} else {
++			} else if (AUTONEG_ENABLE == phydev->autoneg) {
+ 				if (0 == phydev->link_timeout--) {
+ 					phy_force_reduction(phydev);
+ 					needs_aneg = 1;
Index: trunk/target/linux/ixp4xx/patches-2.6.38/700-spread-spectrum-adjust.patch
===================================================================
--- trunk/target/linux/ixp4xx/patches-2.6.38/700-spread-spectrum-adjust.patch	(revision 0)
+++ trunk/target/linux/ixp4xx/patches-2.6.38/700-spread-spectrum-adjust.patch	(working copy)
@@ -0,0 +1,45 @@
+--- a/arch/arm/mach-ixp4xx/include/mach/platform.h
++++ b/arch/arm/mach-ixp4xx/include/mach/platform.h
+@@ -73,7 +73,12 @@ extern unsigned long ixp4xx_exp_bus_size
+  * Clock Speed Definitions.
+  */
+ #define IXP4XX_PERIPHERAL_BUS_CLOCK 	(66) /* 66Mhzi APB BUS   */
++#ifdef CONFIG_IXP4XX_SPREAD_SPECTRUM_CLK
++// Adjusted for 2% down spread-spectrum osciallator
++#define IXP4XX_UART_XTAL        	14598144
++#else
+ #define IXP4XX_UART_XTAL        	14745600
++#endif
+ 
+ /*
+  * This structure provide a means for the board setup code
+--- a/arch/arm/mach-ixp4xx/include/mach/timex.h
++++ b/arch/arm/mach-ixp4xx/include/mach/timex.h
+@@ -10,7 +10,12 @@
+  * 66.66... MHz. We do a convulted calculation of CLOCK_TICK_RATE b/c the
+  * timer register ignores the bottom 2 bits of the LATCH value.
+  */
++#ifdef CONFIG_IXP4XX_SPREAD_SPECTRUM_CLK
++// Adjusted for 2% down spread-spectrum osciallator
++#define IXP4XX_TIMER_FREQ 65999340
++#else
+ #define IXP4XX_TIMER_FREQ 66666000
++#endif
+ #define CLOCK_TICK_RATE \
+ 	(((IXP4XX_TIMER_FREQ / HZ & ~IXP4XX_OST_RELOAD_MASK) + 1) * HZ)
+ 
+--- a/arch/arm/mach-ixp4xx/Kconfig
++++ b/arch/arm/mach-ixp4xx/Kconfig
+@@ -277,6 +277,12 @@ config MACH_MI424WR
+ 
+ comment "IXP4xx Options"
+ 
++config IXP4XX_SPREAD_SPECTRUM_CLK
++	bool "Adjust clocks for 2% Down Spread Spectrum source"
++	help
++	  Say 'Y' here if you want your kernel to adjust clocks for a
++	  2% down spread-spectrum oscillator used as the CPU clock.
++
+ config IXP4XX_INDIRECT_PCI
+ 	bool "Use indirect PCI memory access"
+ 	depends on PCI
Index: trunk/target/linux/ixp4xx/patches-2.6.38/701-mvswitch-88e6061.patch
===================================================================
--- trunk/target/linux/ixp4xx/patches-2.6.38/701-mvswitch-88e6061.patch	(revision 0)
+++ trunk/target/linux/ixp4xx/patches-2.6.38/701-mvswitch-88e6061.patch	(working copy)
@@ -0,0 +1,236 @@
+--- a/drivers/net/phy/mvswitch.c
++++ b/drivers/net/phy/mvswitch.c
+@@ -1,6 +1,7 @@
+ /*
+  * Marvell 88E6060 switch driver
+  * Copyright (c) 2008 Felix Fietkau <nbd@openwrt.org>
++ * Copyright (c) 2008 Sebastian Gottschall <s.gottschall@dd-wrt.com> (just 88E6061 support)
+  *
+  * This program is free software; you can redistribute  it and/or modify it
+  * under  the terms of the GNU General Public License v2 as published by the
+@@ -44,7 +45,7 @@ struct mvswitch_priv {
+ 	const struct net_device_ops *ndo_old;
+ 	struct net_device_ops ndo;
+ 	struct vlan_group *grp;
+-	u8 vlans[16];
++	u8 vlans[2];
+ };
+ 
+ #define to_mvsw(_phy) ((struct mvswitch_priv *) (_phy)->priv)
+@@ -177,12 +178,16 @@ mvswitch_mangle_rx(struct sk_buff *skb,
+ 	/* look for the vlan matching the incoming port */
+ 	for (i = 0; i < ARRAY_SIZE(priv->vlans); i++) {
+ 		if ((1 << buf[1]) & priv->vlans[i])
++		{
+ 			vlan = i;
++			goto receive;
++		}
+ 	}
+ 
+ 	if (vlan == -1)
+ 		goto error;
+ 
++receive:
+ 	skb->protocol = eth_type_trans(skb, skb->dev);
+ 
+ 	if (napi)
+@@ -221,7 +226,7 @@ mvswitch_vlan_rx_register(struct net_dev
+ static int
+ mvswitch_wait_mask(struct phy_device *pdev, int addr, int reg, u16 mask, u16 val)
+ {
+-	int i = 100;
++	int i = 1000;
+ 	u16 r;
+ 
+ 	do {
+@@ -238,7 +243,9 @@ mvswitch_config_init(struct phy_device *
+ 	struct mvswitch_priv *priv = to_mvsw(pdev);
+ 	struct net_device *dev = pdev->attached_dev;
+ 	u8 vlmap = 0;
++	u16 reg;
+ 	int i;
++	u16 emask;
+ 
+ 	if (!dev)
+ 		return -EINVAL;
+@@ -247,14 +254,18 @@ mvswitch_config_init(struct phy_device *
+ 	pdev->supported = ADVERTISED_100baseT_Full;
+ 	pdev->advertising = ADVERTISED_100baseT_Full;
+ 	dev->phy_ptr = priv;
+-	pdev->irq = PHY_POLL;
+-#ifdef HEADER_MODE
+-	dev->flags |= IFF_PROMISC;
+-#endif
++	dev->irq = PHY_POLL;
++	emask = MV_PORTCTRL_ENABLED;
++	reg = r16(pdev, MV_PORTREG(IDENT, 0)) & MV_IDENT_MASK;
++	if (reg == MV_IDENT_VALUE2)
++	{
++	    printk("%s: Marvell 88E6061 workaround enabled\n",dev->name);
++	    emask = MV_PORTCTRL_ENABLED | MV_PORTCTRL_EGRESSALL;
++	}
+ 
+ 	/* initialize default vlans */
+ 	for (i = 0; i < MV_PORTS; i++)
+-		priv->vlans[(i == MV_WANPORT ? 2 : 1)] |= (1 << i);
++		priv->vlans[(i == MV_WANPORT ? 1 : 0)] |= (1 << i);
+ 
+ 	/* before entering reset, disable all ports */
+ 	for (i = 0; i < MV_PORTS; i++)
+@@ -270,6 +281,7 @@ mvswitch_config_init(struct phy_device *
+ 		printk("%s: Timeout waiting for the switch to reset.\n", dev->name);
+ 		return i;
+ 	}
++	msleep(10); /* wait for the status change to settle in */
+ 
+ 	/* set the ATU flags */
+ 	w16(pdev, MV_SWITCHREG(ATU_CTRL),
+@@ -286,8 +298,9 @@ mvswitch_config_init(struct phy_device *
+ 		MV_PORTCTRL_RXTR |
+ 		MV_PORTCTRL_TXTR |
+ #endif
+-		MV_PORTCTRL_ENABLED
++		emask
+ 	);
++
+ 	/* wait for the phy change to settle in */
+ 	msleep(2);
+ 	for (i = 0; i < MV_PORTS; i++) {
+@@ -320,9 +333,7 @@ mvswitch_config_init(struct phy_device *
+ 		);
+ 
+ 		/* re-enable port */
+-		w16(pdev, MV_PORTREG(CONTROL, i),
+-			MV_PORTCTRL_ENABLED
+-		);
++		w16(pdev, MV_PORTREG(CONTROL, i), emask);
+ 	}
+ 
+ 	w16(pdev, MV_PORTREG(VLANMAP, MV_CPUPORT),
+@@ -361,29 +372,54 @@ mvswitch_config_init(struct phy_device *
+ 	return 0;
+ }
+ 
++#define MV_AUTONEG_DONE(mv_phy_specific_status)                   \
++    (((mv_phy_specific_status) &                                  \
++        (MV_STATUS_RESOLVED | MV_STATUS_REAL_TIME_LINK_UP)) ==    \
++        (MV_STATUS_RESOLVED | MV_STATUS_REAL_TIME_LINK_UP))
++
+ static int
+ mvswitch_read_status(struct phy_device *pdev)
+ {
+ 	pdev->speed = SPEED_100;
+ 	pdev->duplex = DUPLEX_FULL;
+-	pdev->link = 1;
+-
+-	/* XXX ugly workaround: we can't force the switch
+-	 * to gracefully handle hosts moving from one port to another,
+-	 * so we have to regularly clear the ATU database */
+-
+-	/* wait for the ATU to become available */
+-	mvswitch_wait_mask(pdev, MV_SWITCHREG(ATU_OP), MV_ATUOP_INPROGRESS, 0);
+-
+-	/* flush the ATU */
+-	w16(pdev, MV_SWITCHREG(ATU_OP),
+-		MV_ATUOP_INPROGRESS |
+-		MV_ATUOP_FLUSH_ALL
+-	);
++	pdev->state = PHY_UP;
++	static int linkstatus[5]={0,0,0,0,0};
+ 
+-	/* wait for operation to complete */
+-	mvswitch_wait_mask(pdev, MV_SWITCHREG(ATU_OP), MV_ATUOP_INPROGRESS, 0);
++	int i;
++	for (i=0;i<MV_PORTS;i++)
++	    {
++	    int status = r16(pdev,MV_PHYPORT(i),MV_PHY_STATUS1);
++	    if (linkstatus[i])
++	    {
++	    if (!(status & MV_STATUS_REAL_TIME_LINK_UP))
++		{
++		printk(KERN_INFO "port %d, link down\n",i);
++		/* XXX ugly workaround: we can't force the switch
++		* to gracefully handle hosts moving from one port to another,
++		* so we have to regularly clear the ATU database */
++
++		/* wait for the ATU to become available */
++		mvswitch_wait_mask(pdev, MV_SWITCHREG(ATU_OP), MV_ATUOP_INPROGRESS, 0);
++
++		/* flush the ATU */
++		w16(pdev, MV_SWITCHREG(ATU_OP),
++			MV_ATUOP_INPROGRESS |
++			MV_ATUOP_FLUSH_ALL
++		);
+ 
++		/* wait for operation to complete */
++		mvswitch_wait_mask(pdev, MV_SWITCHREG(ATU_OP), MV_ATUOP_INPROGRESS, 0);
++		linkstatus[i]=0;
++		}
++	    }else
++	    {
++		if (MV_AUTONEG_DONE(status))
++		    {
++		    printk(KERN_INFO "port %d, link up\n",i);
++		    linkstatus[i]=1;
++		    }
++	    }
++	}
+ 	return 0;
+ }
+ 
+@@ -430,7 +466,7 @@ mvswitch_fixup(struct phy_device *dev)
+ 		return 0;
+ 
+ 	reg = dev->bus->read(dev->bus, MV_PORTREG(IDENT, 0)) & MV_IDENT_MASK;
+-	if (reg != MV_IDENT_VALUE)
++	if (reg != MV_IDENT_VALUE && reg != MV_IDENT_VALUE2)
+ 		return 0;
+ 
+ 	dev->phy_id = MVSWITCH_MAGIC;
+@@ -439,7 +475,7 @@ mvswitch_fixup(struct phy_device *dev)
+ 
+ 
+ static struct phy_driver mvswitch_driver = {
+-	.name		= "Marvell 88E6060",
++	.name		= "Marvell 88E6060/88E6061",
+ 	.phy_id		= MVSWITCH_MAGIC,
+ 	.phy_id_mask	= 0xffffffff,
+ 	.features	= PHY_BASIC_FEATURES,
+--- a/drivers/net/phy/mvswitch.h
++++ b/drivers/net/phy/mvswitch.h
+@@ -1,6 +1,7 @@
+ /*
+  * Marvell 88E6060 switch driver
+  * Copyright (c) 2008 Felix Fietkau <nbd@openwrt.org>
++ * Copyright (c) 2008 Sebastian Gottschall <s.gottschall@dd-wrt.com> (just 88E6061 support)
+  *
+  * This program is free software; you can redistribute  it and/or modify it
+  * under  the terms of the GNU General Public License v2 as published by the
+@@ -21,9 +22,11 @@
+ #define MV_TRAILER_FLAGS_S	24
+ #define MV_TRAILER_OVERRIDE	0x80
+ 
++#define MV_STATUS_REAL_TIME_LINK_UP               0x0400
++#define MV_STATUS_RESOLVED                        0x0800
+ 
+ #define MV_PORTS	5
+-#define MV_WANPORT	4
++#define MV_WANPORT	0
+ #define MV_CPUPORT	5
+ 
+ #define MV_BASE		0x10
+@@ -75,6 +78,7 @@ enum {
+ 	MV_PORTCTRL_BLOCK   =  (1 << 0),
+ 	MV_PORTCTRL_LEARN   =  (2 << 0),
+ 	MV_PORTCTRL_ENABLED =  (3 << 0),
++	MV_PORTCTRL_EGRESSALL =  (12 << 0),     /* Egress all (E6061 only) */
+ 	MV_PORTCTRL_VLANTUN =  (1 << 7),	/* Enforce VLANs on packets */
+ 	MV_PORTCTRL_RXTR    =  (1 << 8),	/* Enable Marvell packet trailer for ingress */
+ 	MV_PORTCTRL_HEADER	= (1 << 11),	/* Enable Marvell packet header mode for port */
+@@ -141,5 +145,6 @@ enum {
+ 
+ #define MV_IDENT_MASK		0xfff0
+ #define MV_IDENT_VALUE		0x0600
++#define MV_IDENT_VALUE2		0x0610
+ 
+ #endif
Index: trunk/target/linux/ixp4xx/patches-2.6.38/702-cambria-gw2359-support.patch
===================================================================
--- trunk/target/linux/ixp4xx/patches-2.6.38/702-cambria-gw2359-support.patch	(revision 0)
+++ trunk/target/linux/ixp4xx/patches-2.6.38/702-cambria-gw2359-support.patch	(working copy)
@@ -0,0 +1,228 @@
+--- a/arch/arm/mach-ixp4xx/cambria-setup.c
++++ b/arch/arm/mach-ixp4xx/cambria-setup.c
+@@ -337,27 +337,98 @@ static struct resource cambria_gpio_reso
+ 	},
+ };
+ 
++static struct gpio cambria_gpios_gw2350[] = {
++	// ARM GPIO
++#if 0 // configured from bootloader
++	{  0, GPIOF_IN,            "ARM_DIO0" },
++	{  1, GPIOF_IN,            "ARM_DIO1" },
++	{  2, GPIOF_IN,            "ARM_DIO2" },
++	{  3, GPIOF_IN,            "ARM_DIO3" },
++	{  4, GPIOF_IN,            "ARM_DIO4" },
++	{  5, GPIOF_IN,            "ARM_DIO5" },
++	{ 12, GPIOF_OUT_INIT_HIGH, "WDOGEN#" },
++#endif
++	{  8, GPIOF_IN,            "ARM_DIO8" },
++	{  9, GPIOF_IN,            "ARM_DIO9" },
++};
++
++static struct gpio cambria_gpios_gw2358[] = {
++	// ARM GPIO
++#if 0 // configured from bootloader
++	{  0, GPIOF_IN,            "*VINLOW#" },
++	{  2, GPIOF_IN,            "*GPS_PPS" },
++	{  3, GPIOF_IN,            "*GPS_IRQ#" },
++	{  4, GPIOF_IN,            "*RS485_IRQ#" },
++	{  5, GPIOF_IN,            "*SER_EN#" },
++	{ 14, GPIOF_OUT_INIT_HIGH, "*WDOGEN#" },
++#endif
++};
++
++static struct gpio cambria_gpios_gw2359[] = {
++	// ARM GPIO
++#if 0 // configured from bootloader
++	{  0, GPIOF_IN,            "*PCA_IRQ#" },
++	{  1, GPIOF_IN,            "ARM_DIO1" },
++	{  2, GPIOF_IN,            "ARM_DIO2" },
++	{  3, GPIOF_IN,            "ARM_DIO3" },
++	{  4, GPIOF_IN,            "ARM_DIO4" },
++	{  5, GPIOF_IN,            "ARM_DIO5" },
++	{  8, GPIOF_OUT_INIT_HIGH, "*WDOGEN#" },
++#endif
++	{ 11, GPIOF_OUT_INIT_HIGH, "*SER_EN"   },       // console serial enable
++	{ 12, GPIOF_IN,            "*GSC_IRQ#" },
++	{ 13, GPIOF_OUT_INIT_HIGH, "*PCIE_RST#"},
++	// GSC GPIO
++#if !(defined(CONFIG_INPUT_GPIO_BUTTONS) || defined(CONFIG_INPUT_GPIO_BUTTONS_MODULE))
++	{100, GPIOF_IN,            "*USER_PB#" },
++#endif
++	{103, GPIOF_OUT_INIT_HIGH, "*5V_EN" },         // 5V aux supply enable
++	{108, GPIOF_IN,            "*SMUXDA0" },
++	{109, GPIOF_IN,            "*SMUXDA1" },
++	{110, GPIOF_IN,            "*SMUXDA2" },
++	{111, GPIOF_IN,            "*SMUXDB0" },
++	{112, GPIOF_IN,            "*SMUXDB1" },
++	{113, GPIOF_IN,            "*SMUXDB2" },
++	// PCA GPIO
++	{118, GPIOF_IN,            "*USIM2_DET#"},     // USIM2 Detect
++	{120, GPIOF_OUT_INIT_LOW,  "*USB1_PCI_SEL"},   // USB1  Select (1=PCI, 0=FP)
++	{121, GPIOF_OUT_INIT_LOW,  "*USB2_PCI_SEL"},   // USB2  Select (1=PCI, 0=FP)
++	{122, GPIOF_IN,            "*USIM1_DET#"},     // USIM1 Detect
++	{123, GPIOF_OUT_INIT_HIGH, "*COM1_DTR#" },     // J21/J10
++	{124, GPIOF_IN,            "*COM1_DSR#" },     // J21/J10
++	{127, GPIOF_IN,            "PCA_DIO0" },
++	{128, GPIOF_IN,            "PCA_DIO1" },
++	{129, GPIOF_IN,            "PCA_DIO2" },
++	{130, GPIOF_IN,            "PCA_DIO3" },
++	{131, GPIOF_IN,            "PCA_DIO4" },
++};
++
+ static struct gpio cambria_gpios_gw2360[] = {
+ 	// ARM GPIO
+-	{  0, GPIOF_IN, "PCA_IRQ#" },
+-	{ 11, GPIOF_OUT_INIT_LOW, "SER0_EN#" },
+-	{ 12, GPIOF_IN, "GSC_IRQ#" },
+-	{ 13, GPIOF_OUT_INIT_HIGH, "PCIE_RST#"},
++	{  0, GPIOF_IN,            "*PCA_IRQ#" },
++	{ 11, GPIOF_OUT_INIT_LOW, "*SER0_EN#" },
++	{ 12, GPIOF_IN,            "*GSC_IRQ#" },
++	{ 13, GPIOF_OUT_INIT_HIGH, "*PCIE_RST#"},
+ 	// GSC GPIO
+ #if !(defined(CONFIG_INPUT_GPIO_BUTTONS) || defined(CONFIG_INPUT_GPIO_BUTTONS_MODULE))
+-	{100, GPIOF_IN, "USER_PB#" },
++	{100, GPIOF_IN,            "*USER_PB#" },
+ #endif
+-	{108, GPIOF_OUT_INIT_LOW, "ENET1_EN#" }, // ENET1 TX Enable
+-	{109, GPIOF_IN, "ENET1_PRES#" },         // ENET1 Detect (0=SFP present)
+-	{110, GPIOF_OUT_INIT_LOW, "ENET2_EN#" }, // ENET2 TX Enable
+-	{111, GPIOF_IN, "ENET2_PRES#"},          // ENET2 Detect (0=SFP present)
++	{108, GPIOF_OUT_INIT_LOW,  "*ENET1_EN#" },     // ENET1 TX Enable
++	{109, GPIOF_IN,            "*ENET1_PRES#" },   // ENET1 Detect (0=SFP present)
++	{110, GPIOF_OUT_INIT_LOW,  "*ENET2_EN#" },     // ENET2 TX Enable
++	{111, GPIOF_IN,            "*ENET2_PRES#"},    // ENET2 Detect (0=SFP present)
+ 	// PCA GPIO
+-	{116, GPIOF_OUT_INIT_HIGH, "USIM2_SEL#"},// USIM2 Slot select (1=Loc, 0=Rem)
+-	{117, GPIOF_IN, "USIM2_DET_LOC#" },      // USIM2 Detect (Local Slot)
+-	{118, GPIOF_IN, "USIM2_DET_REM#" },      // USIM2 Detect (Remote Slot)
+-	{120, GPIOF_OUT_INIT_HIGH, "USB1_SEL#"}, // USB1 Select (1=PCIe1, 0=J1)
+-	{121, GPIOF_OUT_INIT_HIGH, "USB2_SEL#"}, // USB2 Select (1=PCIe2, 0=J1
+-	{122, GPIOF_IN, "USIM1_DET#"},           // USIM1 Detect
++	{116, GPIOF_OUT_INIT_HIGH, "*USIM2_LOC"},      // USIM2 Select (1=Loc, 0=Rem)
++	{117, GPIOF_IN,            "*USIM2_DET_LOC#" },// USIM2 Detect (Local Slot)
++	{118, GPIOF_IN,            "*USIM2_DET_REM#" },// USIM2 Detect (Remote Slot)
++	{120, GPIOF_OUT_INIT_LOW,  "*USB1_PCI_SEL"},   // USB1  Select (1=PCIe1, 0=J1)
++	{121, GPIOF_OUT_INIT_LOW,  "*USB2_PCI_SEL"},   // USB2  Select (1=PCIe2, 0=J1)
++	{122, GPIOF_IN,            "*USIM1_DET#"},     // USIM1 Detect
++	{127, GPIOF_IN,            "DIO0" },
++	{128, GPIOF_IN,            "DIO1" },
++	{129, GPIOF_IN,            "DIO2" },
++	{130, GPIOF_IN,            "DIO3" },
++	{131, GPIOF_IN,            "DIO4" },
+ };
+ 
+ static struct platform_device cambria_gpio = {
+@@ -501,6 +572,25 @@ static struct platform_device *cambria_d
+ 	&cambria_uart,
+ };
+ 
++static int cambria_register_gpio(struct gpio *array, size_t num)
++{
++	int i, err, ret;
++
++	ret = 0;
++	for (i = 0; i < num; i++, array++) {
++		const char *label = array->label;
++		if (label[0] == '*')
++			label++;
++		err = gpio_request_one(array->gpio, array->flags, label);
++		if (err)
++			ret = err;
++		else {
++			err = gpio_export(array->gpio, array->label[0] != '*');
++		}
++	}
++	return ret;
++}
++
+ static void __init cambria_gw23xx_setup(void)
+ {
+ 	cambria_gpio_resources[0].start = (1 << 0) | (1 << 1) | (1 << 2) | (1 << 3) | (1 << 4) |\
+@@ -539,6 +629,9 @@ static void __init cambria_gw2350_setup(
+ 	platform_device_register(&cambria_usb1_device);
+ 
+ 	platform_device_register(&cambria_gpio_leds_device);
++
++	/* gpio config (/sys/class/gpio) */
++	cambria_register_gpio(ARRAY_AND_SIZE(cambria_gpios_gw2350));
+ }
+ 
+ static void __init cambria_gw2358_setup(void)
+@@ -575,6 +668,56 @@ static void __init cambria_gw2358_setup(
+ 	platform_device_register(&cambria_latch_leds_device);
+ 
+ 	platform_device_register(&cambria_gpio_buttons_device);
++
++	/* gpio config (/sys/class/gpio) */
++	cambria_register_gpio(ARRAY_AND_SIZE(cambria_gpios_gw2358));
++}
++
++static void __init cambria_gw2359_setup(void)
++{
++	platform_device_register(&cambria_gpio);
++
++#if defined(CONFIG_MVSWITCH_PHY) || defined(CONFIG_MVSWITCH_PHY_MODULE)
++	/* The mvswitch driver has some hard-coded values which could
++	 * easily be turned into a platform resource if needed.  For now they
++	 * match our hardware configuration:
++	 *  MV_BASE    0x10 - phy base address
++	 *  MV_WANPORT 0 - Port0 (ENET2) is WAN (SFP module)
++	 *  MV_CPUPORT 5 - Port5 is CPU NPEA (eth1)
++	 *
++	 * The mvswitch driver registers a fixup which forces a driver match
++	 * if phy_addr matches MV_BASE
++	 *
++	 * Two static defautl VLAN's are created: WAN port in 1, and all other ports
++	 * in the other.
++	 */
++	cambria_npea_data.phy = 0x10; // mvswitch driver catches this
++#else
++	// Switch Port5 to CPU is MII<->MII (no PHY) - this disables the genphy driver
++	cambria_npea_data.phy = IXP4XX_ETH_PHY_MAX_ADDR;
++	// CPU NPE-C is in bridge bypass mode to Port4 PHY@0x14
++	cambria_npec_data.phy = 0x14;
++#endif
++	platform_device_register(&cambria_npec_device);
++	platform_device_register(&cambria_npea_device);
++
++	platform_device_register(&cambria_usb0_device);
++	platform_device_register(&cambria_usb1_device);
++
++	cambria_gpio_leds_data.num_leds = 3;
++	cambria_gpio_leds[0].name = "user1";
++	cambria_gpio_leds[0].gpio = 125; // PNLLED1#
++	cambria_gpio_leds[1].gpio = 126; // PNLLED3#
++	cambria_gpio_leds[2].gpio = 119; // PNLLED4#
++	platform_device_register(&cambria_gpio_leds_device);
++
++#if (defined(CONFIG_INPUT_GPIO_BUTTONS) || defined(CONFIG_INPUT_GPIO_BUTTONS_MODULE))
++	cambria_gpio_buttons[0].gpio = 100;
++	platform_device_register(&cambria_gpio_buttons_device);
++#endif
++
++	/* gpio config (/sys/class/gpio) */
++	cambria_register_gpio(ARRAY_AND_SIZE(cambria_gpios_gw2359));
+ }
+ 
+ static void __init cambria_gw2360_setup(void)
+@@ -693,7 +836,7 @@ static void __init cambria_gw2360_setup(
+ #endif
+ 
+ 	/* gpio config (/sys/class/gpio) */
+-	gpio_request_array(ARRAY_AND_SIZE(cambria_gpios_gw2360));
++	cambria_register_gpio(ARRAY_AND_SIZE(cambria_gpios_gw2360));
+ }
+ 
+ static struct cambria_board_info cambria_boards[] __initdata = {
+@@ -704,6 +847,9 @@ static struct cambria_board_info cambria
+ 		.model	= "GW2358",
+ 		.setup	= cambria_gw2358_setup,
+ 	}, {
++		.model	= "GW2359",
++		.setup	= cambria_gw2359_setup,
++	}, {
+ 		.model	= "GW2360",
+ 		.setup	= cambria_gw2360_setup,
+ 	}, {
Index: trunk/target/linux/ixp4xx/patches-2.6.38/703-avila-pci-usb.patch
===================================================================
--- trunk/target/linux/ixp4xx/patches-2.6.38/703-avila-pci-usb.patch	(revision 0)
+++ trunk/target/linux/ixp4xx/patches-2.6.38/703-avila-pci-usb.patch	(working copy)
@@ -0,0 +1,11 @@
+--- a/arch/arm/mach-ixp4xx/avila-pci.c
++++ b/arch/arm/mach-ixp4xx/avila-pci.c
+@@ -27,7 +27,7 @@
+ #include <mach/hardware.h>
+ #include <asm/mach-types.h>
+ 
+-#define AVILA_MAX_DEV	4
++#define AVILA_MAX_DEV	6
+ #define LOFT_MAX_DEV	6
+ #define IRQ_LINES	4
+ 
Index: trunk/target/linux/ixp4xx/patches-2.6.38/704-avila-dynamic-flashsize.patch
===================================================================
--- trunk/target/linux/ixp4xx/patches-2.6.38/704-avila-dynamic-flashsize.patch	(revision 0)
+++ trunk/target/linux/ixp4xx/patches-2.6.38/704-avila-dynamic-flashsize.patch	(working copy)
@@ -0,0 +1,72 @@
+--- a/arch/arm/mach-ixp4xx/avila-setup.c
++++ b/arch/arm/mach-ixp4xx/avila-setup.c
+@@ -324,7 +324,6 @@ static struct platform_device avila_latc
+ 
+ static struct platform_device *avila_devices[] __initdata = {
+ 	&avila_i2c_gpio,
+-	&avila_flash,
+ 	&avila_uart
+ };
+ 
+@@ -511,6 +510,8 @@ static void __init avila_gw2357_setup(vo
+ 
+ static void __init avila_gw2365_setup(void)
+ {
++	avila_flash_resource.end = IXP4XX_EXP_BUS_BASE(0) + SZ_32M - 1;
++
+ 	*IXP4XX_EXP_CS4 = 0xBFFF3C43;
+ 	set_irq_type(IRQ_IXP4XX_GPIO0, IRQ_TYPE_EDGE_RISING);
+ 	avila_optional_uart_data[0].mapbase = 0x54000000;
+@@ -563,6 +564,8 @@ static void __init avila_gw2365_setup(vo
+ 
+ static void __init avila_gw2369_setup(void)
+ {
++	avila_flash_resource.end = IXP4XX_EXP_BUS_BASE(0) + SZ_32M - 1;
++
+ 	avila_npeb_data.phy = 1;
+ 	platform_device_register(&avila_npeb_device);
+ 
+@@ -574,6 +577,8 @@ static void __init avila_gw2369_setup(vo
+ 
+ static void __init avila_gw2370_setup(void)
+ {
++	avila_flash_resource.end = IXP4XX_EXP_BUS_BASE(0) + SZ_32M - 1;
++
+ 	avila_npeb_data.phy = 5;
+ 	platform_device_register(&avila_npeb_device);
+ 
+@@ -725,14 +730,6 @@ static void __init avila_init(void)
+ {
+ 	ixp4xx_sys_init();
+ 
+-	/*
+-	 * These devices are present on all Avila models and don't need any
+-	 * model specific setup.
+-	 */
+-	avila_flash_resource.start = IXP4XX_EXP_BUS_BASE(0);
+-	avila_flash_resource.end =
+-		IXP4XX_EXP_BUS_BASE(0) + (2 * ixp4xx_exp_bus_size) - 1;
+-
+ 	platform_add_devices(avila_devices, ARRAY_SIZE(avila_devices));
+ 
+ 	i2c_register_board_info(0, avila_i2c_board_info,
+@@ -746,6 +743,10 @@ static int __init avila_model_setup(void
+ 	if (!machine_is_avila())
+ 		return 0;
+ 
++	/* default 16MB flash */
++	avila_flash_resource.start = IXP4XX_EXP_BUS_BASE(0);
++	avila_flash_resource.end = IXP4XX_EXP_BUS_BASE(0) + SZ_16M - 1;
++
+ 	if (avila_info) {
+ 		printk(KERN_DEBUG "Running on Gateworks Avila %s\n",
+ 							avila_info->model);
+@@ -755,6 +756,8 @@ static int __init avila_model_setup(void
+ 						" -- defaults will be used\n");
+ 		avila_gw23xx_setup();
+ 	}
++	platform_device_register(&avila_flash);
++
+ 	return 0;
+ }
+ late_initcall(avila_model_setup);
Index: trunk/target/linux/ixp4xx/patches-2.6.38/705-gw2351_support.patch
===================================================================
--- trunk/target/linux/ixp4xx/patches-2.6.38/705-gw2351_support.patch	(revision 0)
+++ trunk/target/linux/ixp4xx/patches-2.6.38/705-gw2351_support.patch	(working copy)
@@ -0,0 +1,27 @@
+--- a/arch/arm/mach-ixp4xx/cambria-setup.c
++++ b/arch/arm/mach-ixp4xx/cambria-setup.c
+@@ -634,6 +634,14 @@ static void __init cambria_gw2350_setup(
+ 	cambria_register_gpio(ARRAY_AND_SIZE(cambria_gpios_gw2350));
+ }
+ 
++static void __init cambria_gw2351_setup(void)
++{
++	// GW2351 uses GPIO0 for userLED instead of GPIO5 used on GW2350
++	cambria_gpio_leds[0].gpio = 0;
++
++	cambria_gw2350_setup();
++}
++
+ static void __init cambria_gw2358_setup(void)
+ {
+ 	*IXP4XX_EXP_CS3 = 0xBFFF3C43; // bit0 = 16bit vs 8bit bus
+@@ -844,6 +852,9 @@ static struct cambria_board_info cambria
+ 		.model	= "GW2350",
+ 		.setup	= cambria_gw2350_setup,
+ 	}, {
++		.model	= "GW2351",
++		.setup	= cambria_gw2351_setup,
++	}, {
+ 		.model	= "GW2358",
+ 		.setup	= cambria_gw2358_setup,
+ 	}, {
