Index: trunk/target/linux/imx6/base-files/lib/upgrade/platform.sh
===================================================================
--- trunk/target/linux/imx6/base-files/lib/upgrade/platform.sh	(revision 42297)
+++ trunk/target/linux/imx6/base-files/lib/upgrade/platform.sh	(working copy)
@@ -8,7 +8,7 @@
 	local board=$(imx6_board_name)
 
 	case "$board" in
-	gw54xx)
+	gw5*)
 		nand_do_platform_check $board $1
 		return $?;
 		;;
Index: trunk/target/linux/imx6/config-3.14
===================================================================
--- trunk/target/linux/imx6/config-3.14	(revision 42297)
+++ trunk/target/linux/imx6/config-3.14	(working copy)
@@ -44,6 +44,7 @@
 CONFIG_ATAGS=y
 # CONFIG_ATA_SFF is not set
 CONFIG_AUTO_ZRELADDR=y
+CONFIG_BLK_DEV_SD=y
 # CONFIG_CACHE_L2X0 is not set
 CONFIG_CC_OPTIMIZE_FOR_SIZE=y
 CONFIG_CLKDEV_LOOKUP=y
@@ -311,6 +312,7 @@
 CONFIG_RFS_ACCEL=y
 CONFIG_RPS=y
 CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_DS1672=y
 # CONFIG_RTC_DRV_IMXDI is not set
 # CONFIG_RTC_DRV_MXC is not set
 CONFIG_SATA_AHCI_PLATFORM=y
@@ -346,8 +348,24 @@
 CONFIG_UBIFS_FS_ZLIB=y
 CONFIG_UID16=y
 CONFIG_UNCOMPRESS_INCLUDE="debug/uncompress.h"
-# CONFIG_USB_MXS_PHY is not set
+CONFIG_USB=y
+CONFIG_USB_CHIPIDEA=y
+# CONFIG_USB_CHIPIDEA_DEBUG is not set
+CONFIG_USB_CHIPIDEA_HOST=y
+CONFIG_USB_CHIPIDEA_UDC=y
+CONFIG_USB_COMMON=y
+CONFIG_USB_EHCI_HCD=y
+# CONFIG_USB_EHCI_HCD_PLATFORM is not set
+CONFIG_USB_EHCI_MXC=y
+CONFIG_USB_EHCI_PCI=y
+# CONFIG_USB_ETH is not set
+CONFIG_USB_GADGET=y
+# CONFIG_USB_IMX21_HCD is not set
+CONFIG_USB_MXS_PHY=y
+CONFIG_USB_PHY=y
+CONFIG_USB_STORAGE=y
 CONFIG_USB_SUPPORT=y
+# CONFIG_USB_UHCI_HCD is not set
 CONFIG_USE_OF=y
 CONFIG_VECTORS_BASE=0xffff0000
 CONFIG_VFP=y
Index: trunk/target/linux/imx6/files-3.14/arch/arm/boot/dts/imx6dl-gw551x.dts
===================================================================
--- trunk/target/linux/imx6/files-3.14/arch/arm/boot/dts/imx6dl-gw551x.dts	(revision 0)
+++ trunk/target/linux/imx6/files-3.14/arch/arm/boot/dts/imx6dl-gw551x.dts	(working copy)
@@ -0,0 +1,19 @@
+/*
+ * Copyright 2014 Gateworks Corporation
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/dts-v1/;
+#include "imx6dl.dtsi"
+#include "imx6qdl-gw551x.dtsi"
+
+/ {
+	model = "Gateworks Ventana i.MX6 Solo/DualLite GW551X";
+	compatible = "gw,imx6dl-gw551x", "gw,ventana", "fsl,imx6dl";
+};
Index: trunk/target/linux/imx6/files-3.14/arch/arm/boot/dts/imx6qdl-gw551x.dtsi
===================================================================
--- trunk/target/linux/imx6/files-3.14/arch/arm/boot/dts/imx6qdl-gw551x.dtsi	(revision 0)
+++ trunk/target/linux/imx6/files-3.14/arch/arm/boot/dts/imx6qdl-gw551x.dtsi	(working copy)
@@ -0,0 +1,337 @@
+/*
+ * Copyright 2014 Gateworks Corporation
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/ {
+	/* these are used by bootloader for disabling nodes */
+	aliases {
+		can0 = &can1;
+		led0 = &led0;
+		nand = &gpmi;
+		usb0 = &usbh1;
+		usb1 = &usbotg;
+	};
+
+	chosen {
+		bootargs = "console=ttymxc1,115200";
+	};
+
+	leds {
+		compatible = "gpio-leds";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_gpio_leds>;
+
+		led0: user1 {
+			label = "user1";
+			gpios = <&gpio4 7 1>;
+			default-state = "on";
+			linux,default-trigger = "heartbeat";
+		};
+	};
+
+	memory {
+		reg = <0x10000000 0x20000000>;
+	};
+
+	regulators {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		reg_5p0v: regulator@1 {
+			compatible = "regulator-fixed";
+			reg = <1>;
+			regulator-name = "5P0V";
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			regulator-always-on;
+		};
+		reg_usb_otg_vbus: regulator@2 {
+			compatible = "regulator-fixed";
+			reg = <2>;
+			regulator-name = "OTG_VBUS";
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			regulator-always-on;
+		};
+	};
+};
+
+&can1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_flexcan1>;
+	status = "okay";
+};
+
+&gpmi {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_gpmi_nand>;
+	status = "okay";
+};
+
+&i2c1 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c1>;
+	status = "okay";
+
+	eeprom1: eeprom@50 {
+		compatible = "atmel,24c02";
+		reg = <0x50>;
+		pagesize = <16>;
+	};
+
+	eeprom2: eeprom@51 {
+		compatible = "atmel,24c02";
+		reg = <0x51>;
+		pagesize = <16>;
+	};
+
+	eeprom3: eeprom@52 {
+		compatible = "atmel,24c02";
+		reg = <0x52>;
+		pagesize = <16>;
+	};
+
+	eeprom4: eeprom@53 {
+		compatible = "atmel,24c02";
+		reg = <0x53>;
+		pagesize = <16>;
+	};
+
+	gpio: pca9555@23 {
+		compatible = "nxp,pca9555";
+		reg = <0x23>;
+		gpio-controller;
+		#gpio-cells = <2>;
+	};
+
+	hwmon: gsc@29 {
+		compatible = "gw,gsp";
+		reg = <0x29>;
+	};
+
+	rtc: ds1672@68 {
+		compatible = "dallas,ds1672";
+		reg = <0x68>;
+	};
+};
+
+&i2c2 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c2>;
+	status = "okay";
+
+	ltc3676: pmic@3c {
+		compatible = "lltc,ltc3676";
+		reg = <0x3c>;
+		interrupt-parent = <&gpio1>;
+		interrupts = <8 2>;
+
+		regulators {
+			/* VDD_SOC (1+R1/R2 = 1.635) */
+			reg_vdd_soc: sw1 {
+				regulator-min-microvolt = <674400>;
+				regulator-max-microvolt = <1308000>;
+				lltc,fb-voltage-divider = <127000 200000>;
+				regulator-ramp-delay = <7000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			/* VDD_DDR (1+R1/R2 = 2.105) */
+			reg_vdd_ddr: sw2 {
+				regulator-min-microvolt = <868310>;
+				regulator-max-microvolt = <1684000>;
+				lltc,fb-voltage-divider = <221000 200000>;
+				regulator-ramp-delay = <7000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			/* VDD_ARM (1+R1/R2 = 1.635) */
+			reg_vdd_arm: sw3 {
+				regulator-min-microvolt = <674400>;
+				regulator-max-microvolt = <1308000>;
+				lltc,fb-voltage-divider = <127000 200000>;
+				regulator-ramp-delay = <7000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			/* VDD_3P3 (1+R1/R2 = 1.281) */
+			reg_3p3: sw4 {
+				regulator-min-microvolt = <1880000>;
+				regulator-max-microvolt = <3647000>;
+				lltc,fb-voltage-divider = <200000 56200>;
+				regulator-ramp-delay = <7000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			/* VDD_1P8a (1+R1/R2 = 2.505): HDMI In core */
+			reg_1p8a: ldo2 {
+				regulator-min-microvolt = <1816125>;
+				regulator-max-microvolt = <1816125>;
+				lltc,fb-voltage-divider = <301000 200000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			/* VDD_1P8b: HDMI In analog */
+			reg_1p8b: ldo3 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-boot-on;
+			};
+
+			/* VDD_HIGH (1+R1/R2 = 4.17) */
+			reg_3p0: ldo4 {
+				regulator-min-microvolt = <3023250>;
+				regulator-max-microvolt = <3023250>;
+				lltc,fb-voltage-divider = <634000 200000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+		};
+	};
+};
+
+&i2c3 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c3>;
+	status = "okay";
+
+	gpio_exp: pca9555@24 {
+		compatible = "nxp,pca9555";
+		reg = <0x24>;
+		gpio-controller;
+		#gpio-cells = <2>;
+	};
+};
+
+&iomuxc {
+	imx6qdl-gw51xx {
+		pinctrl_flexcan1: flexcan1grp {
+			fsl,pins = <
+				MX6QDL_PAD_KEY_ROW2__FLEXCAN1_RX	0x1b0b1
+				MX6QDL_PAD_KEY_COL2__FLEXCAN1_TX	0x1b0b1
+				MX6QDL_PAD_GPIO_9__GPIO1_IO09		0x4001b0b0 /* CAN_STBY */
+			>;
+		};
+
+		pinctrl_gpio_leds: gpioledsgrp {
+			fsl,pins = <
+				MX6QDL_PAD_KEY_ROW0__GPIO4_IO07		0x1b0b0
+			>;
+		};
+
+		pinctrl_gpmi_nand: gpminandgrp {
+			fsl,pins = <
+				MX6QDL_PAD_NANDF_CLE__NAND_CLE		0xb0b1
+				MX6QDL_PAD_NANDF_ALE__NAND_ALE		0xb0b1
+				MX6QDL_PAD_NANDF_WP_B__NAND_WP_B	0xb0b1
+				MX6QDL_PAD_NANDF_RB0__NAND_READY_B	0xb000
+				MX6QDL_PAD_NANDF_CS0__NAND_CE0_B	0xb0b1
+				MX6QDL_PAD_NANDF_CS1__NAND_CE1_B	0xb0b1
+				MX6QDL_PAD_SD4_CMD__NAND_RE_B		0xb0b1
+				MX6QDL_PAD_SD4_CLK__NAND_WE_B		0xb0b1
+				MX6QDL_PAD_NANDF_D0__NAND_DATA00	0xb0b1
+				MX6QDL_PAD_NANDF_D1__NAND_DATA01	0xb0b1
+				MX6QDL_PAD_NANDF_D2__NAND_DATA02	0xb0b1
+				MX6QDL_PAD_NANDF_D3__NAND_DATA03	0xb0b1
+				MX6QDL_PAD_NANDF_D4__NAND_DATA04	0xb0b1
+				MX6QDL_PAD_NANDF_D5__NAND_DATA05	0xb0b1
+				MX6QDL_PAD_NANDF_D6__NAND_DATA06	0xb0b1
+				MX6QDL_PAD_NANDF_D7__NAND_DATA07	0xb0b1
+			>;
+		};
+
+		pinctrl_i2c1: i2c1grp {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_D21__I2C1_SCL	0x4001b8b1
+				MX6QDL_PAD_EIM_D28__I2C1_SDA	0x4001b8b1
+			>;
+		};
+
+		pinctrl_i2c2: i2c2grp {
+			fsl,pins = <
+				MX6QDL_PAD_KEY_COL3__I2C2_SCL	0x4001b8b1
+				MX6QDL_PAD_KEY_ROW3__I2C2_SDA	0x4001b8b1
+			>;
+		};
+
+		pinctrl_i2c3: i2c3grp {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_3__I2C3_SCL	0x4001b8b1
+				MX6QDL_PAD_GPIO_6__I2C3_SDA	0x4001b8b1
+			>;
+		};
+
+		pinctrl_pcie: pciegrp {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_0__GPIO1_IO00		0x1b0b0
+			>;
+		};
+
+		pinctrl_uart2: uart2grp {
+			fsl,pins = <
+				MX6QDL_PAD_SD4_DAT7__UART2_TX_DATA	0x1b0b1
+				MX6QDL_PAD_SD4_DAT4__UART2_RX_DATA	0x1b0b1
+			>;
+		};
+
+		pinctrl_uart3: uart3grp {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_D24__UART3_TX_DATA	0x1b0b1
+				MX6QDL_PAD_EIM_D25__UART3_RX_DATA	0x1b0b1
+			>;
+		};
+
+		pinctrl_usbotg: usbotggrp {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_1__USB_OTG_ID		0x17059
+			>;
+		};
+	};
+};
+
+&pcie {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pcie>;
+	reset-gpio = <&gpio1 0 0>;
+	status = "okay";
+};
+
+&uart2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart2>;
+	status = "okay";
+};
+
+&uart3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart3>;
+	status = "okay";
+};
+
+&usbotg {
+	vbus-supply = <&reg_usb_otg_vbus>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usbotg>;
+	disable-over-current;
+	status = "okay";
+};
+
+&usbh1 {
+	status = "okay";
+};
Index: trunk/target/linux/imx6/files-3.14/arch/arm/boot/dts/imx6q-gw551x.dts
===================================================================
--- trunk/target/linux/imx6/files-3.14/arch/arm/boot/dts/imx6q-gw551x.dts	(revision 0)
+++ trunk/target/linux/imx6/files-3.14/arch/arm/boot/dts/imx6q-gw551x.dts	(working copy)
@@ -0,0 +1,19 @@
+/*
+ * Copyright 2014 Gateworks Corporation
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/dts-v1/;
+#include "imx6q.dtsi"
+#include "imx6qdl-gw551x.dtsi"
+
+/ {
+	model = "Gateworks Ventana i.MX6 Dual/Quad GW551X";
+	compatible = "gw,imx6q-gw551x", "gw,ventana", "fsl,imx6q";
+};
Index: trunk/target/linux/imx6/files-3.14/drivers/input/misc/mma8451.c
===================================================================
--- trunk/target/linux/imx6/files-3.14/drivers/input/misc/mma8451.c	(revision 0)
+++ trunk/target/linux/imx6/files-3.14/drivers/input/misc/mma8451.c	(working copy)
@@ -0,0 +1,719 @@
+/*
+ *  mma8451.c - Linux kernel modules for 3-Axis Orientation/Motion
+ *  Detection Sensor
+ *
+ *  Copyright (C) 2010-2013 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/pm.h>
+#include <linux/mutex.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/err.h>
+#include <linux/input-polldev.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#define MMA8451_I2C_ADDR	0x1C
+#define MMA8451_ID		0x1A
+#define MMA8452_ID		0x2A
+#define MMA8453_ID		0x3A
+#define FXOS8700_ID		0xC7
+
+#define POLL_INTERVAL_MIN	1
+#define POLL_INTERVAL_MAX	500
+#define POLL_INTERVAL		100	/* msecs */
+#define INPUT_FUZZ		32
+#define INPUT_FLAT		32
+#define MODE_CHANGE_DELAY_MS	100
+
+#define MMA8451_STATUS_ZYXDR	0x08
+#define MMA8451_BUF_SIZE	7
+#define DEFAULT_POSITION	0
+
+/* register enum for mma8451 registers */
+enum {
+	MMA8451_STATUS = 0x00,
+	MMA8451_OUT_X_MSB,
+	MMA8451_OUT_X_LSB,
+	MMA8451_OUT_Y_MSB,
+	MMA8451_OUT_Y_LSB,
+	MMA8451_OUT_Z_MSB,
+	MMA8451_OUT_Z_LSB,
+
+	MMA8451_F_SETUP = 0x09,
+	MMA8451_TRIG_CFG,
+	MMA8451_SYSMOD,
+	MMA8451_INT_SOURCE,
+	MMA8451_WHO_AM_I,
+	MMA8451_XYZ_DATA_CFG,
+	MMA8451_HP_FILTER_CUTOFF,
+
+	MMA8451_PL_STATUS,
+	MMA8451_PL_CFG,
+	MMA8451_PL_COUNT,
+	MMA8451_PL_BF_ZCOMP,
+	MMA8451_P_L_THS_REG,
+
+	MMA8451_FF_MT_CFG,
+	MMA8451_FF_MT_SRC,
+	MMA8451_FF_MT_THS,
+	MMA8451_FF_MT_COUNT,
+
+	MMA8451_TRANSIENT_CFG = 0x1D,
+	MMA8451_TRANSIENT_SRC,
+	MMA8451_TRANSIENT_THS,
+	MMA8451_TRANSIENT_COUNT,
+
+	MMA8451_PULSE_CFG,
+	MMA8451_PULSE_SRC,
+	MMA8451_PULSE_THSX,
+	MMA8451_PULSE_THSY,
+	MMA8451_PULSE_THSZ,
+	MMA8451_PULSE_TMLT,
+	MMA8451_PULSE_LTCY,
+	MMA8451_PULSE_WIND,
+
+	MMA8451_ASLP_COUNT,
+	MMA8451_CTRL_REG1,
+	MMA8451_CTRL_REG2,
+	MMA8451_CTRL_REG3,
+	MMA8451_CTRL_REG4,
+	MMA8451_CTRL_REG5,
+
+	MMA8451_OFF_X,
+	MMA8451_OFF_Y,
+	MMA8451_OFF_Z,
+
+	FXOS8700_M_DR_STATUS,
+	FXOS8700_M_OUT_X_MSB,
+	FXOS8700_M_OUT_X_LSB,
+	FXOS8700_M_OUT_Y_MSB,
+	FXOS8700_M_OUT_Y_LSB,
+	FXOS8700_M_OUT_Z_MSB,
+	FXOS8700_M_OUT_Z_LSB,
+
+	FXOS8700_M_CTRL_REG1 = 0x5B,
+
+	MMA8451_REG_END,
+};
+
+/* The sensitivity is represented in counts/g. In 2g mode the
+sensitivity is 1024 counts/g. In 4g mode the sensitivity is 512
+counts/g and in 8g mode the sensitivity is 256 counts/g.
+ */
+enum {
+	MODE_2G = 0,
+	MODE_4G,
+	MODE_8G,
+};
+
+enum {
+	MMA_STANDBY = 0,
+	MMA_ACTIVED,
+};
+
+enum {
+	FXOS_ACCEL_ONLY = 0,
+	FXOS_MAG_ONLY,
+	FXOS_NONE,
+	FXOS_HYBRID,
+};
+
+/* mma8451 status */
+struct mma8451_status {
+	u8 mode;
+	u8 ctl_reg1;
+	int active;
+	int position;
+	int hybrid_mode;
+};
+
+static struct mma8451_status mma_status;
+static struct input_polled_dev *mma8451_idev;
+static struct input_polled_dev *fxos8700_m_idev;
+static struct i2c_client *mma8451_i2c_client;
+static int client_id;
+
+static int senstive_mode = MODE_2G;
+static int ACCHAL[8][3][3] = {
+	{ {0, -1, 0}, {1, 0, 0}, {0, 0, 1} },
+	{ {-1, 0, 0}, {0, -1, 0}, {0, 0, 1} },
+	{ {0, 1, 0}, {-1, 0, 0}, {0, 0, 1} },
+	{ {1, 0, 0}, {0, 1, 0}, {0, 0, 1} },
+
+	{ {0, -1, 0}, {-1, 0, 0}, {0, 0, -1} },
+	{ {-1, 0, 0}, {0, 1, 0}, {0, 0, -1} },
+	{ {0, 1, 0}, {1, 0, 0}, {0, 0, -1} },
+	{ {1, 0, 0}, {0, -1, 0}, {0, 0, -1} },
+};
+
+static DEFINE_MUTEX(mma8451_lock);
+static int mma8451_adjust_position(short *x, short *y, short *z)
+{
+	short rawdata[3], data[3];
+	int i, j;
+	int position = mma_status.position;
+	if (position < 0 || position > 7)
+		position = 0;
+	rawdata[0] = *x;
+	rawdata[1] = *y;
+	rawdata[2] = *z;
+	for (i = 0; i < 3; i++) {
+		data[i] = 0;
+		for (j = 0; j < 3; j++)
+			data[i] += rawdata[j] * ACCHAL[position][i][j];
+	}
+	*x = data[0];
+	*y = data[1];
+	*z = data[2];
+	return 0;
+}
+
+static int mma8451_change_mode(struct i2c_client *client, int mode)
+{
+	int result;
+
+	mma_status.ctl_reg1 = 0;
+	result = i2c_smbus_write_byte_data(client, MMA8451_CTRL_REG1, 0);
+	if (result < 0)
+		goto out;
+	mma_status.active = MMA_STANDBY;
+
+	if (client_id == FXOS8700_ID) {
+		mma_status.hybrid_mode = FXOS_HYBRID;
+		result = i2c_smbus_write_byte_data(client, FXOS8700_M_CTRL_REG1, FXOS_HYBRID);
+		if (result < 0)
+			goto out;
+	}
+
+	mma_status.mode = mode;
+	result = i2c_smbus_write_byte_data(client, MMA8451_XYZ_DATA_CFG,
+					   mode);
+	if (result < 0)
+		goto out;
+	mdelay(MODE_CHANGE_DELAY_MS);
+	mma_status.mode = mode;
+
+	return 0;
+out:
+	dev_err(&client->dev, "error when init mma8451:(%d)", result);
+	return result;
+}
+
+static int mma8451_read_data(struct input_polled_dev *idev,
+		short *x, short *y, short *z)
+{
+	u8 tmp_data[MMA8451_BUF_SIZE];
+	char reg = (idev == mma8451_idev)?MMA8451_OUT_X_MSB:FXOS8700_M_OUT_X_MSB;
+	int ret;
+
+	ret = i2c_smbus_read_i2c_block_data(mma8451_i2c_client,
+					    reg, 7, tmp_data);
+	if (ret < MMA8451_BUF_SIZE) {
+		dev_err(&mma8451_i2c_client->dev, "i2c block read failed\n");
+		return -EIO;
+	}
+
+	*x = ((tmp_data[0] << 8) & 0xff00) | tmp_data[1];
+	*y = ((tmp_data[2] << 8) & 0xff00) | tmp_data[3];
+	*z = ((tmp_data[4] << 8) & 0xff00) | tmp_data[5];
+	return 0;
+}
+
+static void report_abs(struct input_polled_dev *idev)
+{
+	short x, y, z;
+	int result;
+	int retry = 3;
+	char reg = (idev == mma8451_idev)?MMA8451_STATUS:FXOS8700_M_DR_STATUS;
+
+	mutex_lock(&mma8451_lock);
+	if (mma_status.active == MMA_STANDBY)
+		goto out;
+	/* wait for the data ready */
+	do {
+		result = i2c_smbus_read_byte_data(mma8451_i2c_client, reg);
+		retry--;
+		msleep(1);
+	} while (!(result & MMA8451_STATUS_ZYXDR) && retry > 0);
+	if (retry == 0)
+		goto out;
+	if (mma8451_read_data(idev, &x, &y, &z) != 0)
+		goto out;
+	mma8451_adjust_position(&x, &y, &z);
+	input_report_abs(idev->input, ABS_X, x);
+	input_report_abs(idev->input, ABS_Y, y);
+	input_report_abs(idev->input, ABS_Z, z);
+	input_sync(idev->input);
+out:
+	mutex_unlock(&mma8451_lock);
+}
+
+static void mma8451_dev_poll(struct input_polled_dev *dev)
+{
+	report_abs(dev);
+}
+
+static ssize_t mma8451_enable_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct input_polled_dev *idev = dev_get_drvdata(dev);
+	struct i2c_client *client;
+	u8 val;
+	int enable = 0;
+
+	mutex_lock(&mma8451_lock);
+	client = mma8451_i2c_client;
+	val = i2c_smbus_read_byte_data(client, MMA8451_CTRL_REG1);
+	if ((val & 0x01) && mma_status.active == MMA_ACTIVED) {
+		if (client_id == FXOS8700_ID) {
+			if (mma_status.hybrid_mode == FXOS_HYBRID)
+				enable = 1;
+			else if (mma_status.hybrid_mode == FXOS_ACCEL_ONLY
+				&& idev == mma8451_idev)
+				enable = 1;
+			else if (mma_status.hybrid_mode == FXOS_MAG_ONLY)
+				enable = 1;
+		}
+		else
+			enable = 1;
+	}
+	mutex_unlock(&mma8451_lock);
+	return sprintf(buf, "%d\n", enable);
+}
+
+static ssize_t mma8451_enable_store(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+	struct input_polled_dev *idev = dev_get_drvdata(dev);
+	struct i2c_client *client;
+	int ret;
+	unsigned long enable;
+	u8 val = 0;
+
+	ret = strict_strtoul(buf, 10, &enable);
+	if (ret) {
+		dev_err(dev, "string transform error\n");
+		return ret;
+	}
+
+	mutex_lock(&mma8451_lock);
+	client = mma8451_i2c_client;
+	enable = (enable > 0) ? 1 : 0;
+	if (client_id == FXOS8700_ID) {
+		val = mma_status.hybrid_mode;
+		if (idev == mma8451_idev) {
+			if (enable) {
+				if (val == FXOS_NONE)
+					val = FXOS_ACCEL_ONLY;
+				else if (val == FXOS_MAG_ONLY)
+					val = FXOS_HYBRID;
+			} else {
+				if (val == FXOS_HYBRID)
+					val = FXOS_MAG_ONLY;
+				else if (val == FXOS_ACCEL_ONLY)
+					val = FXOS_NONE;
+			}
+		} else {
+			if (enable) {
+				if (val == FXOS_NONE)
+					val = FXOS_MAG_ONLY;
+				else if (val == FXOS_ACCEL_ONLY)
+					val = FXOS_HYBRID;
+			} else {
+				if (val == FXOS_HYBRID)
+					val = FXOS_ACCEL_ONLY;
+				else if (val == FXOS_MAG_ONLY)
+					val = FXOS_NONE;
+			}
+		}
+/*
+		if (val != FXOS_NONE) {
+			ret = i2c_smbus_write_byte_data(client,
+				FXOS8700_M_CTRL_REG1, val & 0x03);
+		}
+*/
+		mma_status.hybrid_mode = val;
+		if (mma_status.hybrid_mode == FXOS_NONE)
+			enable = 0;
+		else
+			enable = 1;
+	}
+	if (enable && mma_status.active == MMA_STANDBY) {
+		val = i2c_smbus_read_byte_data(client, MMA8451_CTRL_REG1);
+		ret =
+		    i2c_smbus_write_byte_data(client, MMA8451_CTRL_REG1,
+					      val | 0x01);
+		if (!ret)
+			mma_status.active = MMA_ACTIVED;
+
+	} else if (enable == 0 && mma_status.active == MMA_ACTIVED) {
+		val = i2c_smbus_read_byte_data(client, MMA8451_CTRL_REG1);
+		ret =
+		    i2c_smbus_write_byte_data(client, MMA8451_CTRL_REG1,
+					      val & 0xFE);
+		if (!ret)
+			mma_status.active = MMA_STANDBY;
+
+	}
+	mutex_unlock(&mma8451_lock);
+	return count;
+}
+
+static ssize_t mma8451_position_show(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	int position = 0;
+	mutex_lock(&mma8451_lock);
+	position = mma_status.position;
+	mutex_unlock(&mma8451_lock);
+	return sprintf(buf, "%d\n", position);
+}
+
+static ssize_t mma8451_position_store(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf, size_t count)
+{
+	unsigned long  position;
+	int ret;
+	ret = strict_strtoul(buf, 10, &position);
+	if (ret) {
+		dev_err(dev, "string transform error\n");
+		return ret;
+	}
+
+	mutex_lock(&mma8451_lock);
+	mma_status.position = (int)position;
+	mutex_unlock(&mma8451_lock);
+	return count;
+}
+
+static ssize_t mma8451_scalemode_show(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	int mode = 0;
+	mutex_lock(&mma8451_lock);
+	mode = (int)mma_status.mode;
+	mutex_unlock(&mma8451_lock);
+
+	return sprintf(buf, "%d\n", mode);
+}
+
+static ssize_t mma8451_scalemode_store(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t count)
+{
+	unsigned long  mode;
+	int ret, active_save;
+	struct i2c_client *client = mma8451_i2c_client;
+
+	ret = strict_strtoul(buf, 10, &mode);
+	if (ret) {
+		dev_err(dev, "string transform error\n");
+		goto out;
+	}
+
+	if (mode > MODE_8G) {
+		dev_warn(dev, "not supported mode\n");
+		ret = count;
+		goto out;
+	}
+
+	mutex_lock(&mma8451_lock);
+	if (mode == mma_status.mode) {
+		ret = count;
+		goto out_unlock;
+	}
+
+	active_save = mma_status.active;
+	ret = mma8451_change_mode(client, mode);
+	if (ret)
+		goto out_unlock;
+
+	if (active_save == MMA_ACTIVED) {
+		ret = i2c_smbus_write_byte_data(client, MMA8451_CTRL_REG1, 1);
+
+		if (ret)
+			goto out_unlock;
+		mma_status.active = active_save;
+	}
+
+out_unlock:
+	mutex_unlock(&mma8451_lock);
+out:
+	return ret;
+}
+
+static DEVICE_ATTR(enable, S_IWUSR | S_IRUGO,
+			mma8451_enable_show, mma8451_enable_store);
+static DEVICE_ATTR(position, S_IWUSR | S_IRUGO,
+			mma8451_position_show, mma8451_position_store);
+static DEVICE_ATTR(scalemode, S_IWUSR | S_IRUGO,
+			mma8451_scalemode_show, mma8451_scalemode_store);
+
+static struct attribute *mma8451_attributes[] = {
+	&dev_attr_enable.attr,
+	&dev_attr_position.attr,
+	&dev_attr_scalemode.attr,
+	NULL
+};
+
+static const struct attribute_group mma8451_attr_group = {
+	.attrs = mma8451_attributes,
+};
+
+static int mma8451_probe(struct i2c_client *client,
+				   const struct i2c_device_id *id)
+{
+	int result;
+	struct input_dev *idev;
+	struct i2c_adapter *adapter;
+	u32 pos;
+	struct device_node *of_node = client->dev.of_node;
+	struct regulator *vdd, *vdd_io;
+
+	mma8451_i2c_client = client;
+
+	vdd = devm_regulator_get(&client->dev, "vdd");
+	if (!IS_ERR(vdd)) {
+		result = regulator_enable(vdd);
+		if (result) {
+			dev_err(&client->dev, "vdd set voltage error\n");
+			return result;
+		}
+	}
+
+	vdd_io = devm_regulator_get(&client->dev, "vddio");
+	if (!IS_ERR(vdd_io)) {
+		result = regulator_enable(vdd_io);
+		if (result) {
+			dev_err(&client->dev, "vddio set voltage error\n");
+			return result;
+		}
+	}
+
+	adapter = to_i2c_adapter(client->dev.parent);
+	result = i2c_check_functionality(adapter,
+					 I2C_FUNC_SMBUS_BYTE |
+					 I2C_FUNC_SMBUS_BYTE_DATA);
+	if (!result)
+		goto err_out;
+
+	client_id = i2c_smbus_read_byte_data(client, MMA8451_WHO_AM_I);
+	if (client_id != MMA8451_ID && client_id != MMA8452_ID
+	    && client_id != MMA8453_ID && client_id != FXOS8700_ID) {
+		dev_err(&client->dev,
+			"read chip ID 0x%x is not equal to 0x%x,0x%x,0x%x!\n",
+			result, MMA8451_ID, MMA8452_ID, FXOS8700_ID);
+		result = -EINVAL;
+		goto err_out;
+	}
+
+	/* Initialize the MMA8451 chip */
+	result = mma8451_change_mode(client, senstive_mode);
+	if (result) {
+		dev_err(&client->dev,
+			"error when init mma8451 chip:(%d)\n", result);
+		goto err_out;
+	}
+
+	/* create a polled input device for accelerometer */
+	mma8451_idev = input_allocate_polled_device();
+	if (!mma8451_idev) {
+		result = -ENOMEM;
+		dev_err(&client->dev, "alloc poll device failed!\n");
+		goto err_register_polled_device;
+	}
+	mma8451_idev->poll = mma8451_dev_poll;
+	mma8451_idev->poll_interval = POLL_INTERVAL;
+	mma8451_idev->poll_interval_min = POLL_INTERVAL_MIN;
+	mma8451_idev->poll_interval_max = POLL_INTERVAL_MAX;
+	idev = mma8451_idev->input;
+	if (client_id == FXOS8700_ID)
+		idev->name = "mma845x_a";
+	else
+		idev->name = "mma845x";
+	idev->id.bustype = BUS_I2C;
+	idev->evbit[0] = BIT_MASK(EV_ABS);
+
+	input_set_abs_params(idev, ABS_X, -8192, 8191, INPUT_FUZZ, INPUT_FLAT);
+	input_set_abs_params(idev, ABS_Y, -8192, 8191, INPUT_FUZZ, INPUT_FLAT);
+	input_set_abs_params(idev, ABS_Z, -8192, 8191, INPUT_FUZZ, INPUT_FLAT);
+
+	result = input_register_polled_device(mma8451_idev);
+	if (result) {
+		dev_err(&client->dev, "register poll device failed!\n");
+		goto err_register_polled_device;
+	}
+	result = sysfs_create_group(&idev->dev.kobj, &mma8451_attr_group);
+	if (result) {
+		dev_err(&client->dev, "create device file failed!\n");
+		result = -EINVAL;
+		goto err_register_polled_device;
+	}
+
+	/* create a polled input device for magnetometer */
+	if (client_id == FXOS8700_ID) {
+		fxos8700_m_idev = input_allocate_polled_device();
+		if (!fxos8700_m_idev) {
+			result = -ENOMEM;
+			dev_err(&client->dev, "alloc poll device failed!\n");
+			goto err_alloc_poll_device;
+		}
+		fxos8700_m_idev->poll = mma8451_dev_poll;
+		fxos8700_m_idev->poll_interval = POLL_INTERVAL;
+		fxos8700_m_idev->poll_interval_min = POLL_INTERVAL_MIN;
+		fxos8700_m_idev->poll_interval_max = POLL_INTERVAL_MAX;
+		idev = fxos8700_m_idev->input;
+		idev->name = "fxos8700_m";
+		idev->id.bustype = BUS_I2C;
+		idev->evbit[0] = BIT_MASK(EV_ABS);
+
+		input_set_abs_params(idev, ABS_X, -8192, 8191, INPUT_FUZZ, INPUT_FLAT);
+		input_set_abs_params(idev, ABS_Y, -8192, 8191, INPUT_FUZZ, INPUT_FLAT);
+		input_set_abs_params(idev, ABS_Z, -8192, 8191, INPUT_FUZZ, INPUT_FLAT);
+
+		result = input_register_polled_device(fxos8700_m_idev);
+		if (result) {
+			dev_err(&client->dev, "register poll device failed!\n");
+			goto err_register_polled_device1;
+		}
+		result = sysfs_create_group(&idev->dev.kobj, &mma8451_attr_group);
+		if (result) {
+			dev_err(&client->dev, "create device file failed!\n");
+			result = -EINVAL;
+			goto err_create_sysfs1;
+		}
+	}
+
+	result = of_property_read_u32(of_node, "position", &pos);
+	if (result)
+		pos = DEFAULT_POSITION;
+	mma_status.position = (int)pos;
+
+	return 0;
+
+err_create_sysfs1:
+	input_unregister_polled_device(fxos8700_m_idev);
+err_register_polled_device1:
+	input_free_polled_device(fxos8700_m_idev);
+err_alloc_poll_device:
+err_register_polled_device:
+	input_free_polled_device(mma8451_idev);
+err_out:
+	return result;
+}
+
+static int mma8451_stop_chip(struct i2c_client *client)
+{
+	int ret = 0;
+	if (mma_status.active == MMA_ACTIVED) {
+		mma_status.ctl_reg1 = i2c_smbus_read_byte_data(client,
+							       MMA8451_CTRL_REG1);
+		ret = i2c_smbus_write_byte_data(client, MMA8451_CTRL_REG1,
+						mma_status.ctl_reg1 & 0xFE);
+	}
+	return ret;
+}
+
+static int mma8451_remove(struct i2c_client *client)
+{
+	int ret;
+	ret = mma8451_stop_chip(client);
+
+	if (client_id == FXOS8700_ID) {
+		input_unregister_polled_device(fxos8700_m_idev);
+		input_free_polled_device(fxos8700_m_idev);
+	}
+	input_unregister_polled_device(mma8451_idev);
+	input_free_polled_device(mma8451_idev);
+
+	return ret;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int mma8451_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+
+	return mma8451_stop_chip(client);
+}
+
+static int mma8451_resume(struct device *dev)
+{
+	int ret = 0;
+	struct i2c_client *client = to_i2c_client(dev);
+	if (mma_status.active == MMA_ACTIVED)
+		ret = i2c_smbus_write_byte_data(client, MMA8451_CTRL_REG1,
+						mma_status.ctl_reg1);
+	return ret;
+
+}
+#endif
+
+static const struct i2c_device_id mma8451_id[] = {
+	{"mma8451", 0},
+	{"fxos8700", 0},
+	{ }
+};
+
+MODULE_DEVICE_TABLE(i2c, mma8451_id);
+
+static SIMPLE_DEV_PM_OPS(mma8451_pm_ops, mma8451_suspend, mma8451_resume);
+static struct i2c_driver mma8451_driver = {
+	.driver = {
+		   .name = "mma8451",
+		   .owner = THIS_MODULE,
+		   .pm = &mma8451_pm_ops,
+		   },
+	.probe = mma8451_probe,
+	.remove = mma8451_remove,
+	.id_table = mma8451_id,
+};
+
+static int __init mma8451_init(void)
+{
+	/* register driver */
+	int res;
+
+	res = i2c_add_driver(&mma8451_driver);
+	if (res < 0) {
+		printk(KERN_INFO "add mma8451 i2c driver failed\n");
+		return -ENODEV;
+	}
+	return res;
+}
+
+static void __exit mma8451_exit(void)
+{
+	i2c_del_driver(&mma8451_driver);
+}
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("MMA8451 3-Axis Orientation/Motion Detection Sensor driver");
+MODULE_LICENSE("GPL");
+
+module_init(mma8451_init);
+module_exit(mma8451_exit);
Index: trunk/target/linux/imx6/files-3.14/drivers/net/phy/gw16083.c
===================================================================
--- trunk/target/linux/imx6/files-3.14/drivers/net/phy/gw16083.c	(revision 42297)
+++ trunk/target/linux/imx6/files-3.14/drivers/net/phy/gw16083.c	(working copy)
@@ -485,9 +485,13 @@
 					state->sfp_compat = false;
 				else
 					state->sfp_compat = true;
+				/* trigger a re-select/enable below */
+				state->serdes = !serdes;
+				pdev->state = PHY_RUNNING;
 			} else {
 				state->sfp_compat = false;
 				state->sfp_enabled = false;
+				pdev->state = PHY_NOLINK;
 			}
 		}
 		if (state->sfp_signal != sfp_signal) {
@@ -510,11 +514,8 @@
 			}
 		}
 
-		/*
-		 * if serdes and compatible SFP module and not yet enabled
-		 * then enable for serdes
-		 */
-		if (serdes && state->sfp_compat && state->sfp_signal &&
+		/* if compatible SFP module and not yet enabled then enable */
+		if (state->sfp_compat && state->sfp_signal &&
 		    !state->sfp_enabled)
 		{
 			if (!config_mv88e1111_port_sfp(pdev, port, 1))
Index: trunk/target/linux/imx6/patches-3.14/0009-ARM-imx-dts-add-GW52xx-can-support.patch
===================================================================
--- trunk/target/linux/imx6/patches-3.14/0009-ARM-imx-dts-add-GW52xx-can-support.patch	(revision 0)
+++ trunk/target/linux/imx6/patches-3.14/0009-ARM-imx-dts-add-GW52xx-can-support.patch	(working copy)
@@ -0,0 +1,45 @@
+--- a/arch/arm/boot/dts/imx6qdl-gw52xx.dtsi
++++ b/arch/arm/boot/dts/imx6qdl-gw52xx.dtsi
+@@ -12,6 +12,7 @@
+ / {
+ 	/* these are used by bootloader for disabling nodes */
+ 	aliases {
++		can0 = &can1;
+ 		ethernet0 = &fec;
+ 		led0 = &led0;
+ 		led1 = &led1;
+@@ -142,6 +143,12 @@
+ 	status = "okay";
+ };
+ 
++&can1 {
++	pinctrl-names = "default";
++	pinctrl-0 = <&pinctrl_flexcan1>;
++	status = "okay";
++};
++
+ &fec {
+ 	pinctrl-names = "default";
+ 	pinctrl-0 = <&pinctrl_enet>;
+@@ -325,6 +332,7 @@
+ 				MX6QDL_PAD_ENET_RXD1__GPIO1_IO26 0x80000000 /* GPS_PPS */
+ 				MX6QDL_PAD_GPIO_0__CCM_CLKO1     0x000130b0 /* AUD4_MCK */
+ 				MX6QDL_PAD_GPIO_2__GPIO1_IO02    0x80000000 /* USB_SEL_PCI */
++				MX6QDL_PAD_GPIO_9__GPIO1_IO09    0x80000000 /* CAN_STBY */
+ 				MX6QDL_PAD_GPIO_17__GPIO7_IO12   0x80000000 /* TOUCH_IRQ# */
+ 				MX6QDL_PAD_KEY_COL0__GPIO4_IO06  0x80000000 /* user1 led */
+ 				MX6QDL_PAD_KEY_ROW0__GPIO4_IO07  0x80000000 /* user2 led */
+@@ -365,6 +373,13 @@
+ 			>;
+ 		};
+ 
++		pinctrl_flexcan1: flexcan1grp {
++			fsl,pins = <
++				MX6QDL_PAD_KEY_ROW2__FLEXCAN1_RX	0x80000000
++				MX6QDL_PAD_KEY_COL2__FLEXCAN1_TX	0x80000000
++			>;
++		};
++
+ 		pinctrl_gpmi_nand: gpminandgrp {
+ 			fsl,pins = <
+ 				MX6QDL_PAD_NANDF_CLE__NAND_CLE		0xb0b1
Index: trunk/target/linux/imx6/patches-3.14/207-pci_designware_revert-pcie-map-irq-function.patch
===================================================================
--- trunk/target/linux/imx6/patches-3.14/207-pci_designware_revert-pcie-map-irq-function.patch	(revision 0)
+++ trunk/target/linux/imx6/patches-3.14/207-pci_designware_revert-pcie-map-irq-function.patch	(working copy)
@@ -0,0 +1,24 @@
+Index: linux-3.14.16/drivers/pci/host/pcie-designware.c
+===================================================================
+--- linux-3.14.16.orig/drivers/pci/host/pcie-designware.c	2014-10-23 15:59:17.978240312 -0700
++++ linux-3.14.16/drivers/pci/host/pcie-designware.c	2014-10-23 16:04:32.478231239 -0700
+@@ -744,9 +744,16 @@
+ 	struct pcie_port *pp = sys_to_pcie(dev->bus->sysdata);
+ 	int irq;
+ 
+-	irq = of_irq_parse_and_map_pci(dev, slot, pin);
+-	if (!irq)
+-		irq = pp->irq;
++	switch (pin) {
++	case 1: irq = pp->irq; break;
++	case 2: irq = pp->irq - 1; break;
++	case 3: irq = pp->irq - 2; break;
++	case 4: irq = pp->irq - 3; break;
++	default: irq = -1; break;
++	}
++
++	dev_info(&dev->dev, "map_irq: %04x:%04x slot%d pin%d irq%d\n",
++		 dev->vendor, dev->device, slot, pin, irq);
+ 
+ 	return irq;
+ }
Index: trunk/target/linux/imx6/patches-3.14/210-ventana-gw551x.patch
===================================================================
--- trunk/target/linux/imx6/patches-3.14/210-ventana-gw551x.patch	(revision 0)
+++ trunk/target/linux/imx6/patches-3.14/210-ventana-gw551x.patch	(working copy)
@@ -0,0 +1,18 @@
+--- a/arch/arm/boot/dts/Makefile
++++ b/arch/arm/boot/dts/Makefile
+@@ -159,6 +159,7 @@ dtb-$(CONFIG_ARCH_MXC) += \
+ 	imx6dl-gw53xx.dtb \
+ 	imx6dl-gw54xx.dtb \
+ 	imx6dl-gw552x.dtb \
++	imx6dl-gw551x.dtb \
+ 	imx6dl-hummingboard.dtb \
+ 	imx6dl-sabreauto.dtb \
+ 	imx6dl-sabresd.dtb \
+@@ -171,6 +172,7 @@ dtb-$(CONFIG_ARCH_MXC) += \
+ 	imx6q-gw5400-a.dtb \
+ 	imx6q-gw54xx.dtb \
+ 	imx6q-gw552x.dtb \
++	imx6q-gw551x.dtb \
+ 	imx6q-phytec-pbab01.dtb \
+ 	imx6q-sabreauto.dtb \
+ 	imx6q-sabrelite.dtb \
Index: trunk/target/linux/imx6/patches-3.14/215-input-add-driver-mma8451.patch
===================================================================
--- trunk/target/linux/imx6/patches-3.14/215-input-add-driver-mma8451.patch	(revision 0)
+++ trunk/target/linux/imx6/patches-3.14/215-input-add-driver-mma8451.patch	(working copy)
@@ -0,0 +1,31 @@
+Index: linux-3.14.16/drivers/input/misc/Makefile
+===================================================================
+--- linux-3.14.16.orig/drivers/input/misc/Makefile	2014-08-07 16:50:59.000000000 -0700
++++ linux-3.14.16/drivers/input/misc/Makefile	2014-12-17 10:06:38.694105207 -0800
+@@ -39,6 +39,7 @@
+ obj-$(CONFIG_INPUT_MAX8997_HAPTIC)	+= max8997_haptic.o
+ obj-$(CONFIG_INPUT_MC13783_PWRBUTTON)	+= mc13783-pwrbutton.o
+ obj-$(CONFIG_INPUT_MMA8450)		+= mma8450.o
++obj-$(CONFIG_INPUT_MMA8451)		+= mma8451.o
+ obj-$(CONFIG_INPUT_MPU3050)		+= mpu3050.o
+ obj-$(CONFIG_INPUT_PCAP)		+= pcap_keys.o
+ obj-$(CONFIG_INPUT_PCF50633_PMU)	+= pcf50633-input.o
+Index: linux-3.14.16/drivers/input/misc/Kconfig
+===================================================================
+--- linux-3.14.16.orig/drivers/input/misc/Kconfig	2014-08-07 16:50:59.000000000 -0700
++++ linux-3.14.16/drivers/input/misc/Kconfig	2014-12-17 12:57:57.241808679 -0800
+@@ -187,6 +187,14 @@
+ 	  To compile this driver as a module, choose M here: the
+ 	  module will be called mma8450.
+ 
++config INPUT_MMA8451
++	tristate "MMA8451"
++	depends on I2C
++	select INPUT_POLLDEV
++	help
++	  Say Y here if you want to support Freescale's MMA8451 Accelerometer
++	  through I2C interface.
++
+ config INPUT_MPU3050
+ 	tristate "MPU3050 Triaxial gyroscope sensor"
+ 	depends on I2C
Index: trunk/target/linux/imx6/profiles/120-gateworks.mk
===================================================================
--- trunk/target/linux/imx6/profiles/120-gateworks.mk	(revision 42297)
+++ trunk/target/linux/imx6/profiles/120-gateworks.mk	(working copy)
@@ -41,6 +41,7 @@
 	imx6dl-gw52xx \
 	imx6dl-gw53xx \
 	imx6dl-gw54xx \
+	imx6dl-gw551x \
 	imx6dl-gw552x \
 	imx6q-gw51xx \
 	imx6q-gw52xx \
@@ -47,6 +48,7 @@
 	imx6q-gw53xx \
 	imx6q-gw54xx \
 	imx6q-gw5400-a \
+	imx6q-gw551x \
 	imx6q-gw552x
 
 $(eval $(call Profile,VENTANA))
