Index: trunk/target/linux/imx6/base-files/lib/imx6.sh
===================================================================
--- trunk/target/linux/imx6/base-files/lib/imx6.sh	(revision 42297)
+++ trunk/target/linux/imx6/base-files/lib/imx6.sh	(working copy)
@@ -34,6 +34,11 @@
 		name="gw54xx"
 		;;
 
+	"Gateworks Ventana i.MX6 Dual/Quad GW551X" |\
+	"Gateworks Ventana i.MX6 Solo/DualLite GW551X")
+		name="gw551x"
+		;;
+
 	"Gateworks Ventana i.MX6 DualLite/Solo GW552X" |\
 	"Gateworks Ventana i.MX6 Dual/Quad GW552X")
 		name="gw552x"
Index: trunk/target/linux/imx6/base-files/lib/upgrade/platform.sh
===================================================================
--- trunk/target/linux/imx6/base-files/lib/upgrade/platform.sh	(revision 42297)
+++ trunk/target/linux/imx6/base-files/lib/upgrade/platform.sh	(working copy)
@@ -8,7 +8,7 @@
 	local board=$(imx6_board_name)
 
 	case "$board" in
-	gw54xx)
+	gw5*)
 		nand_do_platform_check $board $1
 		return $?;
 		;;
Index: trunk/target/linux/imx6/config-3.14
===================================================================
--- trunk/target/linux/imx6/config-3.14	(revision 42297)
+++ trunk/target/linux/imx6/config-3.14	(working copy)
@@ -44,6 +44,7 @@
 CONFIG_ATAGS=y
 # CONFIG_ATA_SFF is not set
 CONFIG_AUTO_ZRELADDR=y
+CONFIG_BLK_DEV_SD=y
 # CONFIG_CACHE_L2X0 is not set
 CONFIG_CC_OPTIMIZE_FOR_SIZE=y
 CONFIG_CLKDEV_LOOKUP=y
@@ -311,6 +312,7 @@
 CONFIG_RFS_ACCEL=y
 CONFIG_RPS=y
 CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_DS1672=y
 # CONFIG_RTC_DRV_IMXDI is not set
 # CONFIG_RTC_DRV_MXC is not set
 CONFIG_SATA_AHCI_PLATFORM=y
@@ -346,8 +348,24 @@
 CONFIG_UBIFS_FS_ZLIB=y
 CONFIG_UID16=y
 CONFIG_UNCOMPRESS_INCLUDE="debug/uncompress.h"
-# CONFIG_USB_MXS_PHY is not set
+CONFIG_USB=y
+CONFIG_USB_CHIPIDEA=y
+# CONFIG_USB_CHIPIDEA_DEBUG is not set
+CONFIG_USB_CHIPIDEA_HOST=y
+CONFIG_USB_CHIPIDEA_UDC=y
+CONFIG_USB_COMMON=y
+CONFIG_USB_EHCI_HCD=y
+# CONFIG_USB_EHCI_HCD_PLATFORM is not set
+CONFIG_USB_EHCI_MXC=y
+CONFIG_USB_EHCI_PCI=y
+# CONFIG_USB_ETH is not set
+CONFIG_USB_GADGET=y
+# CONFIG_USB_IMX21_HCD is not set
+CONFIG_USB_MXS_PHY=y
+CONFIG_USB_PHY=y
+CONFIG_USB_STORAGE=y
 CONFIG_USB_SUPPORT=y
+# CONFIG_USB_UHCI_HCD is not set
 CONFIG_USE_OF=y
 CONFIG_VECTORS_BASE=0xffff0000
 CONFIG_VFP=y
@@ -363,3 +381,10 @@
 CONFIG_ZLIB_DEFLATE=y
 CONFIG_ZLIB_INFLATE=y
 CONFIG_ZONE_DMA_FLAG=0
+CONFIG_MFD_CORE=y
+CONFIG_WATCHDOG_CORE=y
+CONFIG_GSC_CORE=y
+CONFIG_GSC_WATCHDOG=y
+CONFIG_INPUT_GSC=y
+CONFIG_GPIO_PCA953X=y
+CONFIG_GPIO_PCA953X_IRQ=y
Index: trunk/target/linux/imx6/files-3.14/arch/arm/boot/dts/imx6dl-gw551x.dts
===================================================================
--- trunk/target/linux/imx6/files-3.14/arch/arm/boot/dts/imx6dl-gw551x.dts	(revision 0)
+++ trunk/target/linux/imx6/files-3.14/arch/arm/boot/dts/imx6dl-gw551x.dts	(working copy)
@@ -0,0 +1,19 @@
+/*
+ * Copyright 2014 Gateworks Corporation
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/dts-v1/;
+#include "imx6dl.dtsi"
+#include "imx6qdl-gw551x.dtsi"
+
+/ {
+	model = "Gateworks Ventana i.MX6 Solo/DualLite GW551X";
+	compatible = "gw,imx6dl-gw551x", "gw,ventana", "fsl,imx6dl";
+};
Index: trunk/target/linux/imx6/files-3.14/arch/arm/boot/dts/imx6qdl-gw551x.dtsi
===================================================================
--- trunk/target/linux/imx6/files-3.14/arch/arm/boot/dts/imx6qdl-gw551x.dtsi	(revision 0)
+++ trunk/target/linux/imx6/files-3.14/arch/arm/boot/dts/imx6qdl-gw551x.dtsi	(working copy)
@@ -0,0 +1,377 @@
+/*
+ * Copyright 2014 Gateworks Corporation
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/ {
+	/* these are used by bootloader for disabling nodes */
+	aliases {
+		can0 = &can1;
+		led0 = &led0;
+		nand = &gpmi;
+		usb0 = &usbh1;
+		usb1 = &usbotg;
+	};
+
+	chosen {
+		bootargs = "console=ttymxc1,115200";
+	};
+
+	leds {
+		compatible = "gpio-leds";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_gpio_leds>;
+
+		led0: user1 {
+			label = "user1";
+			gpios = <&gpio4 7 1>;
+			default-state = "on";
+			linux,default-trigger = "heartbeat";
+		};
+	};
+
+	gpio_keys {
+		compatible = "gpio-keys-polled";
+		poll-interval = <100>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		user_pb {
+			label = "user_pb";
+
+			gpios = <&gsc_gpio 0 1>;
+			linux,code = <256>;
+		};
+	};
+
+	memory {
+		reg = <0x10000000 0x20000000>;
+	};
+
+	regulators {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		reg_5p0v: regulator@1 {
+			compatible = "regulator-fixed";
+			reg = <1>;
+			regulator-name = "5P0V";
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			regulator-always-on;
+		};
+		reg_usb_otg_vbus: regulator@2 {
+			compatible = "regulator-fixed";
+			reg = <2>;
+			regulator-name = "OTG_VBUS";
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			regulator-always-on;
+		};
+	};
+};
+
+&can1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_flexcan1>;
+	status = "okay";
+};
+
+&gpmi {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_gpmi_nand>;
+	status = "okay";
+};
+
+&i2c1 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c1>;
+	status = "okay";
+
+	eeprom1: eeprom@50 {
+		compatible = "atmel,24c02";
+		reg = <0x50>;
+		pagesize = <16>;
+	};
+
+	eeprom2: eeprom@51 {
+		compatible = "atmel,24c02";
+		reg = <0x51>;
+		pagesize = <16>;
+	};
+
+	eeprom3: eeprom@52 {
+		compatible = "atmel,24c02";
+		reg = <0x52>;
+		pagesize = <16>;
+	};
+
+	eeprom4: eeprom@53 {
+		compatible = "atmel,24c02";
+		reg = <0x53>;
+		pagesize = <16>;
+	};
+
+	gsc: gsc@20 {
+		compatible = "gw,gsc";
+		reg = <0x20>;
+		interrupt-parent = <&gpio1>;
+		interrupts = <4 1>;
+		interrupt-controller;
+		#interrupt-cells = <1>;
+
+		/* GSC watchdog */
+		watchdog {
+			compatible = "gw,gsc_wdt";
+			status = "okay";
+		};
+
+		/* Linux input events from GSC interrupt events */
+		input {
+			compatible = "gw,gsc_input";
+			interrupt-parent = <&gsc>;
+			interrupts = <0 1 2 5 7>;
+			interrupt-names = "button", "key-erased", "eeprom-wp", "tamper", "button-held";
+			status = "okay";
+		};
+	};
+
+	gsc_gpio: pca9555@23 {
+		compatible = "nxp,pca9555";
+		reg = <0x23>;
+		gpio-controller;
+		#gpio-cells = <2>;
+		interrupt-parent = <&gsc>;
+		interrupts = <4>;
+	};
+
+	gsc_hwmon: hwmon@29 {
+		compatible = "gw,gsp";
+		reg = <0x29>;
+	};
+
+	gsc_rtc: ds1672@68 {
+		compatible = "dallas,ds1672";
+		reg = <0x68>;
+	};
+};
+
+&i2c2 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c2>;
+	status = "okay";
+
+	ltc3676: pmic@3c {
+		compatible = "lltc,ltc3676";
+		reg = <0x3c>;
+		interrupt-parent = <&gpio1>;
+		interrupts = <8 2>;
+
+		regulators {
+			/* VDD_SOC (1+R1/R2 = 1.635) */
+			reg_vdd_soc: sw1 {
+				regulator-min-microvolt = <674400>;
+				regulator-max-microvolt = <1308000>;
+				lltc,fb-voltage-divider = <127000 200000>;
+				regulator-ramp-delay = <7000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			/* VDD_DDR (1+R1/R2 = 2.105) */
+			reg_vdd_ddr: sw2 {
+				regulator-min-microvolt = <868310>;
+				regulator-max-microvolt = <1684000>;
+				lltc,fb-voltage-divider = <221000 200000>;
+				regulator-ramp-delay = <7000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			/* VDD_ARM (1+R1/R2 = 1.635) */
+			reg_vdd_arm: sw3 {
+				regulator-min-microvolt = <674400>;
+				regulator-max-microvolt = <1308000>;
+				lltc,fb-voltage-divider = <127000 200000>;
+				regulator-ramp-delay = <7000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			/* VDD_3P3 (1+R1/R2 = 1.281) */
+			reg_3p3: sw4 {
+				regulator-min-microvolt = <1880000>;
+				regulator-max-microvolt = <3647000>;
+				lltc,fb-voltage-divider = <200000 56200>;
+				regulator-ramp-delay = <7000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			/* VDD_1P8a (1+R1/R2 = 2.505): HDMI In core */
+			reg_1p8a: ldo2 {
+				regulator-min-microvolt = <1816125>;
+				regulator-max-microvolt = <1816125>;
+				lltc,fb-voltage-divider = <301000 200000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			/* VDD_1P8b: HDMI In analog */
+			reg_1p8b: ldo3 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-boot-on;
+			};
+
+			/* VDD_HIGH (1+R1/R2 = 4.17) */
+			reg_3p0: ldo4 {
+				regulator-min-microvolt = <3023250>;
+				regulator-max-microvolt = <3023250>;
+				lltc,fb-voltage-divider = <634000 200000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+		};
+	};
+};
+
+&i2c3 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c3>;
+	status = "okay";
+
+	gpio_exp: pca9555@24 {
+		compatible = "nxp,pca9555";
+		reg = <0x24>;
+		gpio-controller;
+		#gpio-cells = <2>;
+	};
+};
+
+&iomuxc {
+	imx6qdl-gw51xx {
+		pinctrl_flexcan1: flexcan1grp {
+			fsl,pins = <
+				MX6QDL_PAD_KEY_ROW2__FLEXCAN1_RX	0x1b0b1
+				MX6QDL_PAD_KEY_COL2__FLEXCAN1_TX	0x1b0b1
+				MX6QDL_PAD_GPIO_9__GPIO1_IO09		0x4001b0b0 /* CAN_STBY */
+			>;
+		};
+
+		pinctrl_gpio_leds: gpioledsgrp {
+			fsl,pins = <
+				MX6QDL_PAD_KEY_ROW0__GPIO4_IO07		0x1b0b0
+			>;
+		};
+
+		pinctrl_gpmi_nand: gpminandgrp {
+			fsl,pins = <
+				MX6QDL_PAD_NANDF_CLE__NAND_CLE		0xb0b1
+				MX6QDL_PAD_NANDF_ALE__NAND_ALE		0xb0b1
+				MX6QDL_PAD_NANDF_WP_B__NAND_WP_B	0xb0b1
+				MX6QDL_PAD_NANDF_RB0__NAND_READY_B	0xb000
+				MX6QDL_PAD_NANDF_CS0__NAND_CE0_B	0xb0b1
+				MX6QDL_PAD_NANDF_CS1__NAND_CE1_B	0xb0b1
+				MX6QDL_PAD_SD4_CMD__NAND_RE_B		0xb0b1
+				MX6QDL_PAD_SD4_CLK__NAND_WE_B		0xb0b1
+				MX6QDL_PAD_NANDF_D0__NAND_DATA00	0xb0b1
+				MX6QDL_PAD_NANDF_D1__NAND_DATA01	0xb0b1
+				MX6QDL_PAD_NANDF_D2__NAND_DATA02	0xb0b1
+				MX6QDL_PAD_NANDF_D3__NAND_DATA03	0xb0b1
+				MX6QDL_PAD_NANDF_D4__NAND_DATA04	0xb0b1
+				MX6QDL_PAD_NANDF_D5__NAND_DATA05	0xb0b1
+				MX6QDL_PAD_NANDF_D6__NAND_DATA06	0xb0b1
+				MX6QDL_PAD_NANDF_D7__NAND_DATA07	0xb0b1
+			>;
+		};
+
+		pinctrl_i2c1: i2c1grp {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_D21__I2C1_SCL	0x4001b8b1
+				MX6QDL_PAD_EIM_D28__I2C1_SDA	0x4001b8b1
+			>;
+		};
+
+		pinctrl_i2c2: i2c2grp {
+			fsl,pins = <
+				MX6QDL_PAD_KEY_COL3__I2C2_SCL	0x4001b8b1
+				MX6QDL_PAD_KEY_ROW3__I2C2_SDA	0x4001b8b1
+			>;
+		};
+
+		pinctrl_i2c3: i2c3grp {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_3__I2C3_SCL	0x4001b8b1
+				MX6QDL_PAD_GPIO_6__I2C3_SDA	0x4001b8b1
+			>;
+		};
+
+		pinctrl_pcie: pciegrp {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_0__GPIO1_IO00		0x1b0b0
+			>;
+		};
+
+		pinctrl_uart2: uart2grp {
+			fsl,pins = <
+				MX6QDL_PAD_SD4_DAT7__UART2_TX_DATA	0x1b0b1
+				MX6QDL_PAD_SD4_DAT4__UART2_RX_DATA	0x1b0b1
+			>;
+		};
+
+		pinctrl_uart3: uart3grp {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_D24__UART3_TX_DATA	0x1b0b1
+				MX6QDL_PAD_EIM_D25__UART3_RX_DATA	0x1b0b1
+			>;
+		};
+
+		pinctrl_usbotg: usbotggrp {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_1__USB_OTG_ID		0x17059
+			>;
+		};
+	};
+};
+
+&pcie {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pcie>;
+	reset-gpio = <&gpio1 0 0>;
+	status = "okay";
+};
+
+&uart2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart2>;
+	status = "okay";
+};
+
+&uart3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart3>;
+	status = "okay";
+};
+
+&usbotg {
+	vbus-supply = <&reg_usb_otg_vbus>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usbotg>;
+	disable-over-current;
+	status = "okay";
+};
+
+&usbh1 {
+	status = "okay";
+};
Index: trunk/target/linux/imx6/files-3.14/arch/arm/boot/dts/imx6qdl-gw552x.dtsi
===================================================================
--- trunk/target/linux/imx6/files-3.14/arch/arm/boot/dts/imx6qdl-gw552x.dtsi	(revision 42297)
+++ trunk/target/linux/imx6/files-3.14/arch/arm/boot/dts/imx6qdl-gw552x.dtsi	(working copy)
@@ -46,6 +46,20 @@
 		};
 	};
 
+	gpio_keys {
+		compatible = "gpio-keys-polled";
+		poll-interval = <100>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		user_pb {
+			label = "user_pb";
+
+			gpios = <&gsc_gpio 0 1>;
+			linux,code = <256>;
+		};
+	};
+
 	memory {
 		reg = <0x10000000 0x20000000>;
 	};
@@ -120,19 +134,45 @@
 		pagesize = <16>;
 	};
 
-	gpio: pca9555@23 {
+	gsc: gsc@20 {
+		compatible = "gw,gsc";
+		reg = <0x20>;
+		interrupt-parent = <&gpio1>;
+		interrupts = <4 1>;
+		interrupt-controller;
+		#interrupt-cells = <1>;
+
+		/* GSC watchdog */
+		watchdog {
+			compatible = "gw,gsc_wdt";
+			status = "okay";
+		};
+
+		/* Linux input events from GSC interrupt events */
+		input {
+			compatible = "gw,gsc_input";
+			interrupt-parent = <&gsc>;
+			interrupts = <0 1 2 5 7>;
+			interrupt-names = "button", "key-erased", "eeprom-wp", "tamper", "button-held";
+			status = "okay";
+		};
+	};
+
+	gsc_gpio: pca9555@23 {
 		compatible = "nxp,pca9555";
 		reg = <0x23>;
 		gpio-controller;
 		#gpio-cells = <2>;
+		interrupt-parent = <&gsc>;
+		interrupts = <4>;
 	};
 
-	hwmon: gsc@29 {
+	gsc_hwmon: hwmon@29 {
 		compatible = "gw,gsp";
 		reg = <0x29>;
 	};
 
-	rtc: ds1672@68 {
+	gsc_rtc: ds1672@68 {
 		compatible = "dallas,ds1672";
 		reg = <0x68>;
 	};
Index: trunk/target/linux/imx6/files-3.14/arch/arm/boot/dts/imx6q-gw551x.dts
===================================================================
--- trunk/target/linux/imx6/files-3.14/arch/arm/boot/dts/imx6q-gw551x.dts	(revision 0)
+++ trunk/target/linux/imx6/files-3.14/arch/arm/boot/dts/imx6q-gw551x.dts	(working copy)
@@ -0,0 +1,19 @@
+/*
+ * Copyright 2014 Gateworks Corporation
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/dts-v1/;
+#include "imx6q.dtsi"
+#include "imx6qdl-gw551x.dtsi"
+
+/ {
+	model = "Gateworks Ventana i.MX6 Dual/Quad GW551X";
+	compatible = "gw,imx6q-gw551x", "gw,ventana", "fsl,imx6q";
+};
Index: trunk/target/linux/imx6/files-3.14/drivers/input/misc/gsc-input.c
===================================================================
--- trunk/target/linux/imx6/files-3.14/drivers/input/misc/gsc-input.c	(revision 0)
+++ trunk/target/linux/imx6/files-3.14/drivers/input/misc/gsc-input.c	(working copy)
@@ -0,0 +1,163 @@
+/*
+ * Copyright (C) 2014 Gateworks Corporation
+ *
+ * Written by Tim Harvey <tharvey@gateworks.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of_irq.h>
+#include <linux/platform_device.h>
+
+#include <linux/mfd/gsc.h>
+
+#define DRIVER_NAME "gsc_input"
+
+static irqreturn_t gsc_input_irq(int irq, void *data)
+{
+	struct input_dev *input = (struct input_dev *)data;
+	int key;
+	u8 sts;
+	struct irq_desc *desc = irq_to_desc(irq);
+
+	gsc_i2c_read(GSC_IRQ_STATUS, &sts);
+	dev_dbg(&input->dev, "irq%d status=0x%02x\n", irq, sts);
+
+	while (sts) {
+		irq = fls(sts);
+		irq--;
+		sts &= ~BIT(irq);
+
+		switch(irq) {
+		/* user button press and release within 700ms */
+		case GSC_IRQ_PB:
+			key = BTN_0;
+			break;
+		/* user eeprom section has been erased */
+		case GSC_IRQ_KEY_ERASED:
+			key = BTN_1;
+			break;
+		/* user eeprom write-protect violation */
+		case GSC_IRQ_EEPROM_WP:
+			key = BTN_2;
+			break;
+		/* gpio change event */
+		case GSC_IRQ_GPIO:
+			key = BTN_3;
+			break;
+		/* tamper event */
+		case GSC_IRQ_TAMPER:
+			key = BTN_4;
+			break;
+		/* user button held down for more than 700ms */
+		case GSC_IRQ_SWITCH_HOLD:
+			key = BTN_5;
+			break;
+		default:
+			key = 0;
+			break;
+		}
+
+		if (desc->action->name) {
+			dev_dbg(&input->dev, "bit%d: key=0x%03x %s\n", irq,
+				key, desc->action->name);
+			input_report_key(input, key, 1);
+			input_report_key(input, key, 0);
+			input_sync(input);
+		}
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int gsc_input_probe(struct platform_device *pdev)
+{
+	struct input_dev *input;
+	int err, i, irq;
+	struct resource r;
+	u8 reg;
+
+	if (gsc_i2c_read(GSC_CTRL_0, &reg)) {
+		dev_err(&pdev->dev, "failed reading GSC_CTRL_0\n");
+		return -EIO;
+	}
+
+	input = devm_input_allocate_device(&pdev->dev);
+	if (!input) {
+		dev_err(&pdev->dev, "Can't allocate input device\n");
+		return -ENOMEM;
+	}
+
+	input->name = DRIVER_NAME;
+	input->dev.parent = &pdev->dev;
+
+	input_set_capability(input, EV_KEY, BTN_0);
+	input_set_capability(input, EV_KEY, BTN_1);
+	input_set_capability(input, EV_KEY, BTN_2);
+	input_set_capability(input, EV_KEY, BTN_3);
+	input_set_capability(input, EV_KEY, BTN_4);
+	input_set_capability(input, EV_KEY, BTN_5);
+
+	platform_set_drvdata(pdev, input);
+
+	for (i = 0; i < 8; i++) {
+		irq = of_irq_to_resource(pdev->dev.of_node, i, &r);
+		if (!irq)
+			break;
+		err = devm_request_threaded_irq(&pdev->dev, irq, NULL,
+						gsc_input_irq, 0, r.name,
+						input);
+		if (err < 0) {
+			dev_err(&pdev->dev, "failed to claim irq%d: %d\n", irq,
+				err);
+			return err;
+		}
+		dev_dbg(&pdev->dev, "registered irq%d: %s\n", irq, r.name);
+	}
+
+	err = input_register_device(input);
+	if (err) {
+		dev_err(&pdev->dev, "Can't register input device: %d\n", err);
+		return err;
+	}
+
+	dev_info(&pdev->dev, "input driver installed: CTRL_0=0x%02x\n", reg);
+
+	return 0;
+}
+
+static int gsc_input_remove(struct platform_device *pdev)
+{
+	dev_info(&pdev->dev, "input driver removed\n");
+	return 0;
+}
+
+static const struct of_device_id gsc_input_dt_ids[] = {
+	{ .compatible = "gw,gsc_input", },
+	{ }
+};
+
+static struct platform_driver gsc_input_driver = {
+	.probe		= gsc_input_probe,
+	.remove		= gsc_input_remove,
+	.driver		= {
+		.name	= DRIVER_NAME,
+		.owner	= THIS_MODULE,
+		.of_match_table = gsc_input_dt_ids,
+	},
+};
+
+module_platform_driver(gsc_input_driver);
+
+MODULE_AUTHOR("Tim Harvey <tharvey@gateworks.com>");
+MODULE_DESCRIPTION("Input driver for GSC");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:" DRIVER_NAME);
Index: trunk/target/linux/imx6/files-3.14/drivers/input/misc/mma8451.c
===================================================================
--- trunk/target/linux/imx6/files-3.14/drivers/input/misc/mma8451.c	(revision 0)
+++ trunk/target/linux/imx6/files-3.14/drivers/input/misc/mma8451.c	(working copy)
@@ -0,0 +1,719 @@
+/*
+ *  mma8451.c - Linux kernel modules for 3-Axis Orientation/Motion
+ *  Detection Sensor
+ *
+ *  Copyright (C) 2010-2013 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/pm.h>
+#include <linux/mutex.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/err.h>
+#include <linux/input-polldev.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#define MMA8451_I2C_ADDR	0x1C
+#define MMA8451_ID		0x1A
+#define MMA8452_ID		0x2A
+#define MMA8453_ID		0x3A
+#define FXOS8700_ID		0xC7
+
+#define POLL_INTERVAL_MIN	1
+#define POLL_INTERVAL_MAX	500
+#define POLL_INTERVAL		100	/* msecs */
+#define INPUT_FUZZ		32
+#define INPUT_FLAT		32
+#define MODE_CHANGE_DELAY_MS	100
+
+#define MMA8451_STATUS_ZYXDR	0x08
+#define MMA8451_BUF_SIZE	7
+#define DEFAULT_POSITION	0
+
+/* register enum for mma8451 registers */
+enum {
+	MMA8451_STATUS = 0x00,
+	MMA8451_OUT_X_MSB,
+	MMA8451_OUT_X_LSB,
+	MMA8451_OUT_Y_MSB,
+	MMA8451_OUT_Y_LSB,
+	MMA8451_OUT_Z_MSB,
+	MMA8451_OUT_Z_LSB,
+
+	MMA8451_F_SETUP = 0x09,
+	MMA8451_TRIG_CFG,
+	MMA8451_SYSMOD,
+	MMA8451_INT_SOURCE,
+	MMA8451_WHO_AM_I,
+	MMA8451_XYZ_DATA_CFG,
+	MMA8451_HP_FILTER_CUTOFF,
+
+	MMA8451_PL_STATUS,
+	MMA8451_PL_CFG,
+	MMA8451_PL_COUNT,
+	MMA8451_PL_BF_ZCOMP,
+	MMA8451_P_L_THS_REG,
+
+	MMA8451_FF_MT_CFG,
+	MMA8451_FF_MT_SRC,
+	MMA8451_FF_MT_THS,
+	MMA8451_FF_MT_COUNT,
+
+	MMA8451_TRANSIENT_CFG = 0x1D,
+	MMA8451_TRANSIENT_SRC,
+	MMA8451_TRANSIENT_THS,
+	MMA8451_TRANSIENT_COUNT,
+
+	MMA8451_PULSE_CFG,
+	MMA8451_PULSE_SRC,
+	MMA8451_PULSE_THSX,
+	MMA8451_PULSE_THSY,
+	MMA8451_PULSE_THSZ,
+	MMA8451_PULSE_TMLT,
+	MMA8451_PULSE_LTCY,
+	MMA8451_PULSE_WIND,
+
+	MMA8451_ASLP_COUNT,
+	MMA8451_CTRL_REG1,
+	MMA8451_CTRL_REG2,
+	MMA8451_CTRL_REG3,
+	MMA8451_CTRL_REG4,
+	MMA8451_CTRL_REG5,
+
+	MMA8451_OFF_X,
+	MMA8451_OFF_Y,
+	MMA8451_OFF_Z,
+
+	FXOS8700_M_DR_STATUS,
+	FXOS8700_M_OUT_X_MSB,
+	FXOS8700_M_OUT_X_LSB,
+	FXOS8700_M_OUT_Y_MSB,
+	FXOS8700_M_OUT_Y_LSB,
+	FXOS8700_M_OUT_Z_MSB,
+	FXOS8700_M_OUT_Z_LSB,
+
+	FXOS8700_M_CTRL_REG1 = 0x5B,
+
+	MMA8451_REG_END,
+};
+
+/* The sensitivity is represented in counts/g. In 2g mode the
+sensitivity is 1024 counts/g. In 4g mode the sensitivity is 512
+counts/g and in 8g mode the sensitivity is 256 counts/g.
+ */
+enum {
+	MODE_2G = 0,
+	MODE_4G,
+	MODE_8G,
+};
+
+enum {
+	MMA_STANDBY = 0,
+	MMA_ACTIVED,
+};
+
+enum {
+	FXOS_ACCEL_ONLY = 0,
+	FXOS_MAG_ONLY,
+	FXOS_NONE,
+	FXOS_HYBRID,
+};
+
+/* mma8451 status */
+struct mma8451_status {
+	u8 mode;
+	u8 ctl_reg1;
+	int active;
+	int position;
+	int hybrid_mode;
+};
+
+static struct mma8451_status mma_status;
+static struct input_polled_dev *mma8451_idev;
+static struct input_polled_dev *fxos8700_m_idev;
+static struct i2c_client *mma8451_i2c_client;
+static int client_id;
+
+static int senstive_mode = MODE_2G;
+static int ACCHAL[8][3][3] = {
+	{ {0, -1, 0}, {1, 0, 0}, {0, 0, 1} },
+	{ {-1, 0, 0}, {0, -1, 0}, {0, 0, 1} },
+	{ {0, 1, 0}, {-1, 0, 0}, {0, 0, 1} },
+	{ {1, 0, 0}, {0, 1, 0}, {0, 0, 1} },
+
+	{ {0, -1, 0}, {-1, 0, 0}, {0, 0, -1} },
+	{ {-1, 0, 0}, {0, 1, 0}, {0, 0, -1} },
+	{ {0, 1, 0}, {1, 0, 0}, {0, 0, -1} },
+	{ {1, 0, 0}, {0, -1, 0}, {0, 0, -1} },
+};
+
+static DEFINE_MUTEX(mma8451_lock);
+static int mma8451_adjust_position(short *x, short *y, short *z)
+{
+	short rawdata[3], data[3];
+	int i, j;
+	int position = mma_status.position;
+	if (position < 0 || position > 7)
+		position = 0;
+	rawdata[0] = *x;
+	rawdata[1] = *y;
+	rawdata[2] = *z;
+	for (i = 0; i < 3; i++) {
+		data[i] = 0;
+		for (j = 0; j < 3; j++)
+			data[i] += rawdata[j] * ACCHAL[position][i][j];
+	}
+	*x = data[0];
+	*y = data[1];
+	*z = data[2];
+	return 0;
+}
+
+static int mma8451_change_mode(struct i2c_client *client, int mode)
+{
+	int result;
+
+	mma_status.ctl_reg1 = 0;
+	result = i2c_smbus_write_byte_data(client, MMA8451_CTRL_REG1, 0);
+	if (result < 0)
+		goto out;
+	mma_status.active = MMA_STANDBY;
+
+	if (client_id == FXOS8700_ID) {
+		mma_status.hybrid_mode = FXOS_HYBRID;
+		result = i2c_smbus_write_byte_data(client, FXOS8700_M_CTRL_REG1, FXOS_HYBRID);
+		if (result < 0)
+			goto out;
+	}
+
+	mma_status.mode = mode;
+	result = i2c_smbus_write_byte_data(client, MMA8451_XYZ_DATA_CFG,
+					   mode);
+	if (result < 0)
+		goto out;
+	mdelay(MODE_CHANGE_DELAY_MS);
+	mma_status.mode = mode;
+
+	return 0;
+out:
+	dev_err(&client->dev, "error when init mma8451:(%d)", result);
+	return result;
+}
+
+static int mma8451_read_data(struct input_polled_dev *idev,
+		short *x, short *y, short *z)
+{
+	u8 tmp_data[MMA8451_BUF_SIZE];
+	char reg = (idev == mma8451_idev)?MMA8451_OUT_X_MSB:FXOS8700_M_OUT_X_MSB;
+	int ret;
+
+	ret = i2c_smbus_read_i2c_block_data(mma8451_i2c_client,
+					    reg, 7, tmp_data);
+	if (ret < MMA8451_BUF_SIZE) {
+		dev_err(&mma8451_i2c_client->dev, "i2c block read failed\n");
+		return -EIO;
+	}
+
+	*x = ((tmp_data[0] << 8) & 0xff00) | tmp_data[1];
+	*y = ((tmp_data[2] << 8) & 0xff00) | tmp_data[3];
+	*z = ((tmp_data[4] << 8) & 0xff00) | tmp_data[5];
+	return 0;
+}
+
+static void report_abs(struct input_polled_dev *idev)
+{
+	short x, y, z;
+	int result;
+	int retry = 3;
+	char reg = (idev == mma8451_idev)?MMA8451_STATUS:FXOS8700_M_DR_STATUS;
+
+	mutex_lock(&mma8451_lock);
+	if (mma_status.active == MMA_STANDBY)
+		goto out;
+	/* wait for the data ready */
+	do {
+		result = i2c_smbus_read_byte_data(mma8451_i2c_client, reg);
+		retry--;
+		msleep(1);
+	} while (!(result & MMA8451_STATUS_ZYXDR) && retry > 0);
+	if (retry == 0)
+		goto out;
+	if (mma8451_read_data(idev, &x, &y, &z) != 0)
+		goto out;
+	mma8451_adjust_position(&x, &y, &z);
+	input_report_abs(idev->input, ABS_X, x);
+	input_report_abs(idev->input, ABS_Y, y);
+	input_report_abs(idev->input, ABS_Z, z);
+	input_sync(idev->input);
+out:
+	mutex_unlock(&mma8451_lock);
+}
+
+static void mma8451_dev_poll(struct input_polled_dev *dev)
+{
+	report_abs(dev);
+}
+
+static ssize_t mma8451_enable_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct input_polled_dev *idev = dev_get_drvdata(dev);
+	struct i2c_client *client;
+	u8 val;
+	int enable = 0;
+
+	mutex_lock(&mma8451_lock);
+	client = mma8451_i2c_client;
+	val = i2c_smbus_read_byte_data(client, MMA8451_CTRL_REG1);
+	if ((val & 0x01) && mma_status.active == MMA_ACTIVED) {
+		if (client_id == FXOS8700_ID) {
+			if (mma_status.hybrid_mode == FXOS_HYBRID)
+				enable = 1;
+			else if (mma_status.hybrid_mode == FXOS_ACCEL_ONLY
+				&& idev == mma8451_idev)
+				enable = 1;
+			else if (mma_status.hybrid_mode == FXOS_MAG_ONLY)
+				enable = 1;
+		}
+		else
+			enable = 1;
+	}
+	mutex_unlock(&mma8451_lock);
+	return sprintf(buf, "%d\n", enable);
+}
+
+static ssize_t mma8451_enable_store(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+	struct input_polled_dev *idev = dev_get_drvdata(dev);
+	struct i2c_client *client;
+	int ret;
+	unsigned long enable;
+	u8 val = 0;
+
+	ret = strict_strtoul(buf, 10, &enable);
+	if (ret) {
+		dev_err(dev, "string transform error\n");
+		return ret;
+	}
+
+	mutex_lock(&mma8451_lock);
+	client = mma8451_i2c_client;
+	enable = (enable > 0) ? 1 : 0;
+	if (client_id == FXOS8700_ID) {
+		val = mma_status.hybrid_mode;
+		if (idev == mma8451_idev) {
+			if (enable) {
+				if (val == FXOS_NONE)
+					val = FXOS_ACCEL_ONLY;
+				else if (val == FXOS_MAG_ONLY)
+					val = FXOS_HYBRID;
+			} else {
+				if (val == FXOS_HYBRID)
+					val = FXOS_MAG_ONLY;
+				else if (val == FXOS_ACCEL_ONLY)
+					val = FXOS_NONE;
+			}
+		} else {
+			if (enable) {
+				if (val == FXOS_NONE)
+					val = FXOS_MAG_ONLY;
+				else if (val == FXOS_ACCEL_ONLY)
+					val = FXOS_HYBRID;
+			} else {
+				if (val == FXOS_HYBRID)
+					val = FXOS_ACCEL_ONLY;
+				else if (val == FXOS_MAG_ONLY)
+					val = FXOS_NONE;
+			}
+		}
+/*
+		if (val != FXOS_NONE) {
+			ret = i2c_smbus_write_byte_data(client,
+				FXOS8700_M_CTRL_REG1, val & 0x03);
+		}
+*/
+		mma_status.hybrid_mode = val;
+		if (mma_status.hybrid_mode == FXOS_NONE)
+			enable = 0;
+		else
+			enable = 1;
+	}
+	if (enable && mma_status.active == MMA_STANDBY) {
+		val = i2c_smbus_read_byte_data(client, MMA8451_CTRL_REG1);
+		ret =
+		    i2c_smbus_write_byte_data(client, MMA8451_CTRL_REG1,
+					      val | 0x01);
+		if (!ret)
+			mma_status.active = MMA_ACTIVED;
+
+	} else if (enable == 0 && mma_status.active == MMA_ACTIVED) {
+		val = i2c_smbus_read_byte_data(client, MMA8451_CTRL_REG1);
+		ret =
+		    i2c_smbus_write_byte_data(client, MMA8451_CTRL_REG1,
+					      val & 0xFE);
+		if (!ret)
+			mma_status.active = MMA_STANDBY;
+
+	}
+	mutex_unlock(&mma8451_lock);
+	return count;
+}
+
+static ssize_t mma8451_position_show(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	int position = 0;
+	mutex_lock(&mma8451_lock);
+	position = mma_status.position;
+	mutex_unlock(&mma8451_lock);
+	return sprintf(buf, "%d\n", position);
+}
+
+static ssize_t mma8451_position_store(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf, size_t count)
+{
+	unsigned long  position;
+	int ret;
+	ret = strict_strtoul(buf, 10, &position);
+	if (ret) {
+		dev_err(dev, "string transform error\n");
+		return ret;
+	}
+
+	mutex_lock(&mma8451_lock);
+	mma_status.position = (int)position;
+	mutex_unlock(&mma8451_lock);
+	return count;
+}
+
+static ssize_t mma8451_scalemode_show(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	int mode = 0;
+	mutex_lock(&mma8451_lock);
+	mode = (int)mma_status.mode;
+	mutex_unlock(&mma8451_lock);
+
+	return sprintf(buf, "%d\n", mode);
+}
+
+static ssize_t mma8451_scalemode_store(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t count)
+{
+	unsigned long  mode;
+	int ret, active_save;
+	struct i2c_client *client = mma8451_i2c_client;
+
+	ret = strict_strtoul(buf, 10, &mode);
+	if (ret) {
+		dev_err(dev, "string transform error\n");
+		goto out;
+	}
+
+	if (mode > MODE_8G) {
+		dev_warn(dev, "not supported mode\n");
+		ret = count;
+		goto out;
+	}
+
+	mutex_lock(&mma8451_lock);
+	if (mode == mma_status.mode) {
+		ret = count;
+		goto out_unlock;
+	}
+
+	active_save = mma_status.active;
+	ret = mma8451_change_mode(client, mode);
+	if (ret)
+		goto out_unlock;
+
+	if (active_save == MMA_ACTIVED) {
+		ret = i2c_smbus_write_byte_data(client, MMA8451_CTRL_REG1, 1);
+
+		if (ret)
+			goto out_unlock;
+		mma_status.active = active_save;
+	}
+
+out_unlock:
+	mutex_unlock(&mma8451_lock);
+out:
+	return ret;
+}
+
+static DEVICE_ATTR(enable, S_IWUSR | S_IRUGO,
+			mma8451_enable_show, mma8451_enable_store);
+static DEVICE_ATTR(position, S_IWUSR | S_IRUGO,
+			mma8451_position_show, mma8451_position_store);
+static DEVICE_ATTR(scalemode, S_IWUSR | S_IRUGO,
+			mma8451_scalemode_show, mma8451_scalemode_store);
+
+static struct attribute *mma8451_attributes[] = {
+	&dev_attr_enable.attr,
+	&dev_attr_position.attr,
+	&dev_attr_scalemode.attr,
+	NULL
+};
+
+static const struct attribute_group mma8451_attr_group = {
+	.attrs = mma8451_attributes,
+};
+
+static int mma8451_probe(struct i2c_client *client,
+				   const struct i2c_device_id *id)
+{
+	int result;
+	struct input_dev *idev;
+	struct i2c_adapter *adapter;
+	u32 pos;
+	struct device_node *of_node = client->dev.of_node;
+	struct regulator *vdd, *vdd_io;
+
+	mma8451_i2c_client = client;
+
+	vdd = devm_regulator_get(&client->dev, "vdd");
+	if (!IS_ERR(vdd)) {
+		result = regulator_enable(vdd);
+		if (result) {
+			dev_err(&client->dev, "vdd set voltage error\n");
+			return result;
+		}
+	}
+
+	vdd_io = devm_regulator_get(&client->dev, "vddio");
+	if (!IS_ERR(vdd_io)) {
+		result = regulator_enable(vdd_io);
+		if (result) {
+			dev_err(&client->dev, "vddio set voltage error\n");
+			return result;
+		}
+	}
+
+	adapter = to_i2c_adapter(client->dev.parent);
+	result = i2c_check_functionality(adapter,
+					 I2C_FUNC_SMBUS_BYTE |
+					 I2C_FUNC_SMBUS_BYTE_DATA);
+	if (!result)
+		goto err_out;
+
+	client_id = i2c_smbus_read_byte_data(client, MMA8451_WHO_AM_I);
+	if (client_id != MMA8451_ID && client_id != MMA8452_ID
+	    && client_id != MMA8453_ID && client_id != FXOS8700_ID) {
+		dev_err(&client->dev,
+			"read chip ID 0x%x is not equal to 0x%x,0x%x,0x%x!\n",
+			result, MMA8451_ID, MMA8452_ID, FXOS8700_ID);
+		result = -EINVAL;
+		goto err_out;
+	}
+
+	/* Initialize the MMA8451 chip */
+	result = mma8451_change_mode(client, senstive_mode);
+	if (result) {
+		dev_err(&client->dev,
+			"error when init mma8451 chip:(%d)\n", result);
+		goto err_out;
+	}
+
+	/* create a polled input device for accelerometer */
+	mma8451_idev = input_allocate_polled_device();
+	if (!mma8451_idev) {
+		result = -ENOMEM;
+		dev_err(&client->dev, "alloc poll device failed!\n");
+		goto err_register_polled_device;
+	}
+	mma8451_idev->poll = mma8451_dev_poll;
+	mma8451_idev->poll_interval = POLL_INTERVAL;
+	mma8451_idev->poll_interval_min = POLL_INTERVAL_MIN;
+	mma8451_idev->poll_interval_max = POLL_INTERVAL_MAX;
+	idev = mma8451_idev->input;
+	if (client_id == FXOS8700_ID)
+		idev->name = "mma845x_a";
+	else
+		idev->name = "mma845x";
+	idev->id.bustype = BUS_I2C;
+	idev->evbit[0] = BIT_MASK(EV_ABS);
+
+	input_set_abs_params(idev, ABS_X, -8192, 8191, INPUT_FUZZ, INPUT_FLAT);
+	input_set_abs_params(idev, ABS_Y, -8192, 8191, INPUT_FUZZ, INPUT_FLAT);
+	input_set_abs_params(idev, ABS_Z, -8192, 8191, INPUT_FUZZ, INPUT_FLAT);
+
+	result = input_register_polled_device(mma8451_idev);
+	if (result) {
+		dev_err(&client->dev, "register poll device failed!\n");
+		goto err_register_polled_device;
+	}
+	result = sysfs_create_group(&idev->dev.kobj, &mma8451_attr_group);
+	if (result) {
+		dev_err(&client->dev, "create device file failed!\n");
+		result = -EINVAL;
+		goto err_register_polled_device;
+	}
+
+	/* create a polled input device for magnetometer */
+	if (client_id == FXOS8700_ID) {
+		fxos8700_m_idev = input_allocate_polled_device();
+		if (!fxos8700_m_idev) {
+			result = -ENOMEM;
+			dev_err(&client->dev, "alloc poll device failed!\n");
+			goto err_alloc_poll_device;
+		}
+		fxos8700_m_idev->poll = mma8451_dev_poll;
+		fxos8700_m_idev->poll_interval = POLL_INTERVAL;
+		fxos8700_m_idev->poll_interval_min = POLL_INTERVAL_MIN;
+		fxos8700_m_idev->poll_interval_max = POLL_INTERVAL_MAX;
+		idev = fxos8700_m_idev->input;
+		idev->name = "fxos8700_m";
+		idev->id.bustype = BUS_I2C;
+		idev->evbit[0] = BIT_MASK(EV_ABS);
+
+		input_set_abs_params(idev, ABS_X, -8192, 8191, INPUT_FUZZ, INPUT_FLAT);
+		input_set_abs_params(idev, ABS_Y, -8192, 8191, INPUT_FUZZ, INPUT_FLAT);
+		input_set_abs_params(idev, ABS_Z, -8192, 8191, INPUT_FUZZ, INPUT_FLAT);
+
+		result = input_register_polled_device(fxos8700_m_idev);
+		if (result) {
+			dev_err(&client->dev, "register poll device failed!\n");
+			goto err_register_polled_device1;
+		}
+		result = sysfs_create_group(&idev->dev.kobj, &mma8451_attr_group);
+		if (result) {
+			dev_err(&client->dev, "create device file failed!\n");
+			result = -EINVAL;
+			goto err_create_sysfs1;
+		}
+	}
+
+	result = of_property_read_u32(of_node, "position", &pos);
+	if (result)
+		pos = DEFAULT_POSITION;
+	mma_status.position = (int)pos;
+
+	return 0;
+
+err_create_sysfs1:
+	input_unregister_polled_device(fxos8700_m_idev);
+err_register_polled_device1:
+	input_free_polled_device(fxos8700_m_idev);
+err_alloc_poll_device:
+err_register_polled_device:
+	input_free_polled_device(mma8451_idev);
+err_out:
+	return result;
+}
+
+static int mma8451_stop_chip(struct i2c_client *client)
+{
+	int ret = 0;
+	if (mma_status.active == MMA_ACTIVED) {
+		mma_status.ctl_reg1 = i2c_smbus_read_byte_data(client,
+							       MMA8451_CTRL_REG1);
+		ret = i2c_smbus_write_byte_data(client, MMA8451_CTRL_REG1,
+						mma_status.ctl_reg1 & 0xFE);
+	}
+	return ret;
+}
+
+static int mma8451_remove(struct i2c_client *client)
+{
+	int ret;
+	ret = mma8451_stop_chip(client);
+
+	if (client_id == FXOS8700_ID) {
+		input_unregister_polled_device(fxos8700_m_idev);
+		input_free_polled_device(fxos8700_m_idev);
+	}
+	input_unregister_polled_device(mma8451_idev);
+	input_free_polled_device(mma8451_idev);
+
+	return ret;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int mma8451_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+
+	return mma8451_stop_chip(client);
+}
+
+static int mma8451_resume(struct device *dev)
+{
+	int ret = 0;
+	struct i2c_client *client = to_i2c_client(dev);
+	if (mma_status.active == MMA_ACTIVED)
+		ret = i2c_smbus_write_byte_data(client, MMA8451_CTRL_REG1,
+						mma_status.ctl_reg1);
+	return ret;
+
+}
+#endif
+
+static const struct i2c_device_id mma8451_id[] = {
+	{"mma8451", 0},
+	{"fxos8700", 0},
+	{ }
+};
+
+MODULE_DEVICE_TABLE(i2c, mma8451_id);
+
+static SIMPLE_DEV_PM_OPS(mma8451_pm_ops, mma8451_suspend, mma8451_resume);
+static struct i2c_driver mma8451_driver = {
+	.driver = {
+		   .name = "mma8451",
+		   .owner = THIS_MODULE,
+		   .pm = &mma8451_pm_ops,
+		   },
+	.probe = mma8451_probe,
+	.remove = mma8451_remove,
+	.id_table = mma8451_id,
+};
+
+static int __init mma8451_init(void)
+{
+	/* register driver */
+	int res;
+
+	res = i2c_add_driver(&mma8451_driver);
+	if (res < 0) {
+		printk(KERN_INFO "add mma8451 i2c driver failed\n");
+		return -ENODEV;
+	}
+	return res;
+}
+
+static void __exit mma8451_exit(void)
+{
+	i2c_del_driver(&mma8451_driver);
+}
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("MMA8451 3-Axis Orientation/Motion Detection Sensor driver");
+MODULE_LICENSE("GPL");
+
+module_init(mma8451_init);
+module_exit(mma8451_exit);
Index: trunk/target/linux/imx6/files-3.14/drivers/mfd/gsc-core.c
===================================================================
--- trunk/target/linux/imx6/files-3.14/drivers/mfd/gsc-core.c	(revision 0)
+++ trunk/target/linux/imx6/files-3.14/drivers/mfd/gsc-core.c	(working copy)
@@ -0,0 +1,459 @@
+/*
+ * Copyright (C) 2014 Gateworks Corporation
+ *
+ * Written by Tim Harvey <tharvey@gateworks.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/mfd/core.h>
+#include <linux/mfd/gsc.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+
+#include "gsc-core.h"
+
+#define I2C_RETRIES	3
+
+/*
+ * The Gateworks System Controller (GSC) is a family of a multi-function
+ * "Power Management and System Companion Device" chips originally designed for
+ * use in Gateworks Single Board Computers. The control interface is I2C,
+ * at 100kbps, with an interrupt.
+ *
+ * This driver core provides genirq support for the interrupts emitted,
+ * by the various modules, and exports register access primitives.
+ *
+ */
+
+#define DRIVER_NAME			"gsc"
+
+/*----------------------------------------------------------------------*/
+
+struct gsc {
+	struct i2c_client *client;
+	struct device *dev;
+	unsigned int fwver;
+	unsigned short fwcrc;
+	unsigned char ready;
+	struct mutex io_lock;
+	struct platform_device *gsc;
+	struct platform_device *wdt;
+	struct platform_device *input;
+};
+
+static struct gsc *gsc_priv;
+
+/**
+ * gsc_i2c_write - Writes a register to GSC with retries
+ * @reg: register address
+ * @val: value to write
+ *
+ * Returns the result of operation - 0 is success
+ */
+int __gsc_i2c_write(u8 reg, u8 val)
+{
+	int retry, ret;
+
+	for (retry = 0; retry < I2C_RETRIES; retry++) {
+		ret = i2c_smbus_write_byte_data(gsc_priv->client, reg, val);
+		/*
+		 * -EAGAIN returned when the i2c host controller is busy
+		 * -EIO returned when i2c device is busy
+		 */
+		if (ret != -EAGAIN && ret != -EIO)
+			break;
+	}
+	if (ret < 0) {
+		dev_err(&gsc_priv->client->dev, ">> 0x%02x %d\n", reg, ret);
+		return ret;
+	}
+	dev_dbg(&gsc_priv->client->dev, ">> 0x%02x=0x%02x (%d)\n", reg,
+		val, retry);
+
+	return 0;
+}
+
+/**
+ * gsc_i2c_read - Reads register from GSC with retries
+ * @reg: register address
+ * @val: value to write
+ *
+ * Returns result of operation
+ */
+static int __gsc_i2c_read(u8 reg, u8 *val)
+{
+	int retry, ret;
+
+	for (retry = 0; retry < I2C_RETRIES; retry++) {
+		ret = i2c_smbus_read_byte_data(gsc_priv->client, reg);
+		/*
+		 * -EAGAIN returned when the i2c host controller is busy
+		 * -EIO returned when i2c device is busy
+		 */
+		if (ret != -EAGAIN && ret != -EIO)
+			break;
+	}
+	if (ret < 0) {
+		dev_err(&gsc_priv->client->dev, "<< 0x%02x %d\n", reg, ret);
+		return ret;
+	}
+
+	*val = ret & 0xff;
+	dev_dbg(&gsc_priv->client->dev, "<< 0x%02x=0x%02x (%d)\n", reg,
+		*val, retry);
+
+	return 0;
+}
+
+/**
+ * gsc_i2c_update - set bits
+ * @reg: register address
+ * @mask: bits to clear
+ * @set; bits to set
+ *
+ * Returns result of operation
+ */
+static int __gsc_i2c_update(u8 reg, u8 mask, u8 set)
+{
+	u8 rval;
+	int ret;
+
+	ret = __gsc_i2c_read(reg, &rval);
+	if (ret)
+		return ret;
+	rval &= ~mask;
+	ret = __gsc_i2c_write(reg, rval | set);
+	return ret;
+}
+
+/* Exported Functions */
+
+/**
+ * gsc_i2c_write - Writes a register to GSC
+ * @reg: register address
+ * @val: value to write
+ *
+ * Returns the result of operation - 0 is success
+ */
+int gsc_i2c_write(u8 reg, u8 val)
+{
+	struct device *dev = &gsc_priv->client->dev;
+	int ret = 0;
+
+	if (unlikely(!gsc_priv || !gsc_priv->ready)) {
+		pr_err("%s: not initialized\n", DRIVER_NAME);
+		return -EPERM;
+	}
+
+	mutex_lock(&gsc_priv->io_lock);
+	ret = __gsc_i2c_write(reg, val);
+	if (ret < 0)
+		dev_err(dev, ">> 0x%02x %d\n", reg, ret);
+	else
+		dev_dbg(dev, ">> 0x%02x=0x%02x\n", reg, val);
+	mutex_unlock(&gsc_priv->io_lock);
+
+	return ret;
+}
+EXPORT_SYMBOL(gsc_i2c_write);
+
+/**
+ * gsc_i2c_read - Reads register from GSC
+ * @reg: register address
+ * @val: value to write
+ *
+ * Returns result of operation
+ */
+int gsc_i2c_read(u8 reg, u8 *val)
+{
+	struct device *dev = &gsc_priv->client->dev;
+	int ret = 0;
+
+	if (unlikely(!gsc_priv || !gsc_priv->ready)) {
+		pr_err("%s: not initialized\n", DRIVER_NAME);
+		return -EPERM;
+	}
+
+	mutex_lock(&gsc_priv->io_lock);
+	ret = __gsc_i2c_read(reg, val);
+	if (ret < 0)
+		dev_err(dev, "<< 0x%02x %d\n", reg, ret);
+	else
+		dev_dbg(dev, "<< 0x%02x=0x%02x\n", reg, *val);
+	mutex_unlock(&gsc_priv->io_lock);
+
+	return ret;
+}
+EXPORT_SYMBOL(gsc_i2c_read);
+
+/**
+ * gsc_i2c_update - read/write register from GSC
+ * @reg: register address
+ * @mask: bits to clear
+ * @val: bits to set
+ *
+ * Returns result of operation
+ */
+int gsc_i2c_update(u8 reg, u8 mask, u8 val)
+{
+	int ret = 0;
+
+	if (unlikely(!gsc_priv || !gsc_priv->ready)) {
+		pr_err("%s: not initialized\n", DRIVER_NAME);
+		return -EPERM;
+	}
+
+	mutex_lock(&gsc_priv->io_lock);
+	ret = __gsc_i2c_update(reg, mask, val);
+	mutex_unlock(&gsc_priv->io_lock);
+
+	return ret;
+}
+EXPORT_SYMBOL(gsc_i2c_update);
+
+/*----------------------------------------------------------------------*/
+
+/**
+ * gsc_get_fwver - API to get GSC FW version.
+ */
+int gsc_get_fwver(void)
+{
+	if (unlikely(!gsc_priv || !gsc_priv->ready)) {
+		pr_err("%s: not initialized\n", DRIVER_NAME);
+		return -EPERM;
+	}
+
+	return gsc_priv->fwver;
+}
+EXPORT_SYMBOL_GPL(gsc_get_fwver);
+
+/*
+ * gsc_powerdown - API to use GSC to power down board for a specific time
+ *
+ * secs - number of seconds to remain powered off
+ */
+int gsc_powerdown(unsigned long secs)
+{
+	int ret;
+
+	if (!gsc_priv)
+		return -ENODEV;
+
+	dev_info(&gsc_priv->client->dev, "GSC powerdown for %ld seconds\n",
+		 secs);
+	mutex_lock(&gsc_priv->io_lock);
+	ret = __gsc_i2c_write(GSC_TIME_ADD + 0, secs & 0xff);
+	if (ret)
+		goto done;
+	ret = __gsc_i2c_write(GSC_TIME_ADD + 1, (secs >> 8) & 0xff);
+	if (ret)
+		goto done;
+	ret = __gsc_i2c_write(GSC_TIME_ADD + 2, (secs >> 16) & 0xff);
+	if (ret)
+		goto done;
+	ret = __gsc_i2c_write(GSC_TIME_ADD + 3, (secs >> 24) & 0xff);
+	if (ret)
+		goto done;
+	ret = __gsc_i2c_update(GSC_CTRL_1, 0, 1 << GSC_CTRL_1_LATCH_SLEEP_ADD);
+	if (ret)
+		goto done;
+	ret = __gsc_i2c_update(GSC_CTRL_1, 0, 1 << GSC_CTRL_1_ACTIVATE_SLEEP |
+			       1 << GSC_CTRL_1_SLEEP_ENABLE);
+	if (ret)
+		goto done;
+
+	ret = 0;
+
+done:
+	mutex_unlock(&gsc_priv->io_lock);
+
+	return ret;
+}
+
+/*----------------------------------------------------------------------*/
+
+
+/*
+ * sysfs hooks
+ */
+static ssize_t gsc_show(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct gsc *gsc = dev_get_drvdata(dev);
+	const char *name = attr->attr.name;
+	int rz = 0;
+
+	if (strcasecmp(name, "fw_version") == 0)
+		rz = sprintf(buf, "%d\n", gsc->fwver);
+	else if (strcasecmp(name, "fw_crc") == 0)
+		rz = sprintf(buf, "0x%04x\n", gsc->fwcrc);
+
+	return rz;
+}
+
+static ssize_t gsc_store(struct device *dev, struct device_attribute *attr,
+			 const char *buf, size_t count)
+{
+	const char *name = attr->attr.name;
+	int ret;
+
+	if (strcasecmp(name, "powerdown") == 0) {
+		long value;
+
+		ret = strict_strtol(buf, 0, &value);
+		if (ret == 0)
+			gsc_powerdown(value);
+	} else
+		printk(KERN_ERR "invalid name '%s\n", name);
+
+	return count;
+}
+
+
+/*
+ * Create a group of attributes so that we can create and destroy them all
+ * at once.
+ */
+static struct device_attribute attr_fwver =
+	__ATTR(fw_version, 0440, gsc_show, NULL);
+static struct device_attribute attr_fwcrc =
+	__ATTR(fw_crc, 0440, gsc_show, NULL);
+static struct device_attribute attr_pwrdown =
+	__ATTR(powerdown, 0220, NULL, gsc_store);
+
+static struct attribute *gsc_attrs[] = {
+	&attr_fwver.attr,
+	&attr_fwcrc.attr,
+	&attr_pwrdown.attr,
+	NULL,
+};
+
+static struct attribute_group attr_group = {
+	.attrs = gsc_attrs,
+};
+
+static int
+gsc_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	struct device *dev = &client->dev;
+	struct gsc *gsc;
+	int ret, irq_base = 0;
+	u8 reg;
+
+	if (client->irq <= 0) {
+		dev_err(dev, "%s: no irq specified\n", DRIVER_NAME);
+		return -EINVAL;
+	}
+	if (gsc_priv) {
+		dev_err(dev, "already initialized\n");
+		return -EBUSY;
+	}
+
+	if (i2c_check_functionality(client->adapter, I2C_FUNC_I2C) == 0) {
+		dev_dbg(dev, "can't talk I2C?\n");
+		return -EIO;
+	}
+
+
+	gsc = devm_kzalloc(dev, sizeof(struct gsc), GFP_KERNEL);
+	if (!gsc)
+		ret = -ENOMEM;
+	gsc_priv = gsc;
+
+	mutex_init(&gsc->io_lock);
+	gsc->client = client;
+
+	if (__gsc_i2c_read(GSC_FW_VER, &reg))
+		return -EIO;
+	gsc->fwver = reg;
+	__gsc_i2c_read(GSC_FW_CRC, &reg);
+	gsc->fwcrc = reg << 8;
+	__gsc_i2c_read(GSC_FW_CRC+1, &reg);
+	gsc->fwcrc |= reg;
+	gsc->ready = true;
+
+	irq_base = gsc_irq_init(&client->dev, client->irq);
+	if (irq_base < 0)
+		return irq_base;
+	dev_info(dev, "Gateworks System Controller: fw v%02d crc=0x%04x irq%d\n",
+		 gsc->fwver, gsc->fwcrc, client->irq);
+
+	i2c_set_clientdata(client, gsc);
+	gsc->dev = &client->dev;
+
+	ret = sysfs_create_group(&client->dev.kobj, &attr_group);
+	if (ret)
+		dev_err(dev, "failed to create sysfs attrs\n");
+
+	if (client->dev.of_node) {
+		printk("Populating platform devices\n");
+		ret = of_platform_populate(client->dev.of_node, NULL, NULL,
+					   &client->dev);
+	}
+
+	return ret;
+}
+
+static int gsc_remove(struct i2c_client *client)
+{
+	struct gsc *gsc = i2c_get_clientdata(client);
+
+	sysfs_remove_group(&client->dev.kobj, &attr_group);
+	mfd_remove_devices(gsc->dev);
+	gsc_priv = NULL;
+
+	return 0;
+}
+
+static const struct i2c_device_id gsc_i2c_ids[] = {
+	{ "gsc", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, gsc_i2c_ids);
+
+static const struct of_device_id gsc_dt_ids[] = {
+	{ .compatible = "gw,gsc", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, gsc_dt_ids);
+
+static struct i2c_driver gsc_driver = {
+	.driver = {
+		.name	= DRIVER_NAME,
+		.of_match_table = gsc_dt_ids,
+	},
+	.probe		= gsc_probe,
+	.remove		= gsc_remove,
+	.id_table	= gsc_i2c_ids,
+};
+
+static int __init gsc_init(void)
+{
+        return i2c_add_driver(&gsc_driver);
+}
+/* register after i2c postcore initcall and before
+ * subsys initcalls that may rely on these GPIOs
+ */
+subsys_initcall(gsc_init);
+
+static void __exit gsc_exit(void)
+{
+        i2c_del_driver(&gsc_driver);
+}
+module_exit(gsc_exit);
+
+MODULE_AUTHOR("Tim Harvey <tharvey@gateworks.com>");
+MODULE_DESCRIPTION("I2C Core interface for GSC");
+MODULE_LICENSE("GPL v2");
Index: trunk/target/linux/imx6/files-3.14/drivers/mfd/gsc-core.h
===================================================================
--- trunk/target/linux/imx6/files-3.14/drivers/mfd/gsc-core.h	(revision 0)
+++ trunk/target/linux/imx6/files-3.14/drivers/mfd/gsc-core.h	(working copy)
@@ -0,0 +1,7 @@
+#ifndef __GSC_CORE_H_
+#define __GSC_CORE_H_
+
+extern int gsc_irq_init(struct device *dev, int irq_num);
+extern int gsc_irq_exit(void);
+
+#endif /* __GSC_CORE_H_ */
Index: trunk/target/linux/imx6/files-3.14/drivers/mfd/gsc-irq.c
===================================================================
--- trunk/target/linux/imx6/files-3.14/drivers/mfd/gsc-irq.c	(revision 0)
+++ trunk/target/linux/imx6/files-3.14/drivers/mfd/gsc-irq.c	(working copy)
@@ -0,0 +1,129 @@
+/*
+ * Copyright (C) 2014 Gateworks Corporation
+ *
+ * Written by Tim Harvey <tharvey@gateworks.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/irqdomain.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+
+#include <linux/mfd/gsc.h>
+
+struct gsc_agent {
+	int irq_base;
+	int irq_num;
+};
+
+static struct gsc_agent *gsc_agent;
+
+static struct irq_chip gsc_irq_chip = {
+	.name		= "gsc",
+	.flags		= IRQCHIP_SKIP_SET_WAKE,
+};
+
+static irqreturn_t gsc_irq(int irq, void *data)
+{
+	struct gsc_agent *agent = data;
+	u8 sts;
+
+	gsc_i2c_read(GSC_IRQ_STATUS, &sts);
+	pr_debug("gsc: irq%d status=0x%02x\n", irq, sts);
+
+	while (sts) {
+		irq = fls(sts);
+		irq--;
+		sts &= ~BIT(irq);
+
+		handle_nested_irq(agent->irq_base + irq);
+	}
+
+	/* clear all status bits */
+	gsc_i2c_write(GSC_IRQ_STATUS, 0);
+
+	return IRQ_HANDLED;
+}
+
+int gsc_irq_init(struct device *dev, int irq_num)
+{
+	static struct irq_chip gsc_mod_irq_chip;
+	int ret, i;
+	int irq_base, irq_end, nr_irqs;
+	struct device_node *node = dev->of_node;
+	struct gsc_agent *agent;
+	u8 reg;
+
+	agent = devm_kzalloc(dev, sizeof *agent, GFP_KERNEL);
+	if (!agent)
+		return -ENOMEM;
+
+	nr_irqs = 8;
+
+	/* allocate 8 virq's for GSC status register bits */
+	irq_base = irq_alloc_descs(-1, 0, nr_irqs, 0);
+	if (irq_base< 0)
+		return irq_base;
+
+	irq_domain_add_legacy(node, nr_irqs, irq_base, 0,
+			      &irq_domain_simple_ops, NULL);
+	irq_end = irq_base + nr_irqs;
+
+	/* clear all GSC interrupts */
+	ret = gsc_i2c_read(GSC_IRQ_ENABLE, &reg);
+	if (ret < 0) {
+		dev_err(dev, "failed reading GSC_IRQ_ENABLE\n");
+		return ret;
+	}
+	if (reg == 0)
+		dev_warn(dev, "no GSC interrupts enabled\n");
+	gsc_i2c_write(GSC_IRQ_STATUS, 0);
+
+	/* install irq handler for each module */
+	gsc_mod_irq_chip = dummy_irq_chip;
+	gsc_mod_irq_chip.name = "gsc";
+
+	gsc_irq_chip.irq_ack = dummy_irq_chip.irq_ack;
+	agent->irq_base = irq_base;
+
+	for (i = irq_base; i < irq_end; i++) {
+		irq_set_chip_data(i, agent);
+		irq_set_chip_and_handler(i, &gsc_mod_irq_chip,
+					 handle_simple_irq);
+		irq_set_nested_thread(i, 1);
+	}
+	gsc_i2c_write(GSC_IRQ_ENABLE, reg);
+
+	/* install irq handler to demux the GSC IRQ */
+	ret = devm_request_threaded_irq(dev, irq_num, NULL, gsc_irq,
+					IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
+					"gsc", agent);
+	if (ret < 0) {
+		dev_err(dev, "could not claim irq%d: %d\n", irq_num, ret);
+		goto fail_reqirq;
+	}
+	enable_irq_wake(irq_num);
+	gsc_agent = agent;
+	gsc_agent->irq_num = irq_num;
+
+	return irq_base;
+
+fail_reqirq:
+	irq_free_descs(irq_base, nr_irqs);
+
+	return ret;
+}
+
+int gsc_irq_exit(void)
+{
+	irq_free_descs(gsc_agent->irq_base, nr_irqs);
+	return 0;
+}
Index: trunk/target/linux/imx6/files-3.14/drivers/net/phy/gw16083.c
===================================================================
--- trunk/target/linux/imx6/files-3.14/drivers/net/phy/gw16083.c	(revision 42297)
+++ trunk/target/linux/imx6/files-3.14/drivers/net/phy/gw16083.c	(working copy)
@@ -485,9 +485,13 @@
 					state->sfp_compat = false;
 				else
 					state->sfp_compat = true;
+				/* trigger a re-select/enable below */
+				state->serdes = !serdes;
+				pdev->state = PHY_RUNNING;
 			} else {
 				state->sfp_compat = false;
 				state->sfp_enabled = false;
+				pdev->state = PHY_NOLINK;
 			}
 		}
 		if (state->sfp_signal != sfp_signal) {
@@ -510,11 +514,8 @@
 			}
 		}
 
-		/*
-		 * if serdes and compatible SFP module and not yet enabled
-		 * then enable for serdes
-		 */
-		if (serdes && state->sfp_compat && state->sfp_signal &&
+		/* if compatible SFP module and not yet enabled then enable */
+		if (state->sfp_compat && state->sfp_signal &&
 		    !state->sfp_enabled)
 		{
 			if (!config_mv88e1111_port_sfp(pdev, port, 1))
Index: trunk/target/linux/imx6/files-3.14/drivers/watchdog/gsc_wdt.c
===================================================================
--- trunk/target/linux/imx6/files-3.14/drivers/watchdog/gsc_wdt.c	(revision 0)
+++ trunk/target/linux/imx6/files-3.14/drivers/watchdog/gsc_wdt.c	(working copy)
@@ -0,0 +1,178 @@
+/*
+ * Copyright (C) 2014 Gateworks Corporation
+ *
+ * Written by Tim Harvey <tharvey@gateworks.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/types.h>
+#include <linux/slab.h>
+#include <linux/watchdog.h>
+
+#include <linux/mfd/gsc.h>
+
+static bool nowayout = WATCHDOG_NOWAYOUT;
+module_param(nowayout, bool, 0);
+MODULE_PARM_DESC(nowayout, "Watchdog cannot be stopped once started "
+        "(default=" __MODULE_STRING(WATCHDOG_NOWAYOUT) ")");
+
+static int gsc_wdt_start(struct watchdog_device *wdt)
+{
+	u8 reg = (1 << GSC_CTRL_1_WDT_ENABLE);
+
+	dev_dbg(wdt->dev, "%s timeout=%d\n", __func__, wdt->timeout);
+
+	return gsc_i2c_update(GSC_CTRL_1, reg, reg);
+}
+
+static int gsc_wdt_stop(struct watchdog_device *wdt)
+{
+	u8 reg = (1 << GSC_CTRL_1_WDT_ENABLE);
+
+	dev_dbg(wdt->dev, "%s\n", __func__);
+
+	return gsc_i2c_update(GSC_CTRL_1, reg, 0);
+}
+
+static int gsc_wdt_set_timeout(struct watchdog_device *wdt,
+			       unsigned int timeout)
+{
+	u8 long_sel = 0;
+
+	dev_dbg(wdt->dev, "%s: %d\n", __func__, timeout);
+
+	switch (timeout) {
+	case 60:
+		long_sel = (1 << GSC_CTRL_1_WDT_TIME);
+	case 30:
+		gsc_i2c_update(GSC_CTRL_1,
+			       (1 << GSC_CTRL_1_WDT_TIME),
+			       (long_sel << GSC_CTRL_1_WDT_TIME));
+		wdt->timeout = timeout;
+		return 0;
+	}
+
+	return -EINVAL;
+}
+
+static const struct watchdog_info gsc_wdt_info = {
+	.options = WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING,
+	.identity = "GSC Watchdog"
+};
+
+static const struct watchdog_ops gsc_wdt_ops = {
+	.owner		= THIS_MODULE,
+	.start		= gsc_wdt_start,
+	.stop		= gsc_wdt_stop,
+	.set_timeout	= gsc_wdt_set_timeout,
+};
+
+static int gsc_wdt_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	struct watchdog_device *wdt;
+	u8 reg;
+
+	if (gsc_get_fwver() < 44) {
+		dev_err(&pdev->dev, "firmware v44 or newer required "
+			"for watchdog functionality\n");
+		return -EINVAL;
+	}
+
+	/* ensure WD bit enabled */
+	if (gsc_i2c_read(GSC_CTRL_1, &reg)) {
+		dev_err(&pdev->dev, "failed reading GSC_CTRL_1\n");
+		return -EIO;
+	}
+	if (!(reg & (1 << GSC_CTRL_1_WDT_ENABLE))) {
+		dev_err(&pdev->dev, "GSC WDT_ENABLE not enabled"
+			" - must be manually enabled\n");
+		return -EINVAL;
+	}
+
+	wdt = devm_kzalloc(&pdev->dev, sizeof(*wdt), GFP_KERNEL);
+	if (!wdt)
+		return -ENOMEM;
+
+	wdt->info		= &gsc_wdt_info;
+	wdt->ops		= &gsc_wdt_ops;
+	wdt->status		= 0;
+	wdt->timeout		= 30;
+	wdt->min_timeout	= 30;
+	wdt->max_timeout	= 60;
+
+	watchdog_set_nowayout(wdt, nowayout);
+	platform_set_drvdata(pdev, wdt);
+
+	ret = watchdog_register_device(wdt);
+	if (ret) {
+		platform_set_drvdata(pdev, NULL);
+		return ret;
+	}
+	dev_info(&pdev->dev, "registerted watchdog (nowayout=%d)\n",
+		 nowayout);
+
+	return 0;
+}
+
+static int gsc_wdt_remove(struct platform_device *pdev)
+{
+	struct watchdog_device *wdt = platform_get_drvdata(pdev);
+
+	watchdog_unregister_device(wdt);
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int gsc_wdt_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct watchdog_device *wdt = platform_get_drvdata(pdev);
+	if (watchdog_active(wdt))
+		return gsc_wdt_stop(wdt);
+
+	return 0;
+}
+
+static int gsc_wdt_resume(struct platform_device *pdev)
+{
+	struct watchdog_device *wdt = platform_get_drvdata(pdev);
+	if (watchdog_active(wdt))
+		return gsc_wdt_start(wdt);
+
+	return 0;
+}
+#else
+#define gsc_wdt_suspend        NULL
+#define gsc_wdt_resume         NULL
+#endif
+
+static const struct of_device_id gsc_wdt_dt_ids[] = {
+	{ .compatible = "gw,gsc_wdt", },
+	{ /* sentinel */ }
+};
+
+static struct platform_driver gsc_wdt_driver = {
+	.probe		= gsc_wdt_probe,
+	.remove		= gsc_wdt_remove,
+	.suspend	= gsc_wdt_suspend,
+	.resume		= gsc_wdt_resume,
+	.driver		= {
+		.owner	= THIS_MODULE,
+		.name	= "gsc_wdt",
+		.of_match_table = gsc_wdt_dt_ids,
+	},
+};
+
+module_platform_driver(gsc_wdt_driver);
+
+MODULE_AUTHOR("Tim Harvey <tharvey@gateworks.com>");
+MODULE_DESCRIPTION("Watchdog driver for GSC");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:gsc_wdt");
Index: trunk/target/linux/imx6/files-3.14/include/linux/mfd/gsc.h
===================================================================
--- trunk/target/linux/imx6/files-3.14/include/linux/mfd/gsc.h	(revision 0)
+++ trunk/target/linux/imx6/files-3.14/include/linux/mfd/gsc.h	(working copy)
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2014 Gateworks Corporation
+ *
+ * Written by Tim Harvey <tharvey@gateworks.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __GSC_H_
+#define __GSC_H_
+
+struct gsc_platform_data {
+	struct pca953x_platform_data *pca953x_data;
+};
+
+/* Register offsets */
+#define GSC_CTRL_0	0x00
+#define GSC_CTRL_1	0x01
+#define GSC_TIME	0x02
+#define GSC_TIME_ADD	0x06
+#define GSC_IRQ_STATUS	0x0A
+#define GSC_IRQ_ENABLE	0x0B
+#define GSC_FW_CRC	0x0C
+#define GSC_FW_VER	0x0E
+#define GSC_WP		0x0F
+
+/* Bit definitions */
+#define GSC_CTRL_0_PB_HARD_RESET	0
+#define GSC_CTRL_0_PB_CLEAR_SECURE_KEY	1
+#define GSC_CTRL_0_PB_SOFT_POWER_DOWN	2
+#define GSC_CTRL_0_PB_BOOT_ALTERNATE	3
+#define GSC_CTRL_0_PERFORM_CRC		4
+#define GSC_CTRL_0_TAMPER_DETECT	5
+#define GSC_CTRL_0_SWITCH_HOLD		6
+
+#define GSC_CTRL_1_SLEEP_ENABLE		0
+#define GSC_CTRL_1_ACTIVATE_SLEEP	1
+#define GSC_CTRL_1_LATCH_SLEEP_ADD	2
+#define GSC_CTRL_1_SLEEP_NOWAKEPB	3
+#define GSC_CTRL_1_WDT_TIME		4
+#define GSC_CTRL_1_WDT_ENABLE		5
+#define GSC_CTRL_1_SWITCH_BOOT_ENABLE	6
+#define GSC_CTRL_1_SWITCH_BOOT_CLEAR	7
+
+#define GSC_IRQ_PB			0
+#define GSC_IRQ_KEY_ERASED		1
+#define GSC_IRQ_EEPROM_WP		2
+#define GSC_IRQ_GPIO			4
+#define GSC_IRQ_TAMPER			5
+#define GSC_IRQ_ALT_BOOT		6
+#define GSC_IRQ_SWITCH_HOLD		7
+
+/*
+ * Read and write single 8-bit registers
+ */
+int gsc_i2c_write(u8 reg, u8 val);
+int gsc_i2c_read(u8 reg, u8 *val);
+int gsc_i2c_update(u8 reg, u8 valmask, u8 val);
+
+int gsc_get_fwver(void);
+int gsc_powerdown(unsigned long seconds);
+
+#endif
Index: trunk/target/linux/imx6/patches-3.14/0003-ARM-dts-add-Gateworks-Ventana-support.patch
===================================================================
--- trunk/target/linux/imx6/patches-3.14/0003-ARM-dts-add-Gateworks-Ventana-support.patch	(revision 42297)
+++ trunk/target/linux/imx6/patches-3.14/0003-ARM-dts-add-Gateworks-Ventana-support.patch	(working copy)
@@ -1457,7 +1457,7 @@
 +
 +	accelerometer: fxos8700@1e {
 +		compatible = "fsl,fxos8700";
-+		reg = <0x13>;
++		reg = <0x1e>;
 +	};
 +
 +	codec: sgtl5000@0a {
Index: trunk/target/linux/imx6/patches-3.14/0009-ARM-imx-dts-add-GW52xx-can-support.patch
===================================================================
--- trunk/target/linux/imx6/patches-3.14/0009-ARM-imx-dts-add-GW52xx-can-support.patch	(revision 0)
+++ trunk/target/linux/imx6/patches-3.14/0009-ARM-imx-dts-add-GW52xx-can-support.patch	(working copy)
@@ -0,0 +1,45 @@
+--- a/arch/arm/boot/dts/imx6qdl-gw52xx.dtsi
++++ b/arch/arm/boot/dts/imx6qdl-gw52xx.dtsi
+@@ -12,6 +12,7 @@
+ / {
+ 	/* these are used by bootloader for disabling nodes */
+ 	aliases {
++		can0 = &can1;
+ 		ethernet0 = &fec;
+ 		led0 = &led0;
+ 		led1 = &led1;
+@@ -142,6 +143,12 @@
+ 	status = "okay";
+ };
+ 
++&can1 {
++	pinctrl-names = "default";
++	pinctrl-0 = <&pinctrl_flexcan1>;
++	status = "okay";
++};
++
+ &fec {
+ 	pinctrl-names = "default";
+ 	pinctrl-0 = <&pinctrl_enet>;
+@@ -325,6 +332,7 @@
+ 				MX6QDL_PAD_ENET_RXD1__GPIO1_IO26 0x80000000 /* GPS_PPS */
+ 				MX6QDL_PAD_GPIO_0__CCM_CLKO1     0x000130b0 /* AUD4_MCK */
+ 				MX6QDL_PAD_GPIO_2__GPIO1_IO02    0x80000000 /* USB_SEL_PCI */
++				MX6QDL_PAD_GPIO_9__GPIO1_IO09    0x80000000 /* CAN_STBY */
+ 				MX6QDL_PAD_GPIO_17__GPIO7_IO12   0x80000000 /* TOUCH_IRQ# */
+ 				MX6QDL_PAD_KEY_COL0__GPIO4_IO06  0x80000000 /* user1 led */
+ 				MX6QDL_PAD_KEY_ROW0__GPIO4_IO07  0x80000000 /* user2 led */
+@@ -365,6 +373,13 @@
+ 			>;
+ 		};
+ 
++		pinctrl_flexcan1: flexcan1grp {
++			fsl,pins = <
++				MX6QDL_PAD_KEY_ROW2__FLEXCAN1_RX	0x80000000
++				MX6QDL_PAD_KEY_COL2__FLEXCAN1_TX	0x80000000
++			>;
++		};
++
+ 		pinctrl_gpmi_nand: gpminandgrp {
+ 			fsl,pins = <
+ 				MX6QDL_PAD_NANDF_CLE__NAND_CLE		0xb0b1
Index: trunk/target/linux/imx6/patches-3.14/0065-imx-thermal-use-CPU-temperature-grade-info-for-thresholds.patch
===================================================================
--- trunk/target/linux/imx6/patches-3.14/0065-imx-thermal-use-CPU-temperature-grade-info-for-thresholds.patch	(revision 0)
+++ trunk/target/linux/imx6/patches-3.14/0065-imx-thermal-use-CPU-temperature-grade-info-for-thresholds.patch	(working copy)
@@ -0,0 +1,111 @@
+--- a/drivers/thermal/imx_thermal.c
++++ b/drivers/thermal/imx_thermal.c
+@@ -44,6 +44,7 @@
+ #define TEMPSENSE1			0x0190
+ #define TEMPSENSE1_MEASURE_FREQ		0xffff
+ 
++#define OCOTP_MEM0			0x0480
+ #define OCOTP_ANA1			0x04e0
+ 
+ /* The driver supports 1 passive trip point and 1 critical trip point */
+@@ -53,12 +54,6 @@ enum imx_thermal_trip {
+ 	IMX_TRIP_NUM,
+ };
+ 
+-/*
+- * It defines the temperature in millicelsius for passive trip point
+- * that will trigger cooling action when crossed.
+- */
+-#define IMX_TEMP_PASSIVE		85000
+-
+ #define IMX_POLLING_DELAY		2000 /* millisecond */
+ #define IMX_PASSIVE_DELAY		1000
+ 
+@@ -70,11 +65,13 @@ struct imx_thermal_data {
+ 	int c1, c2; /* See formula in imx_get_sensor_data() */
+ 	unsigned long temp_passive;
+ 	unsigned long temp_critical;
++	unsigned long temp_max;
+ 	unsigned long alarm_temp;
+ 	unsigned long last_temp;
+ 	bool irq_enabled;
+ 	int irq;
+ 	struct clk *thermal_clk;
++	const char* temp_grade;
+ };
+ 
+ static void imx_set_alarm_temp(struct imx_thermal_data *data,
+@@ -239,10 +236,12 @@ static int imx_set_trip_temp(struct ther
+ {
+ 	struct imx_thermal_data *data = tz->devdata;
+ 
++	/* do not allow changing critical threshold */
+ 	if (trip == IMX_TRIP_CRITICAL)
+ 		return -EPERM;
+ 
+-	if (temp > IMX_TEMP_PASSIVE)
++	/* do not allow passive to be set higher than critical */
++	if (temp > data->temp_critical)
+ 		return -EINVAL;
+ 
+ 	data->temp_passive = temp;
+@@ -352,17 +351,39 @@ static int imx_get_sensor_data(struct pl
+ 	data->c1 = 1000 * (t1 - t2) / (n1 - n2);
+ 	data->c2 = 1000 * t2 - data->c1 * n2;
+ 
+-	/*
+-	 * Set the default passive cooling trip point to 20 C below the
+-	 * maximum die temperature. Can be changed from userspace.
+-	 */
+-	data->temp_passive = 1000 * (t2 - 20);
++	/* use OTP for thermal grade */
++	ret = regmap_read(map, OCOTP_MEM0, &val);
++	if (ret) {
++		dev_err(&pdev->dev, "failed to read temp grade: %d\n", ret);
++		return ret;
++	}
++
++	/* The maximum die temp is specified by the Temperature Grade */
++	switch ((val >> 6) & 0x3) {
++	case 0: /* Commercial (0 to 95C) */
++		data->temp_grade = "Commercial";
++		data->temp_max = 95000;
++		break;
++	case 1: /* Extended Commercial (-20 to 105C) */
++		data->temp_grade = "Extended Commercial";
++		data->temp_max = 105000;
++		break;
++	case 2: /* Industrial (-40 to 105C) */
++		data->temp_grade = "Industrial";
++		data->temp_max = 105000;
++		break;
++	case 3: /* Automotive (-40 to 125C) */
++		data->temp_grade = "Automotive";
++		data->temp_max = 125000;
++		break;
++	}
+ 
+ 	/*
+-	 * The maximum die temperature is t2, let's give 5 C cushion
+-	 * for noise and possible temperature rise between measurements.
++	 * Set the critical trip point at 5C under max
++	 * Set the passive trip point at 10C under max (can change via sysfs)
+ 	 */
+-	data->temp_critical = 1000 * (t2 - 5);
++	data->temp_critical = data->temp_max - (1000 * 5);
++	data->temp_passive = data->temp_max - (1000 * 10);
+ 
+ 	return 0;
+ }
+@@ -475,6 +496,11 @@ static int imx_thermal_probe(struct plat
+ 			dev_warn(&pdev->dev, "failed to enable thermal clk: %d\n", ret);
+ 	}
+ 
++	dev_info(&pdev->dev, "%s CPU temperature grade - max:%ldC"
++		 " critical:%ldC passive:%ldC\n", data->temp_grade,
++		 data->temp_max / 1000, data->temp_critical / 1000,
++		 data->temp_passive / 1000);
++
+ 	/* Enable measurements at ~ 10 Hz */
+ 	regmap_write(map, TEMPSENSE1 + REG_CLR, TEMPSENSE1_MEASURE_FREQ);
+ 	measure_freq = DIV_ROUND_UP(32768, 10); /* 10 Hz */
Index: trunk/target/linux/imx6/patches-3.14/195-pci-imx6-disable-Gen2.patch
===================================================================
--- trunk/target/linux/imx6/patches-3.14/195-pci-imx6-disable-Gen2.patch	(revision 0)
+++ trunk/target/linux/imx6/patches-3.14/195-pci-imx6-disable-Gen2.patch	(working copy)
@@ -0,0 +1,47 @@
+From 4327e2a93909ea98e0ae7f9232f7191dba11d166 Mon Sep 17 00:00:00 2001
+From: Pushpal Sidhu <psidhu@gateworks.com>
+Date: Wed, 10 Jun 2015 15:21:33 -0700
+Subject: [PATCH] pci: imx6: disable Gen2
+
+Disable pcie-gen2 in this kernel as the products meant to run it do not fall
+within specification for it. Instead, leave only Gen1 enabled.
+
+Signed-off-by: Tim Harvey <tharvey@gateworks.com>
+Signed-off-by: Pushpal Sidhu <psidhu@gateworks.com>
+---
+ drivers/pci/host/pci-imx6.c | 7 +++++--
+ 1 file changed, 5 insertions(+), 2 deletions(-)
+
+diff --git a/drivers/pci/host/pci-imx6.c b/drivers/pci/host/pci-imx6.c
+index e0ea1f7..2949636 100644
+--- a/drivers/pci/host/pci-imx6.c
++++ b/drivers/pci/host/pci-imx6.c
+@@ -396,12 +396,15 @@ static int imx6_pcie_start_link(struct pcie_port *pp)
+ 	if (ret)
+ 		return ret;
+ 
++#if 0   /* Disable Gen2 */
+ 	/* Allow Gen2 mode after the link is up. */
+ 	tmp = readl(pp->dbi_base + PCIE_RC_LCR);
+ 	tmp &= ~PCIE_RC_LCR_MAX_LINK_SPEEDS_MASK;
+ 	tmp |= PCIE_RC_LCR_MAX_LINK_SPEEDS_GEN2;
+ 	writel(tmp, pp->dbi_base + PCIE_RC_LCR);
+-
++#else
++	dev_info(pp->dev, "Link: Gen2 disabled\n");
++#endif
+ 	/*
+ 	 * Start Directed Speed Change so the best possible speed both link
+ 	 * partners support can be negotiated.
+@@ -429,7 +432,7 @@ static int imx6_pcie_start_link(struct pcie_port *pp)
+ 		dev_err(pp->dev, "Failed to bring link up!\n");
+ 	} else {
+ 		tmp = readl(pp->dbi_base + 0x80);
+-		dev_dbg(pp->dev, "Link up, Gen=%i\n", (tmp >> 16) & 0xf);
++		dev_info(pp->dev, "Link up, Gen=%i\n", (tmp >> 16) & 0xf);
+ 	}
+ 
+ 	return ret;
+-- 
+2.4.3
+
Index: trunk/target/linux/imx6/patches-3.14/207-pci_designware_revert-pcie-map-irq-function.patch
===================================================================
--- trunk/target/linux/imx6/patches-3.14/207-pci_designware_revert-pcie-map-irq-function.patch	(revision 0)
+++ trunk/target/linux/imx6/patches-3.14/207-pci_designware_revert-pcie-map-irq-function.patch	(working copy)
@@ -0,0 +1,24 @@
+Index: linux-3.14.16/drivers/pci/host/pcie-designware.c
+===================================================================
+--- linux-3.14.16.orig/drivers/pci/host/pcie-designware.c	2014-10-23 15:59:17.978240312 -0700
++++ linux-3.14.16/drivers/pci/host/pcie-designware.c	2014-10-23 16:04:32.478231239 -0700
+@@ -744,9 +744,16 @@
+ 	struct pcie_port *pp = sys_to_pcie(dev->bus->sysdata);
+ 	int irq;
+ 
+-	irq = of_irq_parse_and_map_pci(dev, slot, pin);
+-	if (!irq)
+-		irq = pp->irq;
++	switch (pin) {
++	case 1: irq = pp->irq; break;
++	case 2: irq = pp->irq - 1; break;
++	case 3: irq = pp->irq - 2; break;
++	case 4: irq = pp->irq - 3; break;
++	default: irq = -1; break;
++	}
++
++	dev_info(&dev->dev, "map_irq: %04x:%04x slot%d pin%d irq%d\n",
++		 dev->vendor, dev->device, slot, pin, irq);
+ 
+ 	return irq;
+ }
Index: trunk/target/linux/imx6/patches-3.14/210-ventana-gw551x.patch
===================================================================
--- trunk/target/linux/imx6/patches-3.14/210-ventana-gw551x.patch	(revision 0)
+++ trunk/target/linux/imx6/patches-3.14/210-ventana-gw551x.patch	(working copy)
@@ -0,0 +1,18 @@
+--- a/arch/arm/boot/dts/Makefile
++++ b/arch/arm/boot/dts/Makefile
+@@ -159,6 +159,7 @@ dtb-$(CONFIG_ARCH_MXC) += \
+ 	imx6dl-gw53xx.dtb \
+ 	imx6dl-gw54xx.dtb \
+ 	imx6dl-gw552x.dtb \
++	imx6dl-gw551x.dtb \
+ 	imx6dl-hummingboard.dtb \
+ 	imx6dl-sabreauto.dtb \
+ 	imx6dl-sabresd.dtb \
+@@ -171,6 +172,7 @@ dtb-$(CONFIG_ARCH_MXC) += \
+ 	imx6q-gw5400-a.dtb \
+ 	imx6q-gw54xx.dtb \
+ 	imx6q-gw552x.dtb \
++	imx6q-gw551x.dtb \
+ 	imx6q-phytec-pbab01.dtb \
+ 	imx6q-sabreauto.dtb \
+ 	imx6q-sabrelite.dtb \
Index: trunk/target/linux/imx6/patches-3.14/215-input-add-driver-mma8451.patch
===================================================================
--- trunk/target/linux/imx6/patches-3.14/215-input-add-driver-mma8451.patch	(revision 0)
+++ trunk/target/linux/imx6/patches-3.14/215-input-add-driver-mma8451.patch	(working copy)
@@ -0,0 +1,31 @@
+Index: linux-3.14.16/drivers/input/misc/Makefile
+===================================================================
+--- linux-3.14.16.orig/drivers/input/misc/Makefile	2014-08-07 16:50:59.000000000 -0700
++++ linux-3.14.16/drivers/input/misc/Makefile	2014-12-17 10:06:38.694105207 -0800
+@@ -39,6 +39,7 @@
+ obj-$(CONFIG_INPUT_MAX8997_HAPTIC)	+= max8997_haptic.o
+ obj-$(CONFIG_INPUT_MC13783_PWRBUTTON)	+= mc13783-pwrbutton.o
+ obj-$(CONFIG_INPUT_MMA8450)		+= mma8450.o
++obj-$(CONFIG_INPUT_MMA8451)		+= mma8451.o
+ obj-$(CONFIG_INPUT_MPU3050)		+= mpu3050.o
+ obj-$(CONFIG_INPUT_PCAP)		+= pcap_keys.o
+ obj-$(CONFIG_INPUT_PCF50633_PMU)	+= pcf50633-input.o
+Index: linux-3.14.16/drivers/input/misc/Kconfig
+===================================================================
+--- linux-3.14.16.orig/drivers/input/misc/Kconfig	2014-08-07 16:50:59.000000000 -0700
++++ linux-3.14.16/drivers/input/misc/Kconfig	2014-12-17 12:57:57.241808679 -0800
+@@ -187,6 +187,14 @@
+ 	  To compile this driver as a module, choose M here: the
+ 	  module will be called mma8450.
+ 
++config INPUT_MMA8451
++	tristate "MMA8451"
++	depends on I2C
++	select INPUT_POLLDEV
++	help
++	  Say Y here if you want to support Freescale's MMA8451 Accelerometer
++	  through I2C interface.
++
+ config INPUT_MPU3050
+ 	tristate "MPU3050 Triaxial gyroscope sensor"
+ 	depends on I2C
Index: trunk/target/linux/imx6/patches-3.14/220-ventana-gsc-core.patch
===================================================================
--- trunk/target/linux/imx6/patches-3.14/220-ventana-gsc-core.patch	(revision 0)
+++ trunk/target/linux/imx6/patches-3.14/220-ventana-gsc-core.patch	(working copy)
@@ -0,0 +1,34 @@
+--- a/drivers/mfd/Kconfig
++++ b/drivers/mfd/Kconfig
+@@ -189,6 +189,20 @@ config MFD_MC13XXX_I2C
+ 	help
+ 	  Select this if your MC13xxx is connected via an I2C bus.
+ 
++config GSC_CORE
++	tristate "Gateworks System Controller Support"
++	depends on I2C
++	select MFD_CORE
++	select GENERIC_IRQ_CHIP
++	select IRQ_DOMAIN
++	help
++	  Say yes here for support of Gateworks System Controller. This is a
++	  system management IC. This driver provides support for accessing
++	  various features of the device.
++
++	  This driver can be built as a module. If built as a module it will
++	  be called "gsc"
++
+ config HTC_EGPIO
+ 	bool "HTC EGPIO support"
+ 	depends on GPIOLIB && ARM
+--- a/drivers/mfd/Makefile
++++ b/drivers/mfd/Makefile
+@@ -15,6 +15,8 @@ obj-$(CONFIG_MFD_CROS_EC_SPI)	+= cros_ec
+ rtsx_pci-objs			:= rtsx_pcr.o rts5209.o rts5229.o rtl8411.o rts5227.o rts5249.o
+ obj-$(CONFIG_MFD_RTSX_PCI)	+= rtsx_pci.o
+ 
++gsc-objs			:= gsc-core.o gsc-irq.o
++obj-$(CONFIG_GSC_CORE)		+= gsc.o
+ obj-$(CONFIG_HTC_EGPIO)		+= htc-egpio.o
+ obj-$(CONFIG_HTC_PASIC3)	+= htc-pasic3.o
+ obj-$(CONFIG_HTC_I2CPLD)	+= htc-i2cpld.o
Index: trunk/target/linux/imx6/patches-3.14/221-ventana-gsc-watchdog.patch
===================================================================
--- trunk/target/linux/imx6/patches-3.14/221-ventana-gsc-watchdog.patch	(revision 0)
+++ trunk/target/linux/imx6/patches-3.14/221-ventana-gsc-watchdog.patch	(working copy)
@@ -0,0 +1,27 @@
+--- a/drivers/watchdog/Kconfig
++++ b/drivers/watchdog/Kconfig
+@@ -321,6 +321,14 @@ config COH901327_WATCHDOG
+ 	  This watchdog is used to reset the system and thus cannot be
+ 	  compiled as a module.
+ 
++config GSC_WATCHDOG
++	tristate "Gateworks System Controller Watchdog"
++	depends on GSC_CORE
++	select WATCHDOG_CORE
++	help
++	  Support for Gateworks System Controller watchdog.
++	  Say 'Y' here to enable the watchdog timer support for GSC chips.
++
+ config TWL4030_WATCHDOG
+ 	tristate "TWL4030 Watchdog"
+ 	depends on TWL4030_CORE
+--- a/drivers/watchdog/Makefile
++++ b/drivers/watchdog/Makefile
+@@ -33,6 +33,7 @@ obj-$(CONFIG_ARM_SP805_WATCHDOG) += sp80
+ obj-$(CONFIG_AT91RM9200_WATCHDOG) += at91rm9200_wdt.o
+ obj-$(CONFIG_AT91SAM9X_WATCHDOG) += at91sam9_wdt.o
+ obj-$(CONFIG_OMAP_WATCHDOG) += omap_wdt.o
++obj-$(CONFIG_GSC_WATCHDOG) += gsc_wdt.o
+ obj-$(CONFIG_TWL4030_WATCHDOG) += twl4030_wdt.o
+ obj-$(CONFIG_21285_WATCHDOG) += wdt285.o
+ obj-$(CONFIG_977_WATCHDOG) += wdt977.o
Index: trunk/target/linux/imx6/patches-3.14/222-ventana-gsc-input.patch
===================================================================
--- trunk/target/linux/imx6/patches-3.14/222-ventana-gsc-input.patch	(revision 0)
+++ trunk/target/linux/imx6/patches-3.14/222-ventana-gsc-input.patch	(working copy)
@@ -0,0 +1,30 @@
+--- a/drivers/input/misc/Kconfig
++++ b/drivers/input/misc/Kconfig
+@@ -93,6 +93,17 @@ config INPUT_BMA150
+ 	  To compile this driver as a module, choose M here: the
+ 	  module will be called bma150.
+ 
++config INPUT_GSC
++	tristate "Gateworks System Controller Input support"
++	depends on GSC_CORE
++	help
++	Support for Gateworks System Controller input device.
++	  Say Y here if you want to enable Linux input device support for
++	  GSC user-pushbutton, and tamper events.
++
++	  To compile this driver as a module, choose M here. The module will
++	  be called gsc_input.
++
+ config INPUT_PCSPKR
+ 	tristate "PC Speaker support"
+ 	depends on PCSPKR_PLATFORM
+--- a/drivers/input/misc/Makefile
++++ b/drivers/input/misc/Makefile
+@@ -44,6 +44,7 @@ obj-$(CONFIG_INPUT_MPU3050)		+= mpu3050.
+ obj-$(CONFIG_INPUT_PCAP)		+= pcap_keys.o
+ obj-$(CONFIG_INPUT_PCF50633_PMU)	+= pcf50633-input.o
+ obj-$(CONFIG_INPUT_PCF8574)		+= pcf8574_keypad.o
++obj-$(CONFIG_INPUT_GSC)			+= gsc-input.o
+ obj-$(CONFIG_INPUT_PCSPKR)		+= pcspkr.o
+ obj-$(CONFIG_INPUT_PM8XXX_VIBRATOR)	+= pm8xxx-vibrator.o
+ obj-$(CONFIG_INPUT_PMIC8XXX_PWRKEY)	+= pmic8xxx-pwrkey.o
Index: trunk/target/linux/imx6/patches-3.14/223-ventana-enable-gsc-drivers.patch
===================================================================
--- trunk/target/linux/imx6/patches-3.14/223-ventana-enable-gsc-drivers.patch	(revision 0)
+++ trunk/target/linux/imx6/patches-3.14/223-ventana-enable-gsc-drivers.patch	(working copy)
@@ -0,0 +1,204 @@
+--- a/arch/arm/boot/dts/imx6qdl-gw51xx.dtsi
++++ b/arch/arm/boot/dts/imx6qdl-gw51xx.dtsi
+@@ -131,19 +131,45 @@
+ 		pagesize = <16>;
+ 	};
+ 
+-	gpio: pca9555@23 {
++	gsc: gsc@20 {
++		compatible = "gw,gsc";
++		reg = <0x20>;
++		interrupt-parent = <&gpio1>;
++		interrupts = <4 1>;
++		interrupt-controller;
++		#interrupt-cells = <1>;
++
++		/* GSC watchdog */
++		watchdog {
++			compatible = "gw,gsc_wdt";
++			status = "okay";
++		};
++
++		/* Linux input events from GSC interrupt events */
++		input {
++			compatible = "gw,gsc_input";
++			interrupt-parent = <&gsc>;
++			interrupts = <0 1 2 5 7>;
++			interrupt-names = "button", "key-erased", "eeprom-wp", "tamper", "button-held";
++			status = "okay";
++		};
++	};
++
++	gsc_gpio: pca9555@23 {
+ 		compatible = "nxp,pca9555";
+ 		reg = <0x23>;
+ 		gpio-controller;
+ 		#gpio-cells = <2>;
++		interrupt-parent = <&gsc>;
++		interrupts = <4>;
+ 	};
+ 
+-	hwmon: gsc@29 {
++	gsc_hwmon: hwmon@29 {
+ 		compatible = "gw,gsp";
+ 		reg = <0x29>;
+ 	};
+ 
+-	rtc: ds1672@68 {
++	gsc_rtc: ds1672@68 {
+ 		compatible = "dallas,ds1672";
+ 		reg = <0x68>;
+ 	};
+--- a/arch/arm/boot/dts/imx6qdl-gw52xx.dtsi
++++ b/arch/arm/boot/dts/imx6qdl-gw52xx.dtsi
+@@ -193,19 +193,45 @@
+ 		pagesize = <16>;
+ 	};
+ 
+-	gpio: pca9555@23 {
++	gsc: gsc@20 {
++		compatible = "gw,gsc";
++		reg = <0x20>;
++		interrupt-parent = <&gpio1>;
++		interrupts = <4 1>;
++		interrupt-controller;
++		#interrupt-cells = <1>;
++
++		/* GSC watchdog */
++		watchdog {
++			compatible = "gw,gsc_wdt";
++			status = "okay";
++		};
++
++		/* Linux input events from GSC interrupt events */
++		input {
++			compatible = "gw,gsc_input";
++			interrupt-parent = <&gsc>;
++			interrupts = <0 1 2 5 7>;
++			interrupt-names = "button", "key-erased", "eeprom-wp", "tamper", "button-held";
++			status = "okay";
++		};
++	};
++
++	gsc_gpio: pca9555@23 {
+ 		compatible = "nxp,pca9555";
+ 		reg = <0x23>;
+ 		gpio-controller;
+ 		#gpio-cells = <2>;
++		interrupt-parent = <&gsc>;
++		interrupts = <4>;
+ 	};
+ 
+-	hwmon: gsc@29 {
++	gsc_hwmon: hwmon@29 {
+ 		compatible = "gw,gsp";
+ 		reg = <0x29>;
+ 	};
+ 
+-	rtc: ds1672@68 {
++	gsc_rtc: ds1672@68 {
+ 		compatible = "dallas,ds1672";
+ 		reg = <0x68>;
+ 	};
+--- a/arch/arm/boot/dts/imx6qdl-gw53xx.dtsi
++++ b/arch/arm/boot/dts/imx6qdl-gw53xx.dtsi
+@@ -195,19 +195,45 @@
+ 		pagesize = <16>;
+ 	};
+ 
+-	gpio: pca9555@23 {
++	gsc: gsc@20 {
++		compatible = "gw,gsc";
++		reg = <0x20>;
++		interrupt-parent = <&gpio1>;
++		interrupts = <4 1>;
++		interrupt-controller;
++		#interrupt-cells = <1>;
++
++		/* GSC watchdog */
++		watchdog {
++			compatible = "gw,gsc_wdt";
++			status = "okay";
++		};
++
++		/* Linux input events from GSC interrupt events */
++		input {
++			compatible = "gw,gsc_input";
++			interrupt-parent = <&gsc>;
++			interrupts = <0 1 2 5 7>;
++			interrupt-names = "button", "key-erased", "eeprom-wp", "tamper", "button-held";
++			status = "okay";
++		};
++	};
++
++	gsc_gpio: pca9555@23 {
+ 		compatible = "nxp,pca9555";
+ 		reg = <0x23>;
+ 		gpio-controller;
+ 		#gpio-cells = <2>;
++		interrupt-parent = <&gsc>;
++		interrupts = <4>;
+ 	};
+ 
+-	hwmon: gsc@29 {
++	gsc_hwmon: hwmon@29 {
+ 		compatible = "gw,gsp";
+ 		reg = <0x29>;
+ 	};
+ 
+-	rtc: ds1672@68 {
++	gsc_rtc: ds1672@68 {
+ 		compatible = "dallas,ds1672";
+ 		reg = <0x68>;
+ 	};
+--- a/arch/arm/boot/dts/imx6qdl-gw54xx.dtsi
++++ b/arch/arm/boot/dts/imx6qdl-gw54xx.dtsi
+@@ -185,19 +185,45 @@
+ 		pagesize = <16>;
+ 	};
+ 
+-	gpio: pca9555@23 {
++	gsc: gsc@20 {
++		compatible = "gw,gsc";
++		reg = <0x20>;
++		interrupt-parent = <&gpio1>;
++		interrupts = <4 1>;
++		interrupt-controller;
++		#interrupt-cells = <1>;
++
++		/* GSC watchdog */
++		watchdog {
++			compatible = "gw,gsc_wdt";
++			status = "okay";
++		};
++
++		/* Linux input events from GSC interrupt events */
++		input {
++			compatible = "gw,gsc_input";
++			interrupt-parent = <&gsc>;
++			interrupts = <0 1 2 5 7>;
++			interrupt-names = "button", "key-erased", "eeprom-wp", "tamper", "button-held";
++			status = "okay";
++		};
++	};
++
++	gsc_gpio: pca9555@23 {
+ 		compatible = "nxp,pca9555";
+ 		reg = <0x23>;
+ 		gpio-controller;
+ 		#gpio-cells = <2>;
++		interrupt-parent = <&gsc>;
++		interrupts = <4>;
+ 	};
+ 
+-	hwmon: gsc@29 {
++	gsc_hwmon: hwmon@29 {
+ 		compatible = "gw,gsp";
+ 		reg = <0x29>;
+ 	};
+ 
+-	rtc: ds1672@68 {
++	gsc_rtc: ds1672@68 {
+ 		compatible = "dallas,ds1672";
+ 		reg = <0x68>;
+ 	};
Index: trunk/target/linux/imx6/patches-3.14/224-ventana-gpio-keys.patch
===================================================================
--- trunk/target/linux/imx6/patches-3.14/224-ventana-gpio-keys.patch	(revision 0)
+++ trunk/target/linux/imx6/patches-3.14/224-ventana-gpio-keys.patch	(working copy)
@@ -0,0 +1,92 @@
+--- a/arch/arm/boot/dts/imx6qdl-gw52xx.dtsi
++++ b/arch/arm/boot/dts/imx6qdl-gw52xx.dtsi
+@@ -59,6 +59,20 @@
+ 		};
+ 	};
+ 
++	gpio_keys {
++		compatible = "gpio-keys-polled";
++		poll-interval = <100>;
++		#address-cells = <1>;
++		#size-cells = <0>;
++
++		user_pb {
++			label = "user_pb";
++
++			gpios = <&gsc_gpio 0 1>;
++			linux,code = <256>;
++		};
++	};
++
+ 	memory {
+ 		reg = <0x10000000 0x20000000>;
+ 	};
+--- a/arch/arm/boot/dts/imx6qdl-gw51xx.dtsi
++++ b/arch/arm/boot/dts/imx6qdl-gw51xx.dtsi
+@@ -42,6 +42,20 @@
+ 		};
+ 	};
+ 
++	gpio_keys {
++		compatible = "gpio-keys-polled";
++		poll-interval = <100>;
++		#address-cells = <1>;
++		#size-cells = <0>;
++
++		user_pb {
++			label = "user_pb";
++
++			gpios = <&gsc_gpio 0 1>;
++			linux,code = <256>;
++		};
++	};
++
+ 	memory {
+ 		reg = <0x10000000 0x20000000>;
+ 	};
+--- a/arch/arm/boot/dts/imx6qdl-gw53xx.dtsi
++++ b/arch/arm/boot/dts/imx6qdl-gw53xx.dtsi
+@@ -61,6 +61,20 @@
+ 		};
+ 	};
+ 
++	gpio_keys {
++		compatible = "gpio-keys-polled";
++		poll-interval = <100>;
++		#address-cells = <1>;
++		#size-cells = <0>;
++
++		user_pb {
++			label = "user_pb";
++
++			gpios = <&gsc_gpio 0 1>;
++			linux,code = <256>;
++		};
++	};
++
+ 	memory {
+ 		reg = <0x10000000 0x40000000>;
+ 	};
+--- a/arch/arm/boot/dts/imx6qdl-gw54xx.dtsi
++++ b/arch/arm/boot/dts/imx6qdl-gw54xx.dtsi
+@@ -61,6 +61,20 @@
+ 		};
+ 	};
+ 
++	gpio_keys {
++		compatible = "gpio-keys-polled";
++		poll-interval = <100>;
++		#address-cells = <1>;
++		#size-cells = <0>;
++
++		user_pb {
++			label = "user_pb";
++
++			gpios = <&gsc_gpio 0 1>;
++			linux,code = <256>;
++		};
++	};
++
+ 	memory {
+ 		reg = <0x10000000 0x40000000>;
+ 	};
Index: trunk/target/linux/imx6/profiles/120-gateworks.mk
===================================================================
--- trunk/target/linux/imx6/profiles/120-gateworks.mk	(revision 42297)
+++ trunk/target/linux/imx6/profiles/120-gateworks.mk	(working copy)
@@ -41,6 +41,7 @@
 	imx6dl-gw52xx \
 	imx6dl-gw53xx \
 	imx6dl-gw54xx \
+	imx6dl-gw551x \
 	imx6dl-gw552x \
 	imx6q-gw51xx \
 	imx6q-gw52xx \
@@ -47,6 +48,7 @@
 	imx6q-gw53xx \
 	imx6q-gw54xx \
 	imx6q-gw5400-a \
+	imx6q-gw551x \
 	imx6q-gw552x
 
 $(eval $(call Profile,VENTANA))
