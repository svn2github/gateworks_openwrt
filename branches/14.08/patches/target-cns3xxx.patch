Index: trunk/target/linux/cns3xxx/base-files/lib/upgrade/platform.sh
===================================================================
--- trunk/target/linux/cns3xxx/base-files/lib/upgrade/platform.sh	(revision 42297)
+++ trunk/target/linux/cns3xxx/base-files/lib/upgrade/platform.sh	(working copy)
@@ -56,9 +56,17 @@
 		local append=""
 		[ -f "$CONF_TAR" -a "$SAVE_CONFIG" -eq 1 ] && append="-j $CONF_TAR"
 
-		dd if="$1" bs=$CI_BLKSZ skip=1 count=$kern_blocks 2>/dev/null | mtd write - kernel
-		dd if="$1" bs=$CI_BLKSZ skip=$((1+$kern_blocks)) count=$root_blocks 2>/dev/null | \
-				 mtd -r $append write - rootfs
+		while [ 1 ]; do
+			dd if="$1" bs=$CI_BLKSZ skip=1 count=$kern_blocks 2>/dev/null | mtd write - kernel
+			[ $? -eq 0 ] && break
+			echo "mtd write failed - retry..."
+		done
+		while [ 1 ]; do
+			dd if="$1" bs=$CI_BLKSZ skip=$((1+$kern_blocks)) count=$root_blocks 2>/dev/null | \
+				 mtd $append write - rootfs
+			[ $? -eq 0 ] && break
+		done
+		reboot
 	else
 		echo "invalid image"
 	fi
Index: trunk/target/linux/cns3xxx/files/arch/arm/mach-cns3xxx/gpio.c
===================================================================
--- trunk/target/linux/cns3xxx/files/arch/arm/mach-cns3xxx/gpio.c	(revision 42297)
+++ trunk/target/linux/cns3xxx/files/arch/arm/mach-cns3xxx/gpio.c	(working copy)
@@ -15,6 +15,7 @@
 #include <linux/io.h>
 #include <linux/gpio.h>
 #include <linux/irq.h>
+#include <linux/irqdomain.h>
 
 #include <asm/mach/irq.h>
 
@@ -45,9 +46,9 @@
 
 struct cns3xxx_gpio_chip {
 	struct gpio_chip    chip;
+	struct irq_domain   *domain;
 	spinlock_t          lock;
 	void __iomem        *base;
-	int                 secondary_irq_base;
 };
 
 static struct cns3xxx_gpio_chip cns3xxx_gpio_chips[2];
@@ -127,7 +128,7 @@
 	struct cns3xxx_gpio_chip *cchip =
 		container_of(chip, struct cns3xxx_gpio_chip, chip);
 
-	return cchip->secondary_irq_base + pin;
+	return irq_find_mapping(cchip->domain, pin);
 }
 
 
@@ -152,7 +153,7 @@
 	for (i = 0; i < 32; i++) {
 		if (reg & (1 << i)) {
 			/* let the generic IRQ layer handle an interrupt */
-			generic_handle_irq(cchip->secondary_irq_base + i);
+			generic_handle_irq(irq_find_mapping(cchip->domain, i));
 		}
 	}
 
@@ -163,7 +164,7 @@
 {
 	struct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);
 	struct cns3xxx_gpio_chip *cchip = gc->private;
-	u32 gpio = d->irq - cchip->secondary_irq_base;
+	u32 gpio = d->hwirq;
 	unsigned long flags;
 	u32 method, edges, type;
 
@@ -224,6 +225,7 @@
 	struct irq_chip_generic *gc;
 	struct irq_chip_type *ct;
 	char gc_label[16];
+	int irq_base;
 
 	if (cns3xxx_gpio_chip_count == ARRAY_SIZE(cns3xxx_gpio_chips))
 		return;
@@ -243,7 +245,6 @@
 	cchip->chip.can_sleep = 0;
 	spin_lock_init(&cchip->lock);
 	cchip->base = (void __iomem *)base;
-	cchip->secondary_irq_base = secondary_irq_base;
 
 	BUG_ON(gpiochip_add(&cchip->chip) < 0);
 	cns3xxx_gpio_chip_count++;
@@ -251,11 +252,22 @@
 	/* clear GPIO interrupts */
 	__raw_writel(0xffff, cchip->base + GPIO_INTERRUPT_CLEAR);
 
+	irq_base = irq_alloc_descs(-1, secondary_irq_base, ngpio,
+		numa_node_id());
+	if (irq_base < 0)
+		goto out_irqdesc_free;
+
+	cchip->domain = irq_domain_add_legacy(NULL, ngpio, irq_base, 0,
+		&irq_domain_simple_ops, NULL);
+	if (!cchip->domain)
+		goto out_irqdesc_free;
+
 	/*
 	 * IRQ chip init
 	 */
-	gc = irq_alloc_generic_chip("cns3xxx_gpio_irq", 1, secondary_irq_base,
+	gc = irq_alloc_generic_chip("cns3xxx_gpio_irq", 1, irq_base,
 		cchip->base, handle_edge_irq);
+
 	gc->private = cchip;
 
 	ct = gc->chip_types;
@@ -270,7 +282,11 @@
 
 	irq_setup_generic_chip(gc, IRQ_MSK(ngpio), IRQ_GC_INIT_MASK_CACHE,
 		IRQ_NOREQUEST, 0);
-
 	irq_set_chained_handler(irq, cns3xxx_gpio_irq_handler);
 	irq_set_handler_data(irq, cchip);
+
+	return;
+
+out_irqdesc_free:
+	irq_free_descs(irq_base, ngpio);
 }
Index: trunk/target/linux/cns3xxx/files/arch/arm/mach-cns3xxx/laguna.c
===================================================================
--- trunk/target/linux/cns3xxx/files/arch/arm/mach-cns3xxx/laguna.c	(revision 42297)
+++ trunk/target/linux/cns3xxx/files/arch/arm/mach-cns3xxx/laguna.c	(working copy)
@@ -809,7 +809,7 @@
 
 	platform_device_register(&laguna_i2c_controller);
 
-	/* Set ext_int 0-3 drive strength to 21 mA */
+	/* Set I2C 0-3 drive strength to 21 mA */
 	reg = MISC_IO_PAD_DRIVE_STRENGTH_CTRL_B;
 	*reg |= 0x300;
 
@@ -817,9 +817,8 @@
 	reg = MISC_GPIOB_PIN_ENABLE_REG;
 	*reg |= BIT(12) | BIT(13);
 
-	/* Enable MMC/SD pins */
-	reg = MISC_GPIOA_PIN_ENABLE_REG;
-	*reg |= 0xf80;
+	/* Enable SPI pins */
+	*reg |= BIT(7) | BIT(8) | BIT(9) | BIT(10) | BIT(11);
 
 	cns3xxx_pwr_clk_en(1 << PM_CLK_GATE_REG_OFFSET_SPI_PCM_I2C);
 	cns3xxx_pwr_power_up(1 << PM_CLK_GATE_REG_OFFSET_SPI_PCM_I2C);
Index: trunk/target/linux/cns3xxx/patches-3.10/066-pci_isolated_interrupts.patch
===================================================================
--- trunk/target/linux/cns3xxx/patches-3.10/066-pci_isolated_interrupts.patch	(revision 0)
+++ trunk/target/linux/cns3xxx/patches-3.10/066-pci_isolated_interrupts.patch	(working copy)
@@ -0,0 +1,201 @@
+--- a/arch/arm/mach-cns3xxx/cns3420vb.c
++++ b/arch/arm/mach-cns3xxx/cns3420vb.c
+@@ -272,7 +272,7 @@ static int __init cns3420vb_pcie_init(vo
+ 	if (!machine_is_cns3420vb())
+ 		return 0;
+ 
+-	return cns3xxx_pcie_init();
++	return cns3xxx_pcie_init(NULL, NULL);
+ }
+ subsys_initcall(cns3420vb_pcie_init);
+ 
+--- a/arch/arm/mach-cns3xxx/core.h
++++ b/arch/arm/mach-cns3xxx/core.h
+@@ -23,7 +23,7 @@ static inline void cns3xxx_l2x0_init(voi
+ 
+ void __init cns3xxx_map_io(void);
+ void __init cns3xxx_init_irq(void);
+-int  __init cns3xxx_pcie_init(void);
++int  __init cns3xxx_pcie_init(int *pcie0_irqs, int *pcie1_irqs);
+ void cns3xxx_power_off(void);
+ void cns3xxx_restart(char, const char *);
+ 
+--- a/arch/arm/mach-cns3xxx/laguna.c
++++ b/arch/arm/mach-cns3xxx/laguna.c
+@@ -21,6 +21,7 @@
+ #include <linux/kernel.h>
+ #include <linux/compiler.h>
+ #include <linux/io.h>
++#include <linux/irq.h>
+ #include <linux/gpio.h>
+ #include <linux/dma-mapping.h>
+ #include <linux/serial_core.h>
+@@ -869,12 +870,53 @@ static int laguna_register_gpio(struct g
+ 	return ret;
+ }
+ 
++static int cns3xxx_pciextirq = 1;
++
++static int __init cns3xxx_pciextirq_disable(char *s)
++{
++        cns3xxx_pciextirq = 0;
++        return 1;
++}
++__setup("noextirq", cns3xxx_pciextirq_disable);
++
+ static int __init laguna_pcie_init(void)
+ {
+ 	if (!machine_is_gw2388())
+ 		return 0;
+ 
+-	return cns3xxx_pcie_init();
++	if (cns3xxx_pciextirq) {
++		u32 __iomem *mem;
++		u32 reg;
++		int pcie0_irqs[] = {
++			IRQ_CNS3XXX_EXTERNAL_PIN0,
++			IRQ_CNS3XXX_EXTERNAL_PIN1,
++			IRQ_CNS3XXX_EXTERNAL_PIN2,
++			154,
++		};
++
++		/*
++		 * Detect board revision:
++		 *   GW2388-4-G+ GPIOB[26:29] INTA/B/C/D thus will be high
++		 *   GW2388-4-F- GPIOB[16:19] INTA/B/C/D thus will be high
++		 */
++		mem = (void __iomem *)(CNS3XXX_GPIOB_BASE_VIRT + 0x0004);
++		reg = __raw_readl(mem) >> 16;
++		switch (reg & 0x3c00) {
++		case 0x0408: /* GW2388-4-H */
++			pcie0_irqs[0] = IRQ_CNS3XXX_PCIE0_DEVICE;
++			pcie0_irqs[1] = IRQ_CNS3XXX_PCIE0_DEVICE;
++			pcie0_irqs[2] = IRQ_CNS3XXX_PCIE0_DEVICE;
++		case 0x0400: /* GW2388-4-G (mod) */
++			printk("%s: using external-irq\n", __func__);
++			return cns3xxx_pcie_init(pcie0_irqs, NULL);
++			break;
++		case 0x3c00: /* GW2388-4-G */
++		default:
++                	break;
++		}
++        }
++
++	return cns3xxx_pcie_init(NULL, NULL);
+ }
+ subsys_initcall(laguna_pcie_init);
+ 
+@@ -889,8 +931,30 @@ static int __init laguna_model_setup(voi
+ 	printk("Running on Gateworks Laguna %s\n", laguna_info.model);
+ 	cns3xxx_gpio_init( 0, 32, CNS3XXX_GPIOA_BASE_VIRT, IRQ_CNS3XXX_GPIOA,
+ 		NR_IRQS_CNS3XXX);
+-	cns3xxx_gpio_init(32, 32, CNS3XXX_GPIOB_BASE_VIRT, IRQ_CNS3XXX_GPIOB,
+-		NR_IRQS_CNS3XXX + 32);
++
++	if (cns3xxx_pciextirq) {
++		/*
++		 * if pcie external interrupts are supported and desired
++		 * configure IRQ types and configure pin function.
++		 */
++		mem = (void __iomem *)(CNS3XXX_MISC_BASE_VIRT + 0x0018);
++		reg = __raw_readl(mem);
++		/* GPIO26 is gpio, EXT_INT[0:2] not gpio func */
++		reg &= ~0x3c000000;
++		reg |= 0x38000000;
++		__raw_writel(reg, mem);
++
++		cns3xxx_gpio_init(32, 32, CNS3XXX_GPIOB_BASE_VIRT,
++				  IRQ_CNS3XXX_GPIOB, NR_IRQS_CNS3XXX + 32);
++
++		irq_set_irq_type(154, IRQ_TYPE_LEVEL_LOW);
++		irq_set_irq_type(93, IRQ_TYPE_LEVEL_HIGH);
++		irq_set_irq_type(94, IRQ_TYPE_LEVEL_HIGH);
++		irq_set_irq_type(95, IRQ_TYPE_LEVEL_HIGH);
++	} else {
++		cns3xxx_gpio_init(32, 32, CNS3XXX_GPIOB_BASE_VIRT,
++				  IRQ_CNS3XXX_GPIOB, NR_IRQS_CNS3XXX + 32);
++	}
+ 
+ 	if (strncmp(laguna_info.model, "GW", 2) == 0) {
+ 		if (laguna_info.config_bitmap & ETH0_LOAD)
+--- a/arch/arm/mach-cns3xxx/pcie.c
++++ b/arch/arm/mach-cns3xxx/pcie.c
+@@ -18,6 +18,7 @@
+ #include <linux/io.h>
+ #include <linux/ioport.h>
+ #include <linux/interrupt.h>
++#include <linux/irq.h>
+ #include <linux/ptrace.h>
+ #include <asm/mach/map.h>
+ #include "cns3xxx.h"
+@@ -32,7 +33,7 @@ enum cns3xxx_access_type {
+ 
+ struct cns3xxx_pcie {
+ 	struct map_desc cfg_bases[CNS3XXX_NUM_ACCESS_TYPES];
+-	unsigned int irqs[2];
++	unsigned int irqs[6];
+ 	struct resource res_io;
+ 	struct resource res_mem;
+ 	struct hw_pci hw_pci;
+@@ -255,7 +256,7 @@ static struct pci_ops cns3xxx_pcie_ops =
+ static int cns3xxx_pcie_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
+ {
+ 	struct cns3xxx_pcie *cnspci = pdev_to_cnspci(dev);
+-	int irq = cnspci->irqs[slot];
++	int irq = cnspci->irqs[slot+pin-1];
+ 
+ 	pr_info("PCIe map irq: %04d:%02x:%02x.%02x slot %d, pin %d, irq: %d\n",
+ 		pci_domain_nr(dev->bus), dev->bus->number, PCI_SLOT(dev->devfn),
+@@ -298,7 +299,12 @@ static struct cns3xxx_pcie cns3xxx_pcie[
+ 			.end = CNS3XXX_PCIE0_MEM_BASE + SZ_16M - 1,
+ 			.flags = IORESOURCE_MEM,
+ 		},
+-		.irqs = { IRQ_CNS3XXX_PCIE0_RC, IRQ_CNS3XXX_PCIE0_DEVICE, },
++		.irqs = { IRQ_CNS3XXX_PCIE0_RC,
++			  IRQ_CNS3XXX_PCIE0_DEVICE,
++			  IRQ_CNS3XXX_PCIE0_DEVICE,
++			  IRQ_CNS3XXX_PCIE0_DEVICE,
++			  IRQ_CNS3XXX_PCIE0_DEVICE,
++			},
+ 		.hw_pci = {
+ 			.domain = 0,
+ 			.nr_controllers = 1,
+@@ -340,7 +346,13 @@ static struct cns3xxx_pcie cns3xxx_pcie[
+ 			.end = CNS3XXX_PCIE1_MEM_BASE + SZ_16M - 1,
+ 			.flags = IORESOURCE_MEM,
+ 		},
+-		.irqs = { IRQ_CNS3XXX_PCIE1_RC, IRQ_CNS3XXX_PCIE1_DEVICE, },
++		.irqs = {
++			IRQ_CNS3XXX_PCIE1_RC,
++			IRQ_CNS3XXX_PCIE1_DEVICE,
++			IRQ_CNS3XXX_PCIE1_DEVICE,
++			IRQ_CNS3XXX_PCIE1_DEVICE,
++			IRQ_CNS3XXX_PCIE1_DEVICE,
++		},
+ 		.hw_pci = {
+ 			.domain = 1,
+ 			.nr_controllers = 1,
+@@ -460,13 +472,22 @@ void __init cns3xxx_pcie_iotable_init()
+ 	}
+ }
+ 
+-int __init cns3xxx_pcie_init(void)
++int __init cns3xxx_pcie_init(int *pcie0_irqs, int *pcie1_irqs)
+ {
+ 	int i;
+ 
+ 	pcibios_min_io = 0;
+ 	pcibios_min_mem = 0;
+ 
++	if (pcie0_irqs) {
++		for (i = 0; i < 4; i++)
++			cns3xxx_pcie[0].irqs[i+1] = pcie0_irqs[i];
++	}
++	if (pcie1_irqs) {
++		for (i = 0; i < 4; i++)
++			cns3xxx_pcie[1].irqs[i+1] = pcie1_irqs[i];
++	}
++
+ 	hook_fault_code(16 + 6, cns3xxx_pcie_abort_handler, SIGBUS, 0,
+ 			"imprecise external abort");
+ 
