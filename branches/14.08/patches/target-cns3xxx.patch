Index: trunk/target/linux/cns3xxx/base-files/lib/upgrade/platform.sh
===================================================================
--- trunk/target/linux/cns3xxx/base-files/lib/upgrade/platform.sh	(revision 42297)
+++ trunk/target/linux/cns3xxx/base-files/lib/upgrade/platform.sh	(working copy)
@@ -56,9 +56,17 @@
 		local append=""
 		[ -f "$CONF_TAR" -a "$SAVE_CONFIG" -eq 1 ] && append="-j $CONF_TAR"
 
-		dd if="$1" bs=$CI_BLKSZ skip=1 count=$kern_blocks 2>/dev/null | mtd write - kernel
-		dd if="$1" bs=$CI_BLKSZ skip=$((1+$kern_blocks)) count=$root_blocks 2>/dev/null | \
-				 mtd -r $append write - rootfs
+		while [ 1 ]; do
+			dd if="$1" bs=$CI_BLKSZ skip=1 count=$kern_blocks 2>/dev/null | mtd write - kernel
+			[ $? -eq 0 ] && break
+			echo "mtd write failed - retry..."
+		done
+		while [ 1 ]; do
+			dd if="$1" bs=$CI_BLKSZ skip=$((1+$kern_blocks)) count=$root_blocks 2>/dev/null | \
+				 mtd $append write - rootfs
+			[ $? -eq 0 ] && break
+		done
+		reboot
 	else
 		echo "invalid image"
 	fi
Index: trunk/target/linux/cns3xxx/config-3.10
===================================================================
--- trunk/target/linux/cns3xxx/config-3.10	(revision 42297)
+++ trunk/target/linux/cns3xxx/config-3.10	(working copy)
@@ -263,3 +263,6 @@
 CONFIG_ZBOOT_ROM_BSS=0
 CONFIG_ZBOOT_ROM_TEXT=0
 CONFIG_ZONE_DMA_FLAG=0
+CONFIG_GSC_CORE=y
+CONFIG_WATCHDOG_CORE=y
+CONFIG_GSC_WATCHDOG=y
Index: trunk/target/linux/cns3xxx/files/arch/arm/mach-cns3xxx/gpio.c
===================================================================
--- trunk/target/linux/cns3xxx/files/arch/arm/mach-cns3xxx/gpio.c	(revision 42297)
+++ trunk/target/linux/cns3xxx/files/arch/arm/mach-cns3xxx/gpio.c	(working copy)
@@ -15,6 +15,7 @@
 #include <linux/io.h>
 #include <linux/gpio.h>
 #include <linux/irq.h>
+#include <linux/irqdomain.h>
 
 #include <asm/mach/irq.h>
 
@@ -45,9 +46,9 @@
 
 struct cns3xxx_gpio_chip {
 	struct gpio_chip    chip;
+	struct irq_domain   *domain;
 	spinlock_t          lock;
 	void __iomem        *base;
-	int                 secondary_irq_base;
 };
 
 static struct cns3xxx_gpio_chip cns3xxx_gpio_chips[2];
@@ -127,7 +128,7 @@
 	struct cns3xxx_gpio_chip *cchip =
 		container_of(chip, struct cns3xxx_gpio_chip, chip);
 
-	return cchip->secondary_irq_base + pin;
+	return irq_find_mapping(cchip->domain, pin);
 }
 
 
@@ -152,7 +153,7 @@
 	for (i = 0; i < 32; i++) {
 		if (reg & (1 << i)) {
 			/* let the generic IRQ layer handle an interrupt */
-			generic_handle_irq(cchip->secondary_irq_base + i);
+			generic_handle_irq(irq_find_mapping(cchip->domain, i));
 		}
 	}
 
@@ -163,7 +164,7 @@
 {
 	struct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);
 	struct cns3xxx_gpio_chip *cchip = gc->private;
-	u32 gpio = d->irq - cchip->secondary_irq_base;
+	u32 gpio = d->hwirq;
 	unsigned long flags;
 	u32 method, edges, type;
 
@@ -224,6 +225,7 @@
 	struct irq_chip_generic *gc;
 	struct irq_chip_type *ct;
 	char gc_label[16];
+	int irq_base;
 
 	if (cns3xxx_gpio_chip_count == ARRAY_SIZE(cns3xxx_gpio_chips))
 		return;
@@ -243,7 +245,6 @@
 	cchip->chip.can_sleep = 0;
 	spin_lock_init(&cchip->lock);
 	cchip->base = (void __iomem *)base;
-	cchip->secondary_irq_base = secondary_irq_base;
 
 	BUG_ON(gpiochip_add(&cchip->chip) < 0);
 	cns3xxx_gpio_chip_count++;
@@ -251,11 +252,22 @@
 	/* clear GPIO interrupts */
 	__raw_writel(0xffff, cchip->base + GPIO_INTERRUPT_CLEAR);
 
+	irq_base = irq_alloc_descs(-1, secondary_irq_base, ngpio,
+		numa_node_id());
+	if (irq_base < 0)
+		goto out_irqdesc_free;
+
+	cchip->domain = irq_domain_add_legacy(NULL, ngpio, irq_base, 0,
+		&irq_domain_simple_ops, NULL);
+	if (!cchip->domain)
+		goto out_irqdesc_free;
+
 	/*
 	 * IRQ chip init
 	 */
-	gc = irq_alloc_generic_chip("cns3xxx_gpio_irq", 1, secondary_irq_base,
+	gc = irq_alloc_generic_chip("cns3xxx_gpio_irq", 1, irq_base,
 		cchip->base, handle_edge_irq);
+
 	gc->private = cchip;
 
 	ct = gc->chip_types;
@@ -270,7 +282,11 @@
 
 	irq_setup_generic_chip(gc, IRQ_MSK(ngpio), IRQ_GC_INIT_MASK_CACHE,
 		IRQ_NOREQUEST, 0);
-
 	irq_set_chained_handler(irq, cns3xxx_gpio_irq_handler);
 	irq_set_handler_data(irq, cchip);
+
+	return;
+
+out_irqdesc_free:
+	irq_free_descs(irq_base, ngpio);
 }
Index: trunk/target/linux/cns3xxx/files/arch/arm/mach-cns3xxx/laguna.c
===================================================================
--- trunk/target/linux/cns3xxx/files/arch/arm/mach-cns3xxx/laguna.c	(revision 42297)
+++ trunk/target/linux/cns3xxx/files/arch/arm/mach-cns3xxx/laguna.c	(working copy)
@@ -809,7 +809,7 @@
 
 	platform_device_register(&laguna_i2c_controller);
 
-	/* Set ext_int 0-3 drive strength to 21 mA */
+	/* Set I2C 0-3 drive strength to 21 mA */
 	reg = MISC_IO_PAD_DRIVE_STRENGTH_CTRL_B;
 	*reg |= 0x300;
 
@@ -817,9 +817,8 @@
 	reg = MISC_GPIOB_PIN_ENABLE_REG;
 	*reg |= BIT(12) | BIT(13);
 
-	/* Enable MMC/SD pins */
-	reg = MISC_GPIOA_PIN_ENABLE_REG;
-	*reg |= 0xf80;
+	/* Enable SPI pins */
+	*reg |= BIT(7) | BIT(8) | BIT(9) | BIT(10) | BIT(11);
 
 	cns3xxx_pwr_clk_en(1 << PM_CLK_GATE_REG_OFFSET_SPI_PCM_I2C);
 	cns3xxx_pwr_power_up(1 << PM_CLK_GATE_REG_OFFSET_SPI_PCM_I2C);
@@ -1050,7 +1049,9 @@
 			laguna_gpio_leds[0].gpio = 107;
 			laguna_gpio_leds[1].gpio = 106;
 			laguna_gpio_leds_data.num_leds = 2;
-		} else if (strncmp(laguna_info.model, "GW2391", 6) == 0) {
+		} else if ( (strncmp(laguna_info.model, "GW2391", 6) == 0)
+			 || (strncmp(laguna_info.model, "GW2393", 6) == 0) )
+		{
 			// configure GPIO's
 			laguna_register_gpio(ARRAY_AND_SIZE(laguna_gpio_gw2391));
 			// configure LED's
Index: trunk/target/linux/cns3xxx/files/drivers/input/misc/gsc-input.c
===================================================================
--- trunk/target/linux/cns3xxx/files/drivers/input/misc/gsc-input.c	(revision 0)
+++ trunk/target/linux/cns3xxx/files/drivers/input/misc/gsc-input.c	(working copy)
@@ -0,0 +1,180 @@
+/*
+ * Copyright (C) 2014 Gateworks Corporation
+ *
+ * Written by Tim Harvey <tharvey@gateworks.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of_irq.h>
+#include <linux/platform_device.h>
+
+#include <linux/mfd/gsc.h>
+
+#define DRIVER_NAME "gsc_input"
+
+static irqreturn_t gsc_input_irq(int irq, void *data)
+{
+	struct input_dev *input = (struct input_dev *)data;
+	int key;
+	u8 sts;
+	struct irq_desc *desc = irq_to_desc(irq);
+
+	gsc_i2c_read(GSC_IRQ_STATUS, &sts);
+	dev_dbg(&input->dev, "irq%d status=0x%02x\n", irq, sts);
+
+	while (sts) {
+		irq = fls(sts);
+		irq--;
+		sts &= ~BIT(irq);
+
+		switch(irq) {
+		/* user button press and release within 700ms */
+		case GSC_IRQ_PB:
+			key = BTN_0;
+			break;
+		/* user eeprom section has been erased */
+		case GSC_IRQ_KEY_ERASED:
+			key = BTN_1;
+			break;
+		/* user eeprom write-protect violation */
+		case GSC_IRQ_EEPROM_WP:
+			key = BTN_2;
+			break;
+		/* gpio change event */
+		case GSC_IRQ_GPIO:
+			key = BTN_3;
+			break;
+		/* tamper event */
+		case GSC_IRQ_TAMPER:
+			key = BTN_4;
+			break;
+		/* user button held down for more than 700ms */
+		case GSC_IRQ_SWITCH_HOLD:
+			key = BTN_5;
+			break;
+		default:
+			key = 0;
+			break;
+		}
+
+		if (desc->action->name) {
+			dev_dbg(&input->dev, "bit%d: key=0x%03x %s\n", irq,
+				key, desc->action->name);
+			input_report_key(input, key, 1);
+			input_report_key(input, key, 0);
+			input_sync(input);
+		}
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int gsc_input_probe(struct platform_device *pdev)
+{
+	struct input_dev *input;
+	int err, i, irq;
+	struct resource r;
+	static char *irq_names[] = {
+		"button",
+		"key-erased",
+		"eeprom-wp",
+		NULL,
+		NULL,
+		"tamper",
+		NULL,
+		"button-held"
+	};
+	u8 reg;
+
+	if (gsc_i2c_read(GSC_CTRL_0, &reg)) {
+		dev_err(&pdev->dev, "failed reading GSC_CTRL_0\n");
+		return -EIO;
+	}
+
+	input = devm_input_allocate_device(&pdev->dev);
+	if (!input) {
+		dev_err(&pdev->dev, "Can't allocate input device\n");
+		return -ENOMEM;
+	}
+
+	input->name = DRIVER_NAME;
+	input->dev.parent = &pdev->dev;
+
+	input_set_capability(input, EV_KEY, BTN_0);
+	input_set_capability(input, EV_KEY, BTN_1);
+	input_set_capability(input, EV_KEY, BTN_2);
+	input_set_capability(input, EV_KEY, BTN_3);
+	input_set_capability(input, EV_KEY, BTN_4);
+	input_set_capability(input, EV_KEY, BTN_5);
+
+	platform_set_drvdata(pdev, input);
+
+	for (i = 0; i < 8; i++) {
+		if (pdev->dev.of_node) {
+			irq = of_irq_to_resource(pdev->dev.of_node, i, &r);
+			if (!irq)
+				break;
+		} else {
+			if (!irq_names[i])
+				continue;
+			r.name = irq_names[i];
+			irq = 160 + i;
+		}
+		err = devm_request_threaded_irq(&pdev->dev, irq, NULL,
+						gsc_input_irq, 0, r.name,
+						input);
+		if (err < 0) {
+			dev_err(&pdev->dev, "failed to claim irq%d: %d\n", irq,
+				err);
+			return err;
+		}
+		dev_dbg(&pdev->dev, "registered irq%d: %s\n", irq, r.name);
+	}
+
+	err = input_register_device(input);
+	if (err) {
+		dev_err(&pdev->dev, "Can't register input device: %d\n", err);
+		return err;
+	}
+
+	dev_info(&pdev->dev, "input driver installed: CTRL_0=0x%02x\n", reg);
+
+	return 0;
+}
+
+static int gsc_input_remove(struct platform_device *pdev)
+{
+	dev_info(&pdev->dev, "input driver removed\n");
+	return 0;
+}
+
+static const struct of_device_id gsc_input_dt_ids[] = {
+	{ .compatible = "gw,gsc_input", },
+	{ }
+};
+
+static struct platform_driver gsc_input_driver = {
+	.probe		= gsc_input_probe,
+	.remove		= gsc_input_remove,
+	.driver		= {
+		.name	= DRIVER_NAME,
+		.owner	= THIS_MODULE,
+		.of_match_table = gsc_input_dt_ids,
+	},
+};
+
+module_platform_driver(gsc_input_driver);
+
+MODULE_AUTHOR("Tim Harvey <tharvey@gateworks.com>");
+MODULE_DESCRIPTION("Input driver for GSC");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:" DRIVER_NAME);
Index: trunk/target/linux/cns3xxx/files/drivers/mfd/gsc-core.c
===================================================================
--- trunk/target/linux/cns3xxx/files/drivers/mfd/gsc-core.c	(revision 0)
+++ trunk/target/linux/cns3xxx/files/drivers/mfd/gsc-core.c	(working copy)
@@ -0,0 +1,459 @@
+/*
+ * Copyright (C) 2014 Gateworks Corporation
+ *
+ * Written by Tim Harvey <tharvey@gateworks.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/mfd/core.h>
+#include <linux/mfd/gsc.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+
+#include "gsc-core.h"
+
+#define I2C_RETRIES	3
+
+/*
+ * The Gateworks System Controller (GSC) is a family of a multi-function
+ * "Power Management and System Companion Device" chips originally designed for
+ * use in Gateworks Single Board Computers. The control interface is I2C,
+ * at 100kbps, with an interrupt.
+ *
+ * This driver core provides genirq support for the interrupts emitted,
+ * by the various modules, and exports register access primitives.
+ *
+ */
+
+#define DRIVER_NAME			"gsc"
+
+/*----------------------------------------------------------------------*/
+
+struct gsc {
+	struct i2c_client *client;
+	struct device *dev;
+	unsigned int fwver;
+	unsigned short fwcrc;
+	unsigned char ready;
+	struct mutex io_lock;
+	struct platform_device *gsc;
+	struct platform_device *wdt;
+	struct platform_device *input;
+};
+
+static struct gsc *gsc_priv;
+
+/**
+ * gsc_i2c_write - Writes a register to GSC with retries
+ * @reg: register address
+ * @val: value to write
+ *
+ * Returns the result of operation - 0 is success
+ */
+int __gsc_i2c_write(u8 reg, u8 val)
+{
+	int retry, ret;
+
+	for (retry = 0; retry < I2C_RETRIES; retry++) {
+		ret = i2c_smbus_write_byte_data(gsc_priv->client, reg, val);
+		/*
+		 * -EAGAIN returned when the i2c host controller is busy
+		 * -EIO returned when i2c device is busy
+		 */
+		if (ret != -EAGAIN && ret != -EIO)
+			break;
+	}
+	if (ret < 0) {
+		dev_err(&gsc_priv->client->dev, ">> 0x%02x %d\n", reg, ret);
+		return ret;
+	}
+	dev_dbg(&gsc_priv->client->dev, ">> 0x%02x=0x%02x (%d)\n", reg,
+		val, retry);
+
+	return 0;
+}
+
+/**
+ * gsc_i2c_read - Reads register from GSC with retries
+ * @reg: register address
+ * @val: value to write
+ *
+ * Returns result of operation
+ */
+static int __gsc_i2c_read(u8 reg, u8 *val)
+{
+	int retry, ret;
+
+	for (retry = 0; retry < I2C_RETRIES; retry++) {
+		ret = i2c_smbus_read_byte_data(gsc_priv->client, reg);
+		/*
+		 * -EAGAIN returned when the i2c host controller is busy
+		 * -EIO returned when i2c device is busy
+		 */
+		if (ret != -EAGAIN && ret != -EIO)
+			break;
+	}
+	if (ret < 0) {
+		dev_err(&gsc_priv->client->dev, "<< 0x%02x %d\n", reg, ret);
+		return ret;
+	}
+
+	*val = ret & 0xff;
+	dev_dbg(&gsc_priv->client->dev, "<< 0x%02x=0x%02x (%d)\n", reg,
+		*val, retry);
+
+	return 0;
+}
+
+/**
+ * gsc_i2c_update - set bits
+ * @reg: register address
+ * @mask: bits to clear
+ * @set; bits to set
+ *
+ * Returns result of operation
+ */
+static int __gsc_i2c_update(u8 reg, u8 mask, u8 set)
+{
+	u8 rval;
+	int ret;
+
+	ret = __gsc_i2c_read(reg, &rval);
+	if (ret)
+		return ret;
+	rval &= ~mask;
+	ret = __gsc_i2c_write(reg, rval | set);
+	return ret;
+}
+
+/* Exported Functions */
+
+/**
+ * gsc_i2c_write - Writes a register to GSC
+ * @reg: register address
+ * @val: value to write
+ *
+ * Returns the result of operation - 0 is success
+ */
+int gsc_i2c_write(u8 reg, u8 val)
+{
+	struct device *dev = &gsc_priv->client->dev;
+	int ret = 0;
+
+	if (unlikely(!gsc_priv || !gsc_priv->ready)) {
+		pr_err("%s: not initialized\n", DRIVER_NAME);
+		return -EPERM;
+	}
+
+	mutex_lock(&gsc_priv->io_lock);
+	ret = __gsc_i2c_write(reg, val);
+	if (ret < 0)
+		dev_err(dev, ">> 0x%02x %d\n", reg, ret);
+	else
+		dev_dbg(dev, ">> 0x%02x=0x%02x\n", reg, val);
+	mutex_unlock(&gsc_priv->io_lock);
+
+	return ret;
+}
+EXPORT_SYMBOL(gsc_i2c_write);
+
+/**
+ * gsc_i2c_read - Reads register from GSC
+ * @reg: register address
+ * @val: value to write
+ *
+ * Returns result of operation
+ */
+int gsc_i2c_read(u8 reg, u8 *val)
+{
+	struct device *dev = &gsc_priv->client->dev;
+	int ret = 0;
+
+	if (unlikely(!gsc_priv || !gsc_priv->ready)) {
+		pr_err("%s: not initialized\n", DRIVER_NAME);
+		return -EPERM;
+	}
+
+	mutex_lock(&gsc_priv->io_lock);
+	ret = __gsc_i2c_read(reg, val);
+	if (ret < 0)
+		dev_err(dev, "<< 0x%02x %d\n", reg, ret);
+	else
+		dev_dbg(dev, "<< 0x%02x=0x%02x\n", reg, *val);
+	mutex_unlock(&gsc_priv->io_lock);
+
+	return ret;
+}
+EXPORT_SYMBOL(gsc_i2c_read);
+
+/**
+ * gsc_i2c_update - read/write register from GSC
+ * @reg: register address
+ * @mask: bits to clear
+ * @val: bits to set
+ *
+ * Returns result of operation
+ */
+int gsc_i2c_update(u8 reg, u8 mask, u8 val)
+{
+	int ret = 0;
+
+	if (unlikely(!gsc_priv || !gsc_priv->ready)) {
+		pr_err("%s: not initialized\n", DRIVER_NAME);
+		return -EPERM;
+	}
+
+	mutex_lock(&gsc_priv->io_lock);
+	ret = __gsc_i2c_update(reg, mask, val);
+	mutex_unlock(&gsc_priv->io_lock);
+
+	return ret;
+}
+EXPORT_SYMBOL(gsc_i2c_update);
+
+/*----------------------------------------------------------------------*/
+
+/**
+ * gsc_get_fwver - API to get GSC FW version.
+ */
+int gsc_get_fwver(void)
+{
+	if (unlikely(!gsc_priv || !gsc_priv->ready)) {
+		pr_err("%s: not initialized\n", DRIVER_NAME);
+		return -EPERM;
+	}
+
+	return gsc_priv->fwver;
+}
+EXPORT_SYMBOL_GPL(gsc_get_fwver);
+
+/*
+ * gsc_powerdown - API to use GSC to power down board for a specific time
+ *
+ * secs - number of seconds to remain powered off
+ */
+int gsc_powerdown(unsigned long secs)
+{
+	int ret;
+
+	if (!gsc_priv)
+		return -ENODEV;
+
+	dev_info(&gsc_priv->client->dev, "GSC powerdown for %ld seconds\n",
+		 secs);
+	mutex_lock(&gsc_priv->io_lock);
+	ret = __gsc_i2c_write(GSC_TIME_ADD + 0, secs & 0xff);
+	if (ret)
+		goto done;
+	ret = __gsc_i2c_write(GSC_TIME_ADD + 1, (secs >> 8) & 0xff);
+	if (ret)
+		goto done;
+	ret = __gsc_i2c_write(GSC_TIME_ADD + 2, (secs >> 16) & 0xff);
+	if (ret)
+		goto done;
+	ret = __gsc_i2c_write(GSC_TIME_ADD + 3, (secs >> 24) & 0xff);
+	if (ret)
+		goto done;
+	ret = __gsc_i2c_update(GSC_CTRL_1, 0, 1 << GSC_CTRL_1_LATCH_SLEEP_ADD);
+	if (ret)
+		goto done;
+	ret = __gsc_i2c_update(GSC_CTRL_1, 0, 1 << GSC_CTRL_1_ACTIVATE_SLEEP |
+			       1 << GSC_CTRL_1_SLEEP_ENABLE);
+	if (ret)
+		goto done;
+
+	ret = 0;
+
+done:
+	mutex_unlock(&gsc_priv->io_lock);
+
+	return ret;
+}
+
+/*----------------------------------------------------------------------*/
+
+
+/*
+ * sysfs hooks
+ */
+static ssize_t gsc_show(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct gsc *gsc = dev_get_drvdata(dev);
+	const char *name = attr->attr.name;
+	int rz = 0;
+
+	if (strcasecmp(name, "fw_version") == 0)
+		rz = sprintf(buf, "%d\n", gsc->fwver);
+	else if (strcasecmp(name, "fw_crc") == 0)
+		rz = sprintf(buf, "0x%04x\n", gsc->fwcrc);
+
+	return rz;
+}
+
+static ssize_t gsc_store(struct device *dev, struct device_attribute *attr,
+			 const char *buf, size_t count)
+{
+	const char *name = attr->attr.name;
+	int ret;
+
+	if (strcasecmp(name, "powerdown") == 0) {
+		long value;
+
+		ret = strict_strtol(buf, 0, &value);
+		if (ret == 0)
+			gsc_powerdown(value);
+	} else
+		printk(KERN_ERR "invalid name '%s\n", name);
+
+	return count;
+}
+
+
+/*
+ * Create a group of attributes so that we can create and destroy them all
+ * at once.
+ */
+static struct device_attribute attr_fwver =
+	__ATTR(fw_version, 0440, gsc_show, NULL);
+static struct device_attribute attr_fwcrc =
+	__ATTR(fw_crc, 0440, gsc_show, NULL);
+static struct device_attribute attr_pwrdown =
+	__ATTR(powerdown, 0220, NULL, gsc_store);
+
+static struct attribute *gsc_attrs[] = {
+	&attr_fwver.attr,
+	&attr_fwcrc.attr,
+	&attr_pwrdown.attr,
+	NULL,
+};
+
+static struct attribute_group attr_group = {
+	.attrs = gsc_attrs,
+};
+
+static int
+gsc_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	struct device *dev = &client->dev;
+	struct gsc *gsc;
+	int ret, irq_base = 0;
+	u8 reg;
+
+	if (client->irq <= 0) {
+		dev_err(dev, "%s: no irq specified\n", DRIVER_NAME);
+		return -EINVAL;
+	}
+	if (gsc_priv) {
+		dev_err(dev, "already initialized\n");
+		return -EBUSY;
+	}
+
+	if (i2c_check_functionality(client->adapter, I2C_FUNC_I2C) == 0) {
+		dev_dbg(dev, "can't talk I2C?\n");
+		return -EIO;
+	}
+
+
+	gsc = devm_kzalloc(dev, sizeof(struct gsc), GFP_KERNEL);
+	if (!gsc)
+		ret = -ENOMEM;
+	gsc_priv = gsc;
+
+	mutex_init(&gsc->io_lock);
+	gsc->client = client;
+
+	if (__gsc_i2c_read(GSC_FW_VER, &reg))
+		return -EIO;
+	gsc->fwver = reg;
+	__gsc_i2c_read(GSC_FW_CRC, &reg);
+	gsc->fwcrc = reg << 8;
+	__gsc_i2c_read(GSC_FW_CRC+1, &reg);
+	gsc->fwcrc |= reg;
+	gsc->ready = true;
+
+	irq_base = gsc_irq_init(&client->dev, client->irq);
+	if (irq_base < 0)
+		return irq_base;
+	dev_info(dev, "Gateworks System Controller: fw v%02d crc=0x%04x irq%d\n",
+		 gsc->fwver, gsc->fwcrc, client->irq);
+
+	i2c_set_clientdata(client, gsc);
+	gsc->dev = &client->dev;
+
+	ret = sysfs_create_group(&client->dev.kobj, &attr_group);
+	if (ret)
+		dev_err(dev, "failed to create sysfs attrs\n");
+
+	if (client->dev.of_node) {
+		printk("Populating platform devices\n");
+		ret = of_platform_populate(client->dev.of_node, NULL, NULL,
+					   &client->dev);
+	}
+
+	return ret;
+}
+
+static int gsc_remove(struct i2c_client *client)
+{
+	struct gsc *gsc = i2c_get_clientdata(client);
+
+	sysfs_remove_group(&client->dev.kobj, &attr_group);
+	mfd_remove_devices(gsc->dev);
+	gsc_priv = NULL;
+
+	return 0;
+}
+
+static const struct i2c_device_id gsc_i2c_ids[] = {
+	{ "gsc", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, gsc_i2c_ids);
+
+static const struct of_device_id gsc_dt_ids[] = {
+	{ .compatible = "gw,gsc", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, gsc_dt_ids);
+
+static struct i2c_driver gsc_driver = {
+	.driver = {
+		.name	= DRIVER_NAME,
+		.of_match_table = gsc_dt_ids,
+	},
+	.probe		= gsc_probe,
+	.remove		= gsc_remove,
+	.id_table	= gsc_i2c_ids,
+};
+
+static int __init gsc_init(void)
+{
+        return i2c_add_driver(&gsc_driver);
+}
+/* register after i2c postcore initcall and before
+ * subsys initcalls that may rely on these GPIOs
+ */
+subsys_initcall(gsc_init);
+
+static void __exit gsc_exit(void)
+{
+        i2c_del_driver(&gsc_driver);
+}
+module_exit(gsc_exit);
+
+MODULE_AUTHOR("Tim Harvey <tharvey@gateworks.com>");
+MODULE_DESCRIPTION("I2C Core interface for GSC");
+MODULE_LICENSE("GPL v2");
Index: trunk/target/linux/cns3xxx/files/drivers/mfd/gsc-core.h
===================================================================
--- trunk/target/linux/cns3xxx/files/drivers/mfd/gsc-core.h	(revision 0)
+++ trunk/target/linux/cns3xxx/files/drivers/mfd/gsc-core.h	(working copy)
@@ -0,0 +1,7 @@
+#ifndef __GSC_CORE_H_
+#define __GSC_CORE_H_
+
+extern int gsc_irq_init(struct device *dev, int irq_num);
+extern int gsc_irq_exit(void);
+
+#endif /* __GSC_CORE_H_ */
Index: trunk/target/linux/cns3xxx/files/drivers/mfd/gsc-irq.c
===================================================================
--- trunk/target/linux/cns3xxx/files/drivers/mfd/gsc-irq.c	(revision 0)
+++ trunk/target/linux/cns3xxx/files/drivers/mfd/gsc-irq.c	(working copy)
@@ -0,0 +1,129 @@
+/*
+ * Copyright (C) 2014 Gateworks Corporation
+ *
+ * Written by Tim Harvey <tharvey@gateworks.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/irqdomain.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+
+#include <linux/mfd/gsc.h>
+
+struct gsc_agent {
+	int irq_base;
+	int irq_num;
+};
+
+static struct gsc_agent *gsc_agent;
+
+static struct irq_chip gsc_irq_chip = {
+	.name		= "gsc",
+	.flags		= IRQCHIP_SKIP_SET_WAKE,
+};
+
+static irqreturn_t gsc_irq(int irq, void *data)
+{
+	struct gsc_agent *agent = data;
+	u8 sts;
+
+	gsc_i2c_read(GSC_IRQ_STATUS, &sts);
+	pr_debug("gsc: irq%d status=0x%02x\n", irq, sts);
+
+	while (sts) {
+		irq = fls(sts);
+		irq--;
+		sts &= ~BIT(irq);
+
+		handle_nested_irq(agent->irq_base + irq);
+	}
+
+	/* clear all status bits */
+	gsc_i2c_write(GSC_IRQ_STATUS, 0);
+
+	return IRQ_HANDLED;
+}
+
+int gsc_irq_init(struct device *dev, int irq_num)
+{
+	static struct irq_chip gsc_mod_irq_chip;
+	int ret, i;
+	int irq_base, irq_end, nr_irqs;
+	struct device_node *node = dev->of_node;
+	struct gsc_agent *agent;
+	u8 reg;
+
+	agent = devm_kzalloc(dev, sizeof *agent, GFP_KERNEL);
+	if (!agent)
+		return -ENOMEM;
+
+	nr_irqs = 8;
+
+	/* allocate 8 virq's for GSC status register bits */
+	irq_base = irq_alloc_descs(-1, 0, nr_irqs, 0);
+	if (irq_base< 0)
+		return irq_base;
+
+	irq_domain_add_legacy(node, nr_irqs, irq_base, 0,
+			      &irq_domain_simple_ops, NULL);
+	irq_end = irq_base + nr_irqs;
+
+	/* clear all GSC interrupts */
+	ret = gsc_i2c_read(GSC_IRQ_ENABLE, &reg);
+	if (ret < 0) {
+		dev_err(dev, "failed reading GSC_IRQ_ENABLE\n");
+		return ret;
+	}
+	if (reg == 0)
+		dev_warn(dev, "no GSC interrupts enabled\n");
+	gsc_i2c_write(GSC_IRQ_STATUS, 0);
+
+	/* install irq handler for each module */
+	gsc_mod_irq_chip = dummy_irq_chip;
+	gsc_mod_irq_chip.name = "gsc";
+
+	gsc_irq_chip.irq_ack = dummy_irq_chip.irq_ack;
+	agent->irq_base = irq_base;
+
+	for (i = irq_base; i < irq_end; i++) {
+		irq_set_chip_data(i, agent);
+		irq_set_chip_and_handler(i, &gsc_mod_irq_chip,
+					 handle_simple_irq);
+		irq_set_nested_thread(i, 1);
+	}
+	gsc_i2c_write(GSC_IRQ_ENABLE, reg);
+
+	/* install irq handler to demux the GSC IRQ */
+	ret = devm_request_threaded_irq(dev, irq_num, NULL, gsc_irq,
+					IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
+					"gsc", agent);
+	if (ret < 0) {
+		dev_err(dev, "could not claim irq%d: %d\n", irq_num, ret);
+		goto fail_reqirq;
+	}
+	enable_irq_wake(irq_num);
+	gsc_agent = agent;
+	gsc_agent->irq_num = irq_num;
+
+	return irq_base;
+
+fail_reqirq:
+	irq_free_descs(irq_base, nr_irqs);
+
+	return ret;
+}
+
+int gsc_irq_exit(void)
+{
+	irq_free_descs(gsc_agent->irq_base, nr_irqs);
+	return 0;
+}
Index: trunk/target/linux/cns3xxx/files/drivers/net/ethernet/cavium/cns3xxx_eth.c
===================================================================
--- trunk/target/linux/cns3xxx/files/drivers/net/ethernet/cavium/cns3xxx_eth.c	(revision 42297)
+++ trunk/target/linux/cns3xxx/files/drivers/net/ethernet/cavium/cns3xxx_eth.c	(working copy)
@@ -718,8 +718,8 @@
 		napi_complete(napi);
 		enable_irq(sw->rx_irq);
 
-		/* if rx descriptors are full schedule another poll */
-		if (rx_ring->desc[(i-1) & (RX_DESCS-1)].cown)
+		/* If 1 or more frames came in during IRQ enable, re-schedule */
+		if (rx_ring->desc[i].cown)
 			eth_schedule_poll(sw);
 	}
 
Index: trunk/target/linux/cns3xxx/files/drivers/watchdog/gsc_wdt.c
===================================================================
--- trunk/target/linux/cns3xxx/files/drivers/watchdog/gsc_wdt.c	(revision 0)
+++ trunk/target/linux/cns3xxx/files/drivers/watchdog/gsc_wdt.c	(working copy)
@@ -0,0 +1,178 @@
+/*
+ * Copyright (C) 2014 Gateworks Corporation
+ *
+ * Written by Tim Harvey <tharvey@gateworks.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/types.h>
+#include <linux/slab.h>
+#include <linux/watchdog.h>
+
+#include <linux/mfd/gsc.h>
+
+static bool nowayout = WATCHDOG_NOWAYOUT;
+module_param(nowayout, bool, 0);
+MODULE_PARM_DESC(nowayout, "Watchdog cannot be stopped once started "
+        "(default=" __MODULE_STRING(WATCHDOG_NOWAYOUT) ")");
+
+static int gsc_wdt_start(struct watchdog_device *wdt)
+{
+	u8 reg = (1 << GSC_CTRL_1_WDT_ENABLE);
+
+	dev_dbg(wdt->dev, "%s timeout=%d\n", __func__, wdt->timeout);
+
+	return gsc_i2c_update(GSC_CTRL_1, reg, reg);
+}
+
+static int gsc_wdt_stop(struct watchdog_device *wdt)
+{
+	u8 reg = (1 << GSC_CTRL_1_WDT_ENABLE);
+
+	dev_dbg(wdt->dev, "%s\n", __func__);
+
+	return gsc_i2c_update(GSC_CTRL_1, reg, 0);
+}
+
+static int gsc_wdt_set_timeout(struct watchdog_device *wdt,
+			       unsigned int timeout)
+{
+	u8 long_sel = 0;
+
+	dev_dbg(wdt->dev, "%s: %d\n", __func__, timeout);
+
+	switch (timeout) {
+	case 60:
+		long_sel = (1 << GSC_CTRL_1_WDT_TIME);
+	case 30:
+		gsc_i2c_update(GSC_CTRL_1,
+			       (1 << GSC_CTRL_1_WDT_TIME),
+			       (long_sel << GSC_CTRL_1_WDT_TIME));
+		wdt->timeout = timeout;
+		return 0;
+	}
+
+	return -EINVAL;
+}
+
+static const struct watchdog_info gsc_wdt_info = {
+	.options = WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING,
+	.identity = "GSC Watchdog"
+};
+
+static const struct watchdog_ops gsc_wdt_ops = {
+	.owner		= THIS_MODULE,
+	.start		= gsc_wdt_start,
+	.stop		= gsc_wdt_stop,
+	.set_timeout	= gsc_wdt_set_timeout,
+};
+
+static int gsc_wdt_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	struct watchdog_device *wdt;
+	u8 reg;
+
+	if (gsc_get_fwver() < 44) {
+		dev_err(&pdev->dev, "firmware v44 or newer required "
+			"for watchdog functionality\n");
+		return -EINVAL;
+	}
+
+	/* ensure WD bit enabled */
+	if (gsc_i2c_read(GSC_CTRL_1, &reg)) {
+		dev_err(&pdev->dev, "failed reading GSC_CTRL_1\n");
+		return -EIO;
+	}
+	if (!(reg & (1 << GSC_CTRL_1_WDT_ENABLE))) {
+		dev_err(&pdev->dev, "GSC WDT_ENABLE not enabled"
+			" - must be manually enabled\n");
+		return -EINVAL;
+	}
+
+	wdt = devm_kzalloc(&pdev->dev, sizeof(*wdt), GFP_KERNEL);
+	if (!wdt)
+		return -ENOMEM;
+
+	wdt->info		= &gsc_wdt_info;
+	wdt->ops		= &gsc_wdt_ops;
+	wdt->status		= 0;
+	wdt->timeout		= 30;
+	wdt->min_timeout	= 30;
+	wdt->max_timeout	= 60;
+
+	watchdog_set_nowayout(wdt, nowayout);
+	platform_set_drvdata(pdev, wdt);
+
+	ret = watchdog_register_device(wdt);
+	if (ret) {
+		platform_set_drvdata(pdev, NULL);
+		return ret;
+	}
+	dev_info(&pdev->dev, "registerted watchdog (nowayout=%d)\n",
+		 nowayout);
+
+	return 0;
+}
+
+static int gsc_wdt_remove(struct platform_device *pdev)
+{
+	struct watchdog_device *wdt = platform_get_drvdata(pdev);
+
+	watchdog_unregister_device(wdt);
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int gsc_wdt_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct watchdog_device *wdt = platform_get_drvdata(pdev);
+	if (watchdog_active(wdt))
+		return gsc_wdt_stop(wdt);
+
+	return 0;
+}
+
+static int gsc_wdt_resume(struct platform_device *pdev)
+{
+	struct watchdog_device *wdt = platform_get_drvdata(pdev);
+	if (watchdog_active(wdt))
+		return gsc_wdt_start(wdt);
+
+	return 0;
+}
+#else
+#define gsc_wdt_suspend        NULL
+#define gsc_wdt_resume         NULL
+#endif
+
+static const struct of_device_id gsc_wdt_dt_ids[] = {
+	{ .compatible = "gw,gsc_wdt", },
+	{ /* sentinel */ }
+};
+
+static struct platform_driver gsc_wdt_driver = {
+	.probe		= gsc_wdt_probe,
+	.remove		= gsc_wdt_remove,
+	.suspend	= gsc_wdt_suspend,
+	.resume		= gsc_wdt_resume,
+	.driver		= {
+		.owner	= THIS_MODULE,
+		.name	= "gsc_wdt",
+		.of_match_table = gsc_wdt_dt_ids,
+	},
+};
+
+module_platform_driver(gsc_wdt_driver);
+
+MODULE_AUTHOR("Tim Harvey <tharvey@gateworks.com>");
+MODULE_DESCRIPTION("Watchdog driver for GSC");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:gsc_wdt");
Index: trunk/target/linux/cns3xxx/files/include/linux/mfd/gsc.h
===================================================================
--- trunk/target/linux/cns3xxx/files/include/linux/mfd/gsc.h	(revision 0)
+++ trunk/target/linux/cns3xxx/files/include/linux/mfd/gsc.h	(working copy)
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2014 Gateworks Corporation
+ *
+ * Written by Tim Harvey <tharvey@gateworks.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __GSC_H_
+#define __GSC_H_
+
+struct gsc_platform_data {
+	struct pca953x_platform_data *pca953x_data;
+};
+
+/* Register offsets */
+#define GSC_CTRL_0	0x00
+#define GSC_CTRL_1	0x01
+#define GSC_TIME	0x02
+#define GSC_TIME_ADD	0x06
+#define GSC_IRQ_STATUS	0x0A
+#define GSC_IRQ_ENABLE	0x0B
+#define GSC_FW_CRC	0x0C
+#define GSC_FW_VER	0x0E
+#define GSC_WP		0x0F
+
+/* Bit definitions */
+#define GSC_CTRL_0_PB_HARD_RESET	0
+#define GSC_CTRL_0_PB_CLEAR_SECURE_KEY	1
+#define GSC_CTRL_0_PB_SOFT_POWER_DOWN	2
+#define GSC_CTRL_0_PB_BOOT_ALTERNATE	3
+#define GSC_CTRL_0_PERFORM_CRC		4
+#define GSC_CTRL_0_TAMPER_DETECT	5
+#define GSC_CTRL_0_SWITCH_HOLD		6
+
+#define GSC_CTRL_1_SLEEP_ENABLE		0
+#define GSC_CTRL_1_ACTIVATE_SLEEP	1
+#define GSC_CTRL_1_LATCH_SLEEP_ADD	2
+#define GSC_CTRL_1_SLEEP_NOWAKEPB	3
+#define GSC_CTRL_1_WDT_TIME		4
+#define GSC_CTRL_1_WDT_ENABLE		5
+#define GSC_CTRL_1_SWITCH_BOOT_ENABLE	6
+#define GSC_CTRL_1_SWITCH_BOOT_CLEAR	7
+
+#define GSC_IRQ_PB			0
+#define GSC_IRQ_KEY_ERASED		1
+#define GSC_IRQ_EEPROM_WP		2
+#define GSC_IRQ_GPIO			4
+#define GSC_IRQ_TAMPER			5
+#define GSC_IRQ_ALT_BOOT		6
+#define GSC_IRQ_SWITCH_HOLD		7
+
+/*
+ * Read and write single 8-bit registers
+ */
+int gsc_i2c_write(u8 reg, u8 val);
+int gsc_i2c_read(u8 reg, u8 *val);
+int gsc_i2c_update(u8 reg, u8 valmask, u8 val);
+
+int gsc_get_fwver(void);
+int gsc_powerdown(unsigned long seconds);
+
+#endif
Index: trunk/target/linux/cns3xxx/patches-3.10/066-pci_isolated_interrupts.patch
===================================================================
--- trunk/target/linux/cns3xxx/patches-3.10/066-pci_isolated_interrupts.patch	(revision 0)
+++ trunk/target/linux/cns3xxx/patches-3.10/066-pci_isolated_interrupts.patch	(working copy)
@@ -0,0 +1,201 @@
+--- a/arch/arm/mach-cns3xxx/cns3420vb.c
++++ b/arch/arm/mach-cns3xxx/cns3420vb.c
+@@ -272,7 +272,7 @@ static int __init cns3420vb_pcie_init(vo
+ 	if (!machine_is_cns3420vb())
+ 		return 0;
+ 
+-	return cns3xxx_pcie_init();
++	return cns3xxx_pcie_init(NULL, NULL);
+ }
+ subsys_initcall(cns3420vb_pcie_init);
+ 
+--- a/arch/arm/mach-cns3xxx/core.h
++++ b/arch/arm/mach-cns3xxx/core.h
+@@ -23,7 +23,7 @@ static inline void cns3xxx_l2x0_init(voi
+ 
+ void __init cns3xxx_map_io(void);
+ void __init cns3xxx_init_irq(void);
+-int  __init cns3xxx_pcie_init(void);
++int  __init cns3xxx_pcie_init(int *pcie0_irqs, int *pcie1_irqs);
+ void cns3xxx_power_off(void);
+ void cns3xxx_restart(char, const char *);
+ 
+--- a/arch/arm/mach-cns3xxx/laguna.c
++++ b/arch/arm/mach-cns3xxx/laguna.c
+@@ -21,6 +21,7 @@
+ #include <linux/kernel.h>
+ #include <linux/compiler.h>
+ #include <linux/io.h>
++#include <linux/irq.h>
+ #include <linux/gpio.h>
+ #include <linux/dma-mapping.h>
+ #include <linux/serial_core.h>
+@@ -869,12 +870,53 @@ static int laguna_register_gpio(struct g
+ 	return ret;
+ }
+ 
++static int cns3xxx_pciextirq = 1;
++
++static int __init cns3xxx_pciextirq_disable(char *s)
++{
++        cns3xxx_pciextirq = 0;
++        return 1;
++}
++__setup("noextirq", cns3xxx_pciextirq_disable);
++
+ static int __init laguna_pcie_init(void)
+ {
+ 	if (!machine_is_gw2388())
+ 		return 0;
+ 
+-	return cns3xxx_pcie_init();
++	if (cns3xxx_pciextirq) {
++		u32 __iomem *mem;
++		u32 reg;
++		int pcie0_irqs[] = {
++			IRQ_CNS3XXX_EXTERNAL_PIN0,
++			IRQ_CNS3XXX_EXTERNAL_PIN1,
++			IRQ_CNS3XXX_EXTERNAL_PIN2,
++			154,
++		};
++
++		/*
++		 * Detect board revision:
++		 *   GW2388-4-G+ GPIOB[26:29] INTA/B/C/D thus will be high
++		 *   GW2388-4-F- GPIOB[16:19] INTA/B/C/D thus will be high
++		 */
++		mem = (void __iomem *)(CNS3XXX_GPIOB_BASE_VIRT + 0x0004);
++		reg = __raw_readl(mem) >> 16;
++		switch (reg & 0x3c00) {
++		case 0x0408: /* GW2388-4-H */
++			pcie0_irqs[0] = IRQ_CNS3XXX_PCIE0_DEVICE;
++			pcie0_irqs[1] = IRQ_CNS3XXX_PCIE0_DEVICE;
++			pcie0_irqs[2] = IRQ_CNS3XXX_PCIE0_DEVICE;
++		case 0x0400: /* GW2388-4-G (mod) */
++			printk("%s: using external-irq\n", __func__);
++			return cns3xxx_pcie_init(pcie0_irqs, NULL);
++			break;
++		case 0x3c00: /* GW2388-4-G */
++		default:
++                	break;
++		}
++        }
++
++	return cns3xxx_pcie_init(NULL, NULL);
+ }
+ subsys_initcall(laguna_pcie_init);
+ 
+@@ -889,8 +931,30 @@ static int __init laguna_model_setup(voi
+ 	printk("Running on Gateworks Laguna %s\n", laguna_info.model);
+ 	cns3xxx_gpio_init( 0, 32, CNS3XXX_GPIOA_BASE_VIRT, IRQ_CNS3XXX_GPIOA,
+ 		NR_IRQS_CNS3XXX);
+-	cns3xxx_gpio_init(32, 32, CNS3XXX_GPIOB_BASE_VIRT, IRQ_CNS3XXX_GPIOB,
+-		NR_IRQS_CNS3XXX + 32);
++
++	if (cns3xxx_pciextirq) {
++		/*
++		 * if pcie external interrupts are supported and desired
++		 * configure IRQ types and configure pin function.
++		 */
++		mem = (void __iomem *)(CNS3XXX_MISC_BASE_VIRT + 0x0018);
++		reg = __raw_readl(mem);
++		/* GPIO26 is gpio, EXT_INT[0:2] not gpio func */
++		reg &= ~0x3c000000;
++		reg |= 0x38000000;
++		__raw_writel(reg, mem);
++
++		cns3xxx_gpio_init(32, 32, CNS3XXX_GPIOB_BASE_VIRT,
++				  IRQ_CNS3XXX_GPIOB, NR_IRQS_CNS3XXX + 32);
++
++		irq_set_irq_type(154, IRQ_TYPE_LEVEL_LOW);
++		irq_set_irq_type(93, IRQ_TYPE_LEVEL_HIGH);
++		irq_set_irq_type(94, IRQ_TYPE_LEVEL_HIGH);
++		irq_set_irq_type(95, IRQ_TYPE_LEVEL_HIGH);
++	} else {
++		cns3xxx_gpio_init(32, 32, CNS3XXX_GPIOB_BASE_VIRT,
++				  IRQ_CNS3XXX_GPIOB, NR_IRQS_CNS3XXX + 32);
++	}
+ 
+ 	if (strncmp(laguna_info.model, "GW", 2) == 0) {
+ 		if (laguna_info.config_bitmap & ETH0_LOAD)
+--- a/arch/arm/mach-cns3xxx/pcie.c
++++ b/arch/arm/mach-cns3xxx/pcie.c
+@@ -18,6 +18,7 @@
+ #include <linux/io.h>
+ #include <linux/ioport.h>
+ #include <linux/interrupt.h>
++#include <linux/irq.h>
+ #include <linux/ptrace.h>
+ #include <asm/mach/map.h>
+ #include "cns3xxx.h"
+@@ -32,7 +33,7 @@ enum cns3xxx_access_type {
+ 
+ struct cns3xxx_pcie {
+ 	struct map_desc cfg_bases[CNS3XXX_NUM_ACCESS_TYPES];
+-	unsigned int irqs[2];
++	unsigned int irqs[6];
+ 	struct resource res_io;
+ 	struct resource res_mem;
+ 	struct hw_pci hw_pci;
+@@ -255,7 +256,7 @@ static struct pci_ops cns3xxx_pcie_ops =
+ static int cns3xxx_pcie_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
+ {
+ 	struct cns3xxx_pcie *cnspci = pdev_to_cnspci(dev);
+-	int irq = cnspci->irqs[slot];
++	int irq = cnspci->irqs[slot+pin-1];
+ 
+ 	pr_info("PCIe map irq: %04d:%02x:%02x.%02x slot %d, pin %d, irq: %d\n",
+ 		pci_domain_nr(dev->bus), dev->bus->number, PCI_SLOT(dev->devfn),
+@@ -298,7 +299,12 @@ static struct cns3xxx_pcie cns3xxx_pcie[
+ 			.end = CNS3XXX_PCIE0_MEM_BASE + SZ_16M - 1,
+ 			.flags = IORESOURCE_MEM,
+ 		},
+-		.irqs = { IRQ_CNS3XXX_PCIE0_RC, IRQ_CNS3XXX_PCIE0_DEVICE, },
++		.irqs = { IRQ_CNS3XXX_PCIE0_RC,
++			  IRQ_CNS3XXX_PCIE0_DEVICE,
++			  IRQ_CNS3XXX_PCIE0_DEVICE,
++			  IRQ_CNS3XXX_PCIE0_DEVICE,
++			  IRQ_CNS3XXX_PCIE0_DEVICE,
++			},
+ 		.hw_pci = {
+ 			.domain = 0,
+ 			.nr_controllers = 1,
+@@ -340,7 +346,13 @@ static struct cns3xxx_pcie cns3xxx_pcie[
+ 			.end = CNS3XXX_PCIE1_MEM_BASE + SZ_16M - 1,
+ 			.flags = IORESOURCE_MEM,
+ 		},
+-		.irqs = { IRQ_CNS3XXX_PCIE1_RC, IRQ_CNS3XXX_PCIE1_DEVICE, },
++		.irqs = {
++			IRQ_CNS3XXX_PCIE1_RC,
++			IRQ_CNS3XXX_PCIE1_DEVICE,
++			IRQ_CNS3XXX_PCIE1_DEVICE,
++			IRQ_CNS3XXX_PCIE1_DEVICE,
++			IRQ_CNS3XXX_PCIE1_DEVICE,
++		},
+ 		.hw_pci = {
+ 			.domain = 1,
+ 			.nr_controllers = 1,
+@@ -460,13 +472,22 @@ void __init cns3xxx_pcie_iotable_init()
+ 	}
+ }
+ 
+-int __init cns3xxx_pcie_init(void)
++int __init cns3xxx_pcie_init(int *pcie0_irqs, int *pcie1_irqs)
+ {
+ 	int i;
+ 
+ 	pcibios_min_io = 0;
+ 	pcibios_min_mem = 0;
+ 
++	if (pcie0_irqs) {
++		for (i = 0; i < 4; i++)
++			cns3xxx_pcie[0].irqs[i+1] = pcie0_irqs[i];
++	}
++	if (pcie1_irqs) {
++		for (i = 0; i < 4; i++)
++			cns3xxx_pcie[1].irqs[i+1] = pcie1_irqs[i];
++	}
++
+ 	hook_fault_code(16 + 6, cns3xxx_pcie_abort_handler, SIGBUS, 0,
+ 			"imprecise external abort");
+ 
Index: trunk/target/linux/cns3xxx/patches-3.10/420-ventana-gsc-core.patch
===================================================================
--- trunk/target/linux/cns3xxx/patches-3.10/420-ventana-gsc-core.patch	(revision 0)
+++ trunk/target/linux/cns3xxx/patches-3.10/420-ventana-gsc-core.patch	(working copy)
@@ -0,0 +1,34 @@
+--- a/drivers/mfd/Kconfig
++++ b/drivers/mfd/Kconfig
+@@ -169,6 +169,20 @@ config MFD_MC13XXX_I2C
+ 	help
+ 	  Select this if your MC13xxx is connected via an I2C bus.
+ 
++config GSC_CORE
++	tristate "Gateworks System Controller Support"
++	depends on I2C
++	select MFD_CORE
++	select GENERIC_IRQ_CHIP
++	select IRQ_DOMAIN
++	help
++	  Say yes here for support of Gateworks System Controller. This is a
++	  system management IC. This driver provides support for accessing
++	  various features of the device.
++
++	  This driver can be built as a module. If built as a module it will
++	  be called "gsc"
++
+ config HTC_EGPIO
+ 	bool "HTC EGPIO support"
+ 	depends on GENERIC_HARDIRQS && GPIOLIB && ARM
+--- a/drivers/mfd/Makefile
++++ b/drivers/mfd/Makefile
+@@ -15,6 +15,8 @@ obj-$(CONFIG_MFD_CROS_EC_SPI)	+= cros_ec
+ rtsx_pci-objs			:= rtsx_pcr.o rts5209.o rts5229.o rtl8411.o rts5227.o rts5249.o
+ obj-$(CONFIG_MFD_RTSX_PCI)	+= rtsx_pci.o
+ 
++gsc-objs			:= gsc-core.o gsc-irq.o
++obj-$(CONFIG_GSC_CORE)		+= gsc.o
+ obj-$(CONFIG_HTC_EGPIO)		+= htc-egpio.o
+ obj-$(CONFIG_HTC_PASIC3)	+= htc-pasic3.o
+ obj-$(CONFIG_HTC_I2CPLD)	+= htc-i2cpld.o
Index: trunk/target/linux/cns3xxx/patches-3.10/421-ventana-gsc-watchdog.patch
===================================================================
--- trunk/target/linux/cns3xxx/patches-3.10/421-ventana-gsc-watchdog.patch	(revision 0)
+++ trunk/target/linux/cns3xxx/patches-3.10/421-ventana-gsc-watchdog.patch	(working copy)
@@ -0,0 +1,27 @@
+--- a/drivers/watchdog/Kconfig
++++ b/drivers/watchdog/Kconfig
+@@ -310,6 +310,14 @@ config COH901327_WATCHDOG
+ 	  This watchdog is used to reset the system and thus cannot be
+ 	  compiled as a module.
+ 
++config GSC_WATCHDOG
++	tristate "Gateworks System Controller Watchdog"
++	depends on GSC_CORE
++	select WATCHDOG_CORE
++	help
++	  Support for Gateworks System Controller watchdog.
++	  Say 'Y' here to enable the watchdog timer support for GSC chips.
++
+ config TWL4030_WATCHDOG
+ 	tristate "TWL4030 Watchdog"
+ 	depends on TWL4030_CORE
+--- a/drivers/watchdog/Makefile
++++ b/drivers/watchdog/Makefile
+@@ -33,6 +33,7 @@ obj-$(CONFIG_ARM_SP805_WATCHDOG) += sp80
+ obj-$(CONFIG_AT91RM9200_WATCHDOG) += at91rm9200_wdt.o
+ obj-$(CONFIG_AT91SAM9X_WATCHDOG) += at91sam9_wdt.o
+ obj-$(CONFIG_OMAP_WATCHDOG) += omap_wdt.o
++obj-$(CONFIG_GSC_WATCHDOG) += gsc_wdt.o
+ obj-$(CONFIG_TWL4030_WATCHDOG) += twl4030_wdt.o
+ obj-$(CONFIG_21285_WATCHDOG) += wdt285.o
+ obj-$(CONFIG_977_WATCHDOG) += wdt977.o
Index: trunk/target/linux/cns3xxx/patches-3.10/422-ventana-gsc-input.patch
===================================================================
--- trunk/target/linux/cns3xxx/patches-3.10/422-ventana-gsc-input.patch	(revision 0)
+++ trunk/target/linux/cns3xxx/patches-3.10/422-ventana-gsc-input.patch	(working copy)
@@ -0,0 +1,30 @@
+--- a/drivers/input/misc/Kconfig
++++ b/drivers/input/misc/Kconfig
+@@ -93,6 +93,17 @@ config INPUT_BMA150
+ 	  To compile this driver as a module, choose M here: the
+ 	  module will be called bma150.
+ 
++config INPUT_GSC
++	tristate "Gateworks System Controller Input support"
++	depends on GSC_CORE
++	help
++	Support for Gateworks System Controller input device.
++	  Say Y here if you want to enable Linux input device support for
++	  GSC user-pushbutton, and tamper events.
++
++	  To compile this driver as a module, choose M here. The module will
++	  be called gsc_input.
++
+ config INPUT_PCSPKR
+ 	tristate "PC Speaker support"
+ 	depends on PCSPKR_PLATFORM
+--- a/drivers/input/misc/Makefile
++++ b/drivers/input/misc/Makefile
+@@ -42,6 +42,7 @@ obj-$(CONFIG_INPUT_MPU3050)		+= mpu3050.
+ obj-$(CONFIG_INPUT_PCAP)		+= pcap_keys.o
+ obj-$(CONFIG_INPUT_PCF50633_PMU)	+= pcf50633-input.o
+ obj-$(CONFIG_INPUT_PCF8574)		+= pcf8574_keypad.o
++obj-$(CONFIG_INPUT_GSC)			+= gsc-input.o
+ obj-$(CONFIG_INPUT_PCSPKR)		+= pcspkr.o
+ obj-$(CONFIG_INPUT_PM8XXX_VIBRATOR)	+= pm8xxx-vibrator.o
+ obj-$(CONFIG_INPUT_PMIC8XXX_PWRKEY)	+= pmic8xxx-pwrkey.o
Index: trunk/target/linux/cns3xxx/patches-3.10/423-ventana-enable-gsc-drivers.patch
===================================================================
--- trunk/target/linux/cns3xxx/patches-3.10/423-ventana-enable-gsc-drivers.patch	(revision 0)
+++ trunk/target/linux/cns3xxx/patches-3.10/423-ventana-enable-gsc-drivers.patch	(working copy)
@@ -0,0 +1,462 @@
+--- a/arch/arm/mach-cns3xxx/laguna.c
++++ b/arch/arm/mach-cns3xxx/laguna.c
+@@ -20,9 +20,11 @@
+ #include <linux/init.h>
+ #include <linux/kernel.h>
+ #include <linux/compiler.h>
++#include <linux/input.h>
+ #include <linux/io.h>
+ #include <linux/irq.h>
+ #include <linux/gpio.h>
++#include <linux/gpio_keys.h>
+ #include <linux/dma-mapping.h>
+ #include <linux/serial_core.h>
+ #include <linux/serial_8250.h>
+@@ -607,7 +609,7 @@ static struct at24_platform_data laguna_
+ 
+ static struct pca953x_platform_data laguna_pca_data = {
+  	.gpio_base = 100,
+-	.irq_base = -1,
++	.irq_base = 168,
+ };
+ 
+ static struct pca953x_platform_data laguna_pca2_data = {
+@@ -615,14 +617,24 @@ static struct pca953x_platform_data lagu
+ 	.irq_base = -1,
+ };
+ 
++static struct i2c_board_info gscgpio_i2cinfo = {
++	I2C_BOARD_INFO("pca9555", 0x23),
++	.platform_data = &laguna_pca_data,
++	.irq = 164, /* GSC irq4 */
++};
++
++static struct i2c_board_info pca2_i2cinfo = {
++	I2C_BOARD_INFO("pca9555", 0x27),
++	.platform_data = &laguna_pca2_data,
++};
++
++static struct i2c_board_info gsc_i2cinfo = {
++	I2C_BOARD_INFO("gsc", 0x20),
++	.irq = -1, /* assigned at runtime */
++};
++
+ static struct i2c_board_info __initdata laguna_i2c_devices[] = {
+ 	{
+-		I2C_BOARD_INFO("pca9555", 0x23),
+-		.platform_data = &laguna_pca_data,
+-	},{
+-		I2C_BOARD_INFO("pca9555", 0x27),
+-		.platform_data = &laguna_pca2_data,
+-	},{
+ 		I2C_BOARD_INFO("gsp", 0x29),
+ 	},{
+ 		I2C_BOARD_INFO ("24c08",0x50),
+@@ -636,6 +648,11 @@ static struct i2c_board_info __initdata
+  * Watchdog
+  */
+ 
++static struct platform_device laguna_gsc_watchdog = {
++	.name		= "gsc_wdt",
++	.id		= 0,
++};
++
+ static struct resource laguna_watchdog_resources[] = {
+ 	[0] = {
+ 		.start	= CNS3XXX_TC11MP_TWD_BASE + 0x100, // CPU0 watchdog
+@@ -652,6 +669,14 @@ static struct platform_device laguna_wat
+ };
+ 
+ /*
++ * GSC Input device
++ */
++static struct platform_device laguna_gsc_input = {
++	.name		= "gsc_input",
++	.id		= -1,
++};
++
++/*
+  * GPS PPS
+  */
+ static struct pps_gpio_platform_data laguna_pps_data = {
+@@ -673,14 +698,12 @@ static struct platform_device laguna_pps
+ 
+ static struct gpio laguna_gpio_gw2391[] = {
+ 	{   0, GPIOF_IN           , "*GPS_PPS" },
+-	{   1, GPIOF_IN           , "*GSC_IRQ#" },
+ 	{   2, GPIOF_IN           , "*USB_FAULT#" },
+ 	{   5, GPIOF_OUT_INIT_LOW , "*USB0_PCI_SEL" },
+ 	{   6, GPIOF_OUT_INIT_HIGH, "*USB_VBUS_EN" },
+ 	{   7, GPIOF_OUT_INIT_LOW , "*USB1_PCI_SEL" },
+ 	{   8, GPIOF_OUT_INIT_HIGH, "*PERST#" },
+ 	{   9, GPIOF_OUT_INIT_LOW , "*FP_SER_EN#" },
+-	{ 100, GPIOF_IN           , "*USER_PB#" },
+ 	{ 103, GPIOF_OUT_INIT_HIGH, "*V5_EN" },
+ 	{ 108, GPIOF_IN           , "DIO0" },
+ 	{ 109, GPIOF_IN           , "DIO1" },
+@@ -691,13 +714,11 @@ static struct gpio laguna_gpio_gw2391[]
+ 
+ static struct gpio laguna_gpio_gw2388[] = {
+ 	{   0, GPIOF_IN           , "*GPS_PPS" },
+-	{   1, GPIOF_IN           , "*GSC_IRQ#" },
+ 	{   3, GPIOF_IN           , "*USB_FAULT#" },
+ 	{   6, GPIOF_OUT_INIT_HIGH, "*USB_VBUS_EN" },
+ 	{   7, GPIOF_OUT_INIT_LOW , "*GSM_SEL0" },
+ 	{   8, GPIOF_OUT_INIT_LOW , "*GSM_SEL1" },
+ 	{   9, GPIOF_OUT_INIT_LOW , "*FP_SER_EN" },
+-	{ 100, GPIOF_OUT_INIT_HIGH, "*USER_PB#" },
+ 	{ 108, GPIOF_IN           , "DIO0" },
+ 	{ 109, GPIOF_IN           , "DIO1" },
+ 	{ 110, GPIOF_IN           , "DIO2" },
+@@ -707,14 +728,12 @@ static struct gpio laguna_gpio_gw2388[]
+ 
+ static struct gpio laguna_gpio_gw2387[] = {
+ 	{   0, GPIOF_IN           , "*GPS_PPS" },
+-	{   1, GPIOF_IN           , "*GSC_IRQ#" },
+ 	{   2, GPIOF_IN           , "*USB_FAULT#" },
+ 	{   5, GPIOF_OUT_INIT_LOW , "*USB_PCI_SEL" },
+ 	{   6, GPIOF_OUT_INIT_HIGH, "*USB_VBUS_EN" },
+ 	{   7, GPIOF_OUT_INIT_LOW , "*GSM_SEL0" },
+ 	{   8, GPIOF_OUT_INIT_LOW , "*GSM_SEL1" },
+ 	{   9, GPIOF_OUT_INIT_LOW , "*FP_SER_EN" },
+-	{ 100, GPIOF_IN           , "*USER_PB#" },
+ 	{ 103, GPIOF_OUT_INIT_HIGH, "*V5_EN" },
+ 	{ 108, GPIOF_IN           , "DIO0" },
+ 	{ 109, GPIOF_IN           , "DIO1" },
+@@ -724,8 +743,22 @@ static struct gpio laguna_gpio_gw2387[]
+ 	{ 113, GPIOF_IN           , "DIO5" },
+ };
+ 
++static struct gpio laguna_gpio_gw2386[] = {
++	{   0, GPIOF_IN           , "*GPS_PPS" },
++	{   2, GPIOF_IN           , "*USB_FAULT#" },
++	{   6, GPIOF_OUT_INIT_LOW , "*USB_PCI_SEL" },
++	{   7, GPIOF_OUT_INIT_LOW , "*GSM_SEL0" },
++	{   8, GPIOF_OUT_INIT_LOW , "*GSM_SEL1" },
++	{   9, GPIOF_OUT_INIT_LOW , "*FP_SER_EN" },
++	{ 108, GPIOF_IN           , "DIO0" },
++	{ 109, GPIOF_IN           , "DIO1" },
++	{ 110, GPIOF_IN           , "DIO2" },
++	{ 111, GPIOF_IN           , "DIO3" },
++	{ 112, GPIOF_IN           , "DIO4" },
++	{ 113, GPIOF_IN           , "DIO5" },
++};
++
+ static struct gpio laguna_gpio_gw2385[] = {
+-	{   0, GPIOF_IN           , "*GSC_IRQ#" },
+ 	{   1, GPIOF_OUT_INIT_HIGH, "*USB_HST_VBUS_EN" },
+ 	{   2, GPIOF_IN           , "*USB_HST_FAULT#" },
+ 	{   5, GPIOF_IN           , "*USB_OTG_FAULT#" },
+@@ -735,12 +768,10 @@ static struct gpio laguna_gpio_gw2385[]
+ 	{   9, GPIOF_OUT_INIT_LOW , "*SER_EN" },
+ 	{  10, GPIOF_IN,            "*USER_PB#" },
+ 	{  11, GPIOF_OUT_INIT_HIGH, "*PERST#" },
+-	{ 100, GPIOF_IN           , "*USER_PB#" },
+ 	{ 103, GPIOF_OUT_INIT_HIGH, "V5_EN" },
+ };
+ 
+ static struct gpio laguna_gpio_gw2384[] = {
+-	{   0, GPIOF_IN           , "*GSC_IRQ#" },
+ 	{   1, GPIOF_OUT_INIT_HIGH, "*USB_HST_VBUS_EN" },
+ 	{   2, GPIOF_IN           , "*USB_HST_FAULT#" },
+ 	{   5, GPIOF_IN           , "*USB_OTG_FAULT#" },
+@@ -752,25 +783,21 @@ static struct gpio laguna_gpio_gw2384[]
+ 	{  13, GPIOF_OUT_INIT_HIGH, "*I2CMUX_RST#" },
+ 	{  14, GPIOF_OUT_INIT_LOW , "J10_DIOLED1" },
+ 	{  15, GPIOF_OUT_INIT_LOW , "J10_DIOLED2" },
+-	{ 100, GPIOF_IN           , "*USER_PB#" },
+ 	{ 103, GPIOF_OUT_INIT_HIGH, "V5_EN" },
+ 	{ 108, GPIOF_IN           , "J9_DIOGSC0" },
+ };
+ 
+ static struct gpio laguna_gpio_gw2383[] = {
+ 	{   0, GPIOF_IN           , "*GPS_PPS" },
+-	{   1, GPIOF_IN           , "*GSC_IRQ#" },
+ 	{   2, GPIOF_OUT_INIT_HIGH, "*PCIE_RST#" },
+ 	{   3, GPIOF_IN           , "GPIO0" },
+ 	{   8, GPIOF_IN           , "GPIO1" },
+ 	{ 100, GPIOF_IN           , "DIO0" },
+ 	{ 101, GPIOF_IN           , "DIO1" },
+-	{ 108, GPIOF_IN           , "*USER_PB#" },
+ };
+ 
+ static struct gpio laguna_gpio_gw2382[] = {
+ 	{   0, GPIOF_IN           , "*GPS_PPS" },
+-	{   1, GPIOF_IN           , "*GSC_IRQ#" },
+ 	{   2, GPIOF_OUT_INIT_HIGH, "*PCIE_RST#" },
+ 	{   3, GPIOF_IN           , "GPIO0" },
+ 	{   4, GPIOF_IN           , "GPIO1" },
+@@ -778,19 +805,45 @@ static struct gpio laguna_gpio_gw2382[]
+ 	{  10, GPIOF_OUT_INIT_HIGH, "*USB_PCI_SEL#" },
+ 	{ 100, GPIOF_IN           , "DIO0" },
+ 	{ 101, GPIOF_IN           , "DIO1" },
+-	{ 108, GPIOF_IN           , "*USER_PB#" },
+ };
+ 
+ static struct gpio laguna_gpio_gw2380[] = {
+ 	{   0, GPIOF_IN           , "*GPS_PPS" },
+-	{   1, GPIOF_IN           , "*GSC_IRQ#" },
+ 	{   3, GPIOF_IN           , "GPIO0" },
+ 	{   8, GPIOF_IN           , "GPIO1" },
+ 	{ 100, GPIOF_IN           , "DIO0" },
+ 	{ 101, GPIOF_IN           , "DIO1" },
+ 	{ 102, GPIOF_IN           , "DIO2" },
+ 	{ 103, GPIOF_IN           , "DIO3" },
+-	{ 108, GPIOF_IN           , "*USER_PB#" },
++};
++
++/*
++ * GPIO based buttons
++ */
++static struct gpio_keys_button laguna_keys[] = {
++	{
++                .type                   = EV_KEY,
++                .active_low             = 1,
++                .wakeup                 = 0,
++                .debounce_interval      = 100,
++                .desc                   = "USER_PB#",
++                .code                   = BTN_0,
++                .gpio                   = -1, /* assigned at runtime */
++	},
++};
++
++static struct gpio_keys_platform_data laguna_keys_pdata = {
++        .buttons = laguna_keys,
++        .nbuttons = ARRAY_SIZE(laguna_keys),
++        .poll_interval = 100,
++};
++
++static struct platform_device laguna_keys_device = {
++        .name = "gpio-keys-polled",
++        .id = 0,
++        .dev = {
++                .platform_data = &laguna_keys_pdata
++        },
+ };
+ 
+ /*
+@@ -806,10 +859,14 @@ static void __init laguna_init(void)
+ 				      cns3xxx_cpu_clock() * (1000000 / 8));
+ 	clk_register_clkdev(clk, "cpu", NULL);
+ 
+-	platform_device_register(&laguna_watchdog);
+-
+ 	platform_device_register(&laguna_i2c_controller);
+ 
++	/* GPIO controllers */
++	cns3xxx_gpio_init(0, 32, CNS3XXX_GPIOA_BASE_VIRT, IRQ_CNS3XXX_GPIOA,
++			  NR_IRQS_CNS3XXX);
++	cns3xxx_gpio_init(32, 32, CNS3XXX_GPIOB_BASE_VIRT, IRQ_CNS3XXX_GPIOB,
++			  NR_IRQS_CNS3XXX + 32);
++
+ 	/* Set I2C 0-3 drive strength to 21 mA */
+ 	reg = MISC_IO_PAD_DRIVE_STRENGTH_CTRL_B;
+ 	*reg |= 0x300;
+@@ -928,8 +985,6 @@ static int __init laguna_model_setup(voi
+ 		return 0;
+ 
+ 	printk("Running on Gateworks Laguna %s\n", laguna_info.model);
+-	cns3xxx_gpio_init( 0, 32, CNS3XXX_GPIOA_BASE_VIRT, IRQ_CNS3XXX_GPIOA,
+-		NR_IRQS_CNS3XXX);
+ 
+ 	if (cns3xxx_pciextirq) {
+ 		/*
+@@ -943,16 +998,10 @@ static int __init laguna_model_setup(voi
+ 		reg |= 0x38000000;
+ 		__raw_writel(reg, mem);
+ 
+-		cns3xxx_gpio_init(32, 32, CNS3XXX_GPIOB_BASE_VIRT,
+-				  IRQ_CNS3XXX_GPIOB, NR_IRQS_CNS3XXX + 32);
+-
+ 		irq_set_irq_type(154, IRQ_TYPE_LEVEL_LOW);
+ 		irq_set_irq_type(93, IRQ_TYPE_LEVEL_HIGH);
+ 		irq_set_irq_type(94, IRQ_TYPE_LEVEL_HIGH);
+ 		irq_set_irq_type(95, IRQ_TYPE_LEVEL_HIGH);
+-	} else {
+-		cns3xxx_gpio_init(32, 32, CNS3XXX_GPIOB_BASE_VIRT,
+-				  IRQ_CNS3XXX_GPIOB, NR_IRQS_CNS3XXX + 32);
+ 	}
+ 
+ 	if (strncmp(laguna_info.model, "GW", 2) == 0) {
+@@ -1065,19 +1114,56 @@ static int __init laguna_model_setup(voi
+ 		if ( (strncmp(laguna_info.model, "GW2388", 6) == 0)
+ 		  || (strncmp(laguna_info.model, "GW2389", 6) == 0) )
+ 		{
+-			// configure GPIO's
++			// GSC
++			laguna_keys[0].gpio = 100;
++			gsc_i2cinfo.irq = 97;
++			i2c_new_device(i2c_get_adapter(0), &gsc_i2cinfo);
++			// GPIO's
+ 			laguna_register_gpio(ARRAY_AND_SIZE(laguna_gpio_gw2388));
+-			// configure LED's
++			// LED's
+ 			laguna_gpio_leds_data.num_leds = 2;
++
++			i2c_new_device(i2c_get_adapter(0), &gscgpio_i2cinfo);
++			platform_device_register(&laguna_gpio_leds_device);
++			platform_device_register(&laguna_gsc_input);
++			platform_device_register(&laguna_keys_device);
+ 		} else if (strncmp(laguna_info.model, "GW2387", 6) == 0) {
+-			// configure GPIO's
++			// GSC
++			laguna_keys[0].gpio = 100;
++			gsc_i2cinfo.irq = 97;
++			i2c_new_device(i2c_get_adapter(0), &gsc_i2cinfo);
++			// GPIO's
+ 			laguna_register_gpio(ARRAY_AND_SIZE(laguna_gpio_gw2387));
+-			// configure LED's
++			// LED's
++			laguna_gpio_leds_data.num_leds = 2;
++
++			i2c_new_device(i2c_get_adapter(0), &gscgpio_i2cinfo);
++			platform_device_register(&laguna_gpio_leds_device);
++			platform_device_register(&laguna_gsc_input);
++			platform_device_register(&laguna_keys_device);
++		} else if (strncmp(laguna_info.model, "GW2386", 6) == 0) {
++			// GSC
++			laguna_keys[0].gpio = 100;
++			gsc_i2cinfo.irq = 97;
++			i2c_new_device(i2c_get_adapter(0), &gsc_i2cinfo);
++			// GPIO's
++			laguna_register_gpio(ARRAY_AND_SIZE(laguna_gpio_gw2386));
++			// LED's
+ 			laguna_gpio_leds_data.num_leds = 2;
++
++			i2c_new_device(i2c_get_adapter(0), &gscgpio_i2cinfo);
++			i2c_new_device(i2c_get_adapter(0), &pca2_i2cinfo);
++			platform_device_register(&laguna_gpio_leds_device);
++			platform_device_register(&laguna_gsc_input);
++			platform_device_register(&laguna_keys_device);
+ 		} else if (strncmp(laguna_info.model, "GW2385", 6) == 0) {
+-			// configure GPIO's
++			// GSC
++			laguna_keys[0].gpio = 100;
++			gsc_i2cinfo.irq = 96;
++			i2c_new_device(i2c_get_adapter(0), &gsc_i2cinfo);
++			// GPIO's
+ 			laguna_register_gpio(ARRAY_AND_SIZE(laguna_gpio_gw2385));
+-			// configure LED's
++			// LED's
+ 			laguna_gpio_leds[0].gpio = 115;
+ 			laguna_gpio_leds[1].gpio = 12;
+ 			laguna_gpio_leds[1].name = "red";
+@@ -1089,40 +1175,94 @@ static int __init laguna_model_setup(voi
+ 			laguna_gpio_leds[3].name = "blue";
+ 			laguna_gpio_leds[3].active_low = 0,
+ 			laguna_gpio_leds_data.num_leds = 4;
++
++			i2c_new_device(i2c_get_adapter(0), &gscgpio_i2cinfo);
++			platform_device_register(&laguna_gpio_leds_device);
++			platform_device_register(&laguna_gsc_input);
++			platform_device_register(&laguna_keys_device);
+ 		} else if (strncmp(laguna_info.model, "GW2384", 6) == 0) {
+-			// configure GPIO's
++			// GSC
++			laguna_keys[0].gpio = 100;
++			gsc_i2cinfo.irq = 96;
++			i2c_new_device(i2c_get_adapter(0), &gsc_i2cinfo);
++			// GPIO's
+ 			laguna_register_gpio(ARRAY_AND_SIZE(laguna_gpio_gw2384));
+-			// configure LED's
++			// LED's
+ 			laguna_gpio_leds_data.num_leds = 1;
++
++			i2c_new_device(i2c_get_adapter(0), &gscgpio_i2cinfo);
++			platform_device_register(&laguna_gpio_leds_device);
++			platform_device_register(&laguna_gsc_input);
++			platform_device_register(&laguna_keys_device);
+ 		} else if (strncmp(laguna_info.model, "GW2383", 6) == 0) {
+-			// configure GPIO's
++			// GSC
++			laguna_keys[0].gpio = 108;
++			gsc_i2cinfo.irq = 97;
++			i2c_new_device(i2c_get_adapter(0), &gsc_i2cinfo);
++			// GPIO's
+ 			laguna_register_gpio(ARRAY_AND_SIZE(laguna_gpio_gw2383));
+-			// configure LED's
++			// LED's
+ 			laguna_gpio_leds[0].gpio = 107;
+ 			laguna_gpio_leds_data.num_leds = 1;
++
++			i2c_new_device(i2c_get_adapter(0), &gscgpio_i2cinfo);
++			platform_device_register(&laguna_gpio_leds_device);
++			platform_device_register(&laguna_gsc_input);
++			platform_device_register(&laguna_keys_device);
+ 		} else if (strncmp(laguna_info.model, "GW2382", 6) == 0) {
+-			// configure GPIO's
++			// GSC
++			laguna_keys[0].gpio = 108;
++			gsc_i2cinfo.irq = 97;
++			i2c_new_device(i2c_get_adapter(0), &gsc_i2cinfo);
++			// GPIO's
+ 			laguna_register_gpio(ARRAY_AND_SIZE(laguna_gpio_gw2382));
+-			// configure LED's
++			// LED's
+ 			laguna_gpio_leds[0].gpio = 107;
+ 			laguna_gpio_leds_data.num_leds = 1;
++
++			i2c_new_device(i2c_get_adapter(0), &gscgpio_i2cinfo);
++			platform_device_register(&laguna_gpio_leds_device);
++			platform_device_register(&laguna_gsc_input);
++			platform_device_register(&laguna_keys_device);
+ 		} else if (strncmp(laguna_info.model, "GW2380", 6) == 0) {
+-			// configure GPIO's
++			// GSC
++			laguna_keys[0].gpio = 108;
++			gsc_i2cinfo.irq = 97;
++			i2c_new_device(i2c_get_adapter(0), &gsc_i2cinfo);
++			// GPIO's
+ 			laguna_register_gpio(ARRAY_AND_SIZE(laguna_gpio_gw2380));
+-			// configure LED's
++			// LED's
+ 			laguna_gpio_leds[0].gpio = 107;
+ 			laguna_gpio_leds[1].gpio = 106;
+ 			laguna_gpio_leds_data.num_leds = 2;
++
++			i2c_new_device(i2c_get_adapter(0), &gscgpio_i2cinfo);
++			platform_device_register(&laguna_gpio_leds_device);
++			platform_device_register(&laguna_gsc_input);
++			platform_device_register(&laguna_keys_device);
+ 		} else if ( (strncmp(laguna_info.model, "GW2391", 6) == 0)
+ 			 || (strncmp(laguna_info.model, "GW2393", 6) == 0) )
+ 		{
+-			// configure GPIO's
++			// GSC
++			laguna_keys[0].gpio = 100;
++			gsc_i2cinfo.irq = 97;
++			i2c_new_device(i2c_get_adapter(0), &gsc_i2cinfo);
++			// GPIO's
+ 			laguna_register_gpio(ARRAY_AND_SIZE(laguna_gpio_gw2391));
+-			// configure LED's
++			// LED's
+ 			laguna_gpio_leds_data.num_leds = 2;
++
++			platform_device_register(&laguna_gsc_input);
++			i2c_new_device(i2c_get_adapter(0), &gscgpio_i2cinfo);
++			platform_device_register(&laguna_gpio_leds_device);
++			platform_device_register(&laguna_keys_device);
+ 		}
+-		platform_device_register(&laguna_gpio_leds_device);
+ 	} else {
+ 		// Do some defaults here, not sure what yet
+ 	}
++
++	platform_device_register(&laguna_gsc_watchdog);
++
++	platform_device_register(&laguna_watchdog);
++
+ 	return 0;
+ }
+ late_initcall(laguna_model_setup);
+--- a/drivers/watchdog/mpcore_wdt.c
++++ b/drivers/watchdog/mpcore_wdt.c
+@@ -453,7 +453,7 @@ static void __exit mpcore_wdt_exit(void)
+ 	platform_driver_unregister(&mpcore_wdt_driver);
+ }
+ 
+-module_init(mpcore_wdt_init);
++late_initcall(mpcore_wdt_init);
+ module_exit(mpcore_wdt_exit);
+ 
+ MODULE_AUTHOR("ARM Limited");
