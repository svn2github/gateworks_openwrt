Index: trunk/target/linux/imx6/base-files/lib/upgrade/platform.sh
===================================================================
--- trunk/target/linux/imx6/base-files/lib/upgrade/platform.sh	(revision 42297)
+++ trunk/target/linux/imx6/base-files/lib/upgrade/platform.sh	(working copy)
@@ -8,7 +8,7 @@
 	local board=$(imx6_board_name)
 
 	case "$board" in
-	gw54xx)
+	gw5*)
 		nand_do_platform_check $board $1
 		return $?;
 		;;
Index: trunk/target/linux/imx6/config-3.14
===================================================================
--- trunk/target/linux/imx6/config-3.14	(revision 42297)
+++ trunk/target/linux/imx6/config-3.14	(working copy)
@@ -44,6 +44,7 @@
 CONFIG_ATAGS=y
 # CONFIG_ATA_SFF is not set
 CONFIG_AUTO_ZRELADDR=y
+CONFIG_BLK_DEV_SD=y
 # CONFIG_CACHE_L2X0 is not set
 CONFIG_CC_OPTIMIZE_FOR_SIZE=y
 CONFIG_CLKDEV_LOOKUP=y
@@ -311,6 +312,7 @@
 CONFIG_RFS_ACCEL=y
 CONFIG_RPS=y
 CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_DS1672=y
 # CONFIG_RTC_DRV_IMXDI is not set
 # CONFIG_RTC_DRV_MXC is not set
 CONFIG_SATA_AHCI_PLATFORM=y
@@ -346,8 +348,24 @@
 CONFIG_UBIFS_FS_ZLIB=y
 CONFIG_UID16=y
 CONFIG_UNCOMPRESS_INCLUDE="debug/uncompress.h"
-# CONFIG_USB_MXS_PHY is not set
+CONFIG_USB=y
+CONFIG_USB_CHIPIDEA=y
+# CONFIG_USB_CHIPIDEA_DEBUG is not set
+CONFIG_USB_CHIPIDEA_HOST=y
+CONFIG_USB_CHIPIDEA_UDC=y
+CONFIG_USB_COMMON=y
+CONFIG_USB_EHCI_HCD=y
+# CONFIG_USB_EHCI_HCD_PLATFORM is not set
+CONFIG_USB_EHCI_MXC=y
+CONFIG_USB_EHCI_PCI=y
+# CONFIG_USB_ETH is not set
+CONFIG_USB_GADGET=y
+# CONFIG_USB_IMX21_HCD is not set
+CONFIG_USB_MXS_PHY=y
+CONFIG_USB_PHY=y
+CONFIG_USB_STORAGE=y
 CONFIG_USB_SUPPORT=y
+# CONFIG_USB_UHCI_HCD is not set
 CONFIG_USE_OF=y
 CONFIG_VECTORS_BASE=0xffff0000
 CONFIG_VFP=y
Index: trunk/target/linux/imx6/files-3.14/drivers/net/phy/gw16083.c
===================================================================
--- trunk/target/linux/imx6/files-3.14/drivers/net/phy/gw16083.c	(revision 42297)
+++ trunk/target/linux/imx6/files-3.14/drivers/net/phy/gw16083.c	(working copy)
@@ -485,9 +485,13 @@
 					state->sfp_compat = false;
 				else
 					state->sfp_compat = true;
+				/* trigger a re-select/enable below */
+				state->serdes = !serdes;
+				pdev->state = PHY_RUNNING;
 			} else {
 				state->sfp_compat = false;
 				state->sfp_enabled = false;
+				pdev->state = PHY_NOLINK;
 			}
 		}
 		if (state->sfp_signal != sfp_signal) {
@@ -510,11 +514,8 @@
 			}
 		}
 
-		/*
-		 * if serdes and compatible SFP module and not yet enabled
-		 * then enable for serdes
-		 */
-		if (serdes && state->sfp_compat && state->sfp_signal &&
+		/* if compatible SFP module and not yet enabled then enable */
+		if (state->sfp_compat && state->sfp_signal &&
 		    !state->sfp_enabled)
 		{
 			if (!config_mv88e1111_port_sfp(pdev, port, 1))
Index: trunk/target/linux/imx6/patches-3.14/0009-ARM-imx-dts-add-GW52xx-can-support.patch
===================================================================
--- trunk/target/linux/imx6/patches-3.14/0009-ARM-imx-dts-add-GW52xx-can-support.patch	(revision 0)
+++ trunk/target/linux/imx6/patches-3.14/0009-ARM-imx-dts-add-GW52xx-can-support.patch	(working copy)
@@ -0,0 +1,45 @@
+--- a/arch/arm/boot/dts/imx6qdl-gw52xx.dtsi
++++ b/arch/arm/boot/dts/imx6qdl-gw52xx.dtsi
+@@ -12,6 +12,7 @@
+ / {
+ 	/* these are used by bootloader for disabling nodes */
+ 	aliases {
++		can0 = &can1;
+ 		ethernet0 = &fec;
+ 		led0 = &led0;
+ 		led1 = &led1;
+@@ -142,6 +143,12 @@
+ 	status = "okay";
+ };
+ 
++&can1 {
++	pinctrl-names = "default";
++	pinctrl-0 = <&pinctrl_flexcan1>;
++	status = "okay";
++};
++
+ &fec {
+ 	pinctrl-names = "default";
+ 	pinctrl-0 = <&pinctrl_enet>;
+@@ -325,6 +332,7 @@
+ 				MX6QDL_PAD_ENET_RXD1__GPIO1_IO26 0x80000000 /* GPS_PPS */
+ 				MX6QDL_PAD_GPIO_0__CCM_CLKO1     0x000130b0 /* AUD4_MCK */
+ 				MX6QDL_PAD_GPIO_2__GPIO1_IO02    0x80000000 /* USB_SEL_PCI */
++				MX6QDL_PAD_GPIO_9__GPIO1_IO09    0x80000000 /* CAN_STBY */
+ 				MX6QDL_PAD_GPIO_17__GPIO7_IO12   0x80000000 /* TOUCH_IRQ# */
+ 				MX6QDL_PAD_KEY_COL0__GPIO4_IO06  0x80000000 /* user1 led */
+ 				MX6QDL_PAD_KEY_ROW0__GPIO4_IO07  0x80000000 /* user2 led */
+@@ -365,6 +373,13 @@
+ 			>;
+ 		};
+ 
++		pinctrl_flexcan1: flexcan1grp {
++			fsl,pins = <
++				MX6QDL_PAD_KEY_ROW2__FLEXCAN1_RX	0x80000000
++				MX6QDL_PAD_KEY_COL2__FLEXCAN1_TX	0x80000000
++			>;
++		};
++
+ 		pinctrl_gpmi_nand: gpminandgrp {
+ 			fsl,pins = <
+ 				MX6QDL_PAD_NANDF_CLE__NAND_CLE		0xb0b1
Index: trunk/target/linux/imx6/patches-3.14/207-pci_designware_revert-pcie-map-irq-function.patch
===================================================================
--- trunk/target/linux/imx6/patches-3.14/207-pci_designware_revert-pcie-map-irq-function.patch	(revision 0)
+++ trunk/target/linux/imx6/patches-3.14/207-pci_designware_revert-pcie-map-irq-function.patch	(working copy)
@@ -0,0 +1,24 @@
+Index: linux-3.14.16/drivers/pci/host/pcie-designware.c
+===================================================================
+--- linux-3.14.16.orig/drivers/pci/host/pcie-designware.c	2014-10-23 15:59:17.978240312 -0700
++++ linux-3.14.16/drivers/pci/host/pcie-designware.c	2014-10-23 16:04:32.478231239 -0700
+@@ -744,9 +744,16 @@
+ 	struct pcie_port *pp = sys_to_pcie(dev->bus->sysdata);
+ 	int irq;
+ 
+-	irq = of_irq_parse_and_map_pci(dev, slot, pin);
+-	if (!irq)
+-		irq = pp->irq;
++	switch (pin) {
++	case 1: irq = pp->irq; break;
++	case 2: irq = pp->irq - 1; break;
++	case 3: irq = pp->irq - 2; break;
++	case 4: irq = pp->irq - 3; break;
++	default: irq = -1; break;
++	}
++
++	dev_info(&dev->dev, "map_irq: %04x:%04x slot%d pin%d irq%d\n",
++		 dev->vendor, dev->device, slot, pin, irq);
+ 
+ 	return irq;
+ }
